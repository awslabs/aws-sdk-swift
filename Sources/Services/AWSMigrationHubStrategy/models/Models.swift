// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The user does not have permission to perform the action. Check the AWS Identity and Access Management (IAM) policy associated with this user.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MigrationHubStrategyClientTypes.AnalysisStatusUnion: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case runtimeanalysisstatus = "runtimeAnalysisStatus"
        case sdkUnknown
        case srccodeordbanalysisstatus = "srcCodeOrDbAnalysisStatus"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .runtimeanalysisstatus(runtimeanalysisstatus):
                try container.encode(runtimeanalysisstatus.rawValue, forKey: .runtimeanalysisstatus)
            case let .srccodeordbanalysisstatus(srccodeordbanalysisstatus):
                try container.encode(srccodeordbanalysisstatus.rawValue, forKey: .srccodeordbanalysisstatus)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let runtimeanalysisstatusDecoded = try values.decodeIfPresent(MigrationHubStrategyClientTypes.RuntimeAnalysisStatus.self, forKey: .runtimeanalysisstatus)
        if let runtimeanalysisstatus = runtimeanalysisstatusDecoded {
            self = .runtimeanalysisstatus(runtimeanalysisstatus)
            return
        }
        let srccodeordbanalysisstatusDecoded = try values.decodeIfPresent(MigrationHubStrategyClientTypes.SrcCodeOrDbAnalysisStatus.self, forKey: .srccodeordbanalysisstatus)
        if let srccodeordbanalysisstatus = srccodeordbanalysisstatusDecoded {
            self = .srccodeordbanalysisstatus(srccodeordbanalysisstatus)
            return
        }
        self = .sdkUnknown("")
    }
}

extension MigrationHubStrategyClientTypes {
    /// A combination of existing analysis statuses.
    public enum AnalysisStatusUnion: Swift.Equatable {
        /// The status of the analysis.
        case runtimeanalysisstatus(MigrationHubStrategyClientTypes.RuntimeAnalysisStatus)
        /// The status of the source code or database analysis.
        case srccodeordbanalysisstatus(MigrationHubStrategyClientTypes.SrcCodeOrDbAnalysisStatus)
        case sdkUnknown(Swift.String)
    }

}

extension MigrationHubStrategyClientTypes {
    public enum AnalysisType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case binaryAnalysis
        case databaseAnalysis
        case runtimeAnalysis
        case sourceCodeAnalysis
        case sdkUnknown(Swift.String)

        public static var allCases: [AnalysisType] {
            return [
                .binaryAnalysis,
                .databaseAnalysis,
                .runtimeAnalysis,
                .sourceCodeAnalysis,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .binaryAnalysis: return "BINARY_ANALYSIS"
            case .databaseAnalysis: return "DATABASE_ANALYSIS"
            case .runtimeAnalysis: return "RUNTIME_ANALYSIS"
            case .sourceCodeAnalysis: return "SOURCE_CODE_ANALYSIS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AnalysisType(rawValue: rawValue) ?? AnalysisType.sdkUnknown(rawValue)
        }
    }
}

extension MigrationHubStrategyClientTypes.AnalyzerNameUnion: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case binaryanalyzername = "binaryAnalyzerName"
        case runtimeanalyzername = "runTimeAnalyzerName"
        case sdkUnknown
        case sourcecodeanalyzername = "sourceCodeAnalyzerName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .binaryanalyzername(binaryanalyzername):
                try container.encode(binaryanalyzername.rawValue, forKey: .binaryanalyzername)
            case let .runtimeanalyzername(runtimeanalyzername):
                try container.encode(runtimeanalyzername.rawValue, forKey: .runtimeanalyzername)
            case let .sourcecodeanalyzername(sourcecodeanalyzername):
                try container.encode(sourcecodeanalyzername.rawValue, forKey: .sourcecodeanalyzername)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let binaryanalyzernameDecoded = try values.decodeIfPresent(MigrationHubStrategyClientTypes.BinaryAnalyzerName.self, forKey: .binaryanalyzername)
        if let binaryanalyzername = binaryanalyzernameDecoded {
            self = .binaryanalyzername(binaryanalyzername)
            return
        }
        let runtimeanalyzernameDecoded = try values.decodeIfPresent(MigrationHubStrategyClientTypes.RunTimeAnalyzerName.self, forKey: .runtimeanalyzername)
        if let runtimeanalyzername = runtimeanalyzernameDecoded {
            self = .runtimeanalyzername(runtimeanalyzername)
            return
        }
        let sourcecodeanalyzernameDecoded = try values.decodeIfPresent(MigrationHubStrategyClientTypes.SourceCodeAnalyzerName.self, forKey: .sourcecodeanalyzername)
        if let sourcecodeanalyzername = sourcecodeanalyzernameDecoded {
            self = .sourcecodeanalyzername(sourcecodeanalyzername)
            return
        }
        self = .sdkUnknown("")
    }
}

extension MigrationHubStrategyClientTypes {
    /// The combination of the existing analyzers.
    public enum AnalyzerNameUnion: Swift.Equatable {
        /// The binary analyzer names.
        case binaryanalyzername(MigrationHubStrategyClientTypes.BinaryAnalyzerName)
        /// The assessment analyzer names.
        case runtimeanalyzername(MigrationHubStrategyClientTypes.RunTimeAnalyzerName)
        /// The source code analyzer names.
        case sourcecodeanalyzername(MigrationHubStrategyClientTypes.SourceCodeAnalyzerName)
        case sdkUnknown(Swift.String)
    }

}

extension MigrationHubStrategyClientTypes.AntipatternReportResult: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case analyzerName
        case antiPatternReportS3Object
        case antipatternReportStatus
        case antipatternReportStatusMessage
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let analyzerName = self.analyzerName {
            try encodeContainer.encode(analyzerName, forKey: .analyzerName)
        }
        if let antiPatternReportS3Object = self.antiPatternReportS3Object {
            try encodeContainer.encode(antiPatternReportS3Object, forKey: .antiPatternReportS3Object)
        }
        if let antipatternReportStatus = self.antipatternReportStatus {
            try encodeContainer.encode(antipatternReportStatus.rawValue, forKey: .antipatternReportStatus)
        }
        if let antipatternReportStatusMessage = self.antipatternReportStatusMessage {
            try encodeContainer.encode(antipatternReportStatusMessage, forKey: .antipatternReportStatusMessage)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let analyzerNameDecoded = try containerValues.decodeIfPresent(MigrationHubStrategyClientTypes.AnalyzerNameUnion.self, forKey: .analyzerName)
        analyzerName = analyzerNameDecoded
        let antiPatternReportS3ObjectDecoded = try containerValues.decodeIfPresent(MigrationHubStrategyClientTypes.S3Object.self, forKey: .antiPatternReportS3Object)
        antiPatternReportS3Object = antiPatternReportS3ObjectDecoded
        let antipatternReportStatusDecoded = try containerValues.decodeIfPresent(MigrationHubStrategyClientTypes.AntipatternReportStatus.self, forKey: .antipatternReportStatus)
        antipatternReportStatus = antipatternReportStatusDecoded
        let antipatternReportStatusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .antipatternReportStatusMessage)
        antipatternReportStatusMessage = antipatternReportStatusMessageDecoded
    }
}

extension MigrationHubStrategyClientTypes {
    /// The anti-pattern report result.
    public struct AntipatternReportResult: Swift.Equatable {
        /// The analyzer name.
        public var analyzerName: MigrationHubStrategyClientTypes.AnalyzerNameUnion?
        /// Contains the S3 bucket name and the Amazon S3 key name.
        public var antiPatternReportS3Object: MigrationHubStrategyClientTypes.S3Object?
        /// The status of the anti-pattern report generation.
        public var antipatternReportStatus: MigrationHubStrategyClientTypes.AntipatternReportStatus?
        /// The status message for the anti-pattern.
        public var antipatternReportStatusMessage: Swift.String?

        public init(
            analyzerName: MigrationHubStrategyClientTypes.AnalyzerNameUnion? = nil,
            antiPatternReportS3Object: MigrationHubStrategyClientTypes.S3Object? = nil,
            antipatternReportStatus: MigrationHubStrategyClientTypes.AntipatternReportStatus? = nil,
            antipatternReportStatusMessage: Swift.String? = nil
        )
        {
            self.analyzerName = analyzerName
            self.antiPatternReportS3Object = antiPatternReportS3Object
            self.antipatternReportStatus = antipatternReportStatus
            self.antipatternReportStatusMessage = antipatternReportStatusMessage
        }
    }

}

extension MigrationHubStrategyClientTypes {
    public enum AntipatternReportStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failed
        case inProgress
        case success
        case sdkUnknown(Swift.String)

        public static var allCases: [AntipatternReportStatus] {
            return [
                .failed,
                .inProgress,
                .success,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .success: return "SUCCESS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AntipatternReportStatus(rawValue: rawValue) ?? AntipatternReportStatus.sdkUnknown(rawValue)
        }
    }
}

extension MigrationHubStrategyClientTypes.AntipatternSeveritySummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case count
        case severity
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let count = self.count {
            try encodeContainer.encode(count, forKey: .count)
        }
        if let severity = self.severity {
            try encodeContainer.encode(severity.rawValue, forKey: .severity)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let severityDecoded = try containerValues.decodeIfPresent(MigrationHubStrategyClientTypes.Severity.self, forKey: .severity)
        severity = severityDecoded
        let countDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .count)
        count = countDecoded
    }
}

extension MigrationHubStrategyClientTypes {
    /// Contains the summary of anti-patterns and their severity.
    public struct AntipatternSeveritySummary: Swift.Equatable {
        /// Contains the count of anti-patterns.
        public var count: Swift.Int?
        /// Contains the severity of anti-patterns.
        public var severity: MigrationHubStrategyClientTypes.Severity?

        public init(
            count: Swift.Int? = nil,
            severity: MigrationHubStrategyClientTypes.Severity? = nil
        )
        {
            self.count = count
            self.severity = severity
        }
    }

}

extension MigrationHubStrategyClientTypes {
    public enum AppType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case iis
        case cassandra
        case db2
        case dotnetframework
        case dotnet
        case dotnetcore
        case java
        case jboss
        case mariadb
        case mongodb
        case mysql
        case oracle
        case other
        case postgresqlserver
        case spring
        case sqlserver
        case sybase
        case tomcat
        case unknown
        case visualbasic
        case weblogic
        case websphere
        case sdkUnknown(Swift.String)

        public static var allCases: [AppType] {
            return [
                .iis,
                .cassandra,
                .db2,
                .dotnetframework,
                .dotnet,
                .dotnetcore,
                .java,
                .jboss,
                .mariadb,
                .mongodb,
                .mysql,
                .oracle,
                .other,
                .postgresqlserver,
                .spring,
                .sqlserver,
                .sybase,
                .tomcat,
                .unknown,
                .visualbasic,
                .weblogic,
                .websphere,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .iis: return "IIS"
            case .cassandra: return "Cassandra"
            case .db2: return "DB2"
            case .dotnetframework: return "DotNetFramework"
            case .dotnet: return "Dotnet"
            case .dotnetcore: return "DotnetCore"
            case .java: return "Java"
            case .jboss: return "JBoss"
            case .mariadb: return "Maria DB"
            case .mongodb: return "Mongo DB"
            case .mysql: return "MySQL"
            case .oracle: return "Oracle"
            case .other: return "Other"
            case .postgresqlserver: return "PostgreSQLServer"
            case .spring: return "Spring"
            case .sqlserver: return "SQLServer"
            case .sybase: return "Sybase"
            case .tomcat: return "Tomcat"
            case .unknown: return "Unknown"
            case .visualbasic: return "Visual Basic"
            case .weblogic: return "Oracle WebLogic"
            case .websphere: return "IBM WebSphere"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AppType(rawValue: rawValue) ?? AppType.sdkUnknown(rawValue)
        }
    }
}

extension MigrationHubStrategyClientTypes.AppUnitError: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appUnitErrorCategory
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appUnitErrorCategory = self.appUnitErrorCategory {
            try encodeContainer.encode(appUnitErrorCategory.rawValue, forKey: .appUnitErrorCategory)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appUnitErrorCategoryDecoded = try containerValues.decodeIfPresent(MigrationHubStrategyClientTypes.AppUnitErrorCategory.self, forKey: .appUnitErrorCategory)
        appUnitErrorCategory = appUnitErrorCategoryDecoded
    }
}

extension MigrationHubStrategyClientTypes {
    /// Error in the analysis of the application unit.
    public struct AppUnitError: Swift.Equatable {
        /// The category of the error.
        public var appUnitErrorCategory: MigrationHubStrategyClientTypes.AppUnitErrorCategory?

        public init(
            appUnitErrorCategory: MigrationHubStrategyClientTypes.AppUnitErrorCategory? = nil
        )
        {
            self.appUnitErrorCategory = appUnitErrorCategory
        }
    }

}

extension MigrationHubStrategyClientTypes {
    public enum AppUnitErrorCategory: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case connectivityError
        case credentialError
        case otherError
        case permissionError
        case unsupportedError
        case sdkUnknown(Swift.String)

        public static var allCases: [AppUnitErrorCategory] {
            return [
                .connectivityError,
                .credentialError,
                .otherError,
                .permissionError,
                .unsupportedError,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .connectivityError: return "CONNECTIVITY_ERROR"
            case .credentialError: return "CREDENTIAL_ERROR"
            case .otherError: return "OTHER_ERROR"
            case .permissionError: return "PERMISSION_ERROR"
            case .unsupportedError: return "UNSUPPORTED_ERROR"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AppUnitErrorCategory(rawValue: rawValue) ?? AppUnitErrorCategory.sdkUnknown(rawValue)
        }
    }
}

extension MigrationHubStrategyClientTypes {
    public enum ApplicationComponentCriteria: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case analysisStatus
        case appName
        case appType
        case destination
        case errorCategory
        case notDefined
        case serverId
        case strategy
        case sdkUnknown(Swift.String)

        public static var allCases: [ApplicationComponentCriteria] {
            return [
                .analysisStatus,
                .appName,
                .appType,
                .destination,
                .errorCategory,
                .notDefined,
                .serverId,
                .strategy,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .analysisStatus: return "ANALYSIS_STATUS"
            case .appName: return "APP_NAME"
            case .appType: return "APP_TYPE"
            case .destination: return "DESTINATION"
            case .errorCategory: return "ERROR_CATEGORY"
            case .notDefined: return "NOT_DEFINED"
            case .serverId: return "SERVER_ID"
            case .strategy: return "STRATEGY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ApplicationComponentCriteria(rawValue: rawValue) ?? ApplicationComponentCriteria.sdkUnknown(rawValue)
        }
    }
}

extension MigrationHubStrategyClientTypes.ApplicationComponentDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case analysisStatus
        case antipatternReportS3Object
        case antipatternReportStatus
        case antipatternReportStatusMessage
        case appType
        case appUnitError
        case associatedServerId
        case databaseConfigDetail
        case id
        case inclusionStatus
        case lastAnalyzedTimestamp
        case listAntipatternSeveritySummary
        case moreServerAssociationExists
        case name
        case osDriver
        case osVersion
        case recommendationSet
        case resourceSubType
        case resultList
        case runtimeStatus
        case runtimeStatusMessage
        case sourceCodeRepositories
        case statusMessage
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let analysisStatus = self.analysisStatus {
            try encodeContainer.encode(analysisStatus.rawValue, forKey: .analysisStatus)
        }
        if let antipatternReportS3Object = self.antipatternReportS3Object {
            try encodeContainer.encode(antipatternReportS3Object, forKey: .antipatternReportS3Object)
        }
        if let antipatternReportStatus = self.antipatternReportStatus {
            try encodeContainer.encode(antipatternReportStatus.rawValue, forKey: .antipatternReportStatus)
        }
        if let antipatternReportStatusMessage = self.antipatternReportStatusMessage {
            try encodeContainer.encode(antipatternReportStatusMessage, forKey: .antipatternReportStatusMessage)
        }
        if let appType = self.appType {
            try encodeContainer.encode(appType.rawValue, forKey: .appType)
        }
        if let appUnitError = self.appUnitError {
            try encodeContainer.encode(appUnitError, forKey: .appUnitError)
        }
        if let associatedServerId = self.associatedServerId {
            try encodeContainer.encode(associatedServerId, forKey: .associatedServerId)
        }
        if let databaseConfigDetail = self.databaseConfigDetail {
            try encodeContainer.encode(databaseConfigDetail, forKey: .databaseConfigDetail)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let inclusionStatus = self.inclusionStatus {
            try encodeContainer.encode(inclusionStatus.rawValue, forKey: .inclusionStatus)
        }
        if let lastAnalyzedTimestamp = self.lastAnalyzedTimestamp {
            try encodeContainer.encodeTimestamp(lastAnalyzedTimestamp, format: .epochSeconds, forKey: .lastAnalyzedTimestamp)
        }
        if let listAntipatternSeveritySummary = listAntipatternSeveritySummary {
            var listAntipatternSeveritySummaryContainer = encodeContainer.nestedUnkeyedContainer(forKey: .listAntipatternSeveritySummary)
            for antipatternseveritysummary0 in listAntipatternSeveritySummary {
                try listAntipatternSeveritySummaryContainer.encode(antipatternseveritysummary0)
            }
        }
        if let moreServerAssociationExists = self.moreServerAssociationExists {
            try encodeContainer.encode(moreServerAssociationExists, forKey: .moreServerAssociationExists)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let osDriver = self.osDriver {
            try encodeContainer.encode(osDriver, forKey: .osDriver)
        }
        if let osVersion = self.osVersion {
            try encodeContainer.encode(osVersion, forKey: .osVersion)
        }
        if let recommendationSet = self.recommendationSet {
            try encodeContainer.encode(recommendationSet, forKey: .recommendationSet)
        }
        if let resourceSubType = self.resourceSubType {
            try encodeContainer.encode(resourceSubType.rawValue, forKey: .resourceSubType)
        }
        if let resultList = resultList {
            var resultListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resultList)
            for result0 in resultList {
                try resultListContainer.encode(result0)
            }
        }
        if let runtimeStatus = self.runtimeStatus {
            try encodeContainer.encode(runtimeStatus.rawValue, forKey: .runtimeStatus)
        }
        if let runtimeStatusMessage = self.runtimeStatusMessage {
            try encodeContainer.encode(runtimeStatusMessage, forKey: .runtimeStatusMessage)
        }
        if let sourceCodeRepositories = sourceCodeRepositories {
            var sourceCodeRepositoriesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sourceCodeRepositories)
            for sourcecoderepository0 in sourceCodeRepositories {
                try sourceCodeRepositoriesContainer.encode(sourcecoderepository0)
            }
        }
        if let statusMessage = self.statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let recommendationSetDecoded = try containerValues.decodeIfPresent(MigrationHubStrategyClientTypes.RecommendationSet.self, forKey: .recommendationSet)
        recommendationSet = recommendationSetDecoded
        let analysisStatusDecoded = try containerValues.decodeIfPresent(MigrationHubStrategyClientTypes.SrcCodeOrDbAnalysisStatus.self, forKey: .analysisStatus)
        analysisStatus = analysisStatusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let listAntipatternSeveritySummaryContainer = try containerValues.decodeIfPresent([MigrationHubStrategyClientTypes.AntipatternSeveritySummary?].self, forKey: .listAntipatternSeveritySummary)
        var listAntipatternSeveritySummaryDecoded0:[MigrationHubStrategyClientTypes.AntipatternSeveritySummary]? = nil
        if let listAntipatternSeveritySummaryContainer = listAntipatternSeveritySummaryContainer {
            listAntipatternSeveritySummaryDecoded0 = [MigrationHubStrategyClientTypes.AntipatternSeveritySummary]()
            for structure0 in listAntipatternSeveritySummaryContainer {
                if let structure0 = structure0 {
                    listAntipatternSeveritySummaryDecoded0?.append(structure0)
                }
            }
        }
        listAntipatternSeveritySummary = listAntipatternSeveritySummaryDecoded0
        let databaseConfigDetailDecoded = try containerValues.decodeIfPresent(MigrationHubStrategyClientTypes.DatabaseConfigDetail.self, forKey: .databaseConfigDetail)
        databaseConfigDetail = databaseConfigDetailDecoded
        let sourceCodeRepositoriesContainer = try containerValues.decodeIfPresent([MigrationHubStrategyClientTypes.SourceCodeRepository?].self, forKey: .sourceCodeRepositories)
        var sourceCodeRepositoriesDecoded0:[MigrationHubStrategyClientTypes.SourceCodeRepository]? = nil
        if let sourceCodeRepositoriesContainer = sourceCodeRepositoriesContainer {
            sourceCodeRepositoriesDecoded0 = [MigrationHubStrategyClientTypes.SourceCodeRepository]()
            for structure0 in sourceCodeRepositoriesContainer {
                if let structure0 = structure0 {
                    sourceCodeRepositoriesDecoded0?.append(structure0)
                }
            }
        }
        sourceCodeRepositories = sourceCodeRepositoriesDecoded0
        let appTypeDecoded = try containerValues.decodeIfPresent(MigrationHubStrategyClientTypes.AppType.self, forKey: .appType)
        appType = appTypeDecoded
        let resourceSubTypeDecoded = try containerValues.decodeIfPresent(MigrationHubStrategyClientTypes.ResourceSubType.self, forKey: .resourceSubType)
        resourceSubType = resourceSubTypeDecoded
        let inclusionStatusDecoded = try containerValues.decodeIfPresent(MigrationHubStrategyClientTypes.InclusionStatus.self, forKey: .inclusionStatus)
        inclusionStatus = inclusionStatusDecoded
        let antipatternReportS3ObjectDecoded = try containerValues.decodeIfPresent(MigrationHubStrategyClientTypes.S3Object.self, forKey: .antipatternReportS3Object)
        antipatternReportS3Object = antipatternReportS3ObjectDecoded
        let antipatternReportStatusDecoded = try containerValues.decodeIfPresent(MigrationHubStrategyClientTypes.AntipatternReportStatus.self, forKey: .antipatternReportStatus)
        antipatternReportStatus = antipatternReportStatusDecoded
        let antipatternReportStatusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .antipatternReportStatusMessage)
        antipatternReportStatusMessage = antipatternReportStatusMessageDecoded
        let osVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .osVersion)
        osVersion = osVersionDecoded
        let osDriverDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .osDriver)
        osDriver = osDriverDecoded
        let lastAnalyzedTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastAnalyzedTimestamp)
        lastAnalyzedTimestamp = lastAnalyzedTimestampDecoded
        let associatedServerIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .associatedServerId)
        associatedServerId = associatedServerIdDecoded
        let moreServerAssociationExistsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .moreServerAssociationExists)
        moreServerAssociationExists = moreServerAssociationExistsDecoded
        let runtimeStatusDecoded = try containerValues.decodeIfPresent(MigrationHubStrategyClientTypes.RuntimeAnalysisStatus.self, forKey: .runtimeStatus)
        runtimeStatus = runtimeStatusDecoded
        let runtimeStatusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .runtimeStatusMessage)
        runtimeStatusMessage = runtimeStatusMessageDecoded
        let appUnitErrorDecoded = try containerValues.decodeIfPresent(MigrationHubStrategyClientTypes.AppUnitError.self, forKey: .appUnitError)
        appUnitError = appUnitErrorDecoded
        let resultListContainer = try containerValues.decodeIfPresent([MigrationHubStrategyClientTypes.Result?].self, forKey: .resultList)
        var resultListDecoded0:[MigrationHubStrategyClientTypes.Result]? = nil
        if let resultListContainer = resultListContainer {
            resultListDecoded0 = [MigrationHubStrategyClientTypes.Result]()
            for structure0 in resultListContainer {
                if let structure0 = structure0 {
                    resultListDecoded0?.append(structure0)
                }
            }
        }
        resultList = resultListDecoded0
    }
}

extension MigrationHubStrategyClientTypes {
    /// Contains detailed information about an application component.
    public struct ApplicationComponentDetail: Swift.Equatable {
        /// The status of analysis, if the application component has source code or an associated database.
        public var analysisStatus: MigrationHubStrategyClientTypes.SrcCodeOrDbAnalysisStatus?
        /// The S3 bucket name and the Amazon S3 key name for the anti-pattern report.
        public var antipatternReportS3Object: MigrationHubStrategyClientTypes.S3Object?
        /// The status of the anti-pattern report generation.
        public var antipatternReportStatus: MigrationHubStrategyClientTypes.AntipatternReportStatus?
        /// The status message for the anti-pattern.
        public var antipatternReportStatusMessage: Swift.String?
        /// The type of application component.
        public var appType: MigrationHubStrategyClientTypes.AppType?
        /// The error in the analysis of the source code or database.
        public var appUnitError: MigrationHubStrategyClientTypes.AppUnitError?
        /// The ID of the server that the application component is running on.
        public var associatedServerId: Swift.String?
        /// Configuration details for the database associated with the application component.
        public var databaseConfigDetail: MigrationHubStrategyClientTypes.DatabaseConfigDetail?
        /// The ID of the application component.
        public var id: Swift.String?
        /// Indicates whether the application component has been included for server recommendation or not.
        public var inclusionStatus: MigrationHubStrategyClientTypes.InclusionStatus?
        /// The timestamp of when the application component was assessed.
        public var lastAnalyzedTimestamp: ClientRuntime.Date?
        /// A list of anti-pattern severity summaries.
        public var listAntipatternSeveritySummary: [MigrationHubStrategyClientTypes.AntipatternSeveritySummary]?
        /// Set to true if the application component is running on multiple servers.
        public var moreServerAssociationExists: Swift.Bool?
        /// The name of application component.
        public var name: Swift.String?
        /// OS driver.
        public var osDriver: Swift.String?
        /// OS version.
        public var osVersion: Swift.String?
        /// The top recommendation set for the application component.
        public var recommendationSet: MigrationHubStrategyClientTypes.RecommendationSet?
        /// The application component subtype.
        public var resourceSubType: MigrationHubStrategyClientTypes.ResourceSubType?
        /// A list of the analysis results.
        public var resultList: [MigrationHubStrategyClientTypes.Result]?
        /// The status of the application unit.
        public var runtimeStatus: MigrationHubStrategyClientTypes.RuntimeAnalysisStatus?
        /// The status message for the application unit.
        public var runtimeStatusMessage: Swift.String?
        /// Details about the source code repository associated with the application component.
        public var sourceCodeRepositories: [MigrationHubStrategyClientTypes.SourceCodeRepository]?
        /// A detailed description of the analysis status and any failure message.
        public var statusMessage: Swift.String?

        public init(
            analysisStatus: MigrationHubStrategyClientTypes.SrcCodeOrDbAnalysisStatus? = nil,
            antipatternReportS3Object: MigrationHubStrategyClientTypes.S3Object? = nil,
            antipatternReportStatus: MigrationHubStrategyClientTypes.AntipatternReportStatus? = nil,
            antipatternReportStatusMessage: Swift.String? = nil,
            appType: MigrationHubStrategyClientTypes.AppType? = nil,
            appUnitError: MigrationHubStrategyClientTypes.AppUnitError? = nil,
            associatedServerId: Swift.String? = nil,
            databaseConfigDetail: MigrationHubStrategyClientTypes.DatabaseConfigDetail? = nil,
            id: Swift.String? = nil,
            inclusionStatus: MigrationHubStrategyClientTypes.InclusionStatus? = nil,
            lastAnalyzedTimestamp: ClientRuntime.Date? = nil,
            listAntipatternSeveritySummary: [MigrationHubStrategyClientTypes.AntipatternSeveritySummary]? = nil,
            moreServerAssociationExists: Swift.Bool? = nil,
            name: Swift.String? = nil,
            osDriver: Swift.String? = nil,
            osVersion: Swift.String? = nil,
            recommendationSet: MigrationHubStrategyClientTypes.RecommendationSet? = nil,
            resourceSubType: MigrationHubStrategyClientTypes.ResourceSubType? = nil,
            resultList: [MigrationHubStrategyClientTypes.Result]? = nil,
            runtimeStatus: MigrationHubStrategyClientTypes.RuntimeAnalysisStatus? = nil,
            runtimeStatusMessage: Swift.String? = nil,
            sourceCodeRepositories: [MigrationHubStrategyClientTypes.SourceCodeRepository]? = nil,
            statusMessage: Swift.String? = nil
        )
        {
            self.analysisStatus = analysisStatus
            self.antipatternReportS3Object = antipatternReportS3Object
            self.antipatternReportStatus = antipatternReportStatus
            self.antipatternReportStatusMessage = antipatternReportStatusMessage
            self.appType = appType
            self.appUnitError = appUnitError
            self.associatedServerId = associatedServerId
            self.databaseConfigDetail = databaseConfigDetail
            self.id = id
            self.inclusionStatus = inclusionStatus
            self.lastAnalyzedTimestamp = lastAnalyzedTimestamp
            self.listAntipatternSeveritySummary = listAntipatternSeveritySummary
            self.moreServerAssociationExists = moreServerAssociationExists
            self.name = name
            self.osDriver = osDriver
            self.osVersion = osVersion
            self.recommendationSet = recommendationSet
            self.resourceSubType = resourceSubType
            self.resultList = resultList
            self.runtimeStatus = runtimeStatus
            self.runtimeStatusMessage = runtimeStatusMessage
            self.sourceCodeRepositories = sourceCodeRepositories
            self.statusMessage = statusMessage
        }
    }

}

extension MigrationHubStrategyClientTypes.ApplicationComponentStatusSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case count
        case srcCodeOrDbAnalysisStatus
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let count = self.count {
            try encodeContainer.encode(count, forKey: .count)
        }
        if let srcCodeOrDbAnalysisStatus = self.srcCodeOrDbAnalysisStatus {
            try encodeContainer.encode(srcCodeOrDbAnalysisStatus.rawValue, forKey: .srcCodeOrDbAnalysisStatus)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let srcCodeOrDbAnalysisStatusDecoded = try containerValues.decodeIfPresent(MigrationHubStrategyClientTypes.SrcCodeOrDbAnalysisStatus.self, forKey: .srcCodeOrDbAnalysisStatus)
        srcCodeOrDbAnalysisStatus = srcCodeOrDbAnalysisStatusDecoded
        let countDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .count)
        count = countDecoded
    }
}

extension MigrationHubStrategyClientTypes {
    /// Summary of the analysis status of the application component.
    public struct ApplicationComponentStatusSummary: Swift.Equatable {
        /// The number of application components successfully analyzed, partially successful or failed analysis.
        public var count: Swift.Int?
        /// The status of database analysis.
        public var srcCodeOrDbAnalysisStatus: MigrationHubStrategyClientTypes.SrcCodeOrDbAnalysisStatus?

        public init(
            count: Swift.Int? = nil,
            srcCodeOrDbAnalysisStatus: MigrationHubStrategyClientTypes.SrcCodeOrDbAnalysisStatus? = nil
        )
        {
            self.count = count
            self.srcCodeOrDbAnalysisStatus = srcCodeOrDbAnalysisStatus
        }
    }

}

extension MigrationHubStrategyClientTypes.ApplicationComponentStrategy: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case isPreferred
        case recommendation
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let isPreferred = self.isPreferred {
            try encodeContainer.encode(isPreferred, forKey: .isPreferred)
        }
        if let recommendation = self.recommendation {
            try encodeContainer.encode(recommendation, forKey: .recommendation)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recommendationDecoded = try containerValues.decodeIfPresent(MigrationHubStrategyClientTypes.RecommendationSet.self, forKey: .recommendation)
        recommendation = recommendationDecoded
        let statusDecoded = try containerValues.decodeIfPresent(MigrationHubStrategyClientTypes.StrategyRecommendation.self, forKey: .status)
        status = statusDecoded
        let isPreferredDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isPreferred)
        isPreferred = isPreferredDecoded
    }
}

extension MigrationHubStrategyClientTypes {
    /// Contains information about a strategy recommendation for an application component.
    public struct ApplicationComponentStrategy: Swift.Equatable {
        /// Set to true if the recommendation is set as preferred.
        public var isPreferred: Swift.Bool?
        /// Strategy recommendation for the application component.
        public var recommendation: MigrationHubStrategyClientTypes.RecommendationSet?
        /// The recommendation status of a strategy for an application component.
        public var status: MigrationHubStrategyClientTypes.StrategyRecommendation?

        public init(
            isPreferred: Swift.Bool? = nil,
            recommendation: MigrationHubStrategyClientTypes.RecommendationSet? = nil,
            status: MigrationHubStrategyClientTypes.StrategyRecommendation? = nil
        )
        {
            self.isPreferred = isPreferred
            self.recommendation = recommendation
            self.status = status
        }
    }

}

extension MigrationHubStrategyClientTypes.ApplicationComponentSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appType
        case count
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appType = self.appType {
            try encodeContainer.encode(appType.rawValue, forKey: .appType)
        }
        if let count = self.count {
            try encodeContainer.encode(count, forKey: .count)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appTypeDecoded = try containerValues.decodeIfPresent(MigrationHubStrategyClientTypes.AppType.self, forKey: .appType)
        appType = appTypeDecoded
        let countDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .count)
        count = countDecoded
    }
}

extension MigrationHubStrategyClientTypes {
    /// Contains the summary of application components.
    public struct ApplicationComponentSummary: Swift.Equatable {
        /// Contains the name of application types.
        public var appType: MigrationHubStrategyClientTypes.AppType?
        /// Contains the count of application type.
        public var count: Swift.Int?

        public init(
            appType: MigrationHubStrategyClientTypes.AppType? = nil,
            count: Swift.Int? = nil
        )
        {
            self.appType = appType
            self.count = count
        }
    }

}

extension MigrationHubStrategyClientTypes {
    public enum ApplicationMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case all
        case known
        case unknown
        case sdkUnknown(Swift.String)

        public static var allCases: [ApplicationMode] {
            return [
                .all,
                .known,
                .unknown,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .all: return "ALL"
            case .known: return "KNOWN"
            case .unknown: return "UNKNOWN"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ApplicationMode(rawValue: rawValue) ?? ApplicationMode.sdkUnknown(rawValue)
        }
    }
}

extension MigrationHubStrategyClientTypes.ApplicationPreferences: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case managementPreference
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let managementPreference = self.managementPreference {
            try encodeContainer.encode(managementPreference, forKey: .managementPreference)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let managementPreferenceDecoded = try containerValues.decodeIfPresent(MigrationHubStrategyClientTypes.ManagementPreference.self, forKey: .managementPreference)
        managementPreference = managementPreferenceDecoded
    }
}

extension MigrationHubStrategyClientTypes {
    /// Application preferences that you specify.
    public struct ApplicationPreferences: Swift.Equatable {
        /// Application preferences that you specify to prefer managed environment.
        public var managementPreference: MigrationHubStrategyClientTypes.ManagementPreference?

        public init(
            managementPreference: MigrationHubStrategyClientTypes.ManagementPreference? = nil
        )
        {
            self.managementPreference = managementPreference
        }
    }

}

extension MigrationHubStrategyClientTypes {
    public enum AssessmentStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case complete
        case failed
        case inProgress
        case stopped
        case sdkUnknown(Swift.String)

        public static var allCases: [AssessmentStatus] {
            return [
                .complete,
                .failed,
                .inProgress,
                .stopped,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .complete: return "COMPLETE"
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .stopped: return "STOPPED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AssessmentStatus(rawValue: rawValue) ?? AssessmentStatus.sdkUnknown(rawValue)
        }
    }
}

extension MigrationHubStrategyClientTypes.AssessmentSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case antipatternReportS3Object
        case antipatternReportStatus
        case antipatternReportStatusMessage
        case lastAnalyzedTimestamp
        case listAntipatternSeveritySummary
        case listApplicationComponentStatusSummary
        case listApplicationComponentStrategySummary
        case listApplicationComponentSummary
        case listServerStatusSummary
        case listServerStrategySummary
        case listServerSummary
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let antipatternReportS3Object = self.antipatternReportS3Object {
            try encodeContainer.encode(antipatternReportS3Object, forKey: .antipatternReportS3Object)
        }
        if let antipatternReportStatus = self.antipatternReportStatus {
            try encodeContainer.encode(antipatternReportStatus.rawValue, forKey: .antipatternReportStatus)
        }
        if let antipatternReportStatusMessage = self.antipatternReportStatusMessage {
            try encodeContainer.encode(antipatternReportStatusMessage, forKey: .antipatternReportStatusMessage)
        }
        if let lastAnalyzedTimestamp = self.lastAnalyzedTimestamp {
            try encodeContainer.encodeTimestamp(lastAnalyzedTimestamp, format: .epochSeconds, forKey: .lastAnalyzedTimestamp)
        }
        if let listAntipatternSeveritySummary = listAntipatternSeveritySummary {
            var listAntipatternSeveritySummaryContainer = encodeContainer.nestedUnkeyedContainer(forKey: .listAntipatternSeveritySummary)
            for antipatternseveritysummary0 in listAntipatternSeveritySummary {
                try listAntipatternSeveritySummaryContainer.encode(antipatternseveritysummary0)
            }
        }
        if let listApplicationComponentStatusSummary = listApplicationComponentStatusSummary {
            var listApplicationComponentStatusSummaryContainer = encodeContainer.nestedUnkeyedContainer(forKey: .listApplicationComponentStatusSummary)
            for applicationcomponentstatussummary0 in listApplicationComponentStatusSummary {
                try listApplicationComponentStatusSummaryContainer.encode(applicationcomponentstatussummary0)
            }
        }
        if let listApplicationComponentStrategySummary = listApplicationComponentStrategySummary {
            var listApplicationComponentStrategySummaryContainer = encodeContainer.nestedUnkeyedContainer(forKey: .listApplicationComponentStrategySummary)
            for strategysummary0 in listApplicationComponentStrategySummary {
                try listApplicationComponentStrategySummaryContainer.encode(strategysummary0)
            }
        }
        if let listApplicationComponentSummary = listApplicationComponentSummary {
            var listApplicationComponentSummaryContainer = encodeContainer.nestedUnkeyedContainer(forKey: .listApplicationComponentSummary)
            for applicationcomponentsummary0 in listApplicationComponentSummary {
                try listApplicationComponentSummaryContainer.encode(applicationcomponentsummary0)
            }
        }
        if let listServerStatusSummary = listServerStatusSummary {
            var listServerStatusSummaryContainer = encodeContainer.nestedUnkeyedContainer(forKey: .listServerStatusSummary)
            for serverstatussummary0 in listServerStatusSummary {
                try listServerStatusSummaryContainer.encode(serverstatussummary0)
            }
        }
        if let listServerStrategySummary = listServerStrategySummary {
            var listServerStrategySummaryContainer = encodeContainer.nestedUnkeyedContainer(forKey: .listServerStrategySummary)
            for strategysummary0 in listServerStrategySummary {
                try listServerStrategySummaryContainer.encode(strategysummary0)
            }
        }
        if let listServerSummary = listServerSummary {
            var listServerSummaryContainer = encodeContainer.nestedUnkeyedContainer(forKey: .listServerSummary)
            for serversummary0 in listServerSummary {
                try listServerSummaryContainer.encode(serversummary0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let listServerStrategySummaryContainer = try containerValues.decodeIfPresent([MigrationHubStrategyClientTypes.StrategySummary?].self, forKey: .listServerStrategySummary)
        var listServerStrategySummaryDecoded0:[MigrationHubStrategyClientTypes.StrategySummary]? = nil
        if let listServerStrategySummaryContainer = listServerStrategySummaryContainer {
            listServerStrategySummaryDecoded0 = [MigrationHubStrategyClientTypes.StrategySummary]()
            for structure0 in listServerStrategySummaryContainer {
                if let structure0 = structure0 {
                    listServerStrategySummaryDecoded0?.append(structure0)
                }
            }
        }
        listServerStrategySummary = listServerStrategySummaryDecoded0
        let listApplicationComponentStrategySummaryContainer = try containerValues.decodeIfPresent([MigrationHubStrategyClientTypes.StrategySummary?].self, forKey: .listApplicationComponentStrategySummary)
        var listApplicationComponentStrategySummaryDecoded0:[MigrationHubStrategyClientTypes.StrategySummary]? = nil
        if let listApplicationComponentStrategySummaryContainer = listApplicationComponentStrategySummaryContainer {
            listApplicationComponentStrategySummaryDecoded0 = [MigrationHubStrategyClientTypes.StrategySummary]()
            for structure0 in listApplicationComponentStrategySummaryContainer {
                if let structure0 = structure0 {
                    listApplicationComponentStrategySummaryDecoded0?.append(structure0)
                }
            }
        }
        listApplicationComponentStrategySummary = listApplicationComponentStrategySummaryDecoded0
        let listAntipatternSeveritySummaryContainer = try containerValues.decodeIfPresent([MigrationHubStrategyClientTypes.AntipatternSeveritySummary?].self, forKey: .listAntipatternSeveritySummary)
        var listAntipatternSeveritySummaryDecoded0:[MigrationHubStrategyClientTypes.AntipatternSeveritySummary]? = nil
        if let listAntipatternSeveritySummaryContainer = listAntipatternSeveritySummaryContainer {
            listAntipatternSeveritySummaryDecoded0 = [MigrationHubStrategyClientTypes.AntipatternSeveritySummary]()
            for structure0 in listAntipatternSeveritySummaryContainer {
                if let structure0 = structure0 {
                    listAntipatternSeveritySummaryDecoded0?.append(structure0)
                }
            }
        }
        listAntipatternSeveritySummary = listAntipatternSeveritySummaryDecoded0
        let listApplicationComponentSummaryContainer = try containerValues.decodeIfPresent([MigrationHubStrategyClientTypes.ApplicationComponentSummary?].self, forKey: .listApplicationComponentSummary)
        var listApplicationComponentSummaryDecoded0:[MigrationHubStrategyClientTypes.ApplicationComponentSummary]? = nil
        if let listApplicationComponentSummaryContainer = listApplicationComponentSummaryContainer {
            listApplicationComponentSummaryDecoded0 = [MigrationHubStrategyClientTypes.ApplicationComponentSummary]()
            for structure0 in listApplicationComponentSummaryContainer {
                if let structure0 = structure0 {
                    listApplicationComponentSummaryDecoded0?.append(structure0)
                }
            }
        }
        listApplicationComponentSummary = listApplicationComponentSummaryDecoded0
        let listServerSummaryContainer = try containerValues.decodeIfPresent([MigrationHubStrategyClientTypes.ServerSummary?].self, forKey: .listServerSummary)
        var listServerSummaryDecoded0:[MigrationHubStrategyClientTypes.ServerSummary]? = nil
        if let listServerSummaryContainer = listServerSummaryContainer {
            listServerSummaryDecoded0 = [MigrationHubStrategyClientTypes.ServerSummary]()
            for structure0 in listServerSummaryContainer {
                if let structure0 = structure0 {
                    listServerSummaryDecoded0?.append(structure0)
                }
            }
        }
        listServerSummary = listServerSummaryDecoded0
        let antipatternReportS3ObjectDecoded = try containerValues.decodeIfPresent(MigrationHubStrategyClientTypes.S3Object.self, forKey: .antipatternReportS3Object)
        antipatternReportS3Object = antipatternReportS3ObjectDecoded
        let antipatternReportStatusDecoded = try containerValues.decodeIfPresent(MigrationHubStrategyClientTypes.AntipatternReportStatus.self, forKey: .antipatternReportStatus)
        antipatternReportStatus = antipatternReportStatusDecoded
        let antipatternReportStatusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .antipatternReportStatusMessage)
        antipatternReportStatusMessage = antipatternReportStatusMessageDecoded
        let lastAnalyzedTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastAnalyzedTimestamp)
        lastAnalyzedTimestamp = lastAnalyzedTimestampDecoded
        let listApplicationComponentStatusSummaryContainer = try containerValues.decodeIfPresent([MigrationHubStrategyClientTypes.ApplicationComponentStatusSummary?].self, forKey: .listApplicationComponentStatusSummary)
        var listApplicationComponentStatusSummaryDecoded0:[MigrationHubStrategyClientTypes.ApplicationComponentStatusSummary]? = nil
        if let listApplicationComponentStatusSummaryContainer = listApplicationComponentStatusSummaryContainer {
            listApplicationComponentStatusSummaryDecoded0 = [MigrationHubStrategyClientTypes.ApplicationComponentStatusSummary]()
            for structure0 in listApplicationComponentStatusSummaryContainer {
                if let structure0 = structure0 {
                    listApplicationComponentStatusSummaryDecoded0?.append(structure0)
                }
            }
        }
        listApplicationComponentStatusSummary = listApplicationComponentStatusSummaryDecoded0
        let listServerStatusSummaryContainer = try containerValues.decodeIfPresent([MigrationHubStrategyClientTypes.ServerStatusSummary?].self, forKey: .listServerStatusSummary)
        var listServerStatusSummaryDecoded0:[MigrationHubStrategyClientTypes.ServerStatusSummary]? = nil
        if let listServerStatusSummaryContainer = listServerStatusSummaryContainer {
            listServerStatusSummaryDecoded0 = [MigrationHubStrategyClientTypes.ServerStatusSummary]()
            for structure0 in listServerStatusSummaryContainer {
                if let structure0 = structure0 {
                    listServerStatusSummaryDecoded0?.append(structure0)
                }
            }
        }
        listServerStatusSummary = listServerStatusSummaryDecoded0
    }
}

extension MigrationHubStrategyClientTypes {
    /// Contains the summary of the assessment results.
    public struct AssessmentSummary: Swift.Equatable {
        /// The Amazon S3 object containing the anti-pattern report.
        public var antipatternReportS3Object: MigrationHubStrategyClientTypes.S3Object?
        /// The status of the anti-pattern report.
        public var antipatternReportStatus: MigrationHubStrategyClientTypes.AntipatternReportStatus?
        /// The status message of the anti-pattern report.
        public var antipatternReportStatusMessage: Swift.String?
        /// The time the assessment was performed.
        public var lastAnalyzedTimestamp: ClientRuntime.Date?
        /// List of AntipatternSeveritySummary.
        public var listAntipatternSeveritySummary: [MigrationHubStrategyClientTypes.AntipatternSeveritySummary]?
        /// List of status summaries of the analyzed application components.
        public var listApplicationComponentStatusSummary: [MigrationHubStrategyClientTypes.ApplicationComponentStatusSummary]?
        /// List of ApplicationComponentStrategySummary.
        public var listApplicationComponentStrategySummary: [MigrationHubStrategyClientTypes.StrategySummary]?
        /// List of ApplicationComponentSummary.
        public var listApplicationComponentSummary: [MigrationHubStrategyClientTypes.ApplicationComponentSummary]?
        /// List of status summaries of the analyzed servers.
        public var listServerStatusSummary: [MigrationHubStrategyClientTypes.ServerStatusSummary]?
        /// List of ServerStrategySummary.
        public var listServerStrategySummary: [MigrationHubStrategyClientTypes.StrategySummary]?
        /// List of ServerSummary.
        public var listServerSummary: [MigrationHubStrategyClientTypes.ServerSummary]?

        public init(
            antipatternReportS3Object: MigrationHubStrategyClientTypes.S3Object? = nil,
            antipatternReportStatus: MigrationHubStrategyClientTypes.AntipatternReportStatus? = nil,
            antipatternReportStatusMessage: Swift.String? = nil,
            lastAnalyzedTimestamp: ClientRuntime.Date? = nil,
            listAntipatternSeveritySummary: [MigrationHubStrategyClientTypes.AntipatternSeveritySummary]? = nil,
            listApplicationComponentStatusSummary: [MigrationHubStrategyClientTypes.ApplicationComponentStatusSummary]? = nil,
            listApplicationComponentStrategySummary: [MigrationHubStrategyClientTypes.StrategySummary]? = nil,
            listApplicationComponentSummary: [MigrationHubStrategyClientTypes.ApplicationComponentSummary]? = nil,
            listServerStatusSummary: [MigrationHubStrategyClientTypes.ServerStatusSummary]? = nil,
            listServerStrategySummary: [MigrationHubStrategyClientTypes.StrategySummary]? = nil,
            listServerSummary: [MigrationHubStrategyClientTypes.ServerSummary]? = nil
        )
        {
            self.antipatternReportS3Object = antipatternReportS3Object
            self.antipatternReportStatus = antipatternReportStatus
            self.antipatternReportStatusMessage = antipatternReportStatusMessage
            self.lastAnalyzedTimestamp = lastAnalyzedTimestamp
            self.listAntipatternSeveritySummary = listAntipatternSeveritySummary
            self.listApplicationComponentStatusSummary = listApplicationComponentStatusSummary
            self.listApplicationComponentStrategySummary = listApplicationComponentStrategySummary
            self.listApplicationComponentSummary = listApplicationComponentSummary
            self.listServerStatusSummary = listServerStatusSummary
            self.listServerStrategySummary = listServerStrategySummary
            self.listServerSummary = listServerSummary
        }
    }

}

extension MigrationHubStrategyClientTypes.AssessmentTarget: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case condition
        case name
        case values
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let condition = self.condition {
            try encodeContainer.encode(condition.rawValue, forKey: .condition)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let values = values {
            var valuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .values)
            for string0 in values {
                try valuesContainer.encode(string0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let conditionDecoded = try containerValues.decodeIfPresent(MigrationHubStrategyClientTypes.Condition.self, forKey: .condition)
        condition = conditionDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let valuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .values)
        var valuesDecoded0:[Swift.String]? = nil
        if let valuesContainer = valuesContainer {
            valuesDecoded0 = [Swift.String]()
            for string0 in valuesContainer {
                if let string0 = string0 {
                    valuesDecoded0?.append(string0)
                }
            }
        }
        values = valuesDecoded0
    }
}

extension MigrationHubStrategyClientTypes {
    /// Defines the criteria of assessment.
    public struct AssessmentTarget: Swift.Equatable {
        /// Condition of an assessment.
        /// This member is required.
        public var condition: MigrationHubStrategyClientTypes.Condition?
        /// Name of an assessment.
        /// This member is required.
        public var name: Swift.String?
        /// Values of an assessment.
        /// This member is required.
        public var values: [Swift.String]?

        public init(
            condition: MigrationHubStrategyClientTypes.Condition? = nil,
            name: Swift.String? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.condition = condition
            self.name = name
            self.values = values
        }
    }

}

extension MigrationHubStrategyClientTypes.AssociatedApplication: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
    }
}

extension MigrationHubStrategyClientTypes {
    /// Object containing details about applications as defined in Application Discovery Service.
    public struct AssociatedApplication: Swift.Equatable {
        /// ID of the application as defined in Application Discovery Service.
        public var id: Swift.String?
        /// Name of the application as defined in Application Discovery Service.
        public var name: Swift.String?

        public init(
            id: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.id = id
            self.name = name
        }
    }

}

extension MigrationHubStrategyClientTypes {
    public enum AuthType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cert
        case ntlm
        case ssh
        case sdkUnknown(Swift.String)

        public static var allCases: [AuthType] {
            return [
                .cert,
                .ntlm,
                .ssh,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cert: return "CERT"
            case .ntlm: return "NTLM"
            case .ssh: return "SSH"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AuthType(rawValue: rawValue) ?? AuthType.sdkUnknown(rawValue)
        }
    }
}

extension MigrationHubStrategyClientTypes.AwsManagedResources: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case targetDestination
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let targetDestination = targetDestination {
            var targetDestinationContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targetDestination)
            for awsmanagedtargetdestination0 in targetDestination {
                try targetDestinationContainer.encode(awsmanagedtargetdestination0.rawValue)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetDestinationContainer = try containerValues.decodeIfPresent([MigrationHubStrategyClientTypes.AwsManagedTargetDestination?].self, forKey: .targetDestination)
        var targetDestinationDecoded0:[MigrationHubStrategyClientTypes.AwsManagedTargetDestination]? = nil
        if let targetDestinationContainer = targetDestinationContainer {
            targetDestinationDecoded0 = [MigrationHubStrategyClientTypes.AwsManagedTargetDestination]()
            for string0 in targetDestinationContainer {
                if let string0 = string0 {
                    targetDestinationDecoded0?.append(string0)
                }
            }
        }
        targetDestination = targetDestinationDecoded0
    }
}

extension MigrationHubStrategyClientTypes {
    /// Object containing the choice of application destination that you specify.
    public struct AwsManagedResources: Swift.Equatable {
        /// The choice of application destination that you specify.
        /// This member is required.
        public var targetDestination: [MigrationHubStrategyClientTypes.AwsManagedTargetDestination]?

        public init(
            targetDestination: [MigrationHubStrategyClientTypes.AwsManagedTargetDestination]? = nil
        )
        {
            self.targetDestination = targetDestination
        }
    }

}

extension MigrationHubStrategyClientTypes {
    public enum AwsManagedTargetDestination: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case awsElasticBeanstalk
        case awsFargate
        case noneSpecified
        case sdkUnknown(Swift.String)

        public static var allCases: [AwsManagedTargetDestination] {
            return [
                .awsElasticBeanstalk,
                .awsFargate,
                .noneSpecified,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .awsElasticBeanstalk: return "AWS Elastic BeanStalk"
            case .awsFargate: return "AWS Fargate"
            case .noneSpecified: return "None specified"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AwsManagedTargetDestination(rawValue: rawValue) ?? AwsManagedTargetDestination.sdkUnknown(rawValue)
        }
    }
}

extension MigrationHubStrategyClientTypes {
    public enum BinaryAnalyzerName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case bytecodeAnalyzer
        case dllAnalyzer
        case sdkUnknown(Swift.String)

        public static var allCases: [BinaryAnalyzerName] {
            return [
                .bytecodeAnalyzer,
                .dllAnalyzer,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .bytecodeAnalyzer: return "BYTECODE_ANALYZER"
            case .dllAnalyzer: return "DLL_ANALYZER"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = BinaryAnalyzerName(rawValue: rawValue) ?? BinaryAnalyzerName.sdkUnknown(rawValue)
        }
    }
}

extension MigrationHubStrategyClientTypes.BusinessGoals: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case licenseCostReduction
        case modernizeInfrastructureWithCloudNativeTechnologies
        case reduceOperationalOverheadWithManagedServices
        case speedOfMigration
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let licenseCostReduction = self.licenseCostReduction {
            try encodeContainer.encode(licenseCostReduction, forKey: .licenseCostReduction)
        }
        if let modernizeInfrastructureWithCloudNativeTechnologies = self.modernizeInfrastructureWithCloudNativeTechnologies {
            try encodeContainer.encode(modernizeInfrastructureWithCloudNativeTechnologies, forKey: .modernizeInfrastructureWithCloudNativeTechnologies)
        }
        if let reduceOperationalOverheadWithManagedServices = self.reduceOperationalOverheadWithManagedServices {
            try encodeContainer.encode(reduceOperationalOverheadWithManagedServices, forKey: .reduceOperationalOverheadWithManagedServices)
        }
        if let speedOfMigration = self.speedOfMigration {
            try encodeContainer.encode(speedOfMigration, forKey: .speedOfMigration)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let speedOfMigrationDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .speedOfMigration)
        speedOfMigration = speedOfMigrationDecoded
        let reduceOperationalOverheadWithManagedServicesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .reduceOperationalOverheadWithManagedServices)
        reduceOperationalOverheadWithManagedServices = reduceOperationalOverheadWithManagedServicesDecoded
        let modernizeInfrastructureWithCloudNativeTechnologiesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .modernizeInfrastructureWithCloudNativeTechnologies)
        modernizeInfrastructureWithCloudNativeTechnologies = modernizeInfrastructureWithCloudNativeTechnologiesDecoded
        let licenseCostReductionDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .licenseCostReduction)
        licenseCostReduction = licenseCostReductionDecoded
    }
}

extension MigrationHubStrategyClientTypes {
    /// Business goals that you specify.
    public struct BusinessGoals: Swift.Equatable {
        /// Business goal to reduce license costs.
        public var licenseCostReduction: Swift.Int?
        /// Business goal to modernize infrastructure by moving to cloud native technologies.
        public var modernizeInfrastructureWithCloudNativeTechnologies: Swift.Int?
        /// Business goal to reduce the operational overhead on the team by moving into managed services.
        public var reduceOperationalOverheadWithManagedServices: Swift.Int?
        /// Business goal to achieve migration at a fast pace.
        public var speedOfMigration: Swift.Int?

        public init(
            licenseCostReduction: Swift.Int? = nil,
            modernizeInfrastructureWithCloudNativeTechnologies: Swift.Int? = nil,
            reduceOperationalOverheadWithManagedServices: Swift.Int? = nil,
            speedOfMigration: Swift.Int? = nil
        )
        {
            self.licenseCostReduction = licenseCostReduction
            self.modernizeInfrastructureWithCloudNativeTechnologies = modernizeInfrastructureWithCloudNativeTechnologies
            self.reduceOperationalOverheadWithManagedServices = reduceOperationalOverheadWithManagedServices
            self.speedOfMigration = speedOfMigration
        }
    }

}

extension MigrationHubStrategyClientTypes.Collector: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case collectorHealth
        case collectorId
        case collectorVersion
        case configurationSummary
        case hostName
        case ipAddress
        case lastActivityTimeStamp
        case registeredTimeStamp
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let collectorHealth = self.collectorHealth {
            try encodeContainer.encode(collectorHealth.rawValue, forKey: .collectorHealth)
        }
        if let collectorId = self.collectorId {
            try encodeContainer.encode(collectorId, forKey: .collectorId)
        }
        if let collectorVersion = self.collectorVersion {
            try encodeContainer.encode(collectorVersion, forKey: .collectorVersion)
        }
        if let configurationSummary = self.configurationSummary {
            try encodeContainer.encode(configurationSummary, forKey: .configurationSummary)
        }
        if let hostName = self.hostName {
            try encodeContainer.encode(hostName, forKey: .hostName)
        }
        if let ipAddress = self.ipAddress {
            try encodeContainer.encode(ipAddress, forKey: .ipAddress)
        }
        if let lastActivityTimeStamp = self.lastActivityTimeStamp {
            try encodeContainer.encode(lastActivityTimeStamp, forKey: .lastActivityTimeStamp)
        }
        if let registeredTimeStamp = self.registeredTimeStamp {
            try encodeContainer.encode(registeredTimeStamp, forKey: .registeredTimeStamp)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let collectorIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .collectorId)
        collectorId = collectorIdDecoded
        let ipAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ipAddress)
        ipAddress = ipAddressDecoded
        let hostNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hostName)
        hostName = hostNameDecoded
        let collectorHealthDecoded = try containerValues.decodeIfPresent(MigrationHubStrategyClientTypes.CollectorHealth.self, forKey: .collectorHealth)
        collectorHealth = collectorHealthDecoded
        let collectorVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .collectorVersion)
        collectorVersion = collectorVersionDecoded
        let registeredTimeStampDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registeredTimeStamp)
        registeredTimeStamp = registeredTimeStampDecoded
        let lastActivityTimeStampDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastActivityTimeStamp)
        lastActivityTimeStamp = lastActivityTimeStampDecoded
        let configurationSummaryDecoded = try containerValues.decodeIfPresent(MigrationHubStrategyClientTypes.ConfigurationSummary.self, forKey: .configurationSummary)
        configurationSummary = configurationSummaryDecoded
    }
}

extension MigrationHubStrategyClientTypes {
    /// Process data collector that runs in the environment that you specify.
    public struct Collector: Swift.Equatable {
        /// Indicates the health of a collector.
        public var collectorHealth: MigrationHubStrategyClientTypes.CollectorHealth?
        /// The ID of the collector.
        public var collectorId: Swift.String?
        /// Current version of the collector that is running in the environment that you specify.
        public var collectorVersion: Swift.String?
        /// Summary of the collector configuration.
        public var configurationSummary: MigrationHubStrategyClientTypes.ConfigurationSummary?
        /// Hostname of the server that is hosting the collector.
        public var hostName: Swift.String?
        /// IP address of the server that is hosting the collector.
        public var ipAddress: Swift.String?
        /// Time when the collector last pinged the service.
        public var lastActivityTimeStamp: Swift.String?
        /// Time when the collector registered with the service.
        public var registeredTimeStamp: Swift.String?

        public init(
            collectorHealth: MigrationHubStrategyClientTypes.CollectorHealth? = nil,
            collectorId: Swift.String? = nil,
            collectorVersion: Swift.String? = nil,
            configurationSummary: MigrationHubStrategyClientTypes.ConfigurationSummary? = nil,
            hostName: Swift.String? = nil,
            ipAddress: Swift.String? = nil,
            lastActivityTimeStamp: Swift.String? = nil,
            registeredTimeStamp: Swift.String? = nil
        )
        {
            self.collectorHealth = collectorHealth
            self.collectorId = collectorId
            self.collectorVersion = collectorVersion
            self.configurationSummary = configurationSummary
            self.hostName = hostName
            self.ipAddress = ipAddress
            self.lastActivityTimeStamp = lastActivityTimeStamp
            self.registeredTimeStamp = registeredTimeStamp
        }
    }

}

extension MigrationHubStrategyClientTypes {
    public enum CollectorHealth: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case collectorHealthy
        case collectorUnhealthy
        case sdkUnknown(Swift.String)

        public static var allCases: [CollectorHealth] {
            return [
                .collectorHealthy,
                .collectorUnhealthy,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .collectorHealthy: return "COLLECTOR_HEALTHY"
            case .collectorUnhealthy: return "COLLECTOR_UNHEALTHY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CollectorHealth(rawValue: rawValue) ?? CollectorHealth.sdkUnknown(rawValue)
        }
    }
}

extension MigrationHubStrategyClientTypes {
    public enum Condition: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case contains
        case equals
        case notContains
        case notEquals
        case sdkUnknown(Swift.String)

        public static var allCases: [Condition] {
            return [
                .contains,
                .equals,
                .notContains,
                .notEquals,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .contains: return "CONTAINS"
            case .equals: return "EQUALS"
            case .notContains: return "NOT_CONTAINS"
            case .notEquals: return "NOT_EQUALS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Condition(rawValue: rawValue) ?? Condition.sdkUnknown(rawValue)
        }
    }
}

extension MigrationHubStrategyClientTypes.ConfigurationSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ipAddressBasedRemoteInfoList
        case pipelineInfoList
        case remoteSourceCodeAnalysisServerInfo
        case vcenterBasedRemoteInfoList
        case versionControlInfoList
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ipAddressBasedRemoteInfoList = ipAddressBasedRemoteInfoList {
            var ipAddressBasedRemoteInfoListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ipAddressBasedRemoteInfoList)
            for ipaddressbasedremoteinfo0 in ipAddressBasedRemoteInfoList {
                try ipAddressBasedRemoteInfoListContainer.encode(ipaddressbasedremoteinfo0)
            }
        }
        if let pipelineInfoList = pipelineInfoList {
            var pipelineInfoListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .pipelineInfoList)
            for pipelineinfo0 in pipelineInfoList {
                try pipelineInfoListContainer.encode(pipelineinfo0)
            }
        }
        if let remoteSourceCodeAnalysisServerInfo = self.remoteSourceCodeAnalysisServerInfo {
            try encodeContainer.encode(remoteSourceCodeAnalysisServerInfo, forKey: .remoteSourceCodeAnalysisServerInfo)
        }
        if let vcenterBasedRemoteInfoList = vcenterBasedRemoteInfoList {
            var vcenterBasedRemoteInfoListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .vcenterBasedRemoteInfoList)
            for vcenterbasedremoteinfo0 in vcenterBasedRemoteInfoList {
                try vcenterBasedRemoteInfoListContainer.encode(vcenterbasedremoteinfo0)
            }
        }
        if let versionControlInfoList = versionControlInfoList {
            var versionControlInfoListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .versionControlInfoList)
            for versioncontrolinfo0 in versionControlInfoList {
                try versionControlInfoListContainer.encode(versioncontrolinfo0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vcenterBasedRemoteInfoListContainer = try containerValues.decodeIfPresent([MigrationHubStrategyClientTypes.VcenterBasedRemoteInfo?].self, forKey: .vcenterBasedRemoteInfoList)
        var vcenterBasedRemoteInfoListDecoded0:[MigrationHubStrategyClientTypes.VcenterBasedRemoteInfo]? = nil
        if let vcenterBasedRemoteInfoListContainer = vcenterBasedRemoteInfoListContainer {
            vcenterBasedRemoteInfoListDecoded0 = [MigrationHubStrategyClientTypes.VcenterBasedRemoteInfo]()
            for structure0 in vcenterBasedRemoteInfoListContainer {
                if let structure0 = structure0 {
                    vcenterBasedRemoteInfoListDecoded0?.append(structure0)
                }
            }
        }
        vcenterBasedRemoteInfoList = vcenterBasedRemoteInfoListDecoded0
        let ipAddressBasedRemoteInfoListContainer = try containerValues.decodeIfPresent([MigrationHubStrategyClientTypes.IPAddressBasedRemoteInfo?].self, forKey: .ipAddressBasedRemoteInfoList)
        var ipAddressBasedRemoteInfoListDecoded0:[MigrationHubStrategyClientTypes.IPAddressBasedRemoteInfo]? = nil
        if let ipAddressBasedRemoteInfoListContainer = ipAddressBasedRemoteInfoListContainer {
            ipAddressBasedRemoteInfoListDecoded0 = [MigrationHubStrategyClientTypes.IPAddressBasedRemoteInfo]()
            for structure0 in ipAddressBasedRemoteInfoListContainer {
                if let structure0 = structure0 {
                    ipAddressBasedRemoteInfoListDecoded0?.append(structure0)
                }
            }
        }
        ipAddressBasedRemoteInfoList = ipAddressBasedRemoteInfoListDecoded0
        let versionControlInfoListContainer = try containerValues.decodeIfPresent([MigrationHubStrategyClientTypes.VersionControlInfo?].self, forKey: .versionControlInfoList)
        var versionControlInfoListDecoded0:[MigrationHubStrategyClientTypes.VersionControlInfo]? = nil
        if let versionControlInfoListContainer = versionControlInfoListContainer {
            versionControlInfoListDecoded0 = [MigrationHubStrategyClientTypes.VersionControlInfo]()
            for structure0 in versionControlInfoListContainer {
                if let structure0 = structure0 {
                    versionControlInfoListDecoded0?.append(structure0)
                }
            }
        }
        versionControlInfoList = versionControlInfoListDecoded0
        let pipelineInfoListContainer = try containerValues.decodeIfPresent([MigrationHubStrategyClientTypes.PipelineInfo?].self, forKey: .pipelineInfoList)
        var pipelineInfoListDecoded0:[MigrationHubStrategyClientTypes.PipelineInfo]? = nil
        if let pipelineInfoListContainer = pipelineInfoListContainer {
            pipelineInfoListDecoded0 = [MigrationHubStrategyClientTypes.PipelineInfo]()
            for structure0 in pipelineInfoListContainer {
                if let structure0 = structure0 {
                    pipelineInfoListDecoded0?.append(structure0)
                }
            }
        }
        pipelineInfoList = pipelineInfoListDecoded0
        let remoteSourceCodeAnalysisServerInfoDecoded = try containerValues.decodeIfPresent(MigrationHubStrategyClientTypes.RemoteSourceCodeAnalysisServerInfo.self, forKey: .remoteSourceCodeAnalysisServerInfo)
        remoteSourceCodeAnalysisServerInfo = remoteSourceCodeAnalysisServerInfoDecoded
    }
}

extension MigrationHubStrategyClientTypes {
    /// Summary of the collector configuration.
    public struct ConfigurationSummary: Swift.Equatable {
        /// IP address based configurations.
        public var ipAddressBasedRemoteInfoList: [MigrationHubStrategyClientTypes.IPAddressBasedRemoteInfo]?
        /// The list of pipeline info configurations.
        public var pipelineInfoList: [MigrationHubStrategyClientTypes.PipelineInfo]?
        /// Info about the remote server source code configuration.
        public var remoteSourceCodeAnalysisServerInfo: MigrationHubStrategyClientTypes.RemoteSourceCodeAnalysisServerInfo?
        /// The list of vCenter configurations.
        public var vcenterBasedRemoteInfoList: [MigrationHubStrategyClientTypes.VcenterBasedRemoteInfo]?
        /// The list of the version control configurations.
        public var versionControlInfoList: [MigrationHubStrategyClientTypes.VersionControlInfo]?

        public init(
            ipAddressBasedRemoteInfoList: [MigrationHubStrategyClientTypes.IPAddressBasedRemoteInfo]? = nil,
            pipelineInfoList: [MigrationHubStrategyClientTypes.PipelineInfo]? = nil,
            remoteSourceCodeAnalysisServerInfo: MigrationHubStrategyClientTypes.RemoteSourceCodeAnalysisServerInfo? = nil,
            vcenterBasedRemoteInfoList: [MigrationHubStrategyClientTypes.VcenterBasedRemoteInfo]? = nil,
            versionControlInfoList: [MigrationHubStrategyClientTypes.VersionControlInfo]? = nil
        )
        {
            self.ipAddressBasedRemoteInfoList = ipAddressBasedRemoteInfoList
            self.pipelineInfoList = pipelineInfoList
            self.remoteSourceCodeAnalysisServerInfo = remoteSourceCodeAnalysisServerInfo
            self.vcenterBasedRemoteInfoList = vcenterBasedRemoteInfoList
            self.versionControlInfoList = versionControlInfoList
        }
    }

}

extension ConflictException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Exception to indicate that there is an ongoing task when a new task is created. Return when once the existing tasks are complete.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MigrationHubStrategyClientTypes.DataCollectionDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case completionTime
        case failed
        case inProgress
        case servers
        case startTime
        case status
        case statusMessage
        case success
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let completionTime = self.completionTime {
            try encodeContainer.encodeTimestamp(completionTime, format: .epochSeconds, forKey: .completionTime)
        }
        if let failed = self.failed {
            try encodeContainer.encode(failed, forKey: .failed)
        }
        if let inProgress = self.inProgress {
            try encodeContainer.encode(inProgress, forKey: .inProgress)
        }
        if let servers = self.servers {
            try encodeContainer.encode(servers, forKey: .servers)
        }
        if let startTime = self.startTime {
            try encodeContainer.encodeTimestamp(startTime, format: .epochSeconds, forKey: .startTime)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusMessage = self.statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
        if let success = self.success {
            try encodeContainer.encode(success, forKey: .success)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(MigrationHubStrategyClientTypes.AssessmentStatus.self, forKey: .status)
        status = statusDecoded
        let serversDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .servers)
        servers = serversDecoded
        let failedDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .failed)
        failed = failedDecoded
        let successDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .success)
        success = successDecoded
        let inProgressDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .inProgress)
        inProgress = inProgressDecoded
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startTime)
        startTime = startTimeDecoded
        let completionTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .completionTime)
        completionTime = completionTimeDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
    }
}

extension MigrationHubStrategyClientTypes {
    /// Detailed information about an assessment.
    public struct DataCollectionDetails: Swift.Equatable {
        /// The time the assessment completes.
        public var completionTime: ClientRuntime.Date?
        /// The number of failed servers in the assessment.
        public var failed: Swift.Int?
        /// The number of servers with the assessment status IN_PROGESS.
        public var inProgress: Swift.Int?
        /// The total number of servers in the assessment.
        public var servers: Swift.Int?
        /// The start time of assessment.
        public var startTime: ClientRuntime.Date?
        /// The status of the assessment.
        public var status: MigrationHubStrategyClientTypes.AssessmentStatus?
        /// The status message of the assessment.
        public var statusMessage: Swift.String?
        /// The number of successful servers in the assessment.
        public var success: Swift.Int?

        public init(
            completionTime: ClientRuntime.Date? = nil,
            failed: Swift.Int? = nil,
            inProgress: Swift.Int? = nil,
            servers: Swift.Int? = nil,
            startTime: ClientRuntime.Date? = nil,
            status: MigrationHubStrategyClientTypes.AssessmentStatus? = nil,
            statusMessage: Swift.String? = nil,
            success: Swift.Int? = nil
        )
        {
            self.completionTime = completionTime
            self.failed = failed
            self.inProgress = inProgress
            self.servers = servers
            self.startTime = startTime
            self.status = status
            self.statusMessage = statusMessage
            self.success = success
        }
    }

}

extension MigrationHubStrategyClientTypes {
    public enum DataSourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ads
        case `import`
        case mpa
        case sdkUnknown(Swift.String)

        public static var allCases: [DataSourceType] {
            return [
                .ads,
                .import,
                .mpa,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ads: return "ApplicationDiscoveryService"
            case .import: return "Import"
            case .mpa: return "MPA"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DataSourceType(rawValue: rawValue) ?? DataSourceType.sdkUnknown(rawValue)
        }
    }
}

extension MigrationHubStrategyClientTypes.DatabaseConfigDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case secretName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let secretName = self.secretName {
            try encodeContainer.encode(secretName, forKey: .secretName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let secretNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretName)
        secretName = secretNameDecoded
    }
}

extension MigrationHubStrategyClientTypes {
    /// Configuration information used for assessing databases.
    public struct DatabaseConfigDetail: Swift.Equatable {
        /// AWS Secrets Manager key that holds the credentials that you use to connect to a database.
        public var secretName: Swift.String?

        public init(
            secretName: Swift.String? = nil
        )
        {
            self.secretName = secretName
        }
    }

}

extension MigrationHubStrategyClientTypes {
    public enum DatabaseManagementPreference: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case awsManaged
        case noPreference
        case selfManage
        case sdkUnknown(Swift.String)

        public static var allCases: [DatabaseManagementPreference] {
            return [
                .awsManaged,
                .noPreference,
                .selfManage,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .awsManaged: return "AWS-managed"
            case .noPreference: return "No preference"
            case .selfManage: return "Self-manage"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DatabaseManagementPreference(rawValue: rawValue) ?? DatabaseManagementPreference.sdkUnknown(rawValue)
        }
    }
}

extension MigrationHubStrategyClientTypes.DatabaseMigrationPreference: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case heterogeneous
        case homogeneous
        case nopreference = "noPreference"
        case sdkUnknown
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .heterogeneous(heterogeneous):
                try container.encode(heterogeneous, forKey: .heterogeneous)
            case let .homogeneous(homogeneous):
                try container.encode(homogeneous, forKey: .homogeneous)
            case let .nopreference(nopreference):
                try container.encode(nopreference, forKey: .nopreference)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let heterogeneousDecoded = try values.decodeIfPresent(MigrationHubStrategyClientTypes.Heterogeneous.self, forKey: .heterogeneous)
        if let heterogeneous = heterogeneousDecoded {
            self = .heterogeneous(heterogeneous)
            return
        }
        let homogeneousDecoded = try values.decodeIfPresent(MigrationHubStrategyClientTypes.Homogeneous.self, forKey: .homogeneous)
        if let homogeneous = homogeneousDecoded {
            self = .homogeneous(homogeneous)
            return
        }
        let nopreferenceDecoded = try values.decodeIfPresent(MigrationHubStrategyClientTypes.NoDatabaseMigrationPreference.self, forKey: .nopreference)
        if let nopreference = nopreferenceDecoded {
            self = .nopreference(nopreference)
            return
        }
        self = .sdkUnknown("")
    }
}

extension MigrationHubStrategyClientTypes {
    /// Preferences for migrating a database to AWS.
    public enum DatabaseMigrationPreference: Swift.Equatable {
        /// Indicates whether you are interested in moving from one type of database to another. For example, from SQL Server to Amazon Aurora MySQL-Compatible Edition.
        case heterogeneous(MigrationHubStrategyClientTypes.Heterogeneous)
        /// Indicates whether you are interested in moving to the same type of database into AWS. For example, from SQL Server in your environment to SQL Server on AWS.
        case homogeneous(MigrationHubStrategyClientTypes.Homogeneous)
        /// Indicated that you do not prefer heterogeneous or homogeneous.
        case nopreference(MigrationHubStrategyClientTypes.NoDatabaseMigrationPreference)
        case sdkUnknown(Swift.String)
    }

}

extension MigrationHubStrategyClientTypes.DatabasePreferences: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case databaseManagementPreference
        case databaseMigrationPreference
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let databaseManagementPreference = self.databaseManagementPreference {
            try encodeContainer.encode(databaseManagementPreference.rawValue, forKey: .databaseManagementPreference)
        }
        if let databaseMigrationPreference = self.databaseMigrationPreference {
            try encodeContainer.encode(databaseMigrationPreference, forKey: .databaseMigrationPreference)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let databaseManagementPreferenceDecoded = try containerValues.decodeIfPresent(MigrationHubStrategyClientTypes.DatabaseManagementPreference.self, forKey: .databaseManagementPreference)
        databaseManagementPreference = databaseManagementPreferenceDecoded
        let databaseMigrationPreferenceDecoded = try containerValues.decodeIfPresent(MigrationHubStrategyClientTypes.DatabaseMigrationPreference.self, forKey: .databaseMigrationPreference)
        databaseMigrationPreference = databaseMigrationPreferenceDecoded
    }
}

extension MigrationHubStrategyClientTypes {
    /// Preferences on managing your databases on AWS.
    public struct DatabasePreferences: Swift.Equatable {
        /// Specifies whether you're interested in self-managed databases or databases managed by AWS.
        public var databaseManagementPreference: MigrationHubStrategyClientTypes.DatabaseManagementPreference?
        /// Specifies your preferred migration path.
        public var databaseMigrationPreference: MigrationHubStrategyClientTypes.DatabaseMigrationPreference?

        public init(
            databaseManagementPreference: MigrationHubStrategyClientTypes.DatabaseManagementPreference? = nil,
            databaseMigrationPreference: MigrationHubStrategyClientTypes.DatabaseMigrationPreference? = nil
        )
        {
            self.databaseManagementPreference = databaseManagementPreference
            self.databaseMigrationPreference = databaseMigrationPreference
        }
    }

}

extension DependencyException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DependencyExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Dependency encountered an error.
public struct DependencyException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "DependencyException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct DependencyExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension DependencyExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension GetApplicationComponentDetailsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let applicationComponentId = applicationComponentId else {
            return nil
        }
        return "/get-applicationcomponent-details/\(applicationComponentId.urlPercentEncoding())"
    }
}

public struct GetApplicationComponentDetailsInput: Swift.Equatable {
    /// The ID of the application component. The ID is unique within an AWS account.
    /// This member is required.
    public var applicationComponentId: Swift.String?

    public init(
        applicationComponentId: Swift.String? = nil
    )
    {
        self.applicationComponentId = applicationComponentId
    }
}

struct GetApplicationComponentDetailsInputBody: Swift.Equatable {
}

extension GetApplicationComponentDetailsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetApplicationComponentDetailsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetApplicationComponentDetailsOutputBody = try responseDecoder.decode(responseBody: data)
            self.applicationComponentDetail = output.applicationComponentDetail
            self.associatedApplications = output.associatedApplications
            self.associatedServerIds = output.associatedServerIds
            self.moreApplicationResource = output.moreApplicationResource
        } else {
            self.applicationComponentDetail = nil
            self.associatedApplications = nil
            self.associatedServerIds = nil
            self.moreApplicationResource = nil
        }
    }
}

public struct GetApplicationComponentDetailsOutput: Swift.Equatable {
    /// Detailed information about an application component.
    public var applicationComponentDetail: MigrationHubStrategyClientTypes.ApplicationComponentDetail?
    /// The associated application group as defined in AWS Application Discovery Service.
    public var associatedApplications: [MigrationHubStrategyClientTypes.AssociatedApplication]?
    /// A list of the IDs of the servers on which the application component is running.
    public var associatedServerIds: [Swift.String]?
    /// Set to true if the application component belongs to more than one application group.
    public var moreApplicationResource: Swift.Bool?

    public init(
        applicationComponentDetail: MigrationHubStrategyClientTypes.ApplicationComponentDetail? = nil,
        associatedApplications: [MigrationHubStrategyClientTypes.AssociatedApplication]? = nil,
        associatedServerIds: [Swift.String]? = nil,
        moreApplicationResource: Swift.Bool? = nil
    )
    {
        self.applicationComponentDetail = applicationComponentDetail
        self.associatedApplications = associatedApplications
        self.associatedServerIds = associatedServerIds
        self.moreApplicationResource = moreApplicationResource
    }
}

struct GetApplicationComponentDetailsOutputBody: Swift.Equatable {
    let applicationComponentDetail: MigrationHubStrategyClientTypes.ApplicationComponentDetail?
    let associatedApplications: [MigrationHubStrategyClientTypes.AssociatedApplication]?
    let moreApplicationResource: Swift.Bool?
    let associatedServerIds: [Swift.String]?
}

extension GetApplicationComponentDetailsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationComponentDetail
        case associatedApplications
        case associatedServerIds
        case moreApplicationResource
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationComponentDetailDecoded = try containerValues.decodeIfPresent(MigrationHubStrategyClientTypes.ApplicationComponentDetail.self, forKey: .applicationComponentDetail)
        applicationComponentDetail = applicationComponentDetailDecoded
        let associatedApplicationsContainer = try containerValues.decodeIfPresent([MigrationHubStrategyClientTypes.AssociatedApplication?].self, forKey: .associatedApplications)
        var associatedApplicationsDecoded0:[MigrationHubStrategyClientTypes.AssociatedApplication]? = nil
        if let associatedApplicationsContainer = associatedApplicationsContainer {
            associatedApplicationsDecoded0 = [MigrationHubStrategyClientTypes.AssociatedApplication]()
            for structure0 in associatedApplicationsContainer {
                if let structure0 = structure0 {
                    associatedApplicationsDecoded0?.append(structure0)
                }
            }
        }
        associatedApplications = associatedApplicationsDecoded0
        let moreApplicationResourceDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .moreApplicationResource)
        moreApplicationResource = moreApplicationResourceDecoded
        let associatedServerIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .associatedServerIds)
        var associatedServerIdsDecoded0:[Swift.String]? = nil
        if let associatedServerIdsContainer = associatedServerIdsContainer {
            associatedServerIdsDecoded0 = [Swift.String]()
            for string0 in associatedServerIdsContainer {
                if let string0 = string0 {
                    associatedServerIdsDecoded0?.append(string0)
                }
            }
        }
        associatedServerIds = associatedServerIdsDecoded0
    }
}

enum GetApplicationComponentDetailsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetApplicationComponentStrategiesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let applicationComponentId = applicationComponentId else {
            return nil
        }
        return "/get-applicationcomponent-strategies/\(applicationComponentId.urlPercentEncoding())"
    }
}

public struct GetApplicationComponentStrategiesInput: Swift.Equatable {
    /// The ID of the application component. The ID is unique within an AWS account.
    /// This member is required.
    public var applicationComponentId: Swift.String?

    public init(
        applicationComponentId: Swift.String? = nil
    )
    {
        self.applicationComponentId = applicationComponentId
    }
}

struct GetApplicationComponentStrategiesInputBody: Swift.Equatable {
}

extension GetApplicationComponentStrategiesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetApplicationComponentStrategiesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetApplicationComponentStrategiesOutputBody = try responseDecoder.decode(responseBody: data)
            self.applicationComponentStrategies = output.applicationComponentStrategies
        } else {
            self.applicationComponentStrategies = nil
        }
    }
}

public struct GetApplicationComponentStrategiesOutput: Swift.Equatable {
    /// A list of application component strategy recommendations.
    public var applicationComponentStrategies: [MigrationHubStrategyClientTypes.ApplicationComponentStrategy]?

    public init(
        applicationComponentStrategies: [MigrationHubStrategyClientTypes.ApplicationComponentStrategy]? = nil
    )
    {
        self.applicationComponentStrategies = applicationComponentStrategies
    }
}

struct GetApplicationComponentStrategiesOutputBody: Swift.Equatable {
    let applicationComponentStrategies: [MigrationHubStrategyClientTypes.ApplicationComponentStrategy]?
}

extension GetApplicationComponentStrategiesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationComponentStrategies
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationComponentStrategiesContainer = try containerValues.decodeIfPresent([MigrationHubStrategyClientTypes.ApplicationComponentStrategy?].self, forKey: .applicationComponentStrategies)
        var applicationComponentStrategiesDecoded0:[MigrationHubStrategyClientTypes.ApplicationComponentStrategy]? = nil
        if let applicationComponentStrategiesContainer = applicationComponentStrategiesContainer {
            applicationComponentStrategiesDecoded0 = [MigrationHubStrategyClientTypes.ApplicationComponentStrategy]()
            for structure0 in applicationComponentStrategiesContainer {
                if let structure0 = structure0 {
                    applicationComponentStrategiesDecoded0?.append(structure0)
                }
            }
        }
        applicationComponentStrategies = applicationComponentStrategiesDecoded0
    }
}

enum GetApplicationComponentStrategiesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetAssessmentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/get-assessment/\(id.urlPercentEncoding())"
    }
}

public struct GetAssessmentInput: Swift.Equatable {
    /// The assessmentid returned by [StartAssessment].
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct GetAssessmentInputBody: Swift.Equatable {
}

extension GetAssessmentInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetAssessmentOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetAssessmentOutputBody = try responseDecoder.decode(responseBody: data)
            self.assessmentTargets = output.assessmentTargets
            self.dataCollectionDetails = output.dataCollectionDetails
            self.id = output.id
        } else {
            self.assessmentTargets = nil
            self.dataCollectionDetails = nil
            self.id = nil
        }
    }
}

public struct GetAssessmentOutput: Swift.Equatable {
    /// List of criteria for assessment.
    public var assessmentTargets: [MigrationHubStrategyClientTypes.AssessmentTarget]?
    /// Detailed information about the assessment.
    public var dataCollectionDetails: MigrationHubStrategyClientTypes.DataCollectionDetails?
    /// The ID for the specific assessment task.
    public var id: Swift.String?

    public init(
        assessmentTargets: [MigrationHubStrategyClientTypes.AssessmentTarget]? = nil,
        dataCollectionDetails: MigrationHubStrategyClientTypes.DataCollectionDetails? = nil,
        id: Swift.String? = nil
    )
    {
        self.assessmentTargets = assessmentTargets
        self.dataCollectionDetails = dataCollectionDetails
        self.id = id
    }
}

struct GetAssessmentOutputBody: Swift.Equatable {
    let id: Swift.String?
    let dataCollectionDetails: MigrationHubStrategyClientTypes.DataCollectionDetails?
    let assessmentTargets: [MigrationHubStrategyClientTypes.AssessmentTarget]?
}

extension GetAssessmentOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentTargets
        case dataCollectionDetails
        case id
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let dataCollectionDetailsDecoded = try containerValues.decodeIfPresent(MigrationHubStrategyClientTypes.DataCollectionDetails.self, forKey: .dataCollectionDetails)
        dataCollectionDetails = dataCollectionDetailsDecoded
        let assessmentTargetsContainer = try containerValues.decodeIfPresent([MigrationHubStrategyClientTypes.AssessmentTarget?].self, forKey: .assessmentTargets)
        var assessmentTargetsDecoded0:[MigrationHubStrategyClientTypes.AssessmentTarget]? = nil
        if let assessmentTargetsContainer = assessmentTargetsContainer {
            assessmentTargetsDecoded0 = [MigrationHubStrategyClientTypes.AssessmentTarget]()
            for structure0 in assessmentTargetsContainer {
                if let structure0 = structure0 {
                    assessmentTargetsDecoded0?.append(structure0)
                }
            }
        }
        assessmentTargets = assessmentTargetsDecoded0
    }
}

enum GetAssessmentOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetImportFileTaskInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/get-import-file-task/\(id.urlPercentEncoding())"
    }
}

public struct GetImportFileTaskInput: Swift.Equatable {
    /// The ID of the import file task. This ID is returned in the response of [StartImportFileTask].
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct GetImportFileTaskInputBody: Swift.Equatable {
}

extension GetImportFileTaskInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetImportFileTaskOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetImportFileTaskOutputBody = try responseDecoder.decode(responseBody: data)
            self.completionTime = output.completionTime
            self.id = output.id
            self.importName = output.importName
            self.inputS3Bucket = output.inputS3Bucket
            self.inputS3Key = output.inputS3Key
            self.numberOfRecordsFailed = output.numberOfRecordsFailed
            self.numberOfRecordsSuccess = output.numberOfRecordsSuccess
            self.startTime = output.startTime
            self.status = output.status
            self.statusReportS3Bucket = output.statusReportS3Bucket
            self.statusReportS3Key = output.statusReportS3Key
        } else {
            self.completionTime = nil
            self.id = nil
            self.importName = nil
            self.inputS3Bucket = nil
            self.inputS3Key = nil
            self.numberOfRecordsFailed = nil
            self.numberOfRecordsSuccess = nil
            self.startTime = nil
            self.status = nil
            self.statusReportS3Bucket = nil
            self.statusReportS3Key = nil
        }
    }
}

public struct GetImportFileTaskOutput: Swift.Equatable {
    /// The time that the import task completed.
    public var completionTime: ClientRuntime.Date?
    /// The import file task id returned in the response of [StartImportFileTask].
    public var id: Swift.String?
    /// The name of the import task given in [StartImportFileTask].
    public var importName: Swift.String?
    /// The S3 bucket where import file is located.
    public var inputS3Bucket: Swift.String?
    /// The Amazon S3 key name of the import file.
    public var inputS3Key: Swift.String?
    /// The number of records that failed to be imported.
    public var numberOfRecordsFailed: Swift.Int?
    /// The number of records successfully imported.
    public var numberOfRecordsSuccess: Swift.Int?
    /// Start time of the import task.
    public var startTime: ClientRuntime.Date?
    /// Status of import file task.
    public var status: MigrationHubStrategyClientTypes.ImportFileTaskStatus?
    /// The S3 bucket name for status report of import task.
    public var statusReportS3Bucket: Swift.String?
    /// The Amazon S3 key name for status report of import task. The report contains details about whether each record imported successfully or why it did not.
    public var statusReportS3Key: Swift.String?

    public init(
        completionTime: ClientRuntime.Date? = nil,
        id: Swift.String? = nil,
        importName: Swift.String? = nil,
        inputS3Bucket: Swift.String? = nil,
        inputS3Key: Swift.String? = nil,
        numberOfRecordsFailed: Swift.Int? = nil,
        numberOfRecordsSuccess: Swift.Int? = nil,
        startTime: ClientRuntime.Date? = nil,
        status: MigrationHubStrategyClientTypes.ImportFileTaskStatus? = nil,
        statusReportS3Bucket: Swift.String? = nil,
        statusReportS3Key: Swift.String? = nil
    )
    {
        self.completionTime = completionTime
        self.id = id
        self.importName = importName
        self.inputS3Bucket = inputS3Bucket
        self.inputS3Key = inputS3Key
        self.numberOfRecordsFailed = numberOfRecordsFailed
        self.numberOfRecordsSuccess = numberOfRecordsSuccess
        self.startTime = startTime
        self.status = status
        self.statusReportS3Bucket = statusReportS3Bucket
        self.statusReportS3Key = statusReportS3Key
    }
}

struct GetImportFileTaskOutputBody: Swift.Equatable {
    let id: Swift.String?
    let status: MigrationHubStrategyClientTypes.ImportFileTaskStatus?
    let startTime: ClientRuntime.Date?
    let inputS3Bucket: Swift.String?
    let inputS3Key: Swift.String?
    let statusReportS3Bucket: Swift.String?
    let statusReportS3Key: Swift.String?
    let completionTime: ClientRuntime.Date?
    let numberOfRecordsSuccess: Swift.Int?
    let numberOfRecordsFailed: Swift.Int?
    let importName: Swift.String?
}

extension GetImportFileTaskOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case completionTime
        case id
        case importName
        case inputS3Bucket
        case inputS3Key
        case numberOfRecordsFailed
        case numberOfRecordsSuccess
        case startTime
        case status
        case statusReportS3Bucket
        case statusReportS3Key
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let statusDecoded = try containerValues.decodeIfPresent(MigrationHubStrategyClientTypes.ImportFileTaskStatus.self, forKey: .status)
        status = statusDecoded
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startTime)
        startTime = startTimeDecoded
        let inputS3BucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .inputS3Bucket)
        inputS3Bucket = inputS3BucketDecoded
        let inputS3KeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .inputS3Key)
        inputS3Key = inputS3KeyDecoded
        let statusReportS3BucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusReportS3Bucket)
        statusReportS3Bucket = statusReportS3BucketDecoded
        let statusReportS3KeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusReportS3Key)
        statusReportS3Key = statusReportS3KeyDecoded
        let completionTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .completionTime)
        completionTime = completionTimeDecoded
        let numberOfRecordsSuccessDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numberOfRecordsSuccess)
        numberOfRecordsSuccess = numberOfRecordsSuccessDecoded
        let numberOfRecordsFailedDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numberOfRecordsFailed)
        numberOfRecordsFailed = numberOfRecordsFailedDecoded
        let importNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .importName)
        importName = importNameDecoded
    }
}

enum GetImportFileTaskOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetLatestAssessmentIdInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/get-latest-assessment-id"
    }
}

public struct GetLatestAssessmentIdInput: Swift.Equatable {

    public init() { }
}

struct GetLatestAssessmentIdInputBody: Swift.Equatable {
}

extension GetLatestAssessmentIdInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetLatestAssessmentIdOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetLatestAssessmentIdOutputBody = try responseDecoder.decode(responseBody: data)
            self.id = output.id
        } else {
            self.id = nil
        }
    }
}

public struct GetLatestAssessmentIdOutput: Swift.Equatable {
    /// The latest ID for the specific assessment task.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct GetLatestAssessmentIdOutputBody: Swift.Equatable {
    let id: Swift.String?
}

extension GetLatestAssessmentIdOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
    }
}

enum GetLatestAssessmentIdOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "DependencyException": return try await DependencyException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetPortfolioPreferencesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/get-portfolio-preferences"
    }
}

public struct GetPortfolioPreferencesInput: Swift.Equatable {

    public init() { }
}

struct GetPortfolioPreferencesInputBody: Swift.Equatable {
}

extension GetPortfolioPreferencesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetPortfolioPreferencesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetPortfolioPreferencesOutputBody = try responseDecoder.decode(responseBody: data)
            self.applicationMode = output.applicationMode
            self.applicationPreferences = output.applicationPreferences
            self.databasePreferences = output.databasePreferences
            self.prioritizeBusinessGoals = output.prioritizeBusinessGoals
        } else {
            self.applicationMode = nil
            self.applicationPreferences = nil
            self.databasePreferences = nil
            self.prioritizeBusinessGoals = nil
        }
    }
}

public struct GetPortfolioPreferencesOutput: Swift.Equatable {
    /// The classification for application component types.
    public var applicationMode: MigrationHubStrategyClientTypes.ApplicationMode?
    /// The transformation preferences for non-database applications.
    public var applicationPreferences: MigrationHubStrategyClientTypes.ApplicationPreferences?
    /// The transformation preferences for database applications.
    public var databasePreferences: MigrationHubStrategyClientTypes.DatabasePreferences?
    /// The rank of business goals based on priority.
    public var prioritizeBusinessGoals: MigrationHubStrategyClientTypes.PrioritizeBusinessGoals?

    public init(
        applicationMode: MigrationHubStrategyClientTypes.ApplicationMode? = nil,
        applicationPreferences: MigrationHubStrategyClientTypes.ApplicationPreferences? = nil,
        databasePreferences: MigrationHubStrategyClientTypes.DatabasePreferences? = nil,
        prioritizeBusinessGoals: MigrationHubStrategyClientTypes.PrioritizeBusinessGoals? = nil
    )
    {
        self.applicationMode = applicationMode
        self.applicationPreferences = applicationPreferences
        self.databasePreferences = databasePreferences
        self.prioritizeBusinessGoals = prioritizeBusinessGoals
    }
}

struct GetPortfolioPreferencesOutputBody: Swift.Equatable {
    let prioritizeBusinessGoals: MigrationHubStrategyClientTypes.PrioritizeBusinessGoals?
    let applicationPreferences: MigrationHubStrategyClientTypes.ApplicationPreferences?
    let databasePreferences: MigrationHubStrategyClientTypes.DatabasePreferences?
    let applicationMode: MigrationHubStrategyClientTypes.ApplicationMode?
}

extension GetPortfolioPreferencesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationMode
        case applicationPreferences
        case databasePreferences
        case prioritizeBusinessGoals
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let prioritizeBusinessGoalsDecoded = try containerValues.decodeIfPresent(MigrationHubStrategyClientTypes.PrioritizeBusinessGoals.self, forKey: .prioritizeBusinessGoals)
        prioritizeBusinessGoals = prioritizeBusinessGoalsDecoded
        let applicationPreferencesDecoded = try containerValues.decodeIfPresent(MigrationHubStrategyClientTypes.ApplicationPreferences.self, forKey: .applicationPreferences)
        applicationPreferences = applicationPreferencesDecoded
        let databasePreferencesDecoded = try containerValues.decodeIfPresent(MigrationHubStrategyClientTypes.DatabasePreferences.self, forKey: .databasePreferences)
        databasePreferences = databasePreferencesDecoded
        let applicationModeDecoded = try containerValues.decodeIfPresent(MigrationHubStrategyClientTypes.ApplicationMode.self, forKey: .applicationMode)
        applicationMode = applicationModeDecoded
    }
}

enum GetPortfolioPreferencesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetPortfolioSummaryInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/get-portfolio-summary"
    }
}

public struct GetPortfolioSummaryInput: Swift.Equatable {

    public init() { }
}

struct GetPortfolioSummaryInputBody: Swift.Equatable {
}

extension GetPortfolioSummaryInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetPortfolioSummaryOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetPortfolioSummaryOutputBody = try responseDecoder.decode(responseBody: data)
            self.assessmentSummary = output.assessmentSummary
        } else {
            self.assessmentSummary = nil
        }
    }
}

public struct GetPortfolioSummaryOutput: Swift.Equatable {
    /// An assessment summary for the portfolio including the number of servers to rehost and the overall number of anti-patterns.
    public var assessmentSummary: MigrationHubStrategyClientTypes.AssessmentSummary?

    public init(
        assessmentSummary: MigrationHubStrategyClientTypes.AssessmentSummary? = nil
    )
    {
        self.assessmentSummary = assessmentSummary
    }
}

struct GetPortfolioSummaryOutputBody: Swift.Equatable {
    let assessmentSummary: MigrationHubStrategyClientTypes.AssessmentSummary?
}

extension GetPortfolioSummaryOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentSummary
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assessmentSummaryDecoded = try containerValues.decodeIfPresent(MigrationHubStrategyClientTypes.AssessmentSummary.self, forKey: .assessmentSummary)
        assessmentSummary = assessmentSummaryDecoded
    }
}

enum GetPortfolioSummaryOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetRecommendationReportDetailsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let id = id else {
            return nil
        }
        return "/get-recommendation-report-details/\(id.urlPercentEncoding())"
    }
}

public struct GetRecommendationReportDetailsInput: Swift.Equatable {
    /// The recommendation report generation task id returned by [StartRecommendationReportGeneration].
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct GetRecommendationReportDetailsInputBody: Swift.Equatable {
}

extension GetRecommendationReportDetailsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetRecommendationReportDetailsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetRecommendationReportDetailsOutputBody = try responseDecoder.decode(responseBody: data)
            self.id = output.id
            self.recommendationReportDetails = output.recommendationReportDetails
        } else {
            self.id = nil
            self.recommendationReportDetails = nil
        }
    }
}

public struct GetRecommendationReportDetailsOutput: Swift.Equatable {
    /// The ID of the recommendation report generation task. See the response of [StartRecommendationReportGeneration].
    public var id: Swift.String?
    /// Detailed information about the recommendation report.
    public var recommendationReportDetails: MigrationHubStrategyClientTypes.RecommendationReportDetails?

    public init(
        id: Swift.String? = nil,
        recommendationReportDetails: MigrationHubStrategyClientTypes.RecommendationReportDetails? = nil
    )
    {
        self.id = id
        self.recommendationReportDetails = recommendationReportDetails
    }
}

struct GetRecommendationReportDetailsOutputBody: Swift.Equatable {
    let id: Swift.String?
    let recommendationReportDetails: MigrationHubStrategyClientTypes.RecommendationReportDetails?
}

extension GetRecommendationReportDetailsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
        case recommendationReportDetails
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let recommendationReportDetailsDecoded = try containerValues.decodeIfPresent(MigrationHubStrategyClientTypes.RecommendationReportDetails.self, forKey: .recommendationReportDetails)
        recommendationReportDetails = recommendationReportDetailsDecoded
    }
}

enum GetRecommendationReportDetailsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetServerDetailsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension GetServerDetailsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let serverId = serverId else {
            return nil
        }
        return "/get-server-details/\(serverId.urlPercentEncoding())"
    }
}

public struct GetServerDetailsInput: Swift.Equatable {
    /// The maximum number of items to include in the response. The maximum value is 100.
    public var maxResults: Swift.Int?
    /// The token from a previous call that you use to retrieve the next set of results. For example, if a previous call to this action returned 100 items, but you set maxResults to 10. You'll receive a set of 10 results along with a token. You then use the returned token to retrieve the next set of 10.
    public var nextToken: Swift.String?
    /// The ID of the server.
    /// This member is required.
    public var serverId: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        serverId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.serverId = serverId
    }
}

struct GetServerDetailsInputBody: Swift.Equatable {
}

extension GetServerDetailsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetServerDetailsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetServerDetailsOutputBody = try responseDecoder.decode(responseBody: data)
            self.associatedApplications = output.associatedApplications
            self.nextToken = output.nextToken
            self.serverDetail = output.serverDetail
        } else {
            self.associatedApplications = nil
            self.nextToken = nil
            self.serverDetail = nil
        }
    }
}

public struct GetServerDetailsOutput: Swift.Equatable {
    /// The associated application group the server belongs to, as defined in AWS Application Discovery Service.
    public var associatedApplications: [MigrationHubStrategyClientTypes.AssociatedApplication]?
    /// The token you use to retrieve the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?
    /// Detailed information about the server.
    public var serverDetail: MigrationHubStrategyClientTypes.ServerDetail?

    public init(
        associatedApplications: [MigrationHubStrategyClientTypes.AssociatedApplication]? = nil,
        nextToken: Swift.String? = nil,
        serverDetail: MigrationHubStrategyClientTypes.ServerDetail? = nil
    )
    {
        self.associatedApplications = associatedApplications
        self.nextToken = nextToken
        self.serverDetail = serverDetail
    }
}

struct GetServerDetailsOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let serverDetail: MigrationHubStrategyClientTypes.ServerDetail?
    let associatedApplications: [MigrationHubStrategyClientTypes.AssociatedApplication]?
}

extension GetServerDetailsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associatedApplications
        case nextToken
        case serverDetail
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let serverDetailDecoded = try containerValues.decodeIfPresent(MigrationHubStrategyClientTypes.ServerDetail.self, forKey: .serverDetail)
        serverDetail = serverDetailDecoded
        let associatedApplicationsContainer = try containerValues.decodeIfPresent([MigrationHubStrategyClientTypes.AssociatedApplication?].self, forKey: .associatedApplications)
        var associatedApplicationsDecoded0:[MigrationHubStrategyClientTypes.AssociatedApplication]? = nil
        if let associatedApplicationsContainer = associatedApplicationsContainer {
            associatedApplicationsDecoded0 = [MigrationHubStrategyClientTypes.AssociatedApplication]()
            for structure0 in associatedApplicationsContainer {
                if let structure0 = structure0 {
                    associatedApplicationsDecoded0?.append(structure0)
                }
            }
        }
        associatedApplications = associatedApplicationsDecoded0
    }
}

enum GetServerDetailsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetServerStrategiesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let serverId = serverId else {
            return nil
        }
        return "/get-server-strategies/\(serverId.urlPercentEncoding())"
    }
}

public struct GetServerStrategiesInput: Swift.Equatable {
    /// The ID of the server.
    /// This member is required.
    public var serverId: Swift.String?

    public init(
        serverId: Swift.String? = nil
    )
    {
        self.serverId = serverId
    }
}

struct GetServerStrategiesInputBody: Swift.Equatable {
}

extension GetServerStrategiesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetServerStrategiesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetServerStrategiesOutputBody = try responseDecoder.decode(responseBody: data)
            self.serverStrategies = output.serverStrategies
        } else {
            self.serverStrategies = nil
        }
    }
}

public struct GetServerStrategiesOutput: Swift.Equatable {
    /// A list of strategy recommendations for the server.
    public var serverStrategies: [MigrationHubStrategyClientTypes.ServerStrategy]?

    public init(
        serverStrategies: [MigrationHubStrategyClientTypes.ServerStrategy]? = nil
    )
    {
        self.serverStrategies = serverStrategies
    }
}

struct GetServerStrategiesOutputBody: Swift.Equatable {
    let serverStrategies: [MigrationHubStrategyClientTypes.ServerStrategy]?
}

extension GetServerStrategiesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serverStrategies
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverStrategiesContainer = try containerValues.decodeIfPresent([MigrationHubStrategyClientTypes.ServerStrategy?].self, forKey: .serverStrategies)
        var serverStrategiesDecoded0:[MigrationHubStrategyClientTypes.ServerStrategy]? = nil
        if let serverStrategiesContainer = serverStrategiesContainer {
            serverStrategiesDecoded0 = [MigrationHubStrategyClientTypes.ServerStrategy]()
            for structure0 in serverStrategiesContainer {
                if let structure0 = structure0 {
                    serverStrategiesDecoded0?.append(structure0)
                }
            }
        }
        serverStrategies = serverStrategiesDecoded0
    }
}

enum GetServerStrategiesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension MigrationHubStrategyClientTypes.Group: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(MigrationHubStrategyClientTypes.GroupName.self, forKey: .name)
        name = nameDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension MigrationHubStrategyClientTypes {
    /// The object containing information about distinct imports or groups for Strategy Recommendations.
    public struct Group: Swift.Equatable {
        /// The key of the specific import group.
        public var name: MigrationHubStrategyClientTypes.GroupName?
        /// The value of the specific import group.
        public var value: Swift.String?

        public init(
            name: MigrationHubStrategyClientTypes.GroupName? = nil,
            value: Swift.String? = nil
        )
        {
            self.name = name
            self.value = value
        }
    }

}

extension MigrationHubStrategyClientTypes {
    public enum GroupName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case externalId
        case externalSourceType
        case sdkUnknown(Swift.String)

        public static var allCases: [GroupName] {
            return [
                .externalId,
                .externalSourceType,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .externalId: return "ExternalId"
            case .externalSourceType: return "ExternalSourceType"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = GroupName(rawValue: rawValue) ?? GroupName.sdkUnknown(rawValue)
        }
    }
}

extension MigrationHubStrategyClientTypes.Heterogeneous: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case targetDatabaseEngine
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let targetDatabaseEngine = targetDatabaseEngine {
            var targetDatabaseEngineContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targetDatabaseEngine)
            for heterogeneoustargetdatabaseengine0 in targetDatabaseEngine {
                try targetDatabaseEngineContainer.encode(heterogeneoustargetdatabaseengine0.rawValue)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetDatabaseEngineContainer = try containerValues.decodeIfPresent([MigrationHubStrategyClientTypes.HeterogeneousTargetDatabaseEngine?].self, forKey: .targetDatabaseEngine)
        var targetDatabaseEngineDecoded0:[MigrationHubStrategyClientTypes.HeterogeneousTargetDatabaseEngine]? = nil
        if let targetDatabaseEngineContainer = targetDatabaseEngineContainer {
            targetDatabaseEngineDecoded0 = [MigrationHubStrategyClientTypes.HeterogeneousTargetDatabaseEngine]()
            for string0 in targetDatabaseEngineContainer {
                if let string0 = string0 {
                    targetDatabaseEngineDecoded0?.append(string0)
                }
            }
        }
        targetDatabaseEngine = targetDatabaseEngineDecoded0
    }
}

extension MigrationHubStrategyClientTypes {
    /// The object containing details about heterogeneous database preferences.
    public struct Heterogeneous: Swift.Equatable {
        /// The target database engine for heterogeneous database migration preference.
        /// This member is required.
        public var targetDatabaseEngine: [MigrationHubStrategyClientTypes.HeterogeneousTargetDatabaseEngine]?

        public init(
            targetDatabaseEngine: [MigrationHubStrategyClientTypes.HeterogeneousTargetDatabaseEngine]? = nil
        )
        {
            self.targetDatabaseEngine = targetDatabaseEngine
        }
    }

}

extension MigrationHubStrategyClientTypes {
    public enum HeterogeneousTargetDatabaseEngine: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case amazonAurora
        case awsPostgresql
        case db2Luw
        case mariaDb
        case microsoftSqlServer
        case mongoDb
        case mysql
        case noneSpecified
        case oracleDatabase
        case sap
        case sdkUnknown(Swift.String)

        public static var allCases: [HeterogeneousTargetDatabaseEngine] {
            return [
                .amazonAurora,
                .awsPostgresql,
                .db2Luw,
                .mariaDb,
                .microsoftSqlServer,
                .mongoDb,
                .mysql,
                .noneSpecified,
                .oracleDatabase,
                .sap,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .amazonAurora: return "Amazon Aurora"
            case .awsPostgresql: return "AWS PostgreSQL"
            case .db2Luw: return "Db2 LUW"
            case .mariaDb: return "MariaDB"
            case .microsoftSqlServer: return "Microsoft SQL Server"
            case .mongoDb: return "MongoDB"
            case .mysql: return "MySQL"
            case .noneSpecified: return "None specified"
            case .oracleDatabase: return "Oracle Database"
            case .sap: return "SAP"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = HeterogeneousTargetDatabaseEngine(rawValue: rawValue) ?? HeterogeneousTargetDatabaseEngine.sdkUnknown(rawValue)
        }
    }
}

extension MigrationHubStrategyClientTypes.Homogeneous: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case targetDatabaseEngine
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let targetDatabaseEngine = targetDatabaseEngine {
            var targetDatabaseEngineContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targetDatabaseEngine)
            for homogeneoustargetdatabaseengine0 in targetDatabaseEngine {
                try targetDatabaseEngineContainer.encode(homogeneoustargetdatabaseengine0.rawValue)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetDatabaseEngineContainer = try containerValues.decodeIfPresent([MigrationHubStrategyClientTypes.HomogeneousTargetDatabaseEngine?].self, forKey: .targetDatabaseEngine)
        var targetDatabaseEngineDecoded0:[MigrationHubStrategyClientTypes.HomogeneousTargetDatabaseEngine]? = nil
        if let targetDatabaseEngineContainer = targetDatabaseEngineContainer {
            targetDatabaseEngineDecoded0 = [MigrationHubStrategyClientTypes.HomogeneousTargetDatabaseEngine]()
            for string0 in targetDatabaseEngineContainer {
                if let string0 = string0 {
                    targetDatabaseEngineDecoded0?.append(string0)
                }
            }
        }
        targetDatabaseEngine = targetDatabaseEngineDecoded0
    }
}

extension MigrationHubStrategyClientTypes {
    /// The object containing details about homogeneous database preferences.
    public struct Homogeneous: Swift.Equatable {
        /// The target database engine for homogeneous database migration preferences.
        public var targetDatabaseEngine: [MigrationHubStrategyClientTypes.HomogeneousTargetDatabaseEngine]?

        public init(
            targetDatabaseEngine: [MigrationHubStrategyClientTypes.HomogeneousTargetDatabaseEngine]? = nil
        )
        {
            self.targetDatabaseEngine = targetDatabaseEngine
        }
    }

}

extension MigrationHubStrategyClientTypes {
    public enum HomogeneousTargetDatabaseEngine: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case noneSpecified
        case sdkUnknown(Swift.String)

        public static var allCases: [HomogeneousTargetDatabaseEngine] {
            return [
                .noneSpecified,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .noneSpecified: return "None specified"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = HomogeneousTargetDatabaseEngine(rawValue: rawValue) ?? HomogeneousTargetDatabaseEngine.sdkUnknown(rawValue)
        }
    }
}

extension MigrationHubStrategyClientTypes.IPAddressBasedRemoteInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authType
        case ipAddressConfigurationTimeStamp
        case osType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authType = self.authType {
            try encodeContainer.encode(authType.rawValue, forKey: .authType)
        }
        if let ipAddressConfigurationTimeStamp = self.ipAddressConfigurationTimeStamp {
            try encodeContainer.encode(ipAddressConfigurationTimeStamp, forKey: .ipAddressConfigurationTimeStamp)
        }
        if let osType = self.osType {
            try encodeContainer.encode(osType.rawValue, forKey: .osType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ipAddressConfigurationTimeStampDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ipAddressConfigurationTimeStamp)
        ipAddressConfigurationTimeStamp = ipAddressConfigurationTimeStampDecoded
        let authTypeDecoded = try containerValues.decodeIfPresent(MigrationHubStrategyClientTypes.AuthType.self, forKey: .authType)
        authType = authTypeDecoded
        let osTypeDecoded = try containerValues.decodeIfPresent(MigrationHubStrategyClientTypes.OSType.self, forKey: .osType)
        osType = osTypeDecoded
    }
}

extension MigrationHubStrategyClientTypes {
    /// IP address based configurations.
    public struct IPAddressBasedRemoteInfo: Swift.Equatable {
        /// The type of authorization.
        public var authType: MigrationHubStrategyClientTypes.AuthType?
        /// The time stamp of the configuration.
        public var ipAddressConfigurationTimeStamp: Swift.String?
        /// The type of the operating system.
        public var osType: MigrationHubStrategyClientTypes.OSType?

        public init(
            authType: MigrationHubStrategyClientTypes.AuthType? = nil,
            ipAddressConfigurationTimeStamp: Swift.String? = nil,
            osType: MigrationHubStrategyClientTypes.OSType? = nil
        )
        {
            self.authType = authType
            self.ipAddressConfigurationTimeStamp = ipAddressConfigurationTimeStamp
            self.osType = osType
        }
    }

}

extension MigrationHubStrategyClientTypes.ImportFileTaskInformation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case completionTime
        case id
        case importName
        case inputS3Bucket
        case inputS3Key
        case numberOfRecordsFailed
        case numberOfRecordsSuccess
        case startTime
        case status
        case statusReportS3Bucket
        case statusReportS3Key
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let completionTime = self.completionTime {
            try encodeContainer.encodeTimestamp(completionTime, format: .epochSeconds, forKey: .completionTime)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let importName = self.importName {
            try encodeContainer.encode(importName, forKey: .importName)
        }
        if let inputS3Bucket = self.inputS3Bucket {
            try encodeContainer.encode(inputS3Bucket, forKey: .inputS3Bucket)
        }
        if let inputS3Key = self.inputS3Key {
            try encodeContainer.encode(inputS3Key, forKey: .inputS3Key)
        }
        if let numberOfRecordsFailed = self.numberOfRecordsFailed {
            try encodeContainer.encode(numberOfRecordsFailed, forKey: .numberOfRecordsFailed)
        }
        if let numberOfRecordsSuccess = self.numberOfRecordsSuccess {
            try encodeContainer.encode(numberOfRecordsSuccess, forKey: .numberOfRecordsSuccess)
        }
        if let startTime = self.startTime {
            try encodeContainer.encodeTimestamp(startTime, format: .epochSeconds, forKey: .startTime)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusReportS3Bucket = self.statusReportS3Bucket {
            try encodeContainer.encode(statusReportS3Bucket, forKey: .statusReportS3Bucket)
        }
        if let statusReportS3Key = self.statusReportS3Key {
            try encodeContainer.encode(statusReportS3Key, forKey: .statusReportS3Key)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let statusDecoded = try containerValues.decodeIfPresent(MigrationHubStrategyClientTypes.ImportFileTaskStatus.self, forKey: .status)
        status = statusDecoded
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startTime)
        startTime = startTimeDecoded
        let inputS3BucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .inputS3Bucket)
        inputS3Bucket = inputS3BucketDecoded
        let inputS3KeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .inputS3Key)
        inputS3Key = inputS3KeyDecoded
        let statusReportS3BucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusReportS3Bucket)
        statusReportS3Bucket = statusReportS3BucketDecoded
        let statusReportS3KeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusReportS3Key)
        statusReportS3Key = statusReportS3KeyDecoded
        let completionTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .completionTime)
        completionTime = completionTimeDecoded
        let numberOfRecordsSuccessDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numberOfRecordsSuccess)
        numberOfRecordsSuccess = numberOfRecordsSuccessDecoded
        let numberOfRecordsFailedDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numberOfRecordsFailed)
        numberOfRecordsFailed = numberOfRecordsFailedDecoded
        let importNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .importName)
        importName = importNameDecoded
    }
}

extension MigrationHubStrategyClientTypes {
    /// Information about the import file tasks you request.
    public struct ImportFileTaskInformation: Swift.Equatable {
        /// The time that the import task completes.
        public var completionTime: ClientRuntime.Date?
        /// The ID of the import file task.
        public var id: Swift.String?
        /// The name of the import task given in StartImportFileTask.
        public var importName: Swift.String?
        /// The S3 bucket where the import file is located.
        public var inputS3Bucket: Swift.String?
        /// The Amazon S3 key name of the import file.
        public var inputS3Key: Swift.String?
        /// The number of records that failed to be imported.
        public var numberOfRecordsFailed: Swift.Int?
        /// The number of records successfully imported.
        public var numberOfRecordsSuccess: Swift.Int?
        /// Start time of the import task.
        public var startTime: ClientRuntime.Date?
        /// Status of import file task.
        public var status: MigrationHubStrategyClientTypes.ImportFileTaskStatus?
        /// The S3 bucket name for status report of import task.
        public var statusReportS3Bucket: Swift.String?
        /// The Amazon S3 key name for status report of import task. The report contains details about whether each record imported successfully or why it did not.
        public var statusReportS3Key: Swift.String?

        public init(
            completionTime: ClientRuntime.Date? = nil,
            id: Swift.String? = nil,
            importName: Swift.String? = nil,
            inputS3Bucket: Swift.String? = nil,
            inputS3Key: Swift.String? = nil,
            numberOfRecordsFailed: Swift.Int? = nil,
            numberOfRecordsSuccess: Swift.Int? = nil,
            startTime: ClientRuntime.Date? = nil,
            status: MigrationHubStrategyClientTypes.ImportFileTaskStatus? = nil,
            statusReportS3Bucket: Swift.String? = nil,
            statusReportS3Key: Swift.String? = nil
        )
        {
            self.completionTime = completionTime
            self.id = id
            self.importName = importName
            self.inputS3Bucket = inputS3Bucket
            self.inputS3Key = inputS3Key
            self.numberOfRecordsFailed = numberOfRecordsFailed
            self.numberOfRecordsSuccess = numberOfRecordsSuccess
            self.startTime = startTime
            self.status = status
            self.statusReportS3Bucket = statusReportS3Bucket
            self.statusReportS3Key = statusReportS3Key
        }
    }

}

extension MigrationHubStrategyClientTypes {
    public enum ImportFileTaskStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case deleteFailed
        case deleteInProgress
        case deletePartialSuccess
        case deleteSuccess
        case importFailed
        case importInProgress
        case importPartialSuccess
        case importSuccess
        case sdkUnknown(Swift.String)

        public static var allCases: [ImportFileTaskStatus] {
            return [
                .deleteFailed,
                .deleteInProgress,
                .deletePartialSuccess,
                .deleteSuccess,
                .importFailed,
                .importInProgress,
                .importPartialSuccess,
                .importSuccess,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .deleteFailed: return "DeleteFailed"
            case .deleteInProgress: return "DeleteInProgress"
            case .deletePartialSuccess: return "DeletePartialSuccess"
            case .deleteSuccess: return "DeleteSuccess"
            case .importFailed: return "ImportFailed"
            case .importInProgress: return "ImportInProgress"
            case .importPartialSuccess: return "ImportPartialSuccess"
            case .importSuccess: return "ImportSuccess"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ImportFileTaskStatus(rawValue: rawValue) ?? ImportFileTaskStatus.sdkUnknown(rawValue)
        }
    }
}

extension MigrationHubStrategyClientTypes {
    public enum InclusionStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case excludeFromRecommendation
        case includeInRecommendation
        case sdkUnknown(Swift.String)

        public static var allCases: [InclusionStatus] {
            return [
                .excludeFromRecommendation,
                .includeInRecommendation,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .excludeFromRecommendation: return "excludeFromAssessment"
            case .includeInRecommendation: return "includeInAssessment"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = InclusionStatus(rawValue: rawValue) ?? InclusionStatus.sdkUnknown(rawValue)
        }
    }
}

extension InternalServerException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The server experienced an internal error. Try again.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListApplicationComponentsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationComponentCriteria
        case filterValue
        case groupIdFilter
        case maxResults
        case nextToken
        case sort
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationComponentCriteria = self.applicationComponentCriteria {
            try encodeContainer.encode(applicationComponentCriteria.rawValue, forKey: .applicationComponentCriteria)
        }
        if let filterValue = self.filterValue {
            try encodeContainer.encode(filterValue, forKey: .filterValue)
        }
        if let groupIdFilter = groupIdFilter {
            var groupIdFilterContainer = encodeContainer.nestedUnkeyedContainer(forKey: .groupIdFilter)
            for group0 in groupIdFilter {
                try groupIdFilterContainer.encode(group0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let sort = self.sort {
            try encodeContainer.encode(sort.rawValue, forKey: .sort)
        }
    }
}

extension ListApplicationComponentsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/list-applicationcomponents"
    }
}

public struct ListApplicationComponentsInput: Swift.Equatable {
    /// Criteria for filtering the list of application components.
    public var applicationComponentCriteria: MigrationHubStrategyClientTypes.ApplicationComponentCriteria?
    /// Specify the value based on the application component criteria type. For example, if applicationComponentCriteria is set to SERVER_ID and filterValue is set to server1, then [ListApplicationComponents] returns all the application components running on server1.
    public var filterValue: Swift.String?
    /// The group ID specified in to filter on.
    public var groupIdFilter: [MigrationHubStrategyClientTypes.Group]?
    /// The maximum number of items to include in the response. The maximum value is 100.
    public var maxResults: Swift.Int?
    /// The token from a previous call that you use to retrieve the next set of results. For example, if a previous call to this action returned 100 items, but you set maxResults to 10. You'll receive a set of 10 results along with a token. You then use the returned token to retrieve the next set of 10.
    public var nextToken: Swift.String?
    /// Specifies whether to sort by ascending (ASC) or descending (DESC) order.
    public var sort: MigrationHubStrategyClientTypes.SortOrder?

    public init(
        applicationComponentCriteria: MigrationHubStrategyClientTypes.ApplicationComponentCriteria? = nil,
        filterValue: Swift.String? = nil,
        groupIdFilter: [MigrationHubStrategyClientTypes.Group]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        sort: MigrationHubStrategyClientTypes.SortOrder? = nil
    )
    {
        self.applicationComponentCriteria = applicationComponentCriteria
        self.filterValue = filterValue
        self.groupIdFilter = groupIdFilter
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sort = sort
    }
}

struct ListApplicationComponentsInputBody: Swift.Equatable {
    let applicationComponentCriteria: MigrationHubStrategyClientTypes.ApplicationComponentCriteria?
    let filterValue: Swift.String?
    let sort: MigrationHubStrategyClientTypes.SortOrder?
    let groupIdFilter: [MigrationHubStrategyClientTypes.Group]?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListApplicationComponentsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationComponentCriteria
        case filterValue
        case groupIdFilter
        case maxResults
        case nextToken
        case sort
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationComponentCriteriaDecoded = try containerValues.decodeIfPresent(MigrationHubStrategyClientTypes.ApplicationComponentCriteria.self, forKey: .applicationComponentCriteria)
        applicationComponentCriteria = applicationComponentCriteriaDecoded
        let filterValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .filterValue)
        filterValue = filterValueDecoded
        let sortDecoded = try containerValues.decodeIfPresent(MigrationHubStrategyClientTypes.SortOrder.self, forKey: .sort)
        sort = sortDecoded
        let groupIdFilterContainer = try containerValues.decodeIfPresent([MigrationHubStrategyClientTypes.Group?].self, forKey: .groupIdFilter)
        var groupIdFilterDecoded0:[MigrationHubStrategyClientTypes.Group]? = nil
        if let groupIdFilterContainer = groupIdFilterContainer {
            groupIdFilterDecoded0 = [MigrationHubStrategyClientTypes.Group]()
            for structure0 in groupIdFilterContainer {
                if let structure0 = structure0 {
                    groupIdFilterDecoded0?.append(structure0)
                }
            }
        }
        groupIdFilter = groupIdFilterDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListApplicationComponentsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListApplicationComponentsOutputBody = try responseDecoder.decode(responseBody: data)
            self.applicationComponentInfos = output.applicationComponentInfos
            self.nextToken = output.nextToken
        } else {
            self.applicationComponentInfos = nil
            self.nextToken = nil
        }
    }
}

public struct ListApplicationComponentsOutput: Swift.Equatable {
    /// The list of application components with detailed information about each component.
    public var applicationComponentInfos: [MigrationHubStrategyClientTypes.ApplicationComponentDetail]?
    /// The token you use to retrieve the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?

    public init(
        applicationComponentInfos: [MigrationHubStrategyClientTypes.ApplicationComponentDetail]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.applicationComponentInfos = applicationComponentInfos
        self.nextToken = nextToken
    }
}

struct ListApplicationComponentsOutputBody: Swift.Equatable {
    let applicationComponentInfos: [MigrationHubStrategyClientTypes.ApplicationComponentDetail]?
    let nextToken: Swift.String?
}

extension ListApplicationComponentsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationComponentInfos
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationComponentInfosContainer = try containerValues.decodeIfPresent([MigrationHubStrategyClientTypes.ApplicationComponentDetail?].self, forKey: .applicationComponentInfos)
        var applicationComponentInfosDecoded0:[MigrationHubStrategyClientTypes.ApplicationComponentDetail]? = nil
        if let applicationComponentInfosContainer = applicationComponentInfosContainer {
            applicationComponentInfosDecoded0 = [MigrationHubStrategyClientTypes.ApplicationComponentDetail]()
            for structure0 in applicationComponentInfosContainer {
                if let structure0 = structure0 {
                    applicationComponentInfosDecoded0?.append(structure0)
                }
            }
        }
        applicationComponentInfos = applicationComponentInfosDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListApplicationComponentsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceLinkedRoleLockClientException": return try await ServiceLinkedRoleLockClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListCollectorsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListCollectorsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/list-collectors"
    }
}

public struct ListCollectorsInput: Swift.Equatable {
    /// The maximum number of items to include in the response. The maximum value is 100.
    public var maxResults: Swift.Int?
    /// The token from a previous call that you use to retrieve the next set of results. For example, if a previous call to this action returned 100 items, but you set maxResults to 10. You'll receive a set of 10 results along with a token. You then use the returned token to retrieve the next set of 10.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListCollectorsInputBody: Swift.Equatable {
}

extension ListCollectorsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListCollectorsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListCollectorsOutputBody = try responseDecoder.decode(responseBody: data)
            self.collectors = output.collectors
            self.nextToken = output.nextToken
        } else {
            self.collectors = nil
            self.nextToken = nil
        }
    }
}

public struct ListCollectorsOutput: Swift.Equatable {
    /// The list of all the installed collectors.
    public var collectors: [MigrationHubStrategyClientTypes.Collector]?
    /// The token you use to retrieve the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?

    public init(
        collectors: [MigrationHubStrategyClientTypes.Collector]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.collectors = collectors
        self.nextToken = nextToken
    }
}

struct ListCollectorsOutputBody: Swift.Equatable {
    let collectors: [MigrationHubStrategyClientTypes.Collector]?
    let nextToken: Swift.String?
}

extension ListCollectorsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case collectors = "Collectors"
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let collectorsContainer = try containerValues.decodeIfPresent([MigrationHubStrategyClientTypes.Collector?].self, forKey: .collectors)
        var collectorsDecoded0:[MigrationHubStrategyClientTypes.Collector]? = nil
        if let collectorsContainer = collectorsContainer {
            collectorsDecoded0 = [MigrationHubStrategyClientTypes.Collector]()
            for structure0 in collectorsContainer {
                if let structure0 = structure0 {
                    collectorsDecoded0?.append(structure0)
                }
            }
        }
        collectors = collectorsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListCollectorsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListImportFileTaskInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListImportFileTaskInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/list-import-file-task"
    }
}

public struct ListImportFileTaskInput: Swift.Equatable {
    /// The total number of items to return. The maximum value is 100.
    public var maxResults: Swift.Int?
    /// The token from a previous call that you use to retrieve the next set of results. For example, if a previous call to this action returned 100 items, but you set maxResults to 10. You'll receive a set of 10 results along with a token. You then use the returned token to retrieve the next set of 10.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListImportFileTaskInputBody: Swift.Equatable {
}

extension ListImportFileTaskInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListImportFileTaskOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListImportFileTaskOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.taskInfos = output.taskInfos
        } else {
            self.nextToken = nil
            self.taskInfos = nil
        }
    }
}

public struct ListImportFileTaskOutput: Swift.Equatable {
    /// The token you use to retrieve the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?
    /// Lists information about the files you import.
    public var taskInfos: [MigrationHubStrategyClientTypes.ImportFileTaskInformation]?

    public init(
        nextToken: Swift.String? = nil,
        taskInfos: [MigrationHubStrategyClientTypes.ImportFileTaskInformation]? = nil
    )
    {
        self.nextToken = nextToken
        self.taskInfos = taskInfos
    }
}

struct ListImportFileTaskOutputBody: Swift.Equatable {
    let taskInfos: [MigrationHubStrategyClientTypes.ImportFileTaskInformation]?
    let nextToken: Swift.String?
}

extension ListImportFileTaskOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case taskInfos
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let taskInfosContainer = try containerValues.decodeIfPresent([MigrationHubStrategyClientTypes.ImportFileTaskInformation?].self, forKey: .taskInfos)
        var taskInfosDecoded0:[MigrationHubStrategyClientTypes.ImportFileTaskInformation]? = nil
        if let taskInfosContainer = taskInfosContainer {
            taskInfosDecoded0 = [MigrationHubStrategyClientTypes.ImportFileTaskInformation]()
            for structure0 in taskInfosContainer {
                if let structure0 = structure0 {
                    taskInfosDecoded0?.append(structure0)
                }
            }
        }
        taskInfos = taskInfosDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListImportFileTaskOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListServersInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filterValue
        case groupIdFilter
        case maxResults
        case nextToken
        case serverCriteria
        case sort
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filterValue = self.filterValue {
            try encodeContainer.encode(filterValue, forKey: .filterValue)
        }
        if let groupIdFilter = groupIdFilter {
            var groupIdFilterContainer = encodeContainer.nestedUnkeyedContainer(forKey: .groupIdFilter)
            for group0 in groupIdFilter {
                try groupIdFilterContainer.encode(group0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let serverCriteria = self.serverCriteria {
            try encodeContainer.encode(serverCriteria.rawValue, forKey: .serverCriteria)
        }
        if let sort = self.sort {
            try encodeContainer.encode(sort.rawValue, forKey: .sort)
        }
    }
}

extension ListServersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/list-servers"
    }
}

public struct ListServersInput: Swift.Equatable {
    /// Specifies the filter value, which is based on the type of server criteria. For example, if serverCriteria is OS_NAME, and the filterValue is equal to WindowsServer, then ListServers returns all of the servers matching the OS name WindowsServer.
    public var filterValue: Swift.String?
    /// Specifies the group ID to filter on.
    public var groupIdFilter: [MigrationHubStrategyClientTypes.Group]?
    /// The maximum number of items to include in the response. The maximum value is 100.
    public var maxResults: Swift.Int?
    /// The token from a previous call that you use to retrieve the next set of results. For example, if a previous call to this action returned 100 items, but you set maxResults to 10. You'll receive a set of 10 results along with a token. You then use the returned token to retrieve the next set of 10.
    public var nextToken: Swift.String?
    /// Criteria for filtering servers.
    public var serverCriteria: MigrationHubStrategyClientTypes.ServerCriteria?
    /// Specifies whether to sort by ascending (ASC) or descending (DESC) order.
    public var sort: MigrationHubStrategyClientTypes.SortOrder?

    public init(
        filterValue: Swift.String? = nil,
        groupIdFilter: [MigrationHubStrategyClientTypes.Group]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        serverCriteria: MigrationHubStrategyClientTypes.ServerCriteria? = nil,
        sort: MigrationHubStrategyClientTypes.SortOrder? = nil
    )
    {
        self.filterValue = filterValue
        self.groupIdFilter = groupIdFilter
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.serverCriteria = serverCriteria
        self.sort = sort
    }
}

struct ListServersInputBody: Swift.Equatable {
    let serverCriteria: MigrationHubStrategyClientTypes.ServerCriteria?
    let filterValue: Swift.String?
    let sort: MigrationHubStrategyClientTypes.SortOrder?
    let groupIdFilter: [MigrationHubStrategyClientTypes.Group]?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension ListServersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filterValue
        case groupIdFilter
        case maxResults
        case nextToken
        case serverCriteria
        case sort
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverCriteriaDecoded = try containerValues.decodeIfPresent(MigrationHubStrategyClientTypes.ServerCriteria.self, forKey: .serverCriteria)
        serverCriteria = serverCriteriaDecoded
        let filterValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .filterValue)
        filterValue = filterValueDecoded
        let sortDecoded = try containerValues.decodeIfPresent(MigrationHubStrategyClientTypes.SortOrder.self, forKey: .sort)
        sort = sortDecoded
        let groupIdFilterContainer = try containerValues.decodeIfPresent([MigrationHubStrategyClientTypes.Group?].self, forKey: .groupIdFilter)
        var groupIdFilterDecoded0:[MigrationHubStrategyClientTypes.Group]? = nil
        if let groupIdFilterContainer = groupIdFilterContainer {
            groupIdFilterDecoded0 = [MigrationHubStrategyClientTypes.Group]()
            for structure0 in groupIdFilterContainer {
                if let structure0 = structure0 {
                    groupIdFilterDecoded0?.append(structure0)
                }
            }
        }
        groupIdFilter = groupIdFilterDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension ListServersOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListServersOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.serverInfos = output.serverInfos
        } else {
            self.nextToken = nil
            self.serverInfos = nil
        }
    }
}

public struct ListServersOutput: Swift.Equatable {
    /// The token you use to retrieve the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?
    /// The list of servers with detailed information about each server.
    public var serverInfos: [MigrationHubStrategyClientTypes.ServerDetail]?

    public init(
        nextToken: Swift.String? = nil,
        serverInfos: [MigrationHubStrategyClientTypes.ServerDetail]? = nil
    )
    {
        self.nextToken = nextToken
        self.serverInfos = serverInfos
    }
}

struct ListServersOutputBody: Swift.Equatable {
    let serverInfos: [MigrationHubStrategyClientTypes.ServerDetail]?
    let nextToken: Swift.String?
}

extension ListServersOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case serverInfos
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverInfosContainer = try containerValues.decodeIfPresent([MigrationHubStrategyClientTypes.ServerDetail?].self, forKey: .serverInfos)
        var serverInfosDecoded0:[MigrationHubStrategyClientTypes.ServerDetail]? = nil
        if let serverInfosContainer = serverInfosContainer {
            serverInfosDecoded0 = [MigrationHubStrategyClientTypes.ServerDetail]()
            for structure0 in serverInfosContainer {
                if let structure0 = structure0 {
                    serverInfosDecoded0?.append(structure0)
                }
            }
        }
        serverInfos = serverInfosDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListServersOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension MigrationHubStrategyClientTypes.ManagementPreference: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsmanagedresources = "awsManagedResources"
        case nopreference = "noPreference"
        case sdkUnknown
        case selfmanageresources = "selfManageResources"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .awsmanagedresources(awsmanagedresources):
                try container.encode(awsmanagedresources, forKey: .awsmanagedresources)
            case let .nopreference(nopreference):
                try container.encode(nopreference, forKey: .nopreference)
            case let .selfmanageresources(selfmanageresources):
                try container.encode(selfmanageresources, forKey: .selfmanageresources)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let awsmanagedresourcesDecoded = try values.decodeIfPresent(MigrationHubStrategyClientTypes.AwsManagedResources.self, forKey: .awsmanagedresources)
        if let awsmanagedresources = awsmanagedresourcesDecoded {
            self = .awsmanagedresources(awsmanagedresources)
            return
        }
        let selfmanageresourcesDecoded = try values.decodeIfPresent(MigrationHubStrategyClientTypes.SelfManageResources.self, forKey: .selfmanageresources)
        if let selfmanageresources = selfmanageresourcesDecoded {
            self = .selfmanageresources(selfmanageresources)
            return
        }
        let nopreferenceDecoded = try values.decodeIfPresent(MigrationHubStrategyClientTypes.NoManagementPreference.self, forKey: .nopreference)
        if let nopreference = nopreferenceDecoded {
            self = .nopreference(nopreference)
            return
        }
        self = .sdkUnknown("")
    }
}

extension MigrationHubStrategyClientTypes {
    /// Preferences for migrating an application to AWS.
    public enum ManagementPreference: Swift.Equatable {
        /// Indicates interest in solutions that are managed by AWS.
        case awsmanagedresources(MigrationHubStrategyClientTypes.AwsManagedResources)
        /// Indicates interest in managing your own resources on AWS.
        case selfmanageresources(MigrationHubStrategyClientTypes.SelfManageResources)
        /// No specific preference.
        case nopreference(MigrationHubStrategyClientTypes.NoManagementPreference)
        case sdkUnknown(Swift.String)
    }

}

extension MigrationHubStrategyClientTypes.NetworkInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case interfaceName
        case ipAddress
        case macAddress
        case netMask
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let interfaceName = self.interfaceName {
            try encodeContainer.encode(interfaceName, forKey: .interfaceName)
        }
        if let ipAddress = self.ipAddress {
            try encodeContainer.encode(ipAddress, forKey: .ipAddress)
        }
        if let macAddress = self.macAddress {
            try encodeContainer.encode(macAddress, forKey: .macAddress)
        }
        if let netMask = self.netMask {
            try encodeContainer.encode(netMask, forKey: .netMask)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let interfaceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .interfaceName)
        interfaceName = interfaceNameDecoded
        let ipAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ipAddress)
        ipAddress = ipAddressDecoded
        let macAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .macAddress)
        macAddress = macAddressDecoded
        let netMaskDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .netMask)
        netMask = netMaskDecoded
    }
}

extension MigrationHubStrategyClientTypes {
    /// Information about the server's network for which the assessment was run.
    public struct NetworkInfo: Swift.Equatable {
        /// Information about the name of the interface of the server for which the assessment was run.
        /// This member is required.
        public var interfaceName: Swift.String?
        /// Information about the IP address of the server for which the assessment was run.
        /// This member is required.
        public var ipAddress: Swift.String?
        /// Information about the MAC address of the server for which the assessment was run.
        /// This member is required.
        public var macAddress: Swift.String?
        /// Information about the subnet mask of the server for which the assessment was run.
        /// This member is required.
        public var netMask: Swift.String?

        public init(
            interfaceName: Swift.String? = nil,
            ipAddress: Swift.String? = nil,
            macAddress: Swift.String? = nil,
            netMask: Swift.String? = nil
        )
        {
            self.interfaceName = interfaceName
            self.ipAddress = ipAddress
            self.macAddress = macAddress
            self.netMask = netMask
        }
    }

}

extension MigrationHubStrategyClientTypes.NoDatabaseMigrationPreference: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case targetDatabaseEngine
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let targetDatabaseEngine = targetDatabaseEngine {
            var targetDatabaseEngineContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targetDatabaseEngine)
            for targetdatabaseengine0 in targetDatabaseEngine {
                try targetDatabaseEngineContainer.encode(targetdatabaseengine0.rawValue)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetDatabaseEngineContainer = try containerValues.decodeIfPresent([MigrationHubStrategyClientTypes.TargetDatabaseEngine?].self, forKey: .targetDatabaseEngine)
        var targetDatabaseEngineDecoded0:[MigrationHubStrategyClientTypes.TargetDatabaseEngine]? = nil
        if let targetDatabaseEngineContainer = targetDatabaseEngineContainer {
            targetDatabaseEngineDecoded0 = [MigrationHubStrategyClientTypes.TargetDatabaseEngine]()
            for string0 in targetDatabaseEngineContainer {
                if let string0 = string0 {
                    targetDatabaseEngineDecoded0?.append(string0)
                }
            }
        }
        targetDatabaseEngine = targetDatabaseEngineDecoded0
    }
}

extension MigrationHubStrategyClientTypes {
    /// The object containing details about database migration preferences, when you have no particular preference.
    public struct NoDatabaseMigrationPreference: Swift.Equatable {
        /// The target database engine for database migration preference that you specify.
        /// This member is required.
        public var targetDatabaseEngine: [MigrationHubStrategyClientTypes.TargetDatabaseEngine]?

        public init(
            targetDatabaseEngine: [MigrationHubStrategyClientTypes.TargetDatabaseEngine]? = nil
        )
        {
            self.targetDatabaseEngine = targetDatabaseEngine
        }
    }

}

extension MigrationHubStrategyClientTypes.NoManagementPreference: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case targetDestination
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let targetDestination = targetDestination {
            var targetDestinationContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targetDestination)
            for nopreferencetargetdestination0 in targetDestination {
                try targetDestinationContainer.encode(nopreferencetargetdestination0.rawValue)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetDestinationContainer = try containerValues.decodeIfPresent([MigrationHubStrategyClientTypes.NoPreferenceTargetDestination?].self, forKey: .targetDestination)
        var targetDestinationDecoded0:[MigrationHubStrategyClientTypes.NoPreferenceTargetDestination]? = nil
        if let targetDestinationContainer = targetDestinationContainer {
            targetDestinationDecoded0 = [MigrationHubStrategyClientTypes.NoPreferenceTargetDestination]()
            for string0 in targetDestinationContainer {
                if let string0 = string0 {
                    targetDestinationDecoded0?.append(string0)
                }
            }
        }
        targetDestination = targetDestinationDecoded0
    }
}

extension MigrationHubStrategyClientTypes {
    /// Object containing the choice of application destination that you specify.
    public struct NoManagementPreference: Swift.Equatable {
        /// The choice of application destination that you specify.
        /// This member is required.
        public var targetDestination: [MigrationHubStrategyClientTypes.NoPreferenceTargetDestination]?

        public init(
            targetDestination: [MigrationHubStrategyClientTypes.NoPreferenceTargetDestination]? = nil
        )
        {
            self.targetDestination = targetDestination
        }
    }

}

extension MigrationHubStrategyClientTypes {
    public enum NoPreferenceTargetDestination: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case amazonElasticCloudCompute
        case amazonElasticContainerService
        case amazonElasticKubernetesService
        case awsElasticBeanstalk
        case awsFargate
        case noneSpecified
        case sdkUnknown(Swift.String)

        public static var allCases: [NoPreferenceTargetDestination] {
            return [
                .amazonElasticCloudCompute,
                .amazonElasticContainerService,
                .amazonElasticKubernetesService,
                .awsElasticBeanstalk,
                .awsFargate,
                .noneSpecified,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .amazonElasticCloudCompute: return "Amazon Elastic Cloud Compute (EC2)"
            case .amazonElasticContainerService: return "Amazon Elastic Container Service (ECS)"
            case .amazonElasticKubernetesService: return "Amazon Elastic Kubernetes Service (EKS)"
            case .awsElasticBeanstalk: return "AWS Elastic BeanStalk"
            case .awsFargate: return "AWS Fargate"
            case .noneSpecified: return "None specified"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = NoPreferenceTargetDestination(rawValue: rawValue) ?? NoPreferenceTargetDestination.sdkUnknown(rawValue)
        }
    }
}

extension MigrationHubStrategyClientTypes.OSInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case type
        case version
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let version = self.version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(MigrationHubStrategyClientTypes.OSType.self, forKey: .type)
        type = typeDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
    }
}

extension MigrationHubStrategyClientTypes {
    /// Information about the operating system.
    public struct OSInfo: Swift.Equatable {
        /// Information about the type of operating system.
        public var type: MigrationHubStrategyClientTypes.OSType?
        /// Information about the version of operating system.
        public var version: Swift.String?

        public init(
            type: MigrationHubStrategyClientTypes.OSType? = nil,
            version: Swift.String? = nil
        )
        {
            self.type = type
            self.version = version
        }
    }

}

extension MigrationHubStrategyClientTypes {
    public enum OSType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case linux
        case windows
        case sdkUnknown(Swift.String)

        public static var allCases: [OSType] {
            return [
                .linux,
                .windows,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .linux: return "LINUX"
            case .windows: return "WINDOWS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OSType(rawValue: rawValue) ?? OSType.sdkUnknown(rawValue)
        }
    }
}

extension MigrationHubStrategyClientTypes {
    public enum OutputFormat: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case excel
        case json
        case sdkUnknown(Swift.String)

        public static var allCases: [OutputFormat] {
            return [
                .excel,
                .json,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .excel: return "Excel"
            case .json: return "Json"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OutputFormat(rawValue: rawValue) ?? OutputFormat.sdkUnknown(rawValue)
        }
    }
}

extension MigrationHubStrategyClientTypes.PipelineInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case pipelineConfigurationTimeStamp
        case pipelineType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let pipelineConfigurationTimeStamp = self.pipelineConfigurationTimeStamp {
            try encodeContainer.encode(pipelineConfigurationTimeStamp, forKey: .pipelineConfigurationTimeStamp)
        }
        if let pipelineType = self.pipelineType {
            try encodeContainer.encode(pipelineType.rawValue, forKey: .pipelineType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pipelineTypeDecoded = try containerValues.decodeIfPresent(MigrationHubStrategyClientTypes.PipelineType.self, forKey: .pipelineType)
        pipelineType = pipelineTypeDecoded
        let pipelineConfigurationTimeStampDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pipelineConfigurationTimeStamp)
        pipelineConfigurationTimeStamp = pipelineConfigurationTimeStampDecoded
    }
}

extension MigrationHubStrategyClientTypes {
    /// Detailed information of the pipeline.
    public struct PipelineInfo: Swift.Equatable {
        /// The time when the pipeline info was configured.
        public var pipelineConfigurationTimeStamp: Swift.String?
        /// The type of pipeline.
        public var pipelineType: MigrationHubStrategyClientTypes.PipelineType?

        public init(
            pipelineConfigurationTimeStamp: Swift.String? = nil,
            pipelineType: MigrationHubStrategyClientTypes.PipelineType? = nil
        )
        {
            self.pipelineConfigurationTimeStamp = pipelineConfigurationTimeStamp
            self.pipelineType = pipelineType
        }
    }

}

extension MigrationHubStrategyClientTypes {
    public enum PipelineType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case azureDevops
        case sdkUnknown(Swift.String)

        public static var allCases: [PipelineType] {
            return [
                .azureDevops,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .azureDevops: return "AZURE_DEVOPS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PipelineType(rawValue: rawValue) ?? PipelineType.sdkUnknown(rawValue)
        }
    }
}

extension MigrationHubStrategyClientTypes.PrioritizeBusinessGoals: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case businessGoals
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let businessGoals = self.businessGoals {
            try encodeContainer.encode(businessGoals, forKey: .businessGoals)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let businessGoalsDecoded = try containerValues.decodeIfPresent(MigrationHubStrategyClientTypes.BusinessGoals.self, forKey: .businessGoals)
        businessGoals = businessGoalsDecoded
    }
}

extension MigrationHubStrategyClientTypes {
    /// Rank of business goals based on priority.
    public struct PrioritizeBusinessGoals: Swift.Equatable {
        /// Rank of business goals based on priority.
        public var businessGoals: MigrationHubStrategyClientTypes.BusinessGoals?

        public init(
            businessGoals: MigrationHubStrategyClientTypes.BusinessGoals? = nil
        )
        {
            self.businessGoals = businessGoals
        }
    }

}

extension PutPortfolioPreferencesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationMode
        case applicationPreferences
        case databasePreferences
        case prioritizeBusinessGoals
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationMode = self.applicationMode {
            try encodeContainer.encode(applicationMode.rawValue, forKey: .applicationMode)
        }
        if let applicationPreferences = self.applicationPreferences {
            try encodeContainer.encode(applicationPreferences, forKey: .applicationPreferences)
        }
        if let databasePreferences = self.databasePreferences {
            try encodeContainer.encode(databasePreferences, forKey: .databasePreferences)
        }
        if let prioritizeBusinessGoals = self.prioritizeBusinessGoals {
            try encodeContainer.encode(prioritizeBusinessGoals, forKey: .prioritizeBusinessGoals)
        }
    }
}

extension PutPortfolioPreferencesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/put-portfolio-preferences"
    }
}

public struct PutPortfolioPreferencesInput: Swift.Equatable {
    /// The classification for application component types.
    public var applicationMode: MigrationHubStrategyClientTypes.ApplicationMode?
    /// The transformation preferences for non-database applications.
    public var applicationPreferences: MigrationHubStrategyClientTypes.ApplicationPreferences?
    /// The transformation preferences for database applications.
    public var databasePreferences: MigrationHubStrategyClientTypes.DatabasePreferences?
    /// The rank of the business goals based on priority.
    public var prioritizeBusinessGoals: MigrationHubStrategyClientTypes.PrioritizeBusinessGoals?

    public init(
        applicationMode: MigrationHubStrategyClientTypes.ApplicationMode? = nil,
        applicationPreferences: MigrationHubStrategyClientTypes.ApplicationPreferences? = nil,
        databasePreferences: MigrationHubStrategyClientTypes.DatabasePreferences? = nil,
        prioritizeBusinessGoals: MigrationHubStrategyClientTypes.PrioritizeBusinessGoals? = nil
    )
    {
        self.applicationMode = applicationMode
        self.applicationPreferences = applicationPreferences
        self.databasePreferences = databasePreferences
        self.prioritizeBusinessGoals = prioritizeBusinessGoals
    }
}

struct PutPortfolioPreferencesInputBody: Swift.Equatable {
    let prioritizeBusinessGoals: MigrationHubStrategyClientTypes.PrioritizeBusinessGoals?
    let applicationPreferences: MigrationHubStrategyClientTypes.ApplicationPreferences?
    let databasePreferences: MigrationHubStrategyClientTypes.DatabasePreferences?
    let applicationMode: MigrationHubStrategyClientTypes.ApplicationMode?
}

extension PutPortfolioPreferencesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationMode
        case applicationPreferences
        case databasePreferences
        case prioritizeBusinessGoals
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let prioritizeBusinessGoalsDecoded = try containerValues.decodeIfPresent(MigrationHubStrategyClientTypes.PrioritizeBusinessGoals.self, forKey: .prioritizeBusinessGoals)
        prioritizeBusinessGoals = prioritizeBusinessGoalsDecoded
        let applicationPreferencesDecoded = try containerValues.decodeIfPresent(MigrationHubStrategyClientTypes.ApplicationPreferences.self, forKey: .applicationPreferences)
        applicationPreferences = applicationPreferencesDecoded
        let databasePreferencesDecoded = try containerValues.decodeIfPresent(MigrationHubStrategyClientTypes.DatabasePreferences.self, forKey: .databasePreferences)
        databasePreferences = databasePreferencesDecoded
        let applicationModeDecoded = try containerValues.decodeIfPresent(MigrationHubStrategyClientTypes.ApplicationMode.self, forKey: .applicationMode)
        applicationMode = applicationModeDecoded
    }
}

extension PutPortfolioPreferencesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct PutPortfolioPreferencesOutput: Swift.Equatable {

    public init() { }
}

enum PutPortfolioPreferencesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension MigrationHubStrategyClientTypes.RecommendationReportDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case completionTime
        case s3Bucket
        case s3Keys
        case startTime
        case status
        case statusMessage
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let completionTime = self.completionTime {
            try encodeContainer.encodeTimestamp(completionTime, format: .epochSeconds, forKey: .completionTime)
        }
        if let s3Bucket = self.s3Bucket {
            try encodeContainer.encode(s3Bucket, forKey: .s3Bucket)
        }
        if let s3Keys = s3Keys {
            var s3KeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .s3Keys)
            for string0 in s3Keys {
                try s3KeysContainer.encode(string0)
            }
        }
        if let startTime = self.startTime {
            try encodeContainer.encodeTimestamp(startTime, format: .epochSeconds, forKey: .startTime)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusMessage = self.statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(MigrationHubStrategyClientTypes.RecommendationReportStatus.self, forKey: .status)
        status = statusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startTime)
        startTime = startTimeDecoded
        let completionTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .completionTime)
        completionTime = completionTimeDecoded
        let s3BucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3Bucket)
        s3Bucket = s3BucketDecoded
        let s3KeysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .s3Keys)
        var s3KeysDecoded0:[Swift.String]? = nil
        if let s3KeysContainer = s3KeysContainer {
            s3KeysDecoded0 = [Swift.String]()
            for string0 in s3KeysContainer {
                if let string0 = string0 {
                    s3KeysDecoded0?.append(string0)
                }
            }
        }
        s3Keys = s3KeysDecoded0
    }
}

extension MigrationHubStrategyClientTypes {
    /// Contains detailed information about a recommendation report.
    public struct RecommendationReportDetails: Swift.Equatable {
        /// The time that the recommendation report generation task completes.
        public var completionTime: ClientRuntime.Date?
        /// The S3 bucket where the report file is located.
        public var s3Bucket: Swift.String?
        /// The Amazon S3 key name of the report file.
        public var s3Keys: [Swift.String]?
        /// The time that the recommendation report generation task starts.
        public var startTime: ClientRuntime.Date?
        /// The status of the recommendation report generation task.
        public var status: MigrationHubStrategyClientTypes.RecommendationReportStatus?
        /// The status message for recommendation report generation.
        public var statusMessage: Swift.String?

        public init(
            completionTime: ClientRuntime.Date? = nil,
            s3Bucket: Swift.String? = nil,
            s3Keys: [Swift.String]? = nil,
            startTime: ClientRuntime.Date? = nil,
            status: MigrationHubStrategyClientTypes.RecommendationReportStatus? = nil,
            statusMessage: Swift.String? = nil
        )
        {
            self.completionTime = completionTime
            self.s3Bucket = s3Bucket
            self.s3Keys = s3Keys
            self.startTime = startTime
            self.status = status
            self.statusMessage = statusMessage
        }
    }

}

extension MigrationHubStrategyClientTypes {
    public enum RecommendationReportStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failed
        case inProgress
        case success
        case sdkUnknown(Swift.String)

        public static var allCases: [RecommendationReportStatus] {
            return [
                .failed,
                .inProgress,
                .success,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .success: return "SUCCESS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RecommendationReportStatus(rawValue: rawValue) ?? RecommendationReportStatus.sdkUnknown(rawValue)
        }
    }
}

extension MigrationHubStrategyClientTypes.RecommendationSet: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case strategy
        case targetDestination
        case transformationTool
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let strategy = self.strategy {
            try encodeContainer.encode(strategy.rawValue, forKey: .strategy)
        }
        if let targetDestination = self.targetDestination {
            try encodeContainer.encode(targetDestination.rawValue, forKey: .targetDestination)
        }
        if let transformationTool = self.transformationTool {
            try encodeContainer.encode(transformationTool, forKey: .transformationTool)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let transformationToolDecoded = try containerValues.decodeIfPresent(MigrationHubStrategyClientTypes.TransformationTool.self, forKey: .transformationTool)
        transformationTool = transformationToolDecoded
        let targetDestinationDecoded = try containerValues.decodeIfPresent(MigrationHubStrategyClientTypes.TargetDestination.self, forKey: .targetDestination)
        targetDestination = targetDestinationDecoded
        let strategyDecoded = try containerValues.decodeIfPresent(MigrationHubStrategyClientTypes.Strategy.self, forKey: .strategy)
        strategy = strategyDecoded
    }
}

extension MigrationHubStrategyClientTypes {
    /// Contains a recommendation set.
    public struct RecommendationSet: Swift.Equatable {
        /// The recommended strategy.
        public var strategy: MigrationHubStrategyClientTypes.Strategy?
        /// The recommended target destination.
        public var targetDestination: MigrationHubStrategyClientTypes.TargetDestination?
        /// The target destination for the recommendation set.
        public var transformationTool: MigrationHubStrategyClientTypes.TransformationTool?

        public init(
            strategy: MigrationHubStrategyClientTypes.Strategy? = nil,
            targetDestination: MigrationHubStrategyClientTypes.TargetDestination? = nil,
            transformationTool: MigrationHubStrategyClientTypes.TransformationTool? = nil
        )
        {
            self.strategy = strategy
            self.targetDestination = targetDestination
            self.transformationTool = transformationTool
        }
    }

}

extension MigrationHubStrategyClientTypes.RemoteSourceCodeAnalysisServerInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case remoteSourceCodeAnalysisServerConfigurationTimestamp
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let remoteSourceCodeAnalysisServerConfigurationTimestamp = self.remoteSourceCodeAnalysisServerConfigurationTimestamp {
            try encodeContainer.encode(remoteSourceCodeAnalysisServerConfigurationTimestamp, forKey: .remoteSourceCodeAnalysisServerConfigurationTimestamp)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let remoteSourceCodeAnalysisServerConfigurationTimestampDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .remoteSourceCodeAnalysisServerConfigurationTimestamp)
        remoteSourceCodeAnalysisServerConfigurationTimestamp = remoteSourceCodeAnalysisServerConfigurationTimestampDecoded
    }
}

extension MigrationHubStrategyClientTypes {
    /// Information about the server configured for source code analysis.
    public struct RemoteSourceCodeAnalysisServerInfo: Swift.Equatable {
        /// The time when the remote source code server was configured.
        public var remoteSourceCodeAnalysisServerConfigurationTimestamp: Swift.String?

        public init(
            remoteSourceCodeAnalysisServerConfigurationTimestamp: Swift.String? = nil
        )
        {
            self.remoteSourceCodeAnalysisServerConfigurationTimestamp = remoteSourceCodeAnalysisServerConfigurationTimestamp
        }
    }

}

extension ResourceNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The specified ID in the request is not found.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MigrationHubStrategyClientTypes {
    public enum ResourceSubType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case database
        case databaseProcess
        case process
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceSubType] {
            return [
                .database,
                .databaseProcess,
                .process,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .database: return "Database"
            case .databaseProcess: return "DatabaseProcess"
            case .process: return "Process"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResourceSubType(rawValue: rawValue) ?? ResourceSubType.sdkUnknown(rawValue)
        }
    }
}

extension MigrationHubStrategyClientTypes.Result: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case analysisStatus
        case analysisType
        case antipatternReportResultList
        case statusMessage
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let analysisStatus = self.analysisStatus {
            try encodeContainer.encode(analysisStatus, forKey: .analysisStatus)
        }
        if let analysisType = self.analysisType {
            try encodeContainer.encode(analysisType.rawValue, forKey: .analysisType)
        }
        if let antipatternReportResultList = antipatternReportResultList {
            var antipatternReportResultListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .antipatternReportResultList)
            for antipatternreportresult0 in antipatternReportResultList {
                try antipatternReportResultListContainer.encode(antipatternreportresult0)
            }
        }
        if let statusMessage = self.statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let analysisTypeDecoded = try containerValues.decodeIfPresent(MigrationHubStrategyClientTypes.AnalysisType.self, forKey: .analysisType)
        analysisType = analysisTypeDecoded
        let analysisStatusDecoded = try containerValues.decodeIfPresent(MigrationHubStrategyClientTypes.AnalysisStatusUnion.self, forKey: .analysisStatus)
        analysisStatus = analysisStatusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let antipatternReportResultListContainer = try containerValues.decodeIfPresent([MigrationHubStrategyClientTypes.AntipatternReportResult?].self, forKey: .antipatternReportResultList)
        var antipatternReportResultListDecoded0:[MigrationHubStrategyClientTypes.AntipatternReportResult]? = nil
        if let antipatternReportResultListContainer = antipatternReportResultListContainer {
            antipatternReportResultListDecoded0 = [MigrationHubStrategyClientTypes.AntipatternReportResult]()
            for structure0 in antipatternReportResultListContainer {
                if let structure0 = structure0 {
                    antipatternReportResultListDecoded0?.append(structure0)
                }
            }
        }
        antipatternReportResultList = antipatternReportResultListDecoded0
    }
}

extension MigrationHubStrategyClientTypes {
    /// The error in server analysis.
    public struct Result: Swift.Equatable {
        /// The error in server analysis.
        public var analysisStatus: MigrationHubStrategyClientTypes.AnalysisStatusUnion?
        /// The error in server analysis.
        public var analysisType: MigrationHubStrategyClientTypes.AnalysisType?
        /// The error in server analysis.
        public var antipatternReportResultList: [MigrationHubStrategyClientTypes.AntipatternReportResult]?
        /// The error in server analysis.
        public var statusMessage: Swift.String?

        public init(
            analysisStatus: MigrationHubStrategyClientTypes.AnalysisStatusUnion? = nil,
            analysisType: MigrationHubStrategyClientTypes.AnalysisType? = nil,
            antipatternReportResultList: [MigrationHubStrategyClientTypes.AntipatternReportResult]? = nil,
            statusMessage: Swift.String? = nil
        )
        {
            self.analysisStatus = analysisStatus
            self.analysisType = analysisType
            self.antipatternReportResultList = antipatternReportResultList
            self.statusMessage = statusMessage
        }
    }

}

extension MigrationHubStrategyClientTypes {
    public enum RunTimeAnalyzerName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case a2cAnalyzer
        case databaseAnalyzer
        case empPaAnalyzer
        case rehostAnalyzer
        case sctAnalyzer
        case sdkUnknown(Swift.String)

        public static var allCases: [RunTimeAnalyzerName] {
            return [
                .a2cAnalyzer,
                .databaseAnalyzer,
                .empPaAnalyzer,
                .rehostAnalyzer,
                .sctAnalyzer,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .a2cAnalyzer: return "A2C_ANALYZER"
            case .databaseAnalyzer: return "DATABASE_ANALYZER"
            case .empPaAnalyzer: return "EMP_PA_ANALYZER"
            case .rehostAnalyzer: return "REHOST_ANALYZER"
            case .sctAnalyzer: return "SCT_ANALYZER"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RunTimeAnalyzerName(rawValue: rawValue) ?? RunTimeAnalyzerName.sdkUnknown(rawValue)
        }
    }
}

extension MigrationHubStrategyClientTypes {
    public enum RunTimeAssessmentStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case dcFailed
        case dcPartialSuccess
        case dcReqSent
        case dcStarted
        case dcStopped
        case dcSuccess
        case dcToBeScheduled
        case sdkUnknown(Swift.String)

        public static var allCases: [RunTimeAssessmentStatus] {
            return [
                .dcFailed,
                .dcPartialSuccess,
                .dcReqSent,
                .dcStarted,
                .dcStopped,
                .dcSuccess,
                .dcToBeScheduled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .dcFailed: return "dataCollectionTaskFailed"
            case .dcPartialSuccess: return "dataCollectionTaskPartialSuccess"
            case .dcReqSent: return "dataCollectionTaskScheduled"
            case .dcStarted: return "dataCollectionTaskStarted"
            case .dcStopped: return "dataCollectionTaskStopped"
            case .dcSuccess: return "dataCollectionTaskSuccess"
            case .dcToBeScheduled: return "dataCollectionTaskToBeScheduled"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RunTimeAssessmentStatus(rawValue: rawValue) ?? RunTimeAssessmentStatus.sdkUnknown(rawValue)
        }
    }
}

extension MigrationHubStrategyClientTypes {
    public enum RuntimeAnalysisStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case analysisFailed
        case analysisStarted
        case analysisSuccess
        case analysisToBeScheduled
        case sdkUnknown(Swift.String)

        public static var allCases: [RuntimeAnalysisStatus] {
            return [
                .analysisFailed,
                .analysisStarted,
                .analysisSuccess,
                .analysisToBeScheduled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .analysisFailed: return "ANALYSIS_FAILED"
            case .analysisStarted: return "ANALYSIS_STARTED"
            case .analysisSuccess: return "ANALYSIS_SUCCESS"
            case .analysisToBeScheduled: return "ANALYSIS_TO_BE_SCHEDULED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RuntimeAnalysisStatus(rawValue: rawValue) ?? RuntimeAnalysisStatus.sdkUnknown(rawValue)
        }
    }
}

extension MigrationHubStrategyClientTypes.S3Object: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3Bucket
        case s3key
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3Bucket = self.s3Bucket {
            try encodeContainer.encode(s3Bucket, forKey: .s3Bucket)
        }
        if let s3key = self.s3key {
            try encodeContainer.encode(s3key, forKey: .s3key)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3BucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3Bucket)
        s3Bucket = s3BucketDecoded
        let s3keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3key)
        s3key = s3keyDecoded
    }
}

extension MigrationHubStrategyClientTypes {
    /// Contains the S3 bucket name and the Amazon S3 key name.
    public struct S3Object: Swift.Equatable {
        /// The S3 bucket name.
        public var s3Bucket: Swift.String?
        /// The Amazon S3 key name.
        public var s3key: Swift.String?

        public init(
            s3Bucket: Swift.String? = nil,
            s3key: Swift.String? = nil
        )
        {
            self.s3Bucket = s3Bucket
            self.s3key = s3key
        }
    }

}

extension MigrationHubStrategyClientTypes.SelfManageResources: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case targetDestination
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let targetDestination = targetDestination {
            var targetDestinationContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targetDestination)
            for selfmanagetargetdestination0 in targetDestination {
                try targetDestinationContainer.encode(selfmanagetargetdestination0.rawValue)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetDestinationContainer = try containerValues.decodeIfPresent([MigrationHubStrategyClientTypes.SelfManageTargetDestination?].self, forKey: .targetDestination)
        var targetDestinationDecoded0:[MigrationHubStrategyClientTypes.SelfManageTargetDestination]? = nil
        if let targetDestinationContainer = targetDestinationContainer {
            targetDestinationDecoded0 = [MigrationHubStrategyClientTypes.SelfManageTargetDestination]()
            for string0 in targetDestinationContainer {
                if let string0 = string0 {
                    targetDestinationDecoded0?.append(string0)
                }
            }
        }
        targetDestination = targetDestinationDecoded0
    }
}

extension MigrationHubStrategyClientTypes {
    /// Self-managed resources.
    public struct SelfManageResources: Swift.Equatable {
        /// Self-managed resources target destination.
        /// This member is required.
        public var targetDestination: [MigrationHubStrategyClientTypes.SelfManageTargetDestination]?

        public init(
            targetDestination: [MigrationHubStrategyClientTypes.SelfManageTargetDestination]? = nil
        )
        {
            self.targetDestination = targetDestination
        }
    }

}

extension MigrationHubStrategyClientTypes {
    public enum SelfManageTargetDestination: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case amazonElasticCloudCompute
        case amazonElasticContainerService
        case amazonElasticKubernetesService
        case noneSpecified
        case sdkUnknown(Swift.String)

        public static var allCases: [SelfManageTargetDestination] {
            return [
                .amazonElasticCloudCompute,
                .amazonElasticContainerService,
                .amazonElasticKubernetesService,
                .noneSpecified,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .amazonElasticCloudCompute: return "Amazon Elastic Cloud Compute (EC2)"
            case .amazonElasticContainerService: return "Amazon Elastic Container Service (ECS)"
            case .amazonElasticKubernetesService: return "Amazon Elastic Kubernetes Service (EKS)"
            case .noneSpecified: return "None specified"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SelfManageTargetDestination(rawValue: rawValue) ?? SelfManageTargetDestination.sdkUnknown(rawValue)
        }
    }
}

extension MigrationHubStrategyClientTypes {
    public enum ServerCriteria: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case analysisStatus
        case destination
        case errorCategory
        case notDefined
        case osName
        case serverId
        case strategy
        case sdkUnknown(Swift.String)

        public static var allCases: [ServerCriteria] {
            return [
                .analysisStatus,
                .destination,
                .errorCategory,
                .notDefined,
                .osName,
                .serverId,
                .strategy,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .analysisStatus: return "ANALYSIS_STATUS"
            case .destination: return "DESTINATION"
            case .errorCategory: return "ERROR_CATEGORY"
            case .notDefined: return "NOT_DEFINED"
            case .osName: return "OS_NAME"
            case .serverId: return "SERVER_ID"
            case .strategy: return "STRATEGY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ServerCriteria(rawValue: rawValue) ?? ServerCriteria.sdkUnknown(rawValue)
        }
    }
}

extension MigrationHubStrategyClientTypes.ServerDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case antipatternReportS3Object
        case antipatternReportStatus
        case antipatternReportStatusMessage
        case applicationComponentStrategySummary
        case dataCollectionStatus
        case id
        case lastAnalyzedTimestamp
        case listAntipatternSeveritySummary
        case name
        case recommendationSet
        case serverError
        case serverType
        case statusMessage
        case systemInfo
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let antipatternReportS3Object = self.antipatternReportS3Object {
            try encodeContainer.encode(antipatternReportS3Object, forKey: .antipatternReportS3Object)
        }
        if let antipatternReportStatus = self.antipatternReportStatus {
            try encodeContainer.encode(antipatternReportStatus.rawValue, forKey: .antipatternReportStatus)
        }
        if let antipatternReportStatusMessage = self.antipatternReportStatusMessage {
            try encodeContainer.encode(antipatternReportStatusMessage, forKey: .antipatternReportStatusMessage)
        }
        if let applicationComponentStrategySummary = applicationComponentStrategySummary {
            var applicationComponentStrategySummaryContainer = encodeContainer.nestedUnkeyedContainer(forKey: .applicationComponentStrategySummary)
            for strategysummary0 in applicationComponentStrategySummary {
                try applicationComponentStrategySummaryContainer.encode(strategysummary0)
            }
        }
        if let dataCollectionStatus = self.dataCollectionStatus {
            try encodeContainer.encode(dataCollectionStatus.rawValue, forKey: .dataCollectionStatus)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let lastAnalyzedTimestamp = self.lastAnalyzedTimestamp {
            try encodeContainer.encodeTimestamp(lastAnalyzedTimestamp, format: .epochSeconds, forKey: .lastAnalyzedTimestamp)
        }
        if let listAntipatternSeveritySummary = listAntipatternSeveritySummary {
            var listAntipatternSeveritySummaryContainer = encodeContainer.nestedUnkeyedContainer(forKey: .listAntipatternSeveritySummary)
            for antipatternseveritysummary0 in listAntipatternSeveritySummary {
                try listAntipatternSeveritySummaryContainer.encode(antipatternseveritysummary0)
            }
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let recommendationSet = self.recommendationSet {
            try encodeContainer.encode(recommendationSet, forKey: .recommendationSet)
        }
        if let serverError = self.serverError {
            try encodeContainer.encode(serverError, forKey: .serverError)
        }
        if let serverType = self.serverType {
            try encodeContainer.encode(serverType, forKey: .serverType)
        }
        if let statusMessage = self.statusMessage {
            try encodeContainer.encode(statusMessage, forKey: .statusMessage)
        }
        if let systemInfo = self.systemInfo {
            try encodeContainer.encode(systemInfo, forKey: .systemInfo)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let recommendationSetDecoded = try containerValues.decodeIfPresent(MigrationHubStrategyClientTypes.RecommendationSet.self, forKey: .recommendationSet)
        recommendationSet = recommendationSetDecoded
        let dataCollectionStatusDecoded = try containerValues.decodeIfPresent(MigrationHubStrategyClientTypes.RunTimeAssessmentStatus.self, forKey: .dataCollectionStatus)
        dataCollectionStatus = dataCollectionStatusDecoded
        let statusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .statusMessage)
        statusMessage = statusMessageDecoded
        let listAntipatternSeveritySummaryContainer = try containerValues.decodeIfPresent([MigrationHubStrategyClientTypes.AntipatternSeveritySummary?].self, forKey: .listAntipatternSeveritySummary)
        var listAntipatternSeveritySummaryDecoded0:[MigrationHubStrategyClientTypes.AntipatternSeveritySummary]? = nil
        if let listAntipatternSeveritySummaryContainer = listAntipatternSeveritySummaryContainer {
            listAntipatternSeveritySummaryDecoded0 = [MigrationHubStrategyClientTypes.AntipatternSeveritySummary]()
            for structure0 in listAntipatternSeveritySummaryContainer {
                if let structure0 = structure0 {
                    listAntipatternSeveritySummaryDecoded0?.append(structure0)
                }
            }
        }
        listAntipatternSeveritySummary = listAntipatternSeveritySummaryDecoded0
        let systemInfoDecoded = try containerValues.decodeIfPresent(MigrationHubStrategyClientTypes.SystemInfo.self, forKey: .systemInfo)
        systemInfo = systemInfoDecoded
        let applicationComponentStrategySummaryContainer = try containerValues.decodeIfPresent([MigrationHubStrategyClientTypes.StrategySummary?].self, forKey: .applicationComponentStrategySummary)
        var applicationComponentStrategySummaryDecoded0:[MigrationHubStrategyClientTypes.StrategySummary]? = nil
        if let applicationComponentStrategySummaryContainer = applicationComponentStrategySummaryContainer {
            applicationComponentStrategySummaryDecoded0 = [MigrationHubStrategyClientTypes.StrategySummary]()
            for structure0 in applicationComponentStrategySummaryContainer {
                if let structure0 = structure0 {
                    applicationComponentStrategySummaryDecoded0?.append(structure0)
                }
            }
        }
        applicationComponentStrategySummary = applicationComponentStrategySummaryDecoded0
        let antipatternReportS3ObjectDecoded = try containerValues.decodeIfPresent(MigrationHubStrategyClientTypes.S3Object.self, forKey: .antipatternReportS3Object)
        antipatternReportS3Object = antipatternReportS3ObjectDecoded
        let antipatternReportStatusDecoded = try containerValues.decodeIfPresent(MigrationHubStrategyClientTypes.AntipatternReportStatus.self, forKey: .antipatternReportStatus)
        antipatternReportStatus = antipatternReportStatusDecoded
        let antipatternReportStatusMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .antipatternReportStatusMessage)
        antipatternReportStatusMessage = antipatternReportStatusMessageDecoded
        let serverTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverType)
        serverType = serverTypeDecoded
        let lastAnalyzedTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastAnalyzedTimestamp)
        lastAnalyzedTimestamp = lastAnalyzedTimestampDecoded
        let serverErrorDecoded = try containerValues.decodeIfPresent(MigrationHubStrategyClientTypes.ServerError.self, forKey: .serverError)
        serverError = serverErrorDecoded
    }
}

extension MigrationHubStrategyClientTypes {
    /// Detailed information about a server.
    public struct ServerDetail: Swift.Equatable {
        /// The S3 bucket name and Amazon S3 key name for anti-pattern report.
        public var antipatternReportS3Object: MigrationHubStrategyClientTypes.S3Object?
        /// The status of the anti-pattern report generation.
        public var antipatternReportStatus: MigrationHubStrategyClientTypes.AntipatternReportStatus?
        /// A message about the status of the anti-pattern report generation.
        public var antipatternReportStatusMessage: Swift.String?
        /// A list of strategy summaries.
        public var applicationComponentStrategySummary: [MigrationHubStrategyClientTypes.StrategySummary]?
        /// The status of assessment for the server.
        public var dataCollectionStatus: MigrationHubStrategyClientTypes.RunTimeAssessmentStatus?
        /// The server ID.
        public var id: Swift.String?
        /// The timestamp of when the server was assessed.
        public var lastAnalyzedTimestamp: ClientRuntime.Date?
        /// A list of anti-pattern severity summaries.
        public var listAntipatternSeveritySummary: [MigrationHubStrategyClientTypes.AntipatternSeveritySummary]?
        /// The name of the server.
        public var name: Swift.String?
        /// A set of recommendations.
        public var recommendationSet: MigrationHubStrategyClientTypes.RecommendationSet?
        /// The error in server analysis.
        public var serverError: MigrationHubStrategyClientTypes.ServerError?
        /// The type of server.
        public var serverType: Swift.String?
        /// A message about the status of data collection, which contains detailed descriptions of any error messages.
        public var statusMessage: Swift.String?
        /// System information about the server.
        public var systemInfo: MigrationHubStrategyClientTypes.SystemInfo?

        public init(
            antipatternReportS3Object: MigrationHubStrategyClientTypes.S3Object? = nil,
            antipatternReportStatus: MigrationHubStrategyClientTypes.AntipatternReportStatus? = nil,
            antipatternReportStatusMessage: Swift.String? = nil,
            applicationComponentStrategySummary: [MigrationHubStrategyClientTypes.StrategySummary]? = nil,
            dataCollectionStatus: MigrationHubStrategyClientTypes.RunTimeAssessmentStatus? = nil,
            id: Swift.String? = nil,
            lastAnalyzedTimestamp: ClientRuntime.Date? = nil,
            listAntipatternSeveritySummary: [MigrationHubStrategyClientTypes.AntipatternSeveritySummary]? = nil,
            name: Swift.String? = nil,
            recommendationSet: MigrationHubStrategyClientTypes.RecommendationSet? = nil,
            serverError: MigrationHubStrategyClientTypes.ServerError? = nil,
            serverType: Swift.String? = nil,
            statusMessage: Swift.String? = nil,
            systemInfo: MigrationHubStrategyClientTypes.SystemInfo? = nil
        )
        {
            self.antipatternReportS3Object = antipatternReportS3Object
            self.antipatternReportStatus = antipatternReportStatus
            self.antipatternReportStatusMessage = antipatternReportStatusMessage
            self.applicationComponentStrategySummary = applicationComponentStrategySummary
            self.dataCollectionStatus = dataCollectionStatus
            self.id = id
            self.lastAnalyzedTimestamp = lastAnalyzedTimestamp
            self.listAntipatternSeveritySummary = listAntipatternSeveritySummary
            self.name = name
            self.recommendationSet = recommendationSet
            self.serverError = serverError
            self.serverType = serverType
            self.statusMessage = statusMessage
            self.systemInfo = systemInfo
        }
    }

}

extension MigrationHubStrategyClientTypes.ServerError: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serverErrorCategory
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let serverErrorCategory = self.serverErrorCategory {
            try encodeContainer.encode(serverErrorCategory.rawValue, forKey: .serverErrorCategory)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverErrorCategoryDecoded = try containerValues.decodeIfPresent(MigrationHubStrategyClientTypes.ServerErrorCategory.self, forKey: .serverErrorCategory)
        serverErrorCategory = serverErrorCategoryDecoded
    }
}

extension MigrationHubStrategyClientTypes {
    /// The error in server analysis.
    public struct ServerError: Swift.Equatable {
        /// The error category of server analysis.
        public var serverErrorCategory: MigrationHubStrategyClientTypes.ServerErrorCategory?

        public init(
            serverErrorCategory: MigrationHubStrategyClientTypes.ServerErrorCategory? = nil
        )
        {
            self.serverErrorCategory = serverErrorCategory
        }
    }

}

extension MigrationHubStrategyClientTypes {
    public enum ServerErrorCategory: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case architectureError
        case connectivityError
        case credentialError
        case otherError
        case permissionError
        case sdkUnknown(Swift.String)

        public static var allCases: [ServerErrorCategory] {
            return [
                .architectureError,
                .connectivityError,
                .credentialError,
                .otherError,
                .permissionError,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .architectureError: return "ARCHITECTURE_ERROR"
            case .connectivityError: return "CONNECTIVITY_ERROR"
            case .credentialError: return "CREDENTIAL_ERROR"
            case .otherError: return "OTHER_ERROR"
            case .permissionError: return "PERMISSION_ERROR"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ServerErrorCategory(rawValue: rawValue) ?? ServerErrorCategory.sdkUnknown(rawValue)
        }
    }
}

extension MigrationHubStrategyClientTypes {
    public enum ServerOsType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case amazonlinux
        case endofsupportwindowsserver
        case other
        case redhat
        case windowsserver
        case sdkUnknown(Swift.String)

        public static var allCases: [ServerOsType] {
            return [
                .amazonlinux,
                .endofsupportwindowsserver,
                .other,
                .redhat,
                .windowsserver,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .amazonlinux: return "AmazonLinux"
            case .endofsupportwindowsserver: return "EndOfSupportWindowsServer"
            case .other: return "Other"
            case .redhat: return "Redhat"
            case .windowsserver: return "WindowsServer"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ServerOsType(rawValue: rawValue) ?? ServerOsType.sdkUnknown(rawValue)
        }
    }
}

extension MigrationHubStrategyClientTypes.ServerStatusSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case count
        case runTimeAssessmentStatus
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let count = self.count {
            try encodeContainer.encode(count, forKey: .count)
        }
        if let runTimeAssessmentStatus = self.runTimeAssessmentStatus {
            try encodeContainer.encode(runTimeAssessmentStatus.rawValue, forKey: .runTimeAssessmentStatus)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let runTimeAssessmentStatusDecoded = try containerValues.decodeIfPresent(MigrationHubStrategyClientTypes.RunTimeAssessmentStatus.self, forKey: .runTimeAssessmentStatus)
        runTimeAssessmentStatus = runTimeAssessmentStatusDecoded
        let countDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .count)
        count = countDecoded
    }
}

extension MigrationHubStrategyClientTypes {
    /// The status summary of the server analysis.
    public struct ServerStatusSummary: Swift.Equatable {
        /// The number of servers successfully analyzed, partially successful or failed analysis.
        public var count: Swift.Int?
        /// The status of the run time.
        public var runTimeAssessmentStatus: MigrationHubStrategyClientTypes.RunTimeAssessmentStatus?

        public init(
            count: Swift.Int? = nil,
            runTimeAssessmentStatus: MigrationHubStrategyClientTypes.RunTimeAssessmentStatus? = nil
        )
        {
            self.count = count
            self.runTimeAssessmentStatus = runTimeAssessmentStatus
        }
    }

}

extension MigrationHubStrategyClientTypes.ServerStrategy: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case isPreferred
        case numberOfApplicationComponents
        case recommendation
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let isPreferred = self.isPreferred {
            try encodeContainer.encode(isPreferred, forKey: .isPreferred)
        }
        if let numberOfApplicationComponents = self.numberOfApplicationComponents {
            try encodeContainer.encode(numberOfApplicationComponents, forKey: .numberOfApplicationComponents)
        }
        if let recommendation = self.recommendation {
            try encodeContainer.encode(recommendation, forKey: .recommendation)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recommendationDecoded = try containerValues.decodeIfPresent(MigrationHubStrategyClientTypes.RecommendationSet.self, forKey: .recommendation)
        recommendation = recommendationDecoded
        let statusDecoded = try containerValues.decodeIfPresent(MigrationHubStrategyClientTypes.StrategyRecommendation.self, forKey: .status)
        status = statusDecoded
        let numberOfApplicationComponentsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numberOfApplicationComponents)
        numberOfApplicationComponents = numberOfApplicationComponentsDecoded
        let isPreferredDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isPreferred)
        isPreferred = isPreferredDecoded
    }
}

extension MigrationHubStrategyClientTypes {
    /// Contains information about a strategy recommendation for a server.
    public struct ServerStrategy: Swift.Equatable {
        /// Set to true if the recommendation is set as preferred.
        public var isPreferred: Swift.Bool?
        /// The number of application components with this strategy recommendation running on the server.
        public var numberOfApplicationComponents: Swift.Int?
        /// Strategy recommendation for the server.
        public var recommendation: MigrationHubStrategyClientTypes.RecommendationSet?
        /// The recommendation status of the strategy for the server.
        public var status: MigrationHubStrategyClientTypes.StrategyRecommendation?

        public init(
            isPreferred: Swift.Bool? = nil,
            numberOfApplicationComponents: Swift.Int? = nil,
            recommendation: MigrationHubStrategyClientTypes.RecommendationSet? = nil,
            status: MigrationHubStrategyClientTypes.StrategyRecommendation? = nil
        )
        {
            self.isPreferred = isPreferred
            self.numberOfApplicationComponents = numberOfApplicationComponents
            self.recommendation = recommendation
            self.status = status
        }
    }

}

extension MigrationHubStrategyClientTypes.ServerSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serverOsType = "ServerOsType"
        case count
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let serverOsType = self.serverOsType {
            try encodeContainer.encode(serverOsType.rawValue, forKey: .serverOsType)
        }
        if let count = self.count {
            try encodeContainer.encode(count, forKey: .count)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverOsTypeDecoded = try containerValues.decodeIfPresent(MigrationHubStrategyClientTypes.ServerOsType.self, forKey: .serverOsType)
        serverOsType = serverOsTypeDecoded
        let countDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .count)
        count = countDecoded
    }
}

extension MigrationHubStrategyClientTypes {
    /// Object containing details about the servers imported by Application Discovery Service
    public struct ServerSummary: Swift.Equatable {
        /// Number of servers.
        public var count: Swift.Int?
        /// Type of operating system for the servers.
        public var serverOsType: MigrationHubStrategyClientTypes.ServerOsType?

        public init(
            count: Swift.Int? = nil,
            serverOsType: MigrationHubStrategyClientTypes.ServerOsType? = nil
        )
        {
            self.count = count
            self.serverOsType = serverOsType
        }
    }

}

extension ServiceLinkedRoleLockClientException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ServiceLinkedRoleLockClientExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Exception to indicate that the service-linked role (SLR) is locked.
public struct ServiceLinkedRoleLockClientException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceLinkedRoleLockClientException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ServiceLinkedRoleLockClientExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ServiceLinkedRoleLockClientExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ServiceQuotaExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The AWS account has reached its quota of imports. Contact AWS Support to increase the quota for this account.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MigrationHubStrategyClientTypes {
    public enum Severity: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case high
        case low
        case medium
        case sdkUnknown(Swift.String)

        public static var allCases: [Severity] {
            return [
                .high,
                .low,
                .medium,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .high: return "HIGH"
            case .low: return "LOW"
            case .medium: return "MEDIUM"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Severity(rawValue: rawValue) ?? Severity.sdkUnknown(rawValue)
        }
    }
}

extension MigrationHubStrategyClientTypes {
    public enum SortOrder: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case asc
        case desc
        case sdkUnknown(Swift.String)

        public static var allCases: [SortOrder] {
            return [
                .asc,
                .desc,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .asc: return "ASC"
            case .desc: return "DESC"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SortOrder(rawValue: rawValue) ?? SortOrder.sdkUnknown(rawValue)
        }
    }
}

extension MigrationHubStrategyClientTypes.SourceCode: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case location
        case projectName
        case sourceVersion
        case versionControl
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let location = self.location {
            try encodeContainer.encode(location, forKey: .location)
        }
        if let projectName = self.projectName {
            try encodeContainer.encode(projectName, forKey: .projectName)
        }
        if let sourceVersion = self.sourceVersion {
            try encodeContainer.encode(sourceVersion, forKey: .sourceVersion)
        }
        if let versionControl = self.versionControl {
            try encodeContainer.encode(versionControl.rawValue, forKey: .versionControl)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let versionControlDecoded = try containerValues.decodeIfPresent(MigrationHubStrategyClientTypes.VersionControl.self, forKey: .versionControl)
        versionControl = versionControlDecoded
        let sourceVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceVersion)
        sourceVersion = sourceVersionDecoded
        let locationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .location)
        location = locationDecoded
        let projectNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectName)
        projectName = projectNameDecoded
    }
}

extension MigrationHubStrategyClientTypes {
    /// Object containing source code information that is linked to an application component.
    public struct SourceCode: Swift.Equatable {
        /// The repository name for the source code.
        public var location: Swift.String?
        /// The name of the project.
        public var projectName: Swift.String?
        /// The branch of the source code.
        public var sourceVersion: Swift.String?
        /// The type of repository to use for the source code.
        public var versionControl: MigrationHubStrategyClientTypes.VersionControl?

        public init(
            location: Swift.String? = nil,
            projectName: Swift.String? = nil,
            sourceVersion: Swift.String? = nil,
            versionControl: MigrationHubStrategyClientTypes.VersionControl? = nil
        )
        {
            self.location = location
            self.projectName = projectName
            self.sourceVersion = sourceVersion
            self.versionControl = versionControl
        }
    }

}

extension MigrationHubStrategyClientTypes {
    public enum SourceCodeAnalyzerName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case bytecodeAnalyzer
        case csharpAnalyzer
        case javaAnalyzer
        case portingAssistant
        case sdkUnknown(Swift.String)

        public static var allCases: [SourceCodeAnalyzerName] {
            return [
                .bytecodeAnalyzer,
                .csharpAnalyzer,
                .javaAnalyzer,
                .portingAssistant,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .bytecodeAnalyzer: return "BYTECODE_ANALYZER"
            case .csharpAnalyzer: return "CSHARP_ANALYZER"
            case .javaAnalyzer: return "JAVA_ANALYZER"
            case .portingAssistant: return "PORTING_ASSISTANT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SourceCodeAnalyzerName(rawValue: rawValue) ?? SourceCodeAnalyzerName.sdkUnknown(rawValue)
        }
    }
}

extension MigrationHubStrategyClientTypes.SourceCodeRepository: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case branch
        case projectName
        case repository
        case versionControlType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let branch = self.branch {
            try encodeContainer.encode(branch, forKey: .branch)
        }
        if let projectName = self.projectName {
            try encodeContainer.encode(projectName, forKey: .projectName)
        }
        if let repository = self.repository {
            try encodeContainer.encode(repository, forKey: .repository)
        }
        if let versionControlType = self.versionControlType {
            try encodeContainer.encode(versionControlType, forKey: .versionControlType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repository)
        repository = repositoryDecoded
        let branchDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .branch)
        branch = branchDecoded
        let versionControlTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .versionControlType)
        versionControlType = versionControlTypeDecoded
        let projectNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectName)
        projectName = projectNameDecoded
    }
}

extension MigrationHubStrategyClientTypes {
    /// Object containing source code information that is linked to an application component.
    public struct SourceCodeRepository: Swift.Equatable {
        /// The branch of the source code.
        public var branch: Swift.String?
        /// The name of the project.
        public var projectName: Swift.String?
        /// The repository name for the source code.
        public var repository: Swift.String?
        /// The type of repository to use for the source code.
        public var versionControlType: Swift.String?

        public init(
            branch: Swift.String? = nil,
            projectName: Swift.String? = nil,
            repository: Swift.String? = nil,
            versionControlType: Swift.String? = nil
        )
        {
            self.branch = branch
            self.projectName = projectName
            self.repository = repository
            self.versionControlType = versionControlType
        }
    }

}

extension MigrationHubStrategyClientTypes {
    public enum SrcCodeOrDbAnalysisStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case analysisFailed
        case analysisPartialSuccess
        case analysisStarted
        case analysisSuccess
        case analysisToBeScheduled
        case configured
        case unconfigured
        case sdkUnknown(Swift.String)

        public static var allCases: [SrcCodeOrDbAnalysisStatus] {
            return [
                .analysisFailed,
                .analysisPartialSuccess,
                .analysisStarted,
                .analysisSuccess,
                .analysisToBeScheduled,
                .configured,
                .unconfigured,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .analysisFailed: return "ANALYSIS_FAILED"
            case .analysisPartialSuccess: return "ANALYSIS_PARTIAL_SUCCESS"
            case .analysisStarted: return "ANALYSIS_STARTED"
            case .analysisSuccess: return "ANALYSIS_SUCCESS"
            case .analysisToBeScheduled: return "ANALYSIS_TO_BE_SCHEDULED"
            case .configured: return "CONFIGURED"
            case .unconfigured: return "UNCONFIGURED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SrcCodeOrDbAnalysisStatus(rawValue: rawValue) ?? SrcCodeOrDbAnalysisStatus.sdkUnknown(rawValue)
        }
    }
}

extension StartAssessmentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentTargets
        case s3bucketForAnalysisData
        case s3bucketForReportData
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assessmentTargets = assessmentTargets {
            var assessmentTargetsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .assessmentTargets)
            for assessmenttarget0 in assessmentTargets {
                try assessmentTargetsContainer.encode(assessmenttarget0)
            }
        }
        if let s3bucketForAnalysisData = self.s3bucketForAnalysisData {
            try encodeContainer.encode(s3bucketForAnalysisData, forKey: .s3bucketForAnalysisData)
        }
        if let s3bucketForReportData = self.s3bucketForReportData {
            try encodeContainer.encode(s3bucketForReportData, forKey: .s3bucketForReportData)
        }
    }
}

extension StartAssessmentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/start-assessment"
    }
}

public struct StartAssessmentInput: Swift.Equatable {
    /// List of criteria for assessment.
    public var assessmentTargets: [MigrationHubStrategyClientTypes.AssessmentTarget]?
    /// The S3 bucket used by the collectors to send analysis data to the service. The bucket name must begin with migrationhub-strategy-.
    public var s3bucketForAnalysisData: Swift.String?
    /// The S3 bucket where all the reports generated by the service are stored. The bucket name must begin with migrationhub-strategy-.
    public var s3bucketForReportData: Swift.String?

    public init(
        assessmentTargets: [MigrationHubStrategyClientTypes.AssessmentTarget]? = nil,
        s3bucketForAnalysisData: Swift.String? = nil,
        s3bucketForReportData: Swift.String? = nil
    )
    {
        self.assessmentTargets = assessmentTargets
        self.s3bucketForAnalysisData = s3bucketForAnalysisData
        self.s3bucketForReportData = s3bucketForReportData
    }
}

struct StartAssessmentInputBody: Swift.Equatable {
    let s3bucketForAnalysisData: Swift.String?
    let s3bucketForReportData: Swift.String?
    let assessmentTargets: [MigrationHubStrategyClientTypes.AssessmentTarget]?
}

extension StartAssessmentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentTargets
        case s3bucketForAnalysisData
        case s3bucketForReportData
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3bucketForAnalysisDataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3bucketForAnalysisData)
        s3bucketForAnalysisData = s3bucketForAnalysisDataDecoded
        let s3bucketForReportDataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3bucketForReportData)
        s3bucketForReportData = s3bucketForReportDataDecoded
        let assessmentTargetsContainer = try containerValues.decodeIfPresent([MigrationHubStrategyClientTypes.AssessmentTarget?].self, forKey: .assessmentTargets)
        var assessmentTargetsDecoded0:[MigrationHubStrategyClientTypes.AssessmentTarget]? = nil
        if let assessmentTargetsContainer = assessmentTargetsContainer {
            assessmentTargetsDecoded0 = [MigrationHubStrategyClientTypes.AssessmentTarget]()
            for structure0 in assessmentTargetsContainer {
                if let structure0 = structure0 {
                    assessmentTargetsDecoded0?.append(structure0)
                }
            }
        }
        assessmentTargets = assessmentTargetsDecoded0
    }
}

extension StartAssessmentOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StartAssessmentOutputBody = try responseDecoder.decode(responseBody: data)
            self.assessmentId = output.assessmentId
        } else {
            self.assessmentId = nil
        }
    }
}

public struct StartAssessmentOutput: Swift.Equatable {
    /// The ID of the assessment.
    public var assessmentId: Swift.String?

    public init(
        assessmentId: Swift.String? = nil
    )
    {
        self.assessmentId = assessmentId
    }
}

struct StartAssessmentOutputBody: Swift.Equatable {
    let assessmentId: Swift.String?
}

extension StartAssessmentOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assessmentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assessmentId)
        assessmentId = assessmentIdDecoded
    }
}

enum StartAssessmentOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension StartImportFileTaskInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3Bucket = "S3Bucket"
        case dataSourceType
        case groupId
        case name
        case s3bucketForReportData
        case s3key
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let s3Bucket = self.s3Bucket {
            try encodeContainer.encode(s3Bucket, forKey: .s3Bucket)
        }
        if let dataSourceType = self.dataSourceType {
            try encodeContainer.encode(dataSourceType.rawValue, forKey: .dataSourceType)
        }
        if let groupId = groupId {
            var groupIdContainer = encodeContainer.nestedUnkeyedContainer(forKey: .groupId)
            for group0 in groupId {
                try groupIdContainer.encode(group0)
            }
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let s3bucketForReportData = self.s3bucketForReportData {
            try encodeContainer.encode(s3bucketForReportData, forKey: .s3bucketForReportData)
        }
        if let s3key = self.s3key {
            try encodeContainer.encode(s3key, forKey: .s3key)
        }
    }
}

extension StartImportFileTaskInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/start-import-file-task"
    }
}

public struct StartImportFileTaskInput: Swift.Equatable {
    /// Specifies the source that the servers are coming from. By default, Strategy Recommendations assumes that the servers specified in the import file are available in AWS Application Discovery Service.
    public var dataSourceType: MigrationHubStrategyClientTypes.DataSourceType?
    /// Groups the resources in the import file together with a unique name. This ID can be as filter in ListApplicationComponents and ListServers.
    public var groupId: [MigrationHubStrategyClientTypes.Group]?
    /// A descriptive name for the request.
    /// This member is required.
    public var name: Swift.String?
    /// The S3 bucket where the import file is located. The bucket name is required to begin with migrationhub-strategy-.
    /// This member is required.
    public var s3Bucket: Swift.String?
    /// The S3 bucket where Strategy Recommendations uploads import results. The bucket name is required to begin with migrationhub-strategy-.
    public var s3bucketForReportData: Swift.String?
    /// The Amazon S3 key name of the import file.
    /// This member is required.
    public var s3key: Swift.String?

    public init(
        dataSourceType: MigrationHubStrategyClientTypes.DataSourceType? = nil,
        groupId: [MigrationHubStrategyClientTypes.Group]? = nil,
        name: Swift.String? = nil,
        s3Bucket: Swift.String? = nil,
        s3bucketForReportData: Swift.String? = nil,
        s3key: Swift.String? = nil
    )
    {
        self.dataSourceType = dataSourceType
        self.groupId = groupId
        self.name = name
        self.s3Bucket = s3Bucket
        self.s3bucketForReportData = s3bucketForReportData
        self.s3key = s3key
    }
}

struct StartImportFileTaskInputBody: Swift.Equatable {
    let name: Swift.String?
    let s3Bucket: Swift.String?
    let s3key: Swift.String?
    let dataSourceType: MigrationHubStrategyClientTypes.DataSourceType?
    let groupId: [MigrationHubStrategyClientTypes.Group]?
    let s3bucketForReportData: Swift.String?
}

extension StartImportFileTaskInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3Bucket = "S3Bucket"
        case dataSourceType
        case groupId
        case name
        case s3bucketForReportData
        case s3key
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let s3BucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3Bucket)
        s3Bucket = s3BucketDecoded
        let s3keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3key)
        s3key = s3keyDecoded
        let dataSourceTypeDecoded = try containerValues.decodeIfPresent(MigrationHubStrategyClientTypes.DataSourceType.self, forKey: .dataSourceType)
        dataSourceType = dataSourceTypeDecoded
        let groupIdContainer = try containerValues.decodeIfPresent([MigrationHubStrategyClientTypes.Group?].self, forKey: .groupId)
        var groupIdDecoded0:[MigrationHubStrategyClientTypes.Group]? = nil
        if let groupIdContainer = groupIdContainer {
            groupIdDecoded0 = [MigrationHubStrategyClientTypes.Group]()
            for structure0 in groupIdContainer {
                if let structure0 = structure0 {
                    groupIdDecoded0?.append(structure0)
                }
            }
        }
        groupId = groupIdDecoded0
        let s3bucketForReportDataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3bucketForReportData)
        s3bucketForReportData = s3bucketForReportDataDecoded
    }
}

extension StartImportFileTaskOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StartImportFileTaskOutputBody = try responseDecoder.decode(responseBody: data)
            self.id = output.id
        } else {
            self.id = nil
        }
    }
}

public struct StartImportFileTaskOutput: Swift.Equatable {
    /// The ID for a specific import task. The ID is unique within an AWS account.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct StartImportFileTaskOutputBody: Swift.Equatable {
    let id: Swift.String?
}

extension StartImportFileTaskOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
    }
}

enum StartImportFileTaskOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension StartRecommendationReportGenerationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupIdFilter
        case outputFormat
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let groupIdFilter = groupIdFilter {
            var groupIdFilterContainer = encodeContainer.nestedUnkeyedContainer(forKey: .groupIdFilter)
            for group0 in groupIdFilter {
                try groupIdFilterContainer.encode(group0)
            }
        }
        if let outputFormat = self.outputFormat {
            try encodeContainer.encode(outputFormat.rawValue, forKey: .outputFormat)
        }
    }
}

extension StartRecommendationReportGenerationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/start-recommendation-report-generation"
    }
}

public struct StartRecommendationReportGenerationInput: Swift.Equatable {
    /// Groups the resources in the recommendation report with a unique name.
    public var groupIdFilter: [MigrationHubStrategyClientTypes.Group]?
    /// The output format for the recommendation report file. The default format is Microsoft Excel.
    public var outputFormat: MigrationHubStrategyClientTypes.OutputFormat?

    public init(
        groupIdFilter: [MigrationHubStrategyClientTypes.Group]? = nil,
        outputFormat: MigrationHubStrategyClientTypes.OutputFormat? = nil
    )
    {
        self.groupIdFilter = groupIdFilter
        self.outputFormat = outputFormat
    }
}

struct StartRecommendationReportGenerationInputBody: Swift.Equatable {
    let outputFormat: MigrationHubStrategyClientTypes.OutputFormat?
    let groupIdFilter: [MigrationHubStrategyClientTypes.Group]?
}

extension StartRecommendationReportGenerationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupIdFilter
        case outputFormat
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let outputFormatDecoded = try containerValues.decodeIfPresent(MigrationHubStrategyClientTypes.OutputFormat.self, forKey: .outputFormat)
        outputFormat = outputFormatDecoded
        let groupIdFilterContainer = try containerValues.decodeIfPresent([MigrationHubStrategyClientTypes.Group?].self, forKey: .groupIdFilter)
        var groupIdFilterDecoded0:[MigrationHubStrategyClientTypes.Group]? = nil
        if let groupIdFilterContainer = groupIdFilterContainer {
            groupIdFilterDecoded0 = [MigrationHubStrategyClientTypes.Group]()
            for structure0 in groupIdFilterContainer {
                if let structure0 = structure0 {
                    groupIdFilterDecoded0?.append(structure0)
                }
            }
        }
        groupIdFilter = groupIdFilterDecoded0
    }
}

extension StartRecommendationReportGenerationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StartRecommendationReportGenerationOutputBody = try responseDecoder.decode(responseBody: data)
            self.id = output.id
        } else {
            self.id = nil
        }
    }
}

public struct StartRecommendationReportGenerationOutput: Swift.Equatable {
    /// The ID of the recommendation report generation task.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct StartRecommendationReportGenerationOutputBody: Swift.Equatable {
    let id: Swift.String?
}

extension StartRecommendationReportGenerationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
    }
}

enum StartRecommendationReportGenerationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension StopAssessmentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assessmentId = self.assessmentId {
            try encodeContainer.encode(assessmentId, forKey: .assessmentId)
        }
    }
}

extension StopAssessmentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/stop-assessment"
    }
}

public struct StopAssessmentInput: Swift.Equatable {
    /// The assessmentId returned by [StartAssessment].
    /// This member is required.
    public var assessmentId: Swift.String?

    public init(
        assessmentId: Swift.String? = nil
    )
    {
        self.assessmentId = assessmentId
    }
}

struct StopAssessmentInputBody: Swift.Equatable {
    let assessmentId: Swift.String?
}

extension StopAssessmentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assessmentId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assessmentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assessmentId)
        assessmentId = assessmentIdDecoded
    }
}

extension StopAssessmentOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct StopAssessmentOutput: Swift.Equatable {

    public init() { }
}

enum StopAssessmentOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension MigrationHubStrategyClientTypes {
    public enum Strategy: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case refactor
        case rehost
        case relocate
        case replatform
        case repurchase
        case retain
        case retirement
        case sdkUnknown(Swift.String)

        public static var allCases: [Strategy] {
            return [
                .refactor,
                .rehost,
                .relocate,
                .replatform,
                .repurchase,
                .retain,
                .retirement,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .refactor: return "Refactor"
            case .rehost: return "Rehost"
            case .relocate: return "Relocate"
            case .replatform: return "Replatform"
            case .repurchase: return "Repurchase"
            case .retain: return "Retain"
            case .retirement: return "Retirement"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Strategy(rawValue: rawValue) ?? Strategy.sdkUnknown(rawValue)
        }
    }
}

extension MigrationHubStrategyClientTypes.StrategyOption: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case isPreferred
        case strategy
        case targetDestination
        case toolName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let isPreferred = self.isPreferred {
            try encodeContainer.encode(isPreferred, forKey: .isPreferred)
        }
        if let strategy = self.strategy {
            try encodeContainer.encode(strategy.rawValue, forKey: .strategy)
        }
        if let targetDestination = self.targetDestination {
            try encodeContainer.encode(targetDestination.rawValue, forKey: .targetDestination)
        }
        if let toolName = self.toolName {
            try encodeContainer.encode(toolName.rawValue, forKey: .toolName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let strategyDecoded = try containerValues.decodeIfPresent(MigrationHubStrategyClientTypes.Strategy.self, forKey: .strategy)
        strategy = strategyDecoded
        let toolNameDecoded = try containerValues.decodeIfPresent(MigrationHubStrategyClientTypes.TransformationToolName.self, forKey: .toolName)
        toolName = toolNameDecoded
        let targetDestinationDecoded = try containerValues.decodeIfPresent(MigrationHubStrategyClientTypes.TargetDestination.self, forKey: .targetDestination)
        targetDestination = targetDestinationDecoded
        let isPreferredDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isPreferred)
        isPreferred = isPreferredDecoded
    }
}

extension MigrationHubStrategyClientTypes {
    /// Information about all the available strategy options for migrating and modernizing an application component.
    public struct StrategyOption: Swift.Equatable {
        /// Indicates if a specific strategy is preferred for the application component.
        public var isPreferred: Swift.Bool?
        /// Type of transformation. For example, Rehost, Replatform, and so on.
        public var strategy: MigrationHubStrategyClientTypes.Strategy?
        /// Destination information about where the application component can migrate to. For example, EC2, ECS, and so on.
        public var targetDestination: MigrationHubStrategyClientTypes.TargetDestination?
        /// The name of the tool that can be used to transform an application component using this strategy.
        public var toolName: MigrationHubStrategyClientTypes.TransformationToolName?

        public init(
            isPreferred: Swift.Bool? = nil,
            strategy: MigrationHubStrategyClientTypes.Strategy? = nil,
            targetDestination: MigrationHubStrategyClientTypes.TargetDestination? = nil,
            toolName: MigrationHubStrategyClientTypes.TransformationToolName? = nil
        )
        {
            self.isPreferred = isPreferred
            self.strategy = strategy
            self.targetDestination = targetDestination
            self.toolName = toolName
        }
    }

}

extension MigrationHubStrategyClientTypes {
    public enum StrategyRecommendation: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case notRecommended
        case potential
        case recommended
        case viableOption
        case sdkUnknown(Swift.String)

        public static var allCases: [StrategyRecommendation] {
            return [
                .notRecommended,
                .potential,
                .recommended,
                .viableOption,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .notRecommended: return "notRecommended"
            case .potential: return "potential"
            case .recommended: return "recommended"
            case .viableOption: return "viableOption"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = StrategyRecommendation(rawValue: rawValue) ?? StrategyRecommendation.sdkUnknown(rawValue)
        }
    }
}

extension MigrationHubStrategyClientTypes.StrategySummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case count
        case strategy
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let count = self.count {
            try encodeContainer.encode(count, forKey: .count)
        }
        if let strategy = self.strategy {
            try encodeContainer.encode(strategy.rawValue, forKey: .strategy)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let strategyDecoded = try containerValues.decodeIfPresent(MigrationHubStrategyClientTypes.Strategy.self, forKey: .strategy)
        strategy = strategyDecoded
        let countDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .count)
        count = countDecoded
    }
}

extension MigrationHubStrategyClientTypes {
    /// Object containing the summary of the strategy recommendations.
    public struct StrategySummary: Swift.Equatable {
        /// The count of recommendations per strategy.
        public var count: Swift.Int?
        /// The name of recommended strategy.
        public var strategy: MigrationHubStrategyClientTypes.Strategy?

        public init(
            count: Swift.Int? = nil,
            strategy: MigrationHubStrategyClientTypes.Strategy? = nil
        )
        {
            self.count = count
            self.strategy = strategy
        }
    }

}

extension MigrationHubStrategyClientTypes.SystemInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cpuArchitecture
        case fileSystemType
        case networkInfoList
        case osInfo
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cpuArchitecture = self.cpuArchitecture {
            try encodeContainer.encode(cpuArchitecture, forKey: .cpuArchitecture)
        }
        if let fileSystemType = self.fileSystemType {
            try encodeContainer.encode(fileSystemType, forKey: .fileSystemType)
        }
        if let networkInfoList = networkInfoList {
            var networkInfoListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .networkInfoList)
            for networkinfo0 in networkInfoList {
                try networkInfoListContainer.encode(networkinfo0)
            }
        }
        if let osInfo = self.osInfo {
            try encodeContainer.encode(osInfo, forKey: .osInfo)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let osInfoDecoded = try containerValues.decodeIfPresent(MigrationHubStrategyClientTypes.OSInfo.self, forKey: .osInfo)
        osInfo = osInfoDecoded
        let fileSystemTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fileSystemType)
        fileSystemType = fileSystemTypeDecoded
        let networkInfoListContainer = try containerValues.decodeIfPresent([MigrationHubStrategyClientTypes.NetworkInfo?].self, forKey: .networkInfoList)
        var networkInfoListDecoded0:[MigrationHubStrategyClientTypes.NetworkInfo]? = nil
        if let networkInfoListContainer = networkInfoListContainer {
            networkInfoListDecoded0 = [MigrationHubStrategyClientTypes.NetworkInfo]()
            for structure0 in networkInfoListContainer {
                if let structure0 = structure0 {
                    networkInfoListDecoded0?.append(structure0)
                }
            }
        }
        networkInfoList = networkInfoListDecoded0
        let cpuArchitectureDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cpuArchitecture)
        cpuArchitecture = cpuArchitectureDecoded
    }
}

extension MigrationHubStrategyClientTypes {
    /// Information about the server that hosts application components.
    public struct SystemInfo: Swift.Equatable {
        /// CPU architecture type for the server.
        public var cpuArchitecture: Swift.String?
        /// File system type for the server.
        public var fileSystemType: Swift.String?
        /// Networking information related to a server.
        public var networkInfoList: [MigrationHubStrategyClientTypes.NetworkInfo]?
        /// Operating system corresponding to a server.
        public var osInfo: MigrationHubStrategyClientTypes.OSInfo?

        public init(
            cpuArchitecture: Swift.String? = nil,
            fileSystemType: Swift.String? = nil,
            networkInfoList: [MigrationHubStrategyClientTypes.NetworkInfo]? = nil,
            osInfo: MigrationHubStrategyClientTypes.OSInfo? = nil
        )
        {
            self.cpuArchitecture = cpuArchitecture
            self.fileSystemType = fileSystemType
            self.networkInfoList = networkInfoList
            self.osInfo = osInfo
        }
    }

}

extension MigrationHubStrategyClientTypes {
    public enum TargetDatabaseEngine: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case amazonAurora
        case awsPostgresql
        case db2Luw
        case mariaDb
        case microsoftSqlServer
        case mongoDb
        case mysql
        case noneSpecified
        case oracleDatabase
        case sap
        case sdkUnknown(Swift.String)

        public static var allCases: [TargetDatabaseEngine] {
            return [
                .amazonAurora,
                .awsPostgresql,
                .db2Luw,
                .mariaDb,
                .microsoftSqlServer,
                .mongoDb,
                .mysql,
                .noneSpecified,
                .oracleDatabase,
                .sap,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .amazonAurora: return "Amazon Aurora"
            case .awsPostgresql: return "AWS PostgreSQL"
            case .db2Luw: return "Db2 LUW"
            case .mariaDb: return "MariaDB"
            case .microsoftSqlServer: return "Microsoft SQL Server"
            case .mongoDb: return "MongoDB"
            case .mysql: return "MySQL"
            case .noneSpecified: return "None specified"
            case .oracleDatabase: return "Oracle Database"
            case .sap: return "SAP"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TargetDatabaseEngine(rawValue: rawValue) ?? TargetDatabaseEngine.sdkUnknown(rawValue)
        }
    }
}

extension MigrationHubStrategyClientTypes {
    public enum TargetDestination: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case amazonDocumentdb
        case amazonDynamodb
        case amazonElasticCloudCompute
        case amazonElasticContainerService
        case amazonElasticKubernetesService
        case amazonRds
        case amazonRdsMysql
        case amazonRdsPostgresql
        case auroraMysql
        case auroraPostgresql
        case awsElasticBeanstalk
        case awsFargate
        case babelfishAuroraPostgresql
        case noneSpecified
        case sdkUnknown(Swift.String)

        public static var allCases: [TargetDestination] {
            return [
                .amazonDocumentdb,
                .amazonDynamodb,
                .amazonElasticCloudCompute,
                .amazonElasticContainerService,
                .amazonElasticKubernetesService,
                .amazonRds,
                .amazonRdsMysql,
                .amazonRdsPostgresql,
                .auroraMysql,
                .auroraPostgresql,
                .awsElasticBeanstalk,
                .awsFargate,
                .babelfishAuroraPostgresql,
                .noneSpecified,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .amazonDocumentdb: return "Amazon DocumentDB"
            case .amazonDynamodb: return "Amazon DynamoDB"
            case .amazonElasticCloudCompute: return "Amazon Elastic Cloud Compute (EC2)"
            case .amazonElasticContainerService: return "Amazon Elastic Container Service (ECS)"
            case .amazonElasticKubernetesService: return "Amazon Elastic Kubernetes Service (EKS)"
            case .amazonRds: return "Amazon Relational Database Service"
            case .amazonRdsMysql: return "Amazon Relational Database Service on MySQL"
            case .amazonRdsPostgresql: return "Amazon Relational Database Service on PostgreSQL"
            case .auroraMysql: return "Aurora MySQL"
            case .auroraPostgresql: return "Aurora PostgreSQL"
            case .awsElasticBeanstalk: return "AWS Elastic BeanStalk"
            case .awsFargate: return "AWS Fargate"
            case .babelfishAuroraPostgresql: return "Babelfish for Aurora PostgreSQL"
            case .noneSpecified: return "None specified"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TargetDestination(rawValue: rawValue) ?? TargetDestination.sdkUnknown(rawValue)
        }
    }
}

extension ThrottlingException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request was denied due to request throttling.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MigrationHubStrategyClientTypes.TransformationTool: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case name
        case tranformationToolInstallationLink
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let tranformationToolInstallationLink = self.tranformationToolInstallationLink {
            try encodeContainer.encode(tranformationToolInstallationLink, forKey: .tranformationToolInstallationLink)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(MigrationHubStrategyClientTypes.TransformationToolName.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let tranformationToolInstallationLinkDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tranformationToolInstallationLink)
        tranformationToolInstallationLink = tranformationToolInstallationLinkDecoded
    }
}

extension MigrationHubStrategyClientTypes {
    /// Information of the transformation tool that can be used to migrate and modernize the application.
    public struct TransformationTool: Swift.Equatable {
        /// Description of the tool.
        public var description: Swift.String?
        /// Name of the tool.
        public var name: MigrationHubStrategyClientTypes.TransformationToolName?
        /// URL for installing the tool.
        public var tranformationToolInstallationLink: Swift.String?

        public init(
            description: Swift.String? = nil,
            name: MigrationHubStrategyClientTypes.TransformationToolName? = nil,
            tranformationToolInstallationLink: Swift.String? = nil
        )
        {
            self.description = description
            self.name = name
            self.tranformationToolInstallationLink = tranformationToolInstallationLink
        }
    }

}

extension MigrationHubStrategyClientTypes {
    public enum TransformationToolName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case app2container
        case dms
        case emp
        case inPlaceOsUpgrade
        case mgn
        case nativeSql
        case portingAssistant
        case sct
        case strategyRecommendationSupport
        case wwama
        case sdkUnknown(Swift.String)

        public static var allCases: [TransformationToolName] {
            return [
                .app2container,
                .dms,
                .emp,
                .inPlaceOsUpgrade,
                .mgn,
                .nativeSql,
                .portingAssistant,
                .sct,
                .strategyRecommendationSupport,
                .wwama,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .app2container: return "App2Container"
            case .dms: return "Database Migration Service"
            case .emp: return "End of Support Migration"
            case .inPlaceOsUpgrade: return "In Place Operating System Upgrade"
            case .mgn: return "Application Migration Service"
            case .nativeSql: return "Native SQL Server Backup/Restore"
            case .portingAssistant: return "Porting Assistant For .NET"
            case .sct: return "Schema Conversion Tool"
            case .strategyRecommendationSupport: return "Strategy Recommendation Support"
            case .wwama: return "Windows Web Application Migration Assistant"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TransformationToolName(rawValue: rawValue) ?? TransformationToolName.sdkUnknown(rawValue)
        }
    }
}

extension UpdateApplicationComponentConfigInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateApplicationComponentConfigInput(appType: \(Swift.String(describing: appType)), applicationComponentId: \(Swift.String(describing: applicationComponentId)), configureOnly: \(Swift.String(describing: configureOnly)), inclusionStatus: \(Swift.String(describing: inclusionStatus)), sourceCodeList: \(Swift.String(describing: sourceCodeList)), strategyOption: \(Swift.String(describing: strategyOption)), secretsManagerKey: \"CONTENT_REDACTED\")"}
}

extension UpdateApplicationComponentConfigInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appType
        case applicationComponentId
        case configureOnly
        case inclusionStatus
        case secretsManagerKey
        case sourceCodeList
        case strategyOption
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appType = self.appType {
            try encodeContainer.encode(appType.rawValue, forKey: .appType)
        }
        if let applicationComponentId = self.applicationComponentId {
            try encodeContainer.encode(applicationComponentId, forKey: .applicationComponentId)
        }
        if let configureOnly = self.configureOnly {
            try encodeContainer.encode(configureOnly, forKey: .configureOnly)
        }
        if let inclusionStatus = self.inclusionStatus {
            try encodeContainer.encode(inclusionStatus.rawValue, forKey: .inclusionStatus)
        }
        if let secretsManagerKey = self.secretsManagerKey {
            try encodeContainer.encode(secretsManagerKey, forKey: .secretsManagerKey)
        }
        if let sourceCodeList = sourceCodeList {
            var sourceCodeListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sourceCodeList)
            for sourcecode0 in sourceCodeList {
                try sourceCodeListContainer.encode(sourcecode0)
            }
        }
        if let strategyOption = self.strategyOption {
            try encodeContainer.encode(strategyOption, forKey: .strategyOption)
        }
    }
}

extension UpdateApplicationComponentConfigInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/update-applicationcomponent-config"
    }
}

public struct UpdateApplicationComponentConfigInput: Swift.Equatable {
    /// The type of known component.
    public var appType: MigrationHubStrategyClientTypes.AppType?
    /// The ID of the application component. The ID is unique within an AWS account.
    /// This member is required.
    public var applicationComponentId: Swift.String?
    /// Update the configuration request of an application component. If it is set to true, the source code and/or database credentials are updated. If it is set to false, the source code and/or database credentials are updated and an analysis is initiated.
    public var configureOnly: Swift.Bool?
    /// Indicates whether the application component has been included for server recommendation or not.
    public var inclusionStatus: MigrationHubStrategyClientTypes.InclusionStatus?
    /// Database credentials.
    public var secretsManagerKey: Swift.String?
    /// The list of source code configurations to update for the application component.
    public var sourceCodeList: [MigrationHubStrategyClientTypes.SourceCode]?
    /// The preferred strategy options for the application component. Use values from the [GetApplicationComponentStrategies] response.
    public var strategyOption: MigrationHubStrategyClientTypes.StrategyOption?

    public init(
        appType: MigrationHubStrategyClientTypes.AppType? = nil,
        applicationComponentId: Swift.String? = nil,
        configureOnly: Swift.Bool? = nil,
        inclusionStatus: MigrationHubStrategyClientTypes.InclusionStatus? = nil,
        secretsManagerKey: Swift.String? = nil,
        sourceCodeList: [MigrationHubStrategyClientTypes.SourceCode]? = nil,
        strategyOption: MigrationHubStrategyClientTypes.StrategyOption? = nil
    )
    {
        self.appType = appType
        self.applicationComponentId = applicationComponentId
        self.configureOnly = configureOnly
        self.inclusionStatus = inclusionStatus
        self.secretsManagerKey = secretsManagerKey
        self.sourceCodeList = sourceCodeList
        self.strategyOption = strategyOption
    }
}

struct UpdateApplicationComponentConfigInputBody: Swift.Equatable {
    let applicationComponentId: Swift.String?
    let inclusionStatus: MigrationHubStrategyClientTypes.InclusionStatus?
    let strategyOption: MigrationHubStrategyClientTypes.StrategyOption?
    let sourceCodeList: [MigrationHubStrategyClientTypes.SourceCode]?
    let secretsManagerKey: Swift.String?
    let configureOnly: Swift.Bool?
    let appType: MigrationHubStrategyClientTypes.AppType?
}

extension UpdateApplicationComponentConfigInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appType
        case applicationComponentId
        case configureOnly
        case inclusionStatus
        case secretsManagerKey
        case sourceCodeList
        case strategyOption
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let applicationComponentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .applicationComponentId)
        applicationComponentId = applicationComponentIdDecoded
        let inclusionStatusDecoded = try containerValues.decodeIfPresent(MigrationHubStrategyClientTypes.InclusionStatus.self, forKey: .inclusionStatus)
        inclusionStatus = inclusionStatusDecoded
        let strategyOptionDecoded = try containerValues.decodeIfPresent(MigrationHubStrategyClientTypes.StrategyOption.self, forKey: .strategyOption)
        strategyOption = strategyOptionDecoded
        let sourceCodeListContainer = try containerValues.decodeIfPresent([MigrationHubStrategyClientTypes.SourceCode?].self, forKey: .sourceCodeList)
        var sourceCodeListDecoded0:[MigrationHubStrategyClientTypes.SourceCode]? = nil
        if let sourceCodeListContainer = sourceCodeListContainer {
            sourceCodeListDecoded0 = [MigrationHubStrategyClientTypes.SourceCode]()
            for structure0 in sourceCodeListContainer {
                if let structure0 = structure0 {
                    sourceCodeListDecoded0?.append(structure0)
                }
            }
        }
        sourceCodeList = sourceCodeListDecoded0
        let secretsManagerKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretsManagerKey)
        secretsManagerKey = secretsManagerKeyDecoded
        let configureOnlyDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .configureOnly)
        configureOnly = configureOnlyDecoded
        let appTypeDecoded = try containerValues.decodeIfPresent(MigrationHubStrategyClientTypes.AppType.self, forKey: .appType)
        appType = appTypeDecoded
    }
}

extension UpdateApplicationComponentConfigOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateApplicationComponentConfigOutput: Swift.Equatable {

    public init() { }
}

enum UpdateApplicationComponentConfigOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateServerConfigInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serverId
        case strategyOption
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let serverId = self.serverId {
            try encodeContainer.encode(serverId, forKey: .serverId)
        }
        if let strategyOption = self.strategyOption {
            try encodeContainer.encode(strategyOption, forKey: .strategyOption)
        }
    }
}

extension UpdateServerConfigInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/update-server-config"
    }
}

public struct UpdateServerConfigInput: Swift.Equatable {
    /// The ID of the server.
    /// This member is required.
    public var serverId: Swift.String?
    /// The preferred strategy options for the application component. See the response from [GetServerStrategies].
    public var strategyOption: MigrationHubStrategyClientTypes.StrategyOption?

    public init(
        serverId: Swift.String? = nil,
        strategyOption: MigrationHubStrategyClientTypes.StrategyOption? = nil
    )
    {
        self.serverId = serverId
        self.strategyOption = strategyOption
    }
}

struct UpdateServerConfigInputBody: Swift.Equatable {
    let serverId: Swift.String?
    let strategyOption: MigrationHubStrategyClientTypes.StrategyOption?
}

extension UpdateServerConfigInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case serverId
        case strategyOption
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serverIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serverId)
        serverId = serverIdDecoded
        let strategyOptionDecoded = try containerValues.decodeIfPresent(MigrationHubStrategyClientTypes.StrategyOption.self, forKey: .strategyOption)
        strategyOption = strategyOptionDecoded
    }
}

extension UpdateServerConfigOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateServerConfigOutput: Swift.Equatable {

    public init() { }
}

enum UpdateServerConfigOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ValidationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request body isn't valid.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension MigrationHubStrategyClientTypes.VcenterBasedRemoteInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case osType
        case vcenterConfigurationTimeStamp
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let osType = self.osType {
            try encodeContainer.encode(osType.rawValue, forKey: .osType)
        }
        if let vcenterConfigurationTimeStamp = self.vcenterConfigurationTimeStamp {
            try encodeContainer.encode(vcenterConfigurationTimeStamp, forKey: .vcenterConfigurationTimeStamp)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vcenterConfigurationTimeStampDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vcenterConfigurationTimeStamp)
        vcenterConfigurationTimeStamp = vcenterConfigurationTimeStampDecoded
        let osTypeDecoded = try containerValues.decodeIfPresent(MigrationHubStrategyClientTypes.OSType.self, forKey: .osType)
        osType = osTypeDecoded
    }
}

extension MigrationHubStrategyClientTypes {
    /// Details about the server in vCenter.
    public struct VcenterBasedRemoteInfo: Swift.Equatable {
        /// The type of the operating system.
        public var osType: MigrationHubStrategyClientTypes.OSType?
        /// The time when the remote server based on vCenter was last configured.
        public var vcenterConfigurationTimeStamp: Swift.String?

        public init(
            osType: MigrationHubStrategyClientTypes.OSType? = nil,
            vcenterConfigurationTimeStamp: Swift.String? = nil
        )
        {
            self.osType = osType
            self.vcenterConfigurationTimeStamp = vcenterConfigurationTimeStamp
        }
    }

}

extension MigrationHubStrategyClientTypes {
    public enum VersionControl: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case azureDevopsGit
        case github
        case githubEnterprise
        case sdkUnknown(Swift.String)

        public static var allCases: [VersionControl] {
            return [
                .azureDevopsGit,
                .github,
                .githubEnterprise,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .azureDevopsGit: return "AZURE_DEVOPS_GIT"
            case .github: return "GITHUB"
            case .githubEnterprise: return "GITHUB_ENTERPRISE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = VersionControl(rawValue: rawValue) ?? VersionControl.sdkUnknown(rawValue)
        }
    }
}

extension MigrationHubStrategyClientTypes.VersionControlInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case versionControlConfigurationTimeStamp
        case versionControlType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let versionControlConfigurationTimeStamp = self.versionControlConfigurationTimeStamp {
            try encodeContainer.encode(versionControlConfigurationTimeStamp, forKey: .versionControlConfigurationTimeStamp)
        }
        if let versionControlType = self.versionControlType {
            try encodeContainer.encode(versionControlType.rawValue, forKey: .versionControlType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let versionControlTypeDecoded = try containerValues.decodeIfPresent(MigrationHubStrategyClientTypes.VersionControlType.self, forKey: .versionControlType)
        versionControlType = versionControlTypeDecoded
        let versionControlConfigurationTimeStampDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .versionControlConfigurationTimeStamp)
        versionControlConfigurationTimeStamp = versionControlConfigurationTimeStampDecoded
    }
}

extension MigrationHubStrategyClientTypes {
    /// Details about the version control configuration.
    public struct VersionControlInfo: Swift.Equatable {
        /// The time when the version control system was last configured.
        public var versionControlConfigurationTimeStamp: Swift.String?
        /// The type of version control.
        public var versionControlType: MigrationHubStrategyClientTypes.VersionControlType?

        public init(
            versionControlConfigurationTimeStamp: Swift.String? = nil,
            versionControlType: MigrationHubStrategyClientTypes.VersionControlType? = nil
        )
        {
            self.versionControlConfigurationTimeStamp = versionControlConfigurationTimeStamp
            self.versionControlType = versionControlType
        }
    }

}

extension MigrationHubStrategyClientTypes {
    public enum VersionControlType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case azureDevopsGit
        case github
        case githubEnterprise
        case sdkUnknown(Swift.String)

        public static var allCases: [VersionControlType] {
            return [
                .azureDevopsGit,
                .github,
                .githubEnterprise,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .azureDevopsGit: return "AZURE_DEVOPS_GIT"
            case .github: return "GITHUB"
            case .githubEnterprise: return "GITHUB_ENTERPRISE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = VersionControlType(rawValue: rawValue) ?? VersionControlType.sdkUnknown(rawValue)
        }
    }
}
