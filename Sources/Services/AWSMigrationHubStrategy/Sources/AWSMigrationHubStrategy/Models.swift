//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.RestJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
import struct Smithy.URIQueryItem
@_spi(SmithyReadWrite) import struct SmithyReadWrite.ReadingClosureBox
@_spi(SmithyReadWrite) import struct SmithyReadWrite.WritingClosureBox

/// The user does not have permission to perform the action. Check the AWS Identity and Access Management (IAM) policy associated with this user.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension MigrationHubStrategyClientTypes {

    public enum RuntimeAnalysisStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case analysisFailed
        case analysisStarted
        case analysisSuccess
        case analysisToBeScheduled
        case sdkUnknown(Swift.String)

        public static var allCases: [RuntimeAnalysisStatus] {
            return [
                .analysisFailed,
                .analysisStarted,
                .analysisSuccess,
                .analysisToBeScheduled
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .analysisFailed: return "ANALYSIS_FAILED"
            case .analysisStarted: return "ANALYSIS_STARTED"
            case .analysisSuccess: return "ANALYSIS_SUCCESS"
            case .analysisToBeScheduled: return "ANALYSIS_TO_BE_SCHEDULED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MigrationHubStrategyClientTypes {

    public enum SrcCodeOrDbAnalysisStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case analysisFailed
        case analysisPartialSuccess
        case analysisStarted
        case analysisSuccess
        case analysisToBeScheduled
        case configured
        case unconfigured
        case sdkUnknown(Swift.String)

        public static var allCases: [SrcCodeOrDbAnalysisStatus] {
            return [
                .analysisFailed,
                .analysisPartialSuccess,
                .analysisStarted,
                .analysisSuccess,
                .analysisToBeScheduled,
                .configured,
                .unconfigured
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .analysisFailed: return "ANALYSIS_FAILED"
            case .analysisPartialSuccess: return "ANALYSIS_PARTIAL_SUCCESS"
            case .analysisStarted: return "ANALYSIS_STARTED"
            case .analysisSuccess: return "ANALYSIS_SUCCESS"
            case .analysisToBeScheduled: return "ANALYSIS_TO_BE_SCHEDULED"
            case .configured: return "CONFIGURED"
            case .unconfigured: return "UNCONFIGURED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MigrationHubStrategyClientTypes {

    /// A combination of existing analysis statuses.
    public enum AnalysisStatusUnion: Swift.Sendable {
        /// The status of the analysis.
        case runtimeanalysisstatus(MigrationHubStrategyClientTypes.RuntimeAnalysisStatus)
        /// The status of the source code or database analysis.
        case srccodeordbanalysisstatus(MigrationHubStrategyClientTypes.SrcCodeOrDbAnalysisStatus)
        case sdkUnknown(Swift.String)
    }
}

extension MigrationHubStrategyClientTypes {

    public enum AnalysisType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case binaryAnalysis
        case databaseAnalysis
        case runtimeAnalysis
        case sourceCodeAnalysis
        case sdkUnknown(Swift.String)

        public static var allCases: [AnalysisType] {
            return [
                .binaryAnalysis,
                .databaseAnalysis,
                .runtimeAnalysis,
                .sourceCodeAnalysis
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .binaryAnalysis: return "BINARY_ANALYSIS"
            case .databaseAnalysis: return "DATABASE_ANALYSIS"
            case .runtimeAnalysis: return "RUNTIME_ANALYSIS"
            case .sourceCodeAnalysis: return "SOURCE_CODE_ANALYSIS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MigrationHubStrategyClientTypes {

    /// Summary information about an analyzable server.
    public struct AnalyzableServerSummary: Swift.Sendable {
        /// The host name of the analyzable server.
        public var hostname: Swift.String?
        /// The ip address of the analyzable server.
        public var ipAddress: Swift.String?
        /// The data source of the analyzable server.
        public var source: Swift.String?
        /// The virtual machine id of the analyzable server.
        public var vmId: Swift.String?

        public init(
            hostname: Swift.String? = nil,
            ipAddress: Swift.String? = nil,
            source: Swift.String? = nil,
            vmId: Swift.String? = nil
        )
        {
            self.hostname = hostname
            self.ipAddress = ipAddress
            self.source = source
            self.vmId = vmId
        }
    }
}

extension MigrationHubStrategyClientTypes {

    public enum BinaryAnalyzerName: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case bytecodeAnalyzer
        case dllAnalyzer
        case sdkUnknown(Swift.String)

        public static var allCases: [BinaryAnalyzerName] {
            return [
                .bytecodeAnalyzer,
                .dllAnalyzer
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .bytecodeAnalyzer: return "BYTECODE_ANALYZER"
            case .dllAnalyzer: return "DLL_ANALYZER"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MigrationHubStrategyClientTypes {

    public enum RunTimeAnalyzerName: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case a2cAnalyzer
        case databaseAnalyzer
        case empPaAnalyzer
        case rehostAnalyzer
        case sctAnalyzer
        case sdkUnknown(Swift.String)

        public static var allCases: [RunTimeAnalyzerName] {
            return [
                .a2cAnalyzer,
                .databaseAnalyzer,
                .empPaAnalyzer,
                .rehostAnalyzer,
                .sctAnalyzer
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .a2cAnalyzer: return "A2C_ANALYZER"
            case .databaseAnalyzer: return "DATABASE_ANALYZER"
            case .empPaAnalyzer: return "EMP_PA_ANALYZER"
            case .rehostAnalyzer: return "REHOST_ANALYZER"
            case .sctAnalyzer: return "SCT_ANALYZER"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MigrationHubStrategyClientTypes {

    public enum SourceCodeAnalyzerName: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case bytecodeAnalyzer
        case csharpAnalyzer
        case javaAnalyzer
        case portingAssistant
        case sdkUnknown(Swift.String)

        public static var allCases: [SourceCodeAnalyzerName] {
            return [
                .bytecodeAnalyzer,
                .csharpAnalyzer,
                .javaAnalyzer,
                .portingAssistant
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .bytecodeAnalyzer: return "BYTECODE_ANALYZER"
            case .csharpAnalyzer: return "CSHARP_ANALYZER"
            case .javaAnalyzer: return "JAVA_ANALYZER"
            case .portingAssistant: return "PORTING_ASSISTANT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MigrationHubStrategyClientTypes {

    /// The combination of the existing analyzers.
    public enum AnalyzerNameUnion: Swift.Sendable {
        /// The binary analyzer names.
        case binaryanalyzername(MigrationHubStrategyClientTypes.BinaryAnalyzerName)
        /// The assessment analyzer names.
        case runtimeanalyzername(MigrationHubStrategyClientTypes.RunTimeAnalyzerName)
        /// The source code analyzer names.
        case sourcecodeanalyzername(MigrationHubStrategyClientTypes.SourceCodeAnalyzerName)
        case sdkUnknown(Swift.String)
    }
}

extension MigrationHubStrategyClientTypes {

    /// Contains the S3 bucket name and the Amazon S3 key name.
    public struct S3Object: Swift.Sendable {
        /// The S3 bucket name.
        public var s3Bucket: Swift.String?
        /// The Amazon S3 key name.
        public var s3key: Swift.String?

        public init(
            s3Bucket: Swift.String? = nil,
            s3key: Swift.String? = nil
        )
        {
            self.s3Bucket = s3Bucket
            self.s3key = s3key
        }
    }
}

extension MigrationHubStrategyClientTypes {

    public enum AntipatternReportStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case failed
        case inProgress
        case success
        case sdkUnknown(Swift.String)

        public static var allCases: [AntipatternReportStatus] {
            return [
                .failed,
                .inProgress,
                .success
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .success: return "SUCCESS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MigrationHubStrategyClientTypes {

    /// The anti-pattern report result.
    public struct AntipatternReportResult: Swift.Sendable {
        /// The analyzer name.
        public var analyzerName: MigrationHubStrategyClientTypes.AnalyzerNameUnion?
        /// Contains the S3 bucket name and the Amazon S3 key name.
        public var antiPatternReportS3Object: MigrationHubStrategyClientTypes.S3Object?
        /// The status of the anti-pattern report generation.
        public var antipatternReportStatus: MigrationHubStrategyClientTypes.AntipatternReportStatus?
        /// The status message for the anti-pattern.
        public var antipatternReportStatusMessage: Swift.String?

        public init(
            analyzerName: MigrationHubStrategyClientTypes.AnalyzerNameUnion? = nil,
            antiPatternReportS3Object: MigrationHubStrategyClientTypes.S3Object? = nil,
            antipatternReportStatus: MigrationHubStrategyClientTypes.AntipatternReportStatus? = nil,
            antipatternReportStatusMessage: Swift.String? = nil
        )
        {
            self.analyzerName = analyzerName
            self.antiPatternReportS3Object = antiPatternReportS3Object
            self.antipatternReportStatus = antipatternReportStatus
            self.antipatternReportStatusMessage = antipatternReportStatusMessage
        }
    }
}

extension MigrationHubStrategyClientTypes {

    public enum Severity: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case high
        case low
        case medium
        case sdkUnknown(Swift.String)

        public static var allCases: [Severity] {
            return [
                .high,
                .low,
                .medium
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .high: return "HIGH"
            case .low: return "LOW"
            case .medium: return "MEDIUM"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MigrationHubStrategyClientTypes {

    /// Contains the summary of anti-patterns and their severity.
    public struct AntipatternSeveritySummary: Swift.Sendable {
        /// Contains the count of anti-patterns.
        public var count: Swift.Int?
        /// Contains the severity of anti-patterns.
        public var severity: MigrationHubStrategyClientTypes.Severity?

        public init(
            count: Swift.Int? = nil,
            severity: MigrationHubStrategyClientTypes.Severity? = nil
        )
        {
            self.count = count
            self.severity = severity
        }
    }
}

extension MigrationHubStrategyClientTypes {

    public enum ApplicationComponentCriteria: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case analysisStatus
        case appName
        case appType
        case destination
        case errorCategory
        case notDefined
        case serverId
        case strategy
        case sdkUnknown(Swift.String)

        public static var allCases: [ApplicationComponentCriteria] {
            return [
                .analysisStatus,
                .appName,
                .appType,
                .destination,
                .errorCategory,
                .notDefined,
                .serverId,
                .strategy
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .analysisStatus: return "ANALYSIS_STATUS"
            case .appName: return "APP_NAME"
            case .appType: return "APP_TYPE"
            case .destination: return "DESTINATION"
            case .errorCategory: return "ERROR_CATEGORY"
            case .notDefined: return "NOT_DEFINED"
            case .serverId: return "SERVER_ID"
            case .strategy: return "STRATEGY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MigrationHubStrategyClientTypes {

    public enum AppType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case iis
        case cassandra
        case db2
        case dotnetframework
        case dotnet
        case dotnetcore
        case java
        case jboss
        case mariadb
        case mongodb
        case mysql
        case oracle
        case other
        case postgresqlserver
        case spring
        case sqlserver
        case sybase
        case tomcat
        case unknown
        case visualbasic
        case weblogic
        case websphere
        case sdkUnknown(Swift.String)

        public static var allCases: [AppType] {
            return [
                .iis,
                .cassandra,
                .db2,
                .dotnetframework,
                .dotnet,
                .dotnetcore,
                .java,
                .jboss,
                .mariadb,
                .mongodb,
                .mysql,
                .oracle,
                .other,
                .postgresqlserver,
                .spring,
                .sqlserver,
                .sybase,
                .tomcat,
                .unknown,
                .visualbasic,
                .weblogic,
                .websphere
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .iis: return "IIS"
            case .cassandra: return "Cassandra"
            case .db2: return "DB2"
            case .dotnetframework: return "DotNetFramework"
            case .dotnet: return "Dotnet"
            case .dotnetcore: return "DotnetCore"
            case .java: return "Java"
            case .jboss: return "JBoss"
            case .mariadb: return "Maria DB"
            case .mongodb: return "Mongo DB"
            case .mysql: return "MySQL"
            case .oracle: return "Oracle"
            case .other: return "Other"
            case .postgresqlserver: return "PostgreSQLServer"
            case .spring: return "Spring"
            case .sqlserver: return "SQLServer"
            case .sybase: return "Sybase"
            case .tomcat: return "Tomcat"
            case .unknown: return "Unknown"
            case .visualbasic: return "Visual Basic"
            case .weblogic: return "Oracle WebLogic"
            case .websphere: return "IBM WebSphere"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MigrationHubStrategyClientTypes {

    public enum AppUnitErrorCategory: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case connectivityError
        case credentialError
        case otherError
        case permissionError
        case unsupportedError
        case sdkUnknown(Swift.String)

        public static var allCases: [AppUnitErrorCategory] {
            return [
                .connectivityError,
                .credentialError,
                .otherError,
                .permissionError,
                .unsupportedError
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .connectivityError: return "CONNECTIVITY_ERROR"
            case .credentialError: return "CREDENTIAL_ERROR"
            case .otherError: return "OTHER_ERROR"
            case .permissionError: return "PERMISSION_ERROR"
            case .unsupportedError: return "UNSUPPORTED_ERROR"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MigrationHubStrategyClientTypes {

    /// Error in the analysis of the application unit.
    public struct AppUnitError: Swift.Sendable {
        /// The category of the error.
        public var appUnitErrorCategory: MigrationHubStrategyClientTypes.AppUnitErrorCategory?

        public init(
            appUnitErrorCategory: MigrationHubStrategyClientTypes.AppUnitErrorCategory? = nil
        )
        {
            self.appUnitErrorCategory = appUnitErrorCategory
        }
    }
}

extension MigrationHubStrategyClientTypes {

    /// Configuration information used for assessing databases.
    public struct DatabaseConfigDetail: Swift.Sendable {
        /// AWS Secrets Manager key that holds the credentials that you use to connect to a database.
        public var secretName: Swift.String?

        public init(
            secretName: Swift.String? = nil
        )
        {
            self.secretName = secretName
        }
    }
}

extension MigrationHubStrategyClientTypes {

    public enum InclusionStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case excludeFromRecommendation
        case includeInRecommendation
        case sdkUnknown(Swift.String)

        public static var allCases: [InclusionStatus] {
            return [
                .excludeFromRecommendation,
                .includeInRecommendation
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .excludeFromRecommendation: return "excludeFromAssessment"
            case .includeInRecommendation: return "includeInAssessment"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MigrationHubStrategyClientTypes {

    public enum Strategy: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case refactor
        case rehost
        case relocate
        case replatform
        case repurchase
        case retain
        case retirement
        case sdkUnknown(Swift.String)

        public static var allCases: [Strategy] {
            return [
                .refactor,
                .rehost,
                .relocate,
                .replatform,
                .repurchase,
                .retain,
                .retirement
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .refactor: return "Refactor"
            case .rehost: return "Rehost"
            case .relocate: return "Relocate"
            case .replatform: return "Replatform"
            case .repurchase: return "Repurchase"
            case .retain: return "Retain"
            case .retirement: return "Retirement"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MigrationHubStrategyClientTypes {

    public enum TargetDestination: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case amazonDocumentdb
        case amazonDynamodb
        case amazonElasticCloudCompute
        case amazonElasticContainerService
        case amazonElasticKubernetesService
        case amazonRds
        case amazonRdsMysql
        case amazonRdsPostgresql
        case auroraMysql
        case auroraPostgresql
        case awsElasticBeanstalk
        case awsFargate
        case babelfishAuroraPostgresql
        case noneSpecified
        case sdkUnknown(Swift.String)

        public static var allCases: [TargetDestination] {
            return [
                .amazonDocumentdb,
                .amazonDynamodb,
                .amazonElasticCloudCompute,
                .amazonElasticContainerService,
                .amazonElasticKubernetesService,
                .amazonRds,
                .amazonRdsMysql,
                .amazonRdsPostgresql,
                .auroraMysql,
                .auroraPostgresql,
                .awsElasticBeanstalk,
                .awsFargate,
                .babelfishAuroraPostgresql,
                .noneSpecified
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .amazonDocumentdb: return "Amazon DocumentDB"
            case .amazonDynamodb: return "Amazon DynamoDB"
            case .amazonElasticCloudCompute: return "Amazon Elastic Cloud Compute (EC2)"
            case .amazonElasticContainerService: return "Amazon Elastic Container Service (ECS)"
            case .amazonElasticKubernetesService: return "Amazon Elastic Kubernetes Service (EKS)"
            case .amazonRds: return "Amazon Relational Database Service"
            case .amazonRdsMysql: return "Amazon Relational Database Service on MySQL"
            case .amazonRdsPostgresql: return "Amazon Relational Database Service on PostgreSQL"
            case .auroraMysql: return "Aurora MySQL"
            case .auroraPostgresql: return "Aurora PostgreSQL"
            case .awsElasticBeanstalk: return "AWS Elastic BeanStalk"
            case .awsFargate: return "AWS Fargate"
            case .babelfishAuroraPostgresql: return "Babelfish for Aurora PostgreSQL"
            case .noneSpecified: return "None specified"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MigrationHubStrategyClientTypes {

    public enum TransformationToolName: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case app2container
        case dms
        case emp
        case inPlaceOsUpgrade
        case mgn
        case nativeSql
        case portingAssistant
        case sct
        case strategyRecommendationSupport
        case wwama
        case sdkUnknown(Swift.String)

        public static var allCases: [TransformationToolName] {
            return [
                .app2container,
                .dms,
                .emp,
                .inPlaceOsUpgrade,
                .mgn,
                .nativeSql,
                .portingAssistant,
                .sct,
                .strategyRecommendationSupport,
                .wwama
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .app2container: return "App2Container"
            case .dms: return "Database Migration Service"
            case .emp: return "End of Support Migration"
            case .inPlaceOsUpgrade: return "In Place Operating System Upgrade"
            case .mgn: return "Application Migration Service"
            case .nativeSql: return "Native SQL Server Backup/Restore"
            case .portingAssistant: return "Porting Assistant For .NET"
            case .sct: return "Schema Conversion Tool"
            case .strategyRecommendationSupport: return "Strategy Recommendation Support"
            case .wwama: return "Windows Web Application Migration Assistant"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MigrationHubStrategyClientTypes {

    /// Information of the transformation tool that can be used to migrate and modernize the application.
    public struct TransformationTool: Swift.Sendable {
        /// Description of the tool.
        public var description: Swift.String?
        /// Name of the tool.
        public var name: MigrationHubStrategyClientTypes.TransformationToolName?
        /// URL for installing the tool.
        public var tranformationToolInstallationLink: Swift.String?

        public init(
            description: Swift.String? = nil,
            name: MigrationHubStrategyClientTypes.TransformationToolName? = nil,
            tranformationToolInstallationLink: Swift.String? = nil
        )
        {
            self.description = description
            self.name = name
            self.tranformationToolInstallationLink = tranformationToolInstallationLink
        }
    }
}

extension MigrationHubStrategyClientTypes {

    /// Contains a recommendation set.
    public struct RecommendationSet: Swift.Sendable {
        /// The recommended strategy.
        public var strategy: MigrationHubStrategyClientTypes.Strategy?
        /// The recommended target destination.
        public var targetDestination: MigrationHubStrategyClientTypes.TargetDestination?
        /// The target destination for the recommendation set.
        public var transformationTool: MigrationHubStrategyClientTypes.TransformationTool?

        public init(
            strategy: MigrationHubStrategyClientTypes.Strategy? = nil,
            targetDestination: MigrationHubStrategyClientTypes.TargetDestination? = nil,
            transformationTool: MigrationHubStrategyClientTypes.TransformationTool? = nil
        )
        {
            self.strategy = strategy
            self.targetDestination = targetDestination
            self.transformationTool = transformationTool
        }
    }
}

extension MigrationHubStrategyClientTypes {

    public enum ResourceSubType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case database
        case databaseProcess
        case process
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceSubType] {
            return [
                .database,
                .databaseProcess,
                .process
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .database: return "Database"
            case .databaseProcess: return "DatabaseProcess"
            case .process: return "Process"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MigrationHubStrategyClientTypes {

    /// The error in server analysis.
    public struct Result: Swift.Sendable {
        /// The error in server analysis.
        public var analysisStatus: MigrationHubStrategyClientTypes.AnalysisStatusUnion?
        /// The error in server analysis.
        public var analysisType: MigrationHubStrategyClientTypes.AnalysisType?
        /// The error in server analysis.
        public var antipatternReportResultList: [MigrationHubStrategyClientTypes.AntipatternReportResult]?
        /// The error in server analysis.
        public var statusMessage: Swift.String?

        public init(
            analysisStatus: MigrationHubStrategyClientTypes.AnalysisStatusUnion? = nil,
            analysisType: MigrationHubStrategyClientTypes.AnalysisType? = nil,
            antipatternReportResultList: [MigrationHubStrategyClientTypes.AntipatternReportResult]? = nil,
            statusMessage: Swift.String? = nil
        )
        {
            self.analysisStatus = analysisStatus
            self.analysisType = analysisType
            self.antipatternReportResultList = antipatternReportResultList
            self.statusMessage = statusMessage
        }
    }
}

extension MigrationHubStrategyClientTypes {

    /// Object containing source code information that is linked to an application component.
    public struct SourceCodeRepository: Swift.Sendable {
        /// The branch of the source code.
        public var branch: Swift.String?
        /// The name of the project.
        public var projectName: Swift.String?
        /// The repository name for the source code.
        public var repository: Swift.String?
        /// The type of repository to use for the source code.
        public var versionControlType: Swift.String?

        public init(
            branch: Swift.String? = nil,
            projectName: Swift.String? = nil,
            repository: Swift.String? = nil,
            versionControlType: Swift.String? = nil
        )
        {
            self.branch = branch
            self.projectName = projectName
            self.repository = repository
            self.versionControlType = versionControlType
        }
    }
}

extension MigrationHubStrategyClientTypes {

    /// Contains detailed information about an application component.
    public struct ApplicationComponentDetail: Swift.Sendable {
        /// The status of analysis, if the application component has source code or an associated database.
        public var analysisStatus: MigrationHubStrategyClientTypes.SrcCodeOrDbAnalysisStatus?
        /// The S3 bucket name and the Amazon S3 key name for the anti-pattern report.
        public var antipatternReportS3Object: MigrationHubStrategyClientTypes.S3Object?
        /// The status of the anti-pattern report generation.
        public var antipatternReportStatus: MigrationHubStrategyClientTypes.AntipatternReportStatus?
        /// The status message for the anti-pattern.
        public var antipatternReportStatusMessage: Swift.String?
        /// The type of application component.
        public var appType: MigrationHubStrategyClientTypes.AppType?
        /// The error in the analysis of the source code or database.
        public var appUnitError: MigrationHubStrategyClientTypes.AppUnitError?
        /// The ID of the server that the application component is running on.
        public var associatedServerId: Swift.String?
        /// Configuration details for the database associated with the application component.
        public var databaseConfigDetail: MigrationHubStrategyClientTypes.DatabaseConfigDetail?
        /// The ID of the application component.
        public var id: Swift.String?
        /// Indicates whether the application component has been included for server recommendation or not.
        public var inclusionStatus: MigrationHubStrategyClientTypes.InclusionStatus?
        /// The timestamp of when the application component was assessed.
        public var lastAnalyzedTimestamp: Foundation.Date?
        /// A list of anti-pattern severity summaries.
        public var listAntipatternSeveritySummary: [MigrationHubStrategyClientTypes.AntipatternSeveritySummary]?
        /// Set to true if the application component is running on multiple servers.
        public var moreServerAssociationExists: Swift.Bool?
        /// The name of application component.
        public var name: Swift.String?
        /// OS driver.
        public var osDriver: Swift.String?
        /// OS version.
        public var osVersion: Swift.String?
        /// The top recommendation set for the application component.
        public var recommendationSet: MigrationHubStrategyClientTypes.RecommendationSet?
        /// The application component subtype.
        public var resourceSubType: MigrationHubStrategyClientTypes.ResourceSubType?
        /// A list of the analysis results.
        public var resultList: [MigrationHubStrategyClientTypes.Result]?
        /// The status of the application unit.
        public var runtimeStatus: MigrationHubStrategyClientTypes.RuntimeAnalysisStatus?
        /// The status message for the application unit.
        public var runtimeStatusMessage: Swift.String?
        /// Details about the source code repository associated with the application component.
        public var sourceCodeRepositories: [MigrationHubStrategyClientTypes.SourceCodeRepository]?
        /// A detailed description of the analysis status and any failure message.
        public var statusMessage: Swift.String?

        public init(
            analysisStatus: MigrationHubStrategyClientTypes.SrcCodeOrDbAnalysisStatus? = nil,
            antipatternReportS3Object: MigrationHubStrategyClientTypes.S3Object? = nil,
            antipatternReportStatus: MigrationHubStrategyClientTypes.AntipatternReportStatus? = nil,
            antipatternReportStatusMessage: Swift.String? = nil,
            appType: MigrationHubStrategyClientTypes.AppType? = nil,
            appUnitError: MigrationHubStrategyClientTypes.AppUnitError? = nil,
            associatedServerId: Swift.String? = nil,
            databaseConfigDetail: MigrationHubStrategyClientTypes.DatabaseConfigDetail? = nil,
            id: Swift.String? = nil,
            inclusionStatus: MigrationHubStrategyClientTypes.InclusionStatus? = nil,
            lastAnalyzedTimestamp: Foundation.Date? = nil,
            listAntipatternSeveritySummary: [MigrationHubStrategyClientTypes.AntipatternSeveritySummary]? = nil,
            moreServerAssociationExists: Swift.Bool? = nil,
            name: Swift.String? = nil,
            osDriver: Swift.String? = nil,
            osVersion: Swift.String? = nil,
            recommendationSet: MigrationHubStrategyClientTypes.RecommendationSet? = nil,
            resourceSubType: MigrationHubStrategyClientTypes.ResourceSubType? = nil,
            resultList: [MigrationHubStrategyClientTypes.Result]? = nil,
            runtimeStatus: MigrationHubStrategyClientTypes.RuntimeAnalysisStatus? = nil,
            runtimeStatusMessage: Swift.String? = nil,
            sourceCodeRepositories: [MigrationHubStrategyClientTypes.SourceCodeRepository]? = nil,
            statusMessage: Swift.String? = nil
        )
        {
            self.analysisStatus = analysisStatus
            self.antipatternReportS3Object = antipatternReportS3Object
            self.antipatternReportStatus = antipatternReportStatus
            self.antipatternReportStatusMessage = antipatternReportStatusMessage
            self.appType = appType
            self.appUnitError = appUnitError
            self.associatedServerId = associatedServerId
            self.databaseConfigDetail = databaseConfigDetail
            self.id = id
            self.inclusionStatus = inclusionStatus
            self.lastAnalyzedTimestamp = lastAnalyzedTimestamp
            self.listAntipatternSeveritySummary = listAntipatternSeveritySummary
            self.moreServerAssociationExists = moreServerAssociationExists
            self.name = name
            self.osDriver = osDriver
            self.osVersion = osVersion
            self.recommendationSet = recommendationSet
            self.resourceSubType = resourceSubType
            self.resultList = resultList
            self.runtimeStatus = runtimeStatus
            self.runtimeStatusMessage = runtimeStatusMessage
            self.sourceCodeRepositories = sourceCodeRepositories
            self.statusMessage = statusMessage
        }
    }
}

extension MigrationHubStrategyClientTypes {

    /// Summary of the analysis status of the application component.
    public struct ApplicationComponentStatusSummary: Swift.Sendable {
        /// The number of application components successfully analyzed, partially successful or failed analysis.
        public var count: Swift.Int?
        /// The status of database analysis.
        public var srcCodeOrDbAnalysisStatus: MigrationHubStrategyClientTypes.SrcCodeOrDbAnalysisStatus?

        public init(
            count: Swift.Int? = nil,
            srcCodeOrDbAnalysisStatus: MigrationHubStrategyClientTypes.SrcCodeOrDbAnalysisStatus? = nil
        )
        {
            self.count = count
            self.srcCodeOrDbAnalysisStatus = srcCodeOrDbAnalysisStatus
        }
    }
}

extension MigrationHubStrategyClientTypes {

    public enum StrategyRecommendation: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case notRecommended
        case potential
        case recommended
        case viableOption
        case sdkUnknown(Swift.String)

        public static var allCases: [StrategyRecommendation] {
            return [
                .notRecommended,
                .potential,
                .recommended,
                .viableOption
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .notRecommended: return "notRecommended"
            case .potential: return "potential"
            case .recommended: return "recommended"
            case .viableOption: return "viableOption"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MigrationHubStrategyClientTypes {

    /// Contains information about a strategy recommendation for an application component.
    public struct ApplicationComponentStrategy: Swift.Sendable {
        /// Set to true if the recommendation is set as preferred.
        public var isPreferred: Swift.Bool?
        /// Strategy recommendation for the application component.
        public var recommendation: MigrationHubStrategyClientTypes.RecommendationSet?
        /// The recommendation status of a strategy for an application component.
        public var status: MigrationHubStrategyClientTypes.StrategyRecommendation?

        public init(
            isPreferred: Swift.Bool? = nil,
            recommendation: MigrationHubStrategyClientTypes.RecommendationSet? = nil,
            status: MigrationHubStrategyClientTypes.StrategyRecommendation? = nil
        )
        {
            self.isPreferred = isPreferred
            self.recommendation = recommendation
            self.status = status
        }
    }
}

extension MigrationHubStrategyClientTypes {

    /// Contains the summary of application components.
    public struct ApplicationComponentSummary: Swift.Sendable {
        /// Contains the name of application types.
        public var appType: MigrationHubStrategyClientTypes.AppType?
        /// Contains the count of application type.
        public var count: Swift.Int?

        public init(
            appType: MigrationHubStrategyClientTypes.AppType? = nil,
            count: Swift.Int? = nil
        )
        {
            self.appType = appType
            self.count = count
        }
    }
}

extension MigrationHubStrategyClientTypes {

    public enum ApplicationMode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case all
        case known
        case unknown
        case sdkUnknown(Swift.String)

        public static var allCases: [ApplicationMode] {
            return [
                .all,
                .known,
                .unknown
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .all: return "ALL"
            case .known: return "KNOWN"
            case .unknown: return "UNKNOWN"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MigrationHubStrategyClientTypes {

    public enum AwsManagedTargetDestination: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case awsElasticBeanstalk
        case awsFargate
        case noneSpecified
        case sdkUnknown(Swift.String)

        public static var allCases: [AwsManagedTargetDestination] {
            return [
                .awsElasticBeanstalk,
                .awsFargate,
                .noneSpecified
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .awsElasticBeanstalk: return "AWS Elastic BeanStalk"
            case .awsFargate: return "AWS Fargate"
            case .noneSpecified: return "None specified"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MigrationHubStrategyClientTypes {

    /// Object containing the choice of application destination that you specify.
    public struct AwsManagedResources: Swift.Sendable {
        /// The choice of application destination that you specify.
        /// This member is required.
        public var targetDestination: [MigrationHubStrategyClientTypes.AwsManagedTargetDestination]?

        public init(
            targetDestination: [MigrationHubStrategyClientTypes.AwsManagedTargetDestination]? = nil
        )
        {
            self.targetDestination = targetDestination
        }
    }
}

extension MigrationHubStrategyClientTypes {

    public enum NoPreferenceTargetDestination: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case amazonElasticCloudCompute
        case amazonElasticContainerService
        case amazonElasticKubernetesService
        case awsElasticBeanstalk
        case awsFargate
        case noneSpecified
        case sdkUnknown(Swift.String)

        public static var allCases: [NoPreferenceTargetDestination] {
            return [
                .amazonElasticCloudCompute,
                .amazonElasticContainerService,
                .amazonElasticKubernetesService,
                .awsElasticBeanstalk,
                .awsFargate,
                .noneSpecified
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .amazonElasticCloudCompute: return "Amazon Elastic Cloud Compute (EC2)"
            case .amazonElasticContainerService: return "Amazon Elastic Container Service (ECS)"
            case .amazonElasticKubernetesService: return "Amazon Elastic Kubernetes Service (EKS)"
            case .awsElasticBeanstalk: return "AWS Elastic BeanStalk"
            case .awsFargate: return "AWS Fargate"
            case .noneSpecified: return "None specified"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MigrationHubStrategyClientTypes {

    /// Object containing the choice of application destination that you specify.
    public struct NoManagementPreference: Swift.Sendable {
        /// The choice of application destination that you specify.
        /// This member is required.
        public var targetDestination: [MigrationHubStrategyClientTypes.NoPreferenceTargetDestination]?

        public init(
            targetDestination: [MigrationHubStrategyClientTypes.NoPreferenceTargetDestination]? = nil
        )
        {
            self.targetDestination = targetDestination
        }
    }
}

extension MigrationHubStrategyClientTypes {

    public enum SelfManageTargetDestination: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case amazonElasticCloudCompute
        case amazonElasticContainerService
        case amazonElasticKubernetesService
        case noneSpecified
        case sdkUnknown(Swift.String)

        public static var allCases: [SelfManageTargetDestination] {
            return [
                .amazonElasticCloudCompute,
                .amazonElasticContainerService,
                .amazonElasticKubernetesService,
                .noneSpecified
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .amazonElasticCloudCompute: return "Amazon Elastic Cloud Compute (EC2)"
            case .amazonElasticContainerService: return "Amazon Elastic Container Service (ECS)"
            case .amazonElasticKubernetesService: return "Amazon Elastic Kubernetes Service (EKS)"
            case .noneSpecified: return "None specified"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MigrationHubStrategyClientTypes {

    /// Self-managed resources.
    public struct SelfManageResources: Swift.Sendable {
        /// Self-managed resources target destination.
        /// This member is required.
        public var targetDestination: [MigrationHubStrategyClientTypes.SelfManageTargetDestination]?

        public init(
            targetDestination: [MigrationHubStrategyClientTypes.SelfManageTargetDestination]? = nil
        )
        {
            self.targetDestination = targetDestination
        }
    }
}

extension MigrationHubStrategyClientTypes {

    /// Preferences for migrating an application to AWS.
    public enum ManagementPreference: Swift.Sendable {
        /// Indicates interest in solutions that are managed by AWS.
        case awsmanagedresources(MigrationHubStrategyClientTypes.AwsManagedResources)
        /// Indicates interest in managing your own resources on AWS.
        case selfmanageresources(MigrationHubStrategyClientTypes.SelfManageResources)
        /// No specific preference.
        case nopreference(MigrationHubStrategyClientTypes.NoManagementPreference)
        case sdkUnknown(Swift.String)
    }
}

extension MigrationHubStrategyClientTypes {

    /// Application preferences that you specify.
    public struct ApplicationPreferences: Swift.Sendable {
        /// Application preferences that you specify to prefer managed environment.
        public var managementPreference: MigrationHubStrategyClientTypes.ManagementPreference?

        public init(
            managementPreference: MigrationHubStrategyClientTypes.ManagementPreference? = nil
        )
        {
            self.managementPreference = managementPreference
        }
    }
}

extension MigrationHubStrategyClientTypes {

    public enum AssessmentDataSourceType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case ads
        case manualImport
        case srCollector
        case sdkUnknown(Swift.String)

        public static var allCases: [AssessmentDataSourceType] {
            return [
                .ads,
                .manualImport,
                .srCollector
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .ads: return "ApplicationDiscoveryService"
            case .manualImport: return "ManualImport"
            case .srCollector: return "StrategyRecommendationsApplicationDataCollector"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MigrationHubStrategyClientTypes {

    public enum AssessmentStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case complete
        case failed
        case inProgress
        case stopped
        case sdkUnknown(Swift.String)

        public static var allCases: [AssessmentStatus] {
            return [
                .complete,
                .failed,
                .inProgress,
                .stopped
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .complete: return "COMPLETE"
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .stopped: return "STOPPED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MigrationHubStrategyClientTypes {

    /// Object containing the summary of the strategy recommendations.
    public struct StrategySummary: Swift.Sendable {
        /// The count of recommendations per strategy.
        public var count: Swift.Int?
        /// The name of recommended strategy.
        public var strategy: MigrationHubStrategyClientTypes.Strategy?

        public init(
            count: Swift.Int? = nil,
            strategy: MigrationHubStrategyClientTypes.Strategy? = nil
        )
        {
            self.count = count
            self.strategy = strategy
        }
    }
}

extension MigrationHubStrategyClientTypes {

    public enum RunTimeAssessmentStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case dcFailed
        case dcPartialSuccess
        case dcReqSent
        case dcStarted
        case dcStopped
        case dcSuccess
        case dcToBeScheduled
        case sdkUnknown(Swift.String)

        public static var allCases: [RunTimeAssessmentStatus] {
            return [
                .dcFailed,
                .dcPartialSuccess,
                .dcReqSent,
                .dcStarted,
                .dcStopped,
                .dcSuccess,
                .dcToBeScheduled
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .dcFailed: return "dataCollectionTaskFailed"
            case .dcPartialSuccess: return "dataCollectionTaskPartialSuccess"
            case .dcReqSent: return "dataCollectionTaskScheduled"
            case .dcStarted: return "dataCollectionTaskStarted"
            case .dcStopped: return "dataCollectionTaskStopped"
            case .dcSuccess: return "dataCollectionTaskSuccess"
            case .dcToBeScheduled: return "dataCollectionTaskToBeScheduled"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MigrationHubStrategyClientTypes {

    /// The status summary of the server analysis.
    public struct ServerStatusSummary: Swift.Sendable {
        /// The number of servers successfully analyzed, partially successful or failed analysis.
        public var count: Swift.Int?
        /// The status of the run time.
        public var runTimeAssessmentStatus: MigrationHubStrategyClientTypes.RunTimeAssessmentStatus?

        public init(
            count: Swift.Int? = nil,
            runTimeAssessmentStatus: MigrationHubStrategyClientTypes.RunTimeAssessmentStatus? = nil
        )
        {
            self.count = count
            self.runTimeAssessmentStatus = runTimeAssessmentStatus
        }
    }
}

extension MigrationHubStrategyClientTypes {

    public enum ServerOsType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case amazonlinux
        case endofsupportwindowsserver
        case other
        case redhat
        case windowsserver
        case sdkUnknown(Swift.String)

        public static var allCases: [ServerOsType] {
            return [
                .amazonlinux,
                .endofsupportwindowsserver,
                .other,
                .redhat,
                .windowsserver
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .amazonlinux: return "AmazonLinux"
            case .endofsupportwindowsserver: return "EndOfSupportWindowsServer"
            case .other: return "Other"
            case .redhat: return "Redhat"
            case .windowsserver: return "WindowsServer"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MigrationHubStrategyClientTypes {

    /// Object containing details about the servers imported by Application Discovery Service
    public struct ServerSummary: Swift.Sendable {
        /// Number of servers.
        public var count: Swift.Int?
        /// Type of operating system for the servers.
        public var serverOsType: MigrationHubStrategyClientTypes.ServerOsType?

        public init(
            count: Swift.Int? = nil,
            serverOsType: MigrationHubStrategyClientTypes.ServerOsType? = nil
        )
        {
            self.count = count
            self.serverOsType = serverOsType
        }
    }
}

extension MigrationHubStrategyClientTypes {

    /// Contains the summary of the assessment results.
    public struct AssessmentSummary: Swift.Sendable {
        /// The Amazon S3 object containing the anti-pattern report.
        public var antipatternReportS3Object: MigrationHubStrategyClientTypes.S3Object?
        /// The status of the anti-pattern report.
        public var antipatternReportStatus: MigrationHubStrategyClientTypes.AntipatternReportStatus?
        /// The status message of the anti-pattern report.
        public var antipatternReportStatusMessage: Swift.String?
        /// The time the assessment was performed.
        public var lastAnalyzedTimestamp: Foundation.Date?
        /// List of AntipatternSeveritySummary.
        public var listAntipatternSeveritySummary: [MigrationHubStrategyClientTypes.AntipatternSeveritySummary]?
        /// List of status summaries of the analyzed application components.
        public var listApplicationComponentStatusSummary: [MigrationHubStrategyClientTypes.ApplicationComponentStatusSummary]?
        /// List of ApplicationComponentStrategySummary.
        public var listApplicationComponentStrategySummary: [MigrationHubStrategyClientTypes.StrategySummary]?
        /// List of ApplicationComponentSummary.
        public var listApplicationComponentSummary: [MigrationHubStrategyClientTypes.ApplicationComponentSummary]?
        /// List of status summaries of the analyzed servers.
        public var listServerStatusSummary: [MigrationHubStrategyClientTypes.ServerStatusSummary]?
        /// List of ServerStrategySummary.
        public var listServerStrategySummary: [MigrationHubStrategyClientTypes.StrategySummary]?
        /// List of ServerSummary.
        public var listServerSummary: [MigrationHubStrategyClientTypes.ServerSummary]?

        public init(
            antipatternReportS3Object: MigrationHubStrategyClientTypes.S3Object? = nil,
            antipatternReportStatus: MigrationHubStrategyClientTypes.AntipatternReportStatus? = nil,
            antipatternReportStatusMessage: Swift.String? = nil,
            lastAnalyzedTimestamp: Foundation.Date? = nil,
            listAntipatternSeveritySummary: [MigrationHubStrategyClientTypes.AntipatternSeveritySummary]? = nil,
            listApplicationComponentStatusSummary: [MigrationHubStrategyClientTypes.ApplicationComponentStatusSummary]? = nil,
            listApplicationComponentStrategySummary: [MigrationHubStrategyClientTypes.StrategySummary]? = nil,
            listApplicationComponentSummary: [MigrationHubStrategyClientTypes.ApplicationComponentSummary]? = nil,
            listServerStatusSummary: [MigrationHubStrategyClientTypes.ServerStatusSummary]? = nil,
            listServerStrategySummary: [MigrationHubStrategyClientTypes.StrategySummary]? = nil,
            listServerSummary: [MigrationHubStrategyClientTypes.ServerSummary]? = nil
        )
        {
            self.antipatternReportS3Object = antipatternReportS3Object
            self.antipatternReportStatus = antipatternReportStatus
            self.antipatternReportStatusMessage = antipatternReportStatusMessage
            self.lastAnalyzedTimestamp = lastAnalyzedTimestamp
            self.listAntipatternSeveritySummary = listAntipatternSeveritySummary
            self.listApplicationComponentStatusSummary = listApplicationComponentStatusSummary
            self.listApplicationComponentStrategySummary = listApplicationComponentStrategySummary
            self.listApplicationComponentSummary = listApplicationComponentSummary
            self.listServerStatusSummary = listServerStatusSummary
            self.listServerStrategySummary = listServerStrategySummary
            self.listServerSummary = listServerSummary
        }
    }
}

extension MigrationHubStrategyClientTypes {

    public enum Condition: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case contains
        case equals
        case notContains
        case notEquals
        case sdkUnknown(Swift.String)

        public static var allCases: [Condition] {
            return [
                .contains,
                .equals,
                .notContains,
                .notEquals
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .contains: return "CONTAINS"
            case .equals: return "EQUALS"
            case .notContains: return "NOT_CONTAINS"
            case .notEquals: return "NOT_EQUALS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MigrationHubStrategyClientTypes {

    /// Defines the criteria of assessment.
    public struct AssessmentTarget: Swift.Sendable {
        /// Condition of an assessment.
        /// This member is required.
        public var condition: MigrationHubStrategyClientTypes.Condition?
        /// Name of an assessment.
        /// This member is required.
        public var name: Swift.String?
        /// Values of an assessment.
        /// This member is required.
        public var values: [Swift.String]?

        public init(
            condition: MigrationHubStrategyClientTypes.Condition? = nil,
            name: Swift.String? = nil,
            values: [Swift.String]? = nil
        )
        {
            self.condition = condition
            self.name = name
            self.values = values
        }
    }
}

extension MigrationHubStrategyClientTypes {

    /// Object containing details about applications as defined in Application Discovery Service.
    public struct AssociatedApplication: Swift.Sendable {
        /// ID of the application as defined in Application Discovery Service.
        public var id: Swift.String?
        /// Name of the application as defined in Application Discovery Service.
        public var name: Swift.String?

        public init(
            id: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.id = id
            self.name = name
        }
    }
}

extension MigrationHubStrategyClientTypes {

    public enum AuthType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case cert
        case ntlm
        case ssh
        case sdkUnknown(Swift.String)

        public static var allCases: [AuthType] {
            return [
                .cert,
                .ntlm,
                .ssh
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .cert: return "CERT"
            case .ntlm: return "NTLM"
            case .ssh: return "SSH"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// The server experienced an internal error. Try again.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The specified ID in the request is not found.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The request was denied due to request throttling.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct GetApplicationComponentDetailsInput: Swift.Sendable {
    /// The ID of the application component. The ID is unique within an AWS account.
    /// This member is required.
    public var applicationComponentId: Swift.String?

    public init(
        applicationComponentId: Swift.String? = nil
    )
    {
        self.applicationComponentId = applicationComponentId
    }
}

public struct GetApplicationComponentDetailsOutput: Swift.Sendable {
    /// Detailed information about an application component.
    public var applicationComponentDetail: MigrationHubStrategyClientTypes.ApplicationComponentDetail?
    /// The associated application group as defined in AWS Application Discovery Service.
    public var associatedApplications: [MigrationHubStrategyClientTypes.AssociatedApplication]?
    /// A list of the IDs of the servers on which the application component is running.
    public var associatedServerIds: [Swift.String]?
    /// Set to true if the application component belongs to more than one application group.
    public var moreApplicationResource: Swift.Bool?

    public init(
        applicationComponentDetail: MigrationHubStrategyClientTypes.ApplicationComponentDetail? = nil,
        associatedApplications: [MigrationHubStrategyClientTypes.AssociatedApplication]? = nil,
        associatedServerIds: [Swift.String]? = nil,
        moreApplicationResource: Swift.Bool? = nil
    )
    {
        self.applicationComponentDetail = applicationComponentDetail
        self.associatedApplications = associatedApplications
        self.associatedServerIds = associatedServerIds
        self.moreApplicationResource = moreApplicationResource
    }
}

public struct GetApplicationComponentStrategiesInput: Swift.Sendable {
    /// The ID of the application component. The ID is unique within an AWS account.
    /// This member is required.
    public var applicationComponentId: Swift.String?

    public init(
        applicationComponentId: Swift.String? = nil
    )
    {
        self.applicationComponentId = applicationComponentId
    }
}

public struct GetApplicationComponentStrategiesOutput: Swift.Sendable {
    /// A list of application component strategy recommendations.
    public var applicationComponentStrategies: [MigrationHubStrategyClientTypes.ApplicationComponentStrategy]?

    public init(
        applicationComponentStrategies: [MigrationHubStrategyClientTypes.ApplicationComponentStrategy]? = nil
    )
    {
        self.applicationComponentStrategies = applicationComponentStrategies
    }
}

public struct GetAssessmentInput: Swift.Sendable {
    /// The assessmentid returned by [StartAssessment].
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

extension MigrationHubStrategyClientTypes {

    /// Detailed information about an assessment.
    public struct DataCollectionDetails: Swift.Sendable {
        /// The time the assessment completes.
        public var completionTime: Foundation.Date?
        /// The number of failed servers in the assessment.
        public var failed: Swift.Int?
        /// The number of servers with the assessment status IN_PROGESS.
        public var inProgress: Swift.Int?
        /// The total number of servers in the assessment.
        public var servers: Swift.Int?
        /// The start time of assessment.
        public var startTime: Foundation.Date?
        /// The status of the assessment.
        public var status: MigrationHubStrategyClientTypes.AssessmentStatus?
        /// The status message of the assessment.
        public var statusMessage: Swift.String?
        /// The number of successful servers in the assessment.
        public var success: Swift.Int?

        public init(
            completionTime: Foundation.Date? = nil,
            failed: Swift.Int? = nil,
            inProgress: Swift.Int? = nil,
            servers: Swift.Int? = nil,
            startTime: Foundation.Date? = nil,
            status: MigrationHubStrategyClientTypes.AssessmentStatus? = nil,
            statusMessage: Swift.String? = nil,
            success: Swift.Int? = nil
        )
        {
            self.completionTime = completionTime
            self.failed = failed
            self.inProgress = inProgress
            self.servers = servers
            self.startTime = startTime
            self.status = status
            self.statusMessage = statusMessage
            self.success = success
        }
    }
}

public struct GetAssessmentOutput: Swift.Sendable {
    /// List of criteria for assessment.
    public var assessmentTargets: [MigrationHubStrategyClientTypes.AssessmentTarget]?
    /// Detailed information about the assessment.
    public var dataCollectionDetails: MigrationHubStrategyClientTypes.DataCollectionDetails?
    /// The ID for the specific assessment task.
    public var id: Swift.String?

    public init(
        assessmentTargets: [MigrationHubStrategyClientTypes.AssessmentTarget]? = nil,
        dataCollectionDetails: MigrationHubStrategyClientTypes.DataCollectionDetails? = nil,
        id: Swift.String? = nil
    )
    {
        self.assessmentTargets = assessmentTargets
        self.dataCollectionDetails = dataCollectionDetails
        self.id = id
    }
}

/// The request body isn't valid.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct GetImportFileTaskInput: Swift.Sendable {
    /// The ID of the import file task. This ID is returned in the response of [StartImportFileTask].
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

extension MigrationHubStrategyClientTypes {

    public enum ImportFileTaskStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case deleteFailed
        case deleteInProgress
        case deletePartialSuccess
        case deleteSuccess
        case importFailed
        case importInProgress
        case importPartialSuccess
        case importSuccess
        case sdkUnknown(Swift.String)

        public static var allCases: [ImportFileTaskStatus] {
            return [
                .deleteFailed,
                .deleteInProgress,
                .deletePartialSuccess,
                .deleteSuccess,
                .importFailed,
                .importInProgress,
                .importPartialSuccess,
                .importSuccess
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .deleteFailed: return "DeleteFailed"
            case .deleteInProgress: return "DeleteInProgress"
            case .deletePartialSuccess: return "DeletePartialSuccess"
            case .deleteSuccess: return "DeleteSuccess"
            case .importFailed: return "ImportFailed"
            case .importInProgress: return "ImportInProgress"
            case .importPartialSuccess: return "ImportPartialSuccess"
            case .importSuccess: return "ImportSuccess"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetImportFileTaskOutput: Swift.Sendable {
    /// The time that the import task completed.
    public var completionTime: Foundation.Date?
    /// The import file task id returned in the response of [StartImportFileTask].
    public var id: Swift.String?
    /// The name of the import task given in [StartImportFileTask].
    public var importName: Swift.String?
    /// The S3 bucket where import file is located.
    public var inputS3Bucket: Swift.String?
    /// The Amazon S3 key name of the import file.
    public var inputS3Key: Swift.String?
    /// The number of records that failed to be imported.
    public var numberOfRecordsFailed: Swift.Int?
    /// The number of records successfully imported.
    public var numberOfRecordsSuccess: Swift.Int?
    /// Start time of the import task.
    public var startTime: Foundation.Date?
    /// Status of import file task.
    public var status: MigrationHubStrategyClientTypes.ImportFileTaskStatus?
    /// The S3 bucket name for status report of import task.
    public var statusReportS3Bucket: Swift.String?
    /// The Amazon S3 key name for status report of import task. The report contains details about whether each record imported successfully or why it did not.
    public var statusReportS3Key: Swift.String?

    public init(
        completionTime: Foundation.Date? = nil,
        id: Swift.String? = nil,
        importName: Swift.String? = nil,
        inputS3Bucket: Swift.String? = nil,
        inputS3Key: Swift.String? = nil,
        numberOfRecordsFailed: Swift.Int? = nil,
        numberOfRecordsSuccess: Swift.Int? = nil,
        startTime: Foundation.Date? = nil,
        status: MigrationHubStrategyClientTypes.ImportFileTaskStatus? = nil,
        statusReportS3Bucket: Swift.String? = nil,
        statusReportS3Key: Swift.String? = nil
    )
    {
        self.completionTime = completionTime
        self.id = id
        self.importName = importName
        self.inputS3Bucket = inputS3Bucket
        self.inputS3Key = inputS3Key
        self.numberOfRecordsFailed = numberOfRecordsFailed
        self.numberOfRecordsSuccess = numberOfRecordsSuccess
        self.startTime = startTime
        self.status = status
        self.statusReportS3Bucket = statusReportS3Bucket
        self.statusReportS3Key = statusReportS3Key
    }
}

/// Dependency encountered an error.
public struct DependencyException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "DependencyException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct GetLatestAssessmentIdInput: Swift.Sendable {

    public init() { }
}

public struct GetLatestAssessmentIdOutput: Swift.Sendable {
    /// The latest ID for the specific assessment task.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

public struct GetPortfolioPreferencesInput: Swift.Sendable {

    public init() { }
}

extension MigrationHubStrategyClientTypes {

    public enum DatabaseManagementPreference: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case awsManaged
        case noPreference
        case selfManage
        case sdkUnknown(Swift.String)

        public static var allCases: [DatabaseManagementPreference] {
            return [
                .awsManaged,
                .noPreference,
                .selfManage
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .awsManaged: return "AWS-managed"
            case .noPreference: return "No preference"
            case .selfManage: return "Self-manage"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MigrationHubStrategyClientTypes {

    public enum HeterogeneousTargetDatabaseEngine: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case amazonAurora
        case awsPostgresql
        case db2Luw
        case mariaDb
        case microsoftSqlServer
        case mongoDb
        case mysql
        case noneSpecified
        case oracleDatabase
        case sap
        case sdkUnknown(Swift.String)

        public static var allCases: [HeterogeneousTargetDatabaseEngine] {
            return [
                .amazonAurora,
                .awsPostgresql,
                .db2Luw,
                .mariaDb,
                .microsoftSqlServer,
                .mongoDb,
                .mysql,
                .noneSpecified,
                .oracleDatabase,
                .sap
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .amazonAurora: return "Amazon Aurora"
            case .awsPostgresql: return "AWS PostgreSQL"
            case .db2Luw: return "Db2 LUW"
            case .mariaDb: return "MariaDB"
            case .microsoftSqlServer: return "Microsoft SQL Server"
            case .mongoDb: return "MongoDB"
            case .mysql: return "MySQL"
            case .noneSpecified: return "None specified"
            case .oracleDatabase: return "Oracle Database"
            case .sap: return "SAP"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MigrationHubStrategyClientTypes {

    /// The object containing details about heterogeneous database preferences.
    public struct Heterogeneous: Swift.Sendable {
        /// The target database engine for heterogeneous database migration preference.
        /// This member is required.
        public var targetDatabaseEngine: [MigrationHubStrategyClientTypes.HeterogeneousTargetDatabaseEngine]?

        public init(
            targetDatabaseEngine: [MigrationHubStrategyClientTypes.HeterogeneousTargetDatabaseEngine]? = nil
        )
        {
            self.targetDatabaseEngine = targetDatabaseEngine
        }
    }
}

extension MigrationHubStrategyClientTypes {

    public enum HomogeneousTargetDatabaseEngine: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case noneSpecified
        case sdkUnknown(Swift.String)

        public static var allCases: [HomogeneousTargetDatabaseEngine] {
            return [
                .noneSpecified
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .noneSpecified: return "None specified"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MigrationHubStrategyClientTypes {

    /// The object containing details about homogeneous database preferences.
    public struct Homogeneous: Swift.Sendable {
        /// The target database engine for homogeneous database migration preferences.
        public var targetDatabaseEngine: [MigrationHubStrategyClientTypes.HomogeneousTargetDatabaseEngine]?

        public init(
            targetDatabaseEngine: [MigrationHubStrategyClientTypes.HomogeneousTargetDatabaseEngine]? = nil
        )
        {
            self.targetDatabaseEngine = targetDatabaseEngine
        }
    }
}

extension MigrationHubStrategyClientTypes {

    public enum TargetDatabaseEngine: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case amazonAurora
        case awsPostgresql
        case db2Luw
        case mariaDb
        case microsoftSqlServer
        case mongoDb
        case mysql
        case noneSpecified
        case oracleDatabase
        case sap
        case sdkUnknown(Swift.String)

        public static var allCases: [TargetDatabaseEngine] {
            return [
                .amazonAurora,
                .awsPostgresql,
                .db2Luw,
                .mariaDb,
                .microsoftSqlServer,
                .mongoDb,
                .mysql,
                .noneSpecified,
                .oracleDatabase,
                .sap
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .amazonAurora: return "Amazon Aurora"
            case .awsPostgresql: return "AWS PostgreSQL"
            case .db2Luw: return "Db2 LUW"
            case .mariaDb: return "MariaDB"
            case .microsoftSqlServer: return "Microsoft SQL Server"
            case .mongoDb: return "MongoDB"
            case .mysql: return "MySQL"
            case .noneSpecified: return "None specified"
            case .oracleDatabase: return "Oracle Database"
            case .sap: return "SAP"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MigrationHubStrategyClientTypes {

    /// The object containing details about database migration preferences, when you have no particular preference.
    public struct NoDatabaseMigrationPreference: Swift.Sendable {
        /// The target database engine for database migration preference that you specify.
        /// This member is required.
        public var targetDatabaseEngine: [MigrationHubStrategyClientTypes.TargetDatabaseEngine]?

        public init(
            targetDatabaseEngine: [MigrationHubStrategyClientTypes.TargetDatabaseEngine]? = nil
        )
        {
            self.targetDatabaseEngine = targetDatabaseEngine
        }
    }
}

extension MigrationHubStrategyClientTypes {

    /// Preferences for migrating a database to AWS.
    public enum DatabaseMigrationPreference: Swift.Sendable {
        /// Indicates whether you are interested in moving from one type of database to another. For example, from SQL Server to Amazon Aurora MySQL-Compatible Edition.
        case heterogeneous(MigrationHubStrategyClientTypes.Heterogeneous)
        /// Indicates whether you are interested in moving to the same type of database into AWS. For example, from SQL Server in your environment to SQL Server on AWS.
        case homogeneous(MigrationHubStrategyClientTypes.Homogeneous)
        /// Indicated that you do not prefer heterogeneous or homogeneous.
        case nopreference(MigrationHubStrategyClientTypes.NoDatabaseMigrationPreference)
        case sdkUnknown(Swift.String)
    }
}

extension MigrationHubStrategyClientTypes {

    /// Preferences on managing your databases on AWS.
    public struct DatabasePreferences: Swift.Sendable {
        /// Specifies whether you're interested in self-managed databases or databases managed by AWS.
        public var databaseManagementPreference: MigrationHubStrategyClientTypes.DatabaseManagementPreference?
        /// Specifies your preferred migration path.
        public var databaseMigrationPreference: MigrationHubStrategyClientTypes.DatabaseMigrationPreference?

        public init(
            databaseManagementPreference: MigrationHubStrategyClientTypes.DatabaseManagementPreference? = nil,
            databaseMigrationPreference: MigrationHubStrategyClientTypes.DatabaseMigrationPreference? = nil
        )
        {
            self.databaseManagementPreference = databaseManagementPreference
            self.databaseMigrationPreference = databaseMigrationPreference
        }
    }
}

extension MigrationHubStrategyClientTypes {

    /// Business goals that you specify.
    public struct BusinessGoals: Swift.Sendable {
        /// Business goal to reduce license costs.
        public var licenseCostReduction: Swift.Int?
        /// Business goal to modernize infrastructure by moving to cloud native technologies.
        public var modernizeInfrastructureWithCloudNativeTechnologies: Swift.Int?
        /// Business goal to reduce the operational overhead on the team by moving into managed services.
        public var reduceOperationalOverheadWithManagedServices: Swift.Int?
        /// Business goal to achieve migration at a fast pace.
        public var speedOfMigration: Swift.Int?

        public init(
            licenseCostReduction: Swift.Int? = nil,
            modernizeInfrastructureWithCloudNativeTechnologies: Swift.Int? = nil,
            reduceOperationalOverheadWithManagedServices: Swift.Int? = nil,
            speedOfMigration: Swift.Int? = nil
        )
        {
            self.licenseCostReduction = licenseCostReduction
            self.modernizeInfrastructureWithCloudNativeTechnologies = modernizeInfrastructureWithCloudNativeTechnologies
            self.reduceOperationalOverheadWithManagedServices = reduceOperationalOverheadWithManagedServices
            self.speedOfMigration = speedOfMigration
        }
    }
}

extension MigrationHubStrategyClientTypes {

    /// Rank of business goals based on priority.
    public struct PrioritizeBusinessGoals: Swift.Sendable {
        /// Rank of business goals based on priority.
        public var businessGoals: MigrationHubStrategyClientTypes.BusinessGoals?

        public init(
            businessGoals: MigrationHubStrategyClientTypes.BusinessGoals? = nil
        )
        {
            self.businessGoals = businessGoals
        }
    }
}

public struct GetPortfolioPreferencesOutput: Swift.Sendable {
    /// The classification for application component types.
    public var applicationMode: MigrationHubStrategyClientTypes.ApplicationMode?
    /// The transformation preferences for non-database applications.
    public var applicationPreferences: MigrationHubStrategyClientTypes.ApplicationPreferences?
    /// The transformation preferences for database applications.
    public var databasePreferences: MigrationHubStrategyClientTypes.DatabasePreferences?
    /// The rank of business goals based on priority.
    public var prioritizeBusinessGoals: MigrationHubStrategyClientTypes.PrioritizeBusinessGoals?

    public init(
        applicationMode: MigrationHubStrategyClientTypes.ApplicationMode? = nil,
        applicationPreferences: MigrationHubStrategyClientTypes.ApplicationPreferences? = nil,
        databasePreferences: MigrationHubStrategyClientTypes.DatabasePreferences? = nil,
        prioritizeBusinessGoals: MigrationHubStrategyClientTypes.PrioritizeBusinessGoals? = nil
    )
    {
        self.applicationMode = applicationMode
        self.applicationPreferences = applicationPreferences
        self.databasePreferences = databasePreferences
        self.prioritizeBusinessGoals = prioritizeBusinessGoals
    }
}

public struct GetPortfolioSummaryInput: Swift.Sendable {

    public init() { }
}

public struct GetPortfolioSummaryOutput: Swift.Sendable {
    /// An assessment summary for the portfolio including the number of servers to rehost and the overall number of anti-patterns.
    public var assessmentSummary: MigrationHubStrategyClientTypes.AssessmentSummary?

    public init(
        assessmentSummary: MigrationHubStrategyClientTypes.AssessmentSummary? = nil
    )
    {
        self.assessmentSummary = assessmentSummary
    }
}

public struct GetRecommendationReportDetailsInput: Swift.Sendable {
    /// The recommendation report generation task id returned by [StartRecommendationReportGeneration].
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

extension MigrationHubStrategyClientTypes {

    public enum RecommendationReportStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case failed
        case inProgress
        case success
        case sdkUnknown(Swift.String)

        public static var allCases: [RecommendationReportStatus] {
            return [
                .failed,
                .inProgress,
                .success
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .success: return "SUCCESS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MigrationHubStrategyClientTypes {

    /// Contains detailed information about a recommendation report.
    public struct RecommendationReportDetails: Swift.Sendable {
        /// The time that the recommendation report generation task completes.
        public var completionTime: Foundation.Date?
        /// The S3 bucket where the report file is located.
        public var s3Bucket: Swift.String?
        /// The Amazon S3 key name of the report file.
        public var s3Keys: [Swift.String]?
        /// The time that the recommendation report generation task starts.
        public var startTime: Foundation.Date?
        /// The status of the recommendation report generation task.
        public var status: MigrationHubStrategyClientTypes.RecommendationReportStatus?
        /// The status message for recommendation report generation.
        public var statusMessage: Swift.String?

        public init(
            completionTime: Foundation.Date? = nil,
            s3Bucket: Swift.String? = nil,
            s3Keys: [Swift.String]? = nil,
            startTime: Foundation.Date? = nil,
            status: MigrationHubStrategyClientTypes.RecommendationReportStatus? = nil,
            statusMessage: Swift.String? = nil
        )
        {
            self.completionTime = completionTime
            self.s3Bucket = s3Bucket
            self.s3Keys = s3Keys
            self.startTime = startTime
            self.status = status
            self.statusMessage = statusMessage
        }
    }
}

public struct GetRecommendationReportDetailsOutput: Swift.Sendable {
    /// The ID of the recommendation report generation task. See the response of [StartRecommendationReportGeneration].
    public var id: Swift.String?
    /// Detailed information about the recommendation report.
    public var recommendationReportDetails: MigrationHubStrategyClientTypes.RecommendationReportDetails?

    public init(
        id: Swift.String? = nil,
        recommendationReportDetails: MigrationHubStrategyClientTypes.RecommendationReportDetails? = nil
    )
    {
        self.id = id
        self.recommendationReportDetails = recommendationReportDetails
    }
}

public struct GetServerDetailsInput: Swift.Sendable {
    /// The maximum number of items to include in the response. The maximum value is 100.
    public var maxResults: Swift.Int?
    /// The token from a previous call that you use to retrieve the next set of results. For example, if a previous call to this action returned 100 items, but you set maxResults to 10. You'll receive a set of 10 results along with a token. You then use the returned token to retrieve the next set of 10.
    public var nextToken: Swift.String?
    /// The ID of the server.
    /// This member is required.
    public var serverId: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        serverId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.serverId = serverId
    }
}

extension MigrationHubStrategyClientTypes {

    public enum ServerErrorCategory: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case architectureError
        case connectivityError
        case credentialError
        case otherError
        case permissionError
        case sdkUnknown(Swift.String)

        public static var allCases: [ServerErrorCategory] {
            return [
                .architectureError,
                .connectivityError,
                .credentialError,
                .otherError,
                .permissionError
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .architectureError: return "ARCHITECTURE_ERROR"
            case .connectivityError: return "CONNECTIVITY_ERROR"
            case .credentialError: return "CREDENTIAL_ERROR"
            case .otherError: return "OTHER_ERROR"
            case .permissionError: return "PERMISSION_ERROR"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MigrationHubStrategyClientTypes {

    /// The error in server analysis.
    public struct ServerError: Swift.Sendable {
        /// The error category of server analysis.
        public var serverErrorCategory: MigrationHubStrategyClientTypes.ServerErrorCategory?

        public init(
            serverErrorCategory: MigrationHubStrategyClientTypes.ServerErrorCategory? = nil
        )
        {
            self.serverErrorCategory = serverErrorCategory
        }
    }
}

extension MigrationHubStrategyClientTypes {

    /// Information about the server's network for which the assessment was run.
    public struct NetworkInfo: Swift.Sendable {
        /// Information about the name of the interface of the server for which the assessment was run.
        /// This member is required.
        public var interfaceName: Swift.String?
        /// Information about the IP address of the server for which the assessment was run.
        /// This member is required.
        public var ipAddress: Swift.String?
        /// Information about the MAC address of the server for which the assessment was run.
        /// This member is required.
        public var macAddress: Swift.String?
        /// Information about the subnet mask of the server for which the assessment was run.
        /// This member is required.
        public var netMask: Swift.String?

        public init(
            interfaceName: Swift.String? = nil,
            ipAddress: Swift.String? = nil,
            macAddress: Swift.String? = nil,
            netMask: Swift.String? = nil
        )
        {
            self.interfaceName = interfaceName
            self.ipAddress = ipAddress
            self.macAddress = macAddress
            self.netMask = netMask
        }
    }
}

extension MigrationHubStrategyClientTypes {

    public enum OSType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case linux
        case windows
        case sdkUnknown(Swift.String)

        public static var allCases: [OSType] {
            return [
                .linux,
                .windows
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .linux: return "LINUX"
            case .windows: return "WINDOWS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MigrationHubStrategyClientTypes {

    /// Information about the operating system.
    public struct OSInfo: Swift.Sendable {
        /// Information about the type of operating system.
        public var type: MigrationHubStrategyClientTypes.OSType?
        /// Information about the version of operating system.
        public var version: Swift.String?

        public init(
            type: MigrationHubStrategyClientTypes.OSType? = nil,
            version: Swift.String? = nil
        )
        {
            self.type = type
            self.version = version
        }
    }
}

extension MigrationHubStrategyClientTypes {

    /// Information about the server that hosts application components.
    public struct SystemInfo: Swift.Sendable {
        /// CPU architecture type for the server.
        public var cpuArchitecture: Swift.String?
        /// File system type for the server.
        public var fileSystemType: Swift.String?
        /// Networking information related to a server.
        public var networkInfoList: [MigrationHubStrategyClientTypes.NetworkInfo]?
        /// Operating system corresponding to a server.
        public var osInfo: MigrationHubStrategyClientTypes.OSInfo?

        public init(
            cpuArchitecture: Swift.String? = nil,
            fileSystemType: Swift.String? = nil,
            networkInfoList: [MigrationHubStrategyClientTypes.NetworkInfo]? = nil,
            osInfo: MigrationHubStrategyClientTypes.OSInfo? = nil
        )
        {
            self.cpuArchitecture = cpuArchitecture
            self.fileSystemType = fileSystemType
            self.networkInfoList = networkInfoList
            self.osInfo = osInfo
        }
    }
}

extension MigrationHubStrategyClientTypes {

    /// Detailed information about a server.
    public struct ServerDetail: Swift.Sendable {
        /// The S3 bucket name and Amazon S3 key name for anti-pattern report.
        public var antipatternReportS3Object: MigrationHubStrategyClientTypes.S3Object?
        /// The status of the anti-pattern report generation.
        public var antipatternReportStatus: MigrationHubStrategyClientTypes.AntipatternReportStatus?
        /// A message about the status of the anti-pattern report generation.
        public var antipatternReportStatusMessage: Swift.String?
        /// A list of strategy summaries.
        public var applicationComponentStrategySummary: [MigrationHubStrategyClientTypes.StrategySummary]?
        /// The status of assessment for the server.
        public var dataCollectionStatus: MigrationHubStrategyClientTypes.RunTimeAssessmentStatus?
        /// The server ID.
        public var id: Swift.String?
        /// The timestamp of when the server was assessed.
        public var lastAnalyzedTimestamp: Foundation.Date?
        /// A list of anti-pattern severity summaries.
        public var listAntipatternSeveritySummary: [MigrationHubStrategyClientTypes.AntipatternSeveritySummary]?
        /// The name of the server.
        public var name: Swift.String?
        /// A set of recommendations.
        public var recommendationSet: MigrationHubStrategyClientTypes.RecommendationSet?
        /// The error in server analysis.
        public var serverError: MigrationHubStrategyClientTypes.ServerError?
        /// The type of server.
        public var serverType: Swift.String?
        /// A message about the status of data collection, which contains detailed descriptions of any error messages.
        public var statusMessage: Swift.String?
        /// System information about the server.
        public var systemInfo: MigrationHubStrategyClientTypes.SystemInfo?

        public init(
            antipatternReportS3Object: MigrationHubStrategyClientTypes.S3Object? = nil,
            antipatternReportStatus: MigrationHubStrategyClientTypes.AntipatternReportStatus? = nil,
            antipatternReportStatusMessage: Swift.String? = nil,
            applicationComponentStrategySummary: [MigrationHubStrategyClientTypes.StrategySummary]? = nil,
            dataCollectionStatus: MigrationHubStrategyClientTypes.RunTimeAssessmentStatus? = nil,
            id: Swift.String? = nil,
            lastAnalyzedTimestamp: Foundation.Date? = nil,
            listAntipatternSeveritySummary: [MigrationHubStrategyClientTypes.AntipatternSeveritySummary]? = nil,
            name: Swift.String? = nil,
            recommendationSet: MigrationHubStrategyClientTypes.RecommendationSet? = nil,
            serverError: MigrationHubStrategyClientTypes.ServerError? = nil,
            serverType: Swift.String? = nil,
            statusMessage: Swift.String? = nil,
            systemInfo: MigrationHubStrategyClientTypes.SystemInfo? = nil
        )
        {
            self.antipatternReportS3Object = antipatternReportS3Object
            self.antipatternReportStatus = antipatternReportStatus
            self.antipatternReportStatusMessage = antipatternReportStatusMessage
            self.applicationComponentStrategySummary = applicationComponentStrategySummary
            self.dataCollectionStatus = dataCollectionStatus
            self.id = id
            self.lastAnalyzedTimestamp = lastAnalyzedTimestamp
            self.listAntipatternSeveritySummary = listAntipatternSeveritySummary
            self.name = name
            self.recommendationSet = recommendationSet
            self.serverError = serverError
            self.serverType = serverType
            self.statusMessage = statusMessage
            self.systemInfo = systemInfo
        }
    }
}

public struct GetServerDetailsOutput: Swift.Sendable {
    /// The associated application group the server belongs to, as defined in AWS Application Discovery Service.
    public var associatedApplications: [MigrationHubStrategyClientTypes.AssociatedApplication]?
    /// The token you use to retrieve the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?
    /// Detailed information about the server.
    public var serverDetail: MigrationHubStrategyClientTypes.ServerDetail?

    public init(
        associatedApplications: [MigrationHubStrategyClientTypes.AssociatedApplication]? = nil,
        nextToken: Swift.String? = nil,
        serverDetail: MigrationHubStrategyClientTypes.ServerDetail? = nil
    )
    {
        self.associatedApplications = associatedApplications
        self.nextToken = nextToken
        self.serverDetail = serverDetail
    }
}

public struct GetServerStrategiesInput: Swift.Sendable {
    /// The ID of the server.
    /// This member is required.
    public var serverId: Swift.String?

    public init(
        serverId: Swift.String? = nil
    )
    {
        self.serverId = serverId
    }
}

extension MigrationHubStrategyClientTypes {

    /// Contains information about a strategy recommendation for a server.
    public struct ServerStrategy: Swift.Sendable {
        /// Set to true if the recommendation is set as preferred.
        public var isPreferred: Swift.Bool?
        /// The number of application components with this strategy recommendation running on the server.
        public var numberOfApplicationComponents: Swift.Int?
        /// Strategy recommendation for the server.
        public var recommendation: MigrationHubStrategyClientTypes.RecommendationSet?
        /// The recommendation status of the strategy for the server.
        public var status: MigrationHubStrategyClientTypes.StrategyRecommendation?

        public init(
            isPreferred: Swift.Bool? = nil,
            numberOfApplicationComponents: Swift.Int? = nil,
            recommendation: MigrationHubStrategyClientTypes.RecommendationSet? = nil,
            status: MigrationHubStrategyClientTypes.StrategyRecommendation? = nil
        )
        {
            self.isPreferred = isPreferred
            self.numberOfApplicationComponents = numberOfApplicationComponents
            self.recommendation = recommendation
            self.status = status
        }
    }
}

public struct GetServerStrategiesOutput: Swift.Sendable {
    /// A list of strategy recommendations for the server.
    public var serverStrategies: [MigrationHubStrategyClientTypes.ServerStrategy]?

    public init(
        serverStrategies: [MigrationHubStrategyClientTypes.ServerStrategy]? = nil
    )
    {
        self.serverStrategies = serverStrategies
    }
}

extension MigrationHubStrategyClientTypes {

    public enum SortOrder: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case asc
        case desc
        case sdkUnknown(Swift.String)

        public static var allCases: [SortOrder] {
            return [
                .asc,
                .desc
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .asc: return "ASC"
            case .desc: return "DESC"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// Represents input for ListAnalyzableServers operation.
public struct ListAnalyzableServersInput: Swift.Sendable {
    /// The maximum number of items to include in the response. The maximum value is 100.
    public var maxResults: Swift.Int?
    /// The token from a previous call that you use to retrieve the next set of results. For example, if a previous call to this action returned 100 items, but you set maxResults to 10. You'll receive a set of 10 results along with a token. You then use the returned token to retrieve the next set of 10.
    public var nextToken: Swift.String?
    /// Specifies whether to sort by ascending (ASC) or descending (DESC) order.
    public var sort: MigrationHubStrategyClientTypes.SortOrder?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        sort: MigrationHubStrategyClientTypes.SortOrder? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sort = sort
    }
}

/// Represents output for ListAnalyzableServers operation.
public struct ListAnalyzableServersOutput: Swift.Sendable {
    /// The list of analyzable servers with summary information about each server.
    public var analyzableServers: [MigrationHubStrategyClientTypes.AnalyzableServerSummary]?
    /// The token you use to retrieve the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?

    public init(
        analyzableServers: [MigrationHubStrategyClientTypes.AnalyzableServerSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.analyzableServers = analyzableServers
        self.nextToken = nextToken
    }
}

/// Exception to indicate that the service-linked role (SLR) is locked.
public struct ServiceLinkedRoleLockClientException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceLinkedRoleLockClientException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension MigrationHubStrategyClientTypes {

    public enum GroupName: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case externalId
        case externalSourceType
        case sdkUnknown(Swift.String)

        public static var allCases: [GroupName] {
            return [
                .externalId,
                .externalSourceType
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .externalId: return "ExternalId"
            case .externalSourceType: return "ExternalSourceType"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MigrationHubStrategyClientTypes {

    /// The object containing information about distinct imports or groups for Strategy Recommendations.
    public struct Group: Swift.Sendable {
        /// The key of the specific import group.
        public var name: MigrationHubStrategyClientTypes.GroupName?
        /// The value of the specific import group.
        public var value: Swift.String?

        public init(
            name: MigrationHubStrategyClientTypes.GroupName? = nil,
            value: Swift.String? = nil
        )
        {
            self.name = name
            self.value = value
        }
    }
}

public struct ListApplicationComponentsInput: Swift.Sendable {
    /// Criteria for filtering the list of application components.
    public var applicationComponentCriteria: MigrationHubStrategyClientTypes.ApplicationComponentCriteria?
    /// Specify the value based on the application component criteria type. For example, if applicationComponentCriteria is set to SERVER_ID and filterValue is set to server1, then [ListApplicationComponents] returns all the application components running on server1.
    public var filterValue: Swift.String?
    /// The group ID specified in to filter on.
    public var groupIdFilter: [MigrationHubStrategyClientTypes.Group]?
    /// The maximum number of items to include in the response. The maximum value is 100.
    public var maxResults: Swift.Int?
    /// The token from a previous call that you use to retrieve the next set of results. For example, if a previous call to this action returned 100 items, but you set maxResults to 10. You'll receive a set of 10 results along with a token. You then use the returned token to retrieve the next set of 10.
    public var nextToken: Swift.String?
    /// Specifies whether to sort by ascending (ASC) or descending (DESC) order.
    public var sort: MigrationHubStrategyClientTypes.SortOrder?

    public init(
        applicationComponentCriteria: MigrationHubStrategyClientTypes.ApplicationComponentCriteria? = nil,
        filterValue: Swift.String? = nil,
        groupIdFilter: [MigrationHubStrategyClientTypes.Group]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        sort: MigrationHubStrategyClientTypes.SortOrder? = nil
    )
    {
        self.applicationComponentCriteria = applicationComponentCriteria
        self.filterValue = filterValue
        self.groupIdFilter = groupIdFilter
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sort = sort
    }
}

public struct ListApplicationComponentsOutput: Swift.Sendable {
    /// The list of application components with detailed information about each component.
    public var applicationComponentInfos: [MigrationHubStrategyClientTypes.ApplicationComponentDetail]?
    /// The token you use to retrieve the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?

    public init(
        applicationComponentInfos: [MigrationHubStrategyClientTypes.ApplicationComponentDetail]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.applicationComponentInfos = applicationComponentInfos
        self.nextToken = nextToken
    }
}

public struct ListCollectorsInput: Swift.Sendable {
    /// The maximum number of items to include in the response. The maximum value is 100.
    public var maxResults: Swift.Int?
    /// The token from a previous call that you use to retrieve the next set of results. For example, if a previous call to this action returned 100 items, but you set maxResults to 10. You'll receive a set of 10 results along with a token. You then use the returned token to retrieve the next set of 10.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension MigrationHubStrategyClientTypes {

    public enum CollectorHealth: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case collectorHealthy
        case collectorUnhealthy
        case sdkUnknown(Swift.String)

        public static var allCases: [CollectorHealth] {
            return [
                .collectorHealthy,
                .collectorUnhealthy
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .collectorHealthy: return "COLLECTOR_HEALTHY"
            case .collectorUnhealthy: return "COLLECTOR_UNHEALTHY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MigrationHubStrategyClientTypes {

    /// IP address based configurations.
    public struct IPAddressBasedRemoteInfo: Swift.Sendable {
        /// The type of authorization.
        public var authType: MigrationHubStrategyClientTypes.AuthType?
        /// The time stamp of the configuration.
        public var ipAddressConfigurationTimeStamp: Swift.String?
        /// The type of the operating system.
        public var osType: MigrationHubStrategyClientTypes.OSType?

        public init(
            authType: MigrationHubStrategyClientTypes.AuthType? = nil,
            ipAddressConfigurationTimeStamp: Swift.String? = nil,
            osType: MigrationHubStrategyClientTypes.OSType? = nil
        )
        {
            self.authType = authType
            self.ipAddressConfigurationTimeStamp = ipAddressConfigurationTimeStamp
            self.osType = osType
        }
    }
}

extension MigrationHubStrategyClientTypes {

    public enum PipelineType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case azureDevops
        case sdkUnknown(Swift.String)

        public static var allCases: [PipelineType] {
            return [
                .azureDevops
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .azureDevops: return "AZURE_DEVOPS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MigrationHubStrategyClientTypes {

    /// Detailed information of the pipeline.
    public struct PipelineInfo: Swift.Sendable {
        /// The time when the pipeline info was configured.
        public var pipelineConfigurationTimeStamp: Swift.String?
        /// The type of pipeline.
        public var pipelineType: MigrationHubStrategyClientTypes.PipelineType?

        public init(
            pipelineConfigurationTimeStamp: Swift.String? = nil,
            pipelineType: MigrationHubStrategyClientTypes.PipelineType? = nil
        )
        {
            self.pipelineConfigurationTimeStamp = pipelineConfigurationTimeStamp
            self.pipelineType = pipelineType
        }
    }
}

extension MigrationHubStrategyClientTypes {

    /// Information about the server configured for source code analysis.
    public struct RemoteSourceCodeAnalysisServerInfo: Swift.Sendable {
        /// The time when the remote source code server was configured.
        public var remoteSourceCodeAnalysisServerConfigurationTimestamp: Swift.String?

        public init(
            remoteSourceCodeAnalysisServerConfigurationTimestamp: Swift.String? = nil
        )
        {
            self.remoteSourceCodeAnalysisServerConfigurationTimestamp = remoteSourceCodeAnalysisServerConfigurationTimestamp
        }
    }
}

extension MigrationHubStrategyClientTypes {

    /// Details about the server in vCenter.
    public struct VcenterBasedRemoteInfo: Swift.Sendable {
        /// The type of the operating system.
        public var osType: MigrationHubStrategyClientTypes.OSType?
        /// The time when the remote server based on vCenter was last configured.
        public var vcenterConfigurationTimeStamp: Swift.String?

        public init(
            osType: MigrationHubStrategyClientTypes.OSType? = nil,
            vcenterConfigurationTimeStamp: Swift.String? = nil
        )
        {
            self.osType = osType
            self.vcenterConfigurationTimeStamp = vcenterConfigurationTimeStamp
        }
    }
}

extension MigrationHubStrategyClientTypes {

    public enum VersionControlType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case azureDevopsGit
        case github
        case githubEnterprise
        case sdkUnknown(Swift.String)

        public static var allCases: [VersionControlType] {
            return [
                .azureDevopsGit,
                .github,
                .githubEnterprise
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .azureDevopsGit: return "AZURE_DEVOPS_GIT"
            case .github: return "GITHUB"
            case .githubEnterprise: return "GITHUB_ENTERPRISE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MigrationHubStrategyClientTypes {

    /// Details about the version control configuration.
    public struct VersionControlInfo: Swift.Sendable {
        /// The time when the version control system was last configured.
        public var versionControlConfigurationTimeStamp: Swift.String?
        /// The type of version control.
        public var versionControlType: MigrationHubStrategyClientTypes.VersionControlType?

        public init(
            versionControlConfigurationTimeStamp: Swift.String? = nil,
            versionControlType: MigrationHubStrategyClientTypes.VersionControlType? = nil
        )
        {
            self.versionControlConfigurationTimeStamp = versionControlConfigurationTimeStamp
            self.versionControlType = versionControlType
        }
    }
}

extension MigrationHubStrategyClientTypes {

    /// Summary of the collector configuration.
    public struct ConfigurationSummary: Swift.Sendable {
        /// IP address based configurations.
        public var ipAddressBasedRemoteInfoList: [MigrationHubStrategyClientTypes.IPAddressBasedRemoteInfo]?
        /// The list of pipeline info configurations.
        public var pipelineInfoList: [MigrationHubStrategyClientTypes.PipelineInfo]?
        /// Info about the remote server source code configuration.
        public var remoteSourceCodeAnalysisServerInfo: MigrationHubStrategyClientTypes.RemoteSourceCodeAnalysisServerInfo?
        /// The list of vCenter configurations.
        public var vcenterBasedRemoteInfoList: [MigrationHubStrategyClientTypes.VcenterBasedRemoteInfo]?
        /// The list of the version control configurations.
        public var versionControlInfoList: [MigrationHubStrategyClientTypes.VersionControlInfo]?

        public init(
            ipAddressBasedRemoteInfoList: [MigrationHubStrategyClientTypes.IPAddressBasedRemoteInfo]? = nil,
            pipelineInfoList: [MigrationHubStrategyClientTypes.PipelineInfo]? = nil,
            remoteSourceCodeAnalysisServerInfo: MigrationHubStrategyClientTypes.RemoteSourceCodeAnalysisServerInfo? = nil,
            vcenterBasedRemoteInfoList: [MigrationHubStrategyClientTypes.VcenterBasedRemoteInfo]? = nil,
            versionControlInfoList: [MigrationHubStrategyClientTypes.VersionControlInfo]? = nil
        )
        {
            self.ipAddressBasedRemoteInfoList = ipAddressBasedRemoteInfoList
            self.pipelineInfoList = pipelineInfoList
            self.remoteSourceCodeAnalysisServerInfo = remoteSourceCodeAnalysisServerInfo
            self.vcenterBasedRemoteInfoList = vcenterBasedRemoteInfoList
            self.versionControlInfoList = versionControlInfoList
        }
    }
}

extension MigrationHubStrategyClientTypes {

    /// Process data collector that runs in the environment that you specify.
    public struct Collector: Swift.Sendable {
        /// Indicates the health of a collector.
        public var collectorHealth: MigrationHubStrategyClientTypes.CollectorHealth?
        /// The ID of the collector.
        public var collectorId: Swift.String?
        /// Current version of the collector that is running in the environment that you specify.
        public var collectorVersion: Swift.String?
        /// Summary of the collector configuration.
        public var configurationSummary: MigrationHubStrategyClientTypes.ConfigurationSummary?
        /// Hostname of the server that is hosting the collector.
        public var hostName: Swift.String?
        /// IP address of the server that is hosting the collector.
        public var ipAddress: Swift.String?
        /// Time when the collector last pinged the service.
        public var lastActivityTimeStamp: Swift.String?
        /// Time when the collector registered with the service.
        public var registeredTimeStamp: Swift.String?

        public init(
            collectorHealth: MigrationHubStrategyClientTypes.CollectorHealth? = nil,
            collectorId: Swift.String? = nil,
            collectorVersion: Swift.String? = nil,
            configurationSummary: MigrationHubStrategyClientTypes.ConfigurationSummary? = nil,
            hostName: Swift.String? = nil,
            ipAddress: Swift.String? = nil,
            lastActivityTimeStamp: Swift.String? = nil,
            registeredTimeStamp: Swift.String? = nil
        )
        {
            self.collectorHealth = collectorHealth
            self.collectorId = collectorId
            self.collectorVersion = collectorVersion
            self.configurationSummary = configurationSummary
            self.hostName = hostName
            self.ipAddress = ipAddress
            self.lastActivityTimeStamp = lastActivityTimeStamp
            self.registeredTimeStamp = registeredTimeStamp
        }
    }
}

public struct ListCollectorsOutput: Swift.Sendable {
    /// The list of all the installed collectors.
    public var collectors: [MigrationHubStrategyClientTypes.Collector]?
    /// The token you use to retrieve the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?

    public init(
        collectors: [MigrationHubStrategyClientTypes.Collector]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.collectors = collectors
        self.nextToken = nextToken
    }
}

public struct ListImportFileTaskInput: Swift.Sendable {
    /// The total number of items to return. The maximum value is 100.
    public var maxResults: Swift.Int?
    /// The token from a previous call that you use to retrieve the next set of results. For example, if a previous call to this action returned 100 items, but you set maxResults to 10. You'll receive a set of 10 results along with a token. You then use the returned token to retrieve the next set of 10.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension MigrationHubStrategyClientTypes {

    /// Information about the import file tasks you request.
    public struct ImportFileTaskInformation: Swift.Sendable {
        /// The time that the import task completes.
        public var completionTime: Foundation.Date?
        /// The ID of the import file task.
        public var id: Swift.String?
        /// The name of the import task given in StartImportFileTask.
        public var importName: Swift.String?
        /// The S3 bucket where the import file is located.
        public var inputS3Bucket: Swift.String?
        /// The Amazon S3 key name of the import file.
        public var inputS3Key: Swift.String?
        /// The number of records that failed to be imported.
        public var numberOfRecordsFailed: Swift.Int?
        /// The number of records successfully imported.
        public var numberOfRecordsSuccess: Swift.Int?
        /// Start time of the import task.
        public var startTime: Foundation.Date?
        /// Status of import file task.
        public var status: MigrationHubStrategyClientTypes.ImportFileTaskStatus?
        /// The S3 bucket name for status report of import task.
        public var statusReportS3Bucket: Swift.String?
        /// The Amazon S3 key name for status report of import task. The report contains details about whether each record imported successfully or why it did not.
        public var statusReportS3Key: Swift.String?

        public init(
            completionTime: Foundation.Date? = nil,
            id: Swift.String? = nil,
            importName: Swift.String? = nil,
            inputS3Bucket: Swift.String? = nil,
            inputS3Key: Swift.String? = nil,
            numberOfRecordsFailed: Swift.Int? = nil,
            numberOfRecordsSuccess: Swift.Int? = nil,
            startTime: Foundation.Date? = nil,
            status: MigrationHubStrategyClientTypes.ImportFileTaskStatus? = nil,
            statusReportS3Bucket: Swift.String? = nil,
            statusReportS3Key: Swift.String? = nil
        )
        {
            self.completionTime = completionTime
            self.id = id
            self.importName = importName
            self.inputS3Bucket = inputS3Bucket
            self.inputS3Key = inputS3Key
            self.numberOfRecordsFailed = numberOfRecordsFailed
            self.numberOfRecordsSuccess = numberOfRecordsSuccess
            self.startTime = startTime
            self.status = status
            self.statusReportS3Bucket = statusReportS3Bucket
            self.statusReportS3Key = statusReportS3Key
        }
    }
}

public struct ListImportFileTaskOutput: Swift.Sendable {
    /// The token you use to retrieve the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?
    /// Lists information about the files you import.
    public var taskInfos: [MigrationHubStrategyClientTypes.ImportFileTaskInformation]?

    public init(
        nextToken: Swift.String? = nil,
        taskInfos: [MigrationHubStrategyClientTypes.ImportFileTaskInformation]? = nil
    )
    {
        self.nextToken = nextToken
        self.taskInfos = taskInfos
    }
}

extension MigrationHubStrategyClientTypes {

    public enum ServerCriteria: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case analysisStatus
        case destination
        case errorCategory
        case notDefined
        case osName
        case serverId
        case strategy
        case sdkUnknown(Swift.String)

        public static var allCases: [ServerCriteria] {
            return [
                .analysisStatus,
                .destination,
                .errorCategory,
                .notDefined,
                .osName,
                .serverId,
                .strategy
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .analysisStatus: return "ANALYSIS_STATUS"
            case .destination: return "DESTINATION"
            case .errorCategory: return "ERROR_CATEGORY"
            case .notDefined: return "NOT_DEFINED"
            case .osName: return "OS_NAME"
            case .serverId: return "SERVER_ID"
            case .strategy: return "STRATEGY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct ListServersInput: Swift.Sendable {
    /// Specifies the filter value, which is based on the type of server criteria. For example, if serverCriteria is OS_NAME, and the filterValue is equal to WindowsServer, then ListServers returns all of the servers matching the OS name WindowsServer.
    public var filterValue: Swift.String?
    /// Specifies the group ID to filter on.
    public var groupIdFilter: [MigrationHubStrategyClientTypes.Group]?
    /// The maximum number of items to include in the response. The maximum value is 100.
    public var maxResults: Swift.Int?
    /// The token from a previous call that you use to retrieve the next set of results. For example, if a previous call to this action returned 100 items, but you set maxResults to 10. You'll receive a set of 10 results along with a token. You then use the returned token to retrieve the next set of 10.
    public var nextToken: Swift.String?
    /// Criteria for filtering servers.
    public var serverCriteria: MigrationHubStrategyClientTypes.ServerCriteria?
    /// Specifies whether to sort by ascending (ASC) or descending (DESC) order.
    public var sort: MigrationHubStrategyClientTypes.SortOrder?

    public init(
        filterValue: Swift.String? = nil,
        groupIdFilter: [MigrationHubStrategyClientTypes.Group]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        serverCriteria: MigrationHubStrategyClientTypes.ServerCriteria? = nil,
        sort: MigrationHubStrategyClientTypes.SortOrder? = nil
    )
    {
        self.filterValue = filterValue
        self.groupIdFilter = groupIdFilter
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.serverCriteria = serverCriteria
        self.sort = sort
    }
}

public struct ListServersOutput: Swift.Sendable {
    /// The token you use to retrieve the next set of results, or null if there are no more results.
    public var nextToken: Swift.String?
    /// The list of servers with detailed information about each server.
    public var serverInfos: [MigrationHubStrategyClientTypes.ServerDetail]?

    public init(
        nextToken: Swift.String? = nil,
        serverInfos: [MigrationHubStrategyClientTypes.ServerDetail]? = nil
    )
    {
        self.nextToken = nextToken
        self.serverInfos = serverInfos
    }
}

/// Exception to indicate that there is an ongoing task when a new task is created. Return when once the existing tasks are complete.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct PutPortfolioPreferencesInput: Swift.Sendable {
    /// The classification for application component types.
    public var applicationMode: MigrationHubStrategyClientTypes.ApplicationMode?
    /// The transformation preferences for non-database applications.
    public var applicationPreferences: MigrationHubStrategyClientTypes.ApplicationPreferences?
    /// The transformation preferences for database applications.
    public var databasePreferences: MigrationHubStrategyClientTypes.DatabasePreferences?
    /// The rank of the business goals based on priority.
    public var prioritizeBusinessGoals: MigrationHubStrategyClientTypes.PrioritizeBusinessGoals?

    public init(
        applicationMode: MigrationHubStrategyClientTypes.ApplicationMode? = nil,
        applicationPreferences: MigrationHubStrategyClientTypes.ApplicationPreferences? = nil,
        databasePreferences: MigrationHubStrategyClientTypes.DatabasePreferences? = nil,
        prioritizeBusinessGoals: MigrationHubStrategyClientTypes.PrioritizeBusinessGoals? = nil
    )
    {
        self.applicationMode = applicationMode
        self.applicationPreferences = applicationPreferences
        self.databasePreferences = databasePreferences
        self.prioritizeBusinessGoals = prioritizeBusinessGoals
    }
}

public struct PutPortfolioPreferencesOutput: Swift.Sendable {

    public init() { }
}

/// The AWS account has reached its quota of imports. Contact AWS Support to increase the quota for this account.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct StartAssessmentInput: Swift.Sendable {
    /// The data source type of an assessment to be started.
    public var assessmentDataSourceType: MigrationHubStrategyClientTypes.AssessmentDataSourceType?
    /// List of criteria for assessment.
    public var assessmentTargets: [MigrationHubStrategyClientTypes.AssessmentTarget]?
    /// The S3 bucket used by the collectors to send analysis data to the service. The bucket name must begin with migrationhub-strategy-.
    public var s3bucketForAnalysisData: Swift.String?
    /// The S3 bucket where all the reports generated by the service are stored. The bucket name must begin with migrationhub-strategy-.
    public var s3bucketForReportData: Swift.String?

    public init(
        assessmentDataSourceType: MigrationHubStrategyClientTypes.AssessmentDataSourceType? = nil,
        assessmentTargets: [MigrationHubStrategyClientTypes.AssessmentTarget]? = nil,
        s3bucketForAnalysisData: Swift.String? = nil,
        s3bucketForReportData: Swift.String? = nil
    )
    {
        self.assessmentDataSourceType = assessmentDataSourceType
        self.assessmentTargets = assessmentTargets
        self.s3bucketForAnalysisData = s3bucketForAnalysisData
        self.s3bucketForReportData = s3bucketForReportData
    }
}

public struct StartAssessmentOutput: Swift.Sendable {
    /// The ID of the assessment.
    public var assessmentId: Swift.String?

    public init(
        assessmentId: Swift.String? = nil
    )
    {
        self.assessmentId = assessmentId
    }
}

extension MigrationHubStrategyClientTypes {

    public enum DataSourceType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case ads
        case `import`
        case mhsrCollector
        case mpa
        case sdkUnknown(Swift.String)

        public static var allCases: [DataSourceType] {
            return [
                .ads,
                .import,
                .mhsrCollector,
                .mpa
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .ads: return "ApplicationDiscoveryService"
            case .import: return "Import"
            case .mhsrCollector: return "StrategyRecommendationsApplicationDataCollector"
            case .mpa: return "MPA"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct StartImportFileTaskInput: Swift.Sendable {
    /// Specifies the source that the servers are coming from. By default, Strategy Recommendations assumes that the servers specified in the import file are available in AWS Application Discovery Service.
    public var dataSourceType: MigrationHubStrategyClientTypes.DataSourceType?
    /// Groups the resources in the import file together with a unique name. This ID can be as filter in ListApplicationComponents and ListServers.
    public var groupId: [MigrationHubStrategyClientTypes.Group]?
    /// A descriptive name for the request.
    /// This member is required.
    public var name: Swift.String?
    /// The S3 bucket where the import file is located. The bucket name is required to begin with migrationhub-strategy-.
    /// This member is required.
    public var s3Bucket: Swift.String?
    /// The S3 bucket where Strategy Recommendations uploads import results. The bucket name is required to begin with migrationhub-strategy-.
    public var s3bucketForReportData: Swift.String?
    /// The Amazon S3 key name of the import file.
    /// This member is required.
    public var s3key: Swift.String?

    public init(
        dataSourceType: MigrationHubStrategyClientTypes.DataSourceType? = nil,
        groupId: [MigrationHubStrategyClientTypes.Group]? = nil,
        name: Swift.String? = nil,
        s3Bucket: Swift.String? = nil,
        s3bucketForReportData: Swift.String? = nil,
        s3key: Swift.String? = nil
    )
    {
        self.dataSourceType = dataSourceType
        self.groupId = groupId
        self.name = name
        self.s3Bucket = s3Bucket
        self.s3bucketForReportData = s3bucketForReportData
        self.s3key = s3key
    }
}

public struct StartImportFileTaskOutput: Swift.Sendable {
    /// The ID for a specific import task. The ID is unique within an AWS account.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

extension MigrationHubStrategyClientTypes {

    public enum OutputFormat: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case excel
        case json
        case sdkUnknown(Swift.String)

        public static var allCases: [OutputFormat] {
            return [
                .excel,
                .json
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .excel: return "Excel"
            case .json: return "Json"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct StartRecommendationReportGenerationInput: Swift.Sendable {
    /// Groups the resources in the recommendation report with a unique name.
    public var groupIdFilter: [MigrationHubStrategyClientTypes.Group]?
    /// The output format for the recommendation report file. The default format is Microsoft Excel.
    public var outputFormat: MigrationHubStrategyClientTypes.OutputFormat?

    public init(
        groupIdFilter: [MigrationHubStrategyClientTypes.Group]? = nil,
        outputFormat: MigrationHubStrategyClientTypes.OutputFormat? = nil
    )
    {
        self.groupIdFilter = groupIdFilter
        self.outputFormat = outputFormat
    }
}

public struct StartRecommendationReportGenerationOutput: Swift.Sendable {
    /// The ID of the recommendation report generation task.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

public struct StopAssessmentInput: Swift.Sendable {
    /// The assessmentId returned by [StartAssessment].
    /// This member is required.
    public var assessmentId: Swift.String?

    public init(
        assessmentId: Swift.String? = nil
    )
    {
        self.assessmentId = assessmentId
    }
}

public struct StopAssessmentOutput: Swift.Sendable {

    public init() { }
}

extension MigrationHubStrategyClientTypes {

    public enum VersionControl: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case azureDevopsGit
        case github
        case githubEnterprise
        case sdkUnknown(Swift.String)

        public static var allCases: [VersionControl] {
            return [
                .azureDevopsGit,
                .github,
                .githubEnterprise
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .azureDevopsGit: return "AZURE_DEVOPS_GIT"
            case .github: return "GITHUB"
            case .githubEnterprise: return "GITHUB_ENTERPRISE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension MigrationHubStrategyClientTypes {

    /// Object containing source code information that is linked to an application component.
    public struct SourceCode: Swift.Sendable {
        /// The repository name for the source code.
        public var location: Swift.String?
        /// The name of the project.
        public var projectName: Swift.String?
        /// The branch of the source code.
        public var sourceVersion: Swift.String?
        /// The type of repository to use for the source code.
        public var versionControl: MigrationHubStrategyClientTypes.VersionControl?

        public init(
            location: Swift.String? = nil,
            projectName: Swift.String? = nil,
            sourceVersion: Swift.String? = nil,
            versionControl: MigrationHubStrategyClientTypes.VersionControl? = nil
        )
        {
            self.location = location
            self.projectName = projectName
            self.sourceVersion = sourceVersion
            self.versionControl = versionControl
        }
    }
}

extension MigrationHubStrategyClientTypes {

    /// Information about all the available strategy options for migrating and modernizing an application component.
    public struct StrategyOption: Swift.Sendable {
        /// Indicates if a specific strategy is preferred for the application component.
        public var isPreferred: Swift.Bool?
        /// Type of transformation. For example, Rehost, Replatform, and so on.
        public var strategy: MigrationHubStrategyClientTypes.Strategy?
        /// Destination information about where the application component can migrate to. For example, EC2, ECS, and so on.
        public var targetDestination: MigrationHubStrategyClientTypes.TargetDestination?
        /// The name of the tool that can be used to transform an application component using this strategy.
        public var toolName: MigrationHubStrategyClientTypes.TransformationToolName?

        public init(
            isPreferred: Swift.Bool? = nil,
            strategy: MigrationHubStrategyClientTypes.Strategy? = nil,
            targetDestination: MigrationHubStrategyClientTypes.TargetDestination? = nil,
            toolName: MigrationHubStrategyClientTypes.TransformationToolName? = nil
        )
        {
            self.isPreferred = isPreferred
            self.strategy = strategy
            self.targetDestination = targetDestination
            self.toolName = toolName
        }
    }
}

public struct UpdateApplicationComponentConfigInput: Swift.Sendable {
    /// The type of known component.
    public var appType: MigrationHubStrategyClientTypes.AppType?
    /// The ID of the application component. The ID is unique within an AWS account.
    /// This member is required.
    public var applicationComponentId: Swift.String?
    /// Update the configuration request of an application component. If it is set to true, the source code and/or database credentials are updated. If it is set to false, the source code and/or database credentials are updated and an analysis is initiated.
    public var configureOnly: Swift.Bool?
    /// Indicates whether the application component has been included for server recommendation or not.
    public var inclusionStatus: MigrationHubStrategyClientTypes.InclusionStatus?
    /// Database credentials.
    public var secretsManagerKey: Swift.String?
    /// The list of source code configurations to update for the application component.
    public var sourceCodeList: [MigrationHubStrategyClientTypes.SourceCode]?
    /// The preferred strategy options for the application component. Use values from the [GetApplicationComponentStrategies] response.
    public var strategyOption: MigrationHubStrategyClientTypes.StrategyOption?

    public init(
        appType: MigrationHubStrategyClientTypes.AppType? = nil,
        applicationComponentId: Swift.String? = nil,
        configureOnly: Swift.Bool? = nil,
        inclusionStatus: MigrationHubStrategyClientTypes.InclusionStatus? = nil,
        secretsManagerKey: Swift.String? = nil,
        sourceCodeList: [MigrationHubStrategyClientTypes.SourceCode]? = nil,
        strategyOption: MigrationHubStrategyClientTypes.StrategyOption? = nil
    )
    {
        self.appType = appType
        self.applicationComponentId = applicationComponentId
        self.configureOnly = configureOnly
        self.inclusionStatus = inclusionStatus
        self.secretsManagerKey = secretsManagerKey
        self.sourceCodeList = sourceCodeList
        self.strategyOption = strategyOption
    }
}

extension UpdateApplicationComponentConfigInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateApplicationComponentConfigInput(appType: \(Swift.String(describing: appType)), applicationComponentId: \(Swift.String(describing: applicationComponentId)), configureOnly: \(Swift.String(describing: configureOnly)), inclusionStatus: \(Swift.String(describing: inclusionStatus)), sourceCodeList: \(Swift.String(describing: sourceCodeList)), strategyOption: \(Swift.String(describing: strategyOption)), secretsManagerKey: \"CONTENT_REDACTED\")"}
}

public struct UpdateApplicationComponentConfigOutput: Swift.Sendable {

    public init() { }
}

public struct UpdateServerConfigInput: Swift.Sendable {
    /// The ID of the server.
    /// This member is required.
    public var serverId: Swift.String?
    /// The preferred strategy options for the application component. See the response from [GetServerStrategies].
    public var strategyOption: MigrationHubStrategyClientTypes.StrategyOption?

    public init(
        serverId: Swift.String? = nil,
        strategyOption: MigrationHubStrategyClientTypes.StrategyOption? = nil
    )
    {
        self.serverId = serverId
        self.strategyOption = strategyOption
    }
}

public struct UpdateServerConfigOutput: Swift.Sendable {

    public init() { }
}

extension GetApplicationComponentDetailsInput {

    static func urlPathProvider(_ value: GetApplicationComponentDetailsInput) -> Swift.String? {
        guard let applicationComponentId = value.applicationComponentId else {
            return nil
        }
        return "/get-applicationcomponent-details/\(applicationComponentId.urlPercentEncoding())"
    }
}

extension GetApplicationComponentStrategiesInput {

    static func urlPathProvider(_ value: GetApplicationComponentStrategiesInput) -> Swift.String? {
        guard let applicationComponentId = value.applicationComponentId else {
            return nil
        }
        return "/get-applicationcomponent-strategies/\(applicationComponentId.urlPercentEncoding())"
    }
}

extension GetAssessmentInput {

    static func urlPathProvider(_ value: GetAssessmentInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/get-assessment/\(id.urlPercentEncoding())"
    }
}

extension GetImportFileTaskInput {

    static func urlPathProvider(_ value: GetImportFileTaskInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/get-import-file-task/\(id.urlPercentEncoding())"
    }
}

extension GetLatestAssessmentIdInput {

    static func urlPathProvider(_ value: GetLatestAssessmentIdInput) -> Swift.String? {
        return "/get-latest-assessment-id"
    }
}

extension GetPortfolioPreferencesInput {

    static func urlPathProvider(_ value: GetPortfolioPreferencesInput) -> Swift.String? {
        return "/get-portfolio-preferences"
    }
}

extension GetPortfolioSummaryInput {

    static func urlPathProvider(_ value: GetPortfolioSummaryInput) -> Swift.String? {
        return "/get-portfolio-summary"
    }
}

extension GetRecommendationReportDetailsInput {

    static func urlPathProvider(_ value: GetRecommendationReportDetailsInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/get-recommendation-report-details/\(id.urlPercentEncoding())"
    }
}

extension GetServerDetailsInput {

    static func urlPathProvider(_ value: GetServerDetailsInput) -> Swift.String? {
        guard let serverId = value.serverId else {
            return nil
        }
        return "/get-server-details/\(serverId.urlPercentEncoding())"
    }
}

extension GetServerDetailsInput {

    static func queryItemProvider(_ value: GetServerDetailsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension GetServerStrategiesInput {

    static func urlPathProvider(_ value: GetServerStrategiesInput) -> Swift.String? {
        guard let serverId = value.serverId else {
            return nil
        }
        return "/get-server-strategies/\(serverId.urlPercentEncoding())"
    }
}

extension ListAnalyzableServersInput {

    static func urlPathProvider(_ value: ListAnalyzableServersInput) -> Swift.String? {
        return "/list-analyzable-servers"
    }
}

extension ListApplicationComponentsInput {

    static func urlPathProvider(_ value: ListApplicationComponentsInput) -> Swift.String? {
        return "/list-applicationcomponents"
    }
}

extension ListCollectorsInput {

    static func urlPathProvider(_ value: ListCollectorsInput) -> Swift.String? {
        return "/list-collectors"
    }
}

extension ListCollectorsInput {

    static func queryItemProvider(_ value: ListCollectorsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListImportFileTaskInput {

    static func urlPathProvider(_ value: ListImportFileTaskInput) -> Swift.String? {
        return "/list-import-file-task"
    }
}

extension ListImportFileTaskInput {

    static func queryItemProvider(_ value: ListImportFileTaskInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListServersInput {

    static func urlPathProvider(_ value: ListServersInput) -> Swift.String? {
        return "/list-servers"
    }
}

extension PutPortfolioPreferencesInput {

    static func urlPathProvider(_ value: PutPortfolioPreferencesInput) -> Swift.String? {
        return "/put-portfolio-preferences"
    }
}

extension StartAssessmentInput {

    static func urlPathProvider(_ value: StartAssessmentInput) -> Swift.String? {
        return "/start-assessment"
    }
}

extension StartImportFileTaskInput {

    static func urlPathProvider(_ value: StartImportFileTaskInput) -> Swift.String? {
        return "/start-import-file-task"
    }
}

extension StartRecommendationReportGenerationInput {

    static func urlPathProvider(_ value: StartRecommendationReportGenerationInput) -> Swift.String? {
        return "/start-recommendation-report-generation"
    }
}

extension StopAssessmentInput {

    static func urlPathProvider(_ value: StopAssessmentInput) -> Swift.String? {
        return "/stop-assessment"
    }
}

extension UpdateApplicationComponentConfigInput {

    static func urlPathProvider(_ value: UpdateApplicationComponentConfigInput) -> Swift.String? {
        return "/update-applicationcomponent-config"
    }
}

extension UpdateServerConfigInput {

    static func urlPathProvider(_ value: UpdateServerConfigInput) -> Swift.String? {
        return "/update-server-config"
    }
}

extension ListAnalyzableServersInput {

    static func write(value: ListAnalyzableServersInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
        try writer["sort"].write(value.sort)
    }
}

extension ListApplicationComponentsInput {

    static func write(value: ListApplicationComponentsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["applicationComponentCriteria"].write(value.applicationComponentCriteria)
        try writer["filterValue"].write(value.filterValue)
        try writer["groupIdFilter"].writeList(value.groupIdFilter, memberWritingClosure: MigrationHubStrategyClientTypes.Group.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
        try writer["sort"].write(value.sort)
    }
}

extension ListServersInput {

    static func write(value: ListServersInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["filterValue"].write(value.filterValue)
        try writer["groupIdFilter"].writeList(value.groupIdFilter, memberWritingClosure: MigrationHubStrategyClientTypes.Group.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
        try writer["serverCriteria"].write(value.serverCriteria)
        try writer["sort"].write(value.sort)
    }
}

extension PutPortfolioPreferencesInput {

    static func write(value: PutPortfolioPreferencesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["applicationMode"].write(value.applicationMode)
        try writer["applicationPreferences"].write(value.applicationPreferences, with: MigrationHubStrategyClientTypes.ApplicationPreferences.write(value:to:))
        try writer["databasePreferences"].write(value.databasePreferences, with: MigrationHubStrategyClientTypes.DatabasePreferences.write(value:to:))
        try writer["prioritizeBusinessGoals"].write(value.prioritizeBusinessGoals, with: MigrationHubStrategyClientTypes.PrioritizeBusinessGoals.write(value:to:))
    }
}

extension StartAssessmentInput {

    static func write(value: StartAssessmentInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["assessmentDataSourceType"].write(value.assessmentDataSourceType)
        try writer["assessmentTargets"].writeList(value.assessmentTargets, memberWritingClosure: MigrationHubStrategyClientTypes.AssessmentTarget.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["s3bucketForAnalysisData"].write(value.s3bucketForAnalysisData)
        try writer["s3bucketForReportData"].write(value.s3bucketForReportData)
    }
}

extension StartImportFileTaskInput {

    static func write(value: StartImportFileTaskInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["S3Bucket"].write(value.s3Bucket)
        try writer["dataSourceType"].write(value.dataSourceType)
        try writer["groupId"].writeList(value.groupId, memberWritingClosure: MigrationHubStrategyClientTypes.Group.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["name"].write(value.name)
        try writer["s3bucketForReportData"].write(value.s3bucketForReportData)
        try writer["s3key"].write(value.s3key)
    }
}

extension StartRecommendationReportGenerationInput {

    static func write(value: StartRecommendationReportGenerationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["groupIdFilter"].writeList(value.groupIdFilter, memberWritingClosure: MigrationHubStrategyClientTypes.Group.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["outputFormat"].write(value.outputFormat)
    }
}

extension StopAssessmentInput {

    static func write(value: StopAssessmentInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["assessmentId"].write(value.assessmentId)
    }
}

extension UpdateApplicationComponentConfigInput {

    static func write(value: UpdateApplicationComponentConfigInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["appType"].write(value.appType)
        try writer["applicationComponentId"].write(value.applicationComponentId)
        try writer["configureOnly"].write(value.configureOnly)
        try writer["inclusionStatus"].write(value.inclusionStatus)
        try writer["secretsManagerKey"].write(value.secretsManagerKey)
        try writer["sourceCodeList"].writeList(value.sourceCodeList, memberWritingClosure: MigrationHubStrategyClientTypes.SourceCode.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["strategyOption"].write(value.strategyOption, with: MigrationHubStrategyClientTypes.StrategyOption.write(value:to:))
    }
}

extension UpdateServerConfigInput {

    static func write(value: UpdateServerConfigInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["serverId"].write(value.serverId)
        try writer["strategyOption"].write(value.strategyOption, with: MigrationHubStrategyClientTypes.StrategyOption.write(value:to:))
    }
}

extension GetApplicationComponentDetailsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetApplicationComponentDetailsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetApplicationComponentDetailsOutput()
        value.applicationComponentDetail = try reader["applicationComponentDetail"].readIfPresent(with: MigrationHubStrategyClientTypes.ApplicationComponentDetail.read(from:))
        value.associatedApplications = try reader["associatedApplications"].readListIfPresent(memberReadingClosure: MigrationHubStrategyClientTypes.AssociatedApplication.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.associatedServerIds = try reader["associatedServerIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.moreApplicationResource = try reader["moreApplicationResource"].readIfPresent()
        return value
    }
}

extension GetApplicationComponentStrategiesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetApplicationComponentStrategiesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetApplicationComponentStrategiesOutput()
        value.applicationComponentStrategies = try reader["applicationComponentStrategies"].readListIfPresent(memberReadingClosure: MigrationHubStrategyClientTypes.ApplicationComponentStrategy.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GetAssessmentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetAssessmentOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetAssessmentOutput()
        value.assessmentTargets = try reader["assessmentTargets"].readListIfPresent(memberReadingClosure: MigrationHubStrategyClientTypes.AssessmentTarget.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.dataCollectionDetails = try reader["dataCollectionDetails"].readIfPresent(with: MigrationHubStrategyClientTypes.DataCollectionDetails.read(from:))
        value.id = try reader["id"].readIfPresent()
        return value
    }
}

extension GetImportFileTaskOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetImportFileTaskOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetImportFileTaskOutput()
        value.completionTime = try reader["completionTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.id = try reader["id"].readIfPresent()
        value.importName = try reader["importName"].readIfPresent()
        value.inputS3Bucket = try reader["inputS3Bucket"].readIfPresent()
        value.inputS3Key = try reader["inputS3Key"].readIfPresent()
        value.numberOfRecordsFailed = try reader["numberOfRecordsFailed"].readIfPresent()
        value.numberOfRecordsSuccess = try reader["numberOfRecordsSuccess"].readIfPresent()
        value.startTime = try reader["startTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.status = try reader["status"].readIfPresent()
        value.statusReportS3Bucket = try reader["statusReportS3Bucket"].readIfPresent()
        value.statusReportS3Key = try reader["statusReportS3Key"].readIfPresent()
        return value
    }
}

extension GetLatestAssessmentIdOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetLatestAssessmentIdOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetLatestAssessmentIdOutput()
        value.id = try reader["id"].readIfPresent()
        return value
    }
}

extension GetPortfolioPreferencesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetPortfolioPreferencesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetPortfolioPreferencesOutput()
        value.applicationMode = try reader["applicationMode"].readIfPresent()
        value.applicationPreferences = try reader["applicationPreferences"].readIfPresent(with: MigrationHubStrategyClientTypes.ApplicationPreferences.read(from:))
        value.databasePreferences = try reader["databasePreferences"].readIfPresent(with: MigrationHubStrategyClientTypes.DatabasePreferences.read(from:))
        value.prioritizeBusinessGoals = try reader["prioritizeBusinessGoals"].readIfPresent(with: MigrationHubStrategyClientTypes.PrioritizeBusinessGoals.read(from:))
        return value
    }
}

extension GetPortfolioSummaryOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetPortfolioSummaryOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetPortfolioSummaryOutput()
        value.assessmentSummary = try reader["assessmentSummary"].readIfPresent(with: MigrationHubStrategyClientTypes.AssessmentSummary.read(from:))
        return value
    }
}

extension GetRecommendationReportDetailsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetRecommendationReportDetailsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetRecommendationReportDetailsOutput()
        value.id = try reader["id"].readIfPresent()
        value.recommendationReportDetails = try reader["recommendationReportDetails"].readIfPresent(with: MigrationHubStrategyClientTypes.RecommendationReportDetails.read(from:))
        return value
    }
}

extension GetServerDetailsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetServerDetailsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetServerDetailsOutput()
        value.associatedApplications = try reader["associatedApplications"].readListIfPresent(memberReadingClosure: MigrationHubStrategyClientTypes.AssociatedApplication.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.serverDetail = try reader["serverDetail"].readIfPresent(with: MigrationHubStrategyClientTypes.ServerDetail.read(from:))
        return value
    }
}

extension GetServerStrategiesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetServerStrategiesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetServerStrategiesOutput()
        value.serverStrategies = try reader["serverStrategies"].readListIfPresent(memberReadingClosure: MigrationHubStrategyClientTypes.ServerStrategy.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListAnalyzableServersOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListAnalyzableServersOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListAnalyzableServersOutput()
        value.analyzableServers = try reader["analyzableServers"].readListIfPresent(memberReadingClosure: MigrationHubStrategyClientTypes.AnalyzableServerSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListApplicationComponentsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListApplicationComponentsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListApplicationComponentsOutput()
        value.applicationComponentInfos = try reader["applicationComponentInfos"].readListIfPresent(memberReadingClosure: MigrationHubStrategyClientTypes.ApplicationComponentDetail.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListCollectorsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListCollectorsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListCollectorsOutput()
        value.collectors = try reader["Collectors"].readListIfPresent(memberReadingClosure: MigrationHubStrategyClientTypes.Collector.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListImportFileTaskOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListImportFileTaskOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListImportFileTaskOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.taskInfos = try reader["taskInfos"].readListIfPresent(memberReadingClosure: MigrationHubStrategyClientTypes.ImportFileTaskInformation.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListServersOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListServersOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListServersOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.serverInfos = try reader["serverInfos"].readListIfPresent(memberReadingClosure: MigrationHubStrategyClientTypes.ServerDetail.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension PutPortfolioPreferencesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutPortfolioPreferencesOutput {
        return PutPortfolioPreferencesOutput()
    }
}

extension StartAssessmentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartAssessmentOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartAssessmentOutput()
        value.assessmentId = try reader["assessmentId"].readIfPresent()
        return value
    }
}

extension StartImportFileTaskOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartImportFileTaskOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartImportFileTaskOutput()
        value.id = try reader["id"].readIfPresent()
        return value
    }
}

extension StartRecommendationReportGenerationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartRecommendationReportGenerationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartRecommendationReportGenerationOutput()
        value.id = try reader["id"].readIfPresent()
        return value
    }
}

extension StopAssessmentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StopAssessmentOutput {
        return StopAssessmentOutput()
    }
}

extension UpdateApplicationComponentConfigOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateApplicationComponentConfigOutput {
        return UpdateApplicationComponentConfigOutput()
    }
}

extension UpdateServerConfigOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateServerConfigOutput {
        return UpdateServerConfigOutput()
    }
}

enum GetApplicationComponentDetailsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetApplicationComponentStrategiesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetAssessmentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetImportFileTaskOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetLatestAssessmentIdOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "DependencyException": return try DependencyException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetPortfolioPreferencesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetPortfolioSummaryOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetRecommendationReportDetailsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetServerDetailsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetServerStrategiesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListAnalyzableServersOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListApplicationComponentsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ServiceLinkedRoleLockClientException": return try ServiceLinkedRoleLockClientException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListCollectorsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListImportFileTaskOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListServersOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutPortfolioPreferencesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartAssessmentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartImportFileTaskOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartRecommendationReportGenerationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StopAssessmentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateApplicationComponentConfigOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateServerConfigOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ThrottlingException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ThrottlingException {
        let reader = baseError.errorBodyReader
        var value = ThrottlingException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InternalServerException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InternalServerException {
        let reader = baseError.errorBodyReader
        var value = InternalServerException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension AccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> AccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = AccessDeniedException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ValidationException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ValidationException {
        let reader = baseError.errorBodyReader
        var value = ValidationException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension DependencyException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> DependencyException {
        let reader = baseError.errorBodyReader
        var value = DependencyException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ServiceLinkedRoleLockClientException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ServiceLinkedRoleLockClientException {
        let reader = baseError.errorBodyReader
        var value = ServiceLinkedRoleLockClientException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ConflictException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ConflictException {
        let reader = baseError.errorBodyReader
        var value = ConflictException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ServiceQuotaExceededException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ServiceQuotaExceededException {
        let reader = baseError.errorBodyReader
        var value = ServiceQuotaExceededException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension MigrationHubStrategyClientTypes.ApplicationComponentDetail {

    static func read(from reader: SmithyJSON.Reader) throws -> MigrationHubStrategyClientTypes.ApplicationComponentDetail {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MigrationHubStrategyClientTypes.ApplicationComponentDetail()
        value.id = try reader["id"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.recommendationSet = try reader["recommendationSet"].readIfPresent(with: MigrationHubStrategyClientTypes.RecommendationSet.read(from:))
        value.analysisStatus = try reader["analysisStatus"].readIfPresent()
        value.statusMessage = try reader["statusMessage"].readIfPresent()
        value.listAntipatternSeveritySummary = try reader["listAntipatternSeveritySummary"].readListIfPresent(memberReadingClosure: MigrationHubStrategyClientTypes.AntipatternSeveritySummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.databaseConfigDetail = try reader["databaseConfigDetail"].readIfPresent(with: MigrationHubStrategyClientTypes.DatabaseConfigDetail.read(from:))
        value.sourceCodeRepositories = try reader["sourceCodeRepositories"].readListIfPresent(memberReadingClosure: MigrationHubStrategyClientTypes.SourceCodeRepository.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.appType = try reader["appType"].readIfPresent()
        value.resourceSubType = try reader["resourceSubType"].readIfPresent()
        value.inclusionStatus = try reader["inclusionStatus"].readIfPresent()
        value.antipatternReportS3Object = try reader["antipatternReportS3Object"].readIfPresent(with: MigrationHubStrategyClientTypes.S3Object.read(from:))
        value.antipatternReportStatus = try reader["antipatternReportStatus"].readIfPresent()
        value.antipatternReportStatusMessage = try reader["antipatternReportStatusMessage"].readIfPresent()
        value.osVersion = try reader["osVersion"].readIfPresent()
        value.osDriver = try reader["osDriver"].readIfPresent()
        value.lastAnalyzedTimestamp = try reader["lastAnalyzedTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.associatedServerId = try reader["associatedServerId"].readIfPresent()
        value.moreServerAssociationExists = try reader["moreServerAssociationExists"].readIfPresent()
        value.runtimeStatus = try reader["runtimeStatus"].readIfPresent()
        value.runtimeStatusMessage = try reader["runtimeStatusMessage"].readIfPresent()
        value.appUnitError = try reader["appUnitError"].readIfPresent(with: MigrationHubStrategyClientTypes.AppUnitError.read(from:))
        value.resultList = try reader["resultList"].readListIfPresent(memberReadingClosure: MigrationHubStrategyClientTypes.Result.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension MigrationHubStrategyClientTypes.Result {

    static func read(from reader: SmithyJSON.Reader) throws -> MigrationHubStrategyClientTypes.Result {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MigrationHubStrategyClientTypes.Result()
        value.analysisType = try reader["analysisType"].readIfPresent()
        value.analysisStatus = try reader["analysisStatus"].readIfPresent(with: MigrationHubStrategyClientTypes.AnalysisStatusUnion.read(from:))
        value.statusMessage = try reader["statusMessage"].readIfPresent()
        value.antipatternReportResultList = try reader["antipatternReportResultList"].readListIfPresent(memberReadingClosure: MigrationHubStrategyClientTypes.AntipatternReportResult.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension MigrationHubStrategyClientTypes.AntipatternReportResult {

    static func read(from reader: SmithyJSON.Reader) throws -> MigrationHubStrategyClientTypes.AntipatternReportResult {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MigrationHubStrategyClientTypes.AntipatternReportResult()
        value.analyzerName = try reader["analyzerName"].readIfPresent(with: MigrationHubStrategyClientTypes.AnalyzerNameUnion.read(from:))
        value.antiPatternReportS3Object = try reader["antiPatternReportS3Object"].readIfPresent(with: MigrationHubStrategyClientTypes.S3Object.read(from:))
        value.antipatternReportStatus = try reader["antipatternReportStatus"].readIfPresent()
        value.antipatternReportStatusMessage = try reader["antipatternReportStatusMessage"].readIfPresent()
        return value
    }
}

extension MigrationHubStrategyClientTypes.S3Object {

    static func read(from reader: SmithyJSON.Reader) throws -> MigrationHubStrategyClientTypes.S3Object {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MigrationHubStrategyClientTypes.S3Object()
        value.s3Bucket = try reader["s3Bucket"].readIfPresent()
        value.s3key = try reader["s3key"].readIfPresent()
        return value
    }
}

extension MigrationHubStrategyClientTypes.AnalyzerNameUnion {

    static func read(from reader: SmithyJSON.Reader) throws -> MigrationHubStrategyClientTypes.AnalyzerNameUnion {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "binaryAnalyzerName":
                return .binaryanalyzername(try reader["binaryAnalyzerName"].read())
            case "runTimeAnalyzerName":
                return .runtimeanalyzername(try reader["runTimeAnalyzerName"].read())
            case "sourceCodeAnalyzerName":
                return .sourcecodeanalyzername(try reader["sourceCodeAnalyzerName"].read())
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension MigrationHubStrategyClientTypes.AnalysisStatusUnion {

    static func read(from reader: SmithyJSON.Reader) throws -> MigrationHubStrategyClientTypes.AnalysisStatusUnion {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "runtimeAnalysisStatus":
                return .runtimeanalysisstatus(try reader["runtimeAnalysisStatus"].read())
            case "srcCodeOrDbAnalysisStatus":
                return .srccodeordbanalysisstatus(try reader["srcCodeOrDbAnalysisStatus"].read())
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension MigrationHubStrategyClientTypes.AppUnitError {

    static func read(from reader: SmithyJSON.Reader) throws -> MigrationHubStrategyClientTypes.AppUnitError {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MigrationHubStrategyClientTypes.AppUnitError()
        value.appUnitErrorCategory = try reader["appUnitErrorCategory"].readIfPresent()
        return value
    }
}

extension MigrationHubStrategyClientTypes.SourceCodeRepository {

    static func read(from reader: SmithyJSON.Reader) throws -> MigrationHubStrategyClientTypes.SourceCodeRepository {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MigrationHubStrategyClientTypes.SourceCodeRepository()
        value.repository = try reader["repository"].readIfPresent()
        value.branch = try reader["branch"].readIfPresent()
        value.versionControlType = try reader["versionControlType"].readIfPresent()
        value.projectName = try reader["projectName"].readIfPresent()
        return value
    }
}

extension MigrationHubStrategyClientTypes.DatabaseConfigDetail {

    static func read(from reader: SmithyJSON.Reader) throws -> MigrationHubStrategyClientTypes.DatabaseConfigDetail {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MigrationHubStrategyClientTypes.DatabaseConfigDetail()
        value.secretName = try reader["secretName"].readIfPresent()
        return value
    }
}

extension MigrationHubStrategyClientTypes.AntipatternSeveritySummary {

    static func read(from reader: SmithyJSON.Reader) throws -> MigrationHubStrategyClientTypes.AntipatternSeveritySummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MigrationHubStrategyClientTypes.AntipatternSeveritySummary()
        value.severity = try reader["severity"].readIfPresent()
        value.count = try reader["count"].readIfPresent()
        return value
    }
}

extension MigrationHubStrategyClientTypes.RecommendationSet {

    static func read(from reader: SmithyJSON.Reader) throws -> MigrationHubStrategyClientTypes.RecommendationSet {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MigrationHubStrategyClientTypes.RecommendationSet()
        value.transformationTool = try reader["transformationTool"].readIfPresent(with: MigrationHubStrategyClientTypes.TransformationTool.read(from:))
        value.targetDestination = try reader["targetDestination"].readIfPresent()
        value.strategy = try reader["strategy"].readIfPresent()
        return value
    }
}

extension MigrationHubStrategyClientTypes.TransformationTool {

    static func read(from reader: SmithyJSON.Reader) throws -> MigrationHubStrategyClientTypes.TransformationTool {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MigrationHubStrategyClientTypes.TransformationTool()
        value.name = try reader["name"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.tranformationToolInstallationLink = try reader["tranformationToolInstallationLink"].readIfPresent()
        return value
    }
}

extension MigrationHubStrategyClientTypes.AssociatedApplication {

    static func read(from reader: SmithyJSON.Reader) throws -> MigrationHubStrategyClientTypes.AssociatedApplication {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MigrationHubStrategyClientTypes.AssociatedApplication()
        value.name = try reader["name"].readIfPresent()
        value.id = try reader["id"].readIfPresent()
        return value
    }
}

extension MigrationHubStrategyClientTypes.ApplicationComponentStrategy {

    static func read(from reader: SmithyJSON.Reader) throws -> MigrationHubStrategyClientTypes.ApplicationComponentStrategy {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MigrationHubStrategyClientTypes.ApplicationComponentStrategy()
        value.recommendation = try reader["recommendation"].readIfPresent(with: MigrationHubStrategyClientTypes.RecommendationSet.read(from:))
        value.status = try reader["status"].readIfPresent()
        value.isPreferred = try reader["isPreferred"].readIfPresent()
        return value
    }
}

extension MigrationHubStrategyClientTypes.DataCollectionDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> MigrationHubStrategyClientTypes.DataCollectionDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MigrationHubStrategyClientTypes.DataCollectionDetails()
        value.status = try reader["status"].readIfPresent()
        value.servers = try reader["servers"].readIfPresent()
        value.failed = try reader["failed"].readIfPresent()
        value.success = try reader["success"].readIfPresent()
        value.inProgress = try reader["inProgress"].readIfPresent()
        value.startTime = try reader["startTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.completionTime = try reader["completionTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.statusMessage = try reader["statusMessage"].readIfPresent()
        return value
    }
}

extension MigrationHubStrategyClientTypes.AssessmentTarget {

    static func write(value: MigrationHubStrategyClientTypes.AssessmentTarget?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["condition"].write(value.condition)
        try writer["name"].write(value.name)
        try writer["values"].writeList(value.values, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> MigrationHubStrategyClientTypes.AssessmentTarget {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MigrationHubStrategyClientTypes.AssessmentTarget()
        value.condition = try reader["condition"].readIfPresent() ?? .sdkUnknown("")
        value.name = try reader["name"].readIfPresent() ?? ""
        value.values = try reader["values"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension MigrationHubStrategyClientTypes.PrioritizeBusinessGoals {

    static func write(value: MigrationHubStrategyClientTypes.PrioritizeBusinessGoals?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["businessGoals"].write(value.businessGoals, with: MigrationHubStrategyClientTypes.BusinessGoals.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> MigrationHubStrategyClientTypes.PrioritizeBusinessGoals {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MigrationHubStrategyClientTypes.PrioritizeBusinessGoals()
        value.businessGoals = try reader["businessGoals"].readIfPresent(with: MigrationHubStrategyClientTypes.BusinessGoals.read(from:))
        return value
    }
}

extension MigrationHubStrategyClientTypes.BusinessGoals {

    static func write(value: MigrationHubStrategyClientTypes.BusinessGoals?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["licenseCostReduction"].write(value.licenseCostReduction)
        try writer["modernizeInfrastructureWithCloudNativeTechnologies"].write(value.modernizeInfrastructureWithCloudNativeTechnologies)
        try writer["reduceOperationalOverheadWithManagedServices"].write(value.reduceOperationalOverheadWithManagedServices)
        try writer["speedOfMigration"].write(value.speedOfMigration)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> MigrationHubStrategyClientTypes.BusinessGoals {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MigrationHubStrategyClientTypes.BusinessGoals()
        value.speedOfMigration = try reader["speedOfMigration"].readIfPresent()
        value.reduceOperationalOverheadWithManagedServices = try reader["reduceOperationalOverheadWithManagedServices"].readIfPresent()
        value.modernizeInfrastructureWithCloudNativeTechnologies = try reader["modernizeInfrastructureWithCloudNativeTechnologies"].readIfPresent()
        value.licenseCostReduction = try reader["licenseCostReduction"].readIfPresent()
        return value
    }
}

extension MigrationHubStrategyClientTypes.ApplicationPreferences {

    static func write(value: MigrationHubStrategyClientTypes.ApplicationPreferences?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["managementPreference"].write(value.managementPreference, with: MigrationHubStrategyClientTypes.ManagementPreference.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> MigrationHubStrategyClientTypes.ApplicationPreferences {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MigrationHubStrategyClientTypes.ApplicationPreferences()
        value.managementPreference = try reader["managementPreference"].readIfPresent(with: MigrationHubStrategyClientTypes.ManagementPreference.read(from:))
        return value
    }
}

extension MigrationHubStrategyClientTypes.ManagementPreference {

    static func write(value: MigrationHubStrategyClientTypes.ManagementPreference?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .awsmanagedresources(awsmanagedresources):
                try writer["awsManagedResources"].write(awsmanagedresources, with: MigrationHubStrategyClientTypes.AwsManagedResources.write(value:to:))
            case let .nopreference(nopreference):
                try writer["noPreference"].write(nopreference, with: MigrationHubStrategyClientTypes.NoManagementPreference.write(value:to:))
            case let .selfmanageresources(selfmanageresources):
                try writer["selfManageResources"].write(selfmanageresources, with: MigrationHubStrategyClientTypes.SelfManageResources.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> MigrationHubStrategyClientTypes.ManagementPreference {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "awsManagedResources":
                return .awsmanagedresources(try reader["awsManagedResources"].read(with: MigrationHubStrategyClientTypes.AwsManagedResources.read(from:)))
            case "selfManageResources":
                return .selfmanageresources(try reader["selfManageResources"].read(with: MigrationHubStrategyClientTypes.SelfManageResources.read(from:)))
            case "noPreference":
                return .nopreference(try reader["noPreference"].read(with: MigrationHubStrategyClientTypes.NoManagementPreference.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension MigrationHubStrategyClientTypes.NoManagementPreference {

    static func write(value: MigrationHubStrategyClientTypes.NoManagementPreference?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["targetDestination"].writeList(value.targetDestination, memberWritingClosure: SmithyReadWrite.WritingClosureBox<MigrationHubStrategyClientTypes.NoPreferenceTargetDestination>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> MigrationHubStrategyClientTypes.NoManagementPreference {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MigrationHubStrategyClientTypes.NoManagementPreference()
        value.targetDestination = try reader["targetDestination"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<MigrationHubStrategyClientTypes.NoPreferenceTargetDestination>().read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension MigrationHubStrategyClientTypes.SelfManageResources {

    static func write(value: MigrationHubStrategyClientTypes.SelfManageResources?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["targetDestination"].writeList(value.targetDestination, memberWritingClosure: SmithyReadWrite.WritingClosureBox<MigrationHubStrategyClientTypes.SelfManageTargetDestination>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> MigrationHubStrategyClientTypes.SelfManageResources {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MigrationHubStrategyClientTypes.SelfManageResources()
        value.targetDestination = try reader["targetDestination"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<MigrationHubStrategyClientTypes.SelfManageTargetDestination>().read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension MigrationHubStrategyClientTypes.AwsManagedResources {

    static func write(value: MigrationHubStrategyClientTypes.AwsManagedResources?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["targetDestination"].writeList(value.targetDestination, memberWritingClosure: SmithyReadWrite.WritingClosureBox<MigrationHubStrategyClientTypes.AwsManagedTargetDestination>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> MigrationHubStrategyClientTypes.AwsManagedResources {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MigrationHubStrategyClientTypes.AwsManagedResources()
        value.targetDestination = try reader["targetDestination"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<MigrationHubStrategyClientTypes.AwsManagedTargetDestination>().read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension MigrationHubStrategyClientTypes.DatabasePreferences {

    static func write(value: MigrationHubStrategyClientTypes.DatabasePreferences?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["databaseManagementPreference"].write(value.databaseManagementPreference)
        try writer["databaseMigrationPreference"].write(value.databaseMigrationPreference, with: MigrationHubStrategyClientTypes.DatabaseMigrationPreference.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> MigrationHubStrategyClientTypes.DatabasePreferences {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MigrationHubStrategyClientTypes.DatabasePreferences()
        value.databaseManagementPreference = try reader["databaseManagementPreference"].readIfPresent()
        value.databaseMigrationPreference = try reader["databaseMigrationPreference"].readIfPresent(with: MigrationHubStrategyClientTypes.DatabaseMigrationPreference.read(from:))
        return value
    }
}

extension MigrationHubStrategyClientTypes.DatabaseMigrationPreference {

    static func write(value: MigrationHubStrategyClientTypes.DatabaseMigrationPreference?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .heterogeneous(heterogeneous):
                try writer["heterogeneous"].write(heterogeneous, with: MigrationHubStrategyClientTypes.Heterogeneous.write(value:to:))
            case let .homogeneous(homogeneous):
                try writer["homogeneous"].write(homogeneous, with: MigrationHubStrategyClientTypes.Homogeneous.write(value:to:))
            case let .nopreference(nopreference):
                try writer["noPreference"].write(nopreference, with: MigrationHubStrategyClientTypes.NoDatabaseMigrationPreference.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> MigrationHubStrategyClientTypes.DatabaseMigrationPreference {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "heterogeneous":
                return .heterogeneous(try reader["heterogeneous"].read(with: MigrationHubStrategyClientTypes.Heterogeneous.read(from:)))
            case "homogeneous":
                return .homogeneous(try reader["homogeneous"].read(with: MigrationHubStrategyClientTypes.Homogeneous.read(from:)))
            case "noPreference":
                return .nopreference(try reader["noPreference"].read(with: MigrationHubStrategyClientTypes.NoDatabaseMigrationPreference.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension MigrationHubStrategyClientTypes.NoDatabaseMigrationPreference {

    static func write(value: MigrationHubStrategyClientTypes.NoDatabaseMigrationPreference?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["targetDatabaseEngine"].writeList(value.targetDatabaseEngine, memberWritingClosure: SmithyReadWrite.WritingClosureBox<MigrationHubStrategyClientTypes.TargetDatabaseEngine>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> MigrationHubStrategyClientTypes.NoDatabaseMigrationPreference {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MigrationHubStrategyClientTypes.NoDatabaseMigrationPreference()
        value.targetDatabaseEngine = try reader["targetDatabaseEngine"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<MigrationHubStrategyClientTypes.TargetDatabaseEngine>().read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension MigrationHubStrategyClientTypes.Homogeneous {

    static func write(value: MigrationHubStrategyClientTypes.Homogeneous?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["targetDatabaseEngine"].writeList(value.targetDatabaseEngine, memberWritingClosure: SmithyReadWrite.WritingClosureBox<MigrationHubStrategyClientTypes.HomogeneousTargetDatabaseEngine>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> MigrationHubStrategyClientTypes.Homogeneous {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MigrationHubStrategyClientTypes.Homogeneous()
        value.targetDatabaseEngine = try reader["targetDatabaseEngine"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<MigrationHubStrategyClientTypes.HomogeneousTargetDatabaseEngine>().read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension MigrationHubStrategyClientTypes.Heterogeneous {

    static func write(value: MigrationHubStrategyClientTypes.Heterogeneous?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["targetDatabaseEngine"].writeList(value.targetDatabaseEngine, memberWritingClosure: SmithyReadWrite.WritingClosureBox<MigrationHubStrategyClientTypes.HeterogeneousTargetDatabaseEngine>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> MigrationHubStrategyClientTypes.Heterogeneous {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MigrationHubStrategyClientTypes.Heterogeneous()
        value.targetDatabaseEngine = try reader["targetDatabaseEngine"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<MigrationHubStrategyClientTypes.HeterogeneousTargetDatabaseEngine>().read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension MigrationHubStrategyClientTypes.AssessmentSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> MigrationHubStrategyClientTypes.AssessmentSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MigrationHubStrategyClientTypes.AssessmentSummary()
        value.listServerStrategySummary = try reader["listServerStrategySummary"].readListIfPresent(memberReadingClosure: MigrationHubStrategyClientTypes.StrategySummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.listApplicationComponentStrategySummary = try reader["listApplicationComponentStrategySummary"].readListIfPresent(memberReadingClosure: MigrationHubStrategyClientTypes.StrategySummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.listAntipatternSeveritySummary = try reader["listAntipatternSeveritySummary"].readListIfPresent(memberReadingClosure: MigrationHubStrategyClientTypes.AntipatternSeveritySummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.listApplicationComponentSummary = try reader["listApplicationComponentSummary"].readListIfPresent(memberReadingClosure: MigrationHubStrategyClientTypes.ApplicationComponentSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.listServerSummary = try reader["listServerSummary"].readListIfPresent(memberReadingClosure: MigrationHubStrategyClientTypes.ServerSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.antipatternReportS3Object = try reader["antipatternReportS3Object"].readIfPresent(with: MigrationHubStrategyClientTypes.S3Object.read(from:))
        value.antipatternReportStatus = try reader["antipatternReportStatus"].readIfPresent()
        value.antipatternReportStatusMessage = try reader["antipatternReportStatusMessage"].readIfPresent()
        value.lastAnalyzedTimestamp = try reader["lastAnalyzedTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.listApplicationComponentStatusSummary = try reader["listApplicationComponentStatusSummary"].readListIfPresent(memberReadingClosure: MigrationHubStrategyClientTypes.ApplicationComponentStatusSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.listServerStatusSummary = try reader["listServerStatusSummary"].readListIfPresent(memberReadingClosure: MigrationHubStrategyClientTypes.ServerStatusSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension MigrationHubStrategyClientTypes.ServerStatusSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> MigrationHubStrategyClientTypes.ServerStatusSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MigrationHubStrategyClientTypes.ServerStatusSummary()
        value.runTimeAssessmentStatus = try reader["runTimeAssessmentStatus"].readIfPresent()
        value.count = try reader["count"].readIfPresent()
        return value
    }
}

extension MigrationHubStrategyClientTypes.ApplicationComponentStatusSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> MigrationHubStrategyClientTypes.ApplicationComponentStatusSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MigrationHubStrategyClientTypes.ApplicationComponentStatusSummary()
        value.srcCodeOrDbAnalysisStatus = try reader["srcCodeOrDbAnalysisStatus"].readIfPresent()
        value.count = try reader["count"].readIfPresent()
        return value
    }
}

extension MigrationHubStrategyClientTypes.ServerSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> MigrationHubStrategyClientTypes.ServerSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MigrationHubStrategyClientTypes.ServerSummary()
        value.serverOsType = try reader["ServerOsType"].readIfPresent()
        value.count = try reader["count"].readIfPresent()
        return value
    }
}

extension MigrationHubStrategyClientTypes.ApplicationComponentSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> MigrationHubStrategyClientTypes.ApplicationComponentSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MigrationHubStrategyClientTypes.ApplicationComponentSummary()
        value.appType = try reader["appType"].readIfPresent()
        value.count = try reader["count"].readIfPresent()
        return value
    }
}

extension MigrationHubStrategyClientTypes.StrategySummary {

    static func read(from reader: SmithyJSON.Reader) throws -> MigrationHubStrategyClientTypes.StrategySummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MigrationHubStrategyClientTypes.StrategySummary()
        value.strategy = try reader["strategy"].readIfPresent()
        value.count = try reader["count"].readIfPresent()
        return value
    }
}

extension MigrationHubStrategyClientTypes.RecommendationReportDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> MigrationHubStrategyClientTypes.RecommendationReportDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MigrationHubStrategyClientTypes.RecommendationReportDetails()
        value.status = try reader["status"].readIfPresent()
        value.statusMessage = try reader["statusMessage"].readIfPresent()
        value.startTime = try reader["startTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.completionTime = try reader["completionTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.s3Bucket = try reader["s3Bucket"].readIfPresent()
        value.s3Keys = try reader["s3Keys"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension MigrationHubStrategyClientTypes.ServerDetail {

    static func read(from reader: SmithyJSON.Reader) throws -> MigrationHubStrategyClientTypes.ServerDetail {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MigrationHubStrategyClientTypes.ServerDetail()
        value.id = try reader["id"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.recommendationSet = try reader["recommendationSet"].readIfPresent(with: MigrationHubStrategyClientTypes.RecommendationSet.read(from:))
        value.dataCollectionStatus = try reader["dataCollectionStatus"].readIfPresent()
        value.statusMessage = try reader["statusMessage"].readIfPresent()
        value.listAntipatternSeveritySummary = try reader["listAntipatternSeveritySummary"].readListIfPresent(memberReadingClosure: MigrationHubStrategyClientTypes.AntipatternSeveritySummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.systemInfo = try reader["systemInfo"].readIfPresent(with: MigrationHubStrategyClientTypes.SystemInfo.read(from:))
        value.applicationComponentStrategySummary = try reader["applicationComponentStrategySummary"].readListIfPresent(memberReadingClosure: MigrationHubStrategyClientTypes.StrategySummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.antipatternReportS3Object = try reader["antipatternReportS3Object"].readIfPresent(with: MigrationHubStrategyClientTypes.S3Object.read(from:))
        value.antipatternReportStatus = try reader["antipatternReportStatus"].readIfPresent()
        value.antipatternReportStatusMessage = try reader["antipatternReportStatusMessage"].readIfPresent()
        value.serverType = try reader["serverType"].readIfPresent()
        value.lastAnalyzedTimestamp = try reader["lastAnalyzedTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.serverError = try reader["serverError"].readIfPresent(with: MigrationHubStrategyClientTypes.ServerError.read(from:))
        return value
    }
}

extension MigrationHubStrategyClientTypes.ServerError {

    static func read(from reader: SmithyJSON.Reader) throws -> MigrationHubStrategyClientTypes.ServerError {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MigrationHubStrategyClientTypes.ServerError()
        value.serverErrorCategory = try reader["serverErrorCategory"].readIfPresent()
        return value
    }
}

extension MigrationHubStrategyClientTypes.SystemInfo {

    static func read(from reader: SmithyJSON.Reader) throws -> MigrationHubStrategyClientTypes.SystemInfo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MigrationHubStrategyClientTypes.SystemInfo()
        value.osInfo = try reader["osInfo"].readIfPresent(with: MigrationHubStrategyClientTypes.OSInfo.read(from:))
        value.fileSystemType = try reader["fileSystemType"].readIfPresent()
        value.networkInfoList = try reader["networkInfoList"].readListIfPresent(memberReadingClosure: MigrationHubStrategyClientTypes.NetworkInfo.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.cpuArchitecture = try reader["cpuArchitecture"].readIfPresent()
        return value
    }
}

extension MigrationHubStrategyClientTypes.NetworkInfo {

    static func read(from reader: SmithyJSON.Reader) throws -> MigrationHubStrategyClientTypes.NetworkInfo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MigrationHubStrategyClientTypes.NetworkInfo()
        value.interfaceName = try reader["interfaceName"].readIfPresent() ?? ""
        value.ipAddress = try reader["ipAddress"].readIfPresent() ?? ""
        value.macAddress = try reader["macAddress"].readIfPresent() ?? ""
        value.netMask = try reader["netMask"].readIfPresent() ?? ""
        return value
    }
}

extension MigrationHubStrategyClientTypes.OSInfo {

    static func read(from reader: SmithyJSON.Reader) throws -> MigrationHubStrategyClientTypes.OSInfo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MigrationHubStrategyClientTypes.OSInfo()
        value.type = try reader["type"].readIfPresent()
        value.version = try reader["version"].readIfPresent()
        return value
    }
}

extension MigrationHubStrategyClientTypes.ServerStrategy {

    static func read(from reader: SmithyJSON.Reader) throws -> MigrationHubStrategyClientTypes.ServerStrategy {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MigrationHubStrategyClientTypes.ServerStrategy()
        value.recommendation = try reader["recommendation"].readIfPresent(with: MigrationHubStrategyClientTypes.RecommendationSet.read(from:))
        value.status = try reader["status"].readIfPresent()
        value.numberOfApplicationComponents = try reader["numberOfApplicationComponents"].readIfPresent()
        value.isPreferred = try reader["isPreferred"].readIfPresent()
        return value
    }
}

extension MigrationHubStrategyClientTypes.AnalyzableServerSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> MigrationHubStrategyClientTypes.AnalyzableServerSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MigrationHubStrategyClientTypes.AnalyzableServerSummary()
        value.hostname = try reader["hostname"].readIfPresent()
        value.ipAddress = try reader["ipAddress"].readIfPresent()
        value.source = try reader["source"].readIfPresent()
        value.vmId = try reader["vmId"].readIfPresent()
        return value
    }
}

extension MigrationHubStrategyClientTypes.Collector {

    static func read(from reader: SmithyJSON.Reader) throws -> MigrationHubStrategyClientTypes.Collector {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MigrationHubStrategyClientTypes.Collector()
        value.collectorId = try reader["collectorId"].readIfPresent()
        value.ipAddress = try reader["ipAddress"].readIfPresent()
        value.hostName = try reader["hostName"].readIfPresent()
        value.collectorHealth = try reader["collectorHealth"].readIfPresent()
        value.collectorVersion = try reader["collectorVersion"].readIfPresent()
        value.registeredTimeStamp = try reader["registeredTimeStamp"].readIfPresent()
        value.lastActivityTimeStamp = try reader["lastActivityTimeStamp"].readIfPresent()
        value.configurationSummary = try reader["configurationSummary"].readIfPresent(with: MigrationHubStrategyClientTypes.ConfigurationSummary.read(from:))
        return value
    }
}

extension MigrationHubStrategyClientTypes.ConfigurationSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> MigrationHubStrategyClientTypes.ConfigurationSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MigrationHubStrategyClientTypes.ConfigurationSummary()
        value.vcenterBasedRemoteInfoList = try reader["vcenterBasedRemoteInfoList"].readListIfPresent(memberReadingClosure: MigrationHubStrategyClientTypes.VcenterBasedRemoteInfo.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.ipAddressBasedRemoteInfoList = try reader["ipAddressBasedRemoteInfoList"].readListIfPresent(memberReadingClosure: MigrationHubStrategyClientTypes.IPAddressBasedRemoteInfo.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.versionControlInfoList = try reader["versionControlInfoList"].readListIfPresent(memberReadingClosure: MigrationHubStrategyClientTypes.VersionControlInfo.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.pipelineInfoList = try reader["pipelineInfoList"].readListIfPresent(memberReadingClosure: MigrationHubStrategyClientTypes.PipelineInfo.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.remoteSourceCodeAnalysisServerInfo = try reader["remoteSourceCodeAnalysisServerInfo"].readIfPresent(with: MigrationHubStrategyClientTypes.RemoteSourceCodeAnalysisServerInfo.read(from:))
        return value
    }
}

extension MigrationHubStrategyClientTypes.RemoteSourceCodeAnalysisServerInfo {

    static func read(from reader: SmithyJSON.Reader) throws -> MigrationHubStrategyClientTypes.RemoteSourceCodeAnalysisServerInfo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MigrationHubStrategyClientTypes.RemoteSourceCodeAnalysisServerInfo()
        value.remoteSourceCodeAnalysisServerConfigurationTimestamp = try reader["remoteSourceCodeAnalysisServerConfigurationTimestamp"].readIfPresent()
        return value
    }
}

extension MigrationHubStrategyClientTypes.PipelineInfo {

    static func read(from reader: SmithyJSON.Reader) throws -> MigrationHubStrategyClientTypes.PipelineInfo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MigrationHubStrategyClientTypes.PipelineInfo()
        value.pipelineType = try reader["pipelineType"].readIfPresent()
        value.pipelineConfigurationTimeStamp = try reader["pipelineConfigurationTimeStamp"].readIfPresent()
        return value
    }
}

extension MigrationHubStrategyClientTypes.VersionControlInfo {

    static func read(from reader: SmithyJSON.Reader) throws -> MigrationHubStrategyClientTypes.VersionControlInfo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MigrationHubStrategyClientTypes.VersionControlInfo()
        value.versionControlType = try reader["versionControlType"].readIfPresent()
        value.versionControlConfigurationTimeStamp = try reader["versionControlConfigurationTimeStamp"].readIfPresent()
        return value
    }
}

extension MigrationHubStrategyClientTypes.IPAddressBasedRemoteInfo {

    static func read(from reader: SmithyJSON.Reader) throws -> MigrationHubStrategyClientTypes.IPAddressBasedRemoteInfo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MigrationHubStrategyClientTypes.IPAddressBasedRemoteInfo()
        value.ipAddressConfigurationTimeStamp = try reader["ipAddressConfigurationTimeStamp"].readIfPresent()
        value.authType = try reader["authType"].readIfPresent()
        value.osType = try reader["osType"].readIfPresent()
        return value
    }
}

extension MigrationHubStrategyClientTypes.VcenterBasedRemoteInfo {

    static func read(from reader: SmithyJSON.Reader) throws -> MigrationHubStrategyClientTypes.VcenterBasedRemoteInfo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MigrationHubStrategyClientTypes.VcenterBasedRemoteInfo()
        value.vcenterConfigurationTimeStamp = try reader["vcenterConfigurationTimeStamp"].readIfPresent()
        value.osType = try reader["osType"].readIfPresent()
        return value
    }
}

extension MigrationHubStrategyClientTypes.ImportFileTaskInformation {

    static func read(from reader: SmithyJSON.Reader) throws -> MigrationHubStrategyClientTypes.ImportFileTaskInformation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = MigrationHubStrategyClientTypes.ImportFileTaskInformation()
        value.id = try reader["id"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.startTime = try reader["startTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.inputS3Bucket = try reader["inputS3Bucket"].readIfPresent()
        value.inputS3Key = try reader["inputS3Key"].readIfPresent()
        value.statusReportS3Bucket = try reader["statusReportS3Bucket"].readIfPresent()
        value.statusReportS3Key = try reader["statusReportS3Key"].readIfPresent()
        value.completionTime = try reader["completionTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.numberOfRecordsSuccess = try reader["numberOfRecordsSuccess"].readIfPresent()
        value.numberOfRecordsFailed = try reader["numberOfRecordsFailed"].readIfPresent()
        value.importName = try reader["importName"].readIfPresent()
        return value
    }
}

extension MigrationHubStrategyClientTypes.Group {

    static func write(value: MigrationHubStrategyClientTypes.Group?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["name"].write(value.name)
        try writer["value"].write(value.value)
    }
}

extension MigrationHubStrategyClientTypes.StrategyOption {

    static func write(value: MigrationHubStrategyClientTypes.StrategyOption?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["isPreferred"].write(value.isPreferred)
        try writer["strategy"].write(value.strategy)
        try writer["targetDestination"].write(value.targetDestination)
        try writer["toolName"].write(value.toolName)
    }
}

extension MigrationHubStrategyClientTypes.SourceCode {

    static func write(value: MigrationHubStrategyClientTypes.SourceCode?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["location"].write(value.location)
        try writer["projectName"].write(value.projectName)
        try writer["sourceVersion"].write(value.sourceVersion)
        try writer["versionControl"].write(value.versionControl)
    }
}

public enum MigrationHubStrategyClientTypes {}
