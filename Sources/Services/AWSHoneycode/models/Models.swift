// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// You do not have sufficient access to perform this action. Check that the workbook is owned by you and your IAM policy allows access to the resource in the request.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AutomationExecutionException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AutomationExecutionExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The automation execution did not end successfully.
public struct AutomationExecutionException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AutomationExecutionException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct AutomationExecutionExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AutomationExecutionExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension AutomationExecutionTimeoutException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AutomationExecutionTimeoutExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The automation execution timed out.
public struct AutomationExecutionTimeoutException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AutomationExecutionTimeoutException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct AutomationExecutionTimeoutExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AutomationExecutionTimeoutExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension BatchCreateTableRowsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken
        case rowsToCreate
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = self.clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let rowsToCreate = rowsToCreate {
            var rowsToCreateContainer = encodeContainer.nestedUnkeyedContainer(forKey: .rowsToCreate)
            for createrowdata0 in rowsToCreate {
                try rowsToCreateContainer.encode(createrowdata0)
            }
        }
    }
}

extension BatchCreateTableRowsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let workbookId = workbookId else {
            return nil
        }
        guard let tableId = tableId else {
            return nil
        }
        return "/workbooks/\(workbookId.urlPercentEncoding())/tables/\(tableId.urlPercentEncoding())/rows/batchcreate"
    }
}

public struct BatchCreateTableRowsInput: Swift.Equatable {
    /// The request token for performing the batch create operation. Request tokens help to identify duplicate requests. If a call times out or fails due to a transient error like a failed network connection, you can retry the call with the same request token. The service ensures that if the first call using that request token is successfully performed, the second call will not perform the operation again. Note that request tokens are valid only for a few minutes. You cannot use request tokens to dedupe requests spanning hours or days.
    public var clientRequestToken: Swift.String?
    /// The list of rows to create at the end of the table. Each item in this list needs to have a batch item id to uniquely identify the element in the request and the cells to create for that row. You need to specify at least one item in this list. Note that if one of the column ids in any of the rows in the request does not exist in the table, then the request fails and no updates are made to the table.
    /// This member is required.
    public var rowsToCreate: [HoneycodeClientTypes.CreateRowData]?
    /// The ID of the table where the new rows are being added. If a table with the specified ID could not be found, this API throws ResourceNotFoundException.
    /// This member is required.
    public var tableId: Swift.String?
    /// The ID of the workbook where the new rows are being added. If a workbook with the specified ID could not be found, this API throws ResourceNotFoundException.
    /// This member is required.
    public var workbookId: Swift.String?

    public init(
        clientRequestToken: Swift.String? = nil,
        rowsToCreate: [HoneycodeClientTypes.CreateRowData]? = nil,
        tableId: Swift.String? = nil,
        workbookId: Swift.String? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.rowsToCreate = rowsToCreate
        self.tableId = tableId
        self.workbookId = workbookId
    }
}

struct BatchCreateTableRowsInputBody: Swift.Equatable {
    let rowsToCreate: [HoneycodeClientTypes.CreateRowData]?
    let clientRequestToken: Swift.String?
}

extension BatchCreateTableRowsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken
        case rowsToCreate
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let rowsToCreateContainer = try containerValues.decodeIfPresent([HoneycodeClientTypes.CreateRowData?].self, forKey: .rowsToCreate)
        var rowsToCreateDecoded0:[HoneycodeClientTypes.CreateRowData]? = nil
        if let rowsToCreateContainer = rowsToCreateContainer {
            rowsToCreateDecoded0 = [HoneycodeClientTypes.CreateRowData]()
            for structure0 in rowsToCreateContainer {
                if let structure0 = structure0 {
                    rowsToCreateDecoded0?.append(structure0)
                }
            }
        }
        rowsToCreate = rowsToCreateDecoded0
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
    }
}

extension BatchCreateTableRowsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: BatchCreateTableRowsOutputBody = try responseDecoder.decode(responseBody: data)
            self.createdRows = output.createdRows
            self.failedBatchItems = output.failedBatchItems
            self.workbookCursor = output.workbookCursor
        } else {
            self.createdRows = nil
            self.failedBatchItems = nil
            self.workbookCursor = 0
        }
    }
}

public struct BatchCreateTableRowsOutput: Swift.Equatable {
    /// The map of batch item id to the row id that was created for that item.
    /// This member is required.
    public var createdRows: [Swift.String:Swift.String]?
    /// The list of batch items in the request that could not be added to the table. Each element in this list contains one item from the request that could not be added to the table along with the reason why that item could not be added.
    public var failedBatchItems: [HoneycodeClientTypes.FailedBatchItem]?
    /// The updated workbook cursor after adding the new rows at the end of the table.
    /// This member is required.
    public var workbookCursor: Swift.Int

    public init(
        createdRows: [Swift.String:Swift.String]? = nil,
        failedBatchItems: [HoneycodeClientTypes.FailedBatchItem]? = nil,
        workbookCursor: Swift.Int = 0
    )
    {
        self.createdRows = createdRows
        self.failedBatchItems = failedBatchItems
        self.workbookCursor = workbookCursor
    }
}

struct BatchCreateTableRowsOutputBody: Swift.Equatable {
    let workbookCursor: Swift.Int
    let createdRows: [Swift.String:Swift.String]?
    let failedBatchItems: [HoneycodeClientTypes.FailedBatchItem]?
}

extension BatchCreateTableRowsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdRows
        case failedBatchItems
        case workbookCursor
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workbookCursorDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .workbookCursor) ?? 0
        workbookCursor = workbookCursorDecoded
        let createdRowsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .createdRows)
        var createdRowsDecoded0: [Swift.String:Swift.String]? = nil
        if let createdRowsContainer = createdRowsContainer {
            createdRowsDecoded0 = [Swift.String:Swift.String]()
            for (key0, rowid0) in createdRowsContainer {
                if let rowid0 = rowid0 {
                    createdRowsDecoded0?[key0] = rowid0
                }
            }
        }
        createdRows = createdRowsDecoded0
        let failedBatchItemsContainer = try containerValues.decodeIfPresent([HoneycodeClientTypes.FailedBatchItem?].self, forKey: .failedBatchItems)
        var failedBatchItemsDecoded0:[HoneycodeClientTypes.FailedBatchItem]? = nil
        if let failedBatchItemsContainer = failedBatchItemsContainer {
            failedBatchItemsDecoded0 = [HoneycodeClientTypes.FailedBatchItem]()
            for structure0 in failedBatchItemsContainer {
                if let structure0 = structure0 {
                    failedBatchItemsDecoded0?.append(structure0)
                }
            }
        }
        failedBatchItems = failedBatchItemsDecoded0
    }
}

enum BatchCreateTableRowsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RequestTimeoutException": return try await RequestTimeoutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension BatchDeleteTableRowsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken
        case rowIds
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = self.clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let rowIds = rowIds {
            var rowIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .rowIds)
            for rowid0 in rowIds {
                try rowIdsContainer.encode(rowid0)
            }
        }
    }
}

extension BatchDeleteTableRowsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let workbookId = workbookId else {
            return nil
        }
        guard let tableId = tableId else {
            return nil
        }
        return "/workbooks/\(workbookId.urlPercentEncoding())/tables/\(tableId.urlPercentEncoding())/rows/batchdelete"
    }
}

public struct BatchDeleteTableRowsInput: Swift.Equatable {
    /// The request token for performing the delete action. Request tokens help to identify duplicate requests. If a call times out or fails due to a transient error like a failed network connection, you can retry the call with the same request token. The service ensures that if the first call using that request token is successfully performed, the second call will not perform the action again. Note that request tokens are valid only for a few minutes. You cannot use request tokens to dedupe requests spanning hours or days.
    public var clientRequestToken: Swift.String?
    /// The list of row ids to delete from the table. You need to specify at least one row id in this list. Note that if one of the row ids provided in the request does not exist in the table, then the request fails and no rows are deleted from the table.
    /// This member is required.
    public var rowIds: [Swift.String]?
    /// The ID of the table where the rows are being deleted. If a table with the specified id could not be found, this API throws ResourceNotFoundException.
    /// This member is required.
    public var tableId: Swift.String?
    /// The ID of the workbook where the rows are being deleted. If a workbook with the specified id could not be found, this API throws ResourceNotFoundException.
    /// This member is required.
    public var workbookId: Swift.String?

    public init(
        clientRequestToken: Swift.String? = nil,
        rowIds: [Swift.String]? = nil,
        tableId: Swift.String? = nil,
        workbookId: Swift.String? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.rowIds = rowIds
        self.tableId = tableId
        self.workbookId = workbookId
    }
}

struct BatchDeleteTableRowsInputBody: Swift.Equatable {
    let rowIds: [Swift.String]?
    let clientRequestToken: Swift.String?
}

extension BatchDeleteTableRowsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken
        case rowIds
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let rowIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .rowIds)
        var rowIdsDecoded0:[Swift.String]? = nil
        if let rowIdsContainer = rowIdsContainer {
            rowIdsDecoded0 = [Swift.String]()
            for string0 in rowIdsContainer {
                if let string0 = string0 {
                    rowIdsDecoded0?.append(string0)
                }
            }
        }
        rowIds = rowIdsDecoded0
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
    }
}

extension BatchDeleteTableRowsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: BatchDeleteTableRowsOutputBody = try responseDecoder.decode(responseBody: data)
            self.failedBatchItems = output.failedBatchItems
            self.workbookCursor = output.workbookCursor
        } else {
            self.failedBatchItems = nil
            self.workbookCursor = 0
        }
    }
}

public struct BatchDeleteTableRowsOutput: Swift.Equatable {
    /// The list of row ids in the request that could not be deleted from the table. Each element in this list contains one row id from the request that could not be deleted along with the reason why that item could not be deleted.
    public var failedBatchItems: [HoneycodeClientTypes.FailedBatchItem]?
    /// The updated workbook cursor after deleting the rows from the table.
    /// This member is required.
    public var workbookCursor: Swift.Int

    public init(
        failedBatchItems: [HoneycodeClientTypes.FailedBatchItem]? = nil,
        workbookCursor: Swift.Int = 0
    )
    {
        self.failedBatchItems = failedBatchItems
        self.workbookCursor = workbookCursor
    }
}

struct BatchDeleteTableRowsOutputBody: Swift.Equatable {
    let workbookCursor: Swift.Int
    let failedBatchItems: [HoneycodeClientTypes.FailedBatchItem]?
}

extension BatchDeleteTableRowsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failedBatchItems
        case workbookCursor
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workbookCursorDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .workbookCursor) ?? 0
        workbookCursor = workbookCursorDecoded
        let failedBatchItemsContainer = try containerValues.decodeIfPresent([HoneycodeClientTypes.FailedBatchItem?].self, forKey: .failedBatchItems)
        var failedBatchItemsDecoded0:[HoneycodeClientTypes.FailedBatchItem]? = nil
        if let failedBatchItemsContainer = failedBatchItemsContainer {
            failedBatchItemsDecoded0 = [HoneycodeClientTypes.FailedBatchItem]()
            for structure0 in failedBatchItemsContainer {
                if let structure0 = structure0 {
                    failedBatchItemsDecoded0?.append(structure0)
                }
            }
        }
        failedBatchItems = failedBatchItemsDecoded0
    }
}

enum BatchDeleteTableRowsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RequestTimeoutException": return try await RequestTimeoutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension BatchUpdateTableRowsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken
        case rowsToUpdate
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = self.clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let rowsToUpdate = rowsToUpdate {
            var rowsToUpdateContainer = encodeContainer.nestedUnkeyedContainer(forKey: .rowsToUpdate)
            for updaterowdata0 in rowsToUpdate {
                try rowsToUpdateContainer.encode(updaterowdata0)
            }
        }
    }
}

extension BatchUpdateTableRowsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let workbookId = workbookId else {
            return nil
        }
        guard let tableId = tableId else {
            return nil
        }
        return "/workbooks/\(workbookId.urlPercentEncoding())/tables/\(tableId.urlPercentEncoding())/rows/batchupdate"
    }
}

public struct BatchUpdateTableRowsInput: Swift.Equatable {
    /// The request token for performing the update action. Request tokens help to identify duplicate requests. If a call times out or fails due to a transient error like a failed network connection, you can retry the call with the same request token. The service ensures that if the first call using that request token is successfully performed, the second call will not perform the action again. Note that request tokens are valid only for a few minutes. You cannot use request tokens to dedupe requests spanning hours or days.
    public var clientRequestToken: Swift.String?
    /// The list of rows to update in the table. Each item in this list needs to contain the row id to update along with the map of column id to cell values for each column in that row that needs to be updated. You need to specify at least one row in this list, and for each row, you need to specify at least one column to update. Note that if one of the row or column ids in the request does not exist in the table, then the request fails and no updates are made to the table.
    /// This member is required.
    public var rowsToUpdate: [HoneycodeClientTypes.UpdateRowData]?
    /// The ID of the table where the rows are being updated. If a table with the specified id could not be found, this API throws ResourceNotFoundException.
    /// This member is required.
    public var tableId: Swift.String?
    /// The ID of the workbook where the rows are being updated. If a workbook with the specified id could not be found, this API throws ResourceNotFoundException.
    /// This member is required.
    public var workbookId: Swift.String?

    public init(
        clientRequestToken: Swift.String? = nil,
        rowsToUpdate: [HoneycodeClientTypes.UpdateRowData]? = nil,
        tableId: Swift.String? = nil,
        workbookId: Swift.String? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.rowsToUpdate = rowsToUpdate
        self.tableId = tableId
        self.workbookId = workbookId
    }
}

struct BatchUpdateTableRowsInputBody: Swift.Equatable {
    let rowsToUpdate: [HoneycodeClientTypes.UpdateRowData]?
    let clientRequestToken: Swift.String?
}

extension BatchUpdateTableRowsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken
        case rowsToUpdate
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let rowsToUpdateContainer = try containerValues.decodeIfPresent([HoneycodeClientTypes.UpdateRowData?].self, forKey: .rowsToUpdate)
        var rowsToUpdateDecoded0:[HoneycodeClientTypes.UpdateRowData]? = nil
        if let rowsToUpdateContainer = rowsToUpdateContainer {
            rowsToUpdateDecoded0 = [HoneycodeClientTypes.UpdateRowData]()
            for structure0 in rowsToUpdateContainer {
                if let structure0 = structure0 {
                    rowsToUpdateDecoded0?.append(structure0)
                }
            }
        }
        rowsToUpdate = rowsToUpdateDecoded0
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
    }
}

extension BatchUpdateTableRowsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: BatchUpdateTableRowsOutputBody = try responseDecoder.decode(responseBody: data)
            self.failedBatchItems = output.failedBatchItems
            self.workbookCursor = output.workbookCursor
        } else {
            self.failedBatchItems = nil
            self.workbookCursor = 0
        }
    }
}

public struct BatchUpdateTableRowsOutput: Swift.Equatable {
    /// The list of batch items in the request that could not be updated in the table. Each element in this list contains one item from the request that could not be updated in the table along with the reason why that item could not be updated.
    public var failedBatchItems: [HoneycodeClientTypes.FailedBatchItem]?
    /// The updated workbook cursor after adding the new rows at the end of the table.
    /// This member is required.
    public var workbookCursor: Swift.Int

    public init(
        failedBatchItems: [HoneycodeClientTypes.FailedBatchItem]? = nil,
        workbookCursor: Swift.Int = 0
    )
    {
        self.failedBatchItems = failedBatchItems
        self.workbookCursor = workbookCursor
    }
}

struct BatchUpdateTableRowsOutputBody: Swift.Equatable {
    let workbookCursor: Swift.Int
    let failedBatchItems: [HoneycodeClientTypes.FailedBatchItem]?
}

extension BatchUpdateTableRowsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failedBatchItems
        case workbookCursor
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workbookCursorDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .workbookCursor) ?? 0
        workbookCursor = workbookCursorDecoded
        let failedBatchItemsContainer = try containerValues.decodeIfPresent([HoneycodeClientTypes.FailedBatchItem?].self, forKey: .failedBatchItems)
        var failedBatchItemsDecoded0:[HoneycodeClientTypes.FailedBatchItem]? = nil
        if let failedBatchItemsContainer = failedBatchItemsContainer {
            failedBatchItemsDecoded0 = [HoneycodeClientTypes.FailedBatchItem]()
            for structure0 in failedBatchItemsContainer {
                if let structure0 = structure0 {
                    failedBatchItemsDecoded0?.append(structure0)
                }
            }
        }
        failedBatchItems = failedBatchItemsDecoded0
    }
}

enum BatchUpdateTableRowsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RequestTimeoutException": return try await RequestTimeoutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension BatchUpsertTableRowsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken
        case rowsToUpsert
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = self.clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let rowsToUpsert = rowsToUpsert {
            var rowsToUpsertContainer = encodeContainer.nestedUnkeyedContainer(forKey: .rowsToUpsert)
            for upsertrowdata0 in rowsToUpsert {
                try rowsToUpsertContainer.encode(upsertrowdata0)
            }
        }
    }
}

extension BatchUpsertTableRowsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let workbookId = workbookId else {
            return nil
        }
        guard let tableId = tableId else {
            return nil
        }
        return "/workbooks/\(workbookId.urlPercentEncoding())/tables/\(tableId.urlPercentEncoding())/rows/batchupsert"
    }
}

public struct BatchUpsertTableRowsInput: Swift.Equatable {
    /// The request token for performing the update action. Request tokens help to identify duplicate requests. If a call times out or fails due to a transient error like a failed network connection, you can retry the call with the same request token. The service ensures that if the first call using that request token is successfully performed, the second call will not perform the action again. Note that request tokens are valid only for a few minutes. You cannot use request tokens to dedupe requests spanning hours or days.
    public var clientRequestToken: Swift.String?
    /// The list of rows to upsert in the table. Each item in this list needs to have a batch item id to uniquely identify the element in the request, a filter expression to find the rows to update for that element and the cell values to set for each column in the upserted rows. You need to specify at least one item in this list. Note that if one of the filter formulas in the request fails to evaluate because of an error or one of the column ids in any of the rows does not exist in the table, then the request fails and no updates are made to the table.
    /// This member is required.
    public var rowsToUpsert: [HoneycodeClientTypes.UpsertRowData]?
    /// The ID of the table where the rows are being upserted. If a table with the specified id could not be found, this API throws ResourceNotFoundException.
    /// This member is required.
    public var tableId: Swift.String?
    /// The ID of the workbook where the rows are being upserted. If a workbook with the specified id could not be found, this API throws ResourceNotFoundException.
    /// This member is required.
    public var workbookId: Swift.String?

    public init(
        clientRequestToken: Swift.String? = nil,
        rowsToUpsert: [HoneycodeClientTypes.UpsertRowData]? = nil,
        tableId: Swift.String? = nil,
        workbookId: Swift.String? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.rowsToUpsert = rowsToUpsert
        self.tableId = tableId
        self.workbookId = workbookId
    }
}

struct BatchUpsertTableRowsInputBody: Swift.Equatable {
    let rowsToUpsert: [HoneycodeClientTypes.UpsertRowData]?
    let clientRequestToken: Swift.String?
}

extension BatchUpsertTableRowsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken
        case rowsToUpsert
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let rowsToUpsertContainer = try containerValues.decodeIfPresent([HoneycodeClientTypes.UpsertRowData?].self, forKey: .rowsToUpsert)
        var rowsToUpsertDecoded0:[HoneycodeClientTypes.UpsertRowData]? = nil
        if let rowsToUpsertContainer = rowsToUpsertContainer {
            rowsToUpsertDecoded0 = [HoneycodeClientTypes.UpsertRowData]()
            for structure0 in rowsToUpsertContainer {
                if let structure0 = structure0 {
                    rowsToUpsertDecoded0?.append(structure0)
                }
            }
        }
        rowsToUpsert = rowsToUpsertDecoded0
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
    }
}

extension BatchUpsertTableRowsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: BatchUpsertTableRowsOutputBody = try responseDecoder.decode(responseBody: data)
            self.failedBatchItems = output.failedBatchItems
            self.rows = output.rows
            self.workbookCursor = output.workbookCursor
        } else {
            self.failedBatchItems = nil
            self.rows = nil
            self.workbookCursor = 0
        }
    }
}

public struct BatchUpsertTableRowsOutput: Swift.Equatable {
    /// The list of batch items in the request that could not be updated or appended in the table. Each element in this list contains one item from the request that could not be updated in the table along with the reason why that item could not be updated or appended.
    public var failedBatchItems: [HoneycodeClientTypes.FailedBatchItem]?
    /// A map with the batch item id as the key and the result of the upsert operation as the value. The result of the upsert operation specifies whether existing rows were updated or a new row was appended, along with the list of row ids that were affected.
    /// This member is required.
    public var rows: [Swift.String:HoneycodeClientTypes.UpsertRowsResult]?
    /// The updated workbook cursor after updating or appending rows in the table.
    /// This member is required.
    public var workbookCursor: Swift.Int

    public init(
        failedBatchItems: [HoneycodeClientTypes.FailedBatchItem]? = nil,
        rows: [Swift.String:HoneycodeClientTypes.UpsertRowsResult]? = nil,
        workbookCursor: Swift.Int = 0
    )
    {
        self.failedBatchItems = failedBatchItems
        self.rows = rows
        self.workbookCursor = workbookCursor
    }
}

struct BatchUpsertTableRowsOutputBody: Swift.Equatable {
    let rows: [Swift.String:HoneycodeClientTypes.UpsertRowsResult]?
    let workbookCursor: Swift.Int
    let failedBatchItems: [HoneycodeClientTypes.FailedBatchItem]?
}

extension BatchUpsertTableRowsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failedBatchItems
        case rows
        case workbookCursor
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let rowsContainer = try containerValues.decodeIfPresent([Swift.String: HoneycodeClientTypes.UpsertRowsResult?].self, forKey: .rows)
        var rowsDecoded0: [Swift.String:HoneycodeClientTypes.UpsertRowsResult]? = nil
        if let rowsContainer = rowsContainer {
            rowsDecoded0 = [Swift.String:HoneycodeClientTypes.UpsertRowsResult]()
            for (key0, upsertrowsresult0) in rowsContainer {
                if let upsertrowsresult0 = upsertrowsresult0 {
                    rowsDecoded0?[key0] = upsertrowsresult0
                }
            }
        }
        rows = rowsDecoded0
        let workbookCursorDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .workbookCursor) ?? 0
        workbookCursor = workbookCursorDecoded
        let failedBatchItemsContainer = try containerValues.decodeIfPresent([HoneycodeClientTypes.FailedBatchItem?].self, forKey: .failedBatchItems)
        var failedBatchItemsDecoded0:[HoneycodeClientTypes.FailedBatchItem]? = nil
        if let failedBatchItemsContainer = failedBatchItemsContainer {
            failedBatchItemsDecoded0 = [HoneycodeClientTypes.FailedBatchItem]()
            for structure0 in failedBatchItemsContainer {
                if let structure0 = structure0 {
                    failedBatchItemsDecoded0?.append(structure0)
                }
            }
        }
        failedBatchItems = failedBatchItemsDecoded0
    }
}

enum BatchUpsertTableRowsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RequestTimeoutException": return try await RequestTimeoutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension HoneycodeClientTypes.Cell: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case format
        case formattedValue
        case formattedValues
        case formula
        case rawValue
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let format = self.format {
            try encodeContainer.encode(format.rawValue, forKey: .format)
        }
        if let formattedValue = self.formattedValue {
            try encodeContainer.encode(formattedValue, forKey: .formattedValue)
        }
        if let formattedValues = formattedValues {
            var formattedValuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .formattedValues)
            for formattedvalue0 in formattedValues {
                try formattedValuesContainer.encode(formattedvalue0)
            }
        }
        if let formula = self.formula {
            try encodeContainer.encode(formula, forKey: .formula)
        }
        if let rawValue = self.rawValue {
            try encodeContainer.encode(rawValue, forKey: .rawValue)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let formulaDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .formula)
        formula = formulaDecoded
        let formatDecoded = try containerValues.decodeIfPresent(HoneycodeClientTypes.Format.self, forKey: .format)
        format = formatDecoded
        let rawValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .rawValue)
        rawValue = rawValueDecoded
        let formattedValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .formattedValue)
        formattedValue = formattedValueDecoded
        let formattedValuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .formattedValues)
        var formattedValuesDecoded0:[Swift.String]? = nil
        if let formattedValuesContainer = formattedValuesContainer {
            formattedValuesDecoded0 = [Swift.String]()
            for string0 in formattedValuesContainer {
                if let string0 = string0 {
                    formattedValuesDecoded0?.append(string0)
                }
            }
        }
        formattedValues = formattedValuesDecoded0
    }
}

extension HoneycodeClientTypes.Cell: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension HoneycodeClientTypes {
    /// An object that represents a single cell in a table.
    public struct Cell: Swift.Equatable {
        /// The format of the cell. If this field is empty, then the format is either not specified in the workbook or the format is set to AUTO.
        public var format: HoneycodeClientTypes.Format?
        /// The formatted value of the cell. This is the value that you see displayed in the cell in the UI. Note that the formatted value of a cell is always represented as a string irrespective of the data that is stored in the cell. For example, if a cell contains a date, the formatted value of the cell is the string representation of the formatted date being shown in the cell in the UI. See details in the rawValue field below for how cells of different formats will have different raw and formatted values.
        public var formattedValue: Swift.String?
        /// A list of formatted values of the cell. This field is only returned when the cell is ROWSET format (aka multi-select or multi-record picklist). Values in the list are always represented as strings. The formattedValue field will be empty if this field is returned.
        public var formattedValues: [Swift.String]?
        /// The formula contained in the cell. This field is empty if a cell does not have a formula.
        public var formula: Swift.String?
        /// The raw value of the data contained in the cell. The raw value depends on the format of the data in the cell. However the attribute in the API return value is always a string containing the raw value. Cells with format DATE, DATE_TIME or TIME have the raw value as a floating point number where the whole number represents the number of days since 1/1/1900 and the fractional part represents the fraction of the day since midnight. For example, a cell with date 11/3/2020 has the raw value "44138". A cell with the time 9:00 AM has the raw value "0.375" and a cell with date/time value of 11/3/2020 9:00 AM has the raw value "44138.375". Notice that even though the raw value is a number in all three cases, it is still represented as a string. Cells with format NUMBER, CURRENCY, PERCENTAGE and ACCOUNTING have the raw value of the data as the number representing the data being displayed. For example, the number 1.325 with two decimal places in the format will have it's raw value as "1.325" and formatted value as "1.33". A currency value for $10 will have the raw value as "10" and formatted value as "$10.00". A value representing 20% with two decimal places in the format will have its raw value as "0.2" and the formatted value as "20.00%". An accounting value of -$25 will have "-25" as the raw value and "$ (25.00)" as the formatted value. Cells with format TEXT will have the raw text as the raw value. For example, a cell with text "John Smith" will have "John Smith" as both the raw value and the formatted value. Cells with format CONTACT will have the name of the contact as a formatted value and the email address of the contact as the raw value. For example, a contact for John Smith will have "John Smith" as the formatted value and "john.smith@example.com" as the raw value. Cells with format ROWLINK (aka picklist) will have the first column of the linked row as the formatted value and the row id of the linked row as the raw value. For example, a cell containing a picklist to a table that displays task status might have "Completed" as the formatted value and "row:dfcefaee-5b37-4355-8f28-40c3e4ff5dd4/ca432b2f-b8eb-431d-9fb5-cbe0342f9f03" as the raw value. Cells with format ROWSET (aka multi-select or multi-record picklist) will by default have the first column of each of the linked rows as the formatted value in the list, and the rowset id of the linked rows as the raw value. For example, a cell containing a multi-select picklist to a table that contains items might have "Item A", "Item B" in the formatted value list and "rows:b742c1f4-6cb0-4650-a845-35eb86fcc2bb/ [fdea123b-8f68-474a-aa8a-5ff87aa333af,6daf41f0-a138-4eee-89da-123086d36ecf]" as the raw value. Cells with format ATTACHMENT will have the name of the attachment as the formatted value and the attachment id as the raw value. For example, a cell containing an attachment named "image.jpeg" will have "image.jpeg" as the formatted value and "attachment:ca432b2f-b8eb-431d-9fb5-cbe0342f9f03" as the raw value. Cells with format AUTO or cells without any format that are auto-detected as one of the formats above will contain the raw and formatted values as mentioned above, based on the auto-detected formats. If there is no auto-detected format, the raw and formatted values will be the same as the data in the cell.
        public var rawValue: Swift.String?

        public init(
            format: HoneycodeClientTypes.Format? = nil,
            formattedValue: Swift.String? = nil,
            formattedValues: [Swift.String]? = nil,
            formula: Swift.String? = nil,
            rawValue: Swift.String? = nil
        )
        {
            self.format = format
            self.formattedValue = formattedValue
            self.formattedValues = formattedValues
            self.formula = formula
            self.rawValue = rawValue
        }
    }

}

extension HoneycodeClientTypes.CellInput: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fact
        case facts
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fact = self.fact {
            try encodeContainer.encode(fact, forKey: .fact)
        }
        if let facts = facts {
            var factsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .facts)
            for fact0 in facts {
                try factsContainer.encode(fact0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let factDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fact)
        fact = factDecoded
        let factsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .facts)
        var factsDecoded0:[Swift.String]? = nil
        if let factsContainer = factsContainer {
            factsDecoded0 = [Swift.String]()
            for string0 in factsContainer {
                if let string0 = string0 {
                    factsDecoded0?.append(string0)
                }
            }
        }
        facts = factsDecoded0
    }
}

extension HoneycodeClientTypes.CellInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CellInput(facts: \(Swift.String(describing: facts)), fact: \"CONTENT_REDACTED\")"}
}

extension HoneycodeClientTypes {
    /// CellInput object contains the data needed to create or update cells in a table. CellInput object has only a facts field or a fact field, but not both. A 400 bad request will be thrown if both fact and facts field are present.
    public struct CellInput: Swift.Equatable {
        /// Fact represents the data that is entered into a cell. This data can be free text or a formula. Formulas need to start with the equals (=) sign.
        public var fact: Swift.String?
        /// A list representing the values that are entered into a ROWSET cell. Facts list can have either only values or rowIDs, and rowIDs should from the same table.
        public var facts: [Swift.String]?

        public init(
            fact: Swift.String? = nil,
            facts: [Swift.String]? = nil
        )
        {
            self.fact = fact
            self.facts = facts
        }
    }

}

extension HoneycodeClientTypes.ColumnMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case format
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let format = self.format {
            try encodeContainer.encode(format.rawValue, forKey: .format)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let formatDecoded = try containerValues.decodeIfPresent(HoneycodeClientTypes.Format.self, forKey: .format)
        format = formatDecoded
    }
}

extension HoneycodeClientTypes.ColumnMetadata: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ColumnMetadata(format: \(Swift.String(describing: format)), name: \"CONTENT_REDACTED\")"}
}

extension HoneycodeClientTypes {
    /// Metadata for column in the table.
    public struct ColumnMetadata: Swift.Equatable {
        /// The format of the column.
        /// This member is required.
        public var format: HoneycodeClientTypes.Format?
        /// The name of the column.
        /// This member is required.
        public var name: Swift.String?

        public init(
            format: HoneycodeClientTypes.Format? = nil,
            name: Swift.String? = nil
        )
        {
            self.format = format
            self.name = name
        }
    }

}

extension HoneycodeClientTypes.CreateRowData: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case batchItemId
        case cellsToCreate
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let batchItemId = self.batchItemId {
            try encodeContainer.encode(batchItemId, forKey: .batchItemId)
        }
        if let cellsToCreate = cellsToCreate {
            var cellsToCreateContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .cellsToCreate)
            for (dictKey0, rowDataInput0) in cellsToCreate {
                try cellsToCreateContainer.encode(rowDataInput0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let batchItemIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .batchItemId)
        batchItemId = batchItemIdDecoded
        let cellsToCreateContainer = try containerValues.decodeIfPresent([Swift.String: HoneycodeClientTypes.CellInput?].self, forKey: .cellsToCreate)
        var cellsToCreateDecoded0: [Swift.String:HoneycodeClientTypes.CellInput]? = nil
        if let cellsToCreateContainer = cellsToCreateContainer {
            cellsToCreateDecoded0 = [Swift.String:HoneycodeClientTypes.CellInput]()
            for (key0, cellinput0) in cellsToCreateContainer {
                if let cellinput0 = cellinput0 {
                    cellsToCreateDecoded0?[key0] = cellinput0
                }
            }
        }
        cellsToCreate = cellsToCreateDecoded0
    }
}

extension HoneycodeClientTypes {
    /// Data needed to create a single row in a table as part of the BatchCreateTableRows request.
    public struct CreateRowData: Swift.Equatable {
        /// An external identifier that represents the single row that is being created as part of the BatchCreateTableRows request. This can be any string that you can use to identify the row in the request. The BatchCreateTableRows API puts the batch item id in the results to allow you to link data in the request to data in the results.
        /// This member is required.
        public var batchItemId: Swift.String?
        /// A map representing the cells to create in the new row. The key is the column id of the cell and the value is the CellInput object that represents the data to set in that cell.
        /// This member is required.
        public var cellsToCreate: [Swift.String:HoneycodeClientTypes.CellInput]?

        public init(
            batchItemId: Swift.String? = nil,
            cellsToCreate: [Swift.String:HoneycodeClientTypes.CellInput]? = nil
        )
        {
            self.batchItemId = batchItemId
            self.cellsToCreate = cellsToCreate
        }
    }

}

extension HoneycodeClientTypes.DataItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case formattedValue
        case overrideFormat
        case rawValue
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let formattedValue = self.formattedValue {
            try encodeContainer.encode(formattedValue, forKey: .formattedValue)
        }
        if let overrideFormat = self.overrideFormat {
            try encodeContainer.encode(overrideFormat.rawValue, forKey: .overrideFormat)
        }
        if let rawValue = self.rawValue {
            try encodeContainer.encode(rawValue, forKey: .rawValue)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let overrideFormatDecoded = try containerValues.decodeIfPresent(HoneycodeClientTypes.Format.self, forKey: .overrideFormat)
        overrideFormat = overrideFormatDecoded
        let rawValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .rawValue)
        rawValue = rawValueDecoded
        let formattedValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .formattedValue)
        formattedValue = formattedValueDecoded
    }
}

extension HoneycodeClientTypes.DataItem: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension HoneycodeClientTypes {
    /// The data in a particular data cell defined on the screen.
    public struct DataItem: Swift.Equatable {
        /// The formatted value of the data. e.g. John Smith.
        public var formattedValue: Swift.String?
        /// The overrideFormat is optional and is specified only if a particular row of data has a different format for the data than the default format defined on the screen or the table.
        public var overrideFormat: HoneycodeClientTypes.Format?
        /// The raw value of the data. e.g. jsmith@example.com
        public var rawValue: Swift.String?

        public init(
            formattedValue: Swift.String? = nil,
            overrideFormat: HoneycodeClientTypes.Format? = nil,
            rawValue: Swift.String? = nil
        )
        {
            self.formattedValue = formattedValue
            self.overrideFormat = overrideFormat
            self.rawValue = rawValue
        }
    }

}

extension HoneycodeClientTypes.DelimitedTextImportOptions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataCharacterEncoding
        case delimiter
        case hasHeaderRow
        case ignoreEmptyRows
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataCharacterEncoding = self.dataCharacterEncoding {
            try encodeContainer.encode(dataCharacterEncoding.rawValue, forKey: .dataCharacterEncoding)
        }
        if let delimiter = self.delimiter {
            try encodeContainer.encode(delimiter, forKey: .delimiter)
        }
        if hasHeaderRow != false {
            try encodeContainer.encode(hasHeaderRow, forKey: .hasHeaderRow)
        }
        if ignoreEmptyRows != false {
            try encodeContainer.encode(ignoreEmptyRows, forKey: .ignoreEmptyRows)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let delimiterDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .delimiter)
        delimiter = delimiterDecoded
        let hasHeaderRowDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .hasHeaderRow) ?? false
        hasHeaderRow = hasHeaderRowDecoded
        let ignoreEmptyRowsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .ignoreEmptyRows) ?? false
        ignoreEmptyRows = ignoreEmptyRowsDecoded
        let dataCharacterEncodingDecoded = try containerValues.decodeIfPresent(HoneycodeClientTypes.ImportDataCharacterEncoding.self, forKey: .dataCharacterEncoding)
        dataCharacterEncoding = dataCharacterEncodingDecoded
    }
}

extension HoneycodeClientTypes {
    /// An object that contains the options relating to parsing delimited text as part of an import request.
    public struct DelimitedTextImportOptions: Swift.Equatable {
        /// The encoding of the data in the input file.
        public var dataCharacterEncoding: HoneycodeClientTypes.ImportDataCharacterEncoding?
        /// The delimiter to use for separating columns in a single row of the input.
        /// This member is required.
        public var delimiter: Swift.String?
        /// Indicates whether the input file has a header row at the top containing the column names.
        public var hasHeaderRow: Swift.Bool
        /// A parameter to indicate whether empty rows should be ignored or be included in the import.
        public var ignoreEmptyRows: Swift.Bool

        public init(
            dataCharacterEncoding: HoneycodeClientTypes.ImportDataCharacterEncoding? = nil,
            delimiter: Swift.String? = nil,
            hasHeaderRow: Swift.Bool = false,
            ignoreEmptyRows: Swift.Bool = false
        )
        {
            self.dataCharacterEncoding = dataCharacterEncoding
            self.delimiter = delimiter
            self.hasHeaderRow = hasHeaderRow
            self.ignoreEmptyRows = ignoreEmptyRows
        }
    }

}

extension DescribeTableDataImportJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let workbookId = workbookId else {
            return nil
        }
        guard let tableId = tableId else {
            return nil
        }
        guard let jobId = jobId else {
            return nil
        }
        return "/workbooks/\(workbookId.urlPercentEncoding())/tables/\(tableId.urlPercentEncoding())/import/\(jobId.urlPercentEncoding())"
    }
}

public struct DescribeTableDataImportJobInput: Swift.Equatable {
    /// The ID of the job that was returned by the StartTableDataImportJob request. If a job with the specified id could not be found, this API throws ResourceNotFoundException.
    /// This member is required.
    public var jobId: Swift.String?
    /// The ID of the table into which data was imported. If a table with the specified id could not be found, this API throws ResourceNotFoundException.
    /// This member is required.
    public var tableId: Swift.String?
    /// The ID of the workbook into which data was imported. If a workbook with the specified id could not be found, this API throws ResourceNotFoundException.
    /// This member is required.
    public var workbookId: Swift.String?

    public init(
        jobId: Swift.String? = nil,
        tableId: Swift.String? = nil,
        workbookId: Swift.String? = nil
    )
    {
        self.jobId = jobId
        self.tableId = tableId
        self.workbookId = workbookId
    }
}

struct DescribeTableDataImportJobInputBody: Swift.Equatable {
}

extension DescribeTableDataImportJobInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeTableDataImportJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeTableDataImportJobOutputBody = try responseDecoder.decode(responseBody: data)
            self.errorCode = output.errorCode
            self.jobMetadata = output.jobMetadata
            self.jobStatus = output.jobStatus
            self.message = output.message
        } else {
            self.errorCode = nil
            self.jobMetadata = nil
            self.jobStatus = nil
            self.message = nil
        }
    }
}

public struct DescribeTableDataImportJobOutput: Swift.Equatable {
    /// If job status is failed, error code to understand reason for the failure.
    public var errorCode: HoneycodeClientTypes.ErrorCode?
    /// The metadata about the job that was submitted for import.
    /// This member is required.
    public var jobMetadata: HoneycodeClientTypes.TableDataImportJobMetadata?
    /// The current status of the import job.
    /// This member is required.
    public var jobStatus: HoneycodeClientTypes.TableDataImportJobStatus?
    /// A message providing more details about the current status of the import job.
    /// This member is required.
    public var message: Swift.String?

    public init(
        errorCode: HoneycodeClientTypes.ErrorCode? = nil,
        jobMetadata: HoneycodeClientTypes.TableDataImportJobMetadata? = nil,
        jobStatus: HoneycodeClientTypes.TableDataImportJobStatus? = nil,
        message: Swift.String? = nil
    )
    {
        self.errorCode = errorCode
        self.jobMetadata = jobMetadata
        self.jobStatus = jobStatus
        self.message = message
    }
}

struct DescribeTableDataImportJobOutputBody: Swift.Equatable {
    let jobStatus: HoneycodeClientTypes.TableDataImportJobStatus?
    let message: Swift.String?
    let jobMetadata: HoneycodeClientTypes.TableDataImportJobMetadata?
    let errorCode: HoneycodeClientTypes.ErrorCode?
}

extension DescribeTableDataImportJobOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode
        case jobMetadata
        case jobStatus
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobStatusDecoded = try containerValues.decodeIfPresent(HoneycodeClientTypes.TableDataImportJobStatus.self, forKey: .jobStatus)
        jobStatus = jobStatusDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let jobMetadataDecoded = try containerValues.decodeIfPresent(HoneycodeClientTypes.TableDataImportJobMetadata.self, forKey: .jobMetadata)
        jobMetadata = jobMetadataDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(HoneycodeClientTypes.ErrorCode.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
    }
}

enum DescribeTableDataImportJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RequestTimeoutException": return try await RequestTimeoutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension HoneycodeClientTypes.DestinationOptions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case columnMap
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let columnMap = columnMap {
            var columnMapContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .columnMap)
            for (dictKey0, importColumnMap0) in columnMap {
                try columnMapContainer.encode(importColumnMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let columnMapContainer = try containerValues.decodeIfPresent([Swift.String: HoneycodeClientTypes.SourceDataColumnProperties?].self, forKey: .columnMap)
        var columnMapDecoded0: [Swift.String:HoneycodeClientTypes.SourceDataColumnProperties]? = nil
        if let columnMapContainer = columnMapContainer {
            columnMapDecoded0 = [Swift.String:HoneycodeClientTypes.SourceDataColumnProperties]()
            for (key0, sourcedatacolumnproperties0) in columnMapContainer {
                if let sourcedatacolumnproperties0 = sourcedatacolumnproperties0 {
                    columnMapDecoded0?[key0] = sourcedatacolumnproperties0
                }
            }
        }
        columnMap = columnMapDecoded0
    }
}

extension HoneycodeClientTypes {
    /// An object that contains the options relating to the destination of the import request.
    public struct DestinationOptions: Swift.Equatable {
        /// A map of the column id to the import properties for each column.
        public var columnMap: [Swift.String:HoneycodeClientTypes.SourceDataColumnProperties]?

        public init(
            columnMap: [Swift.String:HoneycodeClientTypes.SourceDataColumnProperties]? = nil
        )
        {
            self.columnMap = columnMap
        }
    }

}

extension HoneycodeClientTypes {
    public enum ErrorCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case accessdenied
        case fileemptyerror
        case filenotfounderror
        case fileparsingerror
        case filesizelimiterror
        case invalidfiletypeerror
        case invalidimportoptionserror
        case invalidtablecolumniderror
        case invalidtableiderror
        case invalidurlerror
        case resourcenotfounderror
        case systemlimiterror
        case tablenotfounderror
        case unknownerror
        case sdkUnknown(Swift.String)

        public static var allCases: [ErrorCode] {
            return [
                .accessdenied,
                .fileemptyerror,
                .filenotfounderror,
                .fileparsingerror,
                .filesizelimiterror,
                .invalidfiletypeerror,
                .invalidimportoptionserror,
                .invalidtablecolumniderror,
                .invalidtableiderror,
                .invalidurlerror,
                .resourcenotfounderror,
                .systemlimiterror,
                .tablenotfounderror,
                .unknownerror,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .accessdenied: return "ACCESS_DENIED"
            case .fileemptyerror: return "FILE_EMPTY_ERROR"
            case .filenotfounderror: return "FILE_NOT_FOUND_ERROR"
            case .fileparsingerror: return "FILE_PARSING_ERROR"
            case .filesizelimiterror: return "FILE_SIZE_LIMIT_ERROR"
            case .invalidfiletypeerror: return "INVALID_FILE_TYPE_ERROR"
            case .invalidimportoptionserror: return "INVALID_IMPORT_OPTIONS_ERROR"
            case .invalidtablecolumniderror: return "INVALID_TABLE_COLUMN_ID_ERROR"
            case .invalidtableiderror: return "INVALID_TABLE_ID_ERROR"
            case .invalidurlerror: return "INVALID_URL_ERROR"
            case .resourcenotfounderror: return "RESOURCE_NOT_FOUND_ERROR"
            case .systemlimiterror: return "SYSTEM_LIMIT_ERROR"
            case .tablenotfounderror: return "TABLE_NOT_FOUND_ERROR"
            case .unknownerror: return "UNKNOWN_ERROR"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ErrorCode(rawValue: rawValue) ?? ErrorCode.sdkUnknown(rawValue)
        }
    }
}

extension HoneycodeClientTypes.FailedBatchItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorMessage
        case id
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorMessage = self.errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension HoneycodeClientTypes {
    /// A single item in a batch that failed to perform the intended action because of an error preventing it from succeeding.
    public struct FailedBatchItem: Swift.Equatable {
        /// The error message that indicates why the batch item failed.
        /// This member is required.
        public var errorMessage: Swift.String?
        /// The id of the batch item that failed. This is the batch item id for the BatchCreateTableRows and BatchUpsertTableRows operations and the row id for the BatchUpdateTableRows and BatchDeleteTableRows operations.
        /// This member is required.
        public var id: Swift.String?

        public init(
            errorMessage: Swift.String? = nil,
            id: Swift.String? = nil
        )
        {
            self.errorMessage = errorMessage
            self.id = id
        }
    }

}

extension HoneycodeClientTypes.Filter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contextRowId
        case formula
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contextRowId = self.contextRowId {
            try encodeContainer.encode(contextRowId, forKey: .contextRowId)
        }
        if let formula = self.formula {
            try encodeContainer.encode(formula, forKey: .formula)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let formulaDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .formula)
        formula = formulaDecoded
        let contextRowIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contextRowId)
        contextRowId = contextRowIdDecoded
    }
}

extension HoneycodeClientTypes.Filter: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Filter(contextRowId: \(Swift.String(describing: contextRowId)), formula: \"CONTENT_REDACTED\")"}
}

extension HoneycodeClientTypes {
    /// An object that represents a filter formula along with the id of the context row under which the filter function needs to evaluate.
    public struct Filter: Swift.Equatable {
        /// The optional contextRowId attribute can be used to specify the row id of the context row if the filter formula contains unqualified references to table columns and needs a context row to evaluate them successfully.
        public var contextRowId: Swift.String?
        /// A formula representing a filter function that returns zero or more matching rows from a table. Valid formulas in this field return a list of rows from a table. The most common ways of writing a formula to return a list of rows are to use the FindRow() or Filter() functions. Any other formula that returns zero or more rows is also acceptable. For example, you can use a formula that points to a cell that contains a filter function.
        /// This member is required.
        public var formula: Swift.String?

        public init(
            contextRowId: Swift.String? = nil,
            formula: Swift.String? = nil
        )
        {
            self.contextRowId = contextRowId
            self.formula = formula
        }
    }

}

extension HoneycodeClientTypes {
    public enum Format: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case accounting
        case auto
        case contact
        case currency
        case date
        case datetime
        case number
        case percentage
        case rowlink
        case rowset
        case text
        case time
        case sdkUnknown(Swift.String)

        public static var allCases: [Format] {
            return [
                .accounting,
                .auto,
                .contact,
                .currency,
                .date,
                .datetime,
                .number,
                .percentage,
                .rowlink,
                .rowset,
                .text,
                .time,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .accounting: return "ACCOUNTING"
            case .auto: return "AUTO"
            case .contact: return "CONTACT"
            case .currency: return "CURRENCY"
            case .date: return "DATE"
            case .datetime: return "DATE_TIME"
            case .number: return "NUMBER"
            case .percentage: return "PERCENTAGE"
            case .rowlink: return "ROWLINK"
            case .rowset: return "ROWSET"
            case .text: return "TEXT"
            case .time: return "TIME"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Format(rawValue: rawValue) ?? Format.sdkUnknown(rawValue)
        }
    }
}

extension GetScreenDataInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetScreenDataInput(appId: \(Swift.String(describing: appId)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \(Swift.String(describing: nextToken)), screenId: \(Swift.String(describing: screenId)), workbookId: \(Swift.String(describing: workbookId)), variables: \"CONTENT_REDACTED\")"}
}

extension GetScreenDataInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appId
        case maxResults
        case nextToken
        case screenId
        case variables
        case workbookId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appId = self.appId {
            try encodeContainer.encode(appId, forKey: .appId)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let screenId = self.screenId {
            try encodeContainer.encode(screenId, forKey: .screenId)
        }
        if let variables = variables {
            var variablesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .variables)
            for (dictKey0, variableValueMap0) in variables {
                try variablesContainer.encode(variableValueMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let workbookId = self.workbookId {
            try encodeContainer.encode(workbookId, forKey: .workbookId)
        }
    }
}

extension GetScreenDataInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/screendata"
    }
}

public struct GetScreenDataInput: Swift.Equatable {
    /// The ID of the app that contains the screen.
    /// This member is required.
    public var appId: Swift.String?
    /// The number of results to be returned on a single page. Specify a number between 1 and 100. The maximum value is 100. This parameter is optional. If you don't specify this parameter, the default page size is 100.
    public var maxResults: Swift.Int?
    /// This parameter is optional. If a nextToken is not specified, the API returns the first page of data. Pagination tokens expire after 1 hour. If you use a token that was returned more than an hour back, the API will throw ValidationException.
    public var nextToken: Swift.String?
    /// The ID of the screen.
    /// This member is required.
    public var screenId: Swift.String?
    /// Variables are optional and are needed only if the screen requires them to render correctly. Variables are specified as a map where the key is the name of the variable as defined on the screen. The value is an object which currently has only one property, rawValue, which holds the value of the variable to be passed to the screen.
    public var variables: [Swift.String:HoneycodeClientTypes.VariableValue]?
    /// The ID of the workbook that contains the screen.
    /// This member is required.
    public var workbookId: Swift.String?

    public init(
        appId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        screenId: Swift.String? = nil,
        variables: [Swift.String:HoneycodeClientTypes.VariableValue]? = nil,
        workbookId: Swift.String? = nil
    )
    {
        self.appId = appId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.screenId = screenId
        self.variables = variables
        self.workbookId = workbookId
    }
}

struct GetScreenDataInputBody: Swift.Equatable {
    let workbookId: Swift.String?
    let appId: Swift.String?
    let screenId: Swift.String?
    let variables: [Swift.String:HoneycodeClientTypes.VariableValue]?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension GetScreenDataInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appId
        case maxResults
        case nextToken
        case screenId
        case variables
        case workbookId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workbookIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .workbookId)
        workbookId = workbookIdDecoded
        let appIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appId)
        appId = appIdDecoded
        let screenIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .screenId)
        screenId = screenIdDecoded
        let variablesContainer = try containerValues.decodeIfPresent([Swift.String: HoneycodeClientTypes.VariableValue?].self, forKey: .variables)
        var variablesDecoded0: [Swift.String:HoneycodeClientTypes.VariableValue]? = nil
        if let variablesContainer = variablesContainer {
            variablesDecoded0 = [Swift.String:HoneycodeClientTypes.VariableValue]()
            for (key0, variablevalue0) in variablesContainer {
                if let variablevalue0 = variablevalue0 {
                    variablesDecoded0?[key0] = variablevalue0
                }
            }
        }
        variables = variablesDecoded0
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetScreenDataOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetScreenDataOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.results = output.results
            self.workbookCursor = output.workbookCursor
        } else {
            self.nextToken = nil
            self.results = nil
            self.workbookCursor = 0
        }
    }
}

public struct GetScreenDataOutput: Swift.Equatable {
    /// Provides the pagination token to load the next page if there are more results matching the request. If a pagination token is not present in the response, it means that all data matching the query has been loaded.
    public var nextToken: Swift.String?
    /// A map of all the rows on the screen keyed by block name.
    /// This member is required.
    public var results: [Swift.String:HoneycodeClientTypes.ResultSet]?
    /// Indicates the cursor of the workbook at which the data returned by this workbook is read. Workbook cursor keeps increasing with every update and the increments are not sequential.
    /// This member is required.
    public var workbookCursor: Swift.Int

    public init(
        nextToken: Swift.String? = nil,
        results: [Swift.String:HoneycodeClientTypes.ResultSet]? = nil,
        workbookCursor: Swift.Int = 0
    )
    {
        self.nextToken = nextToken
        self.results = results
        self.workbookCursor = workbookCursor
    }
}

struct GetScreenDataOutputBody: Swift.Equatable {
    let results: [Swift.String:HoneycodeClientTypes.ResultSet]?
    let workbookCursor: Swift.Int
    let nextToken: Swift.String?
}

extension GetScreenDataOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case results
        case workbookCursor
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resultsContainer = try containerValues.decodeIfPresent([Swift.String: HoneycodeClientTypes.ResultSet?].self, forKey: .results)
        var resultsDecoded0: [Swift.String:HoneycodeClientTypes.ResultSet]? = nil
        if let resultsContainer = resultsContainer {
            resultsDecoded0 = [Swift.String:HoneycodeClientTypes.ResultSet]()
            for (key0, resultset0) in resultsContainer {
                if let resultset0 = resultset0 {
                    resultsDecoded0?[key0] = resultset0
                }
            }
        }
        results = resultsDecoded0
        let workbookCursorDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .workbookCursor) ?? 0
        workbookCursor = workbookCursorDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum GetScreenDataOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RequestTimeoutException": return try await RequestTimeoutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension HoneycodeClientTypes {
    public enum ImportDataCharacterEncoding: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case iso88591
        case usAscii
        case utf16
        case utf16be
        case utf16le
        case utf8
        case sdkUnknown(Swift.String)

        public static var allCases: [ImportDataCharacterEncoding] {
            return [
                .iso88591,
                .usAscii,
                .utf16,
                .utf16be,
                .utf16le,
                .utf8,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .iso88591: return "ISO-8859-1"
            case .usAscii: return "US-ASCII"
            case .utf16: return "UTF-16"
            case .utf16be: return "UTF-16BE"
            case .utf16le: return "UTF-16LE"
            case .utf8: return "UTF-8"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ImportDataCharacterEncoding(rawValue: rawValue) ?? ImportDataCharacterEncoding.sdkUnknown(rawValue)
        }
    }
}

extension HoneycodeClientTypes.ImportDataSource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataSourceConfig
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataSourceConfig = self.dataSourceConfig {
            try encodeContainer.encode(dataSourceConfig, forKey: .dataSourceConfig)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataSourceConfigDecoded = try containerValues.decodeIfPresent(HoneycodeClientTypes.ImportDataSourceConfig.self, forKey: .dataSourceConfig)
        dataSourceConfig = dataSourceConfigDecoded
    }
}

extension HoneycodeClientTypes {
    /// An object that has details about the source of the data that was submitted for import.
    public struct ImportDataSource: Swift.Equatable {
        /// The configuration parameters for the data source of the import
        /// This member is required.
        public var dataSourceConfig: HoneycodeClientTypes.ImportDataSourceConfig?

        public init(
            dataSourceConfig: HoneycodeClientTypes.ImportDataSourceConfig? = nil
        )
        {
            self.dataSourceConfig = dataSourceConfig
        }
    }

}

extension HoneycodeClientTypes.ImportDataSourceConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataSourceUrl
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataSourceUrl = self.dataSourceUrl {
            try encodeContainer.encode(dataSourceUrl, forKey: .dataSourceUrl)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataSourceUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataSourceUrl)
        dataSourceUrl = dataSourceUrlDecoded
    }
}

extension HoneycodeClientTypes.ImportDataSourceConfig: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ImportDataSourceConfig(dataSourceUrl: \"CONTENT_REDACTED\")"}
}

extension HoneycodeClientTypes {
    /// An object that contains the configuration parameters for the data source of an import request.
    public struct ImportDataSourceConfig: Swift.Equatable {
        /// The URL from which source data will be downloaded for the import request.
        public var dataSourceUrl: Swift.String?

        public init(
            dataSourceUrl: Swift.String? = nil
        )
        {
            self.dataSourceUrl = dataSourceUrl
        }
    }

}

extension HoneycodeClientTypes.ImportJobSubmitter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case email
        case userArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let email = self.email {
            try encodeContainer.encode(email, forKey: .email)
        }
        if let userArn = self.userArn {
            try encodeContainer.encode(userArn, forKey: .userArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let emailDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .email)
        email = emailDecoded
        let userArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userArn)
        userArn = userArnDecoded
    }
}

extension HoneycodeClientTypes.ImportJobSubmitter: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ImportJobSubmitter(userArn: \(Swift.String(describing: userArn)), email: \"CONTENT_REDACTED\")"}
}

extension HoneycodeClientTypes {
    /// An object that contains the attributes of the submitter of the import job.
    public struct ImportJobSubmitter: Swift.Equatable {
        /// The email id of the submitter of the import job, if available.
        public var email: Swift.String?
        /// The AWS user ARN of the submitter of the import job, if available.
        public var userArn: Swift.String?

        public init(
            email: Swift.String? = nil,
            userArn: Swift.String? = nil
        )
        {
            self.email = email
            self.userArn = userArn
        }
    }

}

extension HoneycodeClientTypes.ImportOptions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case delimitedTextOptions
        case destinationOptions
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let delimitedTextOptions = self.delimitedTextOptions {
            try encodeContainer.encode(delimitedTextOptions, forKey: .delimitedTextOptions)
        }
        if let destinationOptions = self.destinationOptions {
            try encodeContainer.encode(destinationOptions, forKey: .destinationOptions)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let destinationOptionsDecoded = try containerValues.decodeIfPresent(HoneycodeClientTypes.DestinationOptions.self, forKey: .destinationOptions)
        destinationOptions = destinationOptionsDecoded
        let delimitedTextOptionsDecoded = try containerValues.decodeIfPresent(HoneycodeClientTypes.DelimitedTextImportOptions.self, forKey: .delimitedTextOptions)
        delimitedTextOptions = delimitedTextOptionsDecoded
    }
}

extension HoneycodeClientTypes {
    /// An object that contains the options specified by the sumitter of the import request.
    public struct ImportOptions: Swift.Equatable {
        /// Options relating to parsing delimited text. Required if dataFormat is DELIMITED_TEXT.
        public var delimitedTextOptions: HoneycodeClientTypes.DelimitedTextImportOptions?
        /// Options relating to the destination of the import request.
        public var destinationOptions: HoneycodeClientTypes.DestinationOptions?

        public init(
            delimitedTextOptions: HoneycodeClientTypes.DelimitedTextImportOptions? = nil,
            destinationOptions: HoneycodeClientTypes.DestinationOptions? = nil
        )
        {
            self.delimitedTextOptions = delimitedTextOptions
            self.destinationOptions = destinationOptions
        }
    }

}

extension HoneycodeClientTypes {
    public enum ImportSourceDataFormat: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case delimitedtext
        case sdkUnknown(Swift.String)

        public static var allCases: [ImportSourceDataFormat] {
            return [
                .delimitedtext,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .delimitedtext: return "DELIMITED_TEXT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ImportSourceDataFormat(rawValue: rawValue) ?? ImportSourceDataFormat.sdkUnknown(rawValue)
        }
    }
}

extension InternalServerException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// There were unexpected errors from the server.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvokeScreenAutomationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InvokeScreenAutomationInput(appId: \(Swift.String(describing: appId)), clientRequestToken: \(Swift.String(describing: clientRequestToken)), rowId: \(Swift.String(describing: rowId)), screenAutomationId: \(Swift.String(describing: screenAutomationId)), screenId: \(Swift.String(describing: screenId)), workbookId: \(Swift.String(describing: workbookId)), variables: \"CONTENT_REDACTED\")"}
}

extension InvokeScreenAutomationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken
        case rowId
        case variables
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = self.clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let rowId = self.rowId {
            try encodeContainer.encode(rowId, forKey: .rowId)
        }
        if let variables = variables {
            var variablesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .variables)
            for (dictKey0, variableValueMap0) in variables {
                try variablesContainer.encode(variableValueMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension InvokeScreenAutomationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let workbookId = workbookId else {
            return nil
        }
        guard let appId = appId else {
            return nil
        }
        guard let screenId = screenId else {
            return nil
        }
        guard let screenAutomationId = screenAutomationId else {
            return nil
        }
        return "/workbooks/\(workbookId.urlPercentEncoding())/apps/\(appId.urlPercentEncoding())/screens/\(screenId.urlPercentEncoding())/automations/\(screenAutomationId.urlPercentEncoding())"
    }
}

public struct InvokeScreenAutomationInput: Swift.Equatable {
    /// The ID of the app that contains the screen automation.
    /// This member is required.
    public var appId: Swift.String?
    /// The request token for performing the automation action. Request tokens help to identify duplicate requests. If a call times out or fails due to a transient error like a failed network connection, you can retry the call with the same request token. The service ensures that if the first call using that request token is successfully performed, the second call will return the response of the previous call rather than performing the action again. Note that request tokens are valid only for a few minutes. You cannot use request tokens to dedupe requests spanning hours or days.
    public var clientRequestToken: Swift.String?
    /// The row ID for the automation if the automation is defined inside a block with source or list.
    public var rowId: Swift.String?
    /// The ID of the automation action to be performed.
    /// This member is required.
    public var screenAutomationId: Swift.String?
    /// The ID of the screen that contains the screen automation.
    /// This member is required.
    public var screenId: Swift.String?
    /// Variables are specified as a map where the key is the name of the variable as defined on the screen. The value is an object which currently has only one property, rawValue, which holds the value of the variable to be passed to the screen. Any variables defined in a screen are required to be passed in the call.
    public var variables: [Swift.String:HoneycodeClientTypes.VariableValue]?
    /// The ID of the workbook that contains the screen automation.
    /// This member is required.
    public var workbookId: Swift.String?

    public init(
        appId: Swift.String? = nil,
        clientRequestToken: Swift.String? = nil,
        rowId: Swift.String? = nil,
        screenAutomationId: Swift.String? = nil,
        screenId: Swift.String? = nil,
        variables: [Swift.String:HoneycodeClientTypes.VariableValue]? = nil,
        workbookId: Swift.String? = nil
    )
    {
        self.appId = appId
        self.clientRequestToken = clientRequestToken
        self.rowId = rowId
        self.screenAutomationId = screenAutomationId
        self.screenId = screenId
        self.variables = variables
        self.workbookId = workbookId
    }
}

struct InvokeScreenAutomationInputBody: Swift.Equatable {
    let variables: [Swift.String:HoneycodeClientTypes.VariableValue]?
    let rowId: Swift.String?
    let clientRequestToken: Swift.String?
}

extension InvokeScreenAutomationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken
        case rowId
        case variables
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let variablesContainer = try containerValues.decodeIfPresent([Swift.String: HoneycodeClientTypes.VariableValue?].self, forKey: .variables)
        var variablesDecoded0: [Swift.String:HoneycodeClientTypes.VariableValue]? = nil
        if let variablesContainer = variablesContainer {
            variablesDecoded0 = [Swift.String:HoneycodeClientTypes.VariableValue]()
            for (key0, variablevalue0) in variablesContainer {
                if let variablevalue0 = variablevalue0 {
                    variablesDecoded0?[key0] = variablevalue0
                }
            }
        }
        variables = variablesDecoded0
        let rowIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .rowId)
        rowId = rowIdDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
    }
}

extension InvokeScreenAutomationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvokeScreenAutomationOutputBody = try responseDecoder.decode(responseBody: data)
            self.workbookCursor = output.workbookCursor
        } else {
            self.workbookCursor = 0
        }
    }
}

public struct InvokeScreenAutomationOutput: Swift.Equatable {
    /// The updated workbook cursor after performing the automation action.
    /// This member is required.
    public var workbookCursor: Swift.Int

    public init(
        workbookCursor: Swift.Int = 0
    )
    {
        self.workbookCursor = workbookCursor
    }
}

struct InvokeScreenAutomationOutputBody: Swift.Equatable {
    let workbookCursor: Swift.Int
}

extension InvokeScreenAutomationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case workbookCursor
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let workbookCursorDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .workbookCursor) ?? 0
        workbookCursor = workbookCursorDecoded
    }
}

enum InvokeScreenAutomationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "AutomationExecutionException": return try await AutomationExecutionException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "AutomationExecutionTimeoutException": return try await AutomationExecutionTimeoutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RequestTimeoutException": return try await RequestTimeoutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTableColumnsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            return items
        }
    }
}

extension ListTableColumnsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let workbookId = workbookId else {
            return nil
        }
        guard let tableId = tableId else {
            return nil
        }
        return "/workbooks/\(workbookId.urlPercentEncoding())/tables/\(tableId.urlPercentEncoding())/columns"
    }
}

public struct ListTableColumnsInput: Swift.Equatable {
    /// This parameter is optional. If a nextToken is not specified, the API returns the first page of data. Pagination tokens expire after 1 hour. If you use a token that was returned more than an hour back, the API will throw ValidationException.
    public var nextToken: Swift.String?
    /// The ID of the table whose columns are being retrieved. If a table with the specified id could not be found, this API throws ResourceNotFoundException.
    /// This member is required.
    public var tableId: Swift.String?
    /// The ID of the workbook that contains the table whose columns are being retrieved. If a workbook with the specified id could not be found, this API throws ResourceNotFoundException.
    /// This member is required.
    public var workbookId: Swift.String?

    public init(
        nextToken: Swift.String? = nil,
        tableId: Swift.String? = nil,
        workbookId: Swift.String? = nil
    )
    {
        self.nextToken = nextToken
        self.tableId = tableId
        self.workbookId = workbookId
    }
}

struct ListTableColumnsInputBody: Swift.Equatable {
}

extension ListTableColumnsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListTableColumnsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTableColumnsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.tableColumns = output.tableColumns
            self.workbookCursor = output.workbookCursor
        } else {
            self.nextToken = nil
            self.tableColumns = nil
            self.workbookCursor = 0
        }
    }
}

public struct ListTableColumnsOutput: Swift.Equatable {
    /// Provides the pagination token to load the next page if there are more results matching the request. If a pagination token is not present in the response, it means that all data matching the request has been loaded.
    public var nextToken: Swift.String?
    /// The list of columns in the table.
    /// This member is required.
    public var tableColumns: [HoneycodeClientTypes.TableColumn]?
    /// Indicates the cursor of the workbook at which the data returned by this request is read. Workbook cursor keeps increasing with every update and the increments are not sequential.
    public var workbookCursor: Swift.Int

    public init(
        nextToken: Swift.String? = nil,
        tableColumns: [HoneycodeClientTypes.TableColumn]? = nil,
        workbookCursor: Swift.Int = 0
    )
    {
        self.nextToken = nextToken
        self.tableColumns = tableColumns
        self.workbookCursor = workbookCursor
    }
}

struct ListTableColumnsOutputBody: Swift.Equatable {
    let tableColumns: [HoneycodeClientTypes.TableColumn]?
    let nextToken: Swift.String?
    let workbookCursor: Swift.Int
}

extension ListTableColumnsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case tableColumns
        case workbookCursor
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tableColumnsContainer = try containerValues.decodeIfPresent([HoneycodeClientTypes.TableColumn?].self, forKey: .tableColumns)
        var tableColumnsDecoded0:[HoneycodeClientTypes.TableColumn]? = nil
        if let tableColumnsContainer = tableColumnsContainer {
            tableColumnsDecoded0 = [HoneycodeClientTypes.TableColumn]()
            for structure0 in tableColumnsContainer {
                if let structure0 = structure0 {
                    tableColumnsDecoded0?.append(structure0)
                }
            }
        }
        tableColumns = tableColumnsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let workbookCursorDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .workbookCursor) ?? 0
        workbookCursor = workbookCursorDecoded
    }
}

enum ListTableColumnsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RequestTimeoutException": return try await RequestTimeoutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTableRowsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case rowIds
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let rowIds = rowIds {
            var rowIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .rowIds)
            for rowid0 in rowIds {
                try rowIdsContainer.encode(rowid0)
            }
        }
    }
}

extension ListTableRowsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let workbookId = workbookId else {
            return nil
        }
        guard let tableId = tableId else {
            return nil
        }
        return "/workbooks/\(workbookId.urlPercentEncoding())/tables/\(tableId.urlPercentEncoding())/rows/list"
    }
}

public struct ListTableRowsInput: Swift.Equatable {
    /// The maximum number of rows to return in each page of the results.
    public var maxResults: Swift.Int?
    /// This parameter is optional. If a nextToken is not specified, the API returns the first page of data. Pagination tokens expire after 1 hour. If you use a token that was returned more than an hour back, the API will throw ValidationException.
    public var nextToken: Swift.String?
    /// This parameter is optional. If one or more row ids are specified in this list, then only the specified row ids are returned in the result. If no row ids are specified here, then all the rows in the table are returned.
    public var rowIds: [Swift.String]?
    /// The ID of the table whose rows are being retrieved. If a table with the specified id could not be found, this API throws ResourceNotFoundException.
    /// This member is required.
    public var tableId: Swift.String?
    /// The ID of the workbook that contains the table whose rows are being retrieved. If a workbook with the specified id could not be found, this API throws ResourceNotFoundException.
    /// This member is required.
    public var workbookId: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        rowIds: [Swift.String]? = nil,
        tableId: Swift.String? = nil,
        workbookId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.rowIds = rowIds
        self.tableId = tableId
        self.workbookId = workbookId
    }
}

struct ListTableRowsInputBody: Swift.Equatable {
    let rowIds: [Swift.String]?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListTableRowsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case rowIds
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let rowIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .rowIds)
        var rowIdsDecoded0:[Swift.String]? = nil
        if let rowIdsContainer = rowIdsContainer {
            rowIdsDecoded0 = [Swift.String]()
            for string0 in rowIdsContainer {
                if let string0 = string0 {
                    rowIdsDecoded0?.append(string0)
                }
            }
        }
        rowIds = rowIdsDecoded0
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTableRowsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTableRowsOutputBody = try responseDecoder.decode(responseBody: data)
            self.columnIds = output.columnIds
            self.nextToken = output.nextToken
            self.rowIdsNotFound = output.rowIdsNotFound
            self.rows = output.rows
            self.workbookCursor = output.workbookCursor
        } else {
            self.columnIds = nil
            self.nextToken = nil
            self.rowIdsNotFound = nil
            self.rows = nil
            self.workbookCursor = 0
        }
    }
}

public struct ListTableRowsOutput: Swift.Equatable {
    /// The list of columns in the table whose row data is returned in the result.
    /// This member is required.
    public var columnIds: [Swift.String]?
    /// Provides the pagination token to load the next page if there are more results matching the request. If a pagination token is not present in the response, it means that all data matching the request has been loaded.
    public var nextToken: Swift.String?
    /// The list of row ids included in the request that were not found in the table.
    public var rowIdsNotFound: [Swift.String]?
    /// The list of rows in the table. Note that this result is paginated, so this list contains a maximum of 100 rows.
    /// This member is required.
    public var rows: [HoneycodeClientTypes.TableRow]?
    /// Indicates the cursor of the workbook at which the data returned by this request is read. Workbook cursor keeps increasing with every update and the increments are not sequential.
    /// This member is required.
    public var workbookCursor: Swift.Int

    public init(
        columnIds: [Swift.String]? = nil,
        nextToken: Swift.String? = nil,
        rowIdsNotFound: [Swift.String]? = nil,
        rows: [HoneycodeClientTypes.TableRow]? = nil,
        workbookCursor: Swift.Int = 0
    )
    {
        self.columnIds = columnIds
        self.nextToken = nextToken
        self.rowIdsNotFound = rowIdsNotFound
        self.rows = rows
        self.workbookCursor = workbookCursor
    }
}

struct ListTableRowsOutputBody: Swift.Equatable {
    let columnIds: [Swift.String]?
    let rows: [HoneycodeClientTypes.TableRow]?
    let rowIdsNotFound: [Swift.String]?
    let nextToken: Swift.String?
    let workbookCursor: Swift.Int
}

extension ListTableRowsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case columnIds
        case nextToken
        case rowIdsNotFound
        case rows
        case workbookCursor
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let columnIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .columnIds)
        var columnIdsDecoded0:[Swift.String]? = nil
        if let columnIdsContainer = columnIdsContainer {
            columnIdsDecoded0 = [Swift.String]()
            for string0 in columnIdsContainer {
                if let string0 = string0 {
                    columnIdsDecoded0?.append(string0)
                }
            }
        }
        columnIds = columnIdsDecoded0
        let rowsContainer = try containerValues.decodeIfPresent([HoneycodeClientTypes.TableRow?].self, forKey: .rows)
        var rowsDecoded0:[HoneycodeClientTypes.TableRow]? = nil
        if let rowsContainer = rowsContainer {
            rowsDecoded0 = [HoneycodeClientTypes.TableRow]()
            for structure0 in rowsContainer {
                if let structure0 = structure0 {
                    rowsDecoded0?.append(structure0)
                }
            }
        }
        rows = rowsDecoded0
        let rowIdsNotFoundContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .rowIdsNotFound)
        var rowIdsNotFoundDecoded0:[Swift.String]? = nil
        if let rowIdsNotFoundContainer = rowIdsNotFoundContainer {
            rowIdsNotFoundDecoded0 = [Swift.String]()
            for string0 in rowIdsNotFoundContainer {
                if let string0 = string0 {
                    rowIdsNotFoundDecoded0?.append(string0)
                }
            }
        }
        rowIdsNotFound = rowIdsNotFoundDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let workbookCursorDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .workbookCursor) ?? 0
        workbookCursor = workbookCursorDecoded
    }
}

enum ListTableRowsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RequestTimeoutException": return try await RequestTimeoutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTablesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            return items
        }
    }
}

extension ListTablesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let workbookId = workbookId else {
            return nil
        }
        return "/workbooks/\(workbookId.urlPercentEncoding())/tables"
    }
}

public struct ListTablesInput: Swift.Equatable {
    /// The maximum number of tables to return in each page of the results.
    public var maxResults: Swift.Int?
    /// This parameter is optional. If a nextToken is not specified, the API returns the first page of data. Pagination tokens expire after 1 hour. If you use a token that was returned more than an hour back, the API will throw ValidationException.
    public var nextToken: Swift.String?
    /// The ID of the workbook whose tables are being retrieved. If a workbook with the specified id could not be found, this API throws ResourceNotFoundException.
    /// This member is required.
    public var workbookId: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        workbookId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.workbookId = workbookId
    }
}

struct ListTablesInputBody: Swift.Equatable {
}

extension ListTablesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListTablesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTablesOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.tables = output.tables
            self.workbookCursor = output.workbookCursor
        } else {
            self.nextToken = nil
            self.tables = nil
            self.workbookCursor = 0
        }
    }
}

public struct ListTablesOutput: Swift.Equatable {
    /// Provides the pagination token to load the next page if there are more results matching the request. If a pagination token is not present in the response, it means that all data matching the request has been loaded.
    public var nextToken: Swift.String?
    /// The list of tables in the workbook.
    /// This member is required.
    public var tables: [HoneycodeClientTypes.Table]?
    /// Indicates the cursor of the workbook at which the data returned by this request is read. Workbook cursor keeps increasing with every update and the increments are not sequential.
    public var workbookCursor: Swift.Int

    public init(
        nextToken: Swift.String? = nil,
        tables: [HoneycodeClientTypes.Table]? = nil,
        workbookCursor: Swift.Int = 0
    )
    {
        self.nextToken = nextToken
        self.tables = tables
        self.workbookCursor = workbookCursor
    }
}

struct ListTablesOutputBody: Swift.Equatable {
    let tables: [HoneycodeClientTypes.Table]?
    let nextToken: Swift.String?
    let workbookCursor: Swift.Int
}

extension ListTablesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case tables
        case workbookCursor
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tablesContainer = try containerValues.decodeIfPresent([HoneycodeClientTypes.Table?].self, forKey: .tables)
        var tablesDecoded0:[HoneycodeClientTypes.Table]? = nil
        if let tablesContainer = tablesContainer {
            tablesDecoded0 = [HoneycodeClientTypes.Table]()
            for structure0 in tablesContainer {
                if let structure0 = structure0 {
                    tablesDecoded0?.append(structure0)
                }
            }
        }
        tables = tablesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let workbookCursorDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .workbookCursor) ?? 0
        workbookCursor = workbookCursorDecoded
    }
}

enum ListTablesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RequestTimeoutException": return try await RequestTimeoutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The resource's Amazon Resource Name (ARN).
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutput: Swift.Equatable {
    /// The resource's tags.
    public var tags: [Swift.String:Swift.String]?

    public init(
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension ListTagsForResourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum ListTagsForResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RequestTimeoutException": return try await RequestTimeoutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension QueryTableRowsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filterFormula
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filterFormula = self.filterFormula {
            try encodeContainer.encode(filterFormula, forKey: .filterFormula)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension QueryTableRowsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let workbookId = workbookId else {
            return nil
        }
        guard let tableId = tableId else {
            return nil
        }
        return "/workbooks/\(workbookId.urlPercentEncoding())/tables/\(tableId.urlPercentEncoding())/rows/query"
    }
}

public struct QueryTableRowsInput: Swift.Equatable {
    /// An object that represents a filter formula along with the id of the context row under which the filter function needs to evaluate.
    /// This member is required.
    public var filterFormula: HoneycodeClientTypes.Filter?
    /// The maximum number of rows to return in each page of the results.
    public var maxResults: Swift.Int?
    /// This parameter is optional. If a nextToken is not specified, the API returns the first page of data. Pagination tokens expire after 1 hour. If you use a token that was returned more than an hour back, the API will throw ValidationException.
    public var nextToken: Swift.String?
    /// The ID of the table whose rows are being queried. If a table with the specified id could not be found, this API throws ResourceNotFoundException.
    /// This member is required.
    public var tableId: Swift.String?
    /// The ID of the workbook whose table rows are being queried. If a workbook with the specified id could not be found, this API throws ResourceNotFoundException.
    /// This member is required.
    public var workbookId: Swift.String?

    public init(
        filterFormula: HoneycodeClientTypes.Filter? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        tableId: Swift.String? = nil,
        workbookId: Swift.String? = nil
    )
    {
        self.filterFormula = filterFormula
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.tableId = tableId
        self.workbookId = workbookId
    }
}

struct QueryTableRowsInputBody: Swift.Equatable {
    let filterFormula: HoneycodeClientTypes.Filter?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension QueryTableRowsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filterFormula
        case maxResults
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filterFormulaDecoded = try containerValues.decodeIfPresent(HoneycodeClientTypes.Filter.self, forKey: .filterFormula)
        filterFormula = filterFormulaDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension QueryTableRowsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: QueryTableRowsOutputBody = try responseDecoder.decode(responseBody: data)
            self.columnIds = output.columnIds
            self.nextToken = output.nextToken
            self.rows = output.rows
            self.workbookCursor = output.workbookCursor
        } else {
            self.columnIds = nil
            self.nextToken = nil
            self.rows = nil
            self.workbookCursor = 0
        }
    }
}

public struct QueryTableRowsOutput: Swift.Equatable {
    /// The list of columns in the table whose row data is returned in the result.
    /// This member is required.
    public var columnIds: [Swift.String]?
    /// Provides the pagination token to load the next page if there are more results matching the request. If a pagination token is not present in the response, it means that all data matching the request has been loaded.
    public var nextToken: Swift.String?
    /// The list of rows in the table that match the query filter.
    /// This member is required.
    public var rows: [HoneycodeClientTypes.TableRow]?
    /// Indicates the cursor of the workbook at which the data returned by this request is read. Workbook cursor keeps increasing with every update and the increments are not sequential.
    /// This member is required.
    public var workbookCursor: Swift.Int

    public init(
        columnIds: [Swift.String]? = nil,
        nextToken: Swift.String? = nil,
        rows: [HoneycodeClientTypes.TableRow]? = nil,
        workbookCursor: Swift.Int = 0
    )
    {
        self.columnIds = columnIds
        self.nextToken = nextToken
        self.rows = rows
        self.workbookCursor = workbookCursor
    }
}

struct QueryTableRowsOutputBody: Swift.Equatable {
    let columnIds: [Swift.String]?
    let rows: [HoneycodeClientTypes.TableRow]?
    let nextToken: Swift.String?
    let workbookCursor: Swift.Int
}

extension QueryTableRowsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case columnIds
        case nextToken
        case rows
        case workbookCursor
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let columnIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .columnIds)
        var columnIdsDecoded0:[Swift.String]? = nil
        if let columnIdsContainer = columnIdsContainer {
            columnIdsDecoded0 = [Swift.String]()
            for string0 in columnIdsContainer {
                if let string0 = string0 {
                    columnIdsDecoded0?.append(string0)
                }
            }
        }
        columnIds = columnIdsDecoded0
        let rowsContainer = try containerValues.decodeIfPresent([HoneycodeClientTypes.TableRow?].self, forKey: .rows)
        var rowsDecoded0:[HoneycodeClientTypes.TableRow]? = nil
        if let rowsContainer = rowsContainer {
            rowsDecoded0 = [HoneycodeClientTypes.TableRow]()
            for structure0 in rowsContainer {
                if let structure0 = structure0 {
                    rowsDecoded0?.append(structure0)
                }
            }
        }
        rows = rowsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let workbookCursorDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .workbookCursor) ?? 0
        workbookCursor = workbookCursorDecoded
    }
}

enum QueryTableRowsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RequestTimeoutException": return try await RequestTimeoutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension RequestTimeoutException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: RequestTimeoutExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request timed out.
public struct RequestTimeoutException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "RequestTimeoutException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct RequestTimeoutExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension RequestTimeoutExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ResourceNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// A Workbook, Table, App, Screen or Screen Automation was not found with the given ID.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension HoneycodeClientTypes.ResultRow: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataItems
        case rowId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataItems = dataItems {
            var dataItemsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dataItems)
            for dataitem0 in dataItems {
                try dataItemsContainer.encode(dataitem0)
            }
        }
        if let rowId = self.rowId {
            try encodeContainer.encode(rowId, forKey: .rowId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let rowIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .rowId)
        rowId = rowIdDecoded
        let dataItemsContainer = try containerValues.decodeIfPresent([HoneycodeClientTypes.DataItem?].self, forKey: .dataItems)
        var dataItemsDecoded0:[HoneycodeClientTypes.DataItem]? = nil
        if let dataItemsContainer = dataItemsContainer {
            dataItemsDecoded0 = [HoneycodeClientTypes.DataItem]()
            for structure0 in dataItemsContainer {
                if let structure0 = structure0 {
                    dataItemsDecoded0?.append(structure0)
                }
            }
        }
        dataItems = dataItemsDecoded0
    }
}

extension HoneycodeClientTypes {
    /// A single row in the ResultSet.
    public struct ResultRow: Swift.Equatable {
        /// List of all the data cells in a row.
        /// This member is required.
        public var dataItems: [HoneycodeClientTypes.DataItem]?
        /// The ID for a particular row.
        public var rowId: Swift.String?

        public init(
            dataItems: [HoneycodeClientTypes.DataItem]? = nil,
            rowId: Swift.String? = nil
        )
        {
            self.dataItems = dataItems
            self.rowId = rowId
        }
    }

}

extension HoneycodeClientTypes.ResultSet: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case headers
        case rows
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let headers = headers {
            var headersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .headers)
            for columnmetadata0 in headers {
                try headersContainer.encode(columnmetadata0)
            }
        }
        if let rows = rows {
            var rowsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .rows)
            for resultrow0 in rows {
                try rowsContainer.encode(resultrow0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let headersContainer = try containerValues.decodeIfPresent([HoneycodeClientTypes.ColumnMetadata?].self, forKey: .headers)
        var headersDecoded0:[HoneycodeClientTypes.ColumnMetadata]? = nil
        if let headersContainer = headersContainer {
            headersDecoded0 = [HoneycodeClientTypes.ColumnMetadata]()
            for structure0 in headersContainer {
                if let structure0 = structure0 {
                    headersDecoded0?.append(structure0)
                }
            }
        }
        headers = headersDecoded0
        let rowsContainer = try containerValues.decodeIfPresent([HoneycodeClientTypes.ResultRow?].self, forKey: .rows)
        var rowsDecoded0:[HoneycodeClientTypes.ResultRow]? = nil
        if let rowsContainer = rowsContainer {
            rowsDecoded0 = [HoneycodeClientTypes.ResultRow]()
            for structure0 in rowsContainer {
                if let structure0 = structure0 {
                    rowsDecoded0?.append(structure0)
                }
            }
        }
        rows = rowsDecoded0
    }
}

extension HoneycodeClientTypes {
    /// ResultSet contains the results of the request for a single block or list defined on the screen.
    public struct ResultSet: Swift.Equatable {
        /// List of headers for all the data cells in the block. The header identifies the name and default format of the data cell. Data cells appear in the same order in all rows as defined in the header. The names and formats are not repeated in the rows. If a particular row does not have a value for a data cell, a blank value is used. For example, a task list that displays the task name, due date and assigned person might have headers [ { "name": "Task Name"}, {"name": "Due Date", "format": "DATE"}, {"name": "Assigned", "format": "CONTACT"} ]. Every row in the result will have the task name as the first item, due date as the second item and assigned person as the third item. If a particular task does not have a due date, that row will still have a blank value in the second element and the assigned person will still be in the third element.
        /// This member is required.
        public var headers: [HoneycodeClientTypes.ColumnMetadata]?
        /// List of rows returned by the request. Each row has a row Id and a list of data cells in that row. The data cells will be present in the same order as they are defined in the header.
        /// This member is required.
        public var rows: [HoneycodeClientTypes.ResultRow]?

        public init(
            headers: [HoneycodeClientTypes.ColumnMetadata]? = nil,
            rows: [HoneycodeClientTypes.ResultRow]? = nil
        )
        {
            self.headers = headers
            self.rows = rows
        }
    }

}

extension ServiceQuotaExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request caused service quota to be breached.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ServiceUnavailableException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ServiceUnavailableExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Remote service is unreachable.
public struct ServiceUnavailableException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceUnavailableException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ServiceUnavailableExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ServiceUnavailableExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension HoneycodeClientTypes.SourceDataColumnProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case columnIndex
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if columnIndex != 0 {
            try encodeContainer.encode(columnIndex, forKey: .columnIndex)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let columnIndexDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .columnIndex) ?? 0
        columnIndex = columnIndexDecoded
    }
}

extension HoneycodeClientTypes {
    /// An object that contains the properties for importing data to a specific column in a table.
    public struct SourceDataColumnProperties: Swift.Equatable {
        /// The index of the column in the input file.
        public var columnIndex: Swift.Int

        public init(
            columnIndex: Swift.Int = 0
        )
        {
            self.columnIndex = columnIndex
        }
    }

}

extension StartTableDataImportJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken
        case dataFormat
        case dataSource
        case importOptions
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = self.clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let dataFormat = self.dataFormat {
            try encodeContainer.encode(dataFormat.rawValue, forKey: .dataFormat)
        }
        if let dataSource = self.dataSource {
            try encodeContainer.encode(dataSource, forKey: .dataSource)
        }
        if let importOptions = self.importOptions {
            try encodeContainer.encode(importOptions, forKey: .importOptions)
        }
    }
}

extension StartTableDataImportJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let workbookId = workbookId else {
            return nil
        }
        guard let destinationTableId = destinationTableId else {
            return nil
        }
        return "/workbooks/\(workbookId.urlPercentEncoding())/tables/\(destinationTableId.urlPercentEncoding())/import"
    }
}

public struct StartTableDataImportJobInput: Swift.Equatable {
    /// The request token for performing the update action. Request tokens help to identify duplicate requests. If a call times out or fails due to a transient error like a failed network connection, you can retry the call with the same request token. The service ensures that if the first call using that request token is successfully performed, the second call will not perform the action again. Note that request tokens are valid only for a few minutes. You cannot use request tokens to dedupe requests spanning hours or days.
    /// This member is required.
    public var clientRequestToken: Swift.String?
    /// The format of the data that is being imported. Currently the only option supported is "DELIMITED_TEXT".
    /// This member is required.
    public var dataFormat: HoneycodeClientTypes.ImportSourceDataFormat?
    /// The source of the data that is being imported. The size of source must be no larger than 100 MB. Source must have no more than 100,000 cells and no more than 1,000 rows.
    /// This member is required.
    public var dataSource: HoneycodeClientTypes.ImportDataSource?
    /// The ID of the table where the rows are being imported. If a table with the specified id could not be found, this API throws ResourceNotFoundException.
    /// This member is required.
    public var destinationTableId: Swift.String?
    /// The options for customizing this import request.
    /// This member is required.
    public var importOptions: HoneycodeClientTypes.ImportOptions?
    /// The ID of the workbook where the rows are being imported. If a workbook with the specified id could not be found, this API throws ResourceNotFoundException.
    /// This member is required.
    public var workbookId: Swift.String?

    public init(
        clientRequestToken: Swift.String? = nil,
        dataFormat: HoneycodeClientTypes.ImportSourceDataFormat? = nil,
        dataSource: HoneycodeClientTypes.ImportDataSource? = nil,
        destinationTableId: Swift.String? = nil,
        importOptions: HoneycodeClientTypes.ImportOptions? = nil,
        workbookId: Swift.String? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.dataFormat = dataFormat
        self.dataSource = dataSource
        self.destinationTableId = destinationTableId
        self.importOptions = importOptions
        self.workbookId = workbookId
    }
}

struct StartTableDataImportJobInputBody: Swift.Equatable {
    let dataSource: HoneycodeClientTypes.ImportDataSource?
    let dataFormat: HoneycodeClientTypes.ImportSourceDataFormat?
    let importOptions: HoneycodeClientTypes.ImportOptions?
    let clientRequestToken: Swift.String?
}

extension StartTableDataImportJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken
        case dataFormat
        case dataSource
        case importOptions
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataSourceDecoded = try containerValues.decodeIfPresent(HoneycodeClientTypes.ImportDataSource.self, forKey: .dataSource)
        dataSource = dataSourceDecoded
        let dataFormatDecoded = try containerValues.decodeIfPresent(HoneycodeClientTypes.ImportSourceDataFormat.self, forKey: .dataFormat)
        dataFormat = dataFormatDecoded
        let importOptionsDecoded = try containerValues.decodeIfPresent(HoneycodeClientTypes.ImportOptions.self, forKey: .importOptions)
        importOptions = importOptionsDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
    }
}

extension StartTableDataImportJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StartTableDataImportJobOutputBody = try responseDecoder.decode(responseBody: data)
            self.jobId = output.jobId
            self.jobStatus = output.jobStatus
        } else {
            self.jobId = nil
            self.jobStatus = nil
        }
    }
}

public struct StartTableDataImportJobOutput: Swift.Equatable {
    /// The id that is assigned to this import job. Future requests to find out the status of this import job need to send this id in the appropriate parameter in the request.
    /// This member is required.
    public var jobId: Swift.String?
    /// The status of the import job immediately after submitting the request.
    /// This member is required.
    public var jobStatus: HoneycodeClientTypes.TableDataImportJobStatus?

    public init(
        jobId: Swift.String? = nil,
        jobStatus: HoneycodeClientTypes.TableDataImportJobStatus? = nil
    )
    {
        self.jobId = jobId
        self.jobStatus = jobStatus
    }
}

struct StartTableDataImportJobOutputBody: Swift.Equatable {
    let jobId: Swift.String?
    let jobStatus: HoneycodeClientTypes.TableDataImportJobStatus?
}

extension StartTableDataImportJobOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId
        case jobStatus
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let jobStatusDecoded = try containerValues.decodeIfPresent(HoneycodeClientTypes.TableDataImportJobStatus.self, forKey: .jobStatus)
        jobStatus = jobStatusDecoded
    }
}

enum StartTableDataImportJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RequestTimeoutException": return try await RequestTimeoutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension HoneycodeClientTypes.Table: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tableId
        case tableName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tableId = self.tableId {
            try encodeContainer.encode(tableId, forKey: .tableId)
        }
        if let tableName = self.tableName {
            try encodeContainer.encode(tableName, forKey: .tableName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tableIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tableId)
        tableId = tableIdDecoded
        let tableNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tableName)
        tableName = tableNameDecoded
    }
}

extension HoneycodeClientTypes {
    /// An object representing the properties of a table in a workbook.
    public struct Table: Swift.Equatable {
        /// The id of the table.
        public var tableId: Swift.String?
        /// The name of the table.
        public var tableName: Swift.String?

        public init(
            tableId: Swift.String? = nil,
            tableName: Swift.String? = nil
        )
        {
            self.tableId = tableId
            self.tableName = tableName
        }
    }

}

extension HoneycodeClientTypes.TableColumn: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case format
        case tableColumnId
        case tableColumnName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let format = self.format {
            try encodeContainer.encode(format.rawValue, forKey: .format)
        }
        if let tableColumnId = self.tableColumnId {
            try encodeContainer.encode(tableColumnId, forKey: .tableColumnId)
        }
        if let tableColumnName = self.tableColumnName {
            try encodeContainer.encode(tableColumnName, forKey: .tableColumnName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tableColumnIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tableColumnId)
        tableColumnId = tableColumnIdDecoded
        let tableColumnNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .tableColumnName)
        tableColumnName = tableColumnNameDecoded
        let formatDecoded = try containerValues.decodeIfPresent(HoneycodeClientTypes.Format.self, forKey: .format)
        format = formatDecoded
    }
}

extension HoneycodeClientTypes {
    /// An object that contains attributes about a single column in a table
    public struct TableColumn: Swift.Equatable {
        /// The column level format that is applied in the table. An empty value in this field means that the column format is the default value 'AUTO'.
        public var format: HoneycodeClientTypes.Format?
        /// The id of the column in the table.
        public var tableColumnId: Swift.String?
        /// The name of the column in the table.
        public var tableColumnName: Swift.String?

        public init(
            format: HoneycodeClientTypes.Format? = nil,
            tableColumnId: Swift.String? = nil,
            tableColumnName: Swift.String? = nil
        )
        {
            self.format = format
            self.tableColumnId = tableColumnId
            self.tableColumnName = tableColumnName
        }
    }

}

extension HoneycodeClientTypes.TableDataImportJobMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataSource
        case importOptions
        case submitTime
        case submitter
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataSource = self.dataSource {
            try encodeContainer.encode(dataSource, forKey: .dataSource)
        }
        if let importOptions = self.importOptions {
            try encodeContainer.encode(importOptions, forKey: .importOptions)
        }
        if let submitTime = self.submitTime {
            try encodeContainer.encodeTimestamp(submitTime, format: .epochSeconds, forKey: .submitTime)
        }
        if let submitter = self.submitter {
            try encodeContainer.encode(submitter, forKey: .submitter)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let submitterDecoded = try containerValues.decodeIfPresent(HoneycodeClientTypes.ImportJobSubmitter.self, forKey: .submitter)
        submitter = submitterDecoded
        let submitTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .submitTime)
        submitTime = submitTimeDecoded
        let importOptionsDecoded = try containerValues.decodeIfPresent(HoneycodeClientTypes.ImportOptions.self, forKey: .importOptions)
        importOptions = importOptionsDecoded
        let dataSourceDecoded = try containerValues.decodeIfPresent(HoneycodeClientTypes.ImportDataSource.self, forKey: .dataSource)
        dataSource = dataSourceDecoded
    }
}

extension HoneycodeClientTypes {
    /// The metadata associated with the table data import job that was submitted.
    public struct TableDataImportJobMetadata: Swift.Equatable {
        /// The source of the data that was submitted for import.
        /// This member is required.
        public var dataSource: HoneycodeClientTypes.ImportDataSource?
        /// The options that was specified at the time of submitting the import request.
        /// This member is required.
        public var importOptions: HoneycodeClientTypes.ImportOptions?
        /// The timestamp when the job was submitted for import.
        /// This member is required.
        public var submitTime: ClientRuntime.Date?
        /// Details about the submitter of the import request.
        /// This member is required.
        public var submitter: HoneycodeClientTypes.ImportJobSubmitter?

        public init(
            dataSource: HoneycodeClientTypes.ImportDataSource? = nil,
            importOptions: HoneycodeClientTypes.ImportOptions? = nil,
            submitTime: ClientRuntime.Date? = nil,
            submitter: HoneycodeClientTypes.ImportJobSubmitter? = nil
        )
        {
            self.dataSource = dataSource
            self.importOptions = importOptions
            self.submitTime = submitTime
            self.submitter = submitter
        }
    }

}

extension HoneycodeClientTypes {
    public enum TableDataImportJobStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case completed
        case failed
        case inprogress
        case submitted
        case sdkUnknown(Swift.String)

        public static var allCases: [TableDataImportJobStatus] {
            return [
                .completed,
                .failed,
                .inprogress,
                .submitted,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .completed: return "COMPLETED"
            case .failed: return "FAILED"
            case .inprogress: return "IN_PROGRESS"
            case .submitted: return "SUBMITTED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TableDataImportJobStatus(rawValue: rawValue) ?? TableDataImportJobStatus.sdkUnknown(rawValue)
        }
    }
}

extension HoneycodeClientTypes.TableRow: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cells
        case rowId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cells = cells {
            var cellsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .cells)
            for cell0 in cells {
                try cellsContainer.encode(cell0)
            }
        }
        if let rowId = self.rowId {
            try encodeContainer.encode(rowId, forKey: .rowId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let rowIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .rowId)
        rowId = rowIdDecoded
        let cellsContainer = try containerValues.decodeIfPresent([HoneycodeClientTypes.Cell?].self, forKey: .cells)
        var cellsDecoded0:[HoneycodeClientTypes.Cell]? = nil
        if let cellsContainer = cellsContainer {
            cellsDecoded0 = [HoneycodeClientTypes.Cell]()
            for structure0 in cellsContainer {
                if let structure0 = structure0 {
                    cellsDecoded0?.append(structure0)
                }
            }
        }
        cells = cellsDecoded0
    }
}

extension HoneycodeClientTypes {
    /// An object that contains attributes about a single row in a table
    public struct TableRow: Swift.Equatable {
        /// A list of cells in the table row. The cells appear in the same order as the columns of the table.
        /// This member is required.
        public var cells: [HoneycodeClientTypes.Cell]?
        /// The id of the row in the table.
        /// This member is required.
        public var rowId: Swift.String?

        public init(
            cells: [HoneycodeClientTypes.Cell]? = nil,
            rowId: Swift.String? = nil
        )
        {
            self.cells = cells
            self.rowId = rowId
        }
    }

}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagsMap0) in tags {
                try tagsContainer.encode(tagsMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The resource's Amazon Resource Name (ARN).
    /// This member is required.
    public var resourceArn: Swift.String?
    /// A list of tags to apply to the resource.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct TagResourceOutput: Swift.Equatable {

    public init() { }
}

enum TagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RequestTimeoutException": return try await RequestTimeoutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ThrottlingException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Tps(transactions per second) rate reached.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UntagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let tagKeys = tagKeys else {
                let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
            return items
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The resource's Amazon Resource Name (ARN).
    /// This member is required.
    public var resourceArn: Swift.String?
    /// A list of tag keys to remove from the resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UntagResourceOutput: Swift.Equatable {

    public init() { }
}

enum UntagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RequestTimeoutException": return try await RequestTimeoutException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension HoneycodeClientTypes.UpdateRowData: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cellsToUpdate
        case rowId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cellsToUpdate = cellsToUpdate {
            var cellsToUpdateContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .cellsToUpdate)
            for (dictKey0, rowDataInput0) in cellsToUpdate {
                try cellsToUpdateContainer.encode(rowDataInput0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let rowId = self.rowId {
            try encodeContainer.encode(rowId, forKey: .rowId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let rowIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .rowId)
        rowId = rowIdDecoded
        let cellsToUpdateContainer = try containerValues.decodeIfPresent([Swift.String: HoneycodeClientTypes.CellInput?].self, forKey: .cellsToUpdate)
        var cellsToUpdateDecoded0: [Swift.String:HoneycodeClientTypes.CellInput]? = nil
        if let cellsToUpdateContainer = cellsToUpdateContainer {
            cellsToUpdateDecoded0 = [Swift.String:HoneycodeClientTypes.CellInput]()
            for (key0, cellinput0) in cellsToUpdateContainer {
                if let cellinput0 = cellinput0 {
                    cellsToUpdateDecoded0?[key0] = cellinput0
                }
            }
        }
        cellsToUpdate = cellsToUpdateDecoded0
    }
}

extension HoneycodeClientTypes {
    /// Data needed to create a single row in a table as part of the BatchCreateTableRows request.
    public struct UpdateRowData: Swift.Equatable {
        /// A map representing the cells to update in the given row. The key is the column id of the cell and the value is the CellInput object that represents the data to set in that cell.
        /// This member is required.
        public var cellsToUpdate: [Swift.String:HoneycodeClientTypes.CellInput]?
        /// The id of the row that needs to be updated.
        /// This member is required.
        public var rowId: Swift.String?

        public init(
            cellsToUpdate: [Swift.String:HoneycodeClientTypes.CellInput]? = nil,
            rowId: Swift.String? = nil
        )
        {
            self.cellsToUpdate = cellsToUpdate
            self.rowId = rowId
        }
    }

}

extension HoneycodeClientTypes {
    public enum UpsertAction: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case appended
        case updated
        case sdkUnknown(Swift.String)

        public static var allCases: [UpsertAction] {
            return [
                .appended,
                .updated,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .appended: return "APPENDED"
            case .updated: return "UPDATED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = UpsertAction(rawValue: rawValue) ?? UpsertAction.sdkUnknown(rawValue)
        }
    }
}

extension HoneycodeClientTypes.UpsertRowData: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case batchItemId
        case cellsToUpdate
        case filter
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let batchItemId = self.batchItemId {
            try encodeContainer.encode(batchItemId, forKey: .batchItemId)
        }
        if let cellsToUpdate = cellsToUpdate {
            var cellsToUpdateContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .cellsToUpdate)
            for (dictKey0, rowDataInput0) in cellsToUpdate {
                try cellsToUpdateContainer.encode(rowDataInput0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let filter = self.filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let batchItemIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .batchItemId)
        batchItemId = batchItemIdDecoded
        let filterDecoded = try containerValues.decodeIfPresent(HoneycodeClientTypes.Filter.self, forKey: .filter)
        filter = filterDecoded
        let cellsToUpdateContainer = try containerValues.decodeIfPresent([Swift.String: HoneycodeClientTypes.CellInput?].self, forKey: .cellsToUpdate)
        var cellsToUpdateDecoded0: [Swift.String:HoneycodeClientTypes.CellInput]? = nil
        if let cellsToUpdateContainer = cellsToUpdateContainer {
            cellsToUpdateDecoded0 = [Swift.String:HoneycodeClientTypes.CellInput]()
            for (key0, cellinput0) in cellsToUpdateContainer {
                if let cellinput0 = cellinput0 {
                    cellsToUpdateDecoded0?[key0] = cellinput0
                }
            }
        }
        cellsToUpdate = cellsToUpdateDecoded0
    }
}

extension HoneycodeClientTypes {
    /// Data needed to upsert rows in a table as part of a single item in the BatchUpsertTableRows request.
    public struct UpsertRowData: Swift.Equatable {
        /// An external identifier that represents a single item in the request that is being upserted as part of the BatchUpsertTableRows request. This can be any string that you can use to identify the item in the request. The BatchUpsertTableRows API puts the batch item id in the results to allow you to link data in the request to data in the results.
        /// This member is required.
        public var batchItemId: Swift.String?
        /// A map representing the cells to update for the matching rows or an appended row. The key is the column id of the cell and the value is the CellInput object that represents the data to set in that cell.
        /// This member is required.
        public var cellsToUpdate: [Swift.String:HoneycodeClientTypes.CellInput]?
        /// The filter formula to use to find existing matching rows to update. The formula needs to return zero or more rows. If the formula returns 0 rows, then a new row will be appended in the target table. If the formula returns one or more rows, then the returned rows will be updated. Note that the filter formula needs to return rows from the target table for the upsert operation to succeed. If the filter formula has a syntax error or it doesn't evaluate to zero or more rows in the target table for any one item in the input list, then the entire BatchUpsertTableRows request fails and no updates are made to the table.
        /// This member is required.
        public var filter: HoneycodeClientTypes.Filter?

        public init(
            batchItemId: Swift.String? = nil,
            cellsToUpdate: [Swift.String:HoneycodeClientTypes.CellInput]? = nil,
            filter: HoneycodeClientTypes.Filter? = nil
        )
        {
            self.batchItemId = batchItemId
            self.cellsToUpdate = cellsToUpdate
            self.filter = filter
        }
    }

}

extension HoneycodeClientTypes.UpsertRowsResult: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case rowIds
        case upsertAction
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let rowIds = rowIds {
            var rowIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .rowIds)
            for rowid0 in rowIds {
                try rowIdsContainer.encode(rowid0)
            }
        }
        if let upsertAction = self.upsertAction {
            try encodeContainer.encode(upsertAction.rawValue, forKey: .upsertAction)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let rowIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .rowIds)
        var rowIdsDecoded0:[Swift.String]? = nil
        if let rowIdsContainer = rowIdsContainer {
            rowIdsDecoded0 = [Swift.String]()
            for string0 in rowIdsContainer {
                if let string0 = string0 {
                    rowIdsDecoded0?.append(string0)
                }
            }
        }
        rowIds = rowIdsDecoded0
        let upsertActionDecoded = try containerValues.decodeIfPresent(HoneycodeClientTypes.UpsertAction.self, forKey: .upsertAction)
        upsertAction = upsertActionDecoded
    }
}

extension HoneycodeClientTypes {
    /// An object that represents the result of a single upsert row request.
    public struct UpsertRowsResult: Swift.Equatable {
        /// The list of row ids that were changed as part of an upsert row operation. If the upsert resulted in an update, this list could potentially contain multiple rows that matched the filter and hence got updated. If the upsert resulted in an append, this list would only have the single row that was appended.
        /// This member is required.
        public var rowIds: [Swift.String]?
        /// The result of the upsert action.
        /// This member is required.
        public var upsertAction: HoneycodeClientTypes.UpsertAction?

        public init(
            rowIds: [Swift.String]? = nil,
            upsertAction: HoneycodeClientTypes.UpsertAction? = nil
        )
        {
            self.rowIds = rowIds
            self.upsertAction = upsertAction
        }
    }

}

extension ValidationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Request is invalid. The message in the response contains details on why the request is invalid.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension HoneycodeClientTypes.VariableValue: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case rawValue
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let rawValue = self.rawValue {
            try encodeContainer.encode(rawValue, forKey: .rawValue)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let rawValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .rawValue)
        rawValue = rawValueDecoded
    }
}

extension HoneycodeClientTypes.VariableValue: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension HoneycodeClientTypes {
    /// The input variables to the app to be used by the InvokeScreenAutomation action request.
    public struct VariableValue: Swift.Equatable {
        /// Raw value of the variable.
        /// This member is required.
        public var rawValue: Swift.String?

        public init(
            rawValue: Swift.String? = nil
        )
        {
            self.rawValue = rawValue
        }
    }

}
