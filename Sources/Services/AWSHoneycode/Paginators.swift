// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension HoneycodeClient {
    /// Paginate over `[ListTableColumnsOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListTableColumnsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListTableColumnsOutputResponse`
    public func listTableColumnsPaginated(input: ListTableColumnsInput) -> ClientRuntime.PaginatorSequence<ListTableColumnsInput, ListTableColumnsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListTableColumnsInput, ListTableColumnsOutputResponse>(input: input, inputKey: \ListTableColumnsInput.nextToken, outputKey: \ListTableColumnsOutputResponse.nextToken, paginationFunction: self.listTableColumns(input:))
    }
}

extension ListTableColumnsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListTableColumnsInput {
        return ListTableColumnsInput(
            nextToken: token,
            tableId: self.tableId,
            workbookId: self.workbookId
        )}
}

extension PaginatorSequence where Input == ListTableColumnsInput, Output == ListTableColumnsOutputResponse {
    /// This paginator transforms the `AsyncSequence` returned by `listTableColumnsPaginated`
    /// to access the nested member `[HoneycodeClientTypes.TableColumn]`
    /// - Returns: `[HoneycodeClientTypes.TableColumn]`
    public func tableColumns() async throws -> [HoneycodeClientTypes.TableColumn] {
        return try await self.asyncCompactMap { item in item.tableColumns }
    }
}
extension HoneycodeClient {
    /// Paginate over `[ListTableRowsOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListTableRowsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListTableRowsOutputResponse`
    public func listTableRowsPaginated(input: ListTableRowsInput) -> ClientRuntime.PaginatorSequence<ListTableRowsInput, ListTableRowsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListTableRowsInput, ListTableRowsOutputResponse>(input: input, inputKey: \ListTableRowsInput.nextToken, outputKey: \ListTableRowsOutputResponse.nextToken, paginationFunction: self.listTableRows(input:))
    }
}

extension ListTableRowsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListTableRowsInput {
        return ListTableRowsInput(
            maxResults: self.maxResults,
            nextToken: token,
            rowIds: self.rowIds,
            tableId: self.tableId,
            workbookId: self.workbookId
        )}
}

extension PaginatorSequence where Input == ListTableRowsInput, Output == ListTableRowsOutputResponse {
    /// This paginator transforms the `AsyncSequence` returned by `listTableRowsPaginated`
    /// to access the nested member `[HoneycodeClientTypes.TableRow]`
    /// - Returns: `[HoneycodeClientTypes.TableRow]`
    public func rows() async throws -> [HoneycodeClientTypes.TableRow] {
        return try await self.asyncCompactMap { item in item.rows }
    }
}
extension HoneycodeClient {
    /// Paginate over `[ListTablesOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListTablesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListTablesOutputResponse`
    public func listTablesPaginated(input: ListTablesInput) -> ClientRuntime.PaginatorSequence<ListTablesInput, ListTablesOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListTablesInput, ListTablesOutputResponse>(input: input, inputKey: \ListTablesInput.nextToken, outputKey: \ListTablesOutputResponse.nextToken, paginationFunction: self.listTables(input:))
    }
}

extension ListTablesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListTablesInput {
        return ListTablesInput(
            maxResults: self.maxResults,
            nextToken: token,
            workbookId: self.workbookId
        )}
}

extension PaginatorSequence where Input == ListTablesInput, Output == ListTablesOutputResponse {
    /// This paginator transforms the `AsyncSequence` returned by `listTablesPaginated`
    /// to access the nested member `[HoneycodeClientTypes.Table]`
    /// - Returns: `[HoneycodeClientTypes.Table]`
    public func tables() async throws -> [HoneycodeClientTypes.Table] {
        return try await self.asyncCompactMap { item in item.tables }
    }
}
extension HoneycodeClient {
    /// Paginate over `[QueryTableRowsOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[QueryTableRowsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `QueryTableRowsOutputResponse`
    public func queryTableRowsPaginated(input: QueryTableRowsInput) -> ClientRuntime.PaginatorSequence<QueryTableRowsInput, QueryTableRowsOutputResponse> {
        return ClientRuntime.PaginatorSequence<QueryTableRowsInput, QueryTableRowsOutputResponse>(input: input, inputKey: \QueryTableRowsInput.nextToken, outputKey: \QueryTableRowsOutputResponse.nextToken, paginationFunction: self.queryTableRows(input:))
    }
}

extension QueryTableRowsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> QueryTableRowsInput {
        return QueryTableRowsInput(
            filterFormula: self.filterFormula,
            maxResults: self.maxResults,
            nextToken: token,
            tableId: self.tableId,
            workbookId: self.workbookId
        )}
}

extension PaginatorSequence where Input == QueryTableRowsInput, Output == QueryTableRowsOutputResponse {
    /// This paginator transforms the `AsyncSequence` returned by `queryTableRowsPaginated`
    /// to access the nested member `[HoneycodeClientTypes.TableRow]`
    /// - Returns: `[HoneycodeClientTypes.TableRow]`
    public func rows() async throws -> [HoneycodeClientTypes.TableRow] {
        return try await self.asyncCompactMap { item in item.rows }
    }
}
