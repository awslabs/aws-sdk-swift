// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension IotDeviceAdvisorClientTypes {
    public enum AuthenticationMethod: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case signatureversion4
        case x509clientcertificate
        case sdkUnknown(Swift.String)

        public static var allCases: [AuthenticationMethod] {
            return [
                .signatureversion4,
                .x509clientcertificate,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .signatureversion4: return "SignatureVersion4"
            case .x509clientcertificate: return "X509ClientCertificate"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AuthenticationMethod(rawValue: rawValue) ?? AuthenticationMethod.sdkUnknown(rawValue)
        }
    }
}

extension ConflictException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Sends a Conflict Exception.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Sends a Conflict Exception message.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CreateSuiteDefinitionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case suiteDefinitionConfiguration
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let suiteDefinitionConfiguration = self.suiteDefinitionConfiguration {
            try encodeContainer.encode(suiteDefinitionConfiguration, forKey: .suiteDefinitionConfiguration)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateSuiteDefinitionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/suiteDefinitions"
    }
}

public struct CreateSuiteDefinitionInput: Swift.Equatable {
    /// Creates a Device Advisor test suite with suite definition configuration.
    /// This member is required.
    public var suiteDefinitionConfiguration: IotDeviceAdvisorClientTypes.SuiteDefinitionConfiguration?
    /// The tags to be attached to the suite definition.
    public var tags: [Swift.String:Swift.String]?

    public init(
        suiteDefinitionConfiguration: IotDeviceAdvisorClientTypes.SuiteDefinitionConfiguration? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.suiteDefinitionConfiguration = suiteDefinitionConfiguration
        self.tags = tags
    }
}

struct CreateSuiteDefinitionInputBody: Swift.Equatable {
    let suiteDefinitionConfiguration: IotDeviceAdvisorClientTypes.SuiteDefinitionConfiguration?
    let tags: [Swift.String:Swift.String]?
}

extension CreateSuiteDefinitionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case suiteDefinitionConfiguration
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let suiteDefinitionConfigurationDecoded = try containerValues.decodeIfPresent(IotDeviceAdvisorClientTypes.SuiteDefinitionConfiguration.self, forKey: .suiteDefinitionConfiguration)
        suiteDefinitionConfiguration = suiteDefinitionConfigurationDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string2560) in tagsContainer {
                if let string2560 = string2560 {
                    tagsDecoded0?[key0] = string2560
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateSuiteDefinitionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateSuiteDefinitionOutputBody = try responseDecoder.decode(responseBody: data)
            self.createdAt = output.createdAt
            self.suiteDefinitionArn = output.suiteDefinitionArn
            self.suiteDefinitionId = output.suiteDefinitionId
            self.suiteDefinitionName = output.suiteDefinitionName
        } else {
            self.createdAt = nil
            self.suiteDefinitionArn = nil
            self.suiteDefinitionId = nil
            self.suiteDefinitionName = nil
        }
    }
}

public struct CreateSuiteDefinitionOutput: Swift.Equatable {
    /// The timestamp of when the test suite was created.
    public var createdAt: ClientRuntime.Date?
    /// The Amazon Resource Name (ARN) of the test suite.
    public var suiteDefinitionArn: Swift.String?
    /// The UUID of the test suite created.
    public var suiteDefinitionId: Swift.String?
    /// The suite definition name of the test suite. This is a required parameter.
    public var suiteDefinitionName: Swift.String?

    public init(
        createdAt: ClientRuntime.Date? = nil,
        suiteDefinitionArn: Swift.String? = nil,
        suiteDefinitionId: Swift.String? = nil,
        suiteDefinitionName: Swift.String? = nil
    )
    {
        self.createdAt = createdAt
        self.suiteDefinitionArn = suiteDefinitionArn
        self.suiteDefinitionId = suiteDefinitionId
        self.suiteDefinitionName = suiteDefinitionName
    }
}

struct CreateSuiteDefinitionOutputBody: Swift.Equatable {
    let suiteDefinitionId: Swift.String?
    let suiteDefinitionArn: Swift.String?
    let suiteDefinitionName: Swift.String?
    let createdAt: ClientRuntime.Date?
}

extension CreateSuiteDefinitionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt
        case suiteDefinitionArn
        case suiteDefinitionId
        case suiteDefinitionName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let suiteDefinitionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .suiteDefinitionId)
        suiteDefinitionId = suiteDefinitionIdDecoded
        let suiteDefinitionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .suiteDefinitionArn)
        suiteDefinitionArn = suiteDefinitionArnDecoded
        let suiteDefinitionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .suiteDefinitionName)
        suiteDefinitionName = suiteDefinitionNameDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
    }
}

enum CreateSuiteDefinitionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteSuiteDefinitionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let suiteDefinitionId = suiteDefinitionId else {
            return nil
        }
        return "/suiteDefinitions/\(suiteDefinitionId.urlPercentEncoding())"
    }
}

public struct DeleteSuiteDefinitionInput: Swift.Equatable {
    /// Suite definition ID of the test suite to be deleted.
    /// This member is required.
    public var suiteDefinitionId: Swift.String?

    public init(
        suiteDefinitionId: Swift.String? = nil
    )
    {
        self.suiteDefinitionId = suiteDefinitionId
    }
}

struct DeleteSuiteDefinitionInputBody: Swift.Equatable {
}

extension DeleteSuiteDefinitionInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteSuiteDefinitionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteSuiteDefinitionOutput: Swift.Equatable {

    public init() { }
}

enum DeleteSuiteDefinitionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension IotDeviceAdvisorClientTypes.DeviceUnderTest: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateArn
        case deviceRoleArn
        case thingArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificateArn = self.certificateArn {
            try encodeContainer.encode(certificateArn, forKey: .certificateArn)
        }
        if let deviceRoleArn = self.deviceRoleArn {
            try encodeContainer.encode(deviceRoleArn, forKey: .deviceRoleArn)
        }
        if let thingArn = self.thingArn {
            try encodeContainer.encode(thingArn, forKey: .thingArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let thingArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .thingArn)
        thingArn = thingArnDecoded
        let certificateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateArn)
        certificateArn = certificateArnDecoded
        let deviceRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceRoleArn)
        deviceRoleArn = deviceRoleArnDecoded
    }
}

extension IotDeviceAdvisorClientTypes {
    /// Information of a test device. A thing ARN, certificate ARN or device role ARN is required.
    public struct DeviceUnderTest: Swift.Equatable {
        /// Lists device's certificate ARN.
        public var certificateArn: Swift.String?
        /// Lists device's role ARN.
        public var deviceRoleArn: Swift.String?
        /// Lists device's thing ARN.
        public var thingArn: Swift.String?

        public init(
            certificateArn: Swift.String? = nil,
            deviceRoleArn: Swift.String? = nil,
            thingArn: Swift.String? = nil
        )
        {
            self.certificateArn = certificateArn
            self.deviceRoleArn = deviceRoleArn
            self.thingArn = thingArn
        }
    }

}

extension GetEndpointInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let thingArn = thingArn {
                let thingArnQueryItem = ClientRuntime.URLQueryItem(name: "thingArn".urlPercentEncoding(), value: Swift.String(thingArn).urlPercentEncoding())
                items.append(thingArnQueryItem)
            }
            if let certificateArn = certificateArn {
                let certificateArnQueryItem = ClientRuntime.URLQueryItem(name: "certificateArn".urlPercentEncoding(), value: Swift.String(certificateArn).urlPercentEncoding())
                items.append(certificateArnQueryItem)
            }
            if let deviceRoleArn = deviceRoleArn {
                let deviceRoleArnQueryItem = ClientRuntime.URLQueryItem(name: "deviceRoleArn".urlPercentEncoding(), value: Swift.String(deviceRoleArn).urlPercentEncoding())
                items.append(deviceRoleArnQueryItem)
            }
            if let authenticationMethod = authenticationMethod {
                let authenticationMethodQueryItem = ClientRuntime.URLQueryItem(name: "authenticationMethod".urlPercentEncoding(), value: Swift.String(authenticationMethod.rawValue).urlPercentEncoding())
                items.append(authenticationMethodQueryItem)
            }
            return items
        }
    }
}

extension GetEndpointInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/endpoint"
    }
}

public struct GetEndpointInput: Swift.Equatable {
    /// The authentication method used during the device connection.
    public var authenticationMethod: IotDeviceAdvisorClientTypes.AuthenticationMethod?
    /// The certificate ARN of the device. This is an optional parameter.
    public var certificateArn: Swift.String?
    /// The device role ARN of the device. This is an optional parameter.
    public var deviceRoleArn: Swift.String?
    /// The thing ARN of the device. This is an optional parameter.
    public var thingArn: Swift.String?

    public init(
        authenticationMethod: IotDeviceAdvisorClientTypes.AuthenticationMethod? = nil,
        certificateArn: Swift.String? = nil,
        deviceRoleArn: Swift.String? = nil,
        thingArn: Swift.String? = nil
    )
    {
        self.authenticationMethod = authenticationMethod
        self.certificateArn = certificateArn
        self.deviceRoleArn = deviceRoleArn
        self.thingArn = thingArn
    }
}

struct GetEndpointInputBody: Swift.Equatable {
}

extension GetEndpointInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetEndpointOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetEndpointOutputBody = try responseDecoder.decode(responseBody: data)
            self.endpoint = output.endpoint
        } else {
            self.endpoint = nil
        }
    }
}

public struct GetEndpointOutput: Swift.Equatable {
    /// The response of an Device Advisor endpoint.
    public var endpoint: Swift.String?

    public init(
        endpoint: Swift.String? = nil
    )
    {
        self.endpoint = endpoint
    }
}

struct GetEndpointOutputBody: Swift.Equatable {
    let endpoint: Swift.String?
}

extension GetEndpointOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpoint
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpoint)
        endpoint = endpointDecoded
    }
}

enum GetEndpointOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetSuiteDefinitionInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let suiteDefinitionVersion = suiteDefinitionVersion {
                let suiteDefinitionVersionQueryItem = ClientRuntime.URLQueryItem(name: "suiteDefinitionVersion".urlPercentEncoding(), value: Swift.String(suiteDefinitionVersion).urlPercentEncoding())
                items.append(suiteDefinitionVersionQueryItem)
            }
            return items
        }
    }
}

extension GetSuiteDefinitionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let suiteDefinitionId = suiteDefinitionId else {
            return nil
        }
        return "/suiteDefinitions/\(suiteDefinitionId.urlPercentEncoding())"
    }
}

public struct GetSuiteDefinitionInput: Swift.Equatable {
    /// Suite definition ID of the test suite to get.
    /// This member is required.
    public var suiteDefinitionId: Swift.String?
    /// Suite definition version of the test suite to get.
    public var suiteDefinitionVersion: Swift.String?

    public init(
        suiteDefinitionId: Swift.String? = nil,
        suiteDefinitionVersion: Swift.String? = nil
    )
    {
        self.suiteDefinitionId = suiteDefinitionId
        self.suiteDefinitionVersion = suiteDefinitionVersion
    }
}

struct GetSuiteDefinitionInputBody: Swift.Equatable {
}

extension GetSuiteDefinitionInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetSuiteDefinitionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetSuiteDefinitionOutputBody = try responseDecoder.decode(responseBody: data)
            self.createdAt = output.createdAt
            self.lastModifiedAt = output.lastModifiedAt
            self.latestVersion = output.latestVersion
            self.suiteDefinitionArn = output.suiteDefinitionArn
            self.suiteDefinitionConfiguration = output.suiteDefinitionConfiguration
            self.suiteDefinitionId = output.suiteDefinitionId
            self.suiteDefinitionVersion = output.suiteDefinitionVersion
            self.tags = output.tags
        } else {
            self.createdAt = nil
            self.lastModifiedAt = nil
            self.latestVersion = nil
            self.suiteDefinitionArn = nil
            self.suiteDefinitionConfiguration = nil
            self.suiteDefinitionId = nil
            self.suiteDefinitionVersion = nil
            self.tags = nil
        }
    }
}

public struct GetSuiteDefinitionOutput: Swift.Equatable {
    /// Date (in Unix epoch time) when the suite definition was created.
    public var createdAt: ClientRuntime.Date?
    /// Date (in Unix epoch time) when the suite definition was last modified.
    public var lastModifiedAt: ClientRuntime.Date?
    /// Latest suite definition version of the suite definition.
    public var latestVersion: Swift.String?
    /// The ARN of the suite definition.
    public var suiteDefinitionArn: Swift.String?
    /// Suite configuration of the suite definition.
    public var suiteDefinitionConfiguration: IotDeviceAdvisorClientTypes.SuiteDefinitionConfiguration?
    /// Suite definition ID of the suite definition.
    public var suiteDefinitionId: Swift.String?
    /// Suite definition version of the suite definition.
    public var suiteDefinitionVersion: Swift.String?
    /// Tags attached to the suite definition.
    public var tags: [Swift.String:Swift.String]?

    public init(
        createdAt: ClientRuntime.Date? = nil,
        lastModifiedAt: ClientRuntime.Date? = nil,
        latestVersion: Swift.String? = nil,
        suiteDefinitionArn: Swift.String? = nil,
        suiteDefinitionConfiguration: IotDeviceAdvisorClientTypes.SuiteDefinitionConfiguration? = nil,
        suiteDefinitionId: Swift.String? = nil,
        suiteDefinitionVersion: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.createdAt = createdAt
        self.lastModifiedAt = lastModifiedAt
        self.latestVersion = latestVersion
        self.suiteDefinitionArn = suiteDefinitionArn
        self.suiteDefinitionConfiguration = suiteDefinitionConfiguration
        self.suiteDefinitionId = suiteDefinitionId
        self.suiteDefinitionVersion = suiteDefinitionVersion
        self.tags = tags
    }
}

struct GetSuiteDefinitionOutputBody: Swift.Equatable {
    let suiteDefinitionId: Swift.String?
    let suiteDefinitionArn: Swift.String?
    let suiteDefinitionVersion: Swift.String?
    let latestVersion: Swift.String?
    let suiteDefinitionConfiguration: IotDeviceAdvisorClientTypes.SuiteDefinitionConfiguration?
    let createdAt: ClientRuntime.Date?
    let lastModifiedAt: ClientRuntime.Date?
    let tags: [Swift.String:Swift.String]?
}

extension GetSuiteDefinitionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt
        case lastModifiedAt
        case latestVersion
        case suiteDefinitionArn
        case suiteDefinitionConfiguration
        case suiteDefinitionId
        case suiteDefinitionVersion
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let suiteDefinitionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .suiteDefinitionId)
        suiteDefinitionId = suiteDefinitionIdDecoded
        let suiteDefinitionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .suiteDefinitionArn)
        suiteDefinitionArn = suiteDefinitionArnDecoded
        let suiteDefinitionVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .suiteDefinitionVersion)
        suiteDefinitionVersion = suiteDefinitionVersionDecoded
        let latestVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .latestVersion)
        latestVersion = latestVersionDecoded
        let suiteDefinitionConfigurationDecoded = try containerValues.decodeIfPresent(IotDeviceAdvisorClientTypes.SuiteDefinitionConfiguration.self, forKey: .suiteDefinitionConfiguration)
        suiteDefinitionConfiguration = suiteDefinitionConfigurationDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastModifiedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedAt)
        lastModifiedAt = lastModifiedAtDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string2560) in tagsContainer {
                if let string2560 = string2560 {
                    tagsDecoded0?[key0] = string2560
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum GetSuiteDefinitionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetSuiteRunInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let suiteDefinitionId = suiteDefinitionId else {
            return nil
        }
        guard let suiteRunId = suiteRunId else {
            return nil
        }
        return "/suiteDefinitions/\(suiteDefinitionId.urlPercentEncoding())/suiteRuns/\(suiteRunId.urlPercentEncoding())"
    }
}

public struct GetSuiteRunInput: Swift.Equatable {
    /// Suite definition ID for the test suite run.
    /// This member is required.
    public var suiteDefinitionId: Swift.String?
    /// Suite run ID for the test suite run.
    /// This member is required.
    public var suiteRunId: Swift.String?

    public init(
        suiteDefinitionId: Swift.String? = nil,
        suiteRunId: Swift.String? = nil
    )
    {
        self.suiteDefinitionId = suiteDefinitionId
        self.suiteRunId = suiteRunId
    }
}

struct GetSuiteRunInputBody: Swift.Equatable {
}

extension GetSuiteRunInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetSuiteRunOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetSuiteRunOutputBody = try responseDecoder.decode(responseBody: data)
            self.endTime = output.endTime
            self.errorReason = output.errorReason
            self.startTime = output.startTime
            self.status = output.status
            self.suiteDefinitionId = output.suiteDefinitionId
            self.suiteDefinitionVersion = output.suiteDefinitionVersion
            self.suiteRunArn = output.suiteRunArn
            self.suiteRunConfiguration = output.suiteRunConfiguration
            self.suiteRunId = output.suiteRunId
            self.tags = output.tags
            self.testResult = output.testResult
        } else {
            self.endTime = nil
            self.errorReason = nil
            self.startTime = nil
            self.status = nil
            self.suiteDefinitionId = nil
            self.suiteDefinitionVersion = nil
            self.suiteRunArn = nil
            self.suiteRunConfiguration = nil
            self.suiteRunId = nil
            self.tags = nil
            self.testResult = nil
        }
    }
}

public struct GetSuiteRunOutput: Swift.Equatable {
    /// Date (in Unix epoch time) when the test suite run ended.
    public var endTime: ClientRuntime.Date?
    /// Error reason for any test suite run failure.
    public var errorReason: Swift.String?
    /// Date (in Unix epoch time) when the test suite run started.
    public var startTime: ClientRuntime.Date?
    /// Status for the test suite run.
    public var status: IotDeviceAdvisorClientTypes.SuiteRunStatus?
    /// Suite definition ID for the test suite run.
    public var suiteDefinitionId: Swift.String?
    /// Suite definition version for the test suite run.
    public var suiteDefinitionVersion: Swift.String?
    /// The ARN of the suite run.
    public var suiteRunArn: Swift.String?
    /// Suite run configuration for the test suite run.
    public var suiteRunConfiguration: IotDeviceAdvisorClientTypes.SuiteRunConfiguration?
    /// Suite run ID for the test suite run.
    public var suiteRunId: Swift.String?
    /// The tags attached to the suite run.
    public var tags: [Swift.String:Swift.String]?
    /// Test results for the test suite run.
    public var testResult: IotDeviceAdvisorClientTypes.TestResult?

    public init(
        endTime: ClientRuntime.Date? = nil,
        errorReason: Swift.String? = nil,
        startTime: ClientRuntime.Date? = nil,
        status: IotDeviceAdvisorClientTypes.SuiteRunStatus? = nil,
        suiteDefinitionId: Swift.String? = nil,
        suiteDefinitionVersion: Swift.String? = nil,
        suiteRunArn: Swift.String? = nil,
        suiteRunConfiguration: IotDeviceAdvisorClientTypes.SuiteRunConfiguration? = nil,
        suiteRunId: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        testResult: IotDeviceAdvisorClientTypes.TestResult? = nil
    )
    {
        self.endTime = endTime
        self.errorReason = errorReason
        self.startTime = startTime
        self.status = status
        self.suiteDefinitionId = suiteDefinitionId
        self.suiteDefinitionVersion = suiteDefinitionVersion
        self.suiteRunArn = suiteRunArn
        self.suiteRunConfiguration = suiteRunConfiguration
        self.suiteRunId = suiteRunId
        self.tags = tags
        self.testResult = testResult
    }
}

struct GetSuiteRunOutputBody: Swift.Equatable {
    let suiteDefinitionId: Swift.String?
    let suiteDefinitionVersion: Swift.String?
    let suiteRunId: Swift.String?
    let suiteRunArn: Swift.String?
    let suiteRunConfiguration: IotDeviceAdvisorClientTypes.SuiteRunConfiguration?
    let testResult: IotDeviceAdvisorClientTypes.TestResult?
    let startTime: ClientRuntime.Date?
    let endTime: ClientRuntime.Date?
    let status: IotDeviceAdvisorClientTypes.SuiteRunStatus?
    let errorReason: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension GetSuiteRunOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTime
        case errorReason
        case startTime
        case status
        case suiteDefinitionId
        case suiteDefinitionVersion
        case suiteRunArn
        case suiteRunConfiguration
        case suiteRunId
        case tags
        case testResult
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let suiteDefinitionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .suiteDefinitionId)
        suiteDefinitionId = suiteDefinitionIdDecoded
        let suiteDefinitionVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .suiteDefinitionVersion)
        suiteDefinitionVersion = suiteDefinitionVersionDecoded
        let suiteRunIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .suiteRunId)
        suiteRunId = suiteRunIdDecoded
        let suiteRunArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .suiteRunArn)
        suiteRunArn = suiteRunArnDecoded
        let suiteRunConfigurationDecoded = try containerValues.decodeIfPresent(IotDeviceAdvisorClientTypes.SuiteRunConfiguration.self, forKey: .suiteRunConfiguration)
        suiteRunConfiguration = suiteRunConfigurationDecoded
        let testResultDecoded = try containerValues.decodeIfPresent(IotDeviceAdvisorClientTypes.TestResult.self, forKey: .testResult)
        testResult = testResultDecoded
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endTime)
        endTime = endTimeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(IotDeviceAdvisorClientTypes.SuiteRunStatus.self, forKey: .status)
        status = statusDecoded
        let errorReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorReason)
        errorReason = errorReasonDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string2560) in tagsContainer {
                if let string2560 = string2560 {
                    tagsDecoded0?[key0] = string2560
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum GetSuiteRunOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetSuiteRunReportInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let suiteDefinitionId = suiteDefinitionId else {
            return nil
        }
        guard let suiteRunId = suiteRunId else {
            return nil
        }
        return "/suiteDefinitions/\(suiteDefinitionId.urlPercentEncoding())/suiteRuns/\(suiteRunId.urlPercentEncoding())/report"
    }
}

public struct GetSuiteRunReportInput: Swift.Equatable {
    /// Suite definition ID of the test suite.
    /// This member is required.
    public var suiteDefinitionId: Swift.String?
    /// Suite run ID of the test suite run.
    /// This member is required.
    public var suiteRunId: Swift.String?

    public init(
        suiteDefinitionId: Swift.String? = nil,
        suiteRunId: Swift.String? = nil
    )
    {
        self.suiteDefinitionId = suiteDefinitionId
        self.suiteRunId = suiteRunId
    }
}

struct GetSuiteRunReportInputBody: Swift.Equatable {
}

extension GetSuiteRunReportInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetSuiteRunReportOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetSuiteRunReportOutputBody = try responseDecoder.decode(responseBody: data)
            self.qualificationReportDownloadUrl = output.qualificationReportDownloadUrl
        } else {
            self.qualificationReportDownloadUrl = nil
        }
    }
}

public struct GetSuiteRunReportOutput: Swift.Equatable {
    /// Download URL of the qualification report.
    public var qualificationReportDownloadUrl: Swift.String?

    public init(
        qualificationReportDownloadUrl: Swift.String? = nil
    )
    {
        self.qualificationReportDownloadUrl = qualificationReportDownloadUrl
    }
}

struct GetSuiteRunReportOutputBody: Swift.Equatable {
    let qualificationReportDownloadUrl: Swift.String?
}

extension GetSuiteRunReportOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case qualificationReportDownloadUrl
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let qualificationReportDownloadUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .qualificationReportDownloadUrl)
        qualificationReportDownloadUrl = qualificationReportDownloadUrlDecoded
    }
}

enum GetSuiteRunReportOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension IotDeviceAdvisorClientTypes.GroupResult: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupId
        case groupName
        case tests
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let groupId = self.groupId {
            try encodeContainer.encode(groupId, forKey: .groupId)
        }
        if let groupName = self.groupName {
            try encodeContainer.encode(groupName, forKey: .groupName)
        }
        if let tests = tests {
            var testsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tests)
            for testcaserun0 in tests {
                try testsContainer.encode(testcaserun0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupId)
        groupId = groupIdDecoded
        let groupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupName)
        groupName = groupNameDecoded
        let testsContainer = try containerValues.decodeIfPresent([IotDeviceAdvisorClientTypes.TestCaseRun?].self, forKey: .tests)
        var testsDecoded0:[IotDeviceAdvisorClientTypes.TestCaseRun]? = nil
        if let testsContainer = testsContainer {
            testsDecoded0 = [IotDeviceAdvisorClientTypes.TestCaseRun]()
            for structure0 in testsContainer {
                if let structure0 = structure0 {
                    testsDecoded0?.append(structure0)
                }
            }
        }
        tests = testsDecoded0
    }
}

extension IotDeviceAdvisorClientTypes {
    /// Show Group Result.
    public struct GroupResult: Swift.Equatable {
        /// Group result ID.
        public var groupId: Swift.String?
        /// Group Result Name.
        public var groupName: Swift.String?
        /// Tests under Group Result.
        public var tests: [IotDeviceAdvisorClientTypes.TestCaseRun]?

        public init(
            groupId: Swift.String? = nil,
            groupName: Swift.String? = nil,
            tests: [IotDeviceAdvisorClientTypes.TestCaseRun]? = nil
        )
        {
            self.groupId = groupId
            self.groupName = groupName
            self.tests = tests
        }
    }

}

extension InternalServerException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Sends an Internal Failure exception.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Sends an Internal Failure Exception message.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListSuiteDefinitionsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            return items
        }
    }
}

extension ListSuiteDefinitionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/suiteDefinitions"
    }
}

public struct ListSuiteDefinitionsInput: Swift.Equatable {
    /// The maximum number of results to return at once.
    public var maxResults: Swift.Int?
    /// A token used to get the next set of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListSuiteDefinitionsInputBody: Swift.Equatable {
}

extension ListSuiteDefinitionsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListSuiteDefinitionsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListSuiteDefinitionsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.suiteDefinitionInformationList = output.suiteDefinitionInformationList
        } else {
            self.nextToken = nil
            self.suiteDefinitionInformationList = nil
        }
    }
}

public struct ListSuiteDefinitionsOutput: Swift.Equatable {
    /// A token used to get the next set of results.
    public var nextToken: Swift.String?
    /// An array of objects that provide summaries of information about the suite definitions in the list.
    public var suiteDefinitionInformationList: [IotDeviceAdvisorClientTypes.SuiteDefinitionInformation]?

    public init(
        nextToken: Swift.String? = nil,
        suiteDefinitionInformationList: [IotDeviceAdvisorClientTypes.SuiteDefinitionInformation]? = nil
    )
    {
        self.nextToken = nextToken
        self.suiteDefinitionInformationList = suiteDefinitionInformationList
    }
}

struct ListSuiteDefinitionsOutputBody: Swift.Equatable {
    let suiteDefinitionInformationList: [IotDeviceAdvisorClientTypes.SuiteDefinitionInformation]?
    let nextToken: Swift.String?
}

extension ListSuiteDefinitionsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case suiteDefinitionInformationList
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let suiteDefinitionInformationListContainer = try containerValues.decodeIfPresent([IotDeviceAdvisorClientTypes.SuiteDefinitionInformation?].self, forKey: .suiteDefinitionInformationList)
        var suiteDefinitionInformationListDecoded0:[IotDeviceAdvisorClientTypes.SuiteDefinitionInformation]? = nil
        if let suiteDefinitionInformationListContainer = suiteDefinitionInformationListContainer {
            suiteDefinitionInformationListDecoded0 = [IotDeviceAdvisorClientTypes.SuiteDefinitionInformation]()
            for structure0 in suiteDefinitionInformationListContainer {
                if let structure0 = structure0 {
                    suiteDefinitionInformationListDecoded0?.append(structure0)
                }
            }
        }
        suiteDefinitionInformationList = suiteDefinitionInformationListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListSuiteDefinitionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListSuiteRunsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let suiteDefinitionId = suiteDefinitionId {
                let suiteDefinitionIdQueryItem = ClientRuntime.URLQueryItem(name: "suiteDefinitionId".urlPercentEncoding(), value: Swift.String(suiteDefinitionId).urlPercentEncoding())
                items.append(suiteDefinitionIdQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let suiteDefinitionVersion = suiteDefinitionVersion {
                let suiteDefinitionVersionQueryItem = ClientRuntime.URLQueryItem(name: "suiteDefinitionVersion".urlPercentEncoding(), value: Swift.String(suiteDefinitionVersion).urlPercentEncoding())
                items.append(suiteDefinitionVersionQueryItem)
            }
            return items
        }
    }
}

extension ListSuiteRunsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/suiteRuns"
    }
}

public struct ListSuiteRunsInput: Swift.Equatable {
    /// The maximum number of results to return at once.
    public var maxResults: Swift.Int?
    /// A token to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// Lists the test suite runs of the specified test suite based on suite definition ID.
    public var suiteDefinitionId: Swift.String?
    /// Must be passed along with suiteDefinitionId. Lists the test suite runs of the specified test suite based on suite definition version.
    public var suiteDefinitionVersion: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        suiteDefinitionId: Swift.String? = nil,
        suiteDefinitionVersion: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.suiteDefinitionId = suiteDefinitionId
        self.suiteDefinitionVersion = suiteDefinitionVersion
    }
}

struct ListSuiteRunsInputBody: Swift.Equatable {
}

extension ListSuiteRunsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListSuiteRunsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListSuiteRunsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.suiteRunsList = output.suiteRunsList
        } else {
            self.nextToken = nil
            self.suiteRunsList = nil
        }
    }
}

public struct ListSuiteRunsOutput: Swift.Equatable {
    /// A token to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// An array of objects that provide summaries of information about the suite runs in the list.
    public var suiteRunsList: [IotDeviceAdvisorClientTypes.SuiteRunInformation]?

    public init(
        nextToken: Swift.String? = nil,
        suiteRunsList: [IotDeviceAdvisorClientTypes.SuiteRunInformation]? = nil
    )
    {
        self.nextToken = nextToken
        self.suiteRunsList = suiteRunsList
    }
}

struct ListSuiteRunsOutputBody: Swift.Equatable {
    let suiteRunsList: [IotDeviceAdvisorClientTypes.SuiteRunInformation]?
    let nextToken: Swift.String?
}

extension ListSuiteRunsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case suiteRunsList
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let suiteRunsListContainer = try containerValues.decodeIfPresent([IotDeviceAdvisorClientTypes.SuiteRunInformation?].self, forKey: .suiteRunsList)
        var suiteRunsListDecoded0:[IotDeviceAdvisorClientTypes.SuiteRunInformation]? = nil
        if let suiteRunsListContainer = suiteRunsListContainer {
            suiteRunsListDecoded0 = [IotDeviceAdvisorClientTypes.SuiteRunInformation]()
            for structure0 in suiteRunsListContainer {
                if let structure0 = structure0 {
                    suiteRunsListDecoded0?.append(structure0)
                }
            }
        }
        suiteRunsList = suiteRunsListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListSuiteRunsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The resource ARN of the IoT Device Advisor resource. This can be SuiteDefinition ARN or SuiteRun ARN.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutput: Swift.Equatable {
    /// The tags attached to the IoT Device Advisor resource.
    public var tags: [Swift.String:Swift.String]?

    public init(
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension ListTagsForResourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string2560) in tagsContainer {
                if let string2560 = string2560 {
                    tagsDecoded0?[key0] = string2560
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum ListTagsForResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension IotDeviceAdvisorClientTypes {
    public enum ModelProtocol: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case mqttv311
        case mqttv311Overwebsocket
        case mqttv5
        case mqttv5Overwebsocket
        case sdkUnknown(Swift.String)

        public static var allCases: [ModelProtocol] {
            return [
                .mqttv311,
                .mqttv311Overwebsocket,
                .mqttv5,
                .mqttv5Overwebsocket,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .mqttv311: return "MqttV3_1_1"
            case .mqttv311Overwebsocket: return "MqttV3_1_1_OverWebSocket"
            case .mqttv5: return "MqttV5"
            case .mqttv5Overwebsocket: return "MqttV5_OverWebSocket"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ModelProtocol(rawValue: rawValue) ?? ModelProtocol.sdkUnknown(rawValue)
        }
    }
}

extension ResourceNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Sends a Resource Not Found exception.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Sends a Resource Not Found Exception message.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension StartSuiteRunInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case suiteDefinitionVersion
        case suiteRunConfiguration
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let suiteDefinitionVersion = self.suiteDefinitionVersion {
            try encodeContainer.encode(suiteDefinitionVersion, forKey: .suiteDefinitionVersion)
        }
        if let suiteRunConfiguration = self.suiteRunConfiguration {
            try encodeContainer.encode(suiteRunConfiguration, forKey: .suiteRunConfiguration)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension StartSuiteRunInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let suiteDefinitionId = suiteDefinitionId else {
            return nil
        }
        return "/suiteDefinitions/\(suiteDefinitionId.urlPercentEncoding())/suiteRuns"
    }
}

public struct StartSuiteRunInput: Swift.Equatable {
    /// Suite definition ID of the test suite.
    /// This member is required.
    public var suiteDefinitionId: Swift.String?
    /// Suite definition version of the test suite.
    public var suiteDefinitionVersion: Swift.String?
    /// Suite run configuration.
    /// This member is required.
    public var suiteRunConfiguration: IotDeviceAdvisorClientTypes.SuiteRunConfiguration?
    /// The tags to be attached to the suite run.
    public var tags: [Swift.String:Swift.String]?

    public init(
        suiteDefinitionId: Swift.String? = nil,
        suiteDefinitionVersion: Swift.String? = nil,
        suiteRunConfiguration: IotDeviceAdvisorClientTypes.SuiteRunConfiguration? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.suiteDefinitionId = suiteDefinitionId
        self.suiteDefinitionVersion = suiteDefinitionVersion
        self.suiteRunConfiguration = suiteRunConfiguration
        self.tags = tags
    }
}

struct StartSuiteRunInputBody: Swift.Equatable {
    let suiteDefinitionVersion: Swift.String?
    let suiteRunConfiguration: IotDeviceAdvisorClientTypes.SuiteRunConfiguration?
    let tags: [Swift.String:Swift.String]?
}

extension StartSuiteRunInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case suiteDefinitionVersion
        case suiteRunConfiguration
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let suiteDefinitionVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .suiteDefinitionVersion)
        suiteDefinitionVersion = suiteDefinitionVersionDecoded
        let suiteRunConfigurationDecoded = try containerValues.decodeIfPresent(IotDeviceAdvisorClientTypes.SuiteRunConfiguration.self, forKey: .suiteRunConfiguration)
        suiteRunConfiguration = suiteRunConfigurationDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string2560) in tagsContainer {
                if let string2560 = string2560 {
                    tagsDecoded0?[key0] = string2560
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension StartSuiteRunOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StartSuiteRunOutputBody = try responseDecoder.decode(responseBody: data)
            self.createdAt = output.createdAt
            self.endpoint = output.endpoint
            self.suiteRunArn = output.suiteRunArn
            self.suiteRunId = output.suiteRunId
        } else {
            self.createdAt = nil
            self.endpoint = nil
            self.suiteRunArn = nil
            self.suiteRunId = nil
        }
    }
}

public struct StartSuiteRunOutput: Swift.Equatable {
    /// Starts a Device Advisor test suite run based on suite create time.
    public var createdAt: ClientRuntime.Date?
    /// The response of an Device Advisor test endpoint.
    public var endpoint: Swift.String?
    /// Amazon Resource Name (ARN) of the started suite run.
    public var suiteRunArn: Swift.String?
    /// Suite Run ID of the started suite run.
    public var suiteRunId: Swift.String?

    public init(
        createdAt: ClientRuntime.Date? = nil,
        endpoint: Swift.String? = nil,
        suiteRunArn: Swift.String? = nil,
        suiteRunId: Swift.String? = nil
    )
    {
        self.createdAt = createdAt
        self.endpoint = endpoint
        self.suiteRunArn = suiteRunArn
        self.suiteRunId = suiteRunId
    }
}

struct StartSuiteRunOutputBody: Swift.Equatable {
    let suiteRunId: Swift.String?
    let suiteRunArn: Swift.String?
    let createdAt: ClientRuntime.Date?
    let endpoint: Swift.String?
}

extension StartSuiteRunOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt
        case endpoint
        case suiteRunArn
        case suiteRunId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let suiteRunIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .suiteRunId)
        suiteRunId = suiteRunIdDecoded
        let suiteRunArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .suiteRunArn)
        suiteRunArn = suiteRunArnDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let endpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpoint)
        endpoint = endpointDecoded
    }
}

enum StartSuiteRunOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension IotDeviceAdvisorClientTypes {
    public enum Status: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case canceled
        case error
        case fail
        case pass
        case passWithWarnings
        case pending
        case running
        case stopped
        case stopping
        case sdkUnknown(Swift.String)

        public static var allCases: [Status] {
            return [
                .canceled,
                .error,
                .fail,
                .pass,
                .passWithWarnings,
                .pending,
                .running,
                .stopped,
                .stopping,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .canceled: return "CANCELED"
            case .error: return "ERROR"
            case .fail: return "FAIL"
            case .pass: return "PASS"
            case .passWithWarnings: return "PASS_WITH_WARNINGS"
            case .pending: return "PENDING"
            case .running: return "RUNNING"
            case .stopped: return "STOPPED"
            case .stopping: return "STOPPING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Status(rawValue: rawValue) ?? Status.sdkUnknown(rawValue)
        }
    }
}

extension StopSuiteRunInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let suiteDefinitionId = suiteDefinitionId else {
            return nil
        }
        guard let suiteRunId = suiteRunId else {
            return nil
        }
        return "/suiteDefinitions/\(suiteDefinitionId.urlPercentEncoding())/suiteRuns/\(suiteRunId.urlPercentEncoding())/stop"
    }
}

public struct StopSuiteRunInput: Swift.Equatable {
    /// Suite definition ID of the test suite run to be stopped.
    /// This member is required.
    public var suiteDefinitionId: Swift.String?
    /// Suite run ID of the test suite run to be stopped.
    /// This member is required.
    public var suiteRunId: Swift.String?

    public init(
        suiteDefinitionId: Swift.String? = nil,
        suiteRunId: Swift.String? = nil
    )
    {
        self.suiteDefinitionId = suiteDefinitionId
        self.suiteRunId = suiteRunId
    }
}

struct StopSuiteRunInputBody: Swift.Equatable {
}

extension StopSuiteRunInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension StopSuiteRunOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct StopSuiteRunOutput: Swift.Equatable {

    public init() { }
}

enum StopSuiteRunOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension IotDeviceAdvisorClientTypes.SuiteDefinitionConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case devicePermissionRoleArn
        case devices
        case intendedForQualification
        case isLongDurationTest
        case `protocol` = "protocol"
        case rootGroup
        case suiteDefinitionName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let devicePermissionRoleArn = self.devicePermissionRoleArn {
            try encodeContainer.encode(devicePermissionRoleArn, forKey: .devicePermissionRoleArn)
        }
        if let devices = devices {
            var devicesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .devices)
            for deviceundertest0 in devices {
                try devicesContainer.encode(deviceundertest0)
            }
        }
        if intendedForQualification != false {
            try encodeContainer.encode(intendedForQualification, forKey: .intendedForQualification)
        }
        if isLongDurationTest != false {
            try encodeContainer.encode(isLongDurationTest, forKey: .isLongDurationTest)
        }
        if let `protocol` = self.`protocol` {
            try encodeContainer.encode(`protocol`.rawValue, forKey: .`protocol`)
        }
        if let rootGroup = self.rootGroup {
            try encodeContainer.encode(rootGroup, forKey: .rootGroup)
        }
        if let suiteDefinitionName = self.suiteDefinitionName {
            try encodeContainer.encode(suiteDefinitionName, forKey: .suiteDefinitionName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let suiteDefinitionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .suiteDefinitionName)
        suiteDefinitionName = suiteDefinitionNameDecoded
        let devicesContainer = try containerValues.decodeIfPresent([IotDeviceAdvisorClientTypes.DeviceUnderTest?].self, forKey: .devices)
        var devicesDecoded0:[IotDeviceAdvisorClientTypes.DeviceUnderTest]? = nil
        if let devicesContainer = devicesContainer {
            devicesDecoded0 = [IotDeviceAdvisorClientTypes.DeviceUnderTest]()
            for structure0 in devicesContainer {
                if let structure0 = structure0 {
                    devicesDecoded0?.append(structure0)
                }
            }
        }
        devices = devicesDecoded0
        let intendedForQualificationDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .intendedForQualification) ?? false
        intendedForQualification = intendedForQualificationDecoded
        let isLongDurationTestDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isLongDurationTest) ?? false
        isLongDurationTest = isLongDurationTestDecoded
        let rootGroupDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .rootGroup)
        rootGroup = rootGroupDecoded
        let devicePermissionRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .devicePermissionRoleArn)
        devicePermissionRoleArn = devicePermissionRoleArnDecoded
        let protocolDecoded = try containerValues.decodeIfPresent(IotDeviceAdvisorClientTypes.ModelProtocol.self, forKey: .protocol)
        `protocol` = protocolDecoded
    }
}

extension IotDeviceAdvisorClientTypes {
    /// Gets the suite definition configuration.
    public struct SuiteDefinitionConfiguration: Swift.Equatable {
        /// Gets the device permission ARN. This is a required parameter.
        /// This member is required.
        public var devicePermissionRoleArn: Swift.String?
        /// Gets the devices configured.
        public var devices: [IotDeviceAdvisorClientTypes.DeviceUnderTest]?
        /// Gets the tests intended for qualification in a suite.
        public var intendedForQualification: Swift.Bool
        /// Verifies if the test suite is a long duration test.
        public var isLongDurationTest: Swift.Bool
        /// Sets the MQTT protocol that is configured in the suite definition.
        public var `protocol`: IotDeviceAdvisorClientTypes.ModelProtocol?
        /// Gets the test suite root group. This is a required parameter. For updating or creating the latest qualification suite, if intendedForQualification is set to true, rootGroup can be an empty string. If intendedForQualification is false, rootGroup cannot be an empty string. If rootGroup is empty, and intendedForQualification is set to true, all the qualification tests are included, and the configuration is default. For a qualification suite, the minimum length is 0, and the maximum is 2048. For a non-qualification suite, the minimum length is 1, and the maximum is 2048.
        /// This member is required.
        public var rootGroup: Swift.String?
        /// Gets the suite definition name. This is a required parameter.
        /// This member is required.
        public var suiteDefinitionName: Swift.String?

        public init(
            devicePermissionRoleArn: Swift.String? = nil,
            devices: [IotDeviceAdvisorClientTypes.DeviceUnderTest]? = nil,
            intendedForQualification: Swift.Bool = false,
            isLongDurationTest: Swift.Bool = false,
            `protocol`: IotDeviceAdvisorClientTypes.ModelProtocol? = nil,
            rootGroup: Swift.String? = nil,
            suiteDefinitionName: Swift.String? = nil
        )
        {
            self.devicePermissionRoleArn = devicePermissionRoleArn
            self.devices = devices
            self.intendedForQualification = intendedForQualification
            self.isLongDurationTest = isLongDurationTest
            self.`protocol` = `protocol`
            self.rootGroup = rootGroup
            self.suiteDefinitionName = suiteDefinitionName
        }
    }

}

extension IotDeviceAdvisorClientTypes.SuiteDefinitionInformation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt
        case defaultDevices
        case intendedForQualification
        case isLongDurationTest
        case `protocol` = "protocol"
        case suiteDefinitionId
        case suiteDefinitionName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let defaultDevices = defaultDevices {
            var defaultDevicesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .defaultDevices)
            for deviceundertest0 in defaultDevices {
                try defaultDevicesContainer.encode(deviceundertest0)
            }
        }
        if intendedForQualification != false {
            try encodeContainer.encode(intendedForQualification, forKey: .intendedForQualification)
        }
        if isLongDurationTest != false {
            try encodeContainer.encode(isLongDurationTest, forKey: .isLongDurationTest)
        }
        if let `protocol` = self.`protocol` {
            try encodeContainer.encode(`protocol`.rawValue, forKey: .`protocol`)
        }
        if let suiteDefinitionId = self.suiteDefinitionId {
            try encodeContainer.encode(suiteDefinitionId, forKey: .suiteDefinitionId)
        }
        if let suiteDefinitionName = self.suiteDefinitionName {
            try encodeContainer.encode(suiteDefinitionName, forKey: .suiteDefinitionName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let suiteDefinitionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .suiteDefinitionId)
        suiteDefinitionId = suiteDefinitionIdDecoded
        let suiteDefinitionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .suiteDefinitionName)
        suiteDefinitionName = suiteDefinitionNameDecoded
        let defaultDevicesContainer = try containerValues.decodeIfPresent([IotDeviceAdvisorClientTypes.DeviceUnderTest?].self, forKey: .defaultDevices)
        var defaultDevicesDecoded0:[IotDeviceAdvisorClientTypes.DeviceUnderTest]? = nil
        if let defaultDevicesContainer = defaultDevicesContainer {
            defaultDevicesDecoded0 = [IotDeviceAdvisorClientTypes.DeviceUnderTest]()
            for structure0 in defaultDevicesContainer {
                if let structure0 = structure0 {
                    defaultDevicesDecoded0?.append(structure0)
                }
            }
        }
        defaultDevices = defaultDevicesDecoded0
        let intendedForQualificationDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .intendedForQualification) ?? false
        intendedForQualification = intendedForQualificationDecoded
        let isLongDurationTestDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isLongDurationTest) ?? false
        isLongDurationTest = isLongDurationTestDecoded
        let protocolDecoded = try containerValues.decodeIfPresent(IotDeviceAdvisorClientTypes.ModelProtocol.self, forKey: .protocol)
        `protocol` = protocolDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
    }
}

extension IotDeviceAdvisorClientTypes {
    /// Information about the suite definition.
    public struct SuiteDefinitionInformation: Swift.Equatable {
        /// Date (in Unix epoch time) when the test suite was created.
        public var createdAt: ClientRuntime.Date?
        /// Specifies the devices that are under test for the test suite.
        public var defaultDevices: [IotDeviceAdvisorClientTypes.DeviceUnderTest]?
        /// Specifies if the test suite is intended for qualification.
        public var intendedForQualification: Swift.Bool
        /// Verifies if the test suite is a long duration test.
        public var isLongDurationTest: Swift.Bool
        /// Gets the MQTT protocol that is configured in the suite definition.
        public var `protocol`: IotDeviceAdvisorClientTypes.ModelProtocol?
        /// Suite definition ID of the test suite.
        public var suiteDefinitionId: Swift.String?
        /// Suite name of the test suite.
        public var suiteDefinitionName: Swift.String?

        public init(
            createdAt: ClientRuntime.Date? = nil,
            defaultDevices: [IotDeviceAdvisorClientTypes.DeviceUnderTest]? = nil,
            intendedForQualification: Swift.Bool = false,
            isLongDurationTest: Swift.Bool = false,
            `protocol`: IotDeviceAdvisorClientTypes.ModelProtocol? = nil,
            suiteDefinitionId: Swift.String? = nil,
            suiteDefinitionName: Swift.String? = nil
        )
        {
            self.createdAt = createdAt
            self.defaultDevices = defaultDevices
            self.intendedForQualification = intendedForQualification
            self.isLongDurationTest = isLongDurationTest
            self.`protocol` = `protocol`
            self.suiteDefinitionId = suiteDefinitionId
            self.suiteDefinitionName = suiteDefinitionName
        }
    }

}

extension IotDeviceAdvisorClientTypes.SuiteRunConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case parallelRun
        case primaryDevice
        case selectedTestList
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if parallelRun != false {
            try encodeContainer.encode(parallelRun, forKey: .parallelRun)
        }
        if let primaryDevice = self.primaryDevice {
            try encodeContainer.encode(primaryDevice, forKey: .primaryDevice)
        }
        if let selectedTestList = selectedTestList {
            var selectedTestListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .selectedTestList)
            for uuid0 in selectedTestList {
                try selectedTestListContainer.encode(uuid0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let primaryDeviceDecoded = try containerValues.decodeIfPresent(IotDeviceAdvisorClientTypes.DeviceUnderTest.self, forKey: .primaryDevice)
        primaryDevice = primaryDeviceDecoded
        let selectedTestListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .selectedTestList)
        var selectedTestListDecoded0:[Swift.String]? = nil
        if let selectedTestListContainer = selectedTestListContainer {
            selectedTestListDecoded0 = [Swift.String]()
            for string0 in selectedTestListContainer {
                if let string0 = string0 {
                    selectedTestListDecoded0?.append(string0)
                }
            }
        }
        selectedTestList = selectedTestListDecoded0
        let parallelRunDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .parallelRun) ?? false
        parallelRun = parallelRunDecoded
    }
}

extension IotDeviceAdvisorClientTypes {
    /// Gets suite run configuration.
    public struct SuiteRunConfiguration: Swift.Equatable {
        /// TRUE if multiple test suites run in parallel.
        public var parallelRun: Swift.Bool
        /// Sets the primary device for the test suite run. This requires a thing ARN or a certificate ARN.
        /// This member is required.
        public var primaryDevice: IotDeviceAdvisorClientTypes.DeviceUnderTest?
        /// Sets test case list.
        public var selectedTestList: [Swift.String]?

        public init(
            parallelRun: Swift.Bool = false,
            primaryDevice: IotDeviceAdvisorClientTypes.DeviceUnderTest? = nil,
            selectedTestList: [Swift.String]? = nil
        )
        {
            self.parallelRun = parallelRun
            self.primaryDevice = primaryDevice
            self.selectedTestList = selectedTestList
        }
    }

}

extension IotDeviceAdvisorClientTypes.SuiteRunInformation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt
        case endAt
        case failed
        case passed
        case startedAt
        case status
        case suiteDefinitionId
        case suiteDefinitionName
        case suiteDefinitionVersion
        case suiteRunId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let endAt = self.endAt {
            try encodeContainer.encodeTimestamp(endAt, format: .epochSeconds, forKey: .endAt)
        }
        if failed != 0 {
            try encodeContainer.encode(failed, forKey: .failed)
        }
        if passed != 0 {
            try encodeContainer.encode(passed, forKey: .passed)
        }
        if let startedAt = self.startedAt {
            try encodeContainer.encodeTimestamp(startedAt, format: .epochSeconds, forKey: .startedAt)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let suiteDefinitionId = self.suiteDefinitionId {
            try encodeContainer.encode(suiteDefinitionId, forKey: .suiteDefinitionId)
        }
        if let suiteDefinitionName = self.suiteDefinitionName {
            try encodeContainer.encode(suiteDefinitionName, forKey: .suiteDefinitionName)
        }
        if let suiteDefinitionVersion = self.suiteDefinitionVersion {
            try encodeContainer.encode(suiteDefinitionVersion, forKey: .suiteDefinitionVersion)
        }
        if let suiteRunId = self.suiteRunId {
            try encodeContainer.encode(suiteRunId, forKey: .suiteRunId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let suiteDefinitionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .suiteDefinitionId)
        suiteDefinitionId = suiteDefinitionIdDecoded
        let suiteDefinitionVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .suiteDefinitionVersion)
        suiteDefinitionVersion = suiteDefinitionVersionDecoded
        let suiteDefinitionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .suiteDefinitionName)
        suiteDefinitionName = suiteDefinitionNameDecoded
        let suiteRunIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .suiteRunId)
        suiteRunId = suiteRunIdDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let startedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startedAt)
        startedAt = startedAtDecoded
        let endAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endAt)
        endAt = endAtDecoded
        let statusDecoded = try containerValues.decodeIfPresent(IotDeviceAdvisorClientTypes.SuiteRunStatus.self, forKey: .status)
        status = statusDecoded
        let passedDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .passed) ?? 0
        passed = passedDecoded
        let failedDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .failed) ?? 0
        failed = failedDecoded
    }
}

extension IotDeviceAdvisorClientTypes {
    /// Information about the suite run. Requires permission to access the [SuiteRunInformation](https://docs.aws.amazon.com/service-authorization/latest/reference/list_awsiot.html#awsiot-actions-as-permissions) action.
    public struct SuiteRunInformation: Swift.Equatable {
        /// Date (in Unix epoch time) when the suite run was created.
        public var createdAt: ClientRuntime.Date?
        /// Date (in Unix epoch time) when the suite run ended.
        public var endAt: ClientRuntime.Date?
        /// Number of test cases that failed in the suite run.
        public var failed: Swift.Int
        /// Number of test cases that passed in the suite run.
        public var passed: Swift.Int
        /// Date (in Unix epoch time) when the suite run was started.
        public var startedAt: ClientRuntime.Date?
        /// Status of the suite run.
        public var status: IotDeviceAdvisorClientTypes.SuiteRunStatus?
        /// Suite definition ID of the suite run.
        public var suiteDefinitionId: Swift.String?
        /// Suite definition name of the suite run.
        public var suiteDefinitionName: Swift.String?
        /// Suite definition version of the suite run.
        public var suiteDefinitionVersion: Swift.String?
        /// Suite run ID of the suite run.
        public var suiteRunId: Swift.String?

        public init(
            createdAt: ClientRuntime.Date? = nil,
            endAt: ClientRuntime.Date? = nil,
            failed: Swift.Int = 0,
            passed: Swift.Int = 0,
            startedAt: ClientRuntime.Date? = nil,
            status: IotDeviceAdvisorClientTypes.SuiteRunStatus? = nil,
            suiteDefinitionId: Swift.String? = nil,
            suiteDefinitionName: Swift.String? = nil,
            suiteDefinitionVersion: Swift.String? = nil,
            suiteRunId: Swift.String? = nil
        )
        {
            self.createdAt = createdAt
            self.endAt = endAt
            self.failed = failed
            self.passed = passed
            self.startedAt = startedAt
            self.status = status
            self.suiteDefinitionId = suiteDefinitionId
            self.suiteDefinitionName = suiteDefinitionName
            self.suiteDefinitionVersion = suiteDefinitionVersion
            self.suiteRunId = suiteRunId
        }
    }

}

extension IotDeviceAdvisorClientTypes {
    public enum SuiteRunStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case canceled
        case error
        case fail
        case pass
        case passWithWarnings
        case pending
        case running
        case stopped
        case stopping
        case sdkUnknown(Swift.String)

        public static var allCases: [SuiteRunStatus] {
            return [
                .canceled,
                .error,
                .fail,
                .pass,
                .passWithWarnings,
                .pending,
                .running,
                .stopped,
                .stopping,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .canceled: return "CANCELED"
            case .error: return "ERROR"
            case .fail: return "FAIL"
            case .pass: return "PASS"
            case .passWithWarnings: return "PASS_WITH_WARNINGS"
            case .pending: return "PENDING"
            case .running: return "RUNNING"
            case .stopped: return "STOPPED"
            case .stopping: return "STOPPING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SuiteRunStatus(rawValue: rawValue) ?? SuiteRunStatus.sdkUnknown(rawValue)
        }
    }
}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The resource ARN of an IoT Device Advisor resource. This can be SuiteDefinition ARN or SuiteRun ARN.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tags to be attached to the IoT Device Advisor resource.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string2560) in tagsContainer {
                if let string2560 = string2560 {
                    tagsDecoded0?[key0] = string2560
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct TagResourceOutput: Swift.Equatable {

    public init() { }
}

enum TagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension IotDeviceAdvisorClientTypes.TestCaseRun: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTime
        case failure
        case logUrl
        case startTime
        case status
        case testCaseDefinitionId
        case testCaseDefinitionName
        case testCaseRunId
        case testScenarios
        case warnings
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endTime = self.endTime {
            try encodeContainer.encodeTimestamp(endTime, format: .epochSeconds, forKey: .endTime)
        }
        if let failure = self.failure {
            try encodeContainer.encode(failure, forKey: .failure)
        }
        if let logUrl = self.logUrl {
            try encodeContainer.encode(logUrl, forKey: .logUrl)
        }
        if let startTime = self.startTime {
            try encodeContainer.encodeTimestamp(startTime, format: .epochSeconds, forKey: .startTime)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let testCaseDefinitionId = self.testCaseDefinitionId {
            try encodeContainer.encode(testCaseDefinitionId, forKey: .testCaseDefinitionId)
        }
        if let testCaseDefinitionName = self.testCaseDefinitionName {
            try encodeContainer.encode(testCaseDefinitionName, forKey: .testCaseDefinitionName)
        }
        if let testCaseRunId = self.testCaseRunId {
            try encodeContainer.encode(testCaseRunId, forKey: .testCaseRunId)
        }
        if let testScenarios = testScenarios {
            var testScenariosContainer = encodeContainer.nestedUnkeyedContainer(forKey: .testScenarios)
            for testcasescenario0 in testScenarios {
                try testScenariosContainer.encode(testcasescenario0)
            }
        }
        if let warnings = self.warnings {
            try encodeContainer.encode(warnings, forKey: .warnings)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let testCaseRunIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .testCaseRunId)
        testCaseRunId = testCaseRunIdDecoded
        let testCaseDefinitionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .testCaseDefinitionId)
        testCaseDefinitionId = testCaseDefinitionIdDecoded
        let testCaseDefinitionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .testCaseDefinitionName)
        testCaseDefinitionName = testCaseDefinitionNameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(IotDeviceAdvisorClientTypes.Status.self, forKey: .status)
        status = statusDecoded
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endTime)
        endTime = endTimeDecoded
        let logUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .logUrl)
        logUrl = logUrlDecoded
        let warningsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .warnings)
        warnings = warningsDecoded
        let failureDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failure)
        failure = failureDecoded
        let testScenariosContainer = try containerValues.decodeIfPresent([IotDeviceAdvisorClientTypes.TestCaseScenario?].self, forKey: .testScenarios)
        var testScenariosDecoded0:[IotDeviceAdvisorClientTypes.TestCaseScenario]? = nil
        if let testScenariosContainer = testScenariosContainer {
            testScenariosDecoded0 = [IotDeviceAdvisorClientTypes.TestCaseScenario]()
            for structure0 in testScenariosContainer {
                if let structure0 = structure0 {
                    testScenariosDecoded0?.append(structure0)
                }
            }
        }
        testScenarios = testScenariosDecoded0
    }
}

extension IotDeviceAdvisorClientTypes {
    /// Provides the test case run.
    public struct TestCaseRun: Swift.Equatable {
        /// Provides test case run end time.
        public var endTime: ClientRuntime.Date?
        /// Provides test case run failure result.
        public var failure: Swift.String?
        /// Provides test case run log URL.
        public var logUrl: Swift.String?
        /// Provides test case run start time.
        public var startTime: ClientRuntime.Date?
        /// Provides the test case run status. Status is one of the following:
        ///
        /// * PASS: Test passed.
        ///
        /// * FAIL: Test failed.
        ///
        /// * PENDING: Test has not started running but is scheduled.
        ///
        /// * RUNNING: Test is running.
        ///
        /// * STOPPING: Test is performing cleanup steps. You will see this status only if you stop a suite run.
        ///
        /// * STOPPED Test is stopped. You will see this status only if you stop a suite run.
        ///
        /// * PASS_WITH_WARNINGS: Test passed with warnings.
        ///
        /// * ERORR: Test faced an error when running due to an internal issue.
        public var status: IotDeviceAdvisorClientTypes.Status?
        /// Provides the test case run definition ID.
        public var testCaseDefinitionId: Swift.String?
        /// Provides the test case run definition name.
        public var testCaseDefinitionName: Swift.String?
        /// Provides the test case run ID.
        public var testCaseRunId: Swift.String?
        /// Provides the test scenarios for the test case run.
        public var testScenarios: [IotDeviceAdvisorClientTypes.TestCaseScenario]?
        /// Provides test case run warnings.
        public var warnings: Swift.String?

        public init(
            endTime: ClientRuntime.Date? = nil,
            failure: Swift.String? = nil,
            logUrl: Swift.String? = nil,
            startTime: ClientRuntime.Date? = nil,
            status: IotDeviceAdvisorClientTypes.Status? = nil,
            testCaseDefinitionId: Swift.String? = nil,
            testCaseDefinitionName: Swift.String? = nil,
            testCaseRunId: Swift.String? = nil,
            testScenarios: [IotDeviceAdvisorClientTypes.TestCaseScenario]? = nil,
            warnings: Swift.String? = nil
        )
        {
            self.endTime = endTime
            self.failure = failure
            self.logUrl = logUrl
            self.startTime = startTime
            self.status = status
            self.testCaseDefinitionId = testCaseDefinitionId
            self.testCaseDefinitionName = testCaseDefinitionName
            self.testCaseRunId = testCaseRunId
            self.testScenarios = testScenarios
            self.warnings = warnings
        }
    }

}

extension IotDeviceAdvisorClientTypes.TestCaseScenario: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failure
        case status
        case systemMessage
        case testCaseScenarioId
        case testCaseScenarioType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let failure = self.failure {
            try encodeContainer.encode(failure, forKey: .failure)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let systemMessage = self.systemMessage {
            try encodeContainer.encode(systemMessage, forKey: .systemMessage)
        }
        if let testCaseScenarioId = self.testCaseScenarioId {
            try encodeContainer.encode(testCaseScenarioId, forKey: .testCaseScenarioId)
        }
        if let testCaseScenarioType = self.testCaseScenarioType {
            try encodeContainer.encode(testCaseScenarioType.rawValue, forKey: .testCaseScenarioType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let testCaseScenarioIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .testCaseScenarioId)
        testCaseScenarioId = testCaseScenarioIdDecoded
        let testCaseScenarioTypeDecoded = try containerValues.decodeIfPresent(IotDeviceAdvisorClientTypes.TestCaseScenarioType.self, forKey: .testCaseScenarioType)
        testCaseScenarioType = testCaseScenarioTypeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(IotDeviceAdvisorClientTypes.TestCaseScenarioStatus.self, forKey: .status)
        status = statusDecoded
        let failureDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failure)
        failure = failureDecoded
        let systemMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .systemMessage)
        systemMessage = systemMessageDecoded
    }
}

extension IotDeviceAdvisorClientTypes {
    /// Provides test case scenario.
    public struct TestCaseScenario: Swift.Equatable {
        /// Provides test case scenario failure result.
        public var failure: Swift.String?
        /// Provides the test case scenario status. Status is one of the following:
        ///
        /// * PASS: Test passed.
        ///
        /// * FAIL: Test failed.
        ///
        /// * PENDING: Test has not started running but is scheduled.
        ///
        /// * RUNNING: Test is running.
        ///
        /// * STOPPING: Test is performing cleanup steps. You will see this status only if you stop a suite run.
        ///
        /// * STOPPED Test is stopped. You will see this status only if you stop a suite run.
        ///
        /// * PASS_WITH_WARNINGS: Test passed with warnings.
        ///
        /// * ERORR: Test faced an error when running due to an internal issue.
        public var status: IotDeviceAdvisorClientTypes.TestCaseScenarioStatus?
        /// Provides test case scenario system messages if any.
        public var systemMessage: Swift.String?
        /// Provides test case scenario ID.
        public var testCaseScenarioId: Swift.String?
        /// Provides test case scenario type. Type is one of the following:
        ///
        /// * Advanced
        ///
        /// * Basic
        public var testCaseScenarioType: IotDeviceAdvisorClientTypes.TestCaseScenarioType?

        public init(
            failure: Swift.String? = nil,
            status: IotDeviceAdvisorClientTypes.TestCaseScenarioStatus? = nil,
            systemMessage: Swift.String? = nil,
            testCaseScenarioId: Swift.String? = nil,
            testCaseScenarioType: IotDeviceAdvisorClientTypes.TestCaseScenarioType? = nil
        )
        {
            self.failure = failure
            self.status = status
            self.systemMessage = systemMessage
            self.testCaseScenarioId = testCaseScenarioId
            self.testCaseScenarioType = testCaseScenarioType
        }
    }

}

extension IotDeviceAdvisorClientTypes {
    public enum TestCaseScenarioStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case canceled
        case error
        case fail
        case pass
        case passWithWarnings
        case pending
        case running
        case stopped
        case stopping
        case sdkUnknown(Swift.String)

        public static var allCases: [TestCaseScenarioStatus] {
            return [
                .canceled,
                .error,
                .fail,
                .pass,
                .passWithWarnings,
                .pending,
                .running,
                .stopped,
                .stopping,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .canceled: return "CANCELED"
            case .error: return "ERROR"
            case .fail: return "FAIL"
            case .pass: return "PASS"
            case .passWithWarnings: return "PASS_WITH_WARNINGS"
            case .pending: return "PENDING"
            case .running: return "RUNNING"
            case .stopped: return "STOPPED"
            case .stopping: return "STOPPING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TestCaseScenarioStatus(rawValue: rawValue) ?? TestCaseScenarioStatus.sdkUnknown(rawValue)
        }
    }
}

extension IotDeviceAdvisorClientTypes {
    public enum TestCaseScenarioType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case advanced
        case basic
        case sdkUnknown(Swift.String)

        public static var allCases: [TestCaseScenarioType] {
            return [
                .advanced,
                .basic,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .advanced: return "Advanced"
            case .basic: return "Basic"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TestCaseScenarioType(rawValue: rawValue) ?? TestCaseScenarioType.sdkUnknown(rawValue)
        }
    }
}

extension IotDeviceAdvisorClientTypes.TestResult: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groups
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let groups = groups {
            var groupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .groups)
            for groupresult0 in groups {
                try groupsContainer.encode(groupresult0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupsContainer = try containerValues.decodeIfPresent([IotDeviceAdvisorClientTypes.GroupResult?].self, forKey: .groups)
        var groupsDecoded0:[IotDeviceAdvisorClientTypes.GroupResult]? = nil
        if let groupsContainer = groupsContainer {
            groupsDecoded0 = [IotDeviceAdvisorClientTypes.GroupResult]()
            for structure0 in groupsContainer {
                if let structure0 = structure0 {
                    groupsDecoded0?.append(structure0)
                }
            }
        }
        groups = groupsDecoded0
    }
}

extension IotDeviceAdvisorClientTypes {
    /// Show each group result.
    public struct TestResult: Swift.Equatable {
        /// Show each group of test results.
        public var groups: [IotDeviceAdvisorClientTypes.GroupResult]?

        public init(
            groups: [IotDeviceAdvisorClientTypes.GroupResult]? = nil
        )
        {
            self.groups = groups
        }
    }

}

extension UntagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let tagKeys = tagKeys else {
                let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
            return items
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The resource ARN of an IoT Device Advisor resource. This can be SuiteDefinition ARN or SuiteRun ARN.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// List of tag keys to remove from the IoT Device Advisor resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UntagResourceOutput: Swift.Equatable {

    public init() { }
}

enum UntagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateSuiteDefinitionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case suiteDefinitionConfiguration
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let suiteDefinitionConfiguration = self.suiteDefinitionConfiguration {
            try encodeContainer.encode(suiteDefinitionConfiguration, forKey: .suiteDefinitionConfiguration)
        }
    }
}

extension UpdateSuiteDefinitionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let suiteDefinitionId = suiteDefinitionId else {
            return nil
        }
        return "/suiteDefinitions/\(suiteDefinitionId.urlPercentEncoding())"
    }
}

public struct UpdateSuiteDefinitionInput: Swift.Equatable {
    /// Updates a Device Advisor test suite with suite definition configuration.
    /// This member is required.
    public var suiteDefinitionConfiguration: IotDeviceAdvisorClientTypes.SuiteDefinitionConfiguration?
    /// Suite definition ID of the test suite to be updated.
    /// This member is required.
    public var suiteDefinitionId: Swift.String?

    public init(
        suiteDefinitionConfiguration: IotDeviceAdvisorClientTypes.SuiteDefinitionConfiguration? = nil,
        suiteDefinitionId: Swift.String? = nil
    )
    {
        self.suiteDefinitionConfiguration = suiteDefinitionConfiguration
        self.suiteDefinitionId = suiteDefinitionId
    }
}

struct UpdateSuiteDefinitionInputBody: Swift.Equatable {
    let suiteDefinitionConfiguration: IotDeviceAdvisorClientTypes.SuiteDefinitionConfiguration?
}

extension UpdateSuiteDefinitionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case suiteDefinitionConfiguration
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let suiteDefinitionConfigurationDecoded = try containerValues.decodeIfPresent(IotDeviceAdvisorClientTypes.SuiteDefinitionConfiguration.self, forKey: .suiteDefinitionConfiguration)
        suiteDefinitionConfiguration = suiteDefinitionConfigurationDecoded
    }
}

extension UpdateSuiteDefinitionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateSuiteDefinitionOutputBody = try responseDecoder.decode(responseBody: data)
            self.createdAt = output.createdAt
            self.lastUpdatedAt = output.lastUpdatedAt
            self.suiteDefinitionArn = output.suiteDefinitionArn
            self.suiteDefinitionId = output.suiteDefinitionId
            self.suiteDefinitionName = output.suiteDefinitionName
            self.suiteDefinitionVersion = output.suiteDefinitionVersion
        } else {
            self.createdAt = nil
            self.lastUpdatedAt = nil
            self.suiteDefinitionArn = nil
            self.suiteDefinitionId = nil
            self.suiteDefinitionName = nil
            self.suiteDefinitionVersion = nil
        }
    }
}

public struct UpdateSuiteDefinitionOutput: Swift.Equatable {
    /// Timestamp of when the test suite was created.
    public var createdAt: ClientRuntime.Date?
    /// Timestamp of when the test suite was updated.
    public var lastUpdatedAt: ClientRuntime.Date?
    /// Amazon Resource Name (ARN) of the updated test suite.
    public var suiteDefinitionArn: Swift.String?
    /// Suite definition ID of the updated test suite.
    public var suiteDefinitionId: Swift.String?
    /// Updates the suite definition name. This is a required parameter.
    public var suiteDefinitionName: Swift.String?
    /// Suite definition version of the updated test suite.
    public var suiteDefinitionVersion: Swift.String?

    public init(
        createdAt: ClientRuntime.Date? = nil,
        lastUpdatedAt: ClientRuntime.Date? = nil,
        suiteDefinitionArn: Swift.String? = nil,
        suiteDefinitionId: Swift.String? = nil,
        suiteDefinitionName: Swift.String? = nil,
        suiteDefinitionVersion: Swift.String? = nil
    )
    {
        self.createdAt = createdAt
        self.lastUpdatedAt = lastUpdatedAt
        self.suiteDefinitionArn = suiteDefinitionArn
        self.suiteDefinitionId = suiteDefinitionId
        self.suiteDefinitionName = suiteDefinitionName
        self.suiteDefinitionVersion = suiteDefinitionVersion
    }
}

struct UpdateSuiteDefinitionOutputBody: Swift.Equatable {
    let suiteDefinitionId: Swift.String?
    let suiteDefinitionArn: Swift.String?
    let suiteDefinitionName: Swift.String?
    let suiteDefinitionVersion: Swift.String?
    let createdAt: ClientRuntime.Date?
    let lastUpdatedAt: ClientRuntime.Date?
}

extension UpdateSuiteDefinitionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt
        case lastUpdatedAt
        case suiteDefinitionArn
        case suiteDefinitionId
        case suiteDefinitionName
        case suiteDefinitionVersion
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let suiteDefinitionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .suiteDefinitionId)
        suiteDefinitionId = suiteDefinitionIdDecoded
        let suiteDefinitionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .suiteDefinitionArn)
        suiteDefinitionArn = suiteDefinitionArnDecoded
        let suiteDefinitionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .suiteDefinitionName)
        suiteDefinitionName = suiteDefinitionNameDecoded
        let suiteDefinitionVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .suiteDefinitionVersion)
        suiteDefinitionVersion = suiteDefinitionVersionDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
    }
}

enum UpdateSuiteDefinitionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ValidationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Sends a validation exception.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Sends a Validation Exception message.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}
