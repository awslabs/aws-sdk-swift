// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension ConflictException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Sends a Conflict Exception.
public struct ConflictException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Sends a Conflict Exception message.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CreateSuiteDefinitionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case suiteDefinitionConfiguration
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let suiteDefinitionConfiguration = self.suiteDefinitionConfiguration {
            try encodeContainer.encode(suiteDefinitionConfiguration, forKey: .suiteDefinitionConfiguration)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateSuiteDefinitionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/suiteDefinitions"
    }
}

public struct CreateSuiteDefinitionInput: Swift.Equatable {
    /// Creates a Device Advisor test suite with suite definition configuration.
    /// This member is required.
    public var suiteDefinitionConfiguration: IotDeviceAdvisorClientTypes.SuiteDefinitionConfiguration?
    /// The tags to be attached to the suite definition.
    public var tags: [Swift.String:Swift.String]?

    public init (
        suiteDefinitionConfiguration: IotDeviceAdvisorClientTypes.SuiteDefinitionConfiguration? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.suiteDefinitionConfiguration = suiteDefinitionConfiguration
        self.tags = tags
    }
}

struct CreateSuiteDefinitionInputBody: Swift.Equatable {
    let suiteDefinitionConfiguration: IotDeviceAdvisorClientTypes.SuiteDefinitionConfiguration?
    let tags: [Swift.String:Swift.String]?
}

extension CreateSuiteDefinitionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case suiteDefinitionConfiguration
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let suiteDefinitionConfigurationDecoded = try containerValues.decodeIfPresent(IotDeviceAdvisorClientTypes.SuiteDefinitionConfiguration.self, forKey: .suiteDefinitionConfiguration)
        suiteDefinitionConfiguration = suiteDefinitionConfigurationDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string2560) in tagsContainer {
                if let string2560 = string2560 {
                    tagsDecoded0?[key0] = string2560
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateSuiteDefinitionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateSuiteDefinitionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateSuiteDefinitionOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateSuiteDefinitionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateSuiteDefinitionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.createdAt = output.createdAt
            self.suiteDefinitionArn = output.suiteDefinitionArn
            self.suiteDefinitionId = output.suiteDefinitionId
            self.suiteDefinitionName = output.suiteDefinitionName
        } else {
            self.createdAt = nil
            self.suiteDefinitionArn = nil
            self.suiteDefinitionId = nil
            self.suiteDefinitionName = nil
        }
    }
}

public struct CreateSuiteDefinitionOutputResponse: Swift.Equatable {
    /// The timestamp of when the test suite was created.
    public var createdAt: ClientRuntime.Date?
    /// The Amazon Resource Name (ARN) of the test suite.
    public var suiteDefinitionArn: Swift.String?
    /// The UUID of the test suite created.
    public var suiteDefinitionId: Swift.String?
    /// The suite definition name of the test suite. This is a required parameter.
    public var suiteDefinitionName: Swift.String?

    public init (
        createdAt: ClientRuntime.Date? = nil,
        suiteDefinitionArn: Swift.String? = nil,
        suiteDefinitionId: Swift.String? = nil,
        suiteDefinitionName: Swift.String? = nil
    )
    {
        self.createdAt = createdAt
        self.suiteDefinitionArn = suiteDefinitionArn
        self.suiteDefinitionId = suiteDefinitionId
        self.suiteDefinitionName = suiteDefinitionName
    }
}

struct CreateSuiteDefinitionOutputResponseBody: Swift.Equatable {
    let suiteDefinitionId: Swift.String?
    let suiteDefinitionArn: Swift.String?
    let suiteDefinitionName: Swift.String?
    let createdAt: ClientRuntime.Date?
}

extension CreateSuiteDefinitionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt
        case suiteDefinitionArn
        case suiteDefinitionId
        case suiteDefinitionName
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let suiteDefinitionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .suiteDefinitionId)
        suiteDefinitionId = suiteDefinitionIdDecoded
        let suiteDefinitionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .suiteDefinitionArn)
        suiteDefinitionArn = suiteDefinitionArnDecoded
        let suiteDefinitionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .suiteDefinitionName)
        suiteDefinitionName = suiteDefinitionNameDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
    }
}

extension DeleteSuiteDefinitionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let suiteDefinitionId = suiteDefinitionId else {
            return nil
        }
        return "/suiteDefinitions/\(suiteDefinitionId.urlPercentEncoding())"
    }
}

public struct DeleteSuiteDefinitionInput: Swift.Equatable {
    /// Suite definition ID of the test suite to be deleted.
    /// This member is required.
    public var suiteDefinitionId: Swift.String?

    public init (
        suiteDefinitionId: Swift.String? = nil
    )
    {
        self.suiteDefinitionId = suiteDefinitionId
    }
}

struct DeleteSuiteDefinitionInputBody: Swift.Equatable {
}

extension DeleteSuiteDefinitionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteSuiteDefinitionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteSuiteDefinitionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteSuiteDefinitionOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteSuiteDefinitionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteSuiteDefinitionOutputResponse: Swift.Equatable {

    public init () { }
}

extension IotDeviceAdvisorClientTypes.DeviceUnderTest: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case certificateArn
        case thingArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let certificateArn = self.certificateArn {
            try encodeContainer.encode(certificateArn, forKey: .certificateArn)
        }
        if let thingArn = self.thingArn {
            try encodeContainer.encode(thingArn, forKey: .thingArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let thingArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .thingArn)
        thingArn = thingArnDecoded
        let certificateArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .certificateArn)
        certificateArn = certificateArnDecoded
    }
}

extension IotDeviceAdvisorClientTypes {
    /// Information of a test device. A thing ARN or a certificate ARN is required.
    public struct DeviceUnderTest: Swift.Equatable {
        /// Lists devices certificate ARN.
        public var certificateArn: Swift.String?
        /// Lists devices thing ARN.
        public var thingArn: Swift.String?

        public init (
            certificateArn: Swift.String? = nil,
            thingArn: Swift.String? = nil
        )
        {
            self.certificateArn = certificateArn
            self.thingArn = thingArn
        }
    }

}

extension GetEndpointInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let thingArn = thingArn {
                let thingArnQueryItem = ClientRuntime.URLQueryItem(name: "thingArn".urlPercentEncoding(), value: Swift.String(thingArn).urlPercentEncoding())
                items.append(thingArnQueryItem)
            }
            if let certificateArn = certificateArn {
                let certificateArnQueryItem = ClientRuntime.URLQueryItem(name: "certificateArn".urlPercentEncoding(), value: Swift.String(certificateArn).urlPercentEncoding())
                items.append(certificateArnQueryItem)
            }
            return items
        }
    }
}

extension GetEndpointInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/endpoint"
    }
}

public struct GetEndpointInput: Swift.Equatable {
    /// The certificate ARN of the device. This is an optional parameter.
    public var certificateArn: Swift.String?
    /// The thing ARN of the device. This is an optional parameter.
    public var thingArn: Swift.String?

    public init (
        certificateArn: Swift.String? = nil,
        thingArn: Swift.String? = nil
    )
    {
        self.certificateArn = certificateArn
        self.thingArn = thingArn
    }
}

struct GetEndpointInputBody: Swift.Equatable {
}

extension GetEndpointInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetEndpointOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetEndpointOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetEndpointOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetEndpointOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetEndpointOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.endpoint = output.endpoint
        } else {
            self.endpoint = nil
        }
    }
}

public struct GetEndpointOutputResponse: Swift.Equatable {
    /// The response of an Device Advisor endpoint.
    public var endpoint: Swift.String?

    public init (
        endpoint: Swift.String? = nil
    )
    {
        self.endpoint = endpoint
    }
}

struct GetEndpointOutputResponseBody: Swift.Equatable {
    let endpoint: Swift.String?
}

extension GetEndpointOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endpoint
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let endpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpoint)
        endpoint = endpointDecoded
    }
}

extension GetSuiteDefinitionInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let suiteDefinitionVersion = suiteDefinitionVersion {
                let suiteDefinitionVersionQueryItem = ClientRuntime.URLQueryItem(name: "suiteDefinitionVersion".urlPercentEncoding(), value: Swift.String(suiteDefinitionVersion).urlPercentEncoding())
                items.append(suiteDefinitionVersionQueryItem)
            }
            return items
        }
    }
}

extension GetSuiteDefinitionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let suiteDefinitionId = suiteDefinitionId else {
            return nil
        }
        return "/suiteDefinitions/\(suiteDefinitionId.urlPercentEncoding())"
    }
}

public struct GetSuiteDefinitionInput: Swift.Equatable {
    /// Suite definition ID of the test suite to get.
    /// This member is required.
    public var suiteDefinitionId: Swift.String?
    /// Suite definition version of the test suite to get.
    public var suiteDefinitionVersion: Swift.String?

    public init (
        suiteDefinitionId: Swift.String? = nil,
        suiteDefinitionVersion: Swift.String? = nil
    )
    {
        self.suiteDefinitionId = suiteDefinitionId
        self.suiteDefinitionVersion = suiteDefinitionVersion
    }
}

struct GetSuiteDefinitionInputBody: Swift.Equatable {
}

extension GetSuiteDefinitionInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetSuiteDefinitionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetSuiteDefinitionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetSuiteDefinitionOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetSuiteDefinitionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetSuiteDefinitionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.createdAt = output.createdAt
            self.lastModifiedAt = output.lastModifiedAt
            self.latestVersion = output.latestVersion
            self.suiteDefinitionArn = output.suiteDefinitionArn
            self.suiteDefinitionConfiguration = output.suiteDefinitionConfiguration
            self.suiteDefinitionId = output.suiteDefinitionId
            self.suiteDefinitionVersion = output.suiteDefinitionVersion
            self.tags = output.tags
        } else {
            self.createdAt = nil
            self.lastModifiedAt = nil
            self.latestVersion = nil
            self.suiteDefinitionArn = nil
            self.suiteDefinitionConfiguration = nil
            self.suiteDefinitionId = nil
            self.suiteDefinitionVersion = nil
            self.tags = nil
        }
    }
}

public struct GetSuiteDefinitionOutputResponse: Swift.Equatable {
    /// Date (in Unix epoch time) when the suite definition was created.
    public var createdAt: ClientRuntime.Date?
    /// Date (in Unix epoch time) when the suite definition was last modified.
    public var lastModifiedAt: ClientRuntime.Date?
    /// Latest suite definition version of the suite definition.
    public var latestVersion: Swift.String?
    /// The ARN of the suite definition.
    public var suiteDefinitionArn: Swift.String?
    /// Suite configuration of the suite definition.
    public var suiteDefinitionConfiguration: IotDeviceAdvisorClientTypes.SuiteDefinitionConfiguration?
    /// Suite definition ID of the suite definition.
    public var suiteDefinitionId: Swift.String?
    /// Suite definition version of the suite definition.
    public var suiteDefinitionVersion: Swift.String?
    /// Tags attached to the suite definition.
    public var tags: [Swift.String:Swift.String]?

    public init (
        createdAt: ClientRuntime.Date? = nil,
        lastModifiedAt: ClientRuntime.Date? = nil,
        latestVersion: Swift.String? = nil,
        suiteDefinitionArn: Swift.String? = nil,
        suiteDefinitionConfiguration: IotDeviceAdvisorClientTypes.SuiteDefinitionConfiguration? = nil,
        suiteDefinitionId: Swift.String? = nil,
        suiteDefinitionVersion: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.createdAt = createdAt
        self.lastModifiedAt = lastModifiedAt
        self.latestVersion = latestVersion
        self.suiteDefinitionArn = suiteDefinitionArn
        self.suiteDefinitionConfiguration = suiteDefinitionConfiguration
        self.suiteDefinitionId = suiteDefinitionId
        self.suiteDefinitionVersion = suiteDefinitionVersion
        self.tags = tags
    }
}

struct GetSuiteDefinitionOutputResponseBody: Swift.Equatable {
    let suiteDefinitionId: Swift.String?
    let suiteDefinitionArn: Swift.String?
    let suiteDefinitionVersion: Swift.String?
    let latestVersion: Swift.String?
    let suiteDefinitionConfiguration: IotDeviceAdvisorClientTypes.SuiteDefinitionConfiguration?
    let createdAt: ClientRuntime.Date?
    let lastModifiedAt: ClientRuntime.Date?
    let tags: [Swift.String:Swift.String]?
}

extension GetSuiteDefinitionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt
        case lastModifiedAt
        case latestVersion
        case suiteDefinitionArn
        case suiteDefinitionConfiguration
        case suiteDefinitionId
        case suiteDefinitionVersion
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let suiteDefinitionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .suiteDefinitionId)
        suiteDefinitionId = suiteDefinitionIdDecoded
        let suiteDefinitionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .suiteDefinitionArn)
        suiteDefinitionArn = suiteDefinitionArnDecoded
        let suiteDefinitionVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .suiteDefinitionVersion)
        suiteDefinitionVersion = suiteDefinitionVersionDecoded
        let latestVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .latestVersion)
        latestVersion = latestVersionDecoded
        let suiteDefinitionConfigurationDecoded = try containerValues.decodeIfPresent(IotDeviceAdvisorClientTypes.SuiteDefinitionConfiguration.self, forKey: .suiteDefinitionConfiguration)
        suiteDefinitionConfiguration = suiteDefinitionConfigurationDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastModifiedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedAt)
        lastModifiedAt = lastModifiedAtDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string2560) in tagsContainer {
                if let string2560 = string2560 {
                    tagsDecoded0?[key0] = string2560
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension GetSuiteRunInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let suiteDefinitionId = suiteDefinitionId else {
            return nil
        }
        guard let suiteRunId = suiteRunId else {
            return nil
        }
        return "/suiteDefinitions/\(suiteDefinitionId.urlPercentEncoding())/suiteRuns/\(suiteRunId.urlPercentEncoding())"
    }
}

public struct GetSuiteRunInput: Swift.Equatable {
    /// Suite definition ID for the test suite run.
    /// This member is required.
    public var suiteDefinitionId: Swift.String?
    /// Suite run ID for the test suite run.
    /// This member is required.
    public var suiteRunId: Swift.String?

    public init (
        suiteDefinitionId: Swift.String? = nil,
        suiteRunId: Swift.String? = nil
    )
    {
        self.suiteDefinitionId = suiteDefinitionId
        self.suiteRunId = suiteRunId
    }
}

struct GetSuiteRunInputBody: Swift.Equatable {
}

extension GetSuiteRunInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetSuiteRunOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetSuiteRunOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetSuiteRunOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetSuiteRunOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetSuiteRunOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.endTime = output.endTime
            self.errorReason = output.errorReason
            self.startTime = output.startTime
            self.status = output.status
            self.suiteDefinitionId = output.suiteDefinitionId
            self.suiteDefinitionVersion = output.suiteDefinitionVersion
            self.suiteRunArn = output.suiteRunArn
            self.suiteRunConfiguration = output.suiteRunConfiguration
            self.suiteRunId = output.suiteRunId
            self.tags = output.tags
            self.testResult = output.testResult
        } else {
            self.endTime = nil
            self.errorReason = nil
            self.startTime = nil
            self.status = nil
            self.suiteDefinitionId = nil
            self.suiteDefinitionVersion = nil
            self.suiteRunArn = nil
            self.suiteRunConfiguration = nil
            self.suiteRunId = nil
            self.tags = nil
            self.testResult = nil
        }
    }
}

public struct GetSuiteRunOutputResponse: Swift.Equatable {
    /// Date (in Unix epoch time) when the test suite run ended.
    public var endTime: ClientRuntime.Date?
    /// Error reason for any test suite run failure.
    public var errorReason: Swift.String?
    /// Date (in Unix epoch time) when the test suite run started.
    public var startTime: ClientRuntime.Date?
    /// Status for the test suite run.
    public var status: IotDeviceAdvisorClientTypes.SuiteRunStatus?
    /// Suite definition ID for the test suite run.
    public var suiteDefinitionId: Swift.String?
    /// Suite definition version for the test suite run.
    public var suiteDefinitionVersion: Swift.String?
    /// The ARN of the suite run.
    public var suiteRunArn: Swift.String?
    /// Suite run configuration for the test suite run.
    public var suiteRunConfiguration: IotDeviceAdvisorClientTypes.SuiteRunConfiguration?
    /// Suite run ID for the test suite run.
    public var suiteRunId: Swift.String?
    /// The tags attached to the suite run.
    public var tags: [Swift.String:Swift.String]?
    /// Test results for the test suite run.
    public var testResult: IotDeviceAdvisorClientTypes.TestResult?

    public init (
        endTime: ClientRuntime.Date? = nil,
        errorReason: Swift.String? = nil,
        startTime: ClientRuntime.Date? = nil,
        status: IotDeviceAdvisorClientTypes.SuiteRunStatus? = nil,
        suiteDefinitionId: Swift.String? = nil,
        suiteDefinitionVersion: Swift.String? = nil,
        suiteRunArn: Swift.String? = nil,
        suiteRunConfiguration: IotDeviceAdvisorClientTypes.SuiteRunConfiguration? = nil,
        suiteRunId: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        testResult: IotDeviceAdvisorClientTypes.TestResult? = nil
    )
    {
        self.endTime = endTime
        self.errorReason = errorReason
        self.startTime = startTime
        self.status = status
        self.suiteDefinitionId = suiteDefinitionId
        self.suiteDefinitionVersion = suiteDefinitionVersion
        self.suiteRunArn = suiteRunArn
        self.suiteRunConfiguration = suiteRunConfiguration
        self.suiteRunId = suiteRunId
        self.tags = tags
        self.testResult = testResult
    }
}

struct GetSuiteRunOutputResponseBody: Swift.Equatable {
    let suiteDefinitionId: Swift.String?
    let suiteDefinitionVersion: Swift.String?
    let suiteRunId: Swift.String?
    let suiteRunArn: Swift.String?
    let suiteRunConfiguration: IotDeviceAdvisorClientTypes.SuiteRunConfiguration?
    let testResult: IotDeviceAdvisorClientTypes.TestResult?
    let startTime: ClientRuntime.Date?
    let endTime: ClientRuntime.Date?
    let status: IotDeviceAdvisorClientTypes.SuiteRunStatus?
    let errorReason: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension GetSuiteRunOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTime
        case errorReason
        case startTime
        case status
        case suiteDefinitionId
        case suiteDefinitionVersion
        case suiteRunArn
        case suiteRunConfiguration
        case suiteRunId
        case tags
        case testResult
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let suiteDefinitionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .suiteDefinitionId)
        suiteDefinitionId = suiteDefinitionIdDecoded
        let suiteDefinitionVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .suiteDefinitionVersion)
        suiteDefinitionVersion = suiteDefinitionVersionDecoded
        let suiteRunIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .suiteRunId)
        suiteRunId = suiteRunIdDecoded
        let suiteRunArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .suiteRunArn)
        suiteRunArn = suiteRunArnDecoded
        let suiteRunConfigurationDecoded = try containerValues.decodeIfPresent(IotDeviceAdvisorClientTypes.SuiteRunConfiguration.self, forKey: .suiteRunConfiguration)
        suiteRunConfiguration = suiteRunConfigurationDecoded
        let testResultDecoded = try containerValues.decodeIfPresent(IotDeviceAdvisorClientTypes.TestResult.self, forKey: .testResult)
        testResult = testResultDecoded
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endTime)
        endTime = endTimeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(IotDeviceAdvisorClientTypes.SuiteRunStatus.self, forKey: .status)
        status = statusDecoded
        let errorReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorReason)
        errorReason = errorReasonDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string2560) in tagsContainer {
                if let string2560 = string2560 {
                    tagsDecoded0?[key0] = string2560
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension GetSuiteRunReportInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let suiteDefinitionId = suiteDefinitionId else {
            return nil
        }
        guard let suiteRunId = suiteRunId else {
            return nil
        }
        return "/suiteDefinitions/\(suiteDefinitionId.urlPercentEncoding())/suiteRuns/\(suiteRunId.urlPercentEncoding())/report"
    }
}

public struct GetSuiteRunReportInput: Swift.Equatable {
    /// Suite definition ID of the test suite.
    /// This member is required.
    public var suiteDefinitionId: Swift.String?
    /// Suite run ID of the test suite run.
    /// This member is required.
    public var suiteRunId: Swift.String?

    public init (
        suiteDefinitionId: Swift.String? = nil,
        suiteRunId: Swift.String? = nil
    )
    {
        self.suiteDefinitionId = suiteDefinitionId
        self.suiteRunId = suiteRunId
    }
}

struct GetSuiteRunReportInputBody: Swift.Equatable {
}

extension GetSuiteRunReportInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetSuiteRunReportOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetSuiteRunReportOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetSuiteRunReportOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetSuiteRunReportOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetSuiteRunReportOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.qualificationReportDownloadUrl = output.qualificationReportDownloadUrl
        } else {
            self.qualificationReportDownloadUrl = nil
        }
    }
}

public struct GetSuiteRunReportOutputResponse: Swift.Equatable {
    /// Download URL of the qualification report.
    public var qualificationReportDownloadUrl: Swift.String?

    public init (
        qualificationReportDownloadUrl: Swift.String? = nil
    )
    {
        self.qualificationReportDownloadUrl = qualificationReportDownloadUrl
    }
}

struct GetSuiteRunReportOutputResponseBody: Swift.Equatable {
    let qualificationReportDownloadUrl: Swift.String?
}

extension GetSuiteRunReportOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case qualificationReportDownloadUrl
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let qualificationReportDownloadUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .qualificationReportDownloadUrl)
        qualificationReportDownloadUrl = qualificationReportDownloadUrlDecoded
    }
}

extension IotDeviceAdvisorClientTypes.GroupResult: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupId
        case groupName
        case tests
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let groupId = self.groupId {
            try encodeContainer.encode(groupId, forKey: .groupId)
        }
        if let groupName = self.groupName {
            try encodeContainer.encode(groupName, forKey: .groupName)
        }
        if let tests = tests {
            var testsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tests)
            for testcaserun0 in tests {
                try testsContainer.encode(testcaserun0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupId)
        groupId = groupIdDecoded
        let groupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupName)
        groupName = groupNameDecoded
        let testsContainer = try containerValues.decodeIfPresent([IotDeviceAdvisorClientTypes.TestCaseRun?].self, forKey: .tests)
        var testsDecoded0:[IotDeviceAdvisorClientTypes.TestCaseRun]? = nil
        if let testsContainer = testsContainer {
            testsDecoded0 = [IotDeviceAdvisorClientTypes.TestCaseRun]()
            for structure0 in testsContainer {
                if let structure0 = structure0 {
                    testsDecoded0?.append(structure0)
                }
            }
        }
        tests = testsDecoded0
    }
}

extension IotDeviceAdvisorClientTypes {
    /// Show Group Result.
    public struct GroupResult: Swift.Equatable {
        /// Group result ID.
        public var groupId: Swift.String?
        /// Group Result Name.
        public var groupName: Swift.String?
        /// Tests under Group Result.
        public var tests: [IotDeviceAdvisorClientTypes.TestCaseRun]?

        public init (
            groupId: Swift.String? = nil,
            groupName: Swift.String? = nil,
            tests: [IotDeviceAdvisorClientTypes.TestCaseRun]? = nil
        )
        {
            self.groupId = groupId
            self.groupName = groupName
            self.tests = tests
        }
    }

}

extension InternalServerException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Sends an Internal Failure exception.
public struct InternalServerException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    /// Sends an Internal Failure Exception message.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListSuiteDefinitionsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if maxResults != 0 {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            return items
        }
    }
}

extension ListSuiteDefinitionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/suiteDefinitions"
    }
}

public struct ListSuiteDefinitionsInput: Swift.Equatable {
    /// The maximum number of results to return at once.
    public var maxResults: Swift.Int
    /// A token used to get the next set of results.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListSuiteDefinitionsInputBody: Swift.Equatable {
}

extension ListSuiteDefinitionsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListSuiteDefinitionsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListSuiteDefinitionsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListSuiteDefinitionsOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListSuiteDefinitionsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListSuiteDefinitionsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.suiteDefinitionInformationList = output.suiteDefinitionInformationList
        } else {
            self.nextToken = nil
            self.suiteDefinitionInformationList = nil
        }
    }
}

public struct ListSuiteDefinitionsOutputResponse: Swift.Equatable {
    /// A token used to get the next set of results.
    public var nextToken: Swift.String?
    /// An array of objects that provide summaries of information about the suite definitions in the list.
    public var suiteDefinitionInformationList: [IotDeviceAdvisorClientTypes.SuiteDefinitionInformation]?

    public init (
        nextToken: Swift.String? = nil,
        suiteDefinitionInformationList: [IotDeviceAdvisorClientTypes.SuiteDefinitionInformation]? = nil
    )
    {
        self.nextToken = nextToken
        self.suiteDefinitionInformationList = suiteDefinitionInformationList
    }
}

struct ListSuiteDefinitionsOutputResponseBody: Swift.Equatable {
    let suiteDefinitionInformationList: [IotDeviceAdvisorClientTypes.SuiteDefinitionInformation]?
    let nextToken: Swift.String?
}

extension ListSuiteDefinitionsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case suiteDefinitionInformationList
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let suiteDefinitionInformationListContainer = try containerValues.decodeIfPresent([IotDeviceAdvisorClientTypes.SuiteDefinitionInformation?].self, forKey: .suiteDefinitionInformationList)
        var suiteDefinitionInformationListDecoded0:[IotDeviceAdvisorClientTypes.SuiteDefinitionInformation]? = nil
        if let suiteDefinitionInformationListContainer = suiteDefinitionInformationListContainer {
            suiteDefinitionInformationListDecoded0 = [IotDeviceAdvisorClientTypes.SuiteDefinitionInformation]()
            for structure0 in suiteDefinitionInformationListContainer {
                if let structure0 = structure0 {
                    suiteDefinitionInformationListDecoded0?.append(structure0)
                }
            }
        }
        suiteDefinitionInformationList = suiteDefinitionInformationListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListSuiteRunsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let suiteDefinitionId = suiteDefinitionId {
                let suiteDefinitionIdQueryItem = ClientRuntime.URLQueryItem(name: "suiteDefinitionId".urlPercentEncoding(), value: Swift.String(suiteDefinitionId).urlPercentEncoding())
                items.append(suiteDefinitionIdQueryItem)
            }
            if maxResults != 0 {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let suiteDefinitionVersion = suiteDefinitionVersion {
                let suiteDefinitionVersionQueryItem = ClientRuntime.URLQueryItem(name: "suiteDefinitionVersion".urlPercentEncoding(), value: Swift.String(suiteDefinitionVersion).urlPercentEncoding())
                items.append(suiteDefinitionVersionQueryItem)
            }
            return items
        }
    }
}

extension ListSuiteRunsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/suiteRuns"
    }
}

public struct ListSuiteRunsInput: Swift.Equatable {
    /// The maximum number of results to return at once.
    public var maxResults: Swift.Int
    /// A token to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// Lists the test suite runs of the specified test suite based on suite definition ID.
    public var suiteDefinitionId: Swift.String?
    /// Must be passed along with suiteDefinitionId. Lists the test suite runs of the specified test suite based on suite definition version.
    public var suiteDefinitionVersion: Swift.String?

    public init (
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil,
        suiteDefinitionId: Swift.String? = nil,
        suiteDefinitionVersion: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.suiteDefinitionId = suiteDefinitionId
        self.suiteDefinitionVersion = suiteDefinitionVersion
    }
}

struct ListSuiteRunsInputBody: Swift.Equatable {
}

extension ListSuiteRunsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListSuiteRunsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListSuiteRunsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListSuiteRunsOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListSuiteRunsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListSuiteRunsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.suiteRunsList = output.suiteRunsList
        } else {
            self.nextToken = nil
            self.suiteRunsList = nil
        }
    }
}

public struct ListSuiteRunsOutputResponse: Swift.Equatable {
    /// A token to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// An array of objects that provide summaries of information about the suite runs in the list.
    public var suiteRunsList: [IotDeviceAdvisorClientTypes.SuiteRunInformation]?

    public init (
        nextToken: Swift.String? = nil,
        suiteRunsList: [IotDeviceAdvisorClientTypes.SuiteRunInformation]? = nil
    )
    {
        self.nextToken = nextToken
        self.suiteRunsList = suiteRunsList
    }
}

struct ListSuiteRunsOutputResponseBody: Swift.Equatable {
    let suiteRunsList: [IotDeviceAdvisorClientTypes.SuiteRunInformation]?
    let nextToken: Swift.String?
}

extension ListSuiteRunsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case suiteRunsList
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let suiteRunsListContainer = try containerValues.decodeIfPresent([IotDeviceAdvisorClientTypes.SuiteRunInformation?].self, forKey: .suiteRunsList)
        var suiteRunsListDecoded0:[IotDeviceAdvisorClientTypes.SuiteRunInformation]? = nil
        if let suiteRunsListContainer = suiteRunsListContainer {
            suiteRunsListDecoded0 = [IotDeviceAdvisorClientTypes.SuiteRunInformation]()
            for structure0 in suiteRunsListContainer {
                if let structure0 = structure0 {
                    suiteRunsListDecoded0?.append(structure0)
                }
            }
        }
        suiteRunsList = suiteRunsListDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The resource ARN of the IoT Device Advisor resource. This can be SuiteDefinition ARN or SuiteRun ARN.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init (
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// The tags attached to the IoT Device Advisor resource.
    public var tags: [Swift.String:Swift.String]?

    public init (
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string2560) in tagsContainer {
                if let string2560 = string2560 {
                    tagsDecoded0?[key0] = string2560
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension IotDeviceAdvisorClientTypes {
    public enum ModelProtocol: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case mqttv311
        case mqttv5
        case sdkUnknown(Swift.String)

        public static var allCases: [ModelProtocol] {
            return [
                .mqttv311,
                .mqttv5,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .mqttv311: return "MqttV3_1_1"
            case .mqttv5: return "MqttV5"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ModelProtocol(rawValue: rawValue) ?? ModelProtocol.sdkUnknown(rawValue)
        }
    }
}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Sends a Resource Not Found exception.
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Sends a Resource Not Found Exception message.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension StartSuiteRunInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case suiteDefinitionVersion
        case suiteRunConfiguration
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let suiteDefinitionVersion = self.suiteDefinitionVersion {
            try encodeContainer.encode(suiteDefinitionVersion, forKey: .suiteDefinitionVersion)
        }
        if let suiteRunConfiguration = self.suiteRunConfiguration {
            try encodeContainer.encode(suiteRunConfiguration, forKey: .suiteRunConfiguration)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension StartSuiteRunInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let suiteDefinitionId = suiteDefinitionId else {
            return nil
        }
        return "/suiteDefinitions/\(suiteDefinitionId.urlPercentEncoding())/suiteRuns"
    }
}

public struct StartSuiteRunInput: Swift.Equatable {
    /// Suite definition ID of the test suite.
    /// This member is required.
    public var suiteDefinitionId: Swift.String?
    /// Suite definition version of the test suite.
    public var suiteDefinitionVersion: Swift.String?
    /// Suite run configuration.
    /// This member is required.
    public var suiteRunConfiguration: IotDeviceAdvisorClientTypes.SuiteRunConfiguration?
    /// The tags to be attached to the suite run.
    public var tags: [Swift.String:Swift.String]?

    public init (
        suiteDefinitionId: Swift.String? = nil,
        suiteDefinitionVersion: Swift.String? = nil,
        suiteRunConfiguration: IotDeviceAdvisorClientTypes.SuiteRunConfiguration? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.suiteDefinitionId = suiteDefinitionId
        self.suiteDefinitionVersion = suiteDefinitionVersion
        self.suiteRunConfiguration = suiteRunConfiguration
        self.tags = tags
    }
}

struct StartSuiteRunInputBody: Swift.Equatable {
    let suiteDefinitionVersion: Swift.String?
    let suiteRunConfiguration: IotDeviceAdvisorClientTypes.SuiteRunConfiguration?
    let tags: [Swift.String:Swift.String]?
}

extension StartSuiteRunInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case suiteDefinitionVersion
        case suiteRunConfiguration
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let suiteDefinitionVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .suiteDefinitionVersion)
        suiteDefinitionVersion = suiteDefinitionVersionDecoded
        let suiteRunConfigurationDecoded = try containerValues.decodeIfPresent(IotDeviceAdvisorClientTypes.SuiteRunConfiguration.self, forKey: .suiteRunConfiguration)
        suiteRunConfiguration = suiteRunConfigurationDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string2560) in tagsContainer {
                if let string2560 = string2560 {
                    tagsDecoded0?[key0] = string2560
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension StartSuiteRunOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartSuiteRunOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum StartSuiteRunOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartSuiteRunOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: StartSuiteRunOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.createdAt = output.createdAt
            self.endpoint = output.endpoint
            self.suiteRunArn = output.suiteRunArn
            self.suiteRunId = output.suiteRunId
        } else {
            self.createdAt = nil
            self.endpoint = nil
            self.suiteRunArn = nil
            self.suiteRunId = nil
        }
    }
}

public struct StartSuiteRunOutputResponse: Swift.Equatable {
    /// Starts a Device Advisor test suite run based on suite create time.
    public var createdAt: ClientRuntime.Date?
    /// The response of an Device Advisor test endpoint.
    public var endpoint: Swift.String?
    /// Amazon Resource Name (ARN) of the started suite run.
    public var suiteRunArn: Swift.String?
    /// Suite Run ID of the started suite run.
    public var suiteRunId: Swift.String?

    public init (
        createdAt: ClientRuntime.Date? = nil,
        endpoint: Swift.String? = nil,
        suiteRunArn: Swift.String? = nil,
        suiteRunId: Swift.String? = nil
    )
    {
        self.createdAt = createdAt
        self.endpoint = endpoint
        self.suiteRunArn = suiteRunArn
        self.suiteRunId = suiteRunId
    }
}

struct StartSuiteRunOutputResponseBody: Swift.Equatable {
    let suiteRunId: Swift.String?
    let suiteRunArn: Swift.String?
    let createdAt: ClientRuntime.Date?
    let endpoint: Swift.String?
}

extension StartSuiteRunOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt
        case endpoint
        case suiteRunArn
        case suiteRunId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let suiteRunIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .suiteRunId)
        suiteRunId = suiteRunIdDecoded
        let suiteRunArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .suiteRunArn)
        suiteRunArn = suiteRunArnDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let endpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpoint)
        endpoint = endpointDecoded
    }
}

extension IotDeviceAdvisorClientTypes {
    public enum Status: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case canceled
        case error
        case fail
        case pass
        case passWithWarnings
        case pending
        case running
        case stopped
        case stopping
        case sdkUnknown(Swift.String)

        public static var allCases: [Status] {
            return [
                .canceled,
                .error,
                .fail,
                .pass,
                .passWithWarnings,
                .pending,
                .running,
                .stopped,
                .stopping,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .canceled: return "CANCELED"
            case .error: return "ERROR"
            case .fail: return "FAIL"
            case .pass: return "PASS"
            case .passWithWarnings: return "PASS_WITH_WARNINGS"
            case .pending: return "PENDING"
            case .running: return "RUNNING"
            case .stopped: return "STOPPED"
            case .stopping: return "STOPPING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Status(rawValue: rawValue) ?? Status.sdkUnknown(rawValue)
        }
    }
}

extension StopSuiteRunInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let suiteDefinitionId = suiteDefinitionId else {
            return nil
        }
        guard let suiteRunId = suiteRunId else {
            return nil
        }
        return "/suiteDefinitions/\(suiteDefinitionId.urlPercentEncoding())/suiteRuns/\(suiteRunId.urlPercentEncoding())/stop"
    }
}

public struct StopSuiteRunInput: Swift.Equatable {
    /// Suite definition ID of the test suite run to be stopped.
    /// This member is required.
    public var suiteDefinitionId: Swift.String?
    /// Suite run ID of the test suite run to be stopped.
    /// This member is required.
    public var suiteRunId: Swift.String?

    public init (
        suiteDefinitionId: Swift.String? = nil,
        suiteRunId: Swift.String? = nil
    )
    {
        self.suiteDefinitionId = suiteDefinitionId
        self.suiteRunId = suiteRunId
    }
}

struct StopSuiteRunInputBody: Swift.Equatable {
}

extension StopSuiteRunInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension StopSuiteRunOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StopSuiteRunOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum StopSuiteRunOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StopSuiteRunOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct StopSuiteRunOutputResponse: Swift.Equatable {

    public init () { }
}

extension IotDeviceAdvisorClientTypes.SuiteDefinitionConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case devicePermissionRoleArn
        case devices
        case intendedForQualification
        case isLongDurationTest
        case `protocol` = "protocol"
        case rootGroup
        case suiteDefinitionName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let devicePermissionRoleArn = self.devicePermissionRoleArn {
            try encodeContainer.encode(devicePermissionRoleArn, forKey: .devicePermissionRoleArn)
        }
        if let devices = devices {
            var devicesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .devices)
            for deviceundertest0 in devices {
                try devicesContainer.encode(deviceundertest0)
            }
        }
        if intendedForQualification != false {
            try encodeContainer.encode(intendedForQualification, forKey: .intendedForQualification)
        }
        if isLongDurationTest != false {
            try encodeContainer.encode(isLongDurationTest, forKey: .isLongDurationTest)
        }
        if let `protocol` = self.`protocol` {
            try encodeContainer.encode(`protocol`.rawValue, forKey: .`protocol`)
        }
        if let rootGroup = self.rootGroup {
            try encodeContainer.encode(rootGroup, forKey: .rootGroup)
        }
        if let suiteDefinitionName = self.suiteDefinitionName {
            try encodeContainer.encode(suiteDefinitionName, forKey: .suiteDefinitionName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let suiteDefinitionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .suiteDefinitionName)
        suiteDefinitionName = suiteDefinitionNameDecoded
        let devicesContainer = try containerValues.decodeIfPresent([IotDeviceAdvisorClientTypes.DeviceUnderTest?].self, forKey: .devices)
        var devicesDecoded0:[IotDeviceAdvisorClientTypes.DeviceUnderTest]? = nil
        if let devicesContainer = devicesContainer {
            devicesDecoded0 = [IotDeviceAdvisorClientTypes.DeviceUnderTest]()
            for structure0 in devicesContainer {
                if let structure0 = structure0 {
                    devicesDecoded0?.append(structure0)
                }
            }
        }
        devices = devicesDecoded0
        let intendedForQualificationDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .intendedForQualification) ?? false
        intendedForQualification = intendedForQualificationDecoded
        let isLongDurationTestDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isLongDurationTest) ?? false
        isLongDurationTest = isLongDurationTestDecoded
        let rootGroupDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .rootGroup)
        rootGroup = rootGroupDecoded
        let devicePermissionRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .devicePermissionRoleArn)
        devicePermissionRoleArn = devicePermissionRoleArnDecoded
        let protocolDecoded = try containerValues.decodeIfPresent(IotDeviceAdvisorClientTypes.ModelProtocol.self, forKey: .protocol)
        `protocol` = protocolDecoded
    }
}

extension IotDeviceAdvisorClientTypes {
    /// Gets the suite definition configuration.
    public struct SuiteDefinitionConfiguration: Swift.Equatable {
        /// Gets the device permission ARN. This is a required parameter.
        /// This member is required.
        public var devicePermissionRoleArn: Swift.String?
        /// Gets the devices configured.
        public var devices: [IotDeviceAdvisorClientTypes.DeviceUnderTest]?
        /// Gets the tests intended for qualification in a suite.
        public var intendedForQualification: Swift.Bool
        /// Verifies if the test suite is a long duration test.
        public var isLongDurationTest: Swift.Bool
        /// Sets the MQTT protocol that is configured in the suite definition.
        public var `protocol`: IotDeviceAdvisorClientTypes.ModelProtocol?
        /// Gets the test suite root group. This is a required parameter.
        /// This member is required.
        public var rootGroup: Swift.String?
        /// Gets the suite definition name. This is a required parameter.
        /// This member is required.
        public var suiteDefinitionName: Swift.String?

        public init (
            devicePermissionRoleArn: Swift.String? = nil,
            devices: [IotDeviceAdvisorClientTypes.DeviceUnderTest]? = nil,
            intendedForQualification: Swift.Bool = false,
            isLongDurationTest: Swift.Bool = false,
            `protocol`: IotDeviceAdvisorClientTypes.ModelProtocol? = nil,
            rootGroup: Swift.String? = nil,
            suiteDefinitionName: Swift.String? = nil
        )
        {
            self.devicePermissionRoleArn = devicePermissionRoleArn
            self.devices = devices
            self.intendedForQualification = intendedForQualification
            self.isLongDurationTest = isLongDurationTest
            self.`protocol` = `protocol`
            self.rootGroup = rootGroup
            self.suiteDefinitionName = suiteDefinitionName
        }
    }

}

extension IotDeviceAdvisorClientTypes.SuiteDefinitionInformation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt
        case defaultDevices
        case intendedForQualification
        case isLongDurationTest
        case `protocol` = "protocol"
        case suiteDefinitionId
        case suiteDefinitionName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let defaultDevices = defaultDevices {
            var defaultDevicesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .defaultDevices)
            for deviceundertest0 in defaultDevices {
                try defaultDevicesContainer.encode(deviceundertest0)
            }
        }
        if intendedForQualification != false {
            try encodeContainer.encode(intendedForQualification, forKey: .intendedForQualification)
        }
        if isLongDurationTest != false {
            try encodeContainer.encode(isLongDurationTest, forKey: .isLongDurationTest)
        }
        if let `protocol` = self.`protocol` {
            try encodeContainer.encode(`protocol`.rawValue, forKey: .`protocol`)
        }
        if let suiteDefinitionId = self.suiteDefinitionId {
            try encodeContainer.encode(suiteDefinitionId, forKey: .suiteDefinitionId)
        }
        if let suiteDefinitionName = self.suiteDefinitionName {
            try encodeContainer.encode(suiteDefinitionName, forKey: .suiteDefinitionName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let suiteDefinitionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .suiteDefinitionId)
        suiteDefinitionId = suiteDefinitionIdDecoded
        let suiteDefinitionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .suiteDefinitionName)
        suiteDefinitionName = suiteDefinitionNameDecoded
        let defaultDevicesContainer = try containerValues.decodeIfPresent([IotDeviceAdvisorClientTypes.DeviceUnderTest?].self, forKey: .defaultDevices)
        var defaultDevicesDecoded0:[IotDeviceAdvisorClientTypes.DeviceUnderTest]? = nil
        if let defaultDevicesContainer = defaultDevicesContainer {
            defaultDevicesDecoded0 = [IotDeviceAdvisorClientTypes.DeviceUnderTest]()
            for structure0 in defaultDevicesContainer {
                if let structure0 = structure0 {
                    defaultDevicesDecoded0?.append(structure0)
                }
            }
        }
        defaultDevices = defaultDevicesDecoded0
        let intendedForQualificationDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .intendedForQualification) ?? false
        intendedForQualification = intendedForQualificationDecoded
        let isLongDurationTestDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isLongDurationTest) ?? false
        isLongDurationTest = isLongDurationTestDecoded
        let protocolDecoded = try containerValues.decodeIfPresent(IotDeviceAdvisorClientTypes.ModelProtocol.self, forKey: .protocol)
        `protocol` = protocolDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
    }
}

extension IotDeviceAdvisorClientTypes {
    /// Information about the suite definition.
    public struct SuiteDefinitionInformation: Swift.Equatable {
        /// Date (in Unix epoch time) when the test suite was created.
        public var createdAt: ClientRuntime.Date?
        /// Specifies the devices that are under test for the test suite.
        public var defaultDevices: [IotDeviceAdvisorClientTypes.DeviceUnderTest]?
        /// Specifies if the test suite is intended for qualification.
        public var intendedForQualification: Swift.Bool
        /// Verifies if the test suite is a long duration test.
        public var isLongDurationTest: Swift.Bool
        /// Gets the MQTT protocol that is configured in the suite definition.
        public var `protocol`: IotDeviceAdvisorClientTypes.ModelProtocol?
        /// Suite definition ID of the test suite.
        public var suiteDefinitionId: Swift.String?
        /// Suite name of the test suite.
        public var suiteDefinitionName: Swift.String?

        public init (
            createdAt: ClientRuntime.Date? = nil,
            defaultDevices: [IotDeviceAdvisorClientTypes.DeviceUnderTest]? = nil,
            intendedForQualification: Swift.Bool = false,
            isLongDurationTest: Swift.Bool = false,
            `protocol`: IotDeviceAdvisorClientTypes.ModelProtocol? = nil,
            suiteDefinitionId: Swift.String? = nil,
            suiteDefinitionName: Swift.String? = nil
        )
        {
            self.createdAt = createdAt
            self.defaultDevices = defaultDevices
            self.intendedForQualification = intendedForQualification
            self.isLongDurationTest = isLongDurationTest
            self.`protocol` = `protocol`
            self.suiteDefinitionId = suiteDefinitionId
            self.suiteDefinitionName = suiteDefinitionName
        }
    }

}

extension IotDeviceAdvisorClientTypes.SuiteRunConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case parallelRun
        case primaryDevice
        case selectedTestList
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if parallelRun != false {
            try encodeContainer.encode(parallelRun, forKey: .parallelRun)
        }
        if let primaryDevice = self.primaryDevice {
            try encodeContainer.encode(primaryDevice, forKey: .primaryDevice)
        }
        if let selectedTestList = selectedTestList {
            var selectedTestListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .selectedTestList)
            for uuid0 in selectedTestList {
                try selectedTestListContainer.encode(uuid0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let primaryDeviceDecoded = try containerValues.decodeIfPresent(IotDeviceAdvisorClientTypes.DeviceUnderTest.self, forKey: .primaryDevice)
        primaryDevice = primaryDeviceDecoded
        let selectedTestListContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .selectedTestList)
        var selectedTestListDecoded0:[Swift.String]? = nil
        if let selectedTestListContainer = selectedTestListContainer {
            selectedTestListDecoded0 = [Swift.String]()
            for string0 in selectedTestListContainer {
                if let string0 = string0 {
                    selectedTestListDecoded0?.append(string0)
                }
            }
        }
        selectedTestList = selectedTestListDecoded0
        let parallelRunDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .parallelRun) ?? false
        parallelRun = parallelRunDecoded
    }
}

extension IotDeviceAdvisorClientTypes {
    /// Gets suite run configuration.
    public struct SuiteRunConfiguration: Swift.Equatable {
        /// TRUE if multiple test suites run in parallel.
        public var parallelRun: Swift.Bool
        /// Sets the primary device for the test suite run. This requires a thing ARN or a certificate ARN.
        /// This member is required.
        public var primaryDevice: IotDeviceAdvisorClientTypes.DeviceUnderTest?
        /// Sets test case list.
        public var selectedTestList: [Swift.String]?

        public init (
            parallelRun: Swift.Bool = false,
            primaryDevice: IotDeviceAdvisorClientTypes.DeviceUnderTest? = nil,
            selectedTestList: [Swift.String]? = nil
        )
        {
            self.parallelRun = parallelRun
            self.primaryDevice = primaryDevice
            self.selectedTestList = selectedTestList
        }
    }

}

extension IotDeviceAdvisorClientTypes.SuiteRunInformation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt
        case endAt
        case failed
        case passed
        case startedAt
        case status
        case suiteDefinitionId
        case suiteDefinitionName
        case suiteDefinitionVersion
        case suiteRunId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let endAt = self.endAt {
            try encodeContainer.encodeTimestamp(endAt, format: .epochSeconds, forKey: .endAt)
        }
        if failed != 0 {
            try encodeContainer.encode(failed, forKey: .failed)
        }
        if passed != 0 {
            try encodeContainer.encode(passed, forKey: .passed)
        }
        if let startedAt = self.startedAt {
            try encodeContainer.encodeTimestamp(startedAt, format: .epochSeconds, forKey: .startedAt)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let suiteDefinitionId = self.suiteDefinitionId {
            try encodeContainer.encode(suiteDefinitionId, forKey: .suiteDefinitionId)
        }
        if let suiteDefinitionName = self.suiteDefinitionName {
            try encodeContainer.encode(suiteDefinitionName, forKey: .suiteDefinitionName)
        }
        if let suiteDefinitionVersion = self.suiteDefinitionVersion {
            try encodeContainer.encode(suiteDefinitionVersion, forKey: .suiteDefinitionVersion)
        }
        if let suiteRunId = self.suiteRunId {
            try encodeContainer.encode(suiteRunId, forKey: .suiteRunId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let suiteDefinitionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .suiteDefinitionId)
        suiteDefinitionId = suiteDefinitionIdDecoded
        let suiteDefinitionVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .suiteDefinitionVersion)
        suiteDefinitionVersion = suiteDefinitionVersionDecoded
        let suiteDefinitionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .suiteDefinitionName)
        suiteDefinitionName = suiteDefinitionNameDecoded
        let suiteRunIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .suiteRunId)
        suiteRunId = suiteRunIdDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let startedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startedAt)
        startedAt = startedAtDecoded
        let endAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endAt)
        endAt = endAtDecoded
        let statusDecoded = try containerValues.decodeIfPresent(IotDeviceAdvisorClientTypes.SuiteRunStatus.self, forKey: .status)
        status = statusDecoded
        let passedDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .passed) ?? 0
        passed = passedDecoded
        let failedDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .failed) ?? 0
        failed = failedDecoded
    }
}

extension IotDeviceAdvisorClientTypes {
    /// Information about the suite run. Requires permission to access the [SuiteRunInformation](https://docs.aws.amazon.com/service-authorization/latest/reference/list_awsiot.html#awsiot-actions-as-permissions) action.
    public struct SuiteRunInformation: Swift.Equatable {
        /// Date (in Unix epoch time) when the suite run was created.
        public var createdAt: ClientRuntime.Date?
        /// Date (in Unix epoch time) when the suite run ended.
        public var endAt: ClientRuntime.Date?
        /// Number of test cases that failed in the suite run.
        public var failed: Swift.Int
        /// Number of test cases that passed in the suite run.
        public var passed: Swift.Int
        /// Date (in Unix epoch time) when the suite run was started.
        public var startedAt: ClientRuntime.Date?
        /// Status of the suite run.
        public var status: IotDeviceAdvisorClientTypes.SuiteRunStatus?
        /// Suite definition ID of the suite run.
        public var suiteDefinitionId: Swift.String?
        /// Suite definition name of the suite run.
        public var suiteDefinitionName: Swift.String?
        /// Suite definition version of the suite run.
        public var suiteDefinitionVersion: Swift.String?
        /// Suite run ID of the suite run.
        public var suiteRunId: Swift.String?

        public init (
            createdAt: ClientRuntime.Date? = nil,
            endAt: ClientRuntime.Date? = nil,
            failed: Swift.Int = 0,
            passed: Swift.Int = 0,
            startedAt: ClientRuntime.Date? = nil,
            status: IotDeviceAdvisorClientTypes.SuiteRunStatus? = nil,
            suiteDefinitionId: Swift.String? = nil,
            suiteDefinitionName: Swift.String? = nil,
            suiteDefinitionVersion: Swift.String? = nil,
            suiteRunId: Swift.String? = nil
        )
        {
            self.createdAt = createdAt
            self.endAt = endAt
            self.failed = failed
            self.passed = passed
            self.startedAt = startedAt
            self.status = status
            self.suiteDefinitionId = suiteDefinitionId
            self.suiteDefinitionName = suiteDefinitionName
            self.suiteDefinitionVersion = suiteDefinitionVersion
            self.suiteRunId = suiteRunId
        }
    }

}

extension IotDeviceAdvisorClientTypes {
    public enum SuiteRunStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case canceled
        case error
        case fail
        case pass
        case passWithWarnings
        case pending
        case running
        case stopped
        case stopping
        case sdkUnknown(Swift.String)

        public static var allCases: [SuiteRunStatus] {
            return [
                .canceled,
                .error,
                .fail,
                .pass,
                .passWithWarnings,
                .pending,
                .running,
                .stopped,
                .stopping,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .canceled: return "CANCELED"
            case .error: return "ERROR"
            case .fail: return "FAIL"
            case .pass: return "PASS"
            case .passWithWarnings: return "PASS_WITH_WARNINGS"
            case .pending: return "PENDING"
            case .running: return "RUNNING"
            case .stopped: return "STOPPED"
            case .stopping: return "STOPPING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SuiteRunStatus(rawValue: rawValue) ?? SuiteRunStatus.sdkUnknown(rawValue)
        }
    }
}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The resource ARN of an IoT Device Advisor resource. This can be SuiteDefinition ARN or SuiteRun ARN.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tags to be attached to the IoT Device Advisor resource.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string2560) in tagsContainer {
                if let string2560 = string2560 {
                    tagsDecoded0?[key0] = string2560
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

    public init () { }
}

extension IotDeviceAdvisorClientTypes.TestCaseRun: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case endTime
        case failure
        case logUrl
        case startTime
        case status
        case testCaseDefinitionId
        case testCaseDefinitionName
        case testCaseRunId
        case testScenarios
        case warnings
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let endTime = self.endTime {
            try encodeContainer.encodeTimestamp(endTime, format: .epochSeconds, forKey: .endTime)
        }
        if let failure = self.failure {
            try encodeContainer.encode(failure, forKey: .failure)
        }
        if let logUrl = self.logUrl {
            try encodeContainer.encode(logUrl, forKey: .logUrl)
        }
        if let startTime = self.startTime {
            try encodeContainer.encodeTimestamp(startTime, format: .epochSeconds, forKey: .startTime)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let testCaseDefinitionId = self.testCaseDefinitionId {
            try encodeContainer.encode(testCaseDefinitionId, forKey: .testCaseDefinitionId)
        }
        if let testCaseDefinitionName = self.testCaseDefinitionName {
            try encodeContainer.encode(testCaseDefinitionName, forKey: .testCaseDefinitionName)
        }
        if let testCaseRunId = self.testCaseRunId {
            try encodeContainer.encode(testCaseRunId, forKey: .testCaseRunId)
        }
        if let testScenarios = testScenarios {
            var testScenariosContainer = encodeContainer.nestedUnkeyedContainer(forKey: .testScenarios)
            for testcasescenario0 in testScenarios {
                try testScenariosContainer.encode(testcasescenario0)
            }
        }
        if let warnings = self.warnings {
            try encodeContainer.encode(warnings, forKey: .warnings)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let testCaseRunIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .testCaseRunId)
        testCaseRunId = testCaseRunIdDecoded
        let testCaseDefinitionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .testCaseDefinitionId)
        testCaseDefinitionId = testCaseDefinitionIdDecoded
        let testCaseDefinitionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .testCaseDefinitionName)
        testCaseDefinitionName = testCaseDefinitionNameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(IotDeviceAdvisorClientTypes.Status.self, forKey: .status)
        status = statusDecoded
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endTime)
        endTime = endTimeDecoded
        let logUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .logUrl)
        logUrl = logUrlDecoded
        let warningsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .warnings)
        warnings = warningsDecoded
        let failureDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failure)
        failure = failureDecoded
        let testScenariosContainer = try containerValues.decodeIfPresent([IotDeviceAdvisorClientTypes.TestCaseScenario?].self, forKey: .testScenarios)
        var testScenariosDecoded0:[IotDeviceAdvisorClientTypes.TestCaseScenario]? = nil
        if let testScenariosContainer = testScenariosContainer {
            testScenariosDecoded0 = [IotDeviceAdvisorClientTypes.TestCaseScenario]()
            for structure0 in testScenariosContainer {
                if let structure0 = structure0 {
                    testScenariosDecoded0?.append(structure0)
                }
            }
        }
        testScenarios = testScenariosDecoded0
    }
}

extension IotDeviceAdvisorClientTypes {
    /// Provides the test case run.
    public struct TestCaseRun: Swift.Equatable {
        /// Provides test case run end time.
        public var endTime: ClientRuntime.Date?
        /// Provides test case run failure result.
        public var failure: Swift.String?
        /// Provides test case run log URL.
        public var logUrl: Swift.String?
        /// Provides test case run start time.
        public var startTime: ClientRuntime.Date?
        /// Provides the test case run status. Status is one of the following:
        ///
        /// * PASS: Test passed.
        ///
        /// * FAIL: Test failed.
        ///
        /// * PENDING: Test has not started running but is scheduled.
        ///
        /// * RUNNING: Test is running.
        ///
        /// * STOPPING: Test is performing cleanup steps. You will see this status only if you stop a suite run.
        ///
        /// * STOPPED Test is stopped. You will see this status only if you stop a suite run.
        ///
        /// * PASS_WITH_WARNINGS: Test passed with warnings.
        ///
        /// * ERORR: Test faced an error when running due to an internal issue.
        public var status: IotDeviceAdvisorClientTypes.Status?
        /// Provides the test case run definition ID.
        public var testCaseDefinitionId: Swift.String?
        /// Provides the test case run definition name.
        public var testCaseDefinitionName: Swift.String?
        /// Provides the test case run ID.
        public var testCaseRunId: Swift.String?
        /// Provides the test scenarios for the test case run.
        public var testScenarios: [IotDeviceAdvisorClientTypes.TestCaseScenario]?
        /// Provides test case run warnings.
        public var warnings: Swift.String?

        public init (
            endTime: ClientRuntime.Date? = nil,
            failure: Swift.String? = nil,
            logUrl: Swift.String? = nil,
            startTime: ClientRuntime.Date? = nil,
            status: IotDeviceAdvisorClientTypes.Status? = nil,
            testCaseDefinitionId: Swift.String? = nil,
            testCaseDefinitionName: Swift.String? = nil,
            testCaseRunId: Swift.String? = nil,
            testScenarios: [IotDeviceAdvisorClientTypes.TestCaseScenario]? = nil,
            warnings: Swift.String? = nil
        )
        {
            self.endTime = endTime
            self.failure = failure
            self.logUrl = logUrl
            self.startTime = startTime
            self.status = status
            self.testCaseDefinitionId = testCaseDefinitionId
            self.testCaseDefinitionName = testCaseDefinitionName
            self.testCaseRunId = testCaseRunId
            self.testScenarios = testScenarios
            self.warnings = warnings
        }
    }

}

extension IotDeviceAdvisorClientTypes.TestCaseScenario: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failure
        case status
        case systemMessage
        case testCaseScenarioId
        case testCaseScenarioType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let failure = self.failure {
            try encodeContainer.encode(failure, forKey: .failure)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let systemMessage = self.systemMessage {
            try encodeContainer.encode(systemMessage, forKey: .systemMessage)
        }
        if let testCaseScenarioId = self.testCaseScenarioId {
            try encodeContainer.encode(testCaseScenarioId, forKey: .testCaseScenarioId)
        }
        if let testCaseScenarioType = self.testCaseScenarioType {
            try encodeContainer.encode(testCaseScenarioType.rawValue, forKey: .testCaseScenarioType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let testCaseScenarioIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .testCaseScenarioId)
        testCaseScenarioId = testCaseScenarioIdDecoded
        let testCaseScenarioTypeDecoded = try containerValues.decodeIfPresent(IotDeviceAdvisorClientTypes.TestCaseScenarioType.self, forKey: .testCaseScenarioType)
        testCaseScenarioType = testCaseScenarioTypeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(IotDeviceAdvisorClientTypes.TestCaseScenarioStatus.self, forKey: .status)
        status = statusDecoded
        let failureDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failure)
        failure = failureDecoded
        let systemMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .systemMessage)
        systemMessage = systemMessageDecoded
    }
}

extension IotDeviceAdvisorClientTypes {
    /// Provides test case scenario.
    public struct TestCaseScenario: Swift.Equatable {
        /// Provides test case scenario failure result.
        public var failure: Swift.String?
        /// Provides the test case scenario status. Status is one of the following:
        ///
        /// * PASS: Test passed.
        ///
        /// * FAIL: Test failed.
        ///
        /// * PENDING: Test has not started running but is scheduled.
        ///
        /// * RUNNING: Test is running.
        ///
        /// * STOPPING: Test is performing cleanup steps. You will see this status only if you stop a suite run.
        ///
        /// * STOPPED Test is stopped. You will see this status only if you stop a suite run.
        ///
        /// * PASS_WITH_WARNINGS: Test passed with warnings.
        ///
        /// * ERORR: Test faced an error when running due to an internal issue.
        public var status: IotDeviceAdvisorClientTypes.TestCaseScenarioStatus?
        ///
        public var systemMessage: Swift.String?
        /// Provides test case scenario ID.
        public var testCaseScenarioId: Swift.String?
        /// Provides test case scenario type. Type is one of the following:
        ///
        /// * Advanced
        ///
        /// * Basic
        public var testCaseScenarioType: IotDeviceAdvisorClientTypes.TestCaseScenarioType?

        public init (
            failure: Swift.String? = nil,
            status: IotDeviceAdvisorClientTypes.TestCaseScenarioStatus? = nil,
            systemMessage: Swift.String? = nil,
            testCaseScenarioId: Swift.String? = nil,
            testCaseScenarioType: IotDeviceAdvisorClientTypes.TestCaseScenarioType? = nil
        )
        {
            self.failure = failure
            self.status = status
            self.systemMessage = systemMessage
            self.testCaseScenarioId = testCaseScenarioId
            self.testCaseScenarioType = testCaseScenarioType
        }
    }

}

extension IotDeviceAdvisorClientTypes {
    public enum TestCaseScenarioStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case canceled
        case error
        case fail
        case pass
        case passWithWarnings
        case pending
        case running
        case stopped
        case stopping
        case sdkUnknown(Swift.String)

        public static var allCases: [TestCaseScenarioStatus] {
            return [
                .canceled,
                .error,
                .fail,
                .pass,
                .passWithWarnings,
                .pending,
                .running,
                .stopped,
                .stopping,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .canceled: return "CANCELED"
            case .error: return "ERROR"
            case .fail: return "FAIL"
            case .pass: return "PASS"
            case .passWithWarnings: return "PASS_WITH_WARNINGS"
            case .pending: return "PENDING"
            case .running: return "RUNNING"
            case .stopped: return "STOPPED"
            case .stopping: return "STOPPING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TestCaseScenarioStatus(rawValue: rawValue) ?? TestCaseScenarioStatus.sdkUnknown(rawValue)
        }
    }
}

extension IotDeviceAdvisorClientTypes {
    public enum TestCaseScenarioType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case advanced
        case basic
        case sdkUnknown(Swift.String)

        public static var allCases: [TestCaseScenarioType] {
            return [
                .advanced,
                .basic,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .advanced: return "Advanced"
            case .basic: return "Basic"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TestCaseScenarioType(rawValue: rawValue) ?? TestCaseScenarioType.sdkUnknown(rawValue)
        }
    }
}

extension IotDeviceAdvisorClientTypes.TestResult: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groups
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let groups = groups {
            var groupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .groups)
            for groupresult0 in groups {
                try groupsContainer.encode(groupresult0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupsContainer = try containerValues.decodeIfPresent([IotDeviceAdvisorClientTypes.GroupResult?].self, forKey: .groups)
        var groupsDecoded0:[IotDeviceAdvisorClientTypes.GroupResult]? = nil
        if let groupsContainer = groupsContainer {
            groupsDecoded0 = [IotDeviceAdvisorClientTypes.GroupResult]()
            for structure0 in groupsContainer {
                if let structure0 = structure0 {
                    groupsDecoded0?.append(structure0)
                }
            }
        }
        groups = groupsDecoded0
    }
}

extension IotDeviceAdvisorClientTypes {
    /// Show each group result.
    public struct TestResult: Swift.Equatable {
        /// Show each group of test results.
        public var groups: [IotDeviceAdvisorClientTypes.GroupResult]?

        public init (
            groups: [IotDeviceAdvisorClientTypes.GroupResult]? = nil
        )
        {
            self.groups = groups
        }
    }

}

extension UntagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let tagKeys = tagKeys else {
                let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
            return items
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The resource ARN of an IoT Device Advisor resource. This can be SuiteDefinition ARN or SuiteRun ARN.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// List of tag keys to remove from the IoT Device Advisor resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

    public init () { }
}

extension UpdateSuiteDefinitionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case suiteDefinitionConfiguration
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let suiteDefinitionConfiguration = self.suiteDefinitionConfiguration {
            try encodeContainer.encode(suiteDefinitionConfiguration, forKey: .suiteDefinitionConfiguration)
        }
    }
}

extension UpdateSuiteDefinitionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let suiteDefinitionId = suiteDefinitionId else {
            return nil
        }
        return "/suiteDefinitions/\(suiteDefinitionId.urlPercentEncoding())"
    }
}

public struct UpdateSuiteDefinitionInput: Swift.Equatable {
    /// Updates a Device Advisor test suite with suite definition configuration.
    /// This member is required.
    public var suiteDefinitionConfiguration: IotDeviceAdvisorClientTypes.SuiteDefinitionConfiguration?
    /// Suite definition ID of the test suite to be updated.
    /// This member is required.
    public var suiteDefinitionId: Swift.String?

    public init (
        suiteDefinitionConfiguration: IotDeviceAdvisorClientTypes.SuiteDefinitionConfiguration? = nil,
        suiteDefinitionId: Swift.String? = nil
    )
    {
        self.suiteDefinitionConfiguration = suiteDefinitionConfiguration
        self.suiteDefinitionId = suiteDefinitionId
    }
}

struct UpdateSuiteDefinitionInputBody: Swift.Equatable {
    let suiteDefinitionConfiguration: IotDeviceAdvisorClientTypes.SuiteDefinitionConfiguration?
}

extension UpdateSuiteDefinitionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case suiteDefinitionConfiguration
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let suiteDefinitionConfigurationDecoded = try containerValues.decodeIfPresent(IotDeviceAdvisorClientTypes.SuiteDefinitionConfiguration.self, forKey: .suiteDefinitionConfiguration)
        suiteDefinitionConfiguration = suiteDefinitionConfigurationDecoded
    }
}

extension UpdateSuiteDefinitionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateSuiteDefinitionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateSuiteDefinitionOutputError: Swift.Error, Swift.Equatable {
    case internalServerException(InternalServerException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateSuiteDefinitionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateSuiteDefinitionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.createdAt = output.createdAt
            self.lastUpdatedAt = output.lastUpdatedAt
            self.suiteDefinitionArn = output.suiteDefinitionArn
            self.suiteDefinitionId = output.suiteDefinitionId
            self.suiteDefinitionName = output.suiteDefinitionName
            self.suiteDefinitionVersion = output.suiteDefinitionVersion
        } else {
            self.createdAt = nil
            self.lastUpdatedAt = nil
            self.suiteDefinitionArn = nil
            self.suiteDefinitionId = nil
            self.suiteDefinitionName = nil
            self.suiteDefinitionVersion = nil
        }
    }
}

public struct UpdateSuiteDefinitionOutputResponse: Swift.Equatable {
    /// Timestamp of when the test suite was created.
    public var createdAt: ClientRuntime.Date?
    /// Timestamp of when the test suite was updated.
    public var lastUpdatedAt: ClientRuntime.Date?
    /// Amazon Resource Name (ARN) of the updated test suite.
    public var suiteDefinitionArn: Swift.String?
    /// Suite definition ID of the updated test suite.
    public var suiteDefinitionId: Swift.String?
    /// Updates the suite definition name. This is a required parameter.
    public var suiteDefinitionName: Swift.String?
    /// Suite definition version of the updated test suite.
    public var suiteDefinitionVersion: Swift.String?

    public init (
        createdAt: ClientRuntime.Date? = nil,
        lastUpdatedAt: ClientRuntime.Date? = nil,
        suiteDefinitionArn: Swift.String? = nil,
        suiteDefinitionId: Swift.String? = nil,
        suiteDefinitionName: Swift.String? = nil,
        suiteDefinitionVersion: Swift.String? = nil
    )
    {
        self.createdAt = createdAt
        self.lastUpdatedAt = lastUpdatedAt
        self.suiteDefinitionArn = suiteDefinitionArn
        self.suiteDefinitionId = suiteDefinitionId
        self.suiteDefinitionName = suiteDefinitionName
        self.suiteDefinitionVersion = suiteDefinitionVersion
    }
}

struct UpdateSuiteDefinitionOutputResponseBody: Swift.Equatable {
    let suiteDefinitionId: Swift.String?
    let suiteDefinitionArn: Swift.String?
    let suiteDefinitionName: Swift.String?
    let suiteDefinitionVersion: Swift.String?
    let createdAt: ClientRuntime.Date?
    let lastUpdatedAt: ClientRuntime.Date?
}

extension UpdateSuiteDefinitionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt
        case lastUpdatedAt
        case suiteDefinitionArn
        case suiteDefinitionId
        case suiteDefinitionName
        case suiteDefinitionVersion
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let suiteDefinitionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .suiteDefinitionId)
        suiteDefinitionId = suiteDefinitionIdDecoded
        let suiteDefinitionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .suiteDefinitionArn)
        suiteDefinitionArn = suiteDefinitionArnDecoded
        let suiteDefinitionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .suiteDefinitionName)
        suiteDefinitionName = suiteDefinitionNameDecoded
        let suiteDefinitionVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .suiteDefinitionVersion)
        suiteDefinitionVersion = suiteDefinitionVersionDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
    }
}

extension ValidationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// Sends a validation exception.
public struct ValidationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// Sends a Validation Exception message.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}
