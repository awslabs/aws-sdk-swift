//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum Smithy.ClientError
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.RestJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
import struct Smithy.URIQueryItem

extension IotDeviceAdvisorClientTypes {

    public enum AuthenticationMethod: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case signatureversion4
        case x509clientcertificate
        case sdkUnknown(Swift.String)

        public static var allCases: [AuthenticationMethod] {
            return [
                .signatureversion4,
                .x509clientcertificate
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .signatureversion4: return "SignatureVersion4"
            case .x509clientcertificate: return "X509ClientCertificate"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// Sends a Conflict Exception.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Sends a Conflict Exception message.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// Sends an Internal Failure exception.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Sends an Internal Failure Exception message.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// Sends a validation exception.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Sends a Validation Exception message.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension IotDeviceAdvisorClientTypes {

    /// Information of a test device. A thing ARN, certificate ARN or device role ARN is required.
    public struct DeviceUnderTest: Swift.Sendable {
        /// Lists device's certificate ARN.
        public var certificateArn: Swift.String?
        /// Lists device's role ARN.
        public var deviceRoleArn: Swift.String?
        /// Lists device's thing ARN.
        public var thingArn: Swift.String?

        public init(
            certificateArn: Swift.String? = nil,
            deviceRoleArn: Swift.String? = nil,
            thingArn: Swift.String? = nil
        )
        {
            self.certificateArn = certificateArn
            self.deviceRoleArn = deviceRoleArn
            self.thingArn = thingArn
        }
    }
}

extension IotDeviceAdvisorClientTypes {

    public enum ModelProtocol: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case mqttv311
        case mqttv311Overwebsocket
        case mqttv5
        case mqttv5Overwebsocket
        case sdkUnknown(Swift.String)

        public static var allCases: [ModelProtocol] {
            return [
                .mqttv311,
                .mqttv311Overwebsocket,
                .mqttv5,
                .mqttv5Overwebsocket
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .mqttv311: return "MqttV3_1_1"
            case .mqttv311Overwebsocket: return "MqttV3_1_1_OverWebSocket"
            case .mqttv5: return "MqttV5"
            case .mqttv5Overwebsocket: return "MqttV5_OverWebSocket"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IotDeviceAdvisorClientTypes {

    /// Gets the suite definition configuration.
    public struct SuiteDefinitionConfiguration: Swift.Sendable {
        /// Gets the device permission ARN. This is a required parameter.
        /// This member is required.
        public var devicePermissionRoleArn: Swift.String?
        /// Gets the devices configured.
        public var devices: [IotDeviceAdvisorClientTypes.DeviceUnderTest]?
        /// Gets the tests intended for qualification in a suite.
        public var intendedForQualification: Swift.Bool?
        /// Verifies if the test suite is a long duration test.
        public var isLongDurationTest: Swift.Bool?
        /// Sets the MQTT protocol that is configured in the suite definition.
        public var `protocol`: IotDeviceAdvisorClientTypes.ModelProtocol?
        /// Gets the test suite root group. This is a required parameter. For updating or creating the latest qualification suite, if intendedForQualification is set to true, rootGroup can be an empty string. If intendedForQualification is false, rootGroup cannot be an empty string. If rootGroup is empty, and intendedForQualification is set to true, all the qualification tests are included, and the configuration is default. For a qualification suite, the minimum length is 0, and the maximum is 2048. For a non-qualification suite, the minimum length is 1, and the maximum is 2048.
        /// This member is required.
        public var rootGroup: Swift.String?
        /// Gets the suite definition name. This is a required parameter.
        /// This member is required.
        public var suiteDefinitionName: Swift.String?

        public init(
            devicePermissionRoleArn: Swift.String? = nil,
            devices: [IotDeviceAdvisorClientTypes.DeviceUnderTest]? = nil,
            intendedForQualification: Swift.Bool? = nil,
            isLongDurationTest: Swift.Bool? = nil,
            `protocol`: IotDeviceAdvisorClientTypes.ModelProtocol? = nil,
            rootGroup: Swift.String? = nil,
            suiteDefinitionName: Swift.String? = nil
        )
        {
            self.devicePermissionRoleArn = devicePermissionRoleArn
            self.devices = devices
            self.intendedForQualification = intendedForQualification
            self.isLongDurationTest = isLongDurationTest
            self.`protocol` = `protocol`
            self.rootGroup = rootGroup
            self.suiteDefinitionName = suiteDefinitionName
        }
    }
}

public struct CreateSuiteDefinitionInput: Swift.Sendable {
    /// The client token for the test suite definition creation. This token is used for tracking test suite definition creation using retries and obtaining its status. This parameter is optional.
    public var clientToken: Swift.String?
    /// Creates a Device Advisor test suite with suite definition configuration.
    /// This member is required.
    public var suiteDefinitionConfiguration: IotDeviceAdvisorClientTypes.SuiteDefinitionConfiguration?
    /// The tags to be attached to the suite definition.
    public var tags: [Swift.String: Swift.String]?

    public init(
        clientToken: Swift.String? = nil,
        suiteDefinitionConfiguration: IotDeviceAdvisorClientTypes.SuiteDefinitionConfiguration? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.clientToken = clientToken
        self.suiteDefinitionConfiguration = suiteDefinitionConfiguration
        self.tags = tags
    }
}

public struct CreateSuiteDefinitionOutput: Swift.Sendable {
    /// The timestamp of when the test suite was created.
    public var createdAt: Foundation.Date?
    /// The Amazon Resource Name (ARN) of the test suite.
    public var suiteDefinitionArn: Swift.String?
    /// The UUID of the test suite created.
    public var suiteDefinitionId: Swift.String?
    /// The suite definition name of the test suite. This is a required parameter.
    public var suiteDefinitionName: Swift.String?

    public init(
        createdAt: Foundation.Date? = nil,
        suiteDefinitionArn: Swift.String? = nil,
        suiteDefinitionId: Swift.String? = nil,
        suiteDefinitionName: Swift.String? = nil
    )
    {
        self.createdAt = createdAt
        self.suiteDefinitionArn = suiteDefinitionArn
        self.suiteDefinitionId = suiteDefinitionId
        self.suiteDefinitionName = suiteDefinitionName
    }
}

public struct DeleteSuiteDefinitionInput: Swift.Sendable {
    /// Suite definition ID of the test suite to be deleted.
    /// This member is required.
    public var suiteDefinitionId: Swift.String?

    public init(
        suiteDefinitionId: Swift.String? = nil
    )
    {
        self.suiteDefinitionId = suiteDefinitionId
    }
}

public struct DeleteSuiteDefinitionOutput: Swift.Sendable {

    public init() { }
}

/// Sends a Resource Not Found exception.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// Sends a Resource Not Found Exception message.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct GetEndpointInput: Swift.Sendable {
    /// The authentication method used during the device connection.
    public var authenticationMethod: IotDeviceAdvisorClientTypes.AuthenticationMethod?
    /// The certificate ARN of the device. This is an optional parameter.
    public var certificateArn: Swift.String?
    /// The device role ARN of the device. This is an optional parameter.
    public var deviceRoleArn: Swift.String?
    /// The thing ARN of the device. This is an optional parameter.
    public var thingArn: Swift.String?

    public init(
        authenticationMethod: IotDeviceAdvisorClientTypes.AuthenticationMethod? = nil,
        certificateArn: Swift.String? = nil,
        deviceRoleArn: Swift.String? = nil,
        thingArn: Swift.String? = nil
    )
    {
        self.authenticationMethod = authenticationMethod
        self.certificateArn = certificateArn
        self.deviceRoleArn = deviceRoleArn
        self.thingArn = thingArn
    }
}

public struct GetEndpointOutput: Swift.Sendable {
    /// The response of an Device Advisor endpoint.
    public var endpoint: Swift.String?

    public init(
        endpoint: Swift.String? = nil
    )
    {
        self.endpoint = endpoint
    }
}

public struct GetSuiteDefinitionInput: Swift.Sendable {
    /// Suite definition ID of the test suite to get.
    /// This member is required.
    public var suiteDefinitionId: Swift.String?
    /// Suite definition version of the test suite to get.
    public var suiteDefinitionVersion: Swift.String?

    public init(
        suiteDefinitionId: Swift.String? = nil,
        suiteDefinitionVersion: Swift.String? = nil
    )
    {
        self.suiteDefinitionId = suiteDefinitionId
        self.suiteDefinitionVersion = suiteDefinitionVersion
    }
}

public struct GetSuiteDefinitionOutput: Swift.Sendable {
    /// Date (in Unix epoch time) when the suite definition was created.
    public var createdAt: Foundation.Date?
    /// Date (in Unix epoch time) when the suite definition was last modified.
    public var lastModifiedAt: Foundation.Date?
    /// Latest suite definition version of the suite definition.
    public var latestVersion: Swift.String?
    /// The ARN of the suite definition.
    public var suiteDefinitionArn: Swift.String?
    /// Suite configuration of the suite definition.
    public var suiteDefinitionConfiguration: IotDeviceAdvisorClientTypes.SuiteDefinitionConfiguration?
    /// Suite definition ID of the suite definition.
    public var suiteDefinitionId: Swift.String?
    /// Suite definition version of the suite definition.
    public var suiteDefinitionVersion: Swift.String?
    /// Tags attached to the suite definition.
    public var tags: [Swift.String: Swift.String]?

    public init(
        createdAt: Foundation.Date? = nil,
        lastModifiedAt: Foundation.Date? = nil,
        latestVersion: Swift.String? = nil,
        suiteDefinitionArn: Swift.String? = nil,
        suiteDefinitionConfiguration: IotDeviceAdvisorClientTypes.SuiteDefinitionConfiguration? = nil,
        suiteDefinitionId: Swift.String? = nil,
        suiteDefinitionVersion: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.createdAt = createdAt
        self.lastModifiedAt = lastModifiedAt
        self.latestVersion = latestVersion
        self.suiteDefinitionArn = suiteDefinitionArn
        self.suiteDefinitionConfiguration = suiteDefinitionConfiguration
        self.suiteDefinitionId = suiteDefinitionId
        self.suiteDefinitionVersion = suiteDefinitionVersion
        self.tags = tags
    }
}

public struct GetSuiteRunInput: Swift.Sendable {
    /// Suite definition ID for the test suite run.
    /// This member is required.
    public var suiteDefinitionId: Swift.String?
    /// Suite run ID for the test suite run.
    /// This member is required.
    public var suiteRunId: Swift.String?

    public init(
        suiteDefinitionId: Swift.String? = nil,
        suiteRunId: Swift.String? = nil
    )
    {
        self.suiteDefinitionId = suiteDefinitionId
        self.suiteRunId = suiteRunId
    }
}

extension IotDeviceAdvisorClientTypes {

    public enum SuiteRunStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case canceled
        case error
        case fail
        case pass
        case passWithWarnings
        case pending
        case running
        case stopped
        case stopping
        case sdkUnknown(Swift.String)

        public static var allCases: [SuiteRunStatus] {
            return [
                .canceled,
                .error,
                .fail,
                .pass,
                .passWithWarnings,
                .pending,
                .running,
                .stopped,
                .stopping
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .canceled: return "CANCELED"
            case .error: return "ERROR"
            case .fail: return "FAIL"
            case .pass: return "PASS"
            case .passWithWarnings: return "PASS_WITH_WARNINGS"
            case .pending: return "PENDING"
            case .running: return "RUNNING"
            case .stopped: return "STOPPED"
            case .stopping: return "STOPPING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IotDeviceAdvisorClientTypes {

    /// Gets suite run configuration.
    public struct SuiteRunConfiguration: Swift.Sendable {
        /// TRUE if multiple test suites run in parallel.
        public var parallelRun: Swift.Bool?
        /// Sets the primary device for the test suite run. This requires a thing ARN or a certificate ARN.
        /// This member is required.
        public var primaryDevice: IotDeviceAdvisorClientTypes.DeviceUnderTest?
        /// Sets test case list.
        public var selectedTestList: [Swift.String]?

        public init(
            parallelRun: Swift.Bool? = nil,
            primaryDevice: IotDeviceAdvisorClientTypes.DeviceUnderTest? = nil,
            selectedTestList: [Swift.String]? = nil
        )
        {
            self.parallelRun = parallelRun
            self.primaryDevice = primaryDevice
            self.selectedTestList = selectedTestList
        }
    }
}

extension IotDeviceAdvisorClientTypes {

    public enum Status: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case canceled
        case error
        case fail
        case pass
        case passWithWarnings
        case pending
        case running
        case stopped
        case stopping
        case sdkUnknown(Swift.String)

        public static var allCases: [Status] {
            return [
                .canceled,
                .error,
                .fail,
                .pass,
                .passWithWarnings,
                .pending,
                .running,
                .stopped,
                .stopping
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .canceled: return "CANCELED"
            case .error: return "ERROR"
            case .fail: return "FAIL"
            case .pass: return "PASS"
            case .passWithWarnings: return "PASS_WITH_WARNINGS"
            case .pending: return "PENDING"
            case .running: return "RUNNING"
            case .stopped: return "STOPPED"
            case .stopping: return "STOPPING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IotDeviceAdvisorClientTypes {

    public enum TestCaseScenarioStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case canceled
        case error
        case fail
        case pass
        case passWithWarnings
        case pending
        case running
        case stopped
        case stopping
        case sdkUnknown(Swift.String)

        public static var allCases: [TestCaseScenarioStatus] {
            return [
                .canceled,
                .error,
                .fail,
                .pass,
                .passWithWarnings,
                .pending,
                .running,
                .stopped,
                .stopping
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .canceled: return "CANCELED"
            case .error: return "ERROR"
            case .fail: return "FAIL"
            case .pass: return "PASS"
            case .passWithWarnings: return "PASS_WITH_WARNINGS"
            case .pending: return "PENDING"
            case .running: return "RUNNING"
            case .stopped: return "STOPPED"
            case .stopping: return "STOPPING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IotDeviceAdvisorClientTypes {

    public enum TestCaseScenarioType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case advanced
        case basic
        case sdkUnknown(Swift.String)

        public static var allCases: [TestCaseScenarioType] {
            return [
                .advanced,
                .basic
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .advanced: return "Advanced"
            case .basic: return "Basic"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IotDeviceAdvisorClientTypes {

    /// Provides test case scenario.
    public struct TestCaseScenario: Swift.Sendable {
        /// Provides test case scenario failure result.
        public var failure: Swift.String?
        /// Provides the test case scenario status. Status is one of the following:
        ///
        /// * PASS: Test passed.
        ///
        /// * FAIL: Test failed.
        ///
        /// * PENDING: Test has not started running but is scheduled.
        ///
        /// * RUNNING: Test is running.
        ///
        /// * STOPPING: Test is performing cleanup steps. You will see this status only if you stop a suite run.
        ///
        /// * STOPPED Test is stopped. You will see this status only if you stop a suite run.
        ///
        /// * PASS_WITH_WARNINGS: Test passed with warnings.
        ///
        /// * ERORR: Test faced an error when running due to an internal issue.
        public var status: IotDeviceAdvisorClientTypes.TestCaseScenarioStatus?
        /// Provides test case scenario system messages if any.
        public var systemMessage: Swift.String?
        /// Provides test case scenario ID.
        public var testCaseScenarioId: Swift.String?
        /// Provides test case scenario type. Type is one of the following:
        ///
        /// * Advanced
        ///
        /// * Basic
        public var testCaseScenarioType: IotDeviceAdvisorClientTypes.TestCaseScenarioType?

        public init(
            failure: Swift.String? = nil,
            status: IotDeviceAdvisorClientTypes.TestCaseScenarioStatus? = nil,
            systemMessage: Swift.String? = nil,
            testCaseScenarioId: Swift.String? = nil,
            testCaseScenarioType: IotDeviceAdvisorClientTypes.TestCaseScenarioType? = nil
        )
        {
            self.failure = failure
            self.status = status
            self.systemMessage = systemMessage
            self.testCaseScenarioId = testCaseScenarioId
            self.testCaseScenarioType = testCaseScenarioType
        }
    }
}

extension IotDeviceAdvisorClientTypes {

    /// Provides the test case run.
    public struct TestCaseRun: Swift.Sendable {
        /// Provides test case run end time.
        public var endTime: Foundation.Date?
        /// Provides test case run failure result.
        public var failure: Swift.String?
        /// Provides test case run log URL.
        public var logUrl: Swift.String?
        /// Provides test case run start time.
        public var startTime: Foundation.Date?
        /// Provides the test case run status. Status is one of the following:
        ///
        /// * PASS: Test passed.
        ///
        /// * FAIL: Test failed.
        ///
        /// * PENDING: Test has not started running but is scheduled.
        ///
        /// * RUNNING: Test is running.
        ///
        /// * STOPPING: Test is performing cleanup steps. You will see this status only if you stop a suite run.
        ///
        /// * STOPPED Test is stopped. You will see this status only if you stop a suite run.
        ///
        /// * PASS_WITH_WARNINGS: Test passed with warnings.
        ///
        /// * ERORR: Test faced an error when running due to an internal issue.
        public var status: IotDeviceAdvisorClientTypes.Status?
        /// Provides the test case run definition ID.
        public var testCaseDefinitionId: Swift.String?
        /// Provides the test case run definition name.
        public var testCaseDefinitionName: Swift.String?
        /// Provides the test case run ID.
        public var testCaseRunId: Swift.String?
        /// Provides the test scenarios for the test case run.
        public var testScenarios: [IotDeviceAdvisorClientTypes.TestCaseScenario]?
        /// Provides test case run warnings.
        public var warnings: Swift.String?

        public init(
            endTime: Foundation.Date? = nil,
            failure: Swift.String? = nil,
            logUrl: Swift.String? = nil,
            startTime: Foundation.Date? = nil,
            status: IotDeviceAdvisorClientTypes.Status? = nil,
            testCaseDefinitionId: Swift.String? = nil,
            testCaseDefinitionName: Swift.String? = nil,
            testCaseRunId: Swift.String? = nil,
            testScenarios: [IotDeviceAdvisorClientTypes.TestCaseScenario]? = nil,
            warnings: Swift.String? = nil
        )
        {
            self.endTime = endTime
            self.failure = failure
            self.logUrl = logUrl
            self.startTime = startTime
            self.status = status
            self.testCaseDefinitionId = testCaseDefinitionId
            self.testCaseDefinitionName = testCaseDefinitionName
            self.testCaseRunId = testCaseRunId
            self.testScenarios = testScenarios
            self.warnings = warnings
        }
    }
}

extension IotDeviceAdvisorClientTypes {

    /// Show Group Result.
    public struct GroupResult: Swift.Sendable {
        /// Group result ID.
        public var groupId: Swift.String?
        /// Group Result Name.
        public var groupName: Swift.String?
        /// Tests under Group Result.
        public var tests: [IotDeviceAdvisorClientTypes.TestCaseRun]?

        public init(
            groupId: Swift.String? = nil,
            groupName: Swift.String? = nil,
            tests: [IotDeviceAdvisorClientTypes.TestCaseRun]? = nil
        )
        {
            self.groupId = groupId
            self.groupName = groupName
            self.tests = tests
        }
    }
}

extension IotDeviceAdvisorClientTypes {

    /// Show each group result.
    public struct TestResult: Swift.Sendable {
        /// Show each group of test results.
        public var groups: [IotDeviceAdvisorClientTypes.GroupResult]?

        public init(
            groups: [IotDeviceAdvisorClientTypes.GroupResult]? = nil
        )
        {
            self.groups = groups
        }
    }
}

public struct GetSuiteRunOutput: Swift.Sendable {
    /// Date (in Unix epoch time) when the test suite run ended.
    public var endTime: Foundation.Date?
    /// Error reason for any test suite run failure.
    public var errorReason: Swift.String?
    /// Date (in Unix epoch time) when the test suite run started.
    public var startTime: Foundation.Date?
    /// Status for the test suite run.
    public var status: IotDeviceAdvisorClientTypes.SuiteRunStatus?
    /// Suite definition ID for the test suite run.
    public var suiteDefinitionId: Swift.String?
    /// Suite definition version for the test suite run.
    public var suiteDefinitionVersion: Swift.String?
    /// The ARN of the suite run.
    public var suiteRunArn: Swift.String?
    /// Suite run configuration for the test suite run.
    public var suiteRunConfiguration: IotDeviceAdvisorClientTypes.SuiteRunConfiguration?
    /// Suite run ID for the test suite run.
    public var suiteRunId: Swift.String?
    /// The tags attached to the suite run.
    public var tags: [Swift.String: Swift.String]?
    /// Test results for the test suite run.
    public var testResult: IotDeviceAdvisorClientTypes.TestResult?

    public init(
        endTime: Foundation.Date? = nil,
        errorReason: Swift.String? = nil,
        startTime: Foundation.Date? = nil,
        status: IotDeviceAdvisorClientTypes.SuiteRunStatus? = nil,
        suiteDefinitionId: Swift.String? = nil,
        suiteDefinitionVersion: Swift.String? = nil,
        suiteRunArn: Swift.String? = nil,
        suiteRunConfiguration: IotDeviceAdvisorClientTypes.SuiteRunConfiguration? = nil,
        suiteRunId: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        testResult: IotDeviceAdvisorClientTypes.TestResult? = nil
    )
    {
        self.endTime = endTime
        self.errorReason = errorReason
        self.startTime = startTime
        self.status = status
        self.suiteDefinitionId = suiteDefinitionId
        self.suiteDefinitionVersion = suiteDefinitionVersion
        self.suiteRunArn = suiteRunArn
        self.suiteRunConfiguration = suiteRunConfiguration
        self.suiteRunId = suiteRunId
        self.tags = tags
        self.testResult = testResult
    }
}

public struct GetSuiteRunReportInput: Swift.Sendable {
    /// Suite definition ID of the test suite.
    /// This member is required.
    public var suiteDefinitionId: Swift.String?
    /// Suite run ID of the test suite run.
    /// This member is required.
    public var suiteRunId: Swift.String?

    public init(
        suiteDefinitionId: Swift.String? = nil,
        suiteRunId: Swift.String? = nil
    )
    {
        self.suiteDefinitionId = suiteDefinitionId
        self.suiteRunId = suiteRunId
    }
}

public struct GetSuiteRunReportOutput: Swift.Sendable {
    /// Download URL of the qualification report.
    public var qualificationReportDownloadUrl: Swift.String?

    public init(
        qualificationReportDownloadUrl: Swift.String? = nil
    )
    {
        self.qualificationReportDownloadUrl = qualificationReportDownloadUrl
    }
}

public struct ListSuiteDefinitionsInput: Swift.Sendable {
    /// The maximum number of results to return at once.
    public var maxResults: Swift.Int?
    /// A token used to get the next set of results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension IotDeviceAdvisorClientTypes {

    /// Information about the suite definition.
    public struct SuiteDefinitionInformation: Swift.Sendable {
        /// Date (in Unix epoch time) when the test suite was created.
        public var createdAt: Foundation.Date?
        /// Specifies the devices that are under test for the test suite.
        public var defaultDevices: [IotDeviceAdvisorClientTypes.DeviceUnderTest]?
        /// Specifies if the test suite is intended for qualification.
        public var intendedForQualification: Swift.Bool?
        /// Verifies if the test suite is a long duration test.
        public var isLongDurationTest: Swift.Bool?
        /// Gets the MQTT protocol that is configured in the suite definition.
        public var `protocol`: IotDeviceAdvisorClientTypes.ModelProtocol?
        /// Suite definition ID of the test suite.
        public var suiteDefinitionId: Swift.String?
        /// Suite name of the test suite.
        public var suiteDefinitionName: Swift.String?

        public init(
            createdAt: Foundation.Date? = nil,
            defaultDevices: [IotDeviceAdvisorClientTypes.DeviceUnderTest]? = nil,
            intendedForQualification: Swift.Bool? = nil,
            isLongDurationTest: Swift.Bool? = nil,
            `protocol`: IotDeviceAdvisorClientTypes.ModelProtocol? = nil,
            suiteDefinitionId: Swift.String? = nil,
            suiteDefinitionName: Swift.String? = nil
        )
        {
            self.createdAt = createdAt
            self.defaultDevices = defaultDevices
            self.intendedForQualification = intendedForQualification
            self.isLongDurationTest = isLongDurationTest
            self.`protocol` = `protocol`
            self.suiteDefinitionId = suiteDefinitionId
            self.suiteDefinitionName = suiteDefinitionName
        }
    }
}

public struct ListSuiteDefinitionsOutput: Swift.Sendable {
    /// A token used to get the next set of results.
    public var nextToken: Swift.String?
    /// An array of objects that provide summaries of information about the suite definitions in the list.
    public var suiteDefinitionInformationList: [IotDeviceAdvisorClientTypes.SuiteDefinitionInformation]?

    public init(
        nextToken: Swift.String? = nil,
        suiteDefinitionInformationList: [IotDeviceAdvisorClientTypes.SuiteDefinitionInformation]? = nil
    )
    {
        self.nextToken = nextToken
        self.suiteDefinitionInformationList = suiteDefinitionInformationList
    }
}

public struct ListSuiteRunsInput: Swift.Sendable {
    /// The maximum number of results to return at once.
    public var maxResults: Swift.Int?
    /// A token to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// Lists the test suite runs of the specified test suite based on suite definition ID.
    public var suiteDefinitionId: Swift.String?
    /// Must be passed along with suiteDefinitionId. Lists the test suite runs of the specified test suite based on suite definition version.
    public var suiteDefinitionVersion: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        suiteDefinitionId: Swift.String? = nil,
        suiteDefinitionVersion: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.suiteDefinitionId = suiteDefinitionId
        self.suiteDefinitionVersion = suiteDefinitionVersion
    }
}

extension IotDeviceAdvisorClientTypes {

    /// Information about the suite run. Requires permission to access the [SuiteRunInformation](https://docs.aws.amazon.com/service-authorization/latest/reference/list_awsiot.html#awsiot-actions-as-permissions) action.
    public struct SuiteRunInformation: Swift.Sendable {
        /// Date (in Unix epoch time) when the suite run was created.
        public var createdAt: Foundation.Date?
        /// Date (in Unix epoch time) when the suite run ended.
        public var endAt: Foundation.Date?
        /// Number of test cases that failed in the suite run.
        public var failed: Swift.Int?
        /// Number of test cases that passed in the suite run.
        public var passed: Swift.Int?
        /// Date (in Unix epoch time) when the suite run was started.
        public var startedAt: Foundation.Date?
        /// Status of the suite run.
        public var status: IotDeviceAdvisorClientTypes.SuiteRunStatus?
        /// Suite definition ID of the suite run.
        public var suiteDefinitionId: Swift.String?
        /// Suite definition name of the suite run.
        public var suiteDefinitionName: Swift.String?
        /// Suite definition version of the suite run.
        public var suiteDefinitionVersion: Swift.String?
        /// Suite run ID of the suite run.
        public var suiteRunId: Swift.String?

        public init(
            createdAt: Foundation.Date? = nil,
            endAt: Foundation.Date? = nil,
            failed: Swift.Int? = nil,
            passed: Swift.Int? = nil,
            startedAt: Foundation.Date? = nil,
            status: IotDeviceAdvisorClientTypes.SuiteRunStatus? = nil,
            suiteDefinitionId: Swift.String? = nil,
            suiteDefinitionName: Swift.String? = nil,
            suiteDefinitionVersion: Swift.String? = nil,
            suiteRunId: Swift.String? = nil
        )
        {
            self.createdAt = createdAt
            self.endAt = endAt
            self.failed = failed
            self.passed = passed
            self.startedAt = startedAt
            self.status = status
            self.suiteDefinitionId = suiteDefinitionId
            self.suiteDefinitionName = suiteDefinitionName
            self.suiteDefinitionVersion = suiteDefinitionVersion
            self.suiteRunId = suiteRunId
        }
    }
}

public struct ListSuiteRunsOutput: Swift.Sendable {
    /// A token to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// An array of objects that provide summaries of information about the suite runs in the list.
    public var suiteRunsList: [IotDeviceAdvisorClientTypes.SuiteRunInformation]?

    public init(
        nextToken: Swift.String? = nil,
        suiteRunsList: [IotDeviceAdvisorClientTypes.SuiteRunInformation]? = nil
    )
    {
        self.nextToken = nextToken
        self.suiteRunsList = suiteRunsList
    }
}

public struct ListTagsForResourceInput: Swift.Sendable {
    /// The resource ARN of the IoT Device Advisor resource. This can be SuiteDefinition ARN or SuiteRun ARN.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

public struct ListTagsForResourceOutput: Swift.Sendable {
    /// The tags attached to the IoT Device Advisor resource.
    public var tags: [Swift.String: Swift.String]?

    public init(
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

public struct StartSuiteRunInput: Swift.Sendable {
    /// Suite definition ID of the test suite.
    /// This member is required.
    public var suiteDefinitionId: Swift.String?
    /// Suite definition version of the test suite.
    public var suiteDefinitionVersion: Swift.String?
    /// Suite run configuration.
    /// This member is required.
    public var suiteRunConfiguration: IotDeviceAdvisorClientTypes.SuiteRunConfiguration?
    /// The tags to be attached to the suite run.
    public var tags: [Swift.String: Swift.String]?

    public init(
        suiteDefinitionId: Swift.String? = nil,
        suiteDefinitionVersion: Swift.String? = nil,
        suiteRunConfiguration: IotDeviceAdvisorClientTypes.SuiteRunConfiguration? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.suiteDefinitionId = suiteDefinitionId
        self.suiteDefinitionVersion = suiteDefinitionVersion
        self.suiteRunConfiguration = suiteRunConfiguration
        self.tags = tags
    }
}

public struct StartSuiteRunOutput: Swift.Sendable {
    /// Starts a Device Advisor test suite run based on suite create time.
    public var createdAt: Foundation.Date?
    /// The response of an Device Advisor test endpoint.
    public var endpoint: Swift.String?
    /// Amazon Resource Name (ARN) of the started suite run.
    public var suiteRunArn: Swift.String?
    /// Suite Run ID of the started suite run.
    public var suiteRunId: Swift.String?

    public init(
        createdAt: Foundation.Date? = nil,
        endpoint: Swift.String? = nil,
        suiteRunArn: Swift.String? = nil,
        suiteRunId: Swift.String? = nil
    )
    {
        self.createdAt = createdAt
        self.endpoint = endpoint
        self.suiteRunArn = suiteRunArn
        self.suiteRunId = suiteRunId
    }
}

public struct StopSuiteRunInput: Swift.Sendable {
    /// Suite definition ID of the test suite run to be stopped.
    /// This member is required.
    public var suiteDefinitionId: Swift.String?
    /// Suite run ID of the test suite run to be stopped.
    /// This member is required.
    public var suiteRunId: Swift.String?

    public init(
        suiteDefinitionId: Swift.String? = nil,
        suiteRunId: Swift.String? = nil
    )
    {
        self.suiteDefinitionId = suiteDefinitionId
        self.suiteRunId = suiteRunId
    }
}

public struct StopSuiteRunOutput: Swift.Sendable {

    public init() { }
}

public struct TagResourceInput: Swift.Sendable {
    /// The resource ARN of an IoT Device Advisor resource. This can be SuiteDefinition ARN or SuiteRun ARN.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tags to be attached to the IoT Device Advisor resource.
    /// This member is required.
    public var tags: [Swift.String: Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

public struct TagResourceOutput: Swift.Sendable {

    public init() { }
}

public struct UntagResourceInput: Swift.Sendable {
    /// The resource ARN of an IoT Device Advisor resource. This can be SuiteDefinition ARN or SuiteRun ARN.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// List of tag keys to remove from the IoT Device Advisor resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

public struct UntagResourceOutput: Swift.Sendable {

    public init() { }
}

public struct UpdateSuiteDefinitionInput: Swift.Sendable {
    /// Updates a Device Advisor test suite with suite definition configuration.
    /// This member is required.
    public var suiteDefinitionConfiguration: IotDeviceAdvisorClientTypes.SuiteDefinitionConfiguration?
    /// Suite definition ID of the test suite to be updated.
    /// This member is required.
    public var suiteDefinitionId: Swift.String?

    public init(
        suiteDefinitionConfiguration: IotDeviceAdvisorClientTypes.SuiteDefinitionConfiguration? = nil,
        suiteDefinitionId: Swift.String? = nil
    )
    {
        self.suiteDefinitionConfiguration = suiteDefinitionConfiguration
        self.suiteDefinitionId = suiteDefinitionId
    }
}

public struct UpdateSuiteDefinitionOutput: Swift.Sendable {
    /// Timestamp of when the test suite was created.
    public var createdAt: Foundation.Date?
    /// Timestamp of when the test suite was updated.
    public var lastUpdatedAt: Foundation.Date?
    /// Amazon Resource Name (ARN) of the updated test suite.
    public var suiteDefinitionArn: Swift.String?
    /// Suite definition ID of the updated test suite.
    public var suiteDefinitionId: Swift.String?
    /// Updates the suite definition name. This is a required parameter.
    public var suiteDefinitionName: Swift.String?
    /// Suite definition version of the updated test suite.
    public var suiteDefinitionVersion: Swift.String?

    public init(
        createdAt: Foundation.Date? = nil,
        lastUpdatedAt: Foundation.Date? = nil,
        suiteDefinitionArn: Swift.String? = nil,
        suiteDefinitionId: Swift.String? = nil,
        suiteDefinitionName: Swift.String? = nil,
        suiteDefinitionVersion: Swift.String? = nil
    )
    {
        self.createdAt = createdAt
        self.lastUpdatedAt = lastUpdatedAt
        self.suiteDefinitionArn = suiteDefinitionArn
        self.suiteDefinitionId = suiteDefinitionId
        self.suiteDefinitionName = suiteDefinitionName
        self.suiteDefinitionVersion = suiteDefinitionVersion
    }
}

extension CreateSuiteDefinitionInput {

    static func urlPathProvider(_ value: CreateSuiteDefinitionInput) -> Swift.String? {
        return "/suiteDefinitions"
    }
}

extension DeleteSuiteDefinitionInput {

    static func urlPathProvider(_ value: DeleteSuiteDefinitionInput) -> Swift.String? {
        guard let suiteDefinitionId = value.suiteDefinitionId else {
            return nil
        }
        return "/suiteDefinitions/\(suiteDefinitionId.urlPercentEncoding())"
    }
}

extension GetEndpointInput {

    static func urlPathProvider(_ value: GetEndpointInput) -> Swift.String? {
        return "/endpoint"
    }
}

extension GetEndpointInput {

    static func queryItemProvider(_ value: GetEndpointInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let thingArn = value.thingArn {
            let thingArnQueryItem = Smithy.URIQueryItem(name: "thingArn".urlPercentEncoding(), value: Swift.String(thingArn).urlPercentEncoding())
            items.append(thingArnQueryItem)
        }
        if let certificateArn = value.certificateArn {
            let certificateArnQueryItem = Smithy.URIQueryItem(name: "certificateArn".urlPercentEncoding(), value: Swift.String(certificateArn).urlPercentEncoding())
            items.append(certificateArnQueryItem)
        }
        if let deviceRoleArn = value.deviceRoleArn {
            let deviceRoleArnQueryItem = Smithy.URIQueryItem(name: "deviceRoleArn".urlPercentEncoding(), value: Swift.String(deviceRoleArn).urlPercentEncoding())
            items.append(deviceRoleArnQueryItem)
        }
        if let authenticationMethod = value.authenticationMethod {
            let authenticationMethodQueryItem = Smithy.URIQueryItem(name: "authenticationMethod".urlPercentEncoding(), value: Swift.String(authenticationMethod.rawValue).urlPercentEncoding())
            items.append(authenticationMethodQueryItem)
        }
        return items
    }
}

extension GetSuiteDefinitionInput {

    static func urlPathProvider(_ value: GetSuiteDefinitionInput) -> Swift.String? {
        guard let suiteDefinitionId = value.suiteDefinitionId else {
            return nil
        }
        return "/suiteDefinitions/\(suiteDefinitionId.urlPercentEncoding())"
    }
}

extension GetSuiteDefinitionInput {

    static func queryItemProvider(_ value: GetSuiteDefinitionInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let suiteDefinitionVersion = value.suiteDefinitionVersion {
            let suiteDefinitionVersionQueryItem = Smithy.URIQueryItem(name: "suiteDefinitionVersion".urlPercentEncoding(), value: Swift.String(suiteDefinitionVersion).urlPercentEncoding())
            items.append(suiteDefinitionVersionQueryItem)
        }
        return items
    }
}

extension GetSuiteRunInput {

    static func urlPathProvider(_ value: GetSuiteRunInput) -> Swift.String? {
        guard let suiteDefinitionId = value.suiteDefinitionId else {
            return nil
        }
        guard let suiteRunId = value.suiteRunId else {
            return nil
        }
        return "/suiteDefinitions/\(suiteDefinitionId.urlPercentEncoding())/suiteRuns/\(suiteRunId.urlPercentEncoding())"
    }
}

extension GetSuiteRunReportInput {

    static func urlPathProvider(_ value: GetSuiteRunReportInput) -> Swift.String? {
        guard let suiteDefinitionId = value.suiteDefinitionId else {
            return nil
        }
        guard let suiteRunId = value.suiteRunId else {
            return nil
        }
        return "/suiteDefinitions/\(suiteDefinitionId.urlPercentEncoding())/suiteRuns/\(suiteRunId.urlPercentEncoding())/report"
    }
}

extension ListSuiteDefinitionsInput {

    static func urlPathProvider(_ value: ListSuiteDefinitionsInput) -> Swift.String? {
        return "/suiteDefinitions"
    }
}

extension ListSuiteDefinitionsInput {

    static func queryItemProvider(_ value: ListSuiteDefinitionsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        return items
    }
}

extension ListSuiteRunsInput {

    static func urlPathProvider(_ value: ListSuiteRunsInput) -> Swift.String? {
        return "/suiteRuns"
    }
}

extension ListSuiteRunsInput {

    static func queryItemProvider(_ value: ListSuiteRunsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let suiteDefinitionId = value.suiteDefinitionId {
            let suiteDefinitionIdQueryItem = Smithy.URIQueryItem(name: "suiteDefinitionId".urlPercentEncoding(), value: Swift.String(suiteDefinitionId).urlPercentEncoding())
            items.append(suiteDefinitionIdQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let suiteDefinitionVersion = value.suiteDefinitionVersion {
            let suiteDefinitionVersionQueryItem = Smithy.URIQueryItem(name: "suiteDefinitionVersion".urlPercentEncoding(), value: Swift.String(suiteDefinitionVersion).urlPercentEncoding())
            items.append(suiteDefinitionVersionQueryItem)
        }
        return items
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension StartSuiteRunInput {

    static func urlPathProvider(_ value: StartSuiteRunInput) -> Swift.String? {
        guard let suiteDefinitionId = value.suiteDefinitionId else {
            return nil
        }
        return "/suiteDefinitions/\(suiteDefinitionId.urlPercentEncoding())/suiteRuns"
    }
}

extension StopSuiteRunInput {

    static func urlPathProvider(_ value: StopSuiteRunInput) -> Swift.String? {
        guard let suiteDefinitionId = value.suiteDefinitionId else {
            return nil
        }
        guard let suiteRunId = value.suiteRunId else {
            return nil
        }
        return "/suiteDefinitions/\(suiteDefinitionId.urlPercentEncoding())/suiteRuns/\(suiteRunId.urlPercentEncoding())/stop"
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension UntagResourceInput {

    static func queryItemProvider(_ value: UntagResourceInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let tagKeys = value.tagKeys else {
            let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        tagKeys.forEach { queryItemValue in
            let queryItem = Smithy.URIQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
            items.append(queryItem)
        }
        return items
    }
}

extension UpdateSuiteDefinitionInput {

    static func urlPathProvider(_ value: UpdateSuiteDefinitionInput) -> Swift.String? {
        guard let suiteDefinitionId = value.suiteDefinitionId else {
            return nil
        }
        return "/suiteDefinitions/\(suiteDefinitionId.urlPercentEncoding())"
    }
}

extension CreateSuiteDefinitionInput {

    static func write(value: CreateSuiteDefinitionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["suiteDefinitionConfiguration"].write(value.suiteDefinitionConfiguration, with: IotDeviceAdvisorClientTypes.SuiteDefinitionConfiguration.write(value:to:))
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension StartSuiteRunInput {

    static func write(value: StartSuiteRunInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["suiteDefinitionVersion"].write(value.suiteDefinitionVersion)
        try writer["suiteRunConfiguration"].write(value.suiteRunConfiguration, with: IotDeviceAdvisorClientTypes.SuiteRunConfiguration.write(value:to:))
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension UpdateSuiteDefinitionInput {

    static func write(value: UpdateSuiteDefinitionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["suiteDefinitionConfiguration"].write(value.suiteDefinitionConfiguration, with: IotDeviceAdvisorClientTypes.SuiteDefinitionConfiguration.write(value:to:))
    }
}

extension CreateSuiteDefinitionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateSuiteDefinitionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateSuiteDefinitionOutput()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.suiteDefinitionArn = try reader["suiteDefinitionArn"].readIfPresent()
        value.suiteDefinitionId = try reader["suiteDefinitionId"].readIfPresent()
        value.suiteDefinitionName = try reader["suiteDefinitionName"].readIfPresent()
        return value
    }
}

extension DeleteSuiteDefinitionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteSuiteDefinitionOutput {
        return DeleteSuiteDefinitionOutput()
    }
}

extension GetEndpointOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetEndpointOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetEndpointOutput()
        value.endpoint = try reader["endpoint"].readIfPresent()
        return value
    }
}

extension GetSuiteDefinitionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetSuiteDefinitionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetSuiteDefinitionOutput()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastModifiedAt = try reader["lastModifiedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.latestVersion = try reader["latestVersion"].readIfPresent()
        value.suiteDefinitionArn = try reader["suiteDefinitionArn"].readIfPresent()
        value.suiteDefinitionConfiguration = try reader["suiteDefinitionConfiguration"].readIfPresent(with: IotDeviceAdvisorClientTypes.SuiteDefinitionConfiguration.read(from:))
        value.suiteDefinitionId = try reader["suiteDefinitionId"].readIfPresent()
        value.suiteDefinitionVersion = try reader["suiteDefinitionVersion"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension GetSuiteRunOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetSuiteRunOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetSuiteRunOutput()
        value.endTime = try reader["endTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.errorReason = try reader["errorReason"].readIfPresent()
        value.startTime = try reader["startTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.status = try reader["status"].readIfPresent()
        value.suiteDefinitionId = try reader["suiteDefinitionId"].readIfPresent()
        value.suiteDefinitionVersion = try reader["suiteDefinitionVersion"].readIfPresent()
        value.suiteRunArn = try reader["suiteRunArn"].readIfPresent()
        value.suiteRunConfiguration = try reader["suiteRunConfiguration"].readIfPresent(with: IotDeviceAdvisorClientTypes.SuiteRunConfiguration.read(from:))
        value.suiteRunId = try reader["suiteRunId"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.testResult = try reader["testResult"].readIfPresent(with: IotDeviceAdvisorClientTypes.TestResult.read(from:))
        return value
    }
}

extension GetSuiteRunReportOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetSuiteRunReportOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetSuiteRunReportOutput()
        value.qualificationReportDownloadUrl = try reader["qualificationReportDownloadUrl"].readIfPresent()
        return value
    }
}

extension ListSuiteDefinitionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListSuiteDefinitionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListSuiteDefinitionsOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.suiteDefinitionInformationList = try reader["suiteDefinitionInformationList"].readListIfPresent(memberReadingClosure: IotDeviceAdvisorClientTypes.SuiteDefinitionInformation.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListSuiteRunsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListSuiteRunsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListSuiteRunsOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.suiteRunsList = try reader["suiteRunsList"].readListIfPresent(memberReadingClosure: IotDeviceAdvisorClientTypes.SuiteRunInformation.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension StartSuiteRunOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartSuiteRunOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartSuiteRunOutput()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.endpoint = try reader["endpoint"].readIfPresent()
        value.suiteRunArn = try reader["suiteRunArn"].readIfPresent()
        value.suiteRunId = try reader["suiteRunId"].readIfPresent()
        return value
    }
}

extension StopSuiteRunOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StopSuiteRunOutput {
        return StopSuiteRunOutput()
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

extension UpdateSuiteDefinitionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateSuiteDefinitionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateSuiteDefinitionOutput()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastUpdatedAt = try reader["lastUpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.suiteDefinitionArn = try reader["suiteDefinitionArn"].readIfPresent()
        value.suiteDefinitionId = try reader["suiteDefinitionId"].readIfPresent()
        value.suiteDefinitionName = try reader["suiteDefinitionName"].readIfPresent()
        value.suiteDefinitionVersion = try reader["suiteDefinitionVersion"].readIfPresent()
        return value
    }
}

enum CreateSuiteDefinitionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteSuiteDefinitionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetEndpointOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetSuiteDefinitionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetSuiteRunOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetSuiteRunReportOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListSuiteDefinitionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListSuiteRunsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartSuiteRunOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StopSuiteRunOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateSuiteDefinitionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ValidationException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ValidationException {
        let reader = baseError.errorBodyReader
        var value = ValidationException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InternalServerException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InternalServerException {
        let reader = baseError.errorBodyReader
        var value = InternalServerException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ConflictException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ConflictException {
        let reader = baseError.errorBodyReader
        var value = ConflictException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension IotDeviceAdvisorClientTypes.SuiteDefinitionConfiguration {

    static func write(value: IotDeviceAdvisorClientTypes.SuiteDefinitionConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["devicePermissionRoleArn"].write(value.devicePermissionRoleArn)
        try writer["devices"].writeList(value.devices, memberWritingClosure: IotDeviceAdvisorClientTypes.DeviceUnderTest.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["intendedForQualification"].write(value.intendedForQualification)
        try writer["isLongDurationTest"].write(value.isLongDurationTest)
        try writer["protocol"].write(value.`protocol`)
        try writer["rootGroup"].write(value.rootGroup)
        try writer["suiteDefinitionName"].write(value.suiteDefinitionName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IotDeviceAdvisorClientTypes.SuiteDefinitionConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IotDeviceAdvisorClientTypes.SuiteDefinitionConfiguration()
        value.suiteDefinitionName = try reader["suiteDefinitionName"].readIfPresent() ?? ""
        value.devices = try reader["devices"].readListIfPresent(memberReadingClosure: IotDeviceAdvisorClientTypes.DeviceUnderTest.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.intendedForQualification = try reader["intendedForQualification"].readIfPresent()
        value.isLongDurationTest = try reader["isLongDurationTest"].readIfPresent()
        value.rootGroup = try reader["rootGroup"].readIfPresent() ?? ""
        value.devicePermissionRoleArn = try reader["devicePermissionRoleArn"].readIfPresent() ?? ""
        value.`protocol` = try reader["protocol"].readIfPresent()
        return value
    }
}

extension IotDeviceAdvisorClientTypes.DeviceUnderTest {

    static func write(value: IotDeviceAdvisorClientTypes.DeviceUnderTest?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["certificateArn"].write(value.certificateArn)
        try writer["deviceRoleArn"].write(value.deviceRoleArn)
        try writer["thingArn"].write(value.thingArn)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IotDeviceAdvisorClientTypes.DeviceUnderTest {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IotDeviceAdvisorClientTypes.DeviceUnderTest()
        value.thingArn = try reader["thingArn"].readIfPresent()
        value.certificateArn = try reader["certificateArn"].readIfPresent()
        value.deviceRoleArn = try reader["deviceRoleArn"].readIfPresent()
        return value
    }
}

extension IotDeviceAdvisorClientTypes.SuiteRunConfiguration {

    static func write(value: IotDeviceAdvisorClientTypes.SuiteRunConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["parallelRun"].write(value.parallelRun)
        try writer["primaryDevice"].write(value.primaryDevice, with: IotDeviceAdvisorClientTypes.DeviceUnderTest.write(value:to:))
        try writer["selectedTestList"].writeList(value.selectedTestList, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IotDeviceAdvisorClientTypes.SuiteRunConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IotDeviceAdvisorClientTypes.SuiteRunConfiguration()
        value.primaryDevice = try reader["primaryDevice"].readIfPresent(with: IotDeviceAdvisorClientTypes.DeviceUnderTest.read(from:))
        value.selectedTestList = try reader["selectedTestList"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.parallelRun = try reader["parallelRun"].readIfPresent()
        return value
    }
}

extension IotDeviceAdvisorClientTypes.TestResult {

    static func read(from reader: SmithyJSON.Reader) throws -> IotDeviceAdvisorClientTypes.TestResult {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IotDeviceAdvisorClientTypes.TestResult()
        value.groups = try reader["groups"].readListIfPresent(memberReadingClosure: IotDeviceAdvisorClientTypes.GroupResult.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension IotDeviceAdvisorClientTypes.GroupResult {

    static func read(from reader: SmithyJSON.Reader) throws -> IotDeviceAdvisorClientTypes.GroupResult {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IotDeviceAdvisorClientTypes.GroupResult()
        value.groupId = try reader["groupId"].readIfPresent()
        value.groupName = try reader["groupName"].readIfPresent()
        value.tests = try reader["tests"].readListIfPresent(memberReadingClosure: IotDeviceAdvisorClientTypes.TestCaseRun.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension IotDeviceAdvisorClientTypes.TestCaseRun {

    static func read(from reader: SmithyJSON.Reader) throws -> IotDeviceAdvisorClientTypes.TestCaseRun {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IotDeviceAdvisorClientTypes.TestCaseRun()
        value.testCaseRunId = try reader["testCaseRunId"].readIfPresent()
        value.testCaseDefinitionId = try reader["testCaseDefinitionId"].readIfPresent()
        value.testCaseDefinitionName = try reader["testCaseDefinitionName"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.startTime = try reader["startTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.endTime = try reader["endTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.logUrl = try reader["logUrl"].readIfPresent()
        value.warnings = try reader["warnings"].readIfPresent()
        value.failure = try reader["failure"].readIfPresent()
        value.testScenarios = try reader["testScenarios"].readListIfPresent(memberReadingClosure: IotDeviceAdvisorClientTypes.TestCaseScenario.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension IotDeviceAdvisorClientTypes.TestCaseScenario {

    static func read(from reader: SmithyJSON.Reader) throws -> IotDeviceAdvisorClientTypes.TestCaseScenario {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IotDeviceAdvisorClientTypes.TestCaseScenario()
        value.testCaseScenarioId = try reader["testCaseScenarioId"].readIfPresent()
        value.testCaseScenarioType = try reader["testCaseScenarioType"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.failure = try reader["failure"].readIfPresent()
        value.systemMessage = try reader["systemMessage"].readIfPresent()
        return value
    }
}

extension IotDeviceAdvisorClientTypes.SuiteDefinitionInformation {

    static func read(from reader: SmithyJSON.Reader) throws -> IotDeviceAdvisorClientTypes.SuiteDefinitionInformation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IotDeviceAdvisorClientTypes.SuiteDefinitionInformation()
        value.suiteDefinitionId = try reader["suiteDefinitionId"].readIfPresent()
        value.suiteDefinitionName = try reader["suiteDefinitionName"].readIfPresent()
        value.defaultDevices = try reader["defaultDevices"].readListIfPresent(memberReadingClosure: IotDeviceAdvisorClientTypes.DeviceUnderTest.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.intendedForQualification = try reader["intendedForQualification"].readIfPresent()
        value.isLongDurationTest = try reader["isLongDurationTest"].readIfPresent()
        value.`protocol` = try reader["protocol"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension IotDeviceAdvisorClientTypes.SuiteRunInformation {

    static func read(from reader: SmithyJSON.Reader) throws -> IotDeviceAdvisorClientTypes.SuiteRunInformation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IotDeviceAdvisorClientTypes.SuiteRunInformation()
        value.suiteDefinitionId = try reader["suiteDefinitionId"].readIfPresent()
        value.suiteDefinitionVersion = try reader["suiteDefinitionVersion"].readIfPresent()
        value.suiteDefinitionName = try reader["suiteDefinitionName"].readIfPresent()
        value.suiteRunId = try reader["suiteRunId"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.startedAt = try reader["startedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.endAt = try reader["endAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.status = try reader["status"].readIfPresent()
        value.passed = try reader["passed"].readIfPresent()
        value.failed = try reader["failed"].readIfPresent()
        return value
    }
}

public enum IotDeviceAdvisorClientTypes {}
