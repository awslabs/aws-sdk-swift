//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum Smithy.ClientError
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.RestJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
import struct Smithy.URIQueryItem
import struct SmithyHTTPAPI.Header
import struct SmithyHTTPAPI.Headers
@_spi(SmithyReadWrite) import struct SmithyReadWrite.ReadingClosureBox
@_spi(SmithyReadWrite) import struct SmithyReadWrite.WritingClosureBox
@_spi(SmithyTimestamps) import struct SmithyTimestamps.TimestampFormatter


public struct AssociateAssetsOutput: Swift.Sendable {

    public init() { }
}

public struct AssociateTimeSeriesToAssetPropertyOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteGatewayOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteTimeSeriesOutput: Swift.Sendable {

    public init() { }
}

public struct DisassociateAssetsOutput: Swift.Sendable {

    public init() { }
}

public struct DisassociateTimeSeriesFromAssetPropertyOutput: Swift.Sendable {

    public init() { }
}

public struct UpdateAssetPropertyOutput: Swift.Sendable {

    public init() { }
}

public struct UpdateGatewayOutput: Swift.Sendable {

    public init() { }
}

/// Access is denied.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension IoTSiteWiseClientTypes {

    /// Contains information for a group identity in an access policy.
    public struct GroupIdentity: Swift.Sendable {
        /// The IAM Identity Center ID of the group.
        /// This member is required.
        public var id: Swift.String?

        public init(
            id: Swift.String? = nil
        )
        {
            self.id = id
        }
    }
}

extension IoTSiteWiseClientTypes {

    /// Contains information about an Identity and Access Management role. For more information, see [IAM roles](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles.html) in the IAM User Guide.
    public struct IAMRoleIdentity: Swift.Sendable {
        /// The ARN of the IAM role. For more information, see [IAM ARNs](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_identifiers.html) in the IAM User Guide.
        /// This member is required.
        public var arn: Swift.String?

        public init(
            arn: Swift.String? = nil
        )
        {
            self.arn = arn
        }
    }
}

extension IoTSiteWiseClientTypes {

    /// Contains information about an Identity and Access Management user.
    public struct IAMUserIdentity: Swift.Sendable {
        /// The ARN of the IAM user. For more information, see [IAM ARNs](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_identifiers.html) in the IAM User Guide. If you delete the IAM user, access policies that contain this identity include an empty arn. You can delete the access policy for the IAM user that no longer exists.
        /// This member is required.
        public var arn: Swift.String?

        public init(
            arn: Swift.String? = nil
        )
        {
            self.arn = arn
        }
    }
}

extension IoTSiteWiseClientTypes {

    /// Contains information for a user identity in an access policy.
    public struct UserIdentity: Swift.Sendable {
        /// The IAM Identity Center ID of the user.
        /// This member is required.
        public var id: Swift.String?

        public init(
            id: Swift.String? = nil
        )
        {
            self.id = id
        }
    }
}

extension IoTSiteWiseClientTypes {

    /// Contains an identity that can access an IoT SiteWise Monitor resource. Currently, you can't use Amazon Web Services API operations to retrieve IAM Identity Center identity IDs. You can find the IAM Identity Center identity IDs in the URL of user and group pages in the [IAM Identity Center console](https://console.aws.amazon.com/singlesignon).
    public struct Identity: Swift.Sendable {
        /// An IAM Identity Center group identity.
        public var group: IoTSiteWiseClientTypes.GroupIdentity?
        /// An IAM role identity.
        public var iamRole: IoTSiteWiseClientTypes.IAMRoleIdentity?
        /// An IAM user identity.
        public var iamUser: IoTSiteWiseClientTypes.IAMUserIdentity?
        /// An IAM Identity Center user identity.
        public var user: IoTSiteWiseClientTypes.UserIdentity?

        public init(
            group: IoTSiteWiseClientTypes.GroupIdentity? = nil,
            iamRole: IoTSiteWiseClientTypes.IAMRoleIdentity? = nil,
            iamUser: IoTSiteWiseClientTypes.IAMUserIdentity? = nil,
            user: IoTSiteWiseClientTypes.UserIdentity? = nil
        )
        {
            self.group = group
            self.iamRole = iamRole
            self.iamUser = iamUser
            self.user = user
        }
    }
}

extension IoTSiteWiseClientTypes {

    public enum Permission: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case administrator
        case viewer
        case sdkUnknown(Swift.String)

        public static var allCases: [Permission] {
            return [
                .administrator,
                .viewer
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .administrator: return "ADMINISTRATOR"
            case .viewer: return "VIEWER"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTSiteWiseClientTypes {

    /// Identifies an IoT SiteWise Monitor portal.
    public struct PortalResource: Swift.Sendable {
        /// The ID of the portal.
        /// This member is required.
        public var id: Swift.String?

        public init(
            id: Swift.String? = nil
        )
        {
            self.id = id
        }
    }
}

extension IoTSiteWiseClientTypes {

    /// Identifies a specific IoT SiteWise Monitor project.
    public struct ProjectResource: Swift.Sendable {
        /// The ID of the project.
        /// This member is required.
        public var id: Swift.String?

        public init(
            id: Swift.String? = nil
        )
        {
            self.id = id
        }
    }
}

extension IoTSiteWiseClientTypes {

    /// Contains an IoT SiteWise Monitor resource ID for a portal or project.
    public struct Resource: Swift.Sendable {
        /// A portal resource.
        public var portal: IoTSiteWiseClientTypes.PortalResource?
        /// A project resource.
        public var project: IoTSiteWiseClientTypes.ProjectResource?

        public init(
            portal: IoTSiteWiseClientTypes.PortalResource? = nil,
            project: IoTSiteWiseClientTypes.ProjectResource? = nil
        )
        {
            self.portal = portal
            self.project = project
        }
    }
}

extension IoTSiteWiseClientTypes {

    /// Contains an access policy that defines an identity's access to an IoT SiteWise Monitor resource.
    public struct AccessPolicySummary: Swift.Sendable {
        /// The date the access policy was created, in Unix epoch time.
        public var creationDate: Foundation.Date?
        /// The ID of the access policy.
        /// This member is required.
        public var id: Swift.String?
        /// The identity (an IAM Identity Center user, an IAM Identity Center group, or an IAM user).
        /// This member is required.
        public var identity: IoTSiteWiseClientTypes.Identity?
        /// The date the access policy was last updated, in Unix epoch time.
        public var lastUpdateDate: Foundation.Date?
        /// The permissions for the access policy. Note that a project ADMINISTRATOR is also known as a project owner.
        /// This member is required.
        public var permission: IoTSiteWiseClientTypes.Permission?
        /// The IoT SiteWise Monitor resource (a portal or project).
        /// This member is required.
        public var resource: IoTSiteWiseClientTypes.Resource?

        public init(
            creationDate: Foundation.Date? = nil,
            id: Swift.String? = nil,
            identity: IoTSiteWiseClientTypes.Identity? = nil,
            lastUpdateDate: Foundation.Date? = nil,
            permission: IoTSiteWiseClientTypes.Permission? = nil,
            resource: IoTSiteWiseClientTypes.Resource? = nil
        )
        {
            self.creationDate = creationDate
            self.id = id
            self.identity = identity
            self.lastUpdateDate = lastUpdateDate
            self.permission = permission
            self.resource = resource
        }
    }
}

extension IoTSiteWiseClientTypes {

    /// Contains a definition for an action.
    public struct ActionDefinition: Swift.Sendable {
        /// The ID of the action definition.
        /// This member is required.
        public var actionDefinitionId: Swift.String?
        /// The name of the action definition.
        /// This member is required.
        public var actionName: Swift.String?
        /// The type of the action definition.
        /// This member is required.
        public var actionType: Swift.String?

        public init(
            actionDefinitionId: Swift.String? = nil,
            actionName: Swift.String? = nil,
            actionType: Swift.String? = nil
        )
        {
            self.actionDefinitionId = actionDefinitionId
            self.actionName = actionName
            self.actionType = actionType
        }
    }
}

extension IoTSiteWiseClientTypes {

    /// The JSON payload of the action.
    public struct ActionPayload: Swift.Sendable {
        /// The payload of the action in a JSON string.
        /// This member is required.
        public var stringValue: Swift.String?

        public init(
            stringValue: Swift.String? = nil
        )
        {
            self.stringValue = stringValue
        }
    }
}

extension IoTSiteWiseClientTypes {

    /// The resource the action will be taken on.
    public struct TargetResource: Swift.Sendable {
        /// The ID of the asset, in UUID format.
        /// This member is required.
        public var assetId: Swift.String?

        public init(
            assetId: Swift.String? = nil
        )
        {
            self.assetId = assetId
        }
    }
}

extension IoTSiteWiseClientTypes {

    /// Contains the summary of the actions.
    public struct ActionSummary: Swift.Sendable {
        /// The ID of the action definition.
        public var actionDefinitionId: Swift.String?
        /// The ID of the action.
        public var actionId: Swift.String?
        /// The resource the action will be taken on.
        public var targetResource: IoTSiteWiseClientTypes.TargetResource?

        public init(
            actionDefinitionId: Swift.String? = nil,
            actionId: Swift.String? = nil,
            targetResource: IoTSiteWiseClientTypes.TargetResource? = nil
        )
        {
            self.actionDefinitionId = actionDefinitionId
            self.actionId = actionId
            self.targetResource = targetResource
        }
    }
}

extension IoTSiteWiseClientTypes {

    public enum Quality: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case bad
        case good
        case uncertain
        case sdkUnknown(Swift.String)

        public static var allCases: [Quality] {
            return [
                .bad,
                .good,
                .uncertain
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .bad: return "BAD"
            case .good: return "GOOD"
            case .uncertain: return "UNCERTAIN"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTSiteWiseClientTypes {

    /// Contains the (pre-calculated) aggregate values for an asset property.
    public struct Aggregates: Swift.Sendable {
        /// The average (mean) value of the time series over a time interval window.
        public var average: Swift.Double?
        /// The count of data points in the time series over a time interval window.
        public var count: Swift.Double?
        /// The maximum value of the time series over a time interval window.
        public var maximum: Swift.Double?
        /// The minimum value of the time series over a time interval window.
        public var minimum: Swift.Double?
        /// The standard deviation of the time series over a time interval window.
        public var standardDeviation: Swift.Double?
        /// The sum of the time series over a time interval window.
        public var sum: Swift.Double?

        public init(
            average: Swift.Double? = nil,
            count: Swift.Double? = nil,
            maximum: Swift.Double? = nil,
            minimum: Swift.Double? = nil,
            standardDeviation: Swift.Double? = nil,
            sum: Swift.Double? = nil
        )
        {
            self.average = average
            self.count = count
            self.maximum = maximum
            self.minimum = minimum
            self.standardDeviation = standardDeviation
            self.sum = sum
        }
    }
}

extension IoTSiteWiseClientTypes {

    /// Contains aggregated asset property values (for example, average, minimum, and maximum).
    public struct AggregatedValue: Swift.Sendable {
        /// The quality of the aggregated data.
        public var quality: IoTSiteWiseClientTypes.Quality?
        /// The date the aggregating computations occurred, in Unix epoch time.
        /// This member is required.
        public var timestamp: Foundation.Date?
        /// The value of the aggregates.
        /// This member is required.
        public var value: IoTSiteWiseClientTypes.Aggregates?

        public init(
            quality: IoTSiteWiseClientTypes.Quality? = nil,
            timestamp: Foundation.Date? = nil,
            value: IoTSiteWiseClientTypes.Aggregates? = nil
        )
        {
            self.quality = quality
            self.timestamp = timestamp
            self.value = value
        }
    }
}

extension IoTSiteWiseClientTypes {

    public enum AggregateType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case average
        case count
        case maximum
        case minimum
        case standardDeviation
        case sum
        case sdkUnknown(Swift.String)

        public static var allCases: [AggregateType] {
            return [
                .average,
                .count,
                .maximum,
                .minimum,
                .standardDeviation,
                .sum
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .average: return "AVERAGE"
            case .count: return "COUNT"
            case .maximum: return "MAXIMUM"
            case .minimum: return "MINIMUM"
            case .standardDeviation: return "STANDARD_DEVIATION"
            case .sum: return "SUM"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTSiteWiseClientTypes {

    /// Contains the configuration information of an alarm created in an IoT SiteWise Monitor portal. You can use the alarm to monitor an asset property and get notified when the asset property value is outside a specified range. For more information, see [Monitoring with alarms](https://docs.aws.amazon.com/iot-sitewise/latest/appguide/monitor-alarms.html) in the IoT SiteWise Application Guide.
    public struct Alarms: Swift.Sendable {
        /// The [ARN](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the IAM role that allows the alarm to perform actions and access Amazon Web Services resources and services, such as IoT Events.
        /// This member is required.
        public var alarmRoleArn: Swift.String?
        /// The [ARN](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the Lambda function that manages alarm notifications. For more information, see [Managing alarm notifications](https://docs.aws.amazon.com/iotevents/latest/developerguide/lambda-support.html) in the IoT Events Developer Guide.
        public var notificationLambdaArn: Swift.String?

        public init(
            alarmRoleArn: Swift.String? = nil,
            notificationLambdaArn: Swift.String? = nil
        )
        {
            self.alarmRoleArn = alarmRoleArn
            self.notificationLambdaArn = notificationLambdaArn
        }
    }
}

extension IoTSiteWiseClientTypes {

    public enum PropertyDataType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case boolean
        case double
        case integer
        case string
        case `struct`
        case sdkUnknown(Swift.String)

        public static var allCases: [PropertyDataType] {
            return [
                .boolean,
                .double,
                .integer,
                .string,
                .struct
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .boolean: return "BOOLEAN"
            case .double: return "DOUBLE"
            case .integer: return "INTEGER"
            case .string: return "STRING"
            case .struct: return "STRUCT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTSiteWiseClientTypes {

    public enum PropertyNotificationState: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [PropertyNotificationState] {
            return [
                .disabled,
                .enabled
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTSiteWiseClientTypes {

    /// Contains asset property value notification information. When the notification state is enabled, IoT SiteWise publishes property value updates to a unique MQTT topic. For more information, see [Interacting with other services](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/interact-with-other-services.html) in the IoT SiteWise User Guide.
    public struct PropertyNotification: Swift.Sendable {
        /// The current notification state.
        /// This member is required.
        public var state: IoTSiteWiseClientTypes.PropertyNotificationState?
        /// The MQTT topic to which IoT SiteWise publishes property value update notifications.
        /// This member is required.
        public var topic: Swift.String?

        public init(
            state: IoTSiteWiseClientTypes.PropertyNotificationState? = nil,
            topic: Swift.String? = nil
        )
        {
            self.state = state
            self.topic = topic
        }
    }
}

extension IoTSiteWiseClientTypes {

    /// Represents one level between a property and the root of the asset.
    public struct AssetPropertyPathSegment: Swift.Sendable {
        /// The ID of the path segment.
        public var id: Swift.String?
        /// The name of the path segment.
        public var name: Swift.String?

        public init(
            id: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.id = id
            self.name = name
        }
    }
}

extension IoTSiteWiseClientTypes {

    /// Contains asset property information.
    public struct AssetProperty: Swift.Sendable {
        /// The alias that identifies the property, such as an OPC-UA server data stream path (for example, /company/windfarm/3/turbine/7/temperature). For more information, see [Mapping industrial data streams to asset properties](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/connect-data-streams.html) in the IoT SiteWise User Guide.
        public var alias: Swift.String?
        /// The data type of the asset property.
        /// This member is required.
        public var dataType: IoTSiteWiseClientTypes.PropertyDataType?
        /// The data type of the structure for this property. This parameter exists on properties that have the STRUCT data type.
        public var dataTypeSpec: Swift.String?
        /// The external ID of the asset property. For more information, see [Using external IDs](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/object-ids.html#external-ids) in the IoT SiteWise User Guide.
        public var externalId: Swift.String?
        /// The ID of the asset property.
        /// This member is required.
        public var id: Swift.String?
        /// The name of the property.
        /// This member is required.
        public var name: Swift.String?
        /// The asset property's notification topic and state. For more information, see [UpdateAssetProperty](https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_UpdateAssetProperty.html).
        public var notification: IoTSiteWiseClientTypes.PropertyNotification?
        /// The structured path to the property from the root of the asset.
        public var path: [IoTSiteWiseClientTypes.AssetPropertyPathSegment]?
        /// The unit (such as Newtons or RPM) of the asset property.
        public var unit: Swift.String?

        public init(
            alias: Swift.String? = nil,
            dataType: IoTSiteWiseClientTypes.PropertyDataType? = nil,
            dataTypeSpec: Swift.String? = nil,
            externalId: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            notification: IoTSiteWiseClientTypes.PropertyNotification? = nil,
            path: [IoTSiteWiseClientTypes.AssetPropertyPathSegment]? = nil,
            unit: Swift.String? = nil
        )
        {
            self.alias = alias
            self.dataType = dataType
            self.dataTypeSpec = dataTypeSpec
            self.externalId = externalId
            self.id = id
            self.name = name
            self.notification = notification
            self.path = path
            self.unit = unit
        }
    }
}

extension IoTSiteWiseClientTypes {

    /// Contains information about a composite model in an asset. This object contains the asset's properties that you define in the composite model.
    public struct AssetCompositeModel: Swift.Sendable {
        /// The description of the composite model.
        public var description: Swift.String?
        /// The external ID of the asset composite model. For more information, see [Using external IDs](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/object-ids.html#external-ids) in the IoT SiteWise User Guide.
        public var externalId: Swift.String?
        /// The ID of the asset composite model.
        public var id: Swift.String?
        /// The name of the composite model.
        /// This member is required.
        public var name: Swift.String?
        /// The asset properties that this composite model defines.
        /// This member is required.
        public var properties: [IoTSiteWiseClientTypes.AssetProperty]?
        /// The type of the composite model. For alarm composite models, this type is AWS/ALARM.
        /// This member is required.
        public var type: Swift.String?

        public init(
            description: Swift.String? = nil,
            externalId: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            properties: [IoTSiteWiseClientTypes.AssetProperty]? = nil,
            type: Swift.String? = nil
        )
        {
            self.description = description
            self.externalId = externalId
            self.id = id
            self.name = name
            self.properties = properties
            self.type = type
        }
    }
}

extension IoTSiteWiseClientTypes {

    /// Represents one level between a composite model and the root of the asset.
    public struct AssetCompositeModelPathSegment: Swift.Sendable {
        /// The ID of the path segment.
        public var id: Swift.String?
        /// The name of the path segment.
        public var name: Swift.String?

        public init(
            id: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.id = id
            self.name = name
        }
    }
}

extension IoTSiteWiseClientTypes {

    /// Contains a summary of the composite model for a specific asset.
    public struct AssetCompositeModelSummary: Swift.Sendable {
        /// A description of the composite model that this summary describes.
        /// This member is required.
        public var description: Swift.String?
        /// An external ID to assign to the asset model. If the composite model is a derived composite model, or one nested inside a component model, you can only set the external ID using UpdateAssetModelCompositeModel and specifying the derived ID of the model or property from the created model it's a part of.
        public var externalId: Swift.String?
        /// The ID of the composite model that this summary describes.
        /// This member is required.
        public var id: Swift.String?
        /// The name of the composite model that this summary describes.
        /// This member is required.
        public var name: Swift.String?
        /// The path that includes all the components of the asset model for the asset.
        /// This member is required.
        public var path: [IoTSiteWiseClientTypes.AssetCompositeModelPathSegment]?
        /// The type of asset model.
        ///
        /// * ASSET_MODEL – (default) An asset model that you can use to create assets. Can't be included as a component in another asset model.
        ///
        /// * COMPONENT_MODEL – A reusable component that you can include in the composite models of other asset models. You can't create assets directly from this type of asset model.
        /// This member is required.
        public var type: Swift.String?

        public init(
            description: Swift.String? = nil,
            externalId: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            path: [IoTSiteWiseClientTypes.AssetCompositeModelPathSegment]? = nil,
            type: Swift.String? = nil
        )
        {
            self.description = description
            self.externalId = externalId
            self.id = id
            self.name = name
            self.path = path
            self.type = type
        }
    }
}

extension IoTSiteWiseClientTypes {

    public enum AssetErrorCode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case internalFailure
        case sdkUnknown(Swift.String)

        public static var allCases: [AssetErrorCode] {
            return [
                .internalFailure
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .internalFailure: return "INTERNAL_FAILURE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTSiteWiseClientTypes {

    /// Contains error details for the requested associate project asset action.
    public struct AssetErrorDetails: Swift.Sendable {
        /// The ID of the asset, in UUID format.
        /// This member is required.
        public var assetId: Swift.String?
        /// The error code.
        /// This member is required.
        public var code: IoTSiteWiseClientTypes.AssetErrorCode?
        /// The error message.
        /// This member is required.
        public var message: Swift.String?

        public init(
            assetId: Swift.String? = nil,
            code: IoTSiteWiseClientTypes.AssetErrorCode? = nil,
            message: Swift.String? = nil
        )
        {
            self.assetId = assetId
            self.code = code
            self.message = message
        }
    }
}

extension IoTSiteWiseClientTypes {

    /// Describes an asset hierarchy that contains a hierarchy's name and ID.
    public struct AssetHierarchy: Swift.Sendable {
        /// The external ID of the hierarchy, if it has one. When you update an asset hierarchy, you may assign an external ID if it doesn't already have one. You can't change the external ID of an asset hierarchy that already has one. For more information, see [Using external IDs](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/object-ids.html#external-ids) in the IoT SiteWise User Guide.
        public var externalId: Swift.String?
        /// The ID of the hierarchy. This ID is a hierarchyId.
        public var id: Swift.String?
        /// The hierarchy name provided in the [CreateAssetModel](https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_CreateAssetModel.html) or [UpdateAssetModel](https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_UpdateAssetModel.html) API operation.
        /// This member is required.
        public var name: Swift.String?

        public init(
            externalId: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.externalId = externalId
            self.id = id
            self.name = name
        }
    }
}

extension IoTSiteWiseClientTypes {

    /// Contains information about a parent asset and a child asset that are related through an asset hierarchy.
    public struct AssetHierarchyInfo: Swift.Sendable {
        /// The ID of the child asset in this asset relationship.
        public var childAssetId: Swift.String?
        /// The ID of the parent asset in this asset relationship.
        public var parentAssetId: Swift.String?

        public init(
            childAssetId: Swift.String? = nil,
            parentAssetId: Swift.String? = nil
        )
        {
            self.childAssetId = childAssetId
            self.parentAssetId = parentAssetId
        }
    }
}

extension IoTSiteWiseClientTypes {

    /// Represents one level between a property and the root of the asset model.
    public struct AssetModelPropertyPathSegment: Swift.Sendable {
        /// The ID of the path segment.
        public var id: Swift.String?
        /// The name of the path segment.
        public var name: Swift.String?

        public init(
            id: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.id = id
            self.name = name
        }
    }
}

extension IoTSiteWiseClientTypes {

    /// Contains an asset attribute property. For more information, see [Attributes](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/asset-properties.html#attributes) in the IoT SiteWise User Guide.
    public struct Attribute: Swift.Sendable {
        /// The default value of the asset model property attribute. All assets that you create from the asset model contain this attribute value. You can update an attribute's value after you create an asset. For more information, see [Updating attribute values](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/update-attribute-values.html) in the IoT SiteWise User Guide.
        public var defaultValue: Swift.String?

        public init(
            defaultValue: Swift.String? = nil
        )
        {
            self.defaultValue = defaultValue
        }
    }
}

extension IoTSiteWiseClientTypes {

    public enum ForwardingConfigState: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [ForwardingConfigState] {
            return [
                .disabled,
                .enabled
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTSiteWiseClientTypes {

    /// The forwarding configuration for a given property.
    public struct ForwardingConfig: Swift.Sendable {
        /// The forwarding state for the given property.
        /// This member is required.
        public var state: IoTSiteWiseClientTypes.ForwardingConfigState?

        public init(
            state: IoTSiteWiseClientTypes.ForwardingConfigState? = nil
        )
        {
            self.state = state
        }
    }
}

extension IoTSiteWiseClientTypes {

    /// The processing configuration for the given measurement property. You can configure measurements to be kept at the edge or forwarded to the Amazon Web Services Cloud. By default, measurements are forwarded to the cloud.
    public struct MeasurementProcessingConfig: Swift.Sendable {
        /// The forwarding configuration for the given measurement property.
        /// This member is required.
        public var forwardingConfig: IoTSiteWiseClientTypes.ForwardingConfig?

        public init(
            forwardingConfig: IoTSiteWiseClientTypes.ForwardingConfig? = nil
        )
        {
            self.forwardingConfig = forwardingConfig
        }
    }
}

extension IoTSiteWiseClientTypes {

    /// Contains an asset measurement property. For more information, see [Measurements](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/asset-properties.html#measurements) in the IoT SiteWise User Guide.
    public struct Measurement: Swift.Sendable {
        /// The processing configuration for the given measurement property. You can configure measurements to be kept at the edge or forwarded to the Amazon Web Services Cloud. By default, measurements are forwarded to the cloud.
        public var processingConfig: IoTSiteWiseClientTypes.MeasurementProcessingConfig?

        public init(
            processingConfig: IoTSiteWiseClientTypes.MeasurementProcessingConfig? = nil
        )
        {
            self.processingConfig = processingConfig
        }
    }
}

extension IoTSiteWiseClientTypes {

    public enum ComputeLocation: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case cloud
        case edge
        case sdkUnknown(Swift.String)

        public static var allCases: [ComputeLocation] {
            return [
                .cloud,
                .edge
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .cloud: return "CLOUD"
            case .edge: return "EDGE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTSiteWiseClientTypes {

    /// The processing configuration for the given metric property. You can configure metrics to be computed at the edge or in the Amazon Web Services Cloud. By default, metrics are forwarded to the cloud.
    public struct MetricProcessingConfig: Swift.Sendable {
        /// The compute location for the given metric property.
        /// This member is required.
        public var computeLocation: IoTSiteWiseClientTypes.ComputeLocation?

        public init(
            computeLocation: IoTSiteWiseClientTypes.ComputeLocation? = nil
        )
        {
            self.computeLocation = computeLocation
        }
    }
}

extension IoTSiteWiseClientTypes {

    /// Identifies a property value used in an expression.
    public struct VariableValue: Swift.Sendable {
        /// The ID of the hierarchy to query for the property ID. You can use the hierarchy's name instead of the hierarchy's ID. If the hierarchy has an external ID, you can specify externalId: followed by the external ID. For more information, see [Using external IDs](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/object-ids.html#external-ids) in the IoT SiteWise User Guide. You use a hierarchy ID instead of a model ID because you can have several hierarchies using the same model and therefore the same propertyId. For example, you might have separately grouped assets that come from the same asset model. For more information, see [Asset hierarchies](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/asset-hierarchies.html) in the IoT SiteWise User Guide.
        public var hierarchyId: Swift.String?
        /// The ID of the property to use as the variable. You can use the property name if it's from the same asset model. If the property has an external ID, you can specify externalId: followed by the external ID. For more information, see [Using external IDs](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/object-ids.html#external-ids) in the IoT SiteWise User Guide.
        public var propertyId: Swift.String?
        /// The path of the property.
        public var propertyPath: [IoTSiteWiseClientTypes.AssetModelPropertyPathSegment]?

        public init(
            hierarchyId: Swift.String? = nil,
            propertyId: Swift.String? = nil,
            propertyPath: [IoTSiteWiseClientTypes.AssetModelPropertyPathSegment]? = nil
        )
        {
            self.hierarchyId = hierarchyId
            self.propertyId = propertyId
            self.propertyPath = propertyPath
        }
    }
}

extension IoTSiteWiseClientTypes {

    /// Contains expression variable information.
    public struct ExpressionVariable: Swift.Sendable {
        /// The friendly name of the variable to be used in the expression.
        /// This member is required.
        public var name: Swift.String?
        /// The variable that identifies an asset property from which to use values.
        /// This member is required.
        public var value: IoTSiteWiseClientTypes.VariableValue?

        public init(
            name: Swift.String? = nil,
            value: IoTSiteWiseClientTypes.VariableValue? = nil
        )
        {
            self.name = name
            self.value = value
        }
    }
}

extension IoTSiteWiseClientTypes {

    /// Contains a tumbling window, which is a repeating fixed-sized, non-overlapping, and contiguous time window. You can use this window in metrics to aggregate data from properties and other assets. You can use m, h, d, and w when you specify an interval or offset. Note that m represents minutes, h represents hours, d represents days, and w represents weeks. You can also use s to represent seconds in offset. The interval and offset parameters support the [ISO 8601 format](https://en.wikipedia.org/wiki/ISO_8601). For example, PT5S represents 5 seconds, PT5M represents 5 minutes, and PT5H represents 5 hours.
    public struct TumblingWindow: Swift.Sendable {
        /// The time interval for the tumbling window. The interval time must be between 1 minute and 1 week. IoT SiteWise computes the 1w interval the end of Sunday at midnight each week (UTC), the 1d interval at the end of each day at midnight (UTC), the 1h interval at the end of each hour, and so on. When IoT SiteWise aggregates data points for metric computations, the start of each interval is exclusive and the end of each interval is inclusive. IoT SiteWise places the computed data point at the end of the interval.
        /// This member is required.
        public var interval: Swift.String?
        /// The offset for the tumbling window. The offset parameter accepts the following:
        ///
        /// * The offset time. For example, if you specify 18h for offset and 1d for interval, IoT SiteWise aggregates data in one of the following ways:
        ///
        /// * If you create the metric before or at 6 PM (UTC), you get the first aggregation result at 6 PM (UTC) on the day when you create the metric.
        ///
        /// * If you create the metric after 6 PM (UTC), you get the first aggregation result at 6 PM (UTC) the next day.
        ///
        ///
        ///
        ///
        /// * The ISO 8601 format. For example, if you specify PT18H for offset and 1d for interval, IoT SiteWise aggregates data in one of the following ways:
        ///
        /// * If you create the metric before or at 6 PM (UTC), you get the first aggregation result at 6 PM (UTC) on the day when you create the metric.
        ///
        /// * If you create the metric after 6 PM (UTC), you get the first aggregation result at 6 PM (UTC) the next day.
        ///
        ///
        ///
        ///
        /// * The 24-hour clock. For example, if you specify 00:03:00 for offset, 5m for interval, and you create the metric at 2 PM (UTC), you get the first aggregation result at 2:03 PM (UTC). You get the second aggregation result at 2:08 PM (UTC).
        ///
        /// * The offset time zone. For example, if you specify 2021-07-23T18:00-08 for offset and 1d for interval, IoT SiteWise aggregates data in one of the following ways:
        ///
        /// * If you create the metric before or at 6 PM (PST), you get the first aggregation result at 6 PM (PST) on the day when you create the metric.
        ///
        /// * If you create the metric after 6 PM (PST), you get the first aggregation result at 6 PM (PST) the next day.
        public var offset: Swift.String?

        public init(
            interval: Swift.String? = nil,
            offset: Swift.String? = nil
        )
        {
            self.interval = interval
            self.offset = offset
        }
    }
}

extension IoTSiteWiseClientTypes {

    /// Contains a time interval window used for data aggregate computations (for example, average, sum, count, and so on).
    public struct MetricWindow: Swift.Sendable {
        /// The tumbling time interval window.
        public var tumbling: IoTSiteWiseClientTypes.TumblingWindow?

        public init(
            tumbling: IoTSiteWiseClientTypes.TumblingWindow? = nil
        )
        {
            self.tumbling = tumbling
        }
    }
}

extension IoTSiteWiseClientTypes {

    /// Contains an asset metric property. With metrics, you can calculate aggregate functions, such as an average, maximum, or minimum, as specified through an expression. A metric maps several values to a single value (such as a sum). The maximum number of dependent/cascading variables used in any one metric calculation is 10. Therefore, a root metric can have up to 10 cascading metrics in its computational dependency tree. Additionally, a metric can only have a data type of DOUBLE and consume properties with data types of INTEGER or DOUBLE. For more information, see [Metrics](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/asset-properties.html#metrics) in the IoT SiteWise User Guide.
    public struct Metric: Swift.Sendable {
        /// The mathematical expression that defines the metric aggregation function. You can specify up to 10 variables per expression. You can specify up to 10 functions per expression. For more information, see [Quotas](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/quotas.html) in the IoT SiteWise User Guide.
        /// This member is required.
        public var expression: Swift.String?
        /// The processing configuration for the given metric property. You can configure metrics to be computed at the edge or in the Amazon Web Services Cloud. By default, metrics are forwarded to the cloud.
        public var processingConfig: IoTSiteWiseClientTypes.MetricProcessingConfig?
        /// The list of variables used in the expression.
        /// This member is required.
        public var variables: [IoTSiteWiseClientTypes.ExpressionVariable]?
        /// The window (time interval) over which IoT SiteWise computes the metric's aggregation expression. IoT SiteWise computes one data point per window.
        /// This member is required.
        public var window: IoTSiteWiseClientTypes.MetricWindow?

        public init(
            expression: Swift.String? = nil,
            processingConfig: IoTSiteWiseClientTypes.MetricProcessingConfig? = nil,
            variables: [IoTSiteWiseClientTypes.ExpressionVariable]? = nil,
            window: IoTSiteWiseClientTypes.MetricWindow? = nil
        )
        {
            self.expression = expression
            self.processingConfig = processingConfig
            self.variables = variables
            self.window = window
        }
    }
}

extension IoTSiteWiseClientTypes {

    /// The processing configuration for the given transform property. You can configure transforms to be kept at the edge or forwarded to the Amazon Web Services Cloud. You can also configure transforms to be computed at the edge or in the cloud.
    public struct TransformProcessingConfig: Swift.Sendable {
        /// The compute location for the given transform property.
        /// This member is required.
        public var computeLocation: IoTSiteWiseClientTypes.ComputeLocation?
        /// The forwarding configuration for a given property.
        public var forwardingConfig: IoTSiteWiseClientTypes.ForwardingConfig?

        public init(
            computeLocation: IoTSiteWiseClientTypes.ComputeLocation? = nil,
            forwardingConfig: IoTSiteWiseClientTypes.ForwardingConfig? = nil
        )
        {
            self.computeLocation = computeLocation
            self.forwardingConfig = forwardingConfig
        }
    }
}

extension IoTSiteWiseClientTypes {

    /// Contains an asset transform property. A transform is a one-to-one mapping of a property's data points from one form to another. For example, you can use a transform to convert a Celsius data stream to Fahrenheit by applying the transformation expression to each data point of the Celsius stream. A transform can only have a data type of DOUBLE and consume properties with data types of INTEGER or DOUBLE. For more information, see [Transforms](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/asset-properties.html#transforms) in the IoT SiteWise User Guide.
    public struct Transform: Swift.Sendable {
        /// The mathematical expression that defines the transformation function. You can specify up to 10 variables per expression. You can specify up to 10 functions per expression. For more information, see [Quotas](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/quotas.html) in the IoT SiteWise User Guide.
        /// This member is required.
        public var expression: Swift.String?
        /// The processing configuration for the given transform property. You can configure transforms to be kept at the edge or forwarded to the Amazon Web Services Cloud. You can also configure transforms to be computed at the edge or in the cloud.
        public var processingConfig: IoTSiteWiseClientTypes.TransformProcessingConfig?
        /// The list of variables used in the expression.
        /// This member is required.
        public var variables: [IoTSiteWiseClientTypes.ExpressionVariable]?

        public init(
            expression: Swift.String? = nil,
            processingConfig: IoTSiteWiseClientTypes.TransformProcessingConfig? = nil,
            variables: [IoTSiteWiseClientTypes.ExpressionVariable]? = nil
        )
        {
            self.expression = expression
            self.processingConfig = processingConfig
            self.variables = variables
        }
    }
}

extension IoTSiteWiseClientTypes {

    /// Contains a property type, which can be one of attribute, measurement, metric, or transform.
    public struct PropertyType: Swift.Sendable {
        /// Specifies an asset attribute property. An attribute generally contains static information, such as the serial number of an [IIoT](https://en.wikipedia.org/wiki/Internet_of_things#Industrial_applications) wind turbine.
        public var attribute: IoTSiteWiseClientTypes.Attribute?
        /// Specifies an asset measurement property. A measurement represents a device's raw sensor data stream, such as timestamped temperature values or timestamped power values.
        public var measurement: IoTSiteWiseClientTypes.Measurement?
        /// Specifies an asset metric property. A metric contains a mathematical expression that uses aggregate functions to process all input data points over a time interval and output a single data point, such as to calculate the average hourly temperature.
        public var metric: IoTSiteWiseClientTypes.Metric?
        /// Specifies an asset transform property. A transform contains a mathematical expression that maps a property's data points from one form to another, such as a unit conversion from Celsius to Fahrenheit.
        public var transform: IoTSiteWiseClientTypes.Transform?

        public init(
            attribute: IoTSiteWiseClientTypes.Attribute? = nil,
            measurement: IoTSiteWiseClientTypes.Measurement? = nil,
            metric: IoTSiteWiseClientTypes.Metric? = nil,
            transform: IoTSiteWiseClientTypes.Transform? = nil
        )
        {
            self.attribute = attribute
            self.measurement = measurement
            self.metric = metric
            self.transform = transform
        }
    }
}

extension IoTSiteWiseClientTypes {

    /// Contains information about an asset model property.
    public struct AssetModelProperty: Swift.Sendable {
        /// The data type of the asset model property.
        /// This member is required.
        public var dataType: IoTSiteWiseClientTypes.PropertyDataType?
        /// The data type of the structure for this property. This parameter exists on properties that have the STRUCT data type.
        public var dataTypeSpec: Swift.String?
        /// The external ID (if any) provided in the [CreateAssetModel](https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_CreateAssetModel.html) or [UpdateAssetModel](https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_UpdateAssetModel.html) operation. You can assign an external ID by specifying this value as part of a call to [UpdateAssetModel](https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_UpdateAssetModel.html). However, you can't change the external ID if one is already assigned. For more information, see [Using external IDs](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/object-ids.html#external-ids) in the IoT SiteWise User Guide.
        public var externalId: Swift.String?
        /// The ID of the asset model property.
        ///
        /// * If you are callling [UpdateAssetModel](https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_UpdateAssetModel.html) to create a new property: You can specify its ID here, if desired. IoT SiteWise automatically generates a unique ID for you, so this parameter is never required. However, if you prefer to supply your own ID instead, you can specify it here in UUID format. If you specify your own ID, it must be globally unique.
        ///
        /// * If you are calling UpdateAssetModel to modify an existing property: This can be either the actual ID in UUID format, or else externalId: followed by the external ID, if it has one. For more information, see [Referencing objects with external IDs](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/object-ids.html#external-id-references) in the IoT SiteWise User Guide.
        public var id: Swift.String?
        /// The name of the asset model property.
        /// This member is required.
        public var name: Swift.String?
        /// The structured path to the property from the root of the asset model.
        public var path: [IoTSiteWiseClientTypes.AssetModelPropertyPathSegment]?
        /// The property type (see PropertyType).
        /// This member is required.
        public var type: IoTSiteWiseClientTypes.PropertyType?
        /// The unit of the asset model property, such as Newtons or RPM.
        public var unit: Swift.String?

        public init(
            dataType: IoTSiteWiseClientTypes.PropertyDataType? = nil,
            dataTypeSpec: Swift.String? = nil,
            externalId: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            path: [IoTSiteWiseClientTypes.AssetModelPropertyPathSegment]? = nil,
            type: IoTSiteWiseClientTypes.PropertyType? = nil,
            unit: Swift.String? = nil
        )
        {
            self.dataType = dataType
            self.dataTypeSpec = dataTypeSpec
            self.externalId = externalId
            self.id = id
            self.name = name
            self.path = path
            self.type = type
            self.unit = unit
        }
    }
}

extension IoTSiteWiseClientTypes {

    /// Contains information about a composite model in an asset model. This object contains the asset property definitions that you define in the composite model.
    public struct AssetModelCompositeModel: Swift.Sendable {
        /// The description of the composite model.
        public var description: Swift.String?
        /// The external ID of the asset model composite model. For more information, see [Using external IDs](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/object-ids.html#external-ids) in the IoT SiteWise User Guide.
        public var externalId: Swift.String?
        /// The ID of the asset model composite model.
        public var id: Swift.String?
        /// The name of the composite model.
        /// This member is required.
        public var name: Swift.String?
        /// The asset property definitions for this composite model.
        public var properties: [IoTSiteWiseClientTypes.AssetModelProperty]?
        /// The type of the composite model. For alarm composite models, this type is AWS/ALARM.
        /// This member is required.
        public var type: Swift.String?

        public init(
            description: Swift.String? = nil,
            externalId: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            properties: [IoTSiteWiseClientTypes.AssetModelProperty]? = nil,
            type: Swift.String? = nil
        )
        {
            self.description = description
            self.externalId = externalId
            self.id = id
            self.name = name
            self.properties = properties
            self.type = type
        }
    }
}

extension IoTSiteWiseClientTypes {

    /// Contains an asset model property definition. This property definition is applied to all assets created from the asset model.
    public struct AssetModelPropertyDefinition: Swift.Sendable {
        /// The data type of the property definition. If you specify STRUCT, you must also specify dataTypeSpec to identify the type of the structure for this property.
        /// This member is required.
        public var dataType: IoTSiteWiseClientTypes.PropertyDataType?
        /// The data type of the structure for this property. This parameter is required on properties that have the STRUCT data type. The options for this parameter depend on the type of the composite model in which you define this property. Use AWS/ALARM_STATE for alarm state in alarm composite models.
        public var dataTypeSpec: Swift.String?
        /// An external ID to assign to the property definition. The external ID must be unique among property definitions within this asset model. For more information, see [Using external IDs](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/object-ids.html#external-ids) in the IoT SiteWise User Guide.
        public var externalId: Swift.String?
        /// The ID to assign to the asset model property, if desired. IoT SiteWise automatically generates a unique ID for you, so this parameter is never required. However, if you prefer to supply your own ID instead, you can specify it here in UUID format. If you specify your own ID, it must be globally unique.
        public var id: Swift.String?
        /// The name of the property definition.
        /// This member is required.
        public var name: Swift.String?
        /// The property definition type (see PropertyType). You can only specify one type in a property definition.
        /// This member is required.
        public var type: IoTSiteWiseClientTypes.PropertyType?
        /// The unit of the property definition, such as Newtons or RPM.
        public var unit: Swift.String?

        public init(
            dataType: IoTSiteWiseClientTypes.PropertyDataType? = nil,
            dataTypeSpec: Swift.String? = nil,
            externalId: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            type: IoTSiteWiseClientTypes.PropertyType? = nil,
            unit: Swift.String? = nil
        )
        {
            self.dataType = dataType
            self.dataTypeSpec = dataTypeSpec
            self.externalId = externalId
            self.id = id
            self.name = name
            self.type = type
            self.unit = unit
        }
    }
}

extension IoTSiteWiseClientTypes {

    /// Contains a composite model definition in an asset model. This composite model definition is applied to all assets created from the asset model.
    public struct AssetModelCompositeModelDefinition: Swift.Sendable {
        /// The description of the composite model.
        public var description: Swift.String?
        /// An external ID to assign to the composite model. The external ID must be unique among composite models within this asset model. For more information, see [Using external IDs](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/object-ids.html#external-ids) in the IoT SiteWise User Guide.
        public var externalId: Swift.String?
        /// The ID to assign to the composite model, if desired. IoT SiteWise automatically generates a unique ID for you, so this parameter is never required. However, if you prefer to supply your own ID instead, you can specify it here in UUID format. If you specify your own ID, it must be globally unique.
        public var id: Swift.String?
        /// The name of the composite model.
        /// This member is required.
        public var name: Swift.String?
        /// The asset property definitions for this composite model.
        public var properties: [IoTSiteWiseClientTypes.AssetModelPropertyDefinition]?
        /// The type of the composite model. For alarm composite models, this type is AWS/ALARM.
        /// This member is required.
        public var type: Swift.String?

        public init(
            description: Swift.String? = nil,
            externalId: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            properties: [IoTSiteWiseClientTypes.AssetModelPropertyDefinition]? = nil,
            type: Swift.String? = nil
        )
        {
            self.description = description
            self.externalId = externalId
            self.id = id
            self.name = name
            self.properties = properties
            self.type = type
        }
    }
}

extension IoTSiteWiseClientTypes {

    /// Represents one level between a composite model and the root of the asset model.
    public struct AssetModelCompositeModelPathSegment: Swift.Sendable {
        /// The ID of the path segment.
        public var id: Swift.String?
        /// The name of the path segment.
        public var name: Swift.String?

        public init(
            id: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.id = id
            self.name = name
        }
    }
}

extension IoTSiteWiseClientTypes {

    /// Contains a summary of the composite model.
    public struct AssetModelCompositeModelSummary: Swift.Sendable {
        /// The description of the composite model that this summary describes..
        public var description: Swift.String?
        /// The external ID of a composite model on this asset model. For more information, see [Using external IDs](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/object-ids.html#external-ids) in the IoT SiteWise User Guide.
        public var externalId: Swift.String?
        /// The ID of the composite model that this summary describes..
        /// This member is required.
        public var id: Swift.String?
        /// The name of the composite model that this summary describes..
        /// This member is required.
        public var name: Swift.String?
        /// The path that includes all the pieces that make up the composite model.
        public var path: [IoTSiteWiseClientTypes.AssetModelCompositeModelPathSegment]?
        /// The composite model type. Valid values are AWS/ALARM, CUSTOM, or  AWS/L4E_ANOMALY.
        /// This member is required.
        public var type: Swift.String?

        public init(
            description: Swift.String? = nil,
            externalId: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            path: [IoTSiteWiseClientTypes.AssetModelCompositeModelPathSegment]? = nil,
            type: Swift.String? = nil
        )
        {
            self.description = description
            self.externalId = externalId
            self.id = id
            self.name = name
            self.path = path
            self.type = type
        }
    }
}

extension IoTSiteWiseClientTypes {

    /// Describes an asset hierarchy that contains a hierarchy's name, ID, and child asset model ID that specifies the type of asset that can be in this hierarchy.
    public struct AssetModelHierarchy: Swift.Sendable {
        /// The ID of the asset model, in UUID format. All assets in this hierarchy must be instances of the childAssetModelId asset model. IoT SiteWise will always return the actual asset model ID for this value. However, when you are specifying this value as part of a call to [UpdateAssetModel](https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_UpdateAssetModel.html), you may provide either the asset model ID or else externalId: followed by the asset model's external ID. For more information, see [Using external IDs](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/object-ids.html#external-ids) in the IoT SiteWise User Guide.
        /// This member is required.
        public var childAssetModelId: Swift.String?
        /// The external ID (if any) provided in the [CreateAssetModel](https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_CreateAssetModel.html) or [UpdateAssetModel](https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_UpdateAssetModel.html) operation. You can assign an external ID by specifying this value as part of a call to [UpdateAssetModel](https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_UpdateAssetModel.html). However, you can't change the external ID if one is already assigned. For more information, see [Using external IDs](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/object-ids.html#external-ids) in the IoT SiteWise User Guide.
        public var externalId: Swift.String?
        /// The ID of the asset model hierarchy. This ID is a hierarchyId.
        ///
        /// * If you are callling [UpdateAssetModel](https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_UpdateAssetModel.html) to create a new hierarchy: You can specify its ID here, if desired. IoT SiteWise automatically generates a unique ID for you, so this parameter is never required. However, if you prefer to supply your own ID instead, you can specify it here in UUID format. If you specify your own ID, it must be globally unique.
        ///
        /// * If you are calling UpdateAssetModel to modify an existing hierarchy: This can be either the actual ID in UUID format, or else externalId: followed by the external ID, if it has one. For more information, see [Referencing objects with external IDs](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/object-ids.html#external-id-references) in the IoT SiteWise User Guide.
        public var id: Swift.String?
        /// The name of the asset model hierarchy that you specify by using the [CreateAssetModel](https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_CreateAssetModel.html) or [UpdateAssetModel](https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_UpdateAssetModel.html) API operation.
        /// This member is required.
        public var name: Swift.String?

        public init(
            childAssetModelId: Swift.String? = nil,
            externalId: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.childAssetModelId = childAssetModelId
            self.externalId = externalId
            self.id = id
            self.name = name
        }
    }
}

extension IoTSiteWiseClientTypes {

    /// Contains an asset model hierarchy used in asset model creation. An asset model hierarchy determines the kind (or type) of asset that can belong to a hierarchy.
    public struct AssetModelHierarchyDefinition: Swift.Sendable {
        /// The ID of an asset model for this hierarchy. This can be either the actual ID in UUID format, or else externalId: followed by the external ID, if it has one. For more information, see [Referencing objects with external IDs](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/object-ids.html#external-id-references) in the IoT SiteWise User Guide.
        /// This member is required.
        public var childAssetModelId: Swift.String?
        /// An external ID to assign to the asset model hierarchy. The external ID must be unique among asset model hierarchies within this asset model. For more information, see [Using external IDs](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/object-ids.html#external-ids) in the IoT SiteWise User Guide.
        public var externalId: Swift.String?
        /// The ID to assign to the asset model hierarchy, if desired. IoT SiteWise automatically generates a unique ID for you, so this parameter is never required. However, if you prefer to supply your own ID instead, you can specify it here in UUID format. If you specify your own ID, it must be globally unique.
        public var id: Swift.String?
        /// The name of the asset model hierarchy definition (as specified in the [CreateAssetModel](https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_CreateAssetModel.html) or [UpdateAssetModel](https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_UpdateAssetModel.html) API operation).
        /// This member is required.
        public var name: Swift.String?

        public init(
            childAssetModelId: Swift.String? = nil,
            externalId: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.childAssetModelId = childAssetModelId
            self.externalId = externalId
            self.id = id
            self.name = name
        }
    }
}

extension IoTSiteWiseClientTypes {

    /// Contains a summary of a property associated with a model.
    public struct AssetModelPropertySummary: Swift.Sendable {
        /// The ID of the composite model that contains the asset model property.
        public var assetModelCompositeModelId: Swift.String?
        /// The data type of the property.
        /// This member is required.
        public var dataType: IoTSiteWiseClientTypes.PropertyDataType?
        /// The data type of the structure for this property. This parameter exists on properties that have the STRUCT data type.
        public var dataTypeSpec: Swift.String?
        /// The external ID of the property. For more information, see [Using external IDs](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/object-ids.html#external-ids) in the IoT SiteWise User Guide.
        public var externalId: Swift.String?
        /// The ID of the property.
        public var id: Swift.String?
        /// The name of the property.
        /// This member is required.
        public var name: Swift.String?
        /// The structured path to the property from the root of the asset model.
        public var path: [IoTSiteWiseClientTypes.AssetModelPropertyPathSegment]?
        /// Contains a property type, which can be one of attribute, measurement, metric, or transform.
        /// This member is required.
        public var type: IoTSiteWiseClientTypes.PropertyType?
        /// The unit (such as Newtons or RPM) of the property.
        public var unit: Swift.String?

        public init(
            assetModelCompositeModelId: Swift.String? = nil,
            dataType: IoTSiteWiseClientTypes.PropertyDataType? = nil,
            dataTypeSpec: Swift.String? = nil,
            externalId: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            path: [IoTSiteWiseClientTypes.AssetModelPropertyPathSegment]? = nil,
            type: IoTSiteWiseClientTypes.PropertyType? = nil,
            unit: Swift.String? = nil
        )
        {
            self.assetModelCompositeModelId = assetModelCompositeModelId
            self.dataType = dataType
            self.dataTypeSpec = dataTypeSpec
            self.externalId = externalId
            self.id = id
            self.name = name
            self.path = path
            self.type = type
            self.unit = unit
        }
    }
}

extension IoTSiteWiseClientTypes {

    public enum AssetModelState: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case creating
        case deleting
        case failed
        case propagating
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [AssetModelState] {
            return [
                .active,
                .creating,
                .deleting,
                .failed,
                .propagating,
                .updating
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .creating: return "CREATING"
            case .deleting: return "DELETING"
            case .failed: return "FAILED"
            case .propagating: return "PROPAGATING"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTSiteWiseClientTypes {

    public enum ErrorCode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case internalFailure
        case validationError
        case sdkUnknown(Swift.String)

        public static var allCases: [ErrorCode] {
            return [
                .internalFailure,
                .validationError
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .internalFailure: return "INTERNAL_FAILURE"
            case .validationError: return "VALIDATION_ERROR"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTSiteWiseClientTypes {

    public enum DetailedErrorCode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case incompatibleComputeLocation
        case incompatibleForwardingConfiguration
        case sdkUnknown(Swift.String)

        public static var allCases: [DetailedErrorCode] {
            return [
                .incompatibleComputeLocation,
                .incompatibleForwardingConfiguration
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .incompatibleComputeLocation: return "INCOMPATIBLE_COMPUTE_LOCATION"
            case .incompatibleForwardingConfiguration: return "INCOMPATIBLE_FORWARDING_CONFIGURATION"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTSiteWiseClientTypes {

    /// Contains detailed error information.
    public struct DetailedError: Swift.Sendable {
        /// The error code.
        /// This member is required.
        public var code: IoTSiteWiseClientTypes.DetailedErrorCode?
        /// The error message.
        /// This member is required.
        public var message: Swift.String?

        public init(
            code: IoTSiteWiseClientTypes.DetailedErrorCode? = nil,
            message: Swift.String? = nil
        )
        {
            self.code = code
            self.message = message
        }
    }
}

extension IoTSiteWiseClientTypes {

    /// Contains the details of an IoT SiteWise error.
    public struct ErrorDetails: Swift.Sendable {
        /// The error code.
        /// This member is required.
        public var code: IoTSiteWiseClientTypes.ErrorCode?
        /// A list of detailed errors.
        public var details: [IoTSiteWiseClientTypes.DetailedError]?
        /// The error message.
        /// This member is required.
        public var message: Swift.String?

        public init(
            code: IoTSiteWiseClientTypes.ErrorCode? = nil,
            details: [IoTSiteWiseClientTypes.DetailedError]? = nil,
            message: Swift.String? = nil
        )
        {
            self.code = code
            self.details = details
            self.message = message
        }
    }
}

extension IoTSiteWiseClientTypes {

    /// Contains current status information for an asset model. For more information, see [Asset and model states](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/asset-and-model-states.html) in the IoT SiteWise User Guide.
    public struct AssetModelStatus: Swift.Sendable {
        /// Contains associated error information, if any.
        public var error: IoTSiteWiseClientTypes.ErrorDetails?
        /// The current state of the asset model.
        /// This member is required.
        public var state: IoTSiteWiseClientTypes.AssetModelState?

        public init(
            error: IoTSiteWiseClientTypes.ErrorDetails? = nil,
            state: IoTSiteWiseClientTypes.AssetModelState? = nil
        )
        {
            self.error = error
            self.state = state
        }
    }
}

extension IoTSiteWiseClientTypes {

    public enum AssetModelType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case assetModel
        case componentModel
        case sdkUnknown(Swift.String)

        public static var allCases: [AssetModelType] {
            return [
                .assetModel,
                .componentModel
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .assetModel: return "ASSET_MODEL"
            case .componentModel: return "COMPONENT_MODEL"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTSiteWiseClientTypes {

    /// Contains a summary of an asset model.
    public struct AssetModelSummary: Swift.Sendable {
        /// The [ARN](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the asset model, which has the following format. arn:${Partition}:iotsitewise:${Region}:${Account}:asset-model/${AssetModelId}
        /// This member is required.
        public var arn: Swift.String?
        /// The type of asset model.
        ///
        /// * ASSET_MODEL – (default) An asset model that you can use to create assets. Can't be included as a component in another asset model.
        ///
        /// * COMPONENT_MODEL – A reusable component that you can include in the composite models of other asset models. You can't create assets directly from this type of asset model.
        public var assetModelType: IoTSiteWiseClientTypes.AssetModelType?
        /// The date the asset model was created, in Unix epoch time.
        /// This member is required.
        public var creationDate: Foundation.Date?
        /// The asset model description.
        /// This member is required.
        public var description: Swift.String?
        /// The external ID of the asset model. For more information, see [Using external IDs](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/object-ids.html#external-ids) in the IoT SiteWise User Guide.
        public var externalId: Swift.String?
        /// The ID of the asset model (used with IoT SiteWise API operations).
        /// This member is required.
        public var id: Swift.String?
        /// The date the asset model was last updated, in Unix epoch time.
        /// This member is required.
        public var lastUpdateDate: Foundation.Date?
        /// The name of the asset model.
        /// This member is required.
        public var name: Swift.String?
        /// The current status of the asset model.
        /// This member is required.
        public var status: IoTSiteWiseClientTypes.AssetModelStatus?
        /// The version number of the asset model.
        public var version: Swift.String?

        public init(
            arn: Swift.String? = nil,
            assetModelType: IoTSiteWiseClientTypes.AssetModelType? = nil,
            creationDate: Foundation.Date? = nil,
            description: Swift.String? = nil,
            externalId: Swift.String? = nil,
            id: Swift.String? = nil,
            lastUpdateDate: Foundation.Date? = nil,
            name: Swift.String? = nil,
            status: IoTSiteWiseClientTypes.AssetModelStatus? = nil,
            version: Swift.String? = nil
        )
        {
            self.arn = arn
            self.assetModelType = assetModelType
            self.creationDate = creationDate
            self.description = description
            self.externalId = externalId
            self.id = id
            self.lastUpdateDate = lastUpdateDate
            self.name = name
            self.status = status
            self.version = version
        }
    }
}

extension IoTSiteWiseClientTypes {

    public enum AssetModelVersionType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case latest
        case sdkUnknown(Swift.String)

        public static var allCases: [AssetModelVersionType] {
            return [
                .active,
                .latest
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .latest: return "LATEST"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTSiteWiseClientTypes {

    /// Contains a summary of a property associated with an asset.
    public struct AssetPropertySummary: Swift.Sendable {
        /// The alias that identifies the property, such as an OPC-UA server data stream path (for example, /company/windfarm/3/turbine/7/temperature). For more information, see [Mapping industrial data streams to asset properties](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/connect-data-streams.html) in the IoT SiteWise User Guide.
        public var alias: Swift.String?
        /// The ID of the composite model that contains the asset property.
        public var assetCompositeModelId: Swift.String?
        /// The external ID of the property. For more information, see [Using external IDs](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/object-ids.html#external-ids) in the IoT SiteWise User Guide.
        public var externalId: Swift.String?
        /// The ID of the property.
        /// This member is required.
        public var id: Swift.String?
        /// Contains asset property value notification information. When the notification state is enabled, IoT SiteWise publishes property value updates to a unique MQTT topic. For more information, see [Interacting with other services](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/interact-with-other-services.html) in the IoT SiteWise User Guide.
        public var notification: IoTSiteWiseClientTypes.PropertyNotification?
        /// The structured path to the property from the root of the asset.
        public var path: [IoTSiteWiseClientTypes.AssetPropertyPathSegment]?
        /// The unit of measure (such as Newtons or RPM) of the asset property.
        public var unit: Swift.String?

        public init(
            alias: Swift.String? = nil,
            assetCompositeModelId: Swift.String? = nil,
            externalId: Swift.String? = nil,
            id: Swift.String? = nil,
            notification: IoTSiteWiseClientTypes.PropertyNotification? = nil,
            path: [IoTSiteWiseClientTypes.AssetPropertyPathSegment]? = nil,
            unit: Swift.String? = nil
        )
        {
            self.alias = alias
            self.assetCompositeModelId = assetCompositeModelId
            self.externalId = externalId
            self.id = id
            self.notification = notification
            self.path = path
            self.unit = unit
        }
    }
}

extension IoTSiteWiseClientTypes {

    /// Contains a timestamp with optional nanosecond granularity.
    public struct TimeInNanos: Swift.Sendable {
        /// The nanosecond offset from timeInSeconds.
        public var offsetInNanos: Swift.Int?
        /// The timestamp date, in seconds, in the Unix epoch format. Fractional nanosecond data is provided by offsetInNanos.
        /// This member is required.
        public var timeInSeconds: Swift.Int?

        public init(
            offsetInNanos: Swift.Int? = nil,
            timeInSeconds: Swift.Int? = nil
        )
        {
            self.offsetInNanos = offsetInNanos
            self.timeInSeconds = timeInSeconds
        }
    }
}

extension IoTSiteWiseClientTypes {

    /// Contains an asset property value (of a single type only).
    public struct Variant: Swift.Sendable {
        /// Asset property data of type Boolean (true or false).
        public var booleanValue: Swift.Bool?
        /// Asset property data of type double (floating point number).
        public var doubleValue: Swift.Double?
        /// Asset property data of type integer (whole number).
        public var integerValue: Swift.Int?
        /// Asset property data of type string (sequence of characters).
        public var stringValue: Swift.String?

        public init(
            booleanValue: Swift.Bool? = nil,
            doubleValue: Swift.Double? = nil,
            integerValue: Swift.Int? = nil,
            stringValue: Swift.String? = nil
        )
        {
            self.booleanValue = booleanValue
            self.doubleValue = doubleValue
            self.integerValue = integerValue
            self.stringValue = stringValue
        }
    }
}

extension IoTSiteWiseClientTypes {

    /// Contains asset property value information.
    public struct AssetPropertyValue: Swift.Sendable {
        /// The quality of the asset property value.
        public var quality: IoTSiteWiseClientTypes.Quality?
        /// The timestamp of the asset property value.
        /// This member is required.
        public var timestamp: IoTSiteWiseClientTypes.TimeInNanos?
        /// The value of the asset property (see Variant).
        /// This member is required.
        public var value: IoTSiteWiseClientTypes.Variant?

        public init(
            quality: IoTSiteWiseClientTypes.Quality? = nil,
            timestamp: IoTSiteWiseClientTypes.TimeInNanos? = nil,
            value: IoTSiteWiseClientTypes.Variant? = nil
        )
        {
            self.quality = quality
            self.timestamp = timestamp
            self.value = value
        }
    }
}

extension IoTSiteWiseClientTypes {

    public enum AssetRelationshipType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case hierarchy
        case sdkUnknown(Swift.String)

        public static var allCases: [AssetRelationshipType] {
            return [
                .hierarchy
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .hierarchy: return "HIERARCHY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTSiteWiseClientTypes {

    /// Contains information about assets that are related to one another.
    public struct AssetRelationshipSummary: Swift.Sendable {
        /// The assets that are related through an asset hierarchy. This object is present if the relationshipType is HIERARCHY.
        public var hierarchyInfo: IoTSiteWiseClientTypes.AssetHierarchyInfo?
        /// The relationship type of the assets in this relationship. This value is one of the following:
        ///
        /// * HIERARCHY – The assets are related through an asset hierarchy. If you specify this relationship type, this asset relationship includes the hierarchyInfo object.
        /// This member is required.
        public var relationshipType: IoTSiteWiseClientTypes.AssetRelationshipType?

        public init(
            hierarchyInfo: IoTSiteWiseClientTypes.AssetHierarchyInfo? = nil,
            relationshipType: IoTSiteWiseClientTypes.AssetRelationshipType? = nil
        )
        {
            self.hierarchyInfo = hierarchyInfo
            self.relationshipType = relationshipType
        }
    }
}

extension IoTSiteWiseClientTypes {

    public enum AssetState: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case creating
        case deleting
        case failed
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [AssetState] {
            return [
                .active,
                .creating,
                .deleting,
                .failed,
                .updating
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .creating: return "CREATING"
            case .deleting: return "DELETING"
            case .failed: return "FAILED"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTSiteWiseClientTypes {

    /// Contains information about the current status of an asset. For more information, see [Asset and model states](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/asset-and-model-states.html) in the IoT SiteWise User Guide.
    public struct AssetStatus: Swift.Sendable {
        /// Contains associated error information, if any.
        public var error: IoTSiteWiseClientTypes.ErrorDetails?
        /// The current status of the asset.
        /// This member is required.
        public var state: IoTSiteWiseClientTypes.AssetState?

        public init(
            error: IoTSiteWiseClientTypes.ErrorDetails? = nil,
            state: IoTSiteWiseClientTypes.AssetState? = nil
        )
        {
            self.error = error
            self.state = state
        }
    }
}

extension IoTSiteWiseClientTypes {

    /// Contains a summary of an asset.
    public struct AssetSummary: Swift.Sendable {
        /// The [ARN](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the asset, which has the following format. arn:${Partition}:iotsitewise:${Region}:${Account}:asset/${AssetId}
        /// This member is required.
        public var arn: Swift.String?
        /// The ID of the asset model used to create this asset.
        /// This member is required.
        public var assetModelId: Swift.String?
        /// The date the asset was created, in Unix epoch time.
        /// This member is required.
        public var creationDate: Foundation.Date?
        /// A description for the asset.
        public var description: Swift.String?
        /// The external ID of the asset. For more information, see [Using external IDs](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/object-ids.html#external-ids) in the IoT SiteWise User Guide.
        public var externalId: Swift.String?
        /// A list of asset hierarchies that each contain a hierarchyId. A hierarchy specifies allowed parent/child asset relationships.
        /// This member is required.
        public var hierarchies: [IoTSiteWiseClientTypes.AssetHierarchy]?
        /// The ID of the asset, in UUID format.
        /// This member is required.
        public var id: Swift.String?
        /// The date the asset was last updated, in Unix epoch time.
        /// This member is required.
        public var lastUpdateDate: Foundation.Date?
        /// The name of the asset.
        /// This member is required.
        public var name: Swift.String?
        /// The current status of the asset.
        /// This member is required.
        public var status: IoTSiteWiseClientTypes.AssetStatus?

        public init(
            arn: Swift.String? = nil,
            assetModelId: Swift.String? = nil,
            creationDate: Foundation.Date? = nil,
            description: Swift.String? = nil,
            externalId: Swift.String? = nil,
            hierarchies: [IoTSiteWiseClientTypes.AssetHierarchy]? = nil,
            id: Swift.String? = nil,
            lastUpdateDate: Foundation.Date? = nil,
            name: Swift.String? = nil,
            status: IoTSiteWiseClientTypes.AssetStatus? = nil
        )
        {
            self.arn = arn
            self.assetModelId = assetModelId
            self.creationDate = creationDate
            self.description = description
            self.externalId = externalId
            self.hierarchies = hierarchies
            self.id = id
            self.lastUpdateDate = lastUpdateDate
            self.name = name
            self.status = status
        }
    }
}

/// Your request has conflicting operations. This can occur if you're trying to perform more than one operation on the same resource at the same time.
public struct ConflictingOperationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The ARN of the resource that conflicts with this operation.
        /// This member is required.
        public internal(set) var resourceArn: Swift.String? = nil
        /// The ID of the resource that conflicts with this operation.
        /// This member is required.
        public internal(set) var resourceId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictingOperationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceArn: Swift.String? = nil,
        resourceId: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceArn = resourceArn
        self.properties.resourceId = resourceId
    }
}

/// IoT SiteWise can't process your request right now. Try again later.
public struct InternalFailureException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalFailureException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The request isn't valid. This can occur if your request contains malformed JSON or unsupported characters. Check your request and try again.
public struct InvalidRequestException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidRequestException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// You've reached the limit for a resource. For example, this can occur if you're trying to associate more than the allowed number of child assets or attempting to create more than the allowed number of properties for an asset model. For more information, see [Quotas](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/quotas.html) in the IoT SiteWise User Guide.
public struct LimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "LimitExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The resource already exists.
public struct ResourceAlreadyExistsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The ARN of the resource that already exists.
        /// This member is required.
        public internal(set) var resourceArn: Swift.String? = nil
        /// The ID of the resource that already exists.
        /// This member is required.
        public internal(set) var resourceId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceAlreadyExistsException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceArn: Swift.String? = nil,
        resourceId: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceArn = resourceArn
        self.properties.resourceId = resourceId
    }
}

/// The requested resource can't be found.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// Your request exceeded a rate limit. For example, you might have exceeded the number of IoT SiteWise assets that can be created per second, the allowed number of messages per second, and so on. For more information, see [Quotas](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/quotas.html) in the IoT SiteWise User Guide.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct AssociateAssetsInput: Swift.Sendable {
    /// The ID of the parent asset. This can be either the actual ID in UUID format, or else externalId: followed by the external ID, if it has one. For more information, see [Referencing objects with external IDs](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/object-ids.html#external-id-references) in the IoT SiteWise User Guide.
    /// This member is required.
    public var assetId: Swift.String?
    /// The ID of the child asset to be associated. This can be either the actual ID in UUID format, or else externalId: followed by the external ID, if it has one. For more information, see [Referencing objects with external IDs](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/object-ids.html#external-id-references) in the IoT SiteWise User Guide.
    /// This member is required.
    public var childAssetId: Swift.String?
    /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
    public var clientToken: Swift.String?
    /// The ID of a hierarchy in the parent asset's model. (This can be either the actual ID in UUID format, or else externalId: followed by the external ID, if it has one. For more information, see [Referencing objects with external IDs](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/object-ids.html#external-id-references) in the IoT SiteWise User Guide.) Hierarchies allow different groupings of assets to be formed that all come from the same asset model. For more information, see [Asset hierarchies](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/asset-hierarchies.html) in the IoT SiteWise User Guide.
    /// This member is required.
    public var hierarchyId: Swift.String?

    public init(
        assetId: Swift.String? = nil,
        childAssetId: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        hierarchyId: Swift.String? = nil
    )
    {
        self.assetId = assetId
        self.childAssetId = childAssetId
        self.clientToken = clientToken
        self.hierarchyId = hierarchyId
    }
}

extension IoTSiteWiseClientTypes {

    /// Contains a summary of an associated asset.
    public struct AssociatedAssetsSummary: Swift.Sendable {
        /// The [ARN](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the asset, which has the following format. arn:${Partition}:iotsitewise:${Region}:${Account}:asset/${AssetId}
        /// This member is required.
        public var arn: Swift.String?
        /// The ID of the asset model used to create the asset.
        /// This member is required.
        public var assetModelId: Swift.String?
        /// The date the asset was created, in Unix epoch time.
        /// This member is required.
        public var creationDate: Foundation.Date?
        /// A description for the asset.
        public var description: Swift.String?
        /// The external ID of the asset. For more information, see [Using external IDs](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/object-ids.html#external-ids) in the IoT SiteWise User Guide.
        public var externalId: Swift.String?
        /// A list of asset hierarchies that each contain a hierarchyId. A hierarchy specifies allowed parent/child asset relationships.
        /// This member is required.
        public var hierarchies: [IoTSiteWiseClientTypes.AssetHierarchy]?
        /// The ID of the asset, in UUID format.
        /// This member is required.
        public var id: Swift.String?
        /// The date the asset was last updated, in Unix epoch time.
        /// This member is required.
        public var lastUpdateDate: Foundation.Date?
        /// The name of the asset.
        /// This member is required.
        public var name: Swift.String?
        /// The current status of the asset.
        /// This member is required.
        public var status: IoTSiteWiseClientTypes.AssetStatus?

        public init(
            arn: Swift.String? = nil,
            assetModelId: Swift.String? = nil,
            creationDate: Foundation.Date? = nil,
            description: Swift.String? = nil,
            externalId: Swift.String? = nil,
            hierarchies: [IoTSiteWiseClientTypes.AssetHierarchy]? = nil,
            id: Swift.String? = nil,
            lastUpdateDate: Foundation.Date? = nil,
            name: Swift.String? = nil,
            status: IoTSiteWiseClientTypes.AssetStatus? = nil
        )
        {
            self.arn = arn
            self.assetModelId = assetModelId
            self.creationDate = creationDate
            self.description = description
            self.externalId = externalId
            self.hierarchies = hierarchies
            self.id = id
            self.lastUpdateDate = lastUpdateDate
            self.name = name
            self.status = status
        }
    }
}

public struct AssociateTimeSeriesToAssetPropertyInput: Swift.Sendable {
    /// The alias that identifies the time series.
    /// This member is required.
    public var alias: Swift.String?
    /// The ID of the asset in which the asset property was created. This can be either the actual ID in UUID format, or else externalId: followed by the external ID, if it has one. For more information, see [Referencing objects with external IDs](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/object-ids.html#external-id-references) in the IoT SiteWise User Guide.
    /// This member is required.
    public var assetId: Swift.String?
    /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
    public var clientToken: Swift.String?
    /// The ID of the asset property. This can be either the actual ID in UUID format, or else externalId: followed by the external ID, if it has one. For more information, see [Referencing objects with external IDs](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/object-ids.html#external-id-references) in the IoT SiteWise User Guide.
    /// This member is required.
    public var propertyId: Swift.String?

    public init(
        alias: Swift.String? = nil,
        assetId: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        propertyId: Swift.String? = nil
    )
    {
        self.alias = alias
        self.assetId = assetId
        self.clientToken = clientToken
        self.propertyId = propertyId
    }
}

extension IoTSiteWiseClientTypes {

    public enum AuthMode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case iam
        case sso
        case sdkUnknown(Swift.String)

        public static var allCases: [AuthMode] {
            return [
                .iam,
                .sso
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .iam: return "IAM"
            case .sso: return "SSO"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct BatchAssociateProjectAssetsInput: Swift.Sendable {
    /// The IDs of the assets to be associated to the project.
    /// This member is required.
    public var assetIds: [Swift.String]?
    /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
    public var clientToken: Swift.String?
    /// The ID of the project to which to associate the assets.
    /// This member is required.
    public var projectId: Swift.String?

    public init(
        assetIds: [Swift.String]? = nil,
        clientToken: Swift.String? = nil,
        projectId: Swift.String? = nil
    )
    {
        self.assetIds = assetIds
        self.clientToken = clientToken
        self.projectId = projectId
    }
}

public struct BatchAssociateProjectAssetsOutput: Swift.Sendable {
    /// A list of associated error information, if any.
    public var errors: [IoTSiteWiseClientTypes.AssetErrorDetails]?

    public init(
        errors: [IoTSiteWiseClientTypes.AssetErrorDetails]? = nil
    )
    {
        self.errors = errors
    }
}

public struct BatchDisassociateProjectAssetsInput: Swift.Sendable {
    /// The IDs of the assets to be disassociated from the project.
    /// This member is required.
    public var assetIds: [Swift.String]?
    /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
    public var clientToken: Swift.String?
    /// The ID of the project from which to disassociate the assets.
    /// This member is required.
    public var projectId: Swift.String?

    public init(
        assetIds: [Swift.String]? = nil,
        clientToken: Swift.String? = nil,
        projectId: Swift.String? = nil
    )
    {
        self.assetIds = assetIds
        self.clientToken = clientToken
        self.projectId = projectId
    }
}

public struct BatchDisassociateProjectAssetsOutput: Swift.Sendable {
    /// A list of associated error information, if any.
    public var errors: [IoTSiteWiseClientTypes.AssetErrorDetails]?

    public init(
        errors: [IoTSiteWiseClientTypes.AssetErrorDetails]? = nil
    )
    {
        self.errors = errors
    }
}

/// The requested service is unavailable.
public struct ServiceUnavailableException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceUnavailableException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension IoTSiteWiseClientTypes {

    public enum TimeOrdering: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case ascending
        case descending
        case sdkUnknown(Swift.String)

        public static var allCases: [TimeOrdering] {
            return [
                .ascending,
                .descending
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .ascending: return "ASCENDING"
            case .descending: return "DESCENDING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTSiteWiseClientTypes {

    /// Contains information for an asset property aggregate entry that is associated with the [BatchGetAssetPropertyAggregates](https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_BatchGetAssetPropertyAggregates.html) API. To identify an asset property, you must specify one of the following:
    ///
    /// * The assetId and propertyId of an asset property.
    ///
    /// * A propertyAlias, which is a data stream alias (for example, /company/windfarm/3/turbine/7/temperature). To define an asset property's alias, see [UpdateAssetProperty](https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_UpdateAssetProperty.html).
    public struct BatchGetAssetPropertyAggregatesEntry: Swift.Sendable {
        /// The data aggregating function.
        /// This member is required.
        public var aggregateTypes: [IoTSiteWiseClientTypes.AggregateType]?
        /// The ID of the asset in which the asset property was created.
        public var assetId: Swift.String?
        /// The inclusive end of the range from which to query historical data, expressed in seconds in Unix epoch time.
        /// This member is required.
        public var endDate: Foundation.Date?
        /// The ID of the entry.
        /// This member is required.
        public var entryId: Swift.String?
        /// The alias that identifies the property, such as an OPC-UA server data stream path (for example, /company/windfarm/3/turbine/7/temperature). For more information, see [Mapping industrial data streams to asset properties](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/connect-data-streams.html) in the IoT SiteWise User Guide.
        public var propertyAlias: Swift.String?
        /// The ID of the asset property, in UUID format.
        public var propertyId: Swift.String?
        /// The quality by which to filter asset data.
        public var qualities: [IoTSiteWiseClientTypes.Quality]?
        /// The time interval over which to aggregate data.
        /// This member is required.
        public var resolution: Swift.String?
        /// The exclusive start of the range from which to query historical data, expressed in seconds in Unix epoch time.
        /// This member is required.
        public var startDate: Foundation.Date?
        /// The chronological sorting order of the requested information. Default: ASCENDING
        public var timeOrdering: IoTSiteWiseClientTypes.TimeOrdering?

        public init(
            aggregateTypes: [IoTSiteWiseClientTypes.AggregateType]? = nil,
            assetId: Swift.String? = nil,
            endDate: Foundation.Date? = nil,
            entryId: Swift.String? = nil,
            propertyAlias: Swift.String? = nil,
            propertyId: Swift.String? = nil,
            qualities: [IoTSiteWiseClientTypes.Quality]? = nil,
            resolution: Swift.String? = nil,
            startDate: Foundation.Date? = nil,
            timeOrdering: IoTSiteWiseClientTypes.TimeOrdering? = nil
        )
        {
            self.aggregateTypes = aggregateTypes
            self.assetId = assetId
            self.endDate = endDate
            self.entryId = entryId
            self.propertyAlias = propertyAlias
            self.propertyId = propertyId
            self.qualities = qualities
            self.resolution = resolution
            self.startDate = startDate
            self.timeOrdering = timeOrdering
        }
    }
}

public struct BatchGetAssetPropertyAggregatesInput: Swift.Sendable {
    /// The list of asset property aggregate entries for the batch get request. You can specify up to 16 entries per request.
    /// This member is required.
    public var entries: [IoTSiteWiseClientTypes.BatchGetAssetPropertyAggregatesEntry]?
    /// The maximum number of results to return for each paginated request. A result set is returned in the two cases, whichever occurs first.
    ///
    /// * The size of the result set is equal to 1 MB.
    ///
    /// * The number of data points in the result set is equal to the value of maxResults. The maximum value of maxResults is 4000.
    public var maxResults: Swift.Int?
    /// The token to be used for the next set of paginated results.
    public var nextToken: Swift.String?

    public init(
        entries: [IoTSiteWiseClientTypes.BatchGetAssetPropertyAggregatesEntry]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.entries = entries
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension IoTSiteWiseClientTypes {

    public enum BatchGetAssetPropertyAggregatesErrorCode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case accessdeniedexception
        case invalidrequestexception
        case resourcenotfoundexception
        case sdkUnknown(Swift.String)

        public static var allCases: [BatchGetAssetPropertyAggregatesErrorCode] {
            return [
                .accessdeniedexception,
                .invalidrequestexception,
                .resourcenotfoundexception
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .accessdeniedexception: return "AccessDeniedException"
            case .invalidrequestexception: return "InvalidRequestException"
            case .resourcenotfoundexception: return "ResourceNotFoundException"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTSiteWiseClientTypes {

    /// Contains error information for an asset property aggregate entry that is associated with the [BatchGetAssetPropertyAggregates](https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_BatchGetAssetPropertyAggregates.html) API.
    public struct BatchGetAssetPropertyAggregatesErrorEntry: Swift.Sendable {
        /// The ID of the entry.
        /// This member is required.
        public var entryId: Swift.String?
        /// The error code.
        /// This member is required.
        public var errorCode: IoTSiteWiseClientTypes.BatchGetAssetPropertyAggregatesErrorCode?
        /// The associated error message.
        /// This member is required.
        public var errorMessage: Swift.String?

        public init(
            entryId: Swift.String? = nil,
            errorCode: IoTSiteWiseClientTypes.BatchGetAssetPropertyAggregatesErrorCode? = nil,
            errorMessage: Swift.String? = nil
        )
        {
            self.entryId = entryId
            self.errorCode = errorCode
            self.errorMessage = errorMessage
        }
    }
}

extension IoTSiteWiseClientTypes {

    public enum BatchEntryCompletionStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case error
        case success
        case sdkUnknown(Swift.String)

        public static var allCases: [BatchEntryCompletionStatus] {
            return [
                .error,
                .success
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .error: return "ERROR"
            case .success: return "SUCCESS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTSiteWiseClientTypes {

    /// Contains the error code and the timestamp for an asset property aggregate entry that is associated with the [BatchGetAssetPropertyAggregates](https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_BatchGetAssetPropertyAggregates.html) API.
    public struct BatchGetAssetPropertyAggregatesErrorInfo: Swift.Sendable {
        /// The error code.
        /// This member is required.
        public var errorCode: IoTSiteWiseClientTypes.BatchGetAssetPropertyAggregatesErrorCode?
        /// The date the error occurred, in Unix epoch time.
        /// This member is required.
        public var errorTimestamp: Foundation.Date?

        public init(
            errorCode: IoTSiteWiseClientTypes.BatchGetAssetPropertyAggregatesErrorCode? = nil,
            errorTimestamp: Foundation.Date? = nil
        )
        {
            self.errorCode = errorCode
            self.errorTimestamp = errorTimestamp
        }
    }
}

extension IoTSiteWiseClientTypes {

    /// Contains information for an entry that has been processed by the previous [BatchGetAssetPropertyAggregates](https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_BatchGetAssetPropertyAggregates.html) request.
    public struct BatchGetAssetPropertyAggregatesSkippedEntry: Swift.Sendable {
        /// The completion status of each entry that is associated with the [BatchGetAssetPropertyAggregates](https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_BatchGetAssetPropertyAggregates.html) API.
        /// This member is required.
        public var completionStatus: IoTSiteWiseClientTypes.BatchEntryCompletionStatus?
        /// The ID of the entry.
        /// This member is required.
        public var entryId: Swift.String?
        /// The error information, such as the error code and the timestamp.
        public var errorInfo: IoTSiteWiseClientTypes.BatchGetAssetPropertyAggregatesErrorInfo?

        public init(
            completionStatus: IoTSiteWiseClientTypes.BatchEntryCompletionStatus? = nil,
            entryId: Swift.String? = nil,
            errorInfo: IoTSiteWiseClientTypes.BatchGetAssetPropertyAggregatesErrorInfo? = nil
        )
        {
            self.completionStatus = completionStatus
            self.entryId = entryId
            self.errorInfo = errorInfo
        }
    }
}

extension IoTSiteWiseClientTypes {

    /// Contains success information for an entry that is associated with the [BatchGetAssetPropertyAggregates](https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_BatchGetAssetPropertyAggregates.html) API.
    public struct BatchGetAssetPropertyAggregatesSuccessEntry: Swift.Sendable {
        /// The requested aggregated asset property values (for example, average, minimum, and maximum).
        /// This member is required.
        public var aggregatedValues: [IoTSiteWiseClientTypes.AggregatedValue]?
        /// The ID of the entry.
        /// This member is required.
        public var entryId: Swift.String?

        public init(
            aggregatedValues: [IoTSiteWiseClientTypes.AggregatedValue]? = nil,
            entryId: Swift.String? = nil
        )
        {
            self.aggregatedValues = aggregatedValues
            self.entryId = entryId
        }
    }
}

public struct BatchGetAssetPropertyAggregatesOutput: Swift.Sendable {
    /// A list of the errors (if any) associated with the batch request. Each error entry contains the entryId of the entry that failed.
    /// This member is required.
    public var errorEntries: [IoTSiteWiseClientTypes.BatchGetAssetPropertyAggregatesErrorEntry]?
    /// The token for the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?
    /// A list of entries that were not processed by this batch request. because these entries had been completely processed by previous paginated requests. Each skipped entry contains the entryId of the entry that skipped.
    /// This member is required.
    public var skippedEntries: [IoTSiteWiseClientTypes.BatchGetAssetPropertyAggregatesSkippedEntry]?
    /// A list of entries that were processed successfully by this batch request. Each success entry contains the entryId of the entry that succeeded and the latest query result.
    /// This member is required.
    public var successEntries: [IoTSiteWiseClientTypes.BatchGetAssetPropertyAggregatesSuccessEntry]?

    public init(
        errorEntries: [IoTSiteWiseClientTypes.BatchGetAssetPropertyAggregatesErrorEntry]? = nil,
        nextToken: Swift.String? = nil,
        skippedEntries: [IoTSiteWiseClientTypes.BatchGetAssetPropertyAggregatesSkippedEntry]? = nil,
        successEntries: [IoTSiteWiseClientTypes.BatchGetAssetPropertyAggregatesSuccessEntry]? = nil
    )
    {
        self.errorEntries = errorEntries
        self.nextToken = nextToken
        self.skippedEntries = skippedEntries
        self.successEntries = successEntries
    }
}

extension IoTSiteWiseClientTypes {

    /// Contains information for an asset property value entry that is associated with the [BatchGetAssetPropertyValue](https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_BatchGetAssetPropertyValue.html) API. To identify an asset property, you must specify one of the following:
    ///
    /// * The assetId and propertyId of an asset property.
    ///
    /// * A propertyAlias, which is a data stream alias (for example, /company/windfarm/3/turbine/7/temperature). To define an asset property's alias, see [UpdateAssetProperty](https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_UpdateAssetProperty.html).
    public struct BatchGetAssetPropertyValueEntry: Swift.Sendable {
        /// The ID of the asset in which the asset property was created.
        public var assetId: Swift.String?
        /// The ID of the entry.
        /// This member is required.
        public var entryId: Swift.String?
        /// The alias that identifies the property, such as an OPC-UA server data stream path (for example, /company/windfarm/3/turbine/7/temperature). For more information, see [Mapping industrial data streams to asset properties](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/connect-data-streams.html) in the IoT SiteWise User Guide.
        public var propertyAlias: Swift.String?
        /// The ID of the asset property, in UUID format.
        public var propertyId: Swift.String?

        public init(
            assetId: Swift.String? = nil,
            entryId: Swift.String? = nil,
            propertyAlias: Swift.String? = nil,
            propertyId: Swift.String? = nil
        )
        {
            self.assetId = assetId
            self.entryId = entryId
            self.propertyAlias = propertyAlias
            self.propertyId = propertyId
        }
    }
}

public struct BatchGetAssetPropertyValueInput: Swift.Sendable {
    /// The list of asset property value entries for the batch get request. You can specify up to 128 entries per request.
    /// This member is required.
    public var entries: [IoTSiteWiseClientTypes.BatchGetAssetPropertyValueEntry]?
    /// The token to be used for the next set of paginated results.
    public var nextToken: Swift.String?

    public init(
        entries: [IoTSiteWiseClientTypes.BatchGetAssetPropertyValueEntry]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.entries = entries
        self.nextToken = nextToken
    }
}

extension IoTSiteWiseClientTypes {

    public enum BatchGetAssetPropertyValueErrorCode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case accessdeniedexception
        case invalidrequestexception
        case resourcenotfoundexception
        case sdkUnknown(Swift.String)

        public static var allCases: [BatchGetAssetPropertyValueErrorCode] {
            return [
                .accessdeniedexception,
                .invalidrequestexception,
                .resourcenotfoundexception
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .accessdeniedexception: return "AccessDeniedException"
            case .invalidrequestexception: return "InvalidRequestException"
            case .resourcenotfoundexception: return "ResourceNotFoundException"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTSiteWiseClientTypes {

    /// Contains error information for an asset property value entry that is associated with the [BatchGetAssetPropertyValue](https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_BatchGetAssetPropertyValue.html) API.
    public struct BatchGetAssetPropertyValueErrorEntry: Swift.Sendable {
        /// The ID of the entry.
        /// This member is required.
        public var entryId: Swift.String?
        /// The error code.
        /// This member is required.
        public var errorCode: IoTSiteWiseClientTypes.BatchGetAssetPropertyValueErrorCode?
        /// The associated error message.
        /// This member is required.
        public var errorMessage: Swift.String?

        public init(
            entryId: Swift.String? = nil,
            errorCode: IoTSiteWiseClientTypes.BatchGetAssetPropertyValueErrorCode? = nil,
            errorMessage: Swift.String? = nil
        )
        {
            self.entryId = entryId
            self.errorCode = errorCode
            self.errorMessage = errorMessage
        }
    }
}

extension IoTSiteWiseClientTypes {

    /// The error information, such as the error code and the timestamp.
    public struct BatchGetAssetPropertyValueErrorInfo: Swift.Sendable {
        /// The error code.
        /// This member is required.
        public var errorCode: IoTSiteWiseClientTypes.BatchGetAssetPropertyValueErrorCode?
        /// The date the error occurred, in Unix epoch time.
        /// This member is required.
        public var errorTimestamp: Foundation.Date?

        public init(
            errorCode: IoTSiteWiseClientTypes.BatchGetAssetPropertyValueErrorCode? = nil,
            errorTimestamp: Foundation.Date? = nil
        )
        {
            self.errorCode = errorCode
            self.errorTimestamp = errorTimestamp
        }
    }
}

extension IoTSiteWiseClientTypes {

    /// Contains information for an entry that has been processed by the previous [BatchGetAssetPropertyValue](https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_BatchGetAssetPropertyValue.html) request.
    public struct BatchGetAssetPropertyValueSkippedEntry: Swift.Sendable {
        /// The completion status of each entry that is associated with the [BatchGetAssetPropertyValue](https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_BatchGetAssetPropertyValue.html) request.
        /// This member is required.
        public var completionStatus: IoTSiteWiseClientTypes.BatchEntryCompletionStatus?
        /// The ID of the entry.
        /// This member is required.
        public var entryId: Swift.String?
        /// The error information, such as the error code and the timestamp.
        public var errorInfo: IoTSiteWiseClientTypes.BatchGetAssetPropertyValueErrorInfo?

        public init(
            completionStatus: IoTSiteWiseClientTypes.BatchEntryCompletionStatus? = nil,
            entryId: Swift.String? = nil,
            errorInfo: IoTSiteWiseClientTypes.BatchGetAssetPropertyValueErrorInfo? = nil
        )
        {
            self.completionStatus = completionStatus
            self.entryId = entryId
            self.errorInfo = errorInfo
        }
    }
}

extension IoTSiteWiseClientTypes {

    /// Contains success information for an entry that is associated with the [BatchGetAssetPropertyValue](https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_BatchGetAssetPropertyValue.html) API.
    public struct BatchGetAssetPropertyValueSuccessEntry: Swift.Sendable {
        /// Contains asset property value information.
        public var assetPropertyValue: IoTSiteWiseClientTypes.AssetPropertyValue?
        /// The ID of the entry.
        /// This member is required.
        public var entryId: Swift.String?

        public init(
            assetPropertyValue: IoTSiteWiseClientTypes.AssetPropertyValue? = nil,
            entryId: Swift.String? = nil
        )
        {
            self.assetPropertyValue = assetPropertyValue
            self.entryId = entryId
        }
    }
}

public struct BatchGetAssetPropertyValueOutput: Swift.Sendable {
    /// A list of the errors (if any) associated with the batch request. Each error entry contains the entryId of the entry that failed.
    /// This member is required.
    public var errorEntries: [IoTSiteWiseClientTypes.BatchGetAssetPropertyValueErrorEntry]?
    /// The token for the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?
    /// A list of entries that were not processed by this batch request. because these entries had been completely processed by previous paginated requests. Each skipped entry contains the entryId of the entry that skipped.
    /// This member is required.
    public var skippedEntries: [IoTSiteWiseClientTypes.BatchGetAssetPropertyValueSkippedEntry]?
    /// A list of entries that were processed successfully by this batch request. Each success entry contains the entryId of the entry that succeeded and the latest query result.
    /// This member is required.
    public var successEntries: [IoTSiteWiseClientTypes.BatchGetAssetPropertyValueSuccessEntry]?

    public init(
        errorEntries: [IoTSiteWiseClientTypes.BatchGetAssetPropertyValueErrorEntry]? = nil,
        nextToken: Swift.String? = nil,
        skippedEntries: [IoTSiteWiseClientTypes.BatchGetAssetPropertyValueSkippedEntry]? = nil,
        successEntries: [IoTSiteWiseClientTypes.BatchGetAssetPropertyValueSuccessEntry]? = nil
    )
    {
        self.errorEntries = errorEntries
        self.nextToken = nextToken
        self.skippedEntries = skippedEntries
        self.successEntries = successEntries
    }
}

extension IoTSiteWiseClientTypes {

    /// Contains information for an asset property historical value entry that is associated with the [BatchGetAssetPropertyValueHistory](https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_BatchGetAssetPropertyValue.html) API. To identify an asset property, you must specify one of the following:
    ///
    /// * The assetId and propertyId of an asset property.
    ///
    /// * A propertyAlias, which is a data stream alias (for example, /company/windfarm/3/turbine/7/temperature). To define an asset property's alias, see [UpdateAssetProperty](https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_UpdateAssetProperty.html).
    public struct BatchGetAssetPropertyValueHistoryEntry: Swift.Sendable {
        /// The ID of the asset in which the asset property was created.
        public var assetId: Swift.String?
        /// The inclusive end of the range from which to query historical data, expressed in seconds in Unix epoch time.
        public var endDate: Foundation.Date?
        /// The ID of the entry.
        /// This member is required.
        public var entryId: Swift.String?
        /// The alias that identifies the property, such as an OPC-UA server data stream path (for example, /company/windfarm/3/turbine/7/temperature). For more information, see [Mapping industrial data streams to asset properties](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/connect-data-streams.html) in the IoT SiteWise User Guide.
        public var propertyAlias: Swift.String?
        /// The ID of the asset property, in UUID format.
        public var propertyId: Swift.String?
        /// The quality by which to filter asset data.
        public var qualities: [IoTSiteWiseClientTypes.Quality]?
        /// The exclusive start of the range from which to query historical data, expressed in seconds in Unix epoch time.
        public var startDate: Foundation.Date?
        /// The chronological sorting order of the requested information. Default: ASCENDING
        public var timeOrdering: IoTSiteWiseClientTypes.TimeOrdering?

        public init(
            assetId: Swift.String? = nil,
            endDate: Foundation.Date? = nil,
            entryId: Swift.String? = nil,
            propertyAlias: Swift.String? = nil,
            propertyId: Swift.String? = nil,
            qualities: [IoTSiteWiseClientTypes.Quality]? = nil,
            startDate: Foundation.Date? = nil,
            timeOrdering: IoTSiteWiseClientTypes.TimeOrdering? = nil
        )
        {
            self.assetId = assetId
            self.endDate = endDate
            self.entryId = entryId
            self.propertyAlias = propertyAlias
            self.propertyId = propertyId
            self.qualities = qualities
            self.startDate = startDate
            self.timeOrdering = timeOrdering
        }
    }
}

public struct BatchGetAssetPropertyValueHistoryInput: Swift.Sendable {
    /// The list of asset property historical value entries for the batch get request. You can specify up to 16 entries per request.
    /// This member is required.
    public var entries: [IoTSiteWiseClientTypes.BatchGetAssetPropertyValueHistoryEntry]?
    /// The maximum number of results to return for each paginated request. A result set is returned in the two cases, whichever occurs first.
    ///
    /// * The size of the result set is equal to 4 MB.
    ///
    /// * The number of data points in the result set is equal to the value of maxResults. The maximum value of maxResults is 20000.
    public var maxResults: Swift.Int?
    /// The token to be used for the next set of paginated results.
    public var nextToken: Swift.String?

    public init(
        entries: [IoTSiteWiseClientTypes.BatchGetAssetPropertyValueHistoryEntry]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.entries = entries
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension IoTSiteWiseClientTypes {

    public enum BatchGetAssetPropertyValueHistoryErrorCode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case accessdeniedexception
        case invalidrequestexception
        case resourcenotfoundexception
        case sdkUnknown(Swift.String)

        public static var allCases: [BatchGetAssetPropertyValueHistoryErrorCode] {
            return [
                .accessdeniedexception,
                .invalidrequestexception,
                .resourcenotfoundexception
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .accessdeniedexception: return "AccessDeniedException"
            case .invalidrequestexception: return "InvalidRequestException"
            case .resourcenotfoundexception: return "ResourceNotFoundException"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTSiteWiseClientTypes {

    /// A list of the errors (if any) associated with the batch request. Each error entry contains the entryId of the entry that failed.
    public struct BatchGetAssetPropertyValueHistoryErrorEntry: Swift.Sendable {
        /// The ID of the entry.
        /// This member is required.
        public var entryId: Swift.String?
        /// The error code.
        /// This member is required.
        public var errorCode: IoTSiteWiseClientTypes.BatchGetAssetPropertyValueHistoryErrorCode?
        /// The associated error message.
        /// This member is required.
        public var errorMessage: Swift.String?

        public init(
            entryId: Swift.String? = nil,
            errorCode: IoTSiteWiseClientTypes.BatchGetAssetPropertyValueHistoryErrorCode? = nil,
            errorMessage: Swift.String? = nil
        )
        {
            self.entryId = entryId
            self.errorCode = errorCode
            self.errorMessage = errorMessage
        }
    }
}

extension IoTSiteWiseClientTypes {

    /// The error information, such as the error code and the timestamp.
    public struct BatchGetAssetPropertyValueHistoryErrorInfo: Swift.Sendable {
        /// The error code.
        /// This member is required.
        public var errorCode: IoTSiteWiseClientTypes.BatchGetAssetPropertyValueHistoryErrorCode?
        /// The date the error occurred, in Unix epoch time.
        /// This member is required.
        public var errorTimestamp: Foundation.Date?

        public init(
            errorCode: IoTSiteWiseClientTypes.BatchGetAssetPropertyValueHistoryErrorCode? = nil,
            errorTimestamp: Foundation.Date? = nil
        )
        {
            self.errorCode = errorCode
            self.errorTimestamp = errorTimestamp
        }
    }
}

extension IoTSiteWiseClientTypes {

    /// Contains information for an entry that has been processed by the previous [BatchGetAssetPropertyValueHistory](https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_BatchGetAssetPropertyValue.html) request.
    public struct BatchGetAssetPropertyValueHistorySkippedEntry: Swift.Sendable {
        /// The completion status of each entry that is associated with the [BatchGetAssetPropertyValueHistory](https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_BatchGetAssetPropertyValueHistory.html) API.
        /// This member is required.
        public var completionStatus: IoTSiteWiseClientTypes.BatchEntryCompletionStatus?
        /// The ID of the entry.
        /// This member is required.
        public var entryId: Swift.String?
        /// The error information, such as the error code and the timestamp.
        public var errorInfo: IoTSiteWiseClientTypes.BatchGetAssetPropertyValueHistoryErrorInfo?

        public init(
            completionStatus: IoTSiteWiseClientTypes.BatchEntryCompletionStatus? = nil,
            entryId: Swift.String? = nil,
            errorInfo: IoTSiteWiseClientTypes.BatchGetAssetPropertyValueHistoryErrorInfo? = nil
        )
        {
            self.completionStatus = completionStatus
            self.entryId = entryId
            self.errorInfo = errorInfo
        }
    }
}

extension IoTSiteWiseClientTypes {

    /// Contains success information for an entry that is associated with the [BatchGetAssetPropertyValueHistory](https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_BatchGetAssetPropertyValue.html) API.
    public struct BatchGetAssetPropertyValueHistorySuccessEntry: Swift.Sendable {
        /// The requested historical values for the specified asset property.
        /// This member is required.
        public var assetPropertyValueHistory: [IoTSiteWiseClientTypes.AssetPropertyValue]?
        /// The ID of the entry.
        /// This member is required.
        public var entryId: Swift.String?

        public init(
            assetPropertyValueHistory: [IoTSiteWiseClientTypes.AssetPropertyValue]? = nil,
            entryId: Swift.String? = nil
        )
        {
            self.assetPropertyValueHistory = assetPropertyValueHistory
            self.entryId = entryId
        }
    }
}

public struct BatchGetAssetPropertyValueHistoryOutput: Swift.Sendable {
    /// A list of the errors (if any) associated with the batch request. Each error entry contains the entryId of the entry that failed.
    /// This member is required.
    public var errorEntries: [IoTSiteWiseClientTypes.BatchGetAssetPropertyValueHistoryErrorEntry]?
    /// The token for the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?
    /// A list of entries that were not processed by this batch request. because these entries had been completely processed by previous paginated requests. Each skipped entry contains the entryId of the entry that skipped.
    /// This member is required.
    public var skippedEntries: [IoTSiteWiseClientTypes.BatchGetAssetPropertyValueHistorySkippedEntry]?
    /// A list of entries that were processed successfully by this batch request. Each success entry contains the entryId of the entry that succeeded and the latest query result.
    /// This member is required.
    public var successEntries: [IoTSiteWiseClientTypes.BatchGetAssetPropertyValueHistorySuccessEntry]?

    public init(
        errorEntries: [IoTSiteWiseClientTypes.BatchGetAssetPropertyValueHistoryErrorEntry]? = nil,
        nextToken: Swift.String? = nil,
        skippedEntries: [IoTSiteWiseClientTypes.BatchGetAssetPropertyValueHistorySkippedEntry]? = nil,
        successEntries: [IoTSiteWiseClientTypes.BatchGetAssetPropertyValueHistorySuccessEntry]? = nil
    )
    {
        self.errorEntries = errorEntries
        self.nextToken = nextToken
        self.skippedEntries = skippedEntries
        self.successEntries = successEntries
    }
}

extension IoTSiteWiseClientTypes {

    /// Contains a list of value updates for an asset property in the list of asset entries consumed by the [BatchPutAssetPropertyValue](https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_BatchPutAssetPropertyValue.html) API operation.
    public struct PutAssetPropertyValueEntry: Swift.Sendable {
        /// The ID of the asset to update.
        public var assetId: Swift.String?
        /// The user specified ID for the entry. You can use this ID to identify which entries failed.
        /// This member is required.
        public var entryId: Swift.String?
        /// The alias that identifies the property, such as an OPC-UA server data stream path (for example, /company/windfarm/3/turbine/7/temperature). For more information, see [Mapping industrial data streams to asset properties](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/connect-data-streams.html) in the IoT SiteWise User Guide.
        public var propertyAlias: Swift.String?
        /// The ID of the asset property for this entry.
        public var propertyId: Swift.String?
        /// The list of property values to upload. You can specify up to 10 propertyValues array elements.
        /// This member is required.
        public var propertyValues: [IoTSiteWiseClientTypes.AssetPropertyValue]?

        public init(
            assetId: Swift.String? = nil,
            entryId: Swift.String? = nil,
            propertyAlias: Swift.String? = nil,
            propertyId: Swift.String? = nil,
            propertyValues: [IoTSiteWiseClientTypes.AssetPropertyValue]? = nil
        )
        {
            self.assetId = assetId
            self.entryId = entryId
            self.propertyAlias = propertyAlias
            self.propertyId = propertyId
            self.propertyValues = propertyValues
        }
    }
}

public struct BatchPutAssetPropertyValueInput: Swift.Sendable {
    /// The list of asset property value entries for the batch put request. You can specify up to 10 entries per request.
    /// This member is required.
    public var entries: [IoTSiteWiseClientTypes.PutAssetPropertyValueEntry]?

    public init(
        entries: [IoTSiteWiseClientTypes.PutAssetPropertyValueEntry]? = nil
    )
    {
        self.entries = entries
    }
}

extension IoTSiteWiseClientTypes {

    public enum BatchPutAssetPropertyValueErrorCode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case accessdeniedexception
        case conflictingoperationexception
        case internalfailureexception
        case invalidrequestexception
        case limitexceededexception
        case resourcenotfoundexception
        case serviceunavailableexception
        case throttlingexception
        case timestampoutofrangeexception
        case sdkUnknown(Swift.String)

        public static var allCases: [BatchPutAssetPropertyValueErrorCode] {
            return [
                .accessdeniedexception,
                .conflictingoperationexception,
                .internalfailureexception,
                .invalidrequestexception,
                .limitexceededexception,
                .resourcenotfoundexception,
                .serviceunavailableexception,
                .throttlingexception,
                .timestampoutofrangeexception
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .accessdeniedexception: return "AccessDeniedException"
            case .conflictingoperationexception: return "ConflictingOperationException"
            case .internalfailureexception: return "InternalFailureException"
            case .invalidrequestexception: return "InvalidRequestException"
            case .limitexceededexception: return "LimitExceededException"
            case .resourcenotfoundexception: return "ResourceNotFoundException"
            case .serviceunavailableexception: return "ServiceUnavailableException"
            case .throttlingexception: return "ThrottlingException"
            case .timestampoutofrangeexception: return "TimestampOutOfRangeException"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTSiteWiseClientTypes {

    /// Contains error information from updating a batch of asset property values.
    public struct BatchPutAssetPropertyError: Swift.Sendable {
        /// The error code.
        /// This member is required.
        public var errorCode: IoTSiteWiseClientTypes.BatchPutAssetPropertyValueErrorCode?
        /// The associated error message.
        /// This member is required.
        public var errorMessage: Swift.String?
        /// A list of timestamps for each error, if any.
        /// This member is required.
        public var timestamps: [IoTSiteWiseClientTypes.TimeInNanos]?

        public init(
            errorCode: IoTSiteWiseClientTypes.BatchPutAssetPropertyValueErrorCode? = nil,
            errorMessage: Swift.String? = nil,
            timestamps: [IoTSiteWiseClientTypes.TimeInNanos]? = nil
        )
        {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.timestamps = timestamps
        }
    }
}

extension IoTSiteWiseClientTypes {

    /// Contains error information for asset property value entries that are associated with the [BatchPutAssetPropertyValue](https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_BatchPutAssetPropertyValue.html) API.
    public struct BatchPutAssetPropertyErrorEntry: Swift.Sendable {
        /// The ID of the failed entry.
        /// This member is required.
        public var entryId: Swift.String?
        /// The list of update property value errors.
        /// This member is required.
        public var errors: [IoTSiteWiseClientTypes.BatchPutAssetPropertyError]?

        public init(
            entryId: Swift.String? = nil,
            errors: [IoTSiteWiseClientTypes.BatchPutAssetPropertyError]? = nil
        )
        {
            self.entryId = entryId
            self.errors = errors
        }
    }
}

public struct BatchPutAssetPropertyValueOutput: Swift.Sendable {
    /// A list of the errors (if any) associated with the batch put request. Each error entry contains the entryId of the entry that failed.
    /// This member is required.
    public var errorEntries: [IoTSiteWiseClientTypes.BatchPutAssetPropertyErrorEntry]?

    public init(
        errorEntries: [IoTSiteWiseClientTypes.BatchPutAssetPropertyErrorEntry]? = nil
    )
    {
        self.errorEntries = errorEntries
    }
}

public struct CreateAccessPolicyInput: Swift.Sendable {
    /// The identity for this access policy. Choose an IAM Identity Center user, an IAM Identity Center group, or an IAM user.
    /// This member is required.
    public var accessPolicyIdentity: IoTSiteWiseClientTypes.Identity?
    /// The permission level for this access policy. Note that a project ADMINISTRATOR is also known as a project owner.
    /// This member is required.
    public var accessPolicyPermission: IoTSiteWiseClientTypes.Permission?
    /// The IoT SiteWise Monitor resource for this access policy. Choose either a portal or a project.
    /// This member is required.
    public var accessPolicyResource: IoTSiteWiseClientTypes.Resource?
    /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
    public var clientToken: Swift.String?
    /// A list of key-value pairs that contain metadata for the access policy. For more information, see [Tagging your IoT SiteWise resources](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/tag-resources.html) in the IoT SiteWise User Guide.
    public var tags: [Swift.String: Swift.String]?

    public init(
        accessPolicyIdentity: IoTSiteWiseClientTypes.Identity? = nil,
        accessPolicyPermission: IoTSiteWiseClientTypes.Permission? = nil,
        accessPolicyResource: IoTSiteWiseClientTypes.Resource? = nil,
        clientToken: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.accessPolicyIdentity = accessPolicyIdentity
        self.accessPolicyPermission = accessPolicyPermission
        self.accessPolicyResource = accessPolicyResource
        self.clientToken = clientToken
        self.tags = tags
    }
}

public struct CreateAccessPolicyOutput: Swift.Sendable {
    /// The [ARN](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the access policy, which has the following format. arn:${Partition}:iotsitewise:${Region}:${Account}:access-policy/${AccessPolicyId}
    /// This member is required.
    public var accessPolicyArn: Swift.String?
    /// The ID of the access policy.
    /// This member is required.
    public var accessPolicyId: Swift.String?

    public init(
        accessPolicyArn: Swift.String? = nil,
        accessPolicyId: Swift.String? = nil
    )
    {
        self.accessPolicyArn = accessPolicyArn
        self.accessPolicyId = accessPolicyId
    }
}

public struct CreateAssetInput: Swift.Sendable {
    /// A description for the asset.
    public var assetDescription: Swift.String?
    /// An external ID to assign to the asset. The external ID must be unique within your Amazon Web Services account. For more information, see [Using external IDs](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/object-ids.html#external-ids) in the IoT SiteWise User Guide.
    public var assetExternalId: Swift.String?
    /// The ID to assign to the asset, if desired. IoT SiteWise automatically generates a unique ID for you, so this parameter is never required. However, if you prefer to supply your own ID instead, you can specify it here in UUID format. If you specify your own ID, it must be globally unique.
    public var assetId: Swift.String?
    /// The ID of the asset model from which to create the asset. This can be either the actual ID in UUID format, or else externalId: followed by the external ID, if it has one. For more information, see [Referencing objects with external IDs](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/object-ids.html#external-id-references) in the IoT SiteWise User Guide.
    /// This member is required.
    public var assetModelId: Swift.String?
    /// A friendly name for the asset.
    /// This member is required.
    public var assetName: Swift.String?
    /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
    public var clientToken: Swift.String?
    /// A list of key-value pairs that contain metadata for the asset. For more information, see [Tagging your IoT SiteWise resources](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/tag-resources.html) in the IoT SiteWise User Guide.
    public var tags: [Swift.String: Swift.String]?

    public init(
        assetDescription: Swift.String? = nil,
        assetExternalId: Swift.String? = nil,
        assetId: Swift.String? = nil,
        assetModelId: Swift.String? = nil,
        assetName: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.assetDescription = assetDescription
        self.assetExternalId = assetExternalId
        self.assetId = assetId
        self.assetModelId = assetModelId
        self.assetName = assetName
        self.clientToken = clientToken
        self.tags = tags
    }
}

public struct CreateAssetOutput: Swift.Sendable {
    /// The [ARN](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the asset, which has the following format. arn:${Partition}:iotsitewise:${Region}:${Account}:asset/${AssetId}
    /// This member is required.
    public var assetArn: Swift.String?
    /// The ID of the asset, in UUID format. This ID uniquely identifies the asset within IoT SiteWise and can be used with other IoT SiteWise API operations.
    /// This member is required.
    public var assetId: Swift.String?
    /// The status of the asset, which contains a state (CREATING after successfully calling this operation) and any error message.
    /// This member is required.
    public var assetStatus: IoTSiteWiseClientTypes.AssetStatus?

    public init(
        assetArn: Swift.String? = nil,
        assetId: Swift.String? = nil,
        assetStatus: IoTSiteWiseClientTypes.AssetStatus? = nil
    )
    {
        self.assetArn = assetArn
        self.assetId = assetId
        self.assetStatus = assetStatus
    }
}

public struct CreateAssetModelInput: Swift.Sendable {
    /// The composite models that are part of this asset model. It groups properties (such as attributes, measurements, transforms, and metrics) and child composite models that model parts of your industrial equipment. Each composite model has a type that defines the properties that the composite model supports. Use composite models to define alarms on this asset model. When creating custom composite models, you need to use [CreateAssetModelCompositeModel](https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_CreateAssetModelCompositeModel.html). For more information, see [Creating custom composite models (Components)](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/create-custom-composite-models.html) in the IoT SiteWise User Guide.
    public var assetModelCompositeModels: [IoTSiteWiseClientTypes.AssetModelCompositeModelDefinition]?
    /// A description for the asset model.
    public var assetModelDescription: Swift.String?
    /// An external ID to assign to the asset model. The external ID must be unique within your Amazon Web Services account. For more information, see [Using external IDs](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/object-ids.html#external-ids) in the IoT SiteWise User Guide.
    public var assetModelExternalId: Swift.String?
    /// The hierarchy definitions of the asset model. Each hierarchy specifies an asset model whose assets can be children of any other assets created from this asset model. For more information, see [Asset hierarchies](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/asset-hierarchies.html) in the IoT SiteWise User Guide. You can specify up to 10 hierarchies per asset model. For more information, see [Quotas](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/quotas.html) in the IoT SiteWise User Guide.
    public var assetModelHierarchies: [IoTSiteWiseClientTypes.AssetModelHierarchyDefinition]?
    /// The ID to assign to the asset model, if desired. IoT SiteWise automatically generates a unique ID for you, so this parameter is never required. However, if you prefer to supply your own ID instead, you can specify it here in UUID format. If you specify your own ID, it must be globally unique.
    public var assetModelId: Swift.String?
    /// A unique name for the asset model.
    /// This member is required.
    public var assetModelName: Swift.String?
    /// The property definitions of the asset model. For more information, see [Asset properties](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/asset-properties.html) in the IoT SiteWise User Guide. You can specify up to 200 properties per asset model. For more information, see [Quotas](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/quotas.html) in the IoT SiteWise User Guide.
    public var assetModelProperties: [IoTSiteWiseClientTypes.AssetModelPropertyDefinition]?
    /// The type of asset model.
    ///
    /// * ASSET_MODEL – (default) An asset model that you can use to create assets. Can't be included as a component in another asset model.
    ///
    /// * COMPONENT_MODEL – A reusable component that you can include in the composite models of other asset models. You can't create assets directly from this type of asset model.
    public var assetModelType: IoTSiteWiseClientTypes.AssetModelType?
    /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
    public var clientToken: Swift.String?
    /// A list of key-value pairs that contain metadata for the asset model. For more information, see [Tagging your IoT SiteWise resources](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/tag-resources.html) in the IoT SiteWise User Guide.
    public var tags: [Swift.String: Swift.String]?

    public init(
        assetModelCompositeModels: [IoTSiteWiseClientTypes.AssetModelCompositeModelDefinition]? = nil,
        assetModelDescription: Swift.String? = nil,
        assetModelExternalId: Swift.String? = nil,
        assetModelHierarchies: [IoTSiteWiseClientTypes.AssetModelHierarchyDefinition]? = nil,
        assetModelId: Swift.String? = nil,
        assetModelName: Swift.String? = nil,
        assetModelProperties: [IoTSiteWiseClientTypes.AssetModelPropertyDefinition]? = nil,
        assetModelType: IoTSiteWiseClientTypes.AssetModelType? = nil,
        clientToken: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.assetModelCompositeModels = assetModelCompositeModels
        self.assetModelDescription = assetModelDescription
        self.assetModelExternalId = assetModelExternalId
        self.assetModelHierarchies = assetModelHierarchies
        self.assetModelId = assetModelId
        self.assetModelName = assetModelName
        self.assetModelProperties = assetModelProperties
        self.assetModelType = assetModelType
        self.clientToken = clientToken
        self.tags = tags
    }
}

public struct CreateAssetModelOutput: Swift.Sendable {
    /// The [ARN](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the asset model, which has the following format. arn:${Partition}:iotsitewise:${Region}:${Account}:asset-model/${AssetModelId}
    /// This member is required.
    public var assetModelArn: Swift.String?
    /// The ID of the asset model, in UUID format. You can use this ID when you call other IoT SiteWise API operations.
    /// This member is required.
    public var assetModelId: Swift.String?
    /// The status of the asset model, which contains a state (CREATING after successfully calling this operation) and any error message.
    /// This member is required.
    public var assetModelStatus: IoTSiteWiseClientTypes.AssetModelStatus?

    public init(
        assetModelArn: Swift.String? = nil,
        assetModelId: Swift.String? = nil,
        assetModelStatus: IoTSiteWiseClientTypes.AssetModelStatus? = nil
    )
    {
        self.assetModelArn = assetModelArn
        self.assetModelId = assetModelId
        self.assetModelStatus = assetModelStatus
    }
}

/// The precondition in one or more of the request-header fields evaluated to FALSE.
public struct PreconditionFailedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The ARN of the resource on which precondition failed with this operation.
        /// This member is required.
        public internal(set) var resourceArn: Swift.String? = nil
        /// The ID of the resource on which precondition failed with this operation.
        /// This member is required.
        public internal(set) var resourceId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "PreconditionFailedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceArn: Swift.String? = nil,
        resourceId: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceArn = resourceArn
        self.properties.resourceId = resourceId
    }
}

public struct CreateAssetModelCompositeModelInput: Swift.Sendable {
    /// A description for the composite model.
    public var assetModelCompositeModelDescription: Swift.String?
    /// An external ID to assign to the composite model. If the composite model is a derived composite model, or one nested inside a component model, you can only set the external ID using UpdateAssetModelCompositeModel and specifying the derived ID of the model or property from the created model it's a part of.
    public var assetModelCompositeModelExternalId: Swift.String?
    /// The ID of the composite model. IoT SiteWise automatically generates a unique ID for you, so this parameter is never required. However, if you prefer to supply your own ID instead, you can specify it here in UUID format. If you specify your own ID, it must be globally unique.
    public var assetModelCompositeModelId: Swift.String?
    /// A unique name for the composite model.
    /// This member is required.
    public var assetModelCompositeModelName: Swift.String?
    /// The property definitions of the composite model. For more information, see [ Inline custom composite models](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/custom-composite-models.html#inline-composite-models) in the IoT SiteWise User Guide. You can specify up to 200 properties per composite model. For more information, see [Quotas](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/quotas.html) in the IoT SiteWise User Guide.
    public var assetModelCompositeModelProperties: [IoTSiteWiseClientTypes.AssetModelPropertyDefinition]?
    /// The composite model type. Valid values are AWS/ALARM, CUSTOM, or  AWS/L4E_ANOMALY.
    /// This member is required.
    public var assetModelCompositeModelType: Swift.String?
    /// The ID of the asset model this composite model is a part of.
    /// This member is required.
    public var assetModelId: Swift.String?
    /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
    public var clientToken: Swift.String?
    /// The ID of a component model which is reused to create this composite model.
    public var composedAssetModelId: Swift.String?
    /// The expected current entity tag (ETag) for the asset model’s latest or active version (specified using matchForVersionType). The create request is rejected if the tag does not match the latest or active version's current entity tag. See [Optimistic locking for asset model writes](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/opt-locking-for-model.html) in the IoT SiteWise User Guide.
    public var ifMatch: Swift.String?
    /// Accepts * to reject the create request if an active version (specified using matchForVersionType as ACTIVE) already exists for the asset model.
    public var ifNoneMatch: Swift.String?
    /// Specifies the asset model version type (LATEST or ACTIVE) used in conjunction with If-Match or If-None-Match headers to determine the target ETag for the create operation.
    public var matchForVersionType: IoTSiteWiseClientTypes.AssetModelVersionType?
    /// The ID of the parent composite model in this asset model relationship.
    public var parentAssetModelCompositeModelId: Swift.String?

    public init(
        assetModelCompositeModelDescription: Swift.String? = nil,
        assetModelCompositeModelExternalId: Swift.String? = nil,
        assetModelCompositeModelId: Swift.String? = nil,
        assetModelCompositeModelName: Swift.String? = nil,
        assetModelCompositeModelProperties: [IoTSiteWiseClientTypes.AssetModelPropertyDefinition]? = nil,
        assetModelCompositeModelType: Swift.String? = nil,
        assetModelId: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        composedAssetModelId: Swift.String? = nil,
        ifMatch: Swift.String? = nil,
        ifNoneMatch: Swift.String? = nil,
        matchForVersionType: IoTSiteWiseClientTypes.AssetModelVersionType? = nil,
        parentAssetModelCompositeModelId: Swift.String? = nil
    )
    {
        self.assetModelCompositeModelDescription = assetModelCompositeModelDescription
        self.assetModelCompositeModelExternalId = assetModelCompositeModelExternalId
        self.assetModelCompositeModelId = assetModelCompositeModelId
        self.assetModelCompositeModelName = assetModelCompositeModelName
        self.assetModelCompositeModelProperties = assetModelCompositeModelProperties
        self.assetModelCompositeModelType = assetModelCompositeModelType
        self.assetModelId = assetModelId
        self.clientToken = clientToken
        self.composedAssetModelId = composedAssetModelId
        self.ifMatch = ifMatch
        self.ifNoneMatch = ifNoneMatch
        self.matchForVersionType = matchForVersionType
        self.parentAssetModelCompositeModelId = parentAssetModelCompositeModelId
    }
}

public struct CreateAssetModelCompositeModelOutput: Swift.Sendable {
    /// The ID of the composed asset model. You can use this ID when you call other IoT SiteWise APIs.
    /// This member is required.
    public var assetModelCompositeModelId: Swift.String?
    /// The path to the composite model listing the parent composite models.
    /// This member is required.
    public var assetModelCompositeModelPath: [IoTSiteWiseClientTypes.AssetModelCompositeModelPathSegment]?
    /// Contains current status information for an asset model. For more information, see [Asset and model states](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/asset-and-model-states.html) in the IoT SiteWise User Guide.
    /// This member is required.
    public var assetModelStatus: IoTSiteWiseClientTypes.AssetModelStatus?

    public init(
        assetModelCompositeModelId: Swift.String? = nil,
        assetModelCompositeModelPath: [IoTSiteWiseClientTypes.AssetModelCompositeModelPathSegment]? = nil,
        assetModelStatus: IoTSiteWiseClientTypes.AssetModelStatus? = nil
    )
    {
        self.assetModelCompositeModelId = assetModelCompositeModelId
        self.assetModelCompositeModelPath = assetModelCompositeModelPath
        self.assetModelStatus = assetModelStatus
    }
}

extension IoTSiteWiseClientTypes {

    /// The Amazon S3 destination where errors associated with the job creation request are saved.
    public struct ErrorReportLocation: Swift.Sendable {
        /// The name of the Amazon S3 bucket to which errors associated with the bulk import job are sent.
        /// This member is required.
        public var bucket: Swift.String?
        /// Amazon S3 uses the prefix as a folder name to organize data in the bucket. Each Amazon S3 object has a key that is its unique identifier in the bucket. Each object in a bucket has exactly one key. The prefix must end with a forward slash (/). For more information, see [Organizing objects using prefixes](https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-prefixes.html) in the Amazon Simple Storage Service User Guide.
        /// This member is required.
        public var `prefix`: Swift.String?

        public init(
            bucket: Swift.String? = nil,
            `prefix`: Swift.String? = nil
        )
        {
            self.bucket = bucket
            self.`prefix` = `prefix`
        }
    }
}

extension IoTSiteWiseClientTypes {

    /// The file in Amazon S3 where your data is saved.
    public struct File: Swift.Sendable {
        /// The name of the Amazon S3 bucket from which data is imported.
        /// This member is required.
        public var bucket: Swift.String?
        /// The key of the Amazon S3 object that contains your data. Each object has a key that is a unique identifier. Each object has exactly one key.
        /// This member is required.
        public var key: Swift.String?
        /// The version ID to identify a specific version of the Amazon S3 object that contains your data.
        public var versionId: Swift.String?

        public init(
            bucket: Swift.String? = nil,
            key: Swift.String? = nil,
            versionId: Swift.String? = nil
        )
        {
            self.bucket = bucket
            self.key = key
            self.versionId = versionId
        }
    }
}

extension IoTSiteWiseClientTypes {

    public enum ColumnName: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case alias
        case assetId
        case dataType
        case propertyId
        case quality
        case timestampNanoOffset
        case timestampSeconds
        case value
        case sdkUnknown(Swift.String)

        public static var allCases: [ColumnName] {
            return [
                .alias,
                .assetId,
                .dataType,
                .propertyId,
                .quality,
                .timestampNanoOffset,
                .timestampSeconds,
                .value
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .alias: return "ALIAS"
            case .assetId: return "ASSET_ID"
            case .dataType: return "DATA_TYPE"
            case .propertyId: return "PROPERTY_ID"
            case .quality: return "QUALITY"
            case .timestampNanoOffset: return "TIMESTAMP_NANO_OFFSET"
            case .timestampSeconds: return "TIMESTAMP_SECONDS"
            case .value: return "VALUE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTSiteWiseClientTypes {

    /// A .CSV file.
    public struct Csv: Swift.Sendable {
        /// The column names specified in the .csv file.
        /// This member is required.
        public var columnNames: [IoTSiteWiseClientTypes.ColumnName]?

        public init(
            columnNames: [IoTSiteWiseClientTypes.ColumnName]? = nil
        )
        {
            self.columnNames = columnNames
        }
    }
}

extension IoTSiteWiseClientTypes {

    /// A parquet file.
    public struct Parquet: Swift.Sendable {

        public init() { }
    }
}

extension IoTSiteWiseClientTypes {

    /// The file format of the data in S3.
    public struct FileFormat: Swift.Sendable {
        /// The file is in .CSV format.
        public var csv: IoTSiteWiseClientTypes.Csv?
        /// The file is in parquet format.
        public var parquet: IoTSiteWiseClientTypes.Parquet?

        public init(
            csv: IoTSiteWiseClientTypes.Csv? = nil,
            parquet: IoTSiteWiseClientTypes.Parquet? = nil
        )
        {
            self.csv = csv
            self.parquet = parquet
        }
    }
}

extension IoTSiteWiseClientTypes {

    /// Contains the configuration information of a job, such as the file format used to save data in Amazon S3.
    public struct JobConfiguration: Swift.Sendable {
        /// The file format of the data in S3.
        /// This member is required.
        public var fileFormat: IoTSiteWiseClientTypes.FileFormat?

        public init(
            fileFormat: IoTSiteWiseClientTypes.FileFormat? = nil
        )
        {
            self.fileFormat = fileFormat
        }
    }
}

public struct CreateBulkImportJobInput: Swift.Sendable {
    /// If set to true, ingest new data into IoT SiteWise storage. Measurements with notifications, metrics and transforms are computed. If set to false, historical data is ingested into IoT SiteWise as is.
    public var adaptiveIngestion: Swift.Bool?
    /// If set to true, your data files is deleted from S3, after ingestion into IoT SiteWise storage.
    public var deleteFilesAfterImport: Swift.Bool?
    /// The Amazon S3 destination where errors associated with the job creation request are saved.
    /// This member is required.
    public var errorReportLocation: IoTSiteWiseClientTypes.ErrorReportLocation?
    /// The files in the specified Amazon S3 bucket that contain your data.
    /// This member is required.
    public var files: [IoTSiteWiseClientTypes.File]?
    /// Contains the configuration information of a job, such as the file format used to save data in Amazon S3.
    /// This member is required.
    public var jobConfiguration: IoTSiteWiseClientTypes.JobConfiguration?
    /// The unique name that helps identify the job request.
    /// This member is required.
    public var jobName: Swift.String?
    /// The [ARN](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the IAM role that allows IoT SiteWise to read Amazon S3 data.
    /// This member is required.
    public var jobRoleArn: Swift.String?

    public init(
        adaptiveIngestion: Swift.Bool? = nil,
        deleteFilesAfterImport: Swift.Bool? = nil,
        errorReportLocation: IoTSiteWiseClientTypes.ErrorReportLocation? = nil,
        files: [IoTSiteWiseClientTypes.File]? = nil,
        jobConfiguration: IoTSiteWiseClientTypes.JobConfiguration? = nil,
        jobName: Swift.String? = nil,
        jobRoleArn: Swift.String? = nil
    )
    {
        self.adaptiveIngestion = adaptiveIngestion
        self.deleteFilesAfterImport = deleteFilesAfterImport
        self.errorReportLocation = errorReportLocation
        self.files = files
        self.jobConfiguration = jobConfiguration
        self.jobName = jobName
        self.jobRoleArn = jobRoleArn
    }
}

extension IoTSiteWiseClientTypes {

    public enum JobStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case cancelled
        case completed
        case completedWithFailures
        case failed
        case pending
        case running
        case sdkUnknown(Swift.String)

        public static var allCases: [JobStatus] {
            return [
                .cancelled,
                .completed,
                .completedWithFailures,
                .failed,
                .pending,
                .running
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .cancelled: return "CANCELLED"
            case .completed: return "COMPLETED"
            case .completedWithFailures: return "COMPLETED_WITH_FAILURES"
            case .failed: return "FAILED"
            case .pending: return "PENDING"
            case .running: return "RUNNING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateBulkImportJobOutput: Swift.Sendable {
    /// The ID of the job.
    /// This member is required.
    public var jobId: Swift.String?
    /// The unique name that helps identify the job request.
    /// This member is required.
    public var jobName: Swift.String?
    /// The status of the bulk import job can be one of following values:
    ///
    /// * PENDING – IoT SiteWise is waiting for the current bulk import job to finish.
    ///
    /// * CANCELLED – The bulk import job has been canceled.
    ///
    /// * RUNNING – IoT SiteWise is processing your request to import your data from Amazon S3.
    ///
    /// * COMPLETED – IoT SiteWise successfully completed your request to import data from Amazon S3.
    ///
    /// * FAILED – IoT SiteWise couldn't process your request to import data from Amazon S3. You can use logs saved in the specified error report location in Amazon S3 to troubleshoot issues.
    ///
    /// * COMPLETED_WITH_FAILURES – IoT SiteWise completed your request to import data from Amazon S3 with errors. You can use logs saved in the specified error report location in Amazon S3 to troubleshoot issues.
    /// This member is required.
    public var jobStatus: IoTSiteWiseClientTypes.JobStatus?

    public init(
        jobId: Swift.String? = nil,
        jobName: Swift.String? = nil,
        jobStatus: IoTSiteWiseClientTypes.JobStatus? = nil
    )
    {
        self.jobId = jobId
        self.jobName = jobName
        self.jobStatus = jobStatus
    }
}

public struct CreateDashboardInput: Swift.Sendable {
    /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
    public var clientToken: Swift.String?
    /// The dashboard definition specified in a JSON literal. For detailed information, see [Creating dashboards (CLI)](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/create-dashboards-using-aws-cli.html) in the IoT SiteWise User Guide.
    /// This member is required.
    public var dashboardDefinition: Swift.String?
    /// A description for the dashboard.
    public var dashboardDescription: Swift.String?
    /// A friendly name for the dashboard.
    /// This member is required.
    public var dashboardName: Swift.String?
    /// The ID of the project in which to create the dashboard.
    /// This member is required.
    public var projectId: Swift.String?
    /// A list of key-value pairs that contain metadata for the dashboard. For more information, see [Tagging your IoT SiteWise resources](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/tag-resources.html) in the IoT SiteWise User Guide.
    public var tags: [Swift.String: Swift.String]?

    public init(
        clientToken: Swift.String? = nil,
        dashboardDefinition: Swift.String? = nil,
        dashboardDescription: Swift.String? = nil,
        dashboardName: Swift.String? = nil,
        projectId: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.clientToken = clientToken
        self.dashboardDefinition = dashboardDefinition
        self.dashboardDescription = dashboardDescription
        self.dashboardName = dashboardName
        self.projectId = projectId
        self.tags = tags
    }
}

public struct CreateDashboardOutput: Swift.Sendable {
    /// The [ARN](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the dashboard, which has the following format. arn:${Partition}:iotsitewise:${Region}:${Account}:dashboard/${DashboardId}
    /// This member is required.
    public var dashboardArn: Swift.String?
    /// The ID of the dashboard.
    /// This member is required.
    public var dashboardId: Swift.String?

    public init(
        dashboardArn: Swift.String? = nil,
        dashboardId: Swift.String? = nil
    )
    {
        self.dashboardArn = dashboardArn
        self.dashboardId = dashboardId
    }
}

extension IoTSiteWiseClientTypes {

    /// Contains details for a gateway that runs on IoT Greengrass. To create a gateway that runs on IoT Greengrass, you must add the IoT SiteWise connector to a Greengrass group and deploy it. Your Greengrass group must also have permissions to upload data to IoT SiteWise. For more information, see [Ingesting data using a gateway](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/gateway-connector.html) in the IoT SiteWise User Guide.
    public struct Greengrass: Swift.Sendable {
        /// The [ARN](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the Greengrass group. For more information about how to find a group's ARN, see [ListGroups](https://docs.aws.amazon.com/greengrass/v1/apireference/listgroups-get.html) and [GetGroup](https://docs.aws.amazon.com/greengrass/v1/apireference/getgroup-get.html) in the IoT Greengrass V1 API Reference.
        /// This member is required.
        public var groupArn: Swift.String?

        public init(
            groupArn: Swift.String? = nil
        )
        {
            self.groupArn = groupArn
        }
    }
}

extension IoTSiteWiseClientTypes {

    /// Contains details for a gateway that runs on IoT Greengrass V2. To create a gateway that runs on IoT Greengrass V2, you must deploy the IoT SiteWise Edge component to your gateway device. Your [Greengrass device role](https://docs.aws.amazon.com/greengrass/v2/developerguide/device-service-role.html) must use the AWSIoTSiteWiseEdgeAccess policy. For more information, see [Using IoT SiteWise at the edge](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/sw-gateways.html) in the IoT SiteWise User Guide.
    public struct GreengrassV2: Swift.Sendable {
        /// The name of the IoT thing for your IoT Greengrass V2 core device.
        /// This member is required.
        public var coreDeviceThingName: Swift.String?

        public init(
            coreDeviceThingName: Swift.String? = nil
        )
        {
            self.coreDeviceThingName = coreDeviceThingName
        }
    }
}

extension IoTSiteWiseClientTypes {

    /// Contains details for a SiteWise Edge gateway that runs on a Siemens Industrial Edge Device.
    public struct SiemensIE: Swift.Sendable {
        /// The name of the IoT Thing for your SiteWise Edge gateway.
        /// This member is required.
        public var iotCoreThingName: Swift.String?

        public init(
            iotCoreThingName: Swift.String? = nil
        )
        {
            self.iotCoreThingName = iotCoreThingName
        }
    }
}

extension IoTSiteWiseClientTypes {

    /// Contains a gateway's platform information.
    public struct GatewayPlatform: Swift.Sendable {
        /// A gateway that runs on IoT Greengrass.
        public var greengrass: IoTSiteWiseClientTypes.Greengrass?
        /// A gateway that runs on IoT Greengrass V2.
        public var greengrassV2: IoTSiteWiseClientTypes.GreengrassV2?
        /// A SiteWise Edge gateway that runs on a Siemens Industrial Edge Device.
        public var siemensIE: IoTSiteWiseClientTypes.SiemensIE?

        public init(
            greengrass: IoTSiteWiseClientTypes.Greengrass? = nil,
            greengrassV2: IoTSiteWiseClientTypes.GreengrassV2? = nil,
            siemensIE: IoTSiteWiseClientTypes.SiemensIE? = nil
        )
        {
            self.greengrass = greengrass
            self.greengrassV2 = greengrassV2
            self.siemensIE = siemensIE
        }
    }
}

public struct CreateGatewayInput: Swift.Sendable {
    /// A unique name for the gateway.
    /// This member is required.
    public var gatewayName: Swift.String?
    /// The gateway's platform. You can only specify one platform in a gateway.
    /// This member is required.
    public var gatewayPlatform: IoTSiteWiseClientTypes.GatewayPlatform?
    /// A list of key-value pairs that contain metadata for the gateway. For more information, see [Tagging your IoT SiteWise resources](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/tag-resources.html) in the IoT SiteWise User Guide.
    public var tags: [Swift.String: Swift.String]?

    public init(
        gatewayName: Swift.String? = nil,
        gatewayPlatform: IoTSiteWiseClientTypes.GatewayPlatform? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.gatewayName = gatewayName
        self.gatewayPlatform = gatewayPlatform
        self.tags = tags
    }
}

public struct CreateGatewayOutput: Swift.Sendable {
    /// The [ARN](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the gateway, which has the following format. arn:${Partition}:iotsitewise:${Region}:${Account}:gateway/${GatewayId}
    /// This member is required.
    public var gatewayArn: Swift.String?
    /// The ID of the gateway device. You can use this ID when you call other IoT SiteWise API operations.
    /// This member is required.
    public var gatewayId: Swift.String?

    public init(
        gatewayArn: Swift.String? = nil,
        gatewayId: Swift.String? = nil
    )
    {
        self.gatewayArn = gatewayArn
        self.gatewayId = gatewayId
    }
}

extension IoTSiteWiseClientTypes {

    public enum ImageFileType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case png
        case sdkUnknown(Swift.String)

        public static var allCases: [ImageFileType] {
            return [
                .png
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .png: return "PNG"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTSiteWiseClientTypes {

    /// Contains an image file.
    public struct ImageFile: Swift.Sendable {
        /// The image file contents, represented as a base64-encoded string. The file size must be less than 1 MB.
        /// This member is required.
        public var data: Foundation.Data?
        /// The file type of the image.
        /// This member is required.
        public var type: IoTSiteWiseClientTypes.ImageFileType?

        public init(
            data: Foundation.Data? = nil,
            type: IoTSiteWiseClientTypes.ImageFileType? = nil
        )
        {
            self.data = data
            self.type = type
        }
    }
}

public struct CreatePortalInput: Swift.Sendable {
    /// Contains the configuration information of an alarm created in an IoT SiteWise Monitor portal. You can use the alarm to monitor an asset property and get notified when the asset property value is outside a specified range. For more information, see [Monitoring with alarms](https://docs.aws.amazon.com/iot-sitewise/latest/appguide/monitor-alarms.html) in the IoT SiteWise Application Guide.
    public var alarms: IoTSiteWiseClientTypes.Alarms?
    /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
    public var clientToken: Swift.String?
    /// The email address that sends alarm notifications. If you use the [IoT Events managed Lambda function](https://docs.aws.amazon.com/iotevents/latest/developerguide/lambda-support.html) to manage your emails, you must [verify the sender email address in Amazon SES](https://docs.aws.amazon.com/ses/latest/DeveloperGuide/verify-email-addresses.html).
    public var notificationSenderEmail: Swift.String?
    /// The service to use to authenticate users to the portal. Choose from the following options:
    ///
    /// * SSO – The portal uses IAM Identity Center to authenticate users and manage user permissions. Before you can create a portal that uses IAM Identity Center, you must enable IAM Identity Center. For more information, see [Enabling IAM Identity Center](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/monitor-get-started.html#mon-gs-sso) in the IoT SiteWise User Guide. This option is only available in Amazon Web Services Regions other than the China Regions.
    ///
    /// * IAM – The portal uses Identity and Access Management to authenticate users and manage user permissions.
    ///
    ///
    /// You can't change this value after you create a portal. Default: SSO
    public var portalAuthMode: IoTSiteWiseClientTypes.AuthMode?
    /// The Amazon Web Services administrator's contact email address.
    /// This member is required.
    public var portalContactEmail: Swift.String?
    /// A description for the portal.
    public var portalDescription: Swift.String?
    /// A logo image to display in the portal. Upload a square, high-resolution image. The image is displayed on a dark background.
    public var portalLogoImageFile: IoTSiteWiseClientTypes.ImageFile?
    /// A friendly name for the portal.
    /// This member is required.
    public var portalName: Swift.String?
    /// The [ARN](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of a service role that allows the portal's users to access your IoT SiteWise resources on your behalf. For more information, see [Using service roles for IoT SiteWise Monitor](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/monitor-service-role.html) in the IoT SiteWise User Guide.
    /// This member is required.
    public var roleArn: Swift.String?
    /// A list of key-value pairs that contain metadata for the portal. For more information, see [Tagging your IoT SiteWise resources](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/tag-resources.html) in the IoT SiteWise User Guide.
    public var tags: [Swift.String: Swift.String]?

    public init(
        alarms: IoTSiteWiseClientTypes.Alarms? = nil,
        clientToken: Swift.String? = nil,
        notificationSenderEmail: Swift.String? = nil,
        portalAuthMode: IoTSiteWiseClientTypes.AuthMode? = nil,
        portalContactEmail: Swift.String? = nil,
        portalDescription: Swift.String? = nil,
        portalLogoImageFile: IoTSiteWiseClientTypes.ImageFile? = nil,
        portalName: Swift.String? = nil,
        roleArn: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.alarms = alarms
        self.clientToken = clientToken
        self.notificationSenderEmail = notificationSenderEmail
        self.portalAuthMode = portalAuthMode
        self.portalContactEmail = portalContactEmail
        self.portalDescription = portalDescription
        self.portalLogoImageFile = portalLogoImageFile
        self.portalName = portalName
        self.roleArn = roleArn
        self.tags = tags
    }
}

extension IoTSiteWiseClientTypes {

    public enum MonitorErrorCode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case internalFailure
        case limitExceeded
        case validationError
        case sdkUnknown(Swift.String)

        public static var allCases: [MonitorErrorCode] {
            return [
                .internalFailure,
                .limitExceeded,
                .validationError
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .internalFailure: return "INTERNAL_FAILURE"
            case .limitExceeded: return "LIMIT_EXCEEDED"
            case .validationError: return "VALIDATION_ERROR"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTSiteWiseClientTypes {

    /// Contains IoT SiteWise Monitor error details.
    public struct MonitorErrorDetails: Swift.Sendable {
        /// The error code.
        public var code: IoTSiteWiseClientTypes.MonitorErrorCode?
        /// The error message.
        public var message: Swift.String?

        public init(
            code: IoTSiteWiseClientTypes.MonitorErrorCode? = nil,
            message: Swift.String? = nil
        )
        {
            self.code = code
            self.message = message
        }
    }
}

extension IoTSiteWiseClientTypes {

    public enum PortalState: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case creating
        case deleting
        case failed
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [PortalState] {
            return [
                .active,
                .creating,
                .deleting,
                .failed,
                .updating
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .creating: return "CREATING"
            case .deleting: return "DELETING"
            case .failed: return "FAILED"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTSiteWiseClientTypes {

    /// Contains information about the current status of a portal.
    public struct PortalStatus: Swift.Sendable {
        /// Contains associated error information, if any.
        public var error: IoTSiteWiseClientTypes.MonitorErrorDetails?
        /// The current state of the portal.
        /// This member is required.
        public var state: IoTSiteWiseClientTypes.PortalState?

        public init(
            error: IoTSiteWiseClientTypes.MonitorErrorDetails? = nil,
            state: IoTSiteWiseClientTypes.PortalState? = nil
        )
        {
            self.error = error
            self.state = state
        }
    }
}

public struct CreatePortalOutput: Swift.Sendable {
    /// The [ARN](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the portal, which has the following format. arn:${Partition}:iotsitewise:${Region}:${Account}:portal/${PortalId}
    /// This member is required.
    public var portalArn: Swift.String?
    /// The ID of the created portal.
    /// This member is required.
    public var portalId: Swift.String?
    /// The URL for the IoT SiteWise Monitor portal. You can use this URL to access portals that use IAM Identity Center for authentication. For portals that use IAM for authentication, you must use the IoT SiteWise console to get a URL that you can use to access the portal.
    /// This member is required.
    public var portalStartUrl: Swift.String?
    /// The status of the portal, which contains a state (CREATING after successfully calling this operation) and any error message.
    /// This member is required.
    public var portalStatus: IoTSiteWiseClientTypes.PortalStatus?
    /// The associated IAM Identity Center application ID, if the portal uses IAM Identity Center.
    /// This member is required.
    public var ssoApplicationId: Swift.String?

    public init(
        portalArn: Swift.String? = nil,
        portalId: Swift.String? = nil,
        portalStartUrl: Swift.String? = nil,
        portalStatus: IoTSiteWiseClientTypes.PortalStatus? = nil,
        ssoApplicationId: Swift.String? = nil
    )
    {
        self.portalArn = portalArn
        self.portalId = portalId
        self.portalStartUrl = portalStartUrl
        self.portalStatus = portalStatus
        self.ssoApplicationId = ssoApplicationId
    }
}

public struct CreateProjectInput: Swift.Sendable {
    /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
    public var clientToken: Swift.String?
    /// The ID of the portal in which to create the project.
    /// This member is required.
    public var portalId: Swift.String?
    /// A description for the project.
    public var projectDescription: Swift.String?
    /// A friendly name for the project.
    /// This member is required.
    public var projectName: Swift.String?
    /// A list of key-value pairs that contain metadata for the project. For more information, see [Tagging your IoT SiteWise resources](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/tag-resources.html) in the IoT SiteWise User Guide.
    public var tags: [Swift.String: Swift.String]?

    public init(
        clientToken: Swift.String? = nil,
        portalId: Swift.String? = nil,
        projectDescription: Swift.String? = nil,
        projectName: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.clientToken = clientToken
        self.portalId = portalId
        self.projectDescription = projectDescription
        self.projectName = projectName
        self.tags = tags
    }
}

public struct CreateProjectOutput: Swift.Sendable {
    /// The [ARN](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the project, which has the following format. arn:${Partition}:iotsitewise:${Region}:${Account}:project/${ProjectId}
    /// This member is required.
    public var projectArn: Swift.String?
    /// The ID of the project.
    /// This member is required.
    public var projectId: Swift.String?

    public init(
        projectArn: Swift.String? = nil,
        projectId: Swift.String? = nil
    )
    {
        self.projectArn = projectArn
        self.projectId = projectId
    }
}

public struct DeleteAccessPolicyInput: Swift.Sendable {
    /// The ID of the access policy to be deleted.
    /// This member is required.
    public var accessPolicyId: Swift.String?
    /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
    public var clientToken: Swift.String?

    public init(
        accessPolicyId: Swift.String? = nil,
        clientToken: Swift.String? = nil
    )
    {
        self.accessPolicyId = accessPolicyId
        self.clientToken = clientToken
    }
}

public struct DeleteAccessPolicyOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteAssetInput: Swift.Sendable {
    /// The ID of the asset to delete. This can be either the actual ID in UUID format, or else externalId: followed by the external ID, if it has one. For more information, see [Referencing objects with external IDs](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/object-ids.html#external-id-references) in the IoT SiteWise User Guide.
    /// This member is required.
    public var assetId: Swift.String?
    /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
    public var clientToken: Swift.String?

    public init(
        assetId: Swift.String? = nil,
        clientToken: Swift.String? = nil
    )
    {
        self.assetId = assetId
        self.clientToken = clientToken
    }
}

public struct DeleteAssetOutput: Swift.Sendable {
    /// The status of the asset, which contains a state (DELETING after successfully calling this operation) and any error message.
    /// This member is required.
    public var assetStatus: IoTSiteWiseClientTypes.AssetStatus?

    public init(
        assetStatus: IoTSiteWiseClientTypes.AssetStatus? = nil
    )
    {
        self.assetStatus = assetStatus
    }
}

public struct DeleteAssetModelInput: Swift.Sendable {
    /// The ID of the asset model to delete. This can be either the actual ID in UUID format, or else externalId: followed by the external ID, if it has one. For more information, see [Referencing objects with external IDs](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/object-ids.html#external-id-references) in the IoT SiteWise User Guide.
    /// This member is required.
    public var assetModelId: Swift.String?
    /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
    public var clientToken: Swift.String?
    /// The expected current entity tag (ETag) for the asset model’s latest or active version (specified using matchForVersionType). The delete request is rejected if the tag does not match the latest or active version's current entity tag. See [Optimistic locking for asset model writes](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/opt-locking-for-model.html) in the IoT SiteWise User Guide.
    public var ifMatch: Swift.String?
    /// Accepts * to reject the delete request if an active version (specified using matchForVersionType as ACTIVE) already exists for the asset model.
    public var ifNoneMatch: Swift.String?
    /// Specifies the asset model version type (LATEST or ACTIVE) used in conjunction with If-Match or If-None-Match headers to determine the target ETag for the delete operation.
    public var matchForVersionType: IoTSiteWiseClientTypes.AssetModelVersionType?

    public init(
        assetModelId: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        ifMatch: Swift.String? = nil,
        ifNoneMatch: Swift.String? = nil,
        matchForVersionType: IoTSiteWiseClientTypes.AssetModelVersionType? = nil
    )
    {
        self.assetModelId = assetModelId
        self.clientToken = clientToken
        self.ifMatch = ifMatch
        self.ifNoneMatch = ifNoneMatch
        self.matchForVersionType = matchForVersionType
    }
}

public struct DeleteAssetModelOutput: Swift.Sendable {
    /// The status of the asset model, which contains a state (DELETING after successfully calling this operation) and any error message.
    /// This member is required.
    public var assetModelStatus: IoTSiteWiseClientTypes.AssetModelStatus?

    public init(
        assetModelStatus: IoTSiteWiseClientTypes.AssetModelStatus? = nil
    )
    {
        self.assetModelStatus = assetModelStatus
    }
}

public struct DeleteAssetModelCompositeModelInput: Swift.Sendable {
    /// The ID of a composite model on this asset model.
    /// This member is required.
    public var assetModelCompositeModelId: Swift.String?
    /// The ID of the asset model, in UUID format.
    /// This member is required.
    public var assetModelId: Swift.String?
    /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
    public var clientToken: Swift.String?
    /// The expected current entity tag (ETag) for the asset model’s latest or active version (specified using matchForVersionType). The delete request is rejected if the tag does not match the latest or active version's current entity tag. See [Optimistic locking for asset model writes](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/opt-locking-for-model.html) in the IoT SiteWise User Guide.
    public var ifMatch: Swift.String?
    /// Accepts * to reject the delete request if an active version (specified using matchForVersionType as ACTIVE) already exists for the asset model.
    public var ifNoneMatch: Swift.String?
    /// Specifies the asset model version type (LATEST or ACTIVE) used in conjunction with If-Match or If-None-Match headers to determine the target ETag for the delete operation.
    public var matchForVersionType: IoTSiteWiseClientTypes.AssetModelVersionType?

    public init(
        assetModelCompositeModelId: Swift.String? = nil,
        assetModelId: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        ifMatch: Swift.String? = nil,
        ifNoneMatch: Swift.String? = nil,
        matchForVersionType: IoTSiteWiseClientTypes.AssetModelVersionType? = nil
    )
    {
        self.assetModelCompositeModelId = assetModelCompositeModelId
        self.assetModelId = assetModelId
        self.clientToken = clientToken
        self.ifMatch = ifMatch
        self.ifNoneMatch = ifNoneMatch
        self.matchForVersionType = matchForVersionType
    }
}

public struct DeleteAssetModelCompositeModelOutput: Swift.Sendable {
    /// Contains current status information for an asset model. For more information, see [Asset and model states](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/asset-and-model-states.html) in the IoT SiteWise User Guide.
    /// This member is required.
    public var assetModelStatus: IoTSiteWiseClientTypes.AssetModelStatus?

    public init(
        assetModelStatus: IoTSiteWiseClientTypes.AssetModelStatus? = nil
    )
    {
        self.assetModelStatus = assetModelStatus
    }
}

public struct DeleteDashboardInput: Swift.Sendable {
    /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
    public var clientToken: Swift.String?
    /// The ID of the dashboard to delete.
    /// This member is required.
    public var dashboardId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        dashboardId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.dashboardId = dashboardId
    }
}

public struct DeleteDashboardOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteGatewayInput: Swift.Sendable {
    /// The ID of the gateway to delete.
    /// This member is required.
    public var gatewayId: Swift.String?

    public init(
        gatewayId: Swift.String? = nil
    )
    {
        self.gatewayId = gatewayId
    }
}

public struct DeletePortalInput: Swift.Sendable {
    /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
    public var clientToken: Swift.String?
    /// The ID of the portal to delete.
    /// This member is required.
    public var portalId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        portalId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.portalId = portalId
    }
}

public struct DeletePortalOutput: Swift.Sendable {
    /// The status of the portal, which contains a state (DELETING after successfully calling this operation) and any error message.
    /// This member is required.
    public var portalStatus: IoTSiteWiseClientTypes.PortalStatus?

    public init(
        portalStatus: IoTSiteWiseClientTypes.PortalStatus? = nil
    )
    {
        self.portalStatus = portalStatus
    }
}

public struct DeleteProjectInput: Swift.Sendable {
    /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
    public var clientToken: Swift.String?
    /// The ID of the project.
    /// This member is required.
    public var projectId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        projectId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.projectId = projectId
    }
}

public struct DeleteProjectOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteTimeSeriesInput: Swift.Sendable {
    /// The alias that identifies the time series.
    public var alias: Swift.String?
    /// The ID of the asset in which the asset property was created. This can be either the actual ID in UUID format, or else externalId: followed by the external ID, if it has one. For more information, see [Referencing objects with external IDs](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/object-ids.html#external-id-references) in the IoT SiteWise User Guide.
    public var assetId: Swift.String?
    /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
    public var clientToken: Swift.String?
    /// The ID of the asset property. This can be either the actual ID in UUID format, or else externalId: followed by the external ID, if it has one. For more information, see [Referencing objects with external IDs](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/object-ids.html#external-id-references) in the IoT SiteWise User Guide.
    public var propertyId: Swift.String?

    public init(
        alias: Swift.String? = nil,
        assetId: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        propertyId: Swift.String? = nil
    )
    {
        self.alias = alias
        self.assetId = assetId
        self.clientToken = clientToken
        self.propertyId = propertyId
    }
}

public struct DescribeAccessPolicyInput: Swift.Sendable {
    /// The ID of the access policy.
    /// This member is required.
    public var accessPolicyId: Swift.String?

    public init(
        accessPolicyId: Swift.String? = nil
    )
    {
        self.accessPolicyId = accessPolicyId
    }
}

public struct DescribeAccessPolicyOutput: Swift.Sendable {
    /// The [ARN](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the access policy, which has the following format. arn:${Partition}:iotsitewise:${Region}:${Account}:access-policy/${AccessPolicyId}
    /// This member is required.
    public var accessPolicyArn: Swift.String?
    /// The date the access policy was created, in Unix epoch time.
    /// This member is required.
    public var accessPolicyCreationDate: Foundation.Date?
    /// The ID of the access policy.
    /// This member is required.
    public var accessPolicyId: Swift.String?
    /// The identity (IAM Identity Center user, IAM Identity Center group, or IAM user) to which this access policy applies.
    /// This member is required.
    public var accessPolicyIdentity: IoTSiteWiseClientTypes.Identity?
    /// The date the access policy was last updated, in Unix epoch time.
    /// This member is required.
    public var accessPolicyLastUpdateDate: Foundation.Date?
    /// The access policy permission. Note that a project ADMINISTRATOR is also known as a project owner.
    /// This member is required.
    public var accessPolicyPermission: IoTSiteWiseClientTypes.Permission?
    /// The IoT SiteWise Monitor resource (portal or project) to which this access policy provides access.
    /// This member is required.
    public var accessPolicyResource: IoTSiteWiseClientTypes.Resource?

    public init(
        accessPolicyArn: Swift.String? = nil,
        accessPolicyCreationDate: Foundation.Date? = nil,
        accessPolicyId: Swift.String? = nil,
        accessPolicyIdentity: IoTSiteWiseClientTypes.Identity? = nil,
        accessPolicyLastUpdateDate: Foundation.Date? = nil,
        accessPolicyPermission: IoTSiteWiseClientTypes.Permission? = nil,
        accessPolicyResource: IoTSiteWiseClientTypes.Resource? = nil
    )
    {
        self.accessPolicyArn = accessPolicyArn
        self.accessPolicyCreationDate = accessPolicyCreationDate
        self.accessPolicyId = accessPolicyId
        self.accessPolicyIdentity = accessPolicyIdentity
        self.accessPolicyLastUpdateDate = accessPolicyLastUpdateDate
        self.accessPolicyPermission = accessPolicyPermission
        self.accessPolicyResource = accessPolicyResource
    }
}

public struct DescribeActionInput: Swift.Sendable {
    /// The ID of the action.
    /// This member is required.
    public var actionId: Swift.String?

    public init(
        actionId: Swift.String? = nil
    )
    {
        self.actionId = actionId
    }
}

public struct DescribeActionOutput: Swift.Sendable {
    /// The ID of the action definition.
    /// This member is required.
    public var actionDefinitionId: Swift.String?
    /// The ID of the action.
    /// This member is required.
    public var actionId: Swift.String?
    /// The JSON payload of the action.
    /// This member is required.
    public var actionPayload: IoTSiteWiseClientTypes.ActionPayload?
    /// The time the action was executed.
    /// This member is required.
    public var executionTime: Foundation.Date?
    /// The resource the action will be taken on.
    /// This member is required.
    public var targetResource: IoTSiteWiseClientTypes.TargetResource?

    public init(
        actionDefinitionId: Swift.String? = nil,
        actionId: Swift.String? = nil,
        actionPayload: IoTSiteWiseClientTypes.ActionPayload? = nil,
        executionTime: Foundation.Date? = nil,
        targetResource: IoTSiteWiseClientTypes.TargetResource? = nil
    )
    {
        self.actionDefinitionId = actionDefinitionId
        self.actionId = actionId
        self.actionPayload = actionPayload
        self.executionTime = executionTime
        self.targetResource = targetResource
    }
}

public struct DescribeAssetInput: Swift.Sendable {
    /// The ID of the asset. This can be either the actual ID in UUID format, or else externalId: followed by the external ID, if it has one. For more information, see [Referencing objects with external IDs](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/object-ids.html#external-id-references) in the IoT SiteWise User Guide.
    /// This member is required.
    public var assetId: Swift.String?
    /// Whether or not to exclude asset properties from the response.
    public var excludeProperties: Swift.Bool?

    public init(
        assetId: Swift.String? = nil,
        excludeProperties: Swift.Bool? = false
    )
    {
        self.assetId = assetId
        self.excludeProperties = excludeProperties
    }
}

public struct DescribeAssetOutput: Swift.Sendable {
    /// The [ARN](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the asset, which has the following format. arn:${Partition}:iotsitewise:${Region}:${Account}:asset/${AssetId}
    /// This member is required.
    public var assetArn: Swift.String?
    /// The list of the immediate child custom composite model summaries for the asset.
    public var assetCompositeModelSummaries: [IoTSiteWiseClientTypes.AssetCompositeModelSummary]?
    /// The composite models for the asset.
    public var assetCompositeModels: [IoTSiteWiseClientTypes.AssetCompositeModel]?
    /// The date the asset was created, in Unix epoch time.
    /// This member is required.
    public var assetCreationDate: Foundation.Date?
    /// A description for the asset.
    public var assetDescription: Swift.String?
    /// The external ID of the asset, if any.
    public var assetExternalId: Swift.String?
    /// A list of asset hierarchies that each contain a hierarchyId. A hierarchy specifies allowed parent/child asset relationships.
    /// This member is required.
    public var assetHierarchies: [IoTSiteWiseClientTypes.AssetHierarchy]?
    /// The ID of the asset, in UUID format.
    /// This member is required.
    public var assetId: Swift.String?
    /// The date the asset was last updated, in Unix epoch time.
    /// This member is required.
    public var assetLastUpdateDate: Foundation.Date?
    /// The ID of the asset model that was used to create the asset.
    /// This member is required.
    public var assetModelId: Swift.String?
    /// The name of the asset.
    /// This member is required.
    public var assetName: Swift.String?
    /// The list of asset properties for the asset. This object doesn't include properties that you define in composite models. You can find composite model properties in the assetCompositeModels object.
    /// This member is required.
    public var assetProperties: [IoTSiteWiseClientTypes.AssetProperty]?
    /// The current status of the asset, which contains a state and any error message.
    /// This member is required.
    public var assetStatus: IoTSiteWiseClientTypes.AssetStatus?

    public init(
        assetArn: Swift.String? = nil,
        assetCompositeModelSummaries: [IoTSiteWiseClientTypes.AssetCompositeModelSummary]? = nil,
        assetCompositeModels: [IoTSiteWiseClientTypes.AssetCompositeModel]? = nil,
        assetCreationDate: Foundation.Date? = nil,
        assetDescription: Swift.String? = nil,
        assetExternalId: Swift.String? = nil,
        assetHierarchies: [IoTSiteWiseClientTypes.AssetHierarchy]? = nil,
        assetId: Swift.String? = nil,
        assetLastUpdateDate: Foundation.Date? = nil,
        assetModelId: Swift.String? = nil,
        assetName: Swift.String? = nil,
        assetProperties: [IoTSiteWiseClientTypes.AssetProperty]? = nil,
        assetStatus: IoTSiteWiseClientTypes.AssetStatus? = nil
    )
    {
        self.assetArn = assetArn
        self.assetCompositeModelSummaries = assetCompositeModelSummaries
        self.assetCompositeModels = assetCompositeModels
        self.assetCreationDate = assetCreationDate
        self.assetDescription = assetDescription
        self.assetExternalId = assetExternalId
        self.assetHierarchies = assetHierarchies
        self.assetId = assetId
        self.assetLastUpdateDate = assetLastUpdateDate
        self.assetModelId = assetModelId
        self.assetName = assetName
        self.assetProperties = assetProperties
        self.assetStatus = assetStatus
    }
}

public struct DescribeAssetCompositeModelInput: Swift.Sendable {
    /// The ID of a composite model on this asset. This can be either the actual ID in UUID format, or else externalId: followed by the external ID, if it has one. For more information, see [Referencing objects with external IDs](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/object-ids.html#external-id-references) in the IoT SiteWise User Guide.
    /// This member is required.
    public var assetCompositeModelId: Swift.String?
    /// The ID of the asset. This can be either the actual ID in UUID format, or else externalId: followed by the external ID, if it has one. For more information, see [Referencing objects with external IDs](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/object-ids.html#external-id-references) in the IoT SiteWise User Guide.
    /// This member is required.
    public var assetId: Swift.String?

    public init(
        assetCompositeModelId: Swift.String? = nil,
        assetId: Swift.String? = nil
    )
    {
        self.assetCompositeModelId = assetCompositeModelId
        self.assetId = assetId
    }
}

public struct DescribeAssetCompositeModelOutput: Swift.Sendable {
    /// The available actions for a composite model on this asset.
    public var actionDefinitions: [IoTSiteWiseClientTypes.ActionDefinition]?
    /// A description for the composite model.
    /// This member is required.
    public var assetCompositeModelDescription: Swift.String?
    /// An external ID to assign to the asset model. If the composite model is a component-based composite model, or one nested inside a component model, you can only set the external ID using UpdateAssetModelCompositeModel and specifying the derived ID of the model or property from the created model it's a part of.
    public var assetCompositeModelExternalId: Swift.String?
    /// The ID of a composite model on this asset.
    /// This member is required.
    public var assetCompositeModelId: Swift.String?
    /// The unique, friendly name for the composite model.
    /// This member is required.
    public var assetCompositeModelName: Swift.String?
    /// The path to the composite model listing the parent composite models.
    /// This member is required.
    public var assetCompositeModelPath: [IoTSiteWiseClientTypes.AssetCompositeModelPathSegment]?
    /// The property definitions of the composite model that was used to create the asset.
    /// This member is required.
    public var assetCompositeModelProperties: [IoTSiteWiseClientTypes.AssetProperty]?
    /// The list of composite model summaries.
    /// This member is required.
    public var assetCompositeModelSummaries: [IoTSiteWiseClientTypes.AssetCompositeModelSummary]?
    /// The composite model type. Valid values are AWS/ALARM, CUSTOM, or  AWS/L4E_ANOMALY.
    /// This member is required.
    public var assetCompositeModelType: Swift.String?
    /// The ID of the asset, in UUID format. This ID uniquely identifies the asset within IoT SiteWise and can be used with other IoT SiteWise APIs.
    /// This member is required.
    public var assetId: Swift.String?

    public init(
        actionDefinitions: [IoTSiteWiseClientTypes.ActionDefinition]? = nil,
        assetCompositeModelDescription: Swift.String? = nil,
        assetCompositeModelExternalId: Swift.String? = nil,
        assetCompositeModelId: Swift.String? = nil,
        assetCompositeModelName: Swift.String? = nil,
        assetCompositeModelPath: [IoTSiteWiseClientTypes.AssetCompositeModelPathSegment]? = nil,
        assetCompositeModelProperties: [IoTSiteWiseClientTypes.AssetProperty]? = nil,
        assetCompositeModelSummaries: [IoTSiteWiseClientTypes.AssetCompositeModelSummary]? = nil,
        assetCompositeModelType: Swift.String? = nil,
        assetId: Swift.String? = nil
    )
    {
        self.actionDefinitions = actionDefinitions
        self.assetCompositeModelDescription = assetCompositeModelDescription
        self.assetCompositeModelExternalId = assetCompositeModelExternalId
        self.assetCompositeModelId = assetCompositeModelId
        self.assetCompositeModelName = assetCompositeModelName
        self.assetCompositeModelPath = assetCompositeModelPath
        self.assetCompositeModelProperties = assetCompositeModelProperties
        self.assetCompositeModelSummaries = assetCompositeModelSummaries
        self.assetCompositeModelType = assetCompositeModelType
        self.assetId = assetId
    }
}

public struct DescribeAssetModelInput: Swift.Sendable {
    /// The ID of the asset model. This can be either the actual ID in UUID format, or else externalId: followed by the external ID, if it has one. For more information, see [Referencing objects with external IDs](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/object-ids.html#external-id-references) in the IoT SiteWise User Guide.
    /// This member is required.
    public var assetModelId: Swift.String?
    /// The version alias that specifies the latest or active version of the asset model. The details are returned in the response. The default value is LATEST. See [ Asset model versions](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/model-active-version.html) in the IoT SiteWise User Guide.
    public var assetModelVersion: Swift.String?
    /// Whether or not to exclude asset model properties from the response.
    public var excludeProperties: Swift.Bool?

    public init(
        assetModelId: Swift.String? = nil,
        assetModelVersion: Swift.String? = nil,
        excludeProperties: Swift.Bool? = false
    )
    {
        self.assetModelId = assetModelId
        self.assetModelVersion = assetModelVersion
        self.excludeProperties = excludeProperties
    }
}

public struct DescribeAssetModelOutput: Swift.Sendable {
    /// The [ARN](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the asset model, which has the following format. arn:${Partition}:iotsitewise:${Region}:${Account}:asset-model/${AssetModelId}
    /// This member is required.
    public var assetModelArn: Swift.String?
    /// The list of the immediate child custom composite model summaries for the asset model.
    public var assetModelCompositeModelSummaries: [IoTSiteWiseClientTypes.AssetModelCompositeModelSummary]?
    /// The list of built-in composite models for the asset model, such as those with those of type AWS/ALARMS.
    public var assetModelCompositeModels: [IoTSiteWiseClientTypes.AssetModelCompositeModel]?
    /// The date the asset model was created, in Unix epoch time.
    /// This member is required.
    public var assetModelCreationDate: Foundation.Date?
    /// The asset model's description.
    /// This member is required.
    public var assetModelDescription: Swift.String?
    /// The external ID of the asset model, if any.
    public var assetModelExternalId: Swift.String?
    /// A list of asset model hierarchies that each contain a childAssetModelId and a hierarchyId (named id). A hierarchy specifies allowed parent/child asset relationships for an asset model.
    /// This member is required.
    public var assetModelHierarchies: [IoTSiteWiseClientTypes.AssetModelHierarchy]?
    /// The ID of the asset model, in UUID format.
    /// This member is required.
    public var assetModelId: Swift.String?
    /// The date the asset model was last updated, in Unix epoch time.
    /// This member is required.
    public var assetModelLastUpdateDate: Foundation.Date?
    /// The name of the asset model.
    /// This member is required.
    public var assetModelName: Swift.String?
    /// The list of asset properties for the asset model. This object doesn't include properties that you define in composite models. You can find composite model properties in the assetModelCompositeModels object.
    /// This member is required.
    public var assetModelProperties: [IoTSiteWiseClientTypes.AssetModelProperty]?
    /// The current status of the asset model, which contains a state and any error message.
    /// This member is required.
    public var assetModelStatus: IoTSiteWiseClientTypes.AssetModelStatus?
    /// The type of asset model.
    ///
    /// * ASSET_MODEL – (default) An asset model that you can use to create assets. Can't be included as a component in another asset model.
    ///
    /// * COMPONENT_MODEL – A reusable component that you can include in the composite models of other asset models. You can't create assets directly from this type of asset model.
    public var assetModelType: IoTSiteWiseClientTypes.AssetModelType?
    /// The version of the asset model. See [ Asset model versions](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/model-active-version.html) in the IoT SiteWise User Guide.
    public var assetModelVersion: Swift.String?
    /// The entity tag (ETag) is a hash of the retrieved version of the asset model. It's used to make concurrent updates safely to the resource. See [Optimistic locking for asset model writes](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/opt-locking-for-model.html) in the IoT SiteWise User Guide. See [ Optimistic locking for asset model writes](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/opt-locking-for-model.html) in the IoT SiteWise User Guide.
    public var eTag: Swift.String?

    public init(
        assetModelArn: Swift.String? = nil,
        assetModelCompositeModelSummaries: [IoTSiteWiseClientTypes.AssetModelCompositeModelSummary]? = nil,
        assetModelCompositeModels: [IoTSiteWiseClientTypes.AssetModelCompositeModel]? = nil,
        assetModelCreationDate: Foundation.Date? = nil,
        assetModelDescription: Swift.String? = nil,
        assetModelExternalId: Swift.String? = nil,
        assetModelHierarchies: [IoTSiteWiseClientTypes.AssetModelHierarchy]? = nil,
        assetModelId: Swift.String? = nil,
        assetModelLastUpdateDate: Foundation.Date? = nil,
        assetModelName: Swift.String? = nil,
        assetModelProperties: [IoTSiteWiseClientTypes.AssetModelProperty]? = nil,
        assetModelStatus: IoTSiteWiseClientTypes.AssetModelStatus? = nil,
        assetModelType: IoTSiteWiseClientTypes.AssetModelType? = nil,
        assetModelVersion: Swift.String? = nil,
        eTag: Swift.String? = nil
    )
    {
        self.assetModelArn = assetModelArn
        self.assetModelCompositeModelSummaries = assetModelCompositeModelSummaries
        self.assetModelCompositeModels = assetModelCompositeModels
        self.assetModelCreationDate = assetModelCreationDate
        self.assetModelDescription = assetModelDescription
        self.assetModelExternalId = assetModelExternalId
        self.assetModelHierarchies = assetModelHierarchies
        self.assetModelId = assetModelId
        self.assetModelLastUpdateDate = assetModelLastUpdateDate
        self.assetModelName = assetModelName
        self.assetModelProperties = assetModelProperties
        self.assetModelStatus = assetModelStatus
        self.assetModelType = assetModelType
        self.assetModelVersion = assetModelVersion
        self.eTag = eTag
    }
}

public struct DescribeAssetModelCompositeModelInput: Swift.Sendable {
    /// The ID of a composite model on this asset model. This can be either the actual ID in UUID format, or else externalId: followed by the external ID, if it has one. For more information, see [Referencing objects with external IDs](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/object-ids.html#external-id-references) in the IoT SiteWise User Guide.
    /// This member is required.
    public var assetModelCompositeModelId: Swift.String?
    /// The ID of the asset model. This can be either the actual ID in UUID format, or else externalId: followed by the external ID, if it has one. For more information, see [Referencing objects with external IDs](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/object-ids.html#external-id-references) in the IoT SiteWise User Guide.
    /// This member is required.
    public var assetModelId: Swift.String?
    /// The version alias that specifies the latest or active version of the asset model. The details are returned in the response. The default value is LATEST. See [ Asset model versions](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/model-active-version.html) in the IoT SiteWise User Guide.
    public var assetModelVersion: Swift.String?

    public init(
        assetModelCompositeModelId: Swift.String? = nil,
        assetModelId: Swift.String? = nil,
        assetModelVersion: Swift.String? = nil
    )
    {
        self.assetModelCompositeModelId = assetModelCompositeModelId
        self.assetModelId = assetModelId
        self.assetModelVersion = assetModelVersion
    }
}

extension IoTSiteWiseClientTypes {

    /// Represents a composite model that composed an asset model of type COMPONENT_MODEL.
    public struct CompositionRelationshipItem: Swift.Sendable {
        /// The ID of the component.
        public var id: Swift.String?

        public init(
            id: Swift.String? = nil
        )
        {
            self.id = id
        }
    }
}

extension IoTSiteWiseClientTypes {

    /// Metadata for the composition relationship established by using composedAssetModelId in [CreateAssetModelCompositeModel](https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_CreateAssetModelCompositeModel.html).
    public struct CompositionDetails: Swift.Sendable {
        /// An array detailing the composition relationship for this composite model.
        public var compositionRelationship: [IoTSiteWiseClientTypes.CompositionRelationshipItem]?

        public init(
            compositionRelationship: [IoTSiteWiseClientTypes.CompositionRelationshipItem]? = nil
        )
        {
            self.compositionRelationship = compositionRelationship
        }
    }
}

public struct DescribeAssetModelCompositeModelOutput: Swift.Sendable {
    /// The available actions for a composite model on this asset model.
    public var actionDefinitions: [IoTSiteWiseClientTypes.ActionDefinition]?
    /// The description for the composite model.
    /// This member is required.
    public var assetModelCompositeModelDescription: Swift.String?
    /// The external ID of a composite model on this asset model.
    public var assetModelCompositeModelExternalId: Swift.String?
    /// The ID of a composite model on this asset model.
    /// This member is required.
    public var assetModelCompositeModelId: Swift.String?
    /// The unique, friendly name for the composite model.
    /// This member is required.
    public var assetModelCompositeModelName: Swift.String?
    /// The path to the composite model listing the parent composite models.
    /// This member is required.
    public var assetModelCompositeModelPath: [IoTSiteWiseClientTypes.AssetModelCompositeModelPathSegment]?
    /// The property definitions of the composite model.
    /// This member is required.
    public var assetModelCompositeModelProperties: [IoTSiteWiseClientTypes.AssetModelProperty]?
    /// The list of composite model summaries for the composite model.
    /// This member is required.
    public var assetModelCompositeModelSummaries: [IoTSiteWiseClientTypes.AssetModelCompositeModelSummary]?
    /// The composite model type. Valid values are AWS/ALARM, CUSTOM, or  AWS/L4E_ANOMALY.
    /// This member is required.
    public var assetModelCompositeModelType: Swift.String?
    /// The ID of the asset model, in UUID format.
    /// This member is required.
    public var assetModelId: Swift.String?
    /// Metadata for the composition relationship established by using composedAssetModelId in [CreateAssetModelCompositeModel](https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_CreateAssetModelCompositeModel.html). For instance, an array detailing the path of the composition relationship for this composite model.
    public var compositionDetails: IoTSiteWiseClientTypes.CompositionDetails?

    public init(
        actionDefinitions: [IoTSiteWiseClientTypes.ActionDefinition]? = nil,
        assetModelCompositeModelDescription: Swift.String? = nil,
        assetModelCompositeModelExternalId: Swift.String? = nil,
        assetModelCompositeModelId: Swift.String? = nil,
        assetModelCompositeModelName: Swift.String? = nil,
        assetModelCompositeModelPath: [IoTSiteWiseClientTypes.AssetModelCompositeModelPathSegment]? = nil,
        assetModelCompositeModelProperties: [IoTSiteWiseClientTypes.AssetModelProperty]? = nil,
        assetModelCompositeModelSummaries: [IoTSiteWiseClientTypes.AssetModelCompositeModelSummary]? = nil,
        assetModelCompositeModelType: Swift.String? = nil,
        assetModelId: Swift.String? = nil,
        compositionDetails: IoTSiteWiseClientTypes.CompositionDetails? = nil
    )
    {
        self.actionDefinitions = actionDefinitions
        self.assetModelCompositeModelDescription = assetModelCompositeModelDescription
        self.assetModelCompositeModelExternalId = assetModelCompositeModelExternalId
        self.assetModelCompositeModelId = assetModelCompositeModelId
        self.assetModelCompositeModelName = assetModelCompositeModelName
        self.assetModelCompositeModelPath = assetModelCompositeModelPath
        self.assetModelCompositeModelProperties = assetModelCompositeModelProperties
        self.assetModelCompositeModelSummaries = assetModelCompositeModelSummaries
        self.assetModelCompositeModelType = assetModelCompositeModelType
        self.assetModelId = assetModelId
        self.compositionDetails = compositionDetails
    }
}

public struct DescribeAssetPropertyInput: Swift.Sendable {
    /// The ID of the asset. This can be either the actual ID in UUID format, or else externalId: followed by the external ID, if it has one. For more information, see [Referencing objects with external IDs](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/object-ids.html#external-id-references) in the IoT SiteWise User Guide.
    /// This member is required.
    public var assetId: Swift.String?
    /// The ID of the asset property. This can be either the actual ID in UUID format, or else externalId: followed by the external ID, if it has one. For more information, see [Referencing objects with external IDs](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/object-ids.html#external-id-references) in the IoT SiteWise User Guide.
    /// This member is required.
    public var propertyId: Swift.String?

    public init(
        assetId: Swift.String? = nil,
        propertyId: Swift.String? = nil
    )
    {
        self.assetId = assetId
        self.propertyId = propertyId
    }
}

extension IoTSiteWiseClientTypes {

    /// Contains asset property information.
    public struct Property: Swift.Sendable {
        /// The alias that identifies the property, such as an OPC-UA server data stream path (for example, /company/windfarm/3/turbine/7/temperature). For more information, see [Mapping industrial data streams to asset properties](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/connect-data-streams.html) in the IoT SiteWise User Guide.
        public var alias: Swift.String?
        /// The property data type.
        /// This member is required.
        public var dataType: IoTSiteWiseClientTypes.PropertyDataType?
        /// The external ID of the asset property. For more information, see [Using external IDs](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/object-ids.html#external-ids) in the IoT SiteWise User Guide.
        public var externalId: Swift.String?
        /// The ID of the asset property.
        /// This member is required.
        public var id: Swift.String?
        /// The name of the property.
        /// This member is required.
        public var name: Swift.String?
        /// The asset property's notification topic and state. For more information, see [UpdateAssetProperty](https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_UpdateAssetProperty.html).
        public var notification: IoTSiteWiseClientTypes.PropertyNotification?
        /// The structured path to the property from the root of the asset.
        public var path: [IoTSiteWiseClientTypes.AssetPropertyPathSegment]?
        /// The property type (see PropertyType). A property contains one type.
        public var type: IoTSiteWiseClientTypes.PropertyType?
        /// The unit (such as Newtons or RPM) of the asset property.
        public var unit: Swift.String?

        public init(
            alias: Swift.String? = nil,
            dataType: IoTSiteWiseClientTypes.PropertyDataType? = nil,
            externalId: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            notification: IoTSiteWiseClientTypes.PropertyNotification? = nil,
            path: [IoTSiteWiseClientTypes.AssetPropertyPathSegment]? = nil,
            type: IoTSiteWiseClientTypes.PropertyType? = nil,
            unit: Swift.String? = nil
        )
        {
            self.alias = alias
            self.dataType = dataType
            self.externalId = externalId
            self.id = id
            self.name = name
            self.notification = notification
            self.path = path
            self.type = type
            self.unit = unit
        }
    }
}

extension IoTSiteWiseClientTypes {

    /// Contains information about a composite model property on an asset.
    public struct CompositeModelProperty: Swift.Sendable {
        /// Contains asset property information.
        /// This member is required.
        public var assetProperty: IoTSiteWiseClientTypes.Property?
        /// The external ID of the composite model that contains the property. For more information, see [Using external IDs](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/object-ids.html#external-ids) in the IoT SiteWise User Guide.
        public var externalId: Swift.String?
        /// The ID of the composite model that contains the property.
        public var id: Swift.String?
        /// The name of the property.
        /// This member is required.
        public var name: Swift.String?
        /// The type of the composite model that defines this property.
        /// This member is required.
        public var type: Swift.String?

        public init(
            assetProperty: IoTSiteWiseClientTypes.Property? = nil,
            externalId: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            type: Swift.String? = nil
        )
        {
            self.assetProperty = assetProperty
            self.externalId = externalId
            self.id = id
            self.name = name
            self.type = type
        }
    }
}

public struct DescribeAssetPropertyOutput: Swift.Sendable {
    /// The external ID of the asset. For more information, see [Using external IDs](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/object-ids.html#external-ids) in the IoT SiteWise User Guide.
    public var assetExternalId: Swift.String?
    /// The ID of the asset, in UUID format.
    /// This member is required.
    public var assetId: Swift.String?
    /// The ID of the asset model, in UUID format.
    /// This member is required.
    public var assetModelId: Swift.String?
    /// The name of the asset.
    /// This member is required.
    public var assetName: Swift.String?
    /// The asset property's definition, alias, and notification state. This response includes this object for normal asset properties. If you describe an asset property in a composite model, this response includes the asset property information in compositeModel.
    public var assetProperty: IoTSiteWiseClientTypes.Property?
    /// The composite model that declares this asset property, if this asset property exists in a composite model.
    public var compositeModel: IoTSiteWiseClientTypes.CompositeModelProperty?

    public init(
        assetExternalId: Swift.String? = nil,
        assetId: Swift.String? = nil,
        assetModelId: Swift.String? = nil,
        assetName: Swift.String? = nil,
        assetProperty: IoTSiteWiseClientTypes.Property? = nil,
        compositeModel: IoTSiteWiseClientTypes.CompositeModelProperty? = nil
    )
    {
        self.assetExternalId = assetExternalId
        self.assetId = assetId
        self.assetModelId = assetModelId
        self.assetName = assetName
        self.assetProperty = assetProperty
        self.compositeModel = compositeModel
    }
}

public struct DescribeBulkImportJobInput: Swift.Sendable {
    /// The ID of the job.
    /// This member is required.
    public var jobId: Swift.String?

    public init(
        jobId: Swift.String? = nil
    )
    {
        self.jobId = jobId
    }
}

public struct DescribeBulkImportJobOutput: Swift.Sendable {
    /// If set to true, ingest new data into IoT SiteWise storage. Measurements with notifications, metrics and transforms are computed. If set to false, historical data is ingested into IoT SiteWise as is.
    public var adaptiveIngestion: Swift.Bool?
    /// If set to true, your data files is deleted from S3, after ingestion into IoT SiteWise storage.
    public var deleteFilesAfterImport: Swift.Bool?
    /// The Amazon S3 destination where errors associated with the job creation request are saved.
    /// This member is required.
    public var errorReportLocation: IoTSiteWiseClientTypes.ErrorReportLocation?
    /// The files in the specified Amazon S3 bucket that contain your data.
    /// This member is required.
    public var files: [IoTSiteWiseClientTypes.File]?
    /// Contains the configuration information of a job, such as the file format used to save data in Amazon S3.
    /// This member is required.
    public var jobConfiguration: IoTSiteWiseClientTypes.JobConfiguration?
    /// The date the job was created, in Unix epoch TIME.
    /// This member is required.
    public var jobCreationDate: Foundation.Date?
    /// The ID of the job.
    /// This member is required.
    public var jobId: Swift.String?
    /// The date the job was last updated, in Unix epoch time.
    /// This member is required.
    public var jobLastUpdateDate: Foundation.Date?
    /// The unique name that helps identify the job request.
    /// This member is required.
    public var jobName: Swift.String?
    /// The [ARN](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the IAM role that allows IoT SiteWise to read Amazon S3 data.
    /// This member is required.
    public var jobRoleArn: Swift.String?
    /// The status of the bulk import job can be one of following values:
    ///
    /// * PENDING – IoT SiteWise is waiting for the current bulk import job to finish.
    ///
    /// * CANCELLED – The bulk import job has been canceled.
    ///
    /// * RUNNING – IoT SiteWise is processing your request to import your data from Amazon S3.
    ///
    /// * COMPLETED – IoT SiteWise successfully completed your request to import data from Amazon S3.
    ///
    /// * FAILED – IoT SiteWise couldn't process your request to import data from Amazon S3. You can use logs saved in the specified error report location in Amazon S3 to troubleshoot issues.
    ///
    /// * COMPLETED_WITH_FAILURES – IoT SiteWise completed your request to import data from Amazon S3 with errors. You can use logs saved in the specified error report location in Amazon S3 to troubleshoot issues.
    /// This member is required.
    public var jobStatus: IoTSiteWiseClientTypes.JobStatus?

    public init(
        adaptiveIngestion: Swift.Bool? = nil,
        deleteFilesAfterImport: Swift.Bool? = nil,
        errorReportLocation: IoTSiteWiseClientTypes.ErrorReportLocation? = nil,
        files: [IoTSiteWiseClientTypes.File]? = nil,
        jobConfiguration: IoTSiteWiseClientTypes.JobConfiguration? = nil,
        jobCreationDate: Foundation.Date? = nil,
        jobId: Swift.String? = nil,
        jobLastUpdateDate: Foundation.Date? = nil,
        jobName: Swift.String? = nil,
        jobRoleArn: Swift.String? = nil,
        jobStatus: IoTSiteWiseClientTypes.JobStatus? = nil
    )
    {
        self.adaptiveIngestion = adaptiveIngestion
        self.deleteFilesAfterImport = deleteFilesAfterImport
        self.errorReportLocation = errorReportLocation
        self.files = files
        self.jobConfiguration = jobConfiguration
        self.jobCreationDate = jobCreationDate
        self.jobId = jobId
        self.jobLastUpdateDate = jobLastUpdateDate
        self.jobName = jobName
        self.jobRoleArn = jobRoleArn
        self.jobStatus = jobStatus
    }
}

public struct DescribeDashboardInput: Swift.Sendable {
    /// The ID of the dashboard.
    /// This member is required.
    public var dashboardId: Swift.String?

    public init(
        dashboardId: Swift.String? = nil
    )
    {
        self.dashboardId = dashboardId
    }
}

public struct DescribeDashboardOutput: Swift.Sendable {
    /// The [ARN](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the dashboard, which has the following format. arn:${Partition}:iotsitewise:${Region}:${Account}:dashboard/${DashboardId}
    /// This member is required.
    public var dashboardArn: Swift.String?
    /// The date the dashboard was created, in Unix epoch time.
    /// This member is required.
    public var dashboardCreationDate: Foundation.Date?
    /// The dashboard's definition JSON literal. For detailed information, see [Creating dashboards (CLI)](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/create-dashboards-using-aws-cli.html) in the IoT SiteWise User Guide.
    /// This member is required.
    public var dashboardDefinition: Swift.String?
    /// The dashboard's description.
    public var dashboardDescription: Swift.String?
    /// The ID of the dashboard.
    /// This member is required.
    public var dashboardId: Swift.String?
    /// The date the dashboard was last updated, in Unix epoch time.
    /// This member is required.
    public var dashboardLastUpdateDate: Foundation.Date?
    /// The name of the dashboard.
    /// This member is required.
    public var dashboardName: Swift.String?
    /// The ID of the project that the dashboard is in.
    /// This member is required.
    public var projectId: Swift.String?

    public init(
        dashboardArn: Swift.String? = nil,
        dashboardCreationDate: Foundation.Date? = nil,
        dashboardDefinition: Swift.String? = nil,
        dashboardDescription: Swift.String? = nil,
        dashboardId: Swift.String? = nil,
        dashboardLastUpdateDate: Foundation.Date? = nil,
        dashboardName: Swift.String? = nil,
        projectId: Swift.String? = nil
    )
    {
        self.dashboardArn = dashboardArn
        self.dashboardCreationDate = dashboardCreationDate
        self.dashboardDefinition = dashboardDefinition
        self.dashboardDescription = dashboardDescription
        self.dashboardId = dashboardId
        self.dashboardLastUpdateDate = dashboardLastUpdateDate
        self.dashboardName = dashboardName
        self.projectId = projectId
    }
}

public struct DescribeDefaultEncryptionConfigurationInput: Swift.Sendable {

    public init() { }
}

extension IoTSiteWiseClientTypes {

    /// Contains the details of an IoT SiteWise configuration error.
    public struct ConfigurationErrorDetails: Swift.Sendable {
        /// The error code.
        /// This member is required.
        public var code: IoTSiteWiseClientTypes.ErrorCode?
        /// The error message.
        /// This member is required.
        public var message: Swift.String?

        public init(
            code: IoTSiteWiseClientTypes.ErrorCode? = nil,
            message: Swift.String? = nil
        )
        {
            self.code = code
            self.message = message
        }
    }
}

extension IoTSiteWiseClientTypes {

    public enum ConfigurationState: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case updateFailed
        case updateInProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [ConfigurationState] {
            return [
                .active,
                .updateFailed,
                .updateInProgress
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .updateFailed: return "UPDATE_FAILED"
            case .updateInProgress: return "UPDATE_IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTSiteWiseClientTypes {

    /// Contains current status information for the configuration.
    public struct ConfigurationStatus: Swift.Sendable {
        /// Contains associated error information, if any.
        public var error: IoTSiteWiseClientTypes.ConfigurationErrorDetails?
        /// The current state of the configuration.
        /// This member is required.
        public var state: IoTSiteWiseClientTypes.ConfigurationState?

        public init(
            error: IoTSiteWiseClientTypes.ConfigurationErrorDetails? = nil,
            state: IoTSiteWiseClientTypes.ConfigurationState? = nil
        )
        {
            self.error = error
            self.state = state
        }
    }
}

extension IoTSiteWiseClientTypes {

    public enum EncryptionType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case kmsBasedEncryption
        case sitewiseDefaultEncryption
        case sdkUnknown(Swift.String)

        public static var allCases: [EncryptionType] {
            return [
                .kmsBasedEncryption,
                .sitewiseDefaultEncryption
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .kmsBasedEncryption: return "KMS_BASED_ENCRYPTION"
            case .sitewiseDefaultEncryption: return "SITEWISE_DEFAULT_ENCRYPTION"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct DescribeDefaultEncryptionConfigurationOutput: Swift.Sendable {
    /// The status of the account configuration. This contains the ConfigurationState. If there's an error, it also contains the ErrorDetails.
    /// This member is required.
    public var configurationStatus: IoTSiteWiseClientTypes.ConfigurationStatus?
    /// The type of encryption used for the encryption configuration.
    /// This member is required.
    public var encryptionType: IoTSiteWiseClientTypes.EncryptionType?
    /// The key ARN of the customer managed key used for KMS encryption if you use KMS_BASED_ENCRYPTION.
    public var kmsKeyArn: Swift.String?

    public init(
        configurationStatus: IoTSiteWiseClientTypes.ConfigurationStatus? = nil,
        encryptionType: IoTSiteWiseClientTypes.EncryptionType? = nil,
        kmsKeyArn: Swift.String? = nil
    )
    {
        self.configurationStatus = configurationStatus
        self.encryptionType = encryptionType
        self.kmsKeyArn = kmsKeyArn
    }
}

public struct DescribeGatewayInput: Swift.Sendable {
    /// The ID of the gateway device.
    /// This member is required.
    public var gatewayId: Swift.String?

    public init(
        gatewayId: Swift.String? = nil
    )
    {
        self.gatewayId = gatewayId
    }
}

extension IoTSiteWiseClientTypes {

    public enum CapabilitySyncStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case inSync
        case notApplicable
        case outOfSync
        case syncFailed
        case unknown
        case sdkUnknown(Swift.String)

        public static var allCases: [CapabilitySyncStatus] {
            return [
                .inSync,
                .notApplicable,
                .outOfSync,
                .syncFailed,
                .unknown
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .inSync: return "IN_SYNC"
            case .notApplicable: return "NOT_APPLICABLE"
            case .outOfSync: return "OUT_OF_SYNC"
            case .syncFailed: return "SYNC_FAILED"
            case .unknown: return "UNKNOWN"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTSiteWiseClientTypes {

    /// Contains a summary of a gateway capability configuration.
    public struct GatewayCapabilitySummary: Swift.Sendable {
        /// The namespace of the capability configuration. For example, if you configure OPC-UA sources from the IoT SiteWise console, your OPC-UA capability configuration has the namespace iotsitewise:opcuacollector:version, where version is a number such as 1.
        /// This member is required.
        public var capabilityNamespace: Swift.String?
        /// The synchronization status of the capability configuration. The sync status can be one of the following:
        ///
        /// * IN_SYNC – The gateway is running the capability configuration.
        ///
        /// * OUT_OF_SYNC – The gateway hasn't received the capability configuration.
        ///
        /// * SYNC_FAILED – The gateway rejected the capability configuration.
        /// This member is required.
        public var capabilitySyncStatus: IoTSiteWiseClientTypes.CapabilitySyncStatus?

        public init(
            capabilityNamespace: Swift.String? = nil,
            capabilitySyncStatus: IoTSiteWiseClientTypes.CapabilitySyncStatus? = nil
        )
        {
            self.capabilityNamespace = capabilityNamespace
            self.capabilitySyncStatus = capabilitySyncStatus
        }
    }
}

public struct DescribeGatewayOutput: Swift.Sendable {
    /// The date the gateway was created, in Unix epoch time.
    /// This member is required.
    public var creationDate: Foundation.Date?
    /// The [ARN](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the gateway, which has the following format. arn:${Partition}:iotsitewise:${Region}:${Account}:gateway/${GatewayId}
    /// This member is required.
    public var gatewayArn: Swift.String?
    /// A list of gateway capability summaries that each contain a namespace and status. Each gateway capability defines data sources for the gateway. To retrieve a capability configuration's definition, use [DescribeGatewayCapabilityConfiguration](https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_DescribeGatewayCapabilityConfiguration.html).
    /// This member is required.
    public var gatewayCapabilitySummaries: [IoTSiteWiseClientTypes.GatewayCapabilitySummary]?
    /// The ID of the gateway device.
    /// This member is required.
    public var gatewayId: Swift.String?
    /// The name of the gateway.
    /// This member is required.
    public var gatewayName: Swift.String?
    /// The gateway's platform.
    public var gatewayPlatform: IoTSiteWiseClientTypes.GatewayPlatform?
    /// The date the gateway was last updated, in Unix epoch time.
    /// This member is required.
    public var lastUpdateDate: Foundation.Date?

    public init(
        creationDate: Foundation.Date? = nil,
        gatewayArn: Swift.String? = nil,
        gatewayCapabilitySummaries: [IoTSiteWiseClientTypes.GatewayCapabilitySummary]? = nil,
        gatewayId: Swift.String? = nil,
        gatewayName: Swift.String? = nil,
        gatewayPlatform: IoTSiteWiseClientTypes.GatewayPlatform? = nil,
        lastUpdateDate: Foundation.Date? = nil
    )
    {
        self.creationDate = creationDate
        self.gatewayArn = gatewayArn
        self.gatewayCapabilitySummaries = gatewayCapabilitySummaries
        self.gatewayId = gatewayId
        self.gatewayName = gatewayName
        self.gatewayPlatform = gatewayPlatform
        self.lastUpdateDate = lastUpdateDate
    }
}

public struct DescribeGatewayCapabilityConfigurationInput: Swift.Sendable {
    /// The namespace of the capability configuration. For example, if you configure OPC-UA sources from the IoT SiteWise console, your OPC-UA capability configuration has the namespace iotsitewise:opcuacollector:version, where version is a number such as 1.
    /// This member is required.
    public var capabilityNamespace: Swift.String?
    /// The ID of the gateway that defines the capability configuration.
    /// This member is required.
    public var gatewayId: Swift.String?

    public init(
        capabilityNamespace: Swift.String? = nil,
        gatewayId: Swift.String? = nil
    )
    {
        self.capabilityNamespace = capabilityNamespace
        self.gatewayId = gatewayId
    }
}

public struct DescribeGatewayCapabilityConfigurationOutput: Swift.Sendable {
    /// The JSON document that defines the gateway capability's configuration. For more information, see [Configuring data sources (CLI)](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/configure-sources.html#configure-source-cli) in the IoT SiteWise User Guide.
    /// This member is required.
    public var capabilityConfiguration: Swift.String?
    /// The namespace of the gateway capability.
    /// This member is required.
    public var capabilityNamespace: Swift.String?
    /// The synchronization status of the capability configuration. The sync status can be one of the following:
    ///
    /// * IN_SYNC – The gateway is running the capability configuration.
    ///
    /// * OUT_OF_SYNC – The gateway hasn't received the capability configuration.
    ///
    /// * SYNC_FAILED – The gateway rejected the capability configuration.
    /// This member is required.
    public var capabilitySyncStatus: IoTSiteWiseClientTypes.CapabilitySyncStatus?
    /// The ID of the gateway that defines the capability configuration.
    /// This member is required.
    public var gatewayId: Swift.String?

    public init(
        capabilityConfiguration: Swift.String? = nil,
        capabilityNamespace: Swift.String? = nil,
        capabilitySyncStatus: IoTSiteWiseClientTypes.CapabilitySyncStatus? = nil,
        gatewayId: Swift.String? = nil
    )
    {
        self.capabilityConfiguration = capabilityConfiguration
        self.capabilityNamespace = capabilityNamespace
        self.capabilitySyncStatus = capabilitySyncStatus
        self.gatewayId = gatewayId
    }
}

public struct DescribeLoggingOptionsInput: Swift.Sendable {

    public init() { }
}

extension IoTSiteWiseClientTypes {

    public enum LoggingLevel: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case error
        case info
        case off
        case sdkUnknown(Swift.String)

        public static var allCases: [LoggingLevel] {
            return [
                .error,
                .info,
                .off
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .error: return "ERROR"
            case .info: return "INFO"
            case .off: return "OFF"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTSiteWiseClientTypes {

    /// Contains logging options.
    public struct LoggingOptions: Swift.Sendable {
        /// The IoT SiteWise logging verbosity level.
        /// This member is required.
        public var level: IoTSiteWiseClientTypes.LoggingLevel?

        public init(
            level: IoTSiteWiseClientTypes.LoggingLevel? = nil
        )
        {
            self.level = level
        }
    }
}

public struct DescribeLoggingOptionsOutput: Swift.Sendable {
    /// The current logging options.
    /// This member is required.
    public var loggingOptions: IoTSiteWiseClientTypes.LoggingOptions?

    public init(
        loggingOptions: IoTSiteWiseClientTypes.LoggingOptions? = nil
    )
    {
        self.loggingOptions = loggingOptions
    }
}

public struct DescribePortalInput: Swift.Sendable {
    /// The ID of the portal.
    /// This member is required.
    public var portalId: Swift.String?

    public init(
        portalId: Swift.String? = nil
    )
    {
        self.portalId = portalId
    }
}

extension IoTSiteWiseClientTypes {

    /// Contains an image that is uploaded to IoT SiteWise and available at a URL.
    public struct ImageLocation: Swift.Sendable {
        /// The ID of the image.
        /// This member is required.
        public var id: Swift.String?
        /// The URL where the image is available. The URL is valid for 15 minutes so that you can view and download the image
        /// This member is required.
        public var url: Swift.String?

        public init(
            id: Swift.String? = nil,
            url: Swift.String? = nil
        )
        {
            self.id = id
            self.url = url
        }
    }
}

public struct DescribePortalOutput: Swift.Sendable {
    /// Contains the configuration information of an alarm created in an IoT SiteWise Monitor portal.
    public var alarms: IoTSiteWiseClientTypes.Alarms?
    /// The email address that sends alarm notifications.
    public var notificationSenderEmail: Swift.String?
    /// The [ARN](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the portal, which has the following format. arn:${Partition}:iotsitewise:${Region}:${Account}:portal/${PortalId}
    /// This member is required.
    public var portalArn: Swift.String?
    /// The service to use to authenticate users to the portal.
    public var portalAuthMode: IoTSiteWiseClientTypes.AuthMode?
    /// The IAM Identity Center application generated client ID (used with IAM Identity Center API operations). IoT SiteWise includes portalClientId for only portals that use IAM Identity Center to authenticate users.
    /// This member is required.
    public var portalClientId: Swift.String?
    /// The Amazon Web Services administrator's contact email address.
    /// This member is required.
    public var portalContactEmail: Swift.String?
    /// The date the portal was created, in Unix epoch time.
    /// This member is required.
    public var portalCreationDate: Foundation.Date?
    /// The portal's description.
    public var portalDescription: Swift.String?
    /// The ID of the portal.
    /// This member is required.
    public var portalId: Swift.String?
    /// The date the portal was last updated, in Unix epoch time.
    /// This member is required.
    public var portalLastUpdateDate: Foundation.Date?
    /// The portal's logo image, which is available at a URL.
    public var portalLogoImageLocation: IoTSiteWiseClientTypes.ImageLocation?
    /// The name of the portal.
    /// This member is required.
    public var portalName: Swift.String?
    /// The URL for the IoT SiteWise Monitor portal. You can use this URL to access portals that use IAM Identity Center for authentication. For portals that use IAM for authentication, you must use the IoT SiteWise console to get a URL that you can use to access the portal.
    /// This member is required.
    public var portalStartUrl: Swift.String?
    /// The current status of the portal, which contains a state and any error message.
    /// This member is required.
    public var portalStatus: IoTSiteWiseClientTypes.PortalStatus?
    /// The [ARN](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the service role that allows the portal's users to access your IoT SiteWise resources on your behalf. For more information, see [Using service roles for IoT SiteWise Monitor](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/monitor-service-role.html) in the IoT SiteWise User Guide.
    public var roleArn: Swift.String?

    public init(
        alarms: IoTSiteWiseClientTypes.Alarms? = nil,
        notificationSenderEmail: Swift.String? = nil,
        portalArn: Swift.String? = nil,
        portalAuthMode: IoTSiteWiseClientTypes.AuthMode? = nil,
        portalClientId: Swift.String? = nil,
        portalContactEmail: Swift.String? = nil,
        portalCreationDate: Foundation.Date? = nil,
        portalDescription: Swift.String? = nil,
        portalId: Swift.String? = nil,
        portalLastUpdateDate: Foundation.Date? = nil,
        portalLogoImageLocation: IoTSiteWiseClientTypes.ImageLocation? = nil,
        portalName: Swift.String? = nil,
        portalStartUrl: Swift.String? = nil,
        portalStatus: IoTSiteWiseClientTypes.PortalStatus? = nil,
        roleArn: Swift.String? = nil
    )
    {
        self.alarms = alarms
        self.notificationSenderEmail = notificationSenderEmail
        self.portalArn = portalArn
        self.portalAuthMode = portalAuthMode
        self.portalClientId = portalClientId
        self.portalContactEmail = portalContactEmail
        self.portalCreationDate = portalCreationDate
        self.portalDescription = portalDescription
        self.portalId = portalId
        self.portalLastUpdateDate = portalLastUpdateDate
        self.portalLogoImageLocation = portalLogoImageLocation
        self.portalName = portalName
        self.portalStartUrl = portalStartUrl
        self.portalStatus = portalStatus
        self.roleArn = roleArn
    }
}

public struct DescribeProjectInput: Swift.Sendable {
    /// The ID of the project.
    /// This member is required.
    public var projectId: Swift.String?

    public init(
        projectId: Swift.String? = nil
    )
    {
        self.projectId = projectId
    }
}

public struct DescribeProjectOutput: Swift.Sendable {
    /// The ID of the portal that the project is in.
    /// This member is required.
    public var portalId: Swift.String?
    /// The [ARN](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the project, which has the following format. arn:${Partition}:iotsitewise:${Region}:${Account}:project/${ProjectId}
    /// This member is required.
    public var projectArn: Swift.String?
    /// The date the project was created, in Unix epoch time.
    /// This member is required.
    public var projectCreationDate: Foundation.Date?
    /// The project's description.
    public var projectDescription: Swift.String?
    /// The ID of the project.
    /// This member is required.
    public var projectId: Swift.String?
    /// The date the project was last updated, in Unix epoch time.
    /// This member is required.
    public var projectLastUpdateDate: Foundation.Date?
    /// The name of the project.
    /// This member is required.
    public var projectName: Swift.String?

    public init(
        portalId: Swift.String? = nil,
        projectArn: Swift.String? = nil,
        projectCreationDate: Foundation.Date? = nil,
        projectDescription: Swift.String? = nil,
        projectId: Swift.String? = nil,
        projectLastUpdateDate: Foundation.Date? = nil,
        projectName: Swift.String? = nil
    )
    {
        self.portalId = portalId
        self.projectArn = projectArn
        self.projectCreationDate = projectCreationDate
        self.projectDescription = projectDescription
        self.projectId = projectId
        self.projectLastUpdateDate = projectLastUpdateDate
        self.projectName = projectName
    }
}

public struct DescribeStorageConfigurationInput: Swift.Sendable {

    public init() { }
}

extension IoTSiteWiseClientTypes {

    public enum DisassociatedDataStorageState: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [DisassociatedDataStorageState] {
            return [
                .disabled,
                .enabled
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTSiteWiseClientTypes {

    /// Contains information about a customer managed Amazon S3 bucket.
    public struct CustomerManagedS3Storage: Swift.Sendable {
        /// The [ARN](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the Identity and Access Management role that allows IoT SiteWise to send data to Amazon S3.
        /// This member is required.
        public var roleArn: Swift.String?
        /// The [ARN](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the Amazon S3 object. For more information about how to find the ARN for an Amazon S3 object, see [Amazon S3 resources](https://docs.aws.amazon.com/AmazonS3/latest/userguide/s3-arn-format.html) in the Amazon Simple Storage Service User Guide.
        /// This member is required.
        public var s3ResourceArn: Swift.String?

        public init(
            roleArn: Swift.String? = nil,
            s3ResourceArn: Swift.String? = nil
        )
        {
            self.roleArn = roleArn
            self.s3ResourceArn = s3ResourceArn
        }
    }
}

extension IoTSiteWiseClientTypes {

    /// Contains information about the storage destination.
    public struct MultiLayerStorage: Swift.Sendable {
        /// Contains information about a customer managed Amazon S3 bucket.
        /// This member is required.
        public var customerManagedS3Storage: IoTSiteWiseClientTypes.CustomerManagedS3Storage?

        public init(
            customerManagedS3Storage: IoTSiteWiseClientTypes.CustomerManagedS3Storage? = nil
        )
        {
            self.customerManagedS3Storage = customerManagedS3Storage
        }
    }
}

extension IoTSiteWiseClientTypes {

    /// The number of days your data is kept in the hot tier. By default, your data is kept indefinitely in the hot tier.
    public struct RetentionPeriod: Swift.Sendable {
        /// The number of days that your data is kept. If you specified a value for this parameter, the unlimited parameter must be false.
        public var numberOfDays: Swift.Int?
        /// If true, your data is kept indefinitely. If configured to true, you must not specify a value for the numberOfDays parameter.
        public var unlimited: Swift.Bool?

        public init(
            numberOfDays: Swift.Int? = nil,
            unlimited: Swift.Bool? = nil
        )
        {
            self.numberOfDays = numberOfDays
            self.unlimited = unlimited
        }
    }
}

extension IoTSiteWiseClientTypes {

    public enum StorageType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case multiLayerStorage
        case sitewiseDefaultStorage
        case sdkUnknown(Swift.String)

        public static var allCases: [StorageType] {
            return [
                .multiLayerStorage,
                .sitewiseDefaultStorage
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .multiLayerStorage: return "MULTI_LAYER_STORAGE"
            case .sitewiseDefaultStorage: return "SITEWISE_DEFAULT_STORAGE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTSiteWiseClientTypes {

    public enum WarmTierState: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [WarmTierState] {
            return [
                .disabled,
                .enabled
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTSiteWiseClientTypes {

    /// Set this period to specify how long your data is stored in the warm tier before it is deleted. You can set this only if cold tier is enabled.
    public struct WarmTierRetentionPeriod: Swift.Sendable {
        /// The number of days the data is stored in the warm tier.
        public var numberOfDays: Swift.Int?
        /// If set to true, the data is stored indefinitely in the warm tier.
        public var unlimited: Swift.Bool?

        public init(
            numberOfDays: Swift.Int? = nil,
            unlimited: Swift.Bool? = nil
        )
        {
            self.numberOfDays = numberOfDays
            self.unlimited = unlimited
        }
    }
}

public struct DescribeStorageConfigurationOutput: Swift.Sendable {
    /// Contains current status information for the configuration.
    /// This member is required.
    public var configurationStatus: IoTSiteWiseClientTypes.ConfigurationStatus?
    /// Contains the storage configuration for time series (data streams) that aren't associated with asset properties. The disassociatedDataStorage can be one of the following values:
    ///
    /// * ENABLED – IoT SiteWise accepts time series that aren't associated with asset properties. After the disassociatedDataStorage is enabled, you can't disable it.
    ///
    /// * DISABLED – IoT SiteWise doesn't accept time series (data streams) that aren't associated with asset properties.
    ///
    ///
    /// For more information, see [Data streams](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/data-streams.html) in the IoT SiteWise User Guide.
    public var disassociatedDataStorage: IoTSiteWiseClientTypes.DisassociatedDataStorageState?
    /// The date the storage configuration was last updated, in Unix epoch time.
    public var lastUpdateDate: Foundation.Date?
    /// Contains information about the storage destination.
    public var multiLayerStorage: IoTSiteWiseClientTypes.MultiLayerStorage?
    /// The number of days your data is kept in the hot tier. By default, your data is kept indefinitely in the hot tier.
    public var retentionPeriod: IoTSiteWiseClientTypes.RetentionPeriod?
    /// The storage tier that you specified for your data. The storageType parameter can be one of the following values:
    ///
    /// * SITEWISE_DEFAULT_STORAGE – IoT SiteWise saves your data into the hot tier. The hot tier is a service-managed database.
    ///
    /// * MULTI_LAYER_STORAGE – IoT SiteWise saves your data in both the cold tier and the hot tier. The cold tier is a customer-managed Amazon S3 bucket.
    /// This member is required.
    public var storageType: IoTSiteWiseClientTypes.StorageType?
    /// A service managed storage tier optimized for analytical queries. It stores periodically uploaded, buffered and historical data ingested with the CreaeBulkImportJob API.
    public var warmTier: IoTSiteWiseClientTypes.WarmTierState?
    /// Set this period to specify how long your data is stored in the warm tier before it is deleted. You can set this only if cold tier is enabled.
    public var warmTierRetentionPeriod: IoTSiteWiseClientTypes.WarmTierRetentionPeriod?

    public init(
        configurationStatus: IoTSiteWiseClientTypes.ConfigurationStatus? = nil,
        disassociatedDataStorage: IoTSiteWiseClientTypes.DisassociatedDataStorageState? = nil,
        lastUpdateDate: Foundation.Date? = nil,
        multiLayerStorage: IoTSiteWiseClientTypes.MultiLayerStorage? = nil,
        retentionPeriod: IoTSiteWiseClientTypes.RetentionPeriod? = nil,
        storageType: IoTSiteWiseClientTypes.StorageType? = nil,
        warmTier: IoTSiteWiseClientTypes.WarmTierState? = nil,
        warmTierRetentionPeriod: IoTSiteWiseClientTypes.WarmTierRetentionPeriod? = nil
    )
    {
        self.configurationStatus = configurationStatus
        self.disassociatedDataStorage = disassociatedDataStorage
        self.lastUpdateDate = lastUpdateDate
        self.multiLayerStorage = multiLayerStorage
        self.retentionPeriod = retentionPeriod
        self.storageType = storageType
        self.warmTier = warmTier
        self.warmTierRetentionPeriod = warmTierRetentionPeriod
    }
}

public struct DescribeTimeSeriesInput: Swift.Sendable {
    /// The alias that identifies the time series.
    public var alias: Swift.String?
    /// The ID of the asset in which the asset property was created. This can be either the actual ID in UUID format, or else externalId: followed by the external ID, if it has one. For more information, see [Referencing objects with external IDs](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/object-ids.html#external-id-references) in the IoT SiteWise User Guide.
    public var assetId: Swift.String?
    /// The ID of the asset property. This can be either the actual ID in UUID format, or else externalId: followed by the external ID, if it has one. For more information, see [Referencing objects with external IDs](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/object-ids.html#external-id-references) in the IoT SiteWise User Guide.
    public var propertyId: Swift.String?

    public init(
        alias: Swift.String? = nil,
        assetId: Swift.String? = nil,
        propertyId: Swift.String? = nil
    )
    {
        self.alias = alias
        self.assetId = assetId
        self.propertyId = propertyId
    }
}

public struct DescribeTimeSeriesOutput: Swift.Sendable {
    /// The alias that identifies the time series.
    public var alias: Swift.String?
    /// The ID of the asset in which the asset property was created.
    public var assetId: Swift.String?
    /// The data type of the time series. If you specify STRUCT, you must also specify dataTypeSpec to identify the type of the structure for this time series.
    /// This member is required.
    public var dataType: IoTSiteWiseClientTypes.PropertyDataType?
    /// The data type of the structure for this time series. This parameter is required for time series that have the STRUCT data type. The options for this parameter depend on the type of the composite model in which you created the asset property that is associated with your time series. Use AWS/ALARM_STATE for alarm state in alarm composite models.
    public var dataTypeSpec: Swift.String?
    /// The ID of the asset property, in UUID format.
    public var propertyId: Swift.String?
    /// The [ARN](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the time series, which has the following format. arn:${Partition}:iotsitewise:${Region}:${Account}:time-series/${TimeSeriesId}
    /// This member is required.
    public var timeSeriesArn: Swift.String?
    /// The date that the time series was created, in Unix epoch time.
    /// This member is required.
    public var timeSeriesCreationDate: Foundation.Date?
    /// The ID of the time series.
    /// This member is required.
    public var timeSeriesId: Swift.String?
    /// The date that the time series was last updated, in Unix epoch time.
    /// This member is required.
    public var timeSeriesLastUpdateDate: Foundation.Date?

    public init(
        alias: Swift.String? = nil,
        assetId: Swift.String? = nil,
        dataType: IoTSiteWiseClientTypes.PropertyDataType? = nil,
        dataTypeSpec: Swift.String? = nil,
        propertyId: Swift.String? = nil,
        timeSeriesArn: Swift.String? = nil,
        timeSeriesCreationDate: Foundation.Date? = nil,
        timeSeriesId: Swift.String? = nil,
        timeSeriesLastUpdateDate: Foundation.Date? = nil
    )
    {
        self.alias = alias
        self.assetId = assetId
        self.dataType = dataType
        self.dataTypeSpec = dataTypeSpec
        self.propertyId = propertyId
        self.timeSeriesArn = timeSeriesArn
        self.timeSeriesCreationDate = timeSeriesCreationDate
        self.timeSeriesId = timeSeriesId
        self.timeSeriesLastUpdateDate = timeSeriesLastUpdateDate
    }
}

public struct DisassociateAssetsInput: Swift.Sendable {
    /// The ID of the parent asset from which to disassociate the child asset. This can be either the actual ID in UUID format, or else externalId: followed by the external ID, if it has one. For more information, see [Referencing objects with external IDs](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/object-ids.html#external-id-references) in the IoT SiteWise User Guide.
    /// This member is required.
    public var assetId: Swift.String?
    /// The ID of the child asset to disassociate. This can be either the actual ID in UUID format, or else externalId: followed by the external ID, if it has one. For more information, see [Referencing objects with external IDs](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/object-ids.html#external-id-references) in the IoT SiteWise User Guide.
    /// This member is required.
    public var childAssetId: Swift.String?
    /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
    public var clientToken: Swift.String?
    /// The ID of a hierarchy in the parent asset's model. (This can be either the actual ID in UUID format, or else externalId: followed by the external ID, if it has one. For more information, see [Referencing objects with external IDs](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/object-ids.html#external-id-references) in the IoT SiteWise User Guide.) Hierarchies allow different groupings of assets to be formed that all come from the same asset model. You can use the hierarchy ID to identify the correct asset to disassociate. For more information, see [Asset hierarchies](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/asset-hierarchies.html) in the IoT SiteWise User Guide.
    /// This member is required.
    public var hierarchyId: Swift.String?

    public init(
        assetId: Swift.String? = nil,
        childAssetId: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        hierarchyId: Swift.String? = nil
    )
    {
        self.assetId = assetId
        self.childAssetId = childAssetId
        self.clientToken = clientToken
        self.hierarchyId = hierarchyId
    }
}

public struct DisassociateTimeSeriesFromAssetPropertyInput: Swift.Sendable {
    /// The alias that identifies the time series.
    /// This member is required.
    public var alias: Swift.String?
    /// The ID of the asset in which the asset property was created. This can be either the actual ID in UUID format, or else externalId: followed by the external ID, if it has one. For more information, see [Referencing objects with external IDs](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/object-ids.html#external-id-references) in the IoT SiteWise User Guide.
    /// This member is required.
    public var assetId: Swift.String?
    /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
    public var clientToken: Swift.String?
    /// The ID of the asset property. This can be either the actual ID in UUID format, or else externalId: followed by the external ID, if it has one. For more information, see [Referencing objects with external IDs](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/object-ids.html#external-id-references) in the IoT SiteWise User Guide.
    /// This member is required.
    public var propertyId: Swift.String?

    public init(
        alias: Swift.String? = nil,
        assetId: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        propertyId: Swift.String? = nil
    )
    {
        self.alias = alias
        self.assetId = assetId
        self.clientToken = clientToken
        self.propertyId = propertyId
    }
}

public struct ExecuteActionInput: Swift.Sendable {
    /// The ID of the action definition.
    /// This member is required.
    public var actionDefinitionId: Swift.String?
    /// The JSON payload of the action.
    /// This member is required.
    public var actionPayload: IoTSiteWiseClientTypes.ActionPayload?
    /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
    public var clientToken: Swift.String?
    /// The resource the action will be taken on.
    /// This member is required.
    public var targetResource: IoTSiteWiseClientTypes.TargetResource?

    public init(
        actionDefinitionId: Swift.String? = nil,
        actionPayload: IoTSiteWiseClientTypes.ActionPayload? = nil,
        clientToken: Swift.String? = nil,
        targetResource: IoTSiteWiseClientTypes.TargetResource? = nil
    )
    {
        self.actionDefinitionId = actionDefinitionId
        self.actionPayload = actionPayload
        self.clientToken = clientToken
        self.targetResource = targetResource
    }
}

public struct ExecuteActionOutput: Swift.Sendable {
    /// The ID of the action.
    /// This member is required.
    public var actionId: Swift.String?

    public init(
        actionId: Swift.String? = nil
    )
    {
        self.actionId = actionId
    }
}

/// The query timed out.
public struct QueryTimeoutException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "QueryTimeoutException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The validation failed for this query.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct ExecuteQueryInput: Swift.Sendable {
    /// The maximum number of results to return at one time. The default is 25.
    public var maxResults: Swift.Int?
    /// The string that specifies the next page of results.
    public var nextToken: Swift.String?
    /// The IoT SiteWise query statement.
    /// This member is required.
    public var queryStatement: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        queryStatement: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.queryStatement = queryStatement
    }
}

extension IoTSiteWiseClientTypes {

    public enum ScalarType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case boolean
        case double
        case int
        case string
        case timestamp
        case sdkUnknown(Swift.String)

        public static var allCases: [ScalarType] {
            return [
                .boolean,
                .double,
                .int,
                .string,
                .timestamp
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .boolean: return "BOOLEAN"
            case .double: return "DOUBLE"
            case .int: return "INT"
            case .string: return "STRING"
            case .timestamp: return "TIMESTAMP"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTSiteWiseClientTypes {

    /// The data type of the column.
    public struct ColumnType: Swift.Sendable {
        /// The allowed data types that the column has as it's value.
        public var scalarType: IoTSiteWiseClientTypes.ScalarType?

        public init(
            scalarType: IoTSiteWiseClientTypes.ScalarType? = nil
        )
        {
            self.scalarType = scalarType
        }
    }
}

extension IoTSiteWiseClientTypes {

    /// A description of the column in the query results.
    public struct ColumnInfo: Swift.Sendable {
        /// The name of the column description.
        public var name: Swift.String?
        /// The type of the column description.
        public var type: IoTSiteWiseClientTypes.ColumnType?

        public init(
            name: Swift.String? = nil,
            type: IoTSiteWiseClientTypes.ColumnType? = nil
        )
        {
            self.name = name
            self.type = type
        }
    }
}

public struct GetAssetPropertyAggregatesInput: Swift.Sendable {
    /// The data aggregating function.
    /// This member is required.
    public var aggregateTypes: [IoTSiteWiseClientTypes.AggregateType]?
    /// The ID of the asset, in UUID format.
    public var assetId: Swift.String?
    /// The inclusive end of the range from which to query historical data, expressed in seconds in Unix epoch time.
    /// This member is required.
    public var endDate: Foundation.Date?
    /// The maximum number of results to return for each paginated request. A result set is returned in the two cases, whichever occurs first.
    ///
    /// * The size of the result set is equal to 1 MB.
    ///
    /// * The number of data points in the result set is equal to the value of maxResults. The maximum value of maxResults is 2500.
    public var maxResults: Swift.Int?
    /// The token to be used for the next set of paginated results.
    public var nextToken: Swift.String?
    /// The alias that identifies the property, such as an OPC-UA server data stream path (for example, /company/windfarm/3/turbine/7/temperature). For more information, see [Mapping industrial data streams to asset properties](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/connect-data-streams.html) in the IoT SiteWise User Guide.
    public var propertyAlias: Swift.String?
    /// The ID of the asset property, in UUID format.
    public var propertyId: Swift.String?
    /// The quality by which to filter asset data.
    public var qualities: [IoTSiteWiseClientTypes.Quality]?
    /// The time interval over which to aggregate data.
    /// This member is required.
    public var resolution: Swift.String?
    /// The exclusive start of the range from which to query historical data, expressed in seconds in Unix epoch time.
    /// This member is required.
    public var startDate: Foundation.Date?
    /// The chronological sorting order of the requested information. Default: ASCENDING
    public var timeOrdering: IoTSiteWiseClientTypes.TimeOrdering?

    public init(
        aggregateTypes: [IoTSiteWiseClientTypes.AggregateType]? = nil,
        assetId: Swift.String? = nil,
        endDate: Foundation.Date? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        propertyAlias: Swift.String? = nil,
        propertyId: Swift.String? = nil,
        qualities: [IoTSiteWiseClientTypes.Quality]? = nil,
        resolution: Swift.String? = nil,
        startDate: Foundation.Date? = nil,
        timeOrdering: IoTSiteWiseClientTypes.TimeOrdering? = nil
    )
    {
        self.aggregateTypes = aggregateTypes
        self.assetId = assetId
        self.endDate = endDate
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.propertyAlias = propertyAlias
        self.propertyId = propertyId
        self.qualities = qualities
        self.resolution = resolution
        self.startDate = startDate
        self.timeOrdering = timeOrdering
    }
}

public struct GetAssetPropertyAggregatesOutput: Swift.Sendable {
    /// The requested aggregated values.
    /// This member is required.
    public var aggregatedValues: [IoTSiteWiseClientTypes.AggregatedValue]?
    /// The token for the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?

    public init(
        aggregatedValues: [IoTSiteWiseClientTypes.AggregatedValue]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.aggregatedValues = aggregatedValues
        self.nextToken = nextToken
    }
}

public struct GetAssetPropertyValueInput: Swift.Sendable {
    /// The ID of the asset, in UUID format.
    public var assetId: Swift.String?
    /// The alias that identifies the property, such as an OPC-UA server data stream path (for example, /company/windfarm/3/turbine/7/temperature). For more information, see [Mapping industrial data streams to asset properties](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/connect-data-streams.html) in the IoT SiteWise User Guide.
    public var propertyAlias: Swift.String?
    /// The ID of the asset property, in UUID format.
    public var propertyId: Swift.String?

    public init(
        assetId: Swift.String? = nil,
        propertyAlias: Swift.String? = nil,
        propertyId: Swift.String? = nil
    )
    {
        self.assetId = assetId
        self.propertyAlias = propertyAlias
        self.propertyId = propertyId
    }
}

public struct GetAssetPropertyValueOutput: Swift.Sendable {
    /// The current asset property value.
    public var propertyValue: IoTSiteWiseClientTypes.AssetPropertyValue?

    public init(
        propertyValue: IoTSiteWiseClientTypes.AssetPropertyValue? = nil
    )
    {
        self.propertyValue = propertyValue
    }
}

public struct GetAssetPropertyValueHistoryInput: Swift.Sendable {
    /// The ID of the asset, in UUID format.
    public var assetId: Swift.String?
    /// The inclusive end of the range from which to query historical data, expressed in seconds in Unix epoch time.
    public var endDate: Foundation.Date?
    /// The maximum number of results to return for each paginated request. A result set is returned in the two cases, whichever occurs first.
    ///
    /// * The size of the result set is equal to 4 MB.
    ///
    /// * The number of data points in the result set is equal to the value of maxResults. The maximum value of maxResults is 20000.
    public var maxResults: Swift.Int?
    /// The token to be used for the next set of paginated results.
    public var nextToken: Swift.String?
    /// The alias that identifies the property, such as an OPC-UA server data stream path (for example, /company/windfarm/3/turbine/7/temperature). For more information, see [Mapping industrial data streams to asset properties](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/connect-data-streams.html) in the IoT SiteWise User Guide.
    public var propertyAlias: Swift.String?
    /// The ID of the asset property, in UUID format.
    public var propertyId: Swift.String?
    /// The quality by which to filter asset data.
    public var qualities: [IoTSiteWiseClientTypes.Quality]?
    /// The exclusive start of the range from which to query historical data, expressed in seconds in Unix epoch time.
    public var startDate: Foundation.Date?
    /// The chronological sorting order of the requested information. Default: ASCENDING
    public var timeOrdering: IoTSiteWiseClientTypes.TimeOrdering?

    public init(
        assetId: Swift.String? = nil,
        endDate: Foundation.Date? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        propertyAlias: Swift.String? = nil,
        propertyId: Swift.String? = nil,
        qualities: [IoTSiteWiseClientTypes.Quality]? = nil,
        startDate: Foundation.Date? = nil,
        timeOrdering: IoTSiteWiseClientTypes.TimeOrdering? = nil
    )
    {
        self.assetId = assetId
        self.endDate = endDate
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.propertyAlias = propertyAlias
        self.propertyId = propertyId
        self.qualities = qualities
        self.startDate = startDate
        self.timeOrdering = timeOrdering
    }
}

public struct GetAssetPropertyValueHistoryOutput: Swift.Sendable {
    /// The asset property's value history.
    /// This member is required.
    public var assetPropertyValueHistory: [IoTSiteWiseClientTypes.AssetPropertyValue]?
    /// The token for the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?

    public init(
        assetPropertyValueHistory: [IoTSiteWiseClientTypes.AssetPropertyValue]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.assetPropertyValueHistory = assetPropertyValueHistory
        self.nextToken = nextToken
    }
}

public struct GetInterpolatedAssetPropertyValuesInput: Swift.Sendable {
    /// The ID of the asset, in UUID format.
    public var assetId: Swift.String?
    /// The inclusive end of the range from which to interpolate data, expressed in seconds in Unix epoch time.
    /// This member is required.
    public var endTimeInSeconds: Swift.Int?
    /// The nanosecond offset converted from endTimeInSeconds.
    public var endTimeOffsetInNanos: Swift.Int?
    /// The time interval in seconds over which to interpolate data. Each interval starts when the previous one ends.
    /// This member is required.
    public var intervalInSeconds: Swift.Int?
    /// The query interval for the window, in seconds. IoT SiteWise computes each interpolated value by using data points from the timestamp of each interval, minus the window to the timestamp of each interval plus the window. If not specified, the window ranges between the start time minus the interval and the end time plus the interval.
    ///
    /// * If you specify a value for the intervalWindowInSeconds parameter, the value for the type parameter must be LINEAR_INTERPOLATION.
    ///
    /// * If a data point isn't found during the specified query window, IoT SiteWise won't return an interpolated value for the interval. This indicates that there's a gap in the ingested data points.
    ///
    ///
    /// For example, you can get the interpolated temperature values for a wind turbine every 24 hours over a duration of 7 days. If the interpolation starts on July 1, 2021, at 9 AM with a window of 2 hours, IoT SiteWise uses the data points from 7 AM (9 AM minus 2 hours) to 11 AM (9 AM plus 2 hours) on July 2, 2021 to compute the first interpolated value. Next, IoT SiteWise uses the data points from 7 AM (9 AM minus 2 hours) to 11 AM (9 AM plus 2 hours) on July 3, 2021 to compute the second interpolated value, and so on.
    public var intervalWindowInSeconds: Swift.Int?
    /// The maximum number of results to return for each paginated request. If not specified, the default value is 10.
    public var maxResults: Swift.Int?
    /// The token to be used for the next set of paginated results.
    public var nextToken: Swift.String?
    /// The alias that identifies the property, such as an OPC-UA server data stream path (for example, /company/windfarm/3/turbine/7/temperature). For more information, see [Mapping industrial data streams to asset properties](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/connect-data-streams.html) in the IoT SiteWise User Guide.
    public var propertyAlias: Swift.String?
    /// The ID of the asset property, in UUID format.
    public var propertyId: Swift.String?
    /// The quality of the asset property value. You can use this parameter as a filter to choose only the asset property values that have a specific quality.
    /// This member is required.
    public var quality: IoTSiteWiseClientTypes.Quality?
    /// The exclusive start of the range from which to interpolate data, expressed in seconds in Unix epoch time.
    /// This member is required.
    public var startTimeInSeconds: Swift.Int?
    /// The nanosecond offset converted from startTimeInSeconds.
    public var startTimeOffsetInNanos: Swift.Int?
    /// The interpolation type. Valid values: LINEAR_INTERPOLATION | LOCF_INTERPOLATION
    ///
    /// * LINEAR_INTERPOLATION – Estimates missing data using [linear interpolation](https://en.wikipedia.org/wiki/Linear_interpolation). For example, you can use this operation to return the interpolated temperature values for a wind turbine every 24 hours over a duration of 7 days. If the interpolation starts July 1, 2021, at 9 AM, IoT SiteWise returns the first interpolated value on July 2, 2021, at 9 AM, the second interpolated value on July 3, 2021, at 9 AM, and so on.
    ///
    /// * LOCF_INTERPOLATION – Estimates missing data using last observation carried forward interpolation If no data point is found for an interval, IoT SiteWise returns the last observed data point for the previous interval and carries forward this interpolated value until a new data point is found. For example, you can get the state of an on-off valve every 24 hours over a duration of 7 days. If the interpolation starts July 1, 2021, at 9 AM, IoT SiteWise returns the last observed data point between July 1, 2021, at 9 AM and July 2, 2021, at 9 AM as the first interpolated value. If a data point isn't found after 9 AM on July 2, 2021, IoT SiteWise uses the same interpolated value for the rest of the days.
    /// This member is required.
    public var type: Swift.String?

    public init(
        assetId: Swift.String? = nil,
        endTimeInSeconds: Swift.Int? = nil,
        endTimeOffsetInNanos: Swift.Int? = nil,
        intervalInSeconds: Swift.Int? = nil,
        intervalWindowInSeconds: Swift.Int? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        propertyAlias: Swift.String? = nil,
        propertyId: Swift.String? = nil,
        quality: IoTSiteWiseClientTypes.Quality? = nil,
        startTimeInSeconds: Swift.Int? = nil,
        startTimeOffsetInNanos: Swift.Int? = nil,
        type: Swift.String? = nil
    )
    {
        self.assetId = assetId
        self.endTimeInSeconds = endTimeInSeconds
        self.endTimeOffsetInNanos = endTimeOffsetInNanos
        self.intervalInSeconds = intervalInSeconds
        self.intervalWindowInSeconds = intervalWindowInSeconds
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.propertyAlias = propertyAlias
        self.propertyId = propertyId
        self.quality = quality
        self.startTimeInSeconds = startTimeInSeconds
        self.startTimeOffsetInNanos = startTimeOffsetInNanos
        self.type = type
    }
}

extension IoTSiteWiseClientTypes {

    /// Contains information about an interpolated asset property value.
    public struct InterpolatedAssetPropertyValue: Swift.Sendable {
        /// Contains a timestamp with optional nanosecond granularity.
        /// This member is required.
        public var timestamp: IoTSiteWiseClientTypes.TimeInNanos?
        /// Contains an asset property value (of a single type only).
        /// This member is required.
        public var value: IoTSiteWiseClientTypes.Variant?

        public init(
            timestamp: IoTSiteWiseClientTypes.TimeInNanos? = nil,
            value: IoTSiteWiseClientTypes.Variant? = nil
        )
        {
            self.timestamp = timestamp
            self.value = value
        }
    }
}

public struct GetInterpolatedAssetPropertyValuesOutput: Swift.Sendable {
    /// The requested interpolated values.
    /// This member is required.
    public var interpolatedAssetPropertyValues: [IoTSiteWiseClientTypes.InterpolatedAssetPropertyValue]?
    /// The token for the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?

    public init(
        interpolatedAssetPropertyValues: [IoTSiteWiseClientTypes.InterpolatedAssetPropertyValue]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.interpolatedAssetPropertyValues = interpolatedAssetPropertyValues
        self.nextToken = nextToken
    }
}

extension IoTSiteWiseClientTypes {

    public enum IdentityType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case group
        case iam
        case user
        case sdkUnknown(Swift.String)

        public static var allCases: [IdentityType] {
            return [
                .group,
                .iam,
                .user
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .group: return "GROUP"
            case .iam: return "IAM"
            case .user: return "USER"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension IoTSiteWiseClientTypes {

    public enum ResourceType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case portal
        case project
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceType] {
            return [
                .portal,
                .project
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .portal: return "PORTAL"
            case .project: return "PROJECT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct ListAccessPoliciesInput: Swift.Sendable {
    /// The ARN of the IAM user. For more information, see [IAM ARNs](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_identifiers.html) in the IAM User Guide. This parameter is required if you specify IAM for identityType.
    public var iamArn: Swift.String?
    /// The ID of the identity. This parameter is required if you specify USER or GROUP for identityType.
    public var identityId: Swift.String?
    /// The type of identity (IAM Identity Center user, IAM Identity Center group, or IAM user). This parameter is required if you specify identityId.
    public var identityType: IoTSiteWiseClientTypes.IdentityType?
    /// The maximum number of results to return for each paginated request. Default: 50
    public var maxResults: Swift.Int?
    /// The token to be used for the next set of paginated results.
    public var nextToken: Swift.String?
    /// The ID of the resource. This parameter is required if you specify resourceType.
    public var resourceId: Swift.String?
    /// The type of resource (portal or project). This parameter is required if you specify resourceId.
    public var resourceType: IoTSiteWiseClientTypes.ResourceType?

    public init(
        iamArn: Swift.String? = nil,
        identityId: Swift.String? = nil,
        identityType: IoTSiteWiseClientTypes.IdentityType? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: IoTSiteWiseClientTypes.ResourceType? = nil
    )
    {
        self.iamArn = iamArn
        self.identityId = identityId
        self.identityType = identityType
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceId = resourceId
        self.resourceType = resourceType
    }
}

public struct ListAccessPoliciesOutput: Swift.Sendable {
    /// A list that summarizes each access policy.
    /// This member is required.
    public var accessPolicySummaries: [IoTSiteWiseClientTypes.AccessPolicySummary]?
    /// The token for the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?

    public init(
        accessPolicySummaries: [IoTSiteWiseClientTypes.AccessPolicySummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.accessPolicySummaries = accessPolicySummaries
        self.nextToken = nextToken
    }
}

extension IoTSiteWiseClientTypes {

    public enum TargetResourceType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case asset
        case sdkUnknown(Swift.String)

        public static var allCases: [TargetResourceType] {
            return [
                .asset
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .asset: return "ASSET"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct ListActionsInput: Swift.Sendable {
    /// The maximum number of results to return for each paginated request.
    public var maxResults: Swift.Int?
    /// The token to be used for the next set of paginated results.
    public var nextToken: Swift.String?
    /// The ID of the target resource.
    /// This member is required.
    public var targetResourceId: Swift.String?
    /// The type of resource.
    /// This member is required.
    public var targetResourceType: IoTSiteWiseClientTypes.TargetResourceType?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        targetResourceId: Swift.String? = nil,
        targetResourceType: IoTSiteWiseClientTypes.TargetResourceType? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.targetResourceId = targetResourceId
        self.targetResourceType = targetResourceType
    }
}

public struct ListActionsOutput: Swift.Sendable {
    /// A list that summarizes the actions associated with the specified asset.
    /// This member is required.
    public var actionSummaries: [IoTSiteWiseClientTypes.ActionSummary]?
    /// The token for the next set of results, or null if there are no additional results.
    /// This member is required.
    public var nextToken: Swift.String?

    public init(
        actionSummaries: [IoTSiteWiseClientTypes.ActionSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.actionSummaries = actionSummaries
        self.nextToken = nextToken
    }
}

public struct ListAssetModelCompositeModelsInput: Swift.Sendable {
    /// The ID of the asset model. This can be either the actual ID in UUID format, or else externalId: followed by the external ID, if it has one. For more information, see [Referencing objects with external IDs](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/object-ids.html#external-id-references) in the IoT SiteWise User Guide.
    /// This member is required.
    public var assetModelId: Swift.String?
    /// The version alias that specifies the latest or active version of the asset model. The details are returned in the response. The default value is LATEST. See [ Asset model versions](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/model-active-version.html) in the IoT SiteWise User Guide.
    public var assetModelVersion: Swift.String?
    /// The maximum number of results to return for each paginated request. Default: 50
    public var maxResults: Swift.Int?
    /// The token to be used for the next set of paginated results.
    public var nextToken: Swift.String?

    public init(
        assetModelId: Swift.String? = nil,
        assetModelVersion: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.assetModelId = assetModelId
        self.assetModelVersion = assetModelVersion
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListAssetModelCompositeModelsOutput: Swift.Sendable {
    /// A list that summarizes each composite model.
    /// This member is required.
    public var assetModelCompositeModelSummaries: [IoTSiteWiseClientTypes.AssetModelCompositeModelSummary]?
    /// The token for the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?

    public init(
        assetModelCompositeModelSummaries: [IoTSiteWiseClientTypes.AssetModelCompositeModelSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.assetModelCompositeModelSummaries = assetModelCompositeModelSummaries
        self.nextToken = nextToken
    }
}

extension IoTSiteWiseClientTypes {

    public enum ListAssetModelPropertiesFilter: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case all
        case base
        case sdkUnknown(Swift.String)

        public static var allCases: [ListAssetModelPropertiesFilter] {
            return [
                .all,
                .base
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .all: return "ALL"
            case .base: return "BASE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct ListAssetModelPropertiesInput: Swift.Sendable {
    /// The ID of the asset model. This can be either the actual ID in UUID format, or else externalId: followed by the external ID, if it has one. For more information, see [Referencing objects with external IDs](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/object-ids.html#external-id-references) in the IoT SiteWise User Guide.
    /// This member is required.
    public var assetModelId: Swift.String?
    /// The version alias that specifies the latest or active version of the asset model. The details are returned in the response. The default value is LATEST. See [ Asset model versions](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/model-active-version.html) in the IoT SiteWise User Guide.
    public var assetModelVersion: Swift.String?
    /// Filters the requested list of asset model properties. You can choose one of the following options:
    ///
    /// * ALL – The list includes all asset model properties for a given asset model ID.
    ///
    /// * BASE – The list includes only base asset model properties for a given asset model ID.
    ///
    ///
    /// Default: BASE
    public var filter: IoTSiteWiseClientTypes.ListAssetModelPropertiesFilter?
    /// The maximum number of results to return for each paginated request. If not specified, the default value is 50.
    public var maxResults: Swift.Int?
    /// The token to be used for the next set of paginated results.
    public var nextToken: Swift.String?

    public init(
        assetModelId: Swift.String? = nil,
        assetModelVersion: Swift.String? = nil,
        filter: IoTSiteWiseClientTypes.ListAssetModelPropertiesFilter? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.assetModelId = assetModelId
        self.assetModelVersion = assetModelVersion
        self.filter = filter
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListAssetModelPropertiesOutput: Swift.Sendable {
    /// A list that summarizes the properties associated with the specified asset model.
    /// This member is required.
    public var assetModelPropertySummaries: [IoTSiteWiseClientTypes.AssetModelPropertySummary]?
    /// The token for the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?

    public init(
        assetModelPropertySummaries: [IoTSiteWiseClientTypes.AssetModelPropertySummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.assetModelPropertySummaries = assetModelPropertySummaries
        self.nextToken = nextToken
    }
}

public struct ListAssetModelsInput: Swift.Sendable {
    /// The type of asset model. If you don't provide an assetModelTypes, all types of asset models are returned.
    ///
    /// * ASSET_MODEL – An asset model that you can use to create assets. Can't be included as a component in another asset model.
    ///
    /// * COMPONENT_MODEL – A reusable component that you can include in the composite models of other asset models. You can't create assets directly from this type of asset model.
    public var assetModelTypes: [IoTSiteWiseClientTypes.AssetModelType]?
    /// The version alias that specifies the latest or active version of the asset model. The details are returned in the response. The default value is LATEST. See [ Asset model versions](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/model-active-version.html) in the IoT SiteWise User Guide.
    public var assetModelVersion: Swift.String?
    /// The maximum number of results to return for each paginated request. Default: 50
    public var maxResults: Swift.Int?
    /// The token to be used for the next set of paginated results.
    public var nextToken: Swift.String?

    public init(
        assetModelTypes: [IoTSiteWiseClientTypes.AssetModelType]? = nil,
        assetModelVersion: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.assetModelTypes = assetModelTypes
        self.assetModelVersion = assetModelVersion
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListAssetModelsOutput: Swift.Sendable {
    /// A list that summarizes each asset model.
    /// This member is required.
    public var assetModelSummaries: [IoTSiteWiseClientTypes.AssetModelSummary]?
    /// The token for the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?

    public init(
        assetModelSummaries: [IoTSiteWiseClientTypes.AssetModelSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.assetModelSummaries = assetModelSummaries
        self.nextToken = nextToken
    }
}

extension IoTSiteWiseClientTypes {

    public enum ListAssetPropertiesFilter: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case all
        case base
        case sdkUnknown(Swift.String)

        public static var allCases: [ListAssetPropertiesFilter] {
            return [
                .all,
                .base
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .all: return "ALL"
            case .base: return "BASE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct ListAssetPropertiesInput: Swift.Sendable {
    /// The ID of the asset. This can be either the actual ID in UUID format, or else externalId: followed by the external ID, if it has one. For more information, see [Referencing objects with external IDs](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/object-ids.html#external-id-references) in the IoT SiteWise User Guide.
    /// This member is required.
    public var assetId: Swift.String?
    /// Filters the requested list of asset properties. You can choose one of the following options:
    ///
    /// * ALL – The list includes all asset properties for a given asset model ID.
    ///
    /// * BASE – The list includes only base asset properties for a given asset model ID.
    ///
    ///
    /// Default: BASE
    public var filter: IoTSiteWiseClientTypes.ListAssetPropertiesFilter?
    /// The maximum number of results to return for each paginated request. If not specified, the default value is 50.
    public var maxResults: Swift.Int?
    /// The token to be used for the next set of paginated results.
    public var nextToken: Swift.String?

    public init(
        assetId: Swift.String? = nil,
        filter: IoTSiteWiseClientTypes.ListAssetPropertiesFilter? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.assetId = assetId
        self.filter = filter
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListAssetPropertiesOutput: Swift.Sendable {
    /// A list that summarizes the properties associated with the specified asset.
    /// This member is required.
    public var assetPropertySummaries: [IoTSiteWiseClientTypes.AssetPropertySummary]?
    /// The token for the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?

    public init(
        assetPropertySummaries: [IoTSiteWiseClientTypes.AssetPropertySummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.assetPropertySummaries = assetPropertySummaries
        self.nextToken = nextToken
    }
}

extension IoTSiteWiseClientTypes {

    public enum TraversalType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case pathToRoot
        case sdkUnknown(Swift.String)

        public static var allCases: [TraversalType] {
            return [
                .pathToRoot
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .pathToRoot: return "PATH_TO_ROOT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct ListAssetRelationshipsInput: Swift.Sendable {
    /// The ID of the asset. This can be either the actual ID in UUID format, or else externalId: followed by the external ID, if it has one. For more information, see [Referencing objects with external IDs](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/object-ids.html#external-id-references) in the IoT SiteWise User Guide.
    /// This member is required.
    public var assetId: Swift.String?
    /// The maximum number of results to return for each paginated request.
    public var maxResults: Swift.Int?
    /// The token to be used for the next set of paginated results.
    public var nextToken: Swift.String?
    /// The type of traversal to use to identify asset relationships. Choose the following option:
    ///
    /// * PATH_TO_ROOT – Identify the asset's parent assets up to the root asset. The asset that you specify in assetId is the first result in the list of assetRelationshipSummaries, and the root asset is the last result.
    /// This member is required.
    public var traversalType: IoTSiteWiseClientTypes.TraversalType?

    public init(
        assetId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        traversalType: IoTSiteWiseClientTypes.TraversalType? = nil
    )
    {
        self.assetId = assetId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.traversalType = traversalType
    }
}

public struct ListAssetRelationshipsOutput: Swift.Sendable {
    /// A list that summarizes each asset relationship.
    /// This member is required.
    public var assetRelationshipSummaries: [IoTSiteWiseClientTypes.AssetRelationshipSummary]?
    /// The token for the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?

    public init(
        assetRelationshipSummaries: [IoTSiteWiseClientTypes.AssetRelationshipSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.assetRelationshipSummaries = assetRelationshipSummaries
        self.nextToken = nextToken
    }
}

extension IoTSiteWiseClientTypes {

    public enum ListAssetsFilter: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case all
        case topLevel
        case sdkUnknown(Swift.String)

        public static var allCases: [ListAssetsFilter] {
            return [
                .all,
                .topLevel
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .all: return "ALL"
            case .topLevel: return "TOP_LEVEL"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct ListAssetsInput: Swift.Sendable {
    /// The ID of the asset model by which to filter the list of assets. This parameter is required if you choose ALL for filter. This can be either the actual ID in UUID format, or else externalId: followed by the external ID, if it has one. For more information, see [Referencing objects with external IDs](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/object-ids.html#external-id-references) in the IoT SiteWise User Guide.
    public var assetModelId: Swift.String?
    /// The filter for the requested list of assets. Choose one of the following options:
    ///
    /// * ALL – The list includes all assets for a given asset model ID. The assetModelId parameter is required if you filter by ALL.
    ///
    /// * TOP_LEVEL – The list includes only top-level assets in the asset hierarchy tree.
    ///
    ///
    /// Default: ALL
    public var filter: IoTSiteWiseClientTypes.ListAssetsFilter?
    /// The maximum number of results to return for each paginated request. Default: 50
    public var maxResults: Swift.Int?
    /// The token to be used for the next set of paginated results.
    public var nextToken: Swift.String?

    public init(
        assetModelId: Swift.String? = nil,
        filter: IoTSiteWiseClientTypes.ListAssetsFilter? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.assetModelId = assetModelId
        self.filter = filter
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListAssetsOutput: Swift.Sendable {
    /// A list that summarizes each asset.
    /// This member is required.
    public var assetSummaries: [IoTSiteWiseClientTypes.AssetSummary]?
    /// The token for the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?

    public init(
        assetSummaries: [IoTSiteWiseClientTypes.AssetSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.assetSummaries = assetSummaries
        self.nextToken = nextToken
    }
}

extension IoTSiteWiseClientTypes {

    public enum TraversalDirection: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case child
        case parent
        case sdkUnknown(Swift.String)

        public static var allCases: [TraversalDirection] {
            return [
                .child,
                .parent
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .child: return "CHILD"
            case .parent: return "PARENT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct ListAssociatedAssetsInput: Swift.Sendable {
    /// The ID of the asset to query. This can be either the actual ID in UUID format, or else externalId: followed by the external ID, if it has one. For more information, see [Referencing objects with external IDs](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/object-ids.html#external-id-references) in the IoT SiteWise User Guide.
    /// This member is required.
    public var assetId: Swift.String?
    /// (Optional) If you don't provide a hierarchyId, all the immediate assets in the traversalDirection will be returned. The ID of the hierarchy by which child assets are associated to the asset. (This can be either the actual ID in UUID format, or else externalId: followed by the external ID, if it has one. For more information, see [Referencing objects with external IDs](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/object-ids.html#external-id-references) in the IoT SiteWise User Guide.) For more information, see [Asset hierarchies](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/asset-hierarchies.html) in the IoT SiteWise User Guide.
    public var hierarchyId: Swift.String?
    /// The maximum number of results to return for each paginated request. Default: 50
    public var maxResults: Swift.Int?
    /// The token to be used for the next set of paginated results.
    public var nextToken: Swift.String?
    /// The direction to list associated assets. Choose one of the following options:
    ///
    /// * CHILD – The list includes all child assets associated to the asset.
    ///
    /// * PARENT – The list includes the asset's parent asset.
    ///
    ///
    /// Default: CHILD
    public var traversalDirection: IoTSiteWiseClientTypes.TraversalDirection?

    public init(
        assetId: Swift.String? = nil,
        hierarchyId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        traversalDirection: IoTSiteWiseClientTypes.TraversalDirection? = nil
    )
    {
        self.assetId = assetId
        self.hierarchyId = hierarchyId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.traversalDirection = traversalDirection
    }
}

public struct ListAssociatedAssetsOutput: Swift.Sendable {
    /// A list that summarizes the associated assets.
    /// This member is required.
    public var assetSummaries: [IoTSiteWiseClientTypes.AssociatedAssetsSummary]?
    /// The token for the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?

    public init(
        assetSummaries: [IoTSiteWiseClientTypes.AssociatedAssetsSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.assetSummaries = assetSummaries
        self.nextToken = nextToken
    }
}

extension IoTSiteWiseClientTypes {

    public enum ListBulkImportJobsFilter: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case all
        case cancelled
        case completed
        case completedWithFailures
        case failed
        case pending
        case running
        case sdkUnknown(Swift.String)

        public static var allCases: [ListBulkImportJobsFilter] {
            return [
                .all,
                .cancelled,
                .completed,
                .completedWithFailures,
                .failed,
                .pending,
                .running
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .all: return "ALL"
            case .cancelled: return "CANCELLED"
            case .completed: return "COMPLETED"
            case .completedWithFailures: return "COMPLETED_WITH_FAILURES"
            case .failed: return "FAILED"
            case .pending: return "PENDING"
            case .running: return "RUNNING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct ListBulkImportJobsInput: Swift.Sendable {
    /// You can use a filter to select the bulk import jobs that you want to retrieve.
    public var filter: IoTSiteWiseClientTypes.ListBulkImportJobsFilter?
    /// The maximum number of results to return for each paginated request.
    public var maxResults: Swift.Int?
    /// The token to be used for the next set of paginated results.
    public var nextToken: Swift.String?

    public init(
        filter: IoTSiteWiseClientTypes.ListBulkImportJobsFilter? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filter = filter
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension IoTSiteWiseClientTypes {

    /// Contains the job summary information.
    public struct JobSummary: Swift.Sendable {
        /// The ID of the job.
        /// This member is required.
        public var id: Swift.String?
        /// The unique name that helps identify the job request.
        /// This member is required.
        public var name: Swift.String?
        /// The status of the bulk import job can be one of following values:
        ///
        /// * PENDING – IoT SiteWise is waiting for the current bulk import job to finish.
        ///
        /// * CANCELLED – The bulk import job has been canceled.
        ///
        /// * RUNNING – IoT SiteWise is processing your request to import your data from Amazon S3.
        ///
        /// * COMPLETED – IoT SiteWise successfully completed your request to import data from Amazon S3.
        ///
        /// * FAILED – IoT SiteWise couldn't process your request to import data from Amazon S3. You can use logs saved in the specified error report location in Amazon S3 to troubleshoot issues.
        ///
        /// * COMPLETED_WITH_FAILURES – IoT SiteWise completed your request to import data from Amazon S3 with errors. You can use logs saved in the specified error report location in Amazon S3 to troubleshoot issues.
        /// This member is required.
        public var status: IoTSiteWiseClientTypes.JobStatus?

        public init(
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            status: IoTSiteWiseClientTypes.JobStatus? = nil
        )
        {
            self.id = id
            self.name = name
            self.status = status
        }
    }
}

public struct ListBulkImportJobsOutput: Swift.Sendable {
    /// One or more job summaries to list.
    /// This member is required.
    public var jobSummaries: [IoTSiteWiseClientTypes.JobSummary]?
    /// The token for the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?

    public init(
        jobSummaries: [IoTSiteWiseClientTypes.JobSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.jobSummaries = jobSummaries
        self.nextToken = nextToken
    }
}

public struct ListCompositionRelationshipsInput: Swift.Sendable {
    /// The ID of the asset model. This can be either the actual ID in UUID format, or else externalId: followed by the external ID, if it has one. For more information, see [Referencing objects with external IDs](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/object-ids.html#external-id-references) in the IoT SiteWise User Guide.
    /// This member is required.
    public var assetModelId: Swift.String?
    /// The maximum number of results to return for each paginated request. Default: 50
    public var maxResults: Swift.Int?
    /// The token to be used for the next set of paginated results.
    public var nextToken: Swift.String?

    public init(
        assetModelId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.assetModelId = assetModelId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension IoTSiteWiseClientTypes {

    /// Contains a summary of the components of the composite model.
    public struct CompositionRelationshipSummary: Swift.Sendable {
        /// The ID of a composite model on this asset model.
        /// This member is required.
        public var assetModelCompositeModelId: Swift.String?
        /// The composite model type. Valid values are AWS/ALARM, CUSTOM, or  AWS/L4E_ANOMALY.
        /// This member is required.
        public var assetModelCompositeModelType: Swift.String?
        /// The ID of the asset model, in UUID format.
        /// This member is required.
        public var assetModelId: Swift.String?

        public init(
            assetModelCompositeModelId: Swift.String? = nil,
            assetModelCompositeModelType: Swift.String? = nil,
            assetModelId: Swift.String? = nil
        )
        {
            self.assetModelCompositeModelId = assetModelCompositeModelId
            self.assetModelCompositeModelType = assetModelCompositeModelType
            self.assetModelId = assetModelId
        }
    }
}

public struct ListCompositionRelationshipsOutput: Swift.Sendable {
    /// A list that summarizes each composition relationship.
    /// This member is required.
    public var compositionRelationshipSummaries: [IoTSiteWiseClientTypes.CompositionRelationshipSummary]?
    /// The token for the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?

    public init(
        compositionRelationshipSummaries: [IoTSiteWiseClientTypes.CompositionRelationshipSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.compositionRelationshipSummaries = compositionRelationshipSummaries
        self.nextToken = nextToken
    }
}

public struct ListDashboardsInput: Swift.Sendable {
    /// The maximum number of results to return for each paginated request. Default: 50
    public var maxResults: Swift.Int?
    /// The token to be used for the next set of paginated results.
    public var nextToken: Swift.String?
    /// The ID of the project.
    /// This member is required.
    public var projectId: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        projectId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.projectId = projectId
    }
}

extension IoTSiteWiseClientTypes {

    /// Contains a dashboard summary.
    public struct DashboardSummary: Swift.Sendable {
        /// The date the dashboard was created, in Unix epoch time.
        public var creationDate: Foundation.Date?
        /// The dashboard's description.
        public var description: Swift.String?
        /// The ID of the dashboard.
        /// This member is required.
        public var id: Swift.String?
        /// The date the dashboard was last updated, in Unix epoch time.
        public var lastUpdateDate: Foundation.Date?
        /// The name of the dashboard
        /// This member is required.
        public var name: Swift.String?

        public init(
            creationDate: Foundation.Date? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            lastUpdateDate: Foundation.Date? = nil,
            name: Swift.String? = nil
        )
        {
            self.creationDate = creationDate
            self.description = description
            self.id = id
            self.lastUpdateDate = lastUpdateDate
            self.name = name
        }
    }
}

public struct ListDashboardsOutput: Swift.Sendable {
    /// A list that summarizes each dashboard in the project.
    /// This member is required.
    public var dashboardSummaries: [IoTSiteWiseClientTypes.DashboardSummary]?
    /// The token for the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?

    public init(
        dashboardSummaries: [IoTSiteWiseClientTypes.DashboardSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.dashboardSummaries = dashboardSummaries
        self.nextToken = nextToken
    }
}

public struct ListGatewaysInput: Swift.Sendable {
    /// The maximum number of results to return for each paginated request. Default: 50
    public var maxResults: Swift.Int?
    /// The token to be used for the next set of paginated results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension IoTSiteWiseClientTypes {

    /// Contains a summary of a gateway.
    public struct GatewaySummary: Swift.Sendable {
        /// The date the gateway was created, in Unix epoch time.
        /// This member is required.
        public var creationDate: Foundation.Date?
        /// A list of gateway capability summaries that each contain a namespace and status. Each gateway capability defines data sources for the gateway. To retrieve a capability configuration's definition, use [DescribeGatewayCapabilityConfiguration](https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_DescribeGatewayCapabilityConfiguration.html).
        public var gatewayCapabilitySummaries: [IoTSiteWiseClientTypes.GatewayCapabilitySummary]?
        /// The ID of the gateway device.
        /// This member is required.
        public var gatewayId: Swift.String?
        /// The name of the gateway.
        /// This member is required.
        public var gatewayName: Swift.String?
        /// Contains a gateway's platform information.
        public var gatewayPlatform: IoTSiteWiseClientTypes.GatewayPlatform?
        /// The date the gateway was last updated, in Unix epoch time.
        /// This member is required.
        public var lastUpdateDate: Foundation.Date?

        public init(
            creationDate: Foundation.Date? = nil,
            gatewayCapabilitySummaries: [IoTSiteWiseClientTypes.GatewayCapabilitySummary]? = nil,
            gatewayId: Swift.String? = nil,
            gatewayName: Swift.String? = nil,
            gatewayPlatform: IoTSiteWiseClientTypes.GatewayPlatform? = nil,
            lastUpdateDate: Foundation.Date? = nil
        )
        {
            self.creationDate = creationDate
            self.gatewayCapabilitySummaries = gatewayCapabilitySummaries
            self.gatewayId = gatewayId
            self.gatewayName = gatewayName
            self.gatewayPlatform = gatewayPlatform
            self.lastUpdateDate = lastUpdateDate
        }
    }
}

public struct ListGatewaysOutput: Swift.Sendable {
    /// A list that summarizes each gateway.
    /// This member is required.
    public var gatewaySummaries: [IoTSiteWiseClientTypes.GatewaySummary]?
    /// The token for the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?

    public init(
        gatewaySummaries: [IoTSiteWiseClientTypes.GatewaySummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.gatewaySummaries = gatewaySummaries
        self.nextToken = nextToken
    }
}

public struct ListPortalsInput: Swift.Sendable {
    /// The maximum number of results to return for each paginated request. Default: 50
    public var maxResults: Swift.Int?
    /// The token to be used for the next set of paginated results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension IoTSiteWiseClientTypes {

    /// Contains a portal summary.
    public struct PortalSummary: Swift.Sendable {
        /// The date the portal was created, in Unix epoch time.
        public var creationDate: Foundation.Date?
        /// The portal's description.
        public var description: Swift.String?
        /// The ID of the portal.
        /// This member is required.
        public var id: Swift.String?
        /// The date the portal was last updated, in Unix epoch time.
        public var lastUpdateDate: Foundation.Date?
        /// The name of the portal.
        /// This member is required.
        public var name: Swift.String?
        /// The [ARN](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the service role that allows the portal's users to access your IoT SiteWise resources on your behalf. For more information, see [Using service roles for IoT SiteWise Monitor](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/monitor-service-role.html) in the IoT SiteWise User Guide.
        public var roleArn: Swift.String?
        /// The URL for the IoT SiteWise Monitor portal. You can use this URL to access portals that use IAM Identity Center for authentication. For portals that use IAM for authentication, you must use the IoT SiteWise console to get a URL that you can use to access the portal.
        /// This member is required.
        public var startUrl: Swift.String?
        /// Contains information about the current status of a portal.
        /// This member is required.
        public var status: IoTSiteWiseClientTypes.PortalStatus?

        public init(
            creationDate: Foundation.Date? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            lastUpdateDate: Foundation.Date? = nil,
            name: Swift.String? = nil,
            roleArn: Swift.String? = nil,
            startUrl: Swift.String? = nil,
            status: IoTSiteWiseClientTypes.PortalStatus? = nil
        )
        {
            self.creationDate = creationDate
            self.description = description
            self.id = id
            self.lastUpdateDate = lastUpdateDate
            self.name = name
            self.roleArn = roleArn
            self.startUrl = startUrl
            self.status = status
        }
    }
}

public struct ListPortalsOutput: Swift.Sendable {
    /// The token for the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?
    /// A list that summarizes each portal.
    public var portalSummaries: [IoTSiteWiseClientTypes.PortalSummary]?

    public init(
        nextToken: Swift.String? = nil,
        portalSummaries: [IoTSiteWiseClientTypes.PortalSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.portalSummaries = portalSummaries
    }
}

public struct ListProjectAssetsInput: Swift.Sendable {
    /// The maximum number of results to return for each paginated request. Default: 50
    public var maxResults: Swift.Int?
    /// The token to be used for the next set of paginated results.
    public var nextToken: Swift.String?
    /// The ID of the project.
    /// This member is required.
    public var projectId: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        projectId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.projectId = projectId
    }
}

public struct ListProjectAssetsOutput: Swift.Sendable {
    /// A list that contains the IDs of each asset associated with the project.
    /// This member is required.
    public var assetIds: [Swift.String]?
    /// The token for the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?

    public init(
        assetIds: [Swift.String]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.assetIds = assetIds
        self.nextToken = nextToken
    }
}

public struct ListProjectsInput: Swift.Sendable {
    /// The maximum number of results to return for each paginated request. Default: 50
    public var maxResults: Swift.Int?
    /// The token to be used for the next set of paginated results.
    public var nextToken: Swift.String?
    /// The ID of the portal.
    /// This member is required.
    public var portalId: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        portalId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.portalId = portalId
    }
}

extension IoTSiteWiseClientTypes {

    /// Contains project summary information.
    public struct ProjectSummary: Swift.Sendable {
        /// The date the project was created, in Unix epoch time.
        public var creationDate: Foundation.Date?
        /// The project's description.
        public var description: Swift.String?
        /// The ID of the project.
        /// This member is required.
        public var id: Swift.String?
        /// The date the project was last updated, in Unix epoch time.
        public var lastUpdateDate: Foundation.Date?
        /// The name of the project.
        /// This member is required.
        public var name: Swift.String?

        public init(
            creationDate: Foundation.Date? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            lastUpdateDate: Foundation.Date? = nil,
            name: Swift.String? = nil
        )
        {
            self.creationDate = creationDate
            self.description = description
            self.id = id
            self.lastUpdateDate = lastUpdateDate
            self.name = name
        }
    }
}

public struct ListProjectsOutput: Swift.Sendable {
    /// The token for the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?
    /// A list that summarizes each project in the portal.
    /// This member is required.
    public var projectSummaries: [IoTSiteWiseClientTypes.ProjectSummary]?

    public init(
        nextToken: Swift.String? = nil,
        projectSummaries: [IoTSiteWiseClientTypes.ProjectSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.projectSummaries = projectSummaries
    }
}

/// You are not authorized.
public struct UnauthorizedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "UnauthorizedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct ListTagsForResourceInput: Swift.Sendable {
    /// The [ARN](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

public struct ListTagsForResourceOutput: Swift.Sendable {
    /// The list of key-value pairs that contain metadata for the resource. For more information, see [Tagging your IoT SiteWise resources](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/tag-resources.html) in the IoT SiteWise User Guide.
    public var tags: [Swift.String: Swift.String]?

    public init(
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

extension IoTSiteWiseClientTypes {

    public enum ListTimeSeriesType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case associated
        case disassociated
        case sdkUnknown(Swift.String)

        public static var allCases: [ListTimeSeriesType] {
            return [
                .associated,
                .disassociated
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .associated: return "ASSOCIATED"
            case .disassociated: return "DISASSOCIATED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct ListTimeSeriesInput: Swift.Sendable {
    /// The alias prefix of the time series.
    public var aliasPrefix: Swift.String?
    /// The ID of the asset in which the asset property was created. This can be either the actual ID in UUID format, or else externalId: followed by the external ID, if it has one. For more information, see [Referencing objects with external IDs](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/object-ids.html#external-id-references) in the IoT SiteWise User Guide.
    public var assetId: Swift.String?
    /// The maximum number of results to return for each paginated request.
    public var maxResults: Swift.Int?
    /// The token to be used for the next set of paginated results.
    public var nextToken: Swift.String?
    /// The type of the time series. The time series type can be one of the following values:
    ///
    /// * ASSOCIATED – The time series is associated with an asset property.
    ///
    /// * DISASSOCIATED – The time series isn't associated with any asset property.
    public var timeSeriesType: IoTSiteWiseClientTypes.ListTimeSeriesType?

    public init(
        aliasPrefix: Swift.String? = nil,
        assetId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        timeSeriesType: IoTSiteWiseClientTypes.ListTimeSeriesType? = nil
    )
    {
        self.aliasPrefix = aliasPrefix
        self.assetId = assetId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.timeSeriesType = timeSeriesType
    }
}

extension IoTSiteWiseClientTypes {

    /// Contains a summary of a time series (data stream).
    public struct TimeSeriesSummary: Swift.Sendable {
        /// The alias that identifies the time series.
        public var alias: Swift.String?
        /// The ID of the asset in which the asset property was created.
        public var assetId: Swift.String?
        /// The data type of the time series. If you specify STRUCT, you must also specify dataTypeSpec to identify the type of the structure for this time series.
        /// This member is required.
        public var dataType: IoTSiteWiseClientTypes.PropertyDataType?
        /// The data type of the structure for this time series. This parameter is required for time series that have the STRUCT data type. The options for this parameter depend on the type of the composite model in which you created the asset property that is associated with your time series. Use AWS/ALARM_STATE for alarm state in alarm composite models.
        public var dataTypeSpec: Swift.String?
        /// The ID of the asset property, in UUID format.
        public var propertyId: Swift.String?
        /// The [ARN](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the time series, which has the following format. arn:${Partition}:iotsitewise:${Region}:${Account}:time-series/${TimeSeriesId}
        /// This member is required.
        public var timeSeriesArn: Swift.String?
        /// The date that the time series was created, in Unix epoch time.
        /// This member is required.
        public var timeSeriesCreationDate: Foundation.Date?
        /// The ID of the time series.
        /// This member is required.
        public var timeSeriesId: Swift.String?
        /// The date that the time series was last updated, in Unix epoch time.
        /// This member is required.
        public var timeSeriesLastUpdateDate: Foundation.Date?

        public init(
            alias: Swift.String? = nil,
            assetId: Swift.String? = nil,
            dataType: IoTSiteWiseClientTypes.PropertyDataType? = nil,
            dataTypeSpec: Swift.String? = nil,
            propertyId: Swift.String? = nil,
            timeSeriesArn: Swift.String? = nil,
            timeSeriesCreationDate: Foundation.Date? = nil,
            timeSeriesId: Swift.String? = nil,
            timeSeriesLastUpdateDate: Foundation.Date? = nil
        )
        {
            self.alias = alias
            self.assetId = assetId
            self.dataType = dataType
            self.dataTypeSpec = dataTypeSpec
            self.propertyId = propertyId
            self.timeSeriesArn = timeSeriesArn
            self.timeSeriesCreationDate = timeSeriesCreationDate
            self.timeSeriesId = timeSeriesId
            self.timeSeriesLastUpdateDate = timeSeriesLastUpdateDate
        }
    }
}

public struct ListTimeSeriesOutput: Swift.Sendable {
    /// The token for the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?
    /// One or more time series summaries to list.
    /// This member is required.
    public var timeSeriesSummaries: [IoTSiteWiseClientTypes.TimeSeriesSummary]?

    public init(
        nextToken: Swift.String? = nil,
        timeSeriesSummaries: [IoTSiteWiseClientTypes.TimeSeriesSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.timeSeriesSummaries = timeSeriesSummaries
    }
}

public struct PutDefaultEncryptionConfigurationInput: Swift.Sendable {
    /// The type of encryption used for the encryption configuration.
    /// This member is required.
    public var encryptionType: IoTSiteWiseClientTypes.EncryptionType?
    /// The Key ID of the customer managed key used for KMS encryption. This is required if you use KMS_BASED_ENCRYPTION.
    public var kmsKeyId: Swift.String?

    public init(
        encryptionType: IoTSiteWiseClientTypes.EncryptionType? = nil,
        kmsKeyId: Swift.String? = nil
    )
    {
        self.encryptionType = encryptionType
        self.kmsKeyId = kmsKeyId
    }
}

public struct PutDefaultEncryptionConfigurationOutput: Swift.Sendable {
    /// The status of the account configuration. This contains the ConfigurationState. If there is an error, it also contains the ErrorDetails.
    /// This member is required.
    public var configurationStatus: IoTSiteWiseClientTypes.ConfigurationStatus?
    /// The type of encryption used for the encryption configuration.
    /// This member is required.
    public var encryptionType: IoTSiteWiseClientTypes.EncryptionType?
    /// The Key ARN of the KMS key used for KMS encryption if you use KMS_BASED_ENCRYPTION.
    public var kmsKeyArn: Swift.String?

    public init(
        configurationStatus: IoTSiteWiseClientTypes.ConfigurationStatus? = nil,
        encryptionType: IoTSiteWiseClientTypes.EncryptionType? = nil,
        kmsKeyArn: Swift.String? = nil
    )
    {
        self.configurationStatus = configurationStatus
        self.encryptionType = encryptionType
        self.kmsKeyArn = kmsKeyArn
    }
}

public struct PutLoggingOptionsInput: Swift.Sendable {
    /// The logging options to set.
    /// This member is required.
    public var loggingOptions: IoTSiteWiseClientTypes.LoggingOptions?

    public init(
        loggingOptions: IoTSiteWiseClientTypes.LoggingOptions? = nil
    )
    {
        self.loggingOptions = loggingOptions
    }
}

public struct PutLoggingOptionsOutput: Swift.Sendable {

    public init() { }
}

public struct PutStorageConfigurationInput: Swift.Sendable {
    /// Contains the storage configuration for time series (data streams) that aren't associated with asset properties. The disassociatedDataStorage can be one of the following values:
    ///
    /// * ENABLED – IoT SiteWise accepts time series that aren't associated with asset properties. After the disassociatedDataStorage is enabled, you can't disable it.
    ///
    /// * DISABLED – IoT SiteWise doesn't accept time series (data streams) that aren't associated with asset properties.
    ///
    ///
    /// For more information, see [Data streams](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/data-streams.html) in the IoT SiteWise User Guide.
    public var disassociatedDataStorage: IoTSiteWiseClientTypes.DisassociatedDataStorageState?
    /// Identifies a storage destination. If you specified MULTI_LAYER_STORAGE for the storage type, you must specify a MultiLayerStorage object.
    public var multiLayerStorage: IoTSiteWiseClientTypes.MultiLayerStorage?
    /// The number of days your data is kept in the hot tier. By default, your data is kept indefinitely in the hot tier.
    public var retentionPeriod: IoTSiteWiseClientTypes.RetentionPeriod?
    /// The storage tier that you specified for your data. The storageType parameter can be one of the following values:
    ///
    /// * SITEWISE_DEFAULT_STORAGE – IoT SiteWise saves your data into the hot tier. The hot tier is a service-managed database.
    ///
    /// * MULTI_LAYER_STORAGE – IoT SiteWise saves your data in both the cold tier and the hot tier. The cold tier is a customer-managed Amazon S3 bucket.
    /// This member is required.
    public var storageType: IoTSiteWiseClientTypes.StorageType?
    /// A service managed storage tier optimized for analytical queries. It stores periodically uploaded, buffered and historical data ingested with the CreaeBulkImportJob API.
    public var warmTier: IoTSiteWiseClientTypes.WarmTierState?
    /// Set this period to specify how long your data is stored in the warm tier before it is deleted. You can set this only if cold tier is enabled.
    public var warmTierRetentionPeriod: IoTSiteWiseClientTypes.WarmTierRetentionPeriod?

    public init(
        disassociatedDataStorage: IoTSiteWiseClientTypes.DisassociatedDataStorageState? = nil,
        multiLayerStorage: IoTSiteWiseClientTypes.MultiLayerStorage? = nil,
        retentionPeriod: IoTSiteWiseClientTypes.RetentionPeriod? = nil,
        storageType: IoTSiteWiseClientTypes.StorageType? = nil,
        warmTier: IoTSiteWiseClientTypes.WarmTierState? = nil,
        warmTierRetentionPeriod: IoTSiteWiseClientTypes.WarmTierRetentionPeriod? = nil
    )
    {
        self.disassociatedDataStorage = disassociatedDataStorage
        self.multiLayerStorage = multiLayerStorage
        self.retentionPeriod = retentionPeriod
        self.storageType = storageType
        self.warmTier = warmTier
        self.warmTierRetentionPeriod = warmTierRetentionPeriod
    }
}

public struct PutStorageConfigurationOutput: Swift.Sendable {
    /// Contains current status information for the configuration.
    /// This member is required.
    public var configurationStatus: IoTSiteWiseClientTypes.ConfigurationStatus?
    /// Contains the storage configuration for time series (data streams) that aren't associated with asset properties. The disassociatedDataStorage can be one of the following values:
    ///
    /// * ENABLED – IoT SiteWise accepts time series that aren't associated with asset properties. After the disassociatedDataStorage is enabled, you can't disable it.
    ///
    /// * DISABLED – IoT SiteWise doesn't accept time series (data streams) that aren't associated with asset properties.
    ///
    ///
    /// For more information, see [Data streams](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/data-streams.html) in the IoT SiteWise User Guide.
    public var disassociatedDataStorage: IoTSiteWiseClientTypes.DisassociatedDataStorageState?
    /// Contains information about the storage destination.
    public var multiLayerStorage: IoTSiteWiseClientTypes.MultiLayerStorage?
    /// The number of days your data is kept in the hot tier. By default, your data is kept indefinitely in the hot tier.
    public var retentionPeriod: IoTSiteWiseClientTypes.RetentionPeriod?
    /// The storage tier that you specified for your data. The storageType parameter can be one of the following values:
    ///
    /// * SITEWISE_DEFAULT_STORAGE – IoT SiteWise saves your data into the hot tier. The hot tier is a service-managed database.
    ///
    /// * MULTI_LAYER_STORAGE – IoT SiteWise saves your data in both the cold tier and the hot tier. The cold tier is a customer-managed Amazon S3 bucket.
    /// This member is required.
    public var storageType: IoTSiteWiseClientTypes.StorageType?
    /// A service managed storage tier optimized for analytical queries. It stores periodically uploaded, buffered and historical data ingested with the CreaeBulkImportJob API.
    public var warmTier: IoTSiteWiseClientTypes.WarmTierState?
    /// Set this period to specify how long your data is stored in the warm tier before it is deleted. You can set this only if cold tier is enabled.
    public var warmTierRetentionPeriod: IoTSiteWiseClientTypes.WarmTierRetentionPeriod?

    public init(
        configurationStatus: IoTSiteWiseClientTypes.ConfigurationStatus? = nil,
        disassociatedDataStorage: IoTSiteWiseClientTypes.DisassociatedDataStorageState? = nil,
        multiLayerStorage: IoTSiteWiseClientTypes.MultiLayerStorage? = nil,
        retentionPeriod: IoTSiteWiseClientTypes.RetentionPeriod? = nil,
        storageType: IoTSiteWiseClientTypes.StorageType? = nil,
        warmTier: IoTSiteWiseClientTypes.WarmTierState? = nil,
        warmTierRetentionPeriod: IoTSiteWiseClientTypes.WarmTierRetentionPeriod? = nil
    )
    {
        self.configurationStatus = configurationStatus
        self.disassociatedDataStorage = disassociatedDataStorage
        self.multiLayerStorage = multiLayerStorage
        self.retentionPeriod = retentionPeriod
        self.storageType = storageType
        self.warmTier = warmTier
        self.warmTierRetentionPeriod = warmTierRetentionPeriod
    }
}

/// You've reached the limit for the number of tags allowed for a resource. For more information, see [Tag naming limits and requirements](https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html#tag-conventions) in the Amazon Web Services General Reference.
public struct TooManyTagsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        /// The name of the resource with too many tags.
        public internal(set) var resourceName: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyTagsException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceName: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceName = resourceName
    }
}

public struct TagResourceInput: Swift.Sendable {
    /// The [ARN](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the resource to tag.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// A list of key-value pairs that contain metadata for the resource. For more information, see [Tagging your IoT SiteWise resources](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/tag-resources.html) in the IoT SiteWise User Guide.
    /// This member is required.
    public var tags: [Swift.String: Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

public struct TagResourceOutput: Swift.Sendable {

    public init() { }
}

public struct UntagResourceInput: Swift.Sendable {
    /// The [ARN](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the resource to untag.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// A list of keys for tags to remove from the resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

public struct UntagResourceOutput: Swift.Sendable {

    public init() { }
}

public struct UpdateAccessPolicyInput: Swift.Sendable {
    /// The ID of the access policy.
    /// This member is required.
    public var accessPolicyId: Swift.String?
    /// The identity for this access policy. Choose an IAM Identity Center user, an IAM Identity Center group, or an IAM user.
    /// This member is required.
    public var accessPolicyIdentity: IoTSiteWiseClientTypes.Identity?
    /// The permission level for this access policy. Note that a project ADMINISTRATOR is also known as a project owner.
    /// This member is required.
    public var accessPolicyPermission: IoTSiteWiseClientTypes.Permission?
    /// The IoT SiteWise Monitor resource for this access policy. Choose either a portal or a project.
    /// This member is required.
    public var accessPolicyResource: IoTSiteWiseClientTypes.Resource?
    /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
    public var clientToken: Swift.String?

    public init(
        accessPolicyId: Swift.String? = nil,
        accessPolicyIdentity: IoTSiteWiseClientTypes.Identity? = nil,
        accessPolicyPermission: IoTSiteWiseClientTypes.Permission? = nil,
        accessPolicyResource: IoTSiteWiseClientTypes.Resource? = nil,
        clientToken: Swift.String? = nil
    )
    {
        self.accessPolicyId = accessPolicyId
        self.accessPolicyIdentity = accessPolicyIdentity
        self.accessPolicyPermission = accessPolicyPermission
        self.accessPolicyResource = accessPolicyResource
        self.clientToken = clientToken
    }
}

public struct UpdateAccessPolicyOutput: Swift.Sendable {

    public init() { }
}

public struct UpdateAssetInput: Swift.Sendable {
    /// A description for the asset.
    public var assetDescription: Swift.String?
    /// An external ID to assign to the asset. The asset must not already have an external ID. The external ID must be unique within your Amazon Web Services account. For more information, see [Using external IDs](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/object-ids.html#external-ids) in the IoT SiteWise User Guide.
    public var assetExternalId: Swift.String?
    /// The ID of the asset to update. This can be either the actual ID in UUID format, or else externalId: followed by the external ID, if it has one. For more information, see [Referencing objects with external IDs](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/object-ids.html#external-id-references) in the IoT SiteWise User Guide.
    /// This member is required.
    public var assetId: Swift.String?
    /// A friendly name for the asset.
    /// This member is required.
    public var assetName: Swift.String?
    /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
    public var clientToken: Swift.String?

    public init(
        assetDescription: Swift.String? = nil,
        assetExternalId: Swift.String? = nil,
        assetId: Swift.String? = nil,
        assetName: Swift.String? = nil,
        clientToken: Swift.String? = nil
    )
    {
        self.assetDescription = assetDescription
        self.assetExternalId = assetExternalId
        self.assetId = assetId
        self.assetName = assetName
        self.clientToken = clientToken
    }
}

public struct UpdateAssetOutput: Swift.Sendable {
    /// The status of the asset, which contains a state (UPDATING after successfully calling this operation) and any error message.
    /// This member is required.
    public var assetStatus: IoTSiteWiseClientTypes.AssetStatus?

    public init(
        assetStatus: IoTSiteWiseClientTypes.AssetStatus? = nil
    )
    {
        self.assetStatus = assetStatus
    }
}

public struct UpdateAssetModelInput: Swift.Sendable {
    /// The composite models that are part of this asset model. It groups properties (such as attributes, measurements, transforms, and metrics) and child composite models that model parts of your industrial equipment. Each composite model has a type that defines the properties that the composite model supports. Use composite models to define alarms on this asset model. When creating custom composite models, you need to use [CreateAssetModelCompositeModel](https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_CreateAssetModelCompositeModel.html). For more information, see [Creating custom composite models (Components)](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/create-custom-composite-models.html) in the IoT SiteWise User Guide.
    public var assetModelCompositeModels: [IoTSiteWiseClientTypes.AssetModelCompositeModel]?
    /// A description for the asset model.
    public var assetModelDescription: Swift.String?
    /// An external ID to assign to the asset model. The asset model must not already have an external ID. The external ID must be unique within your Amazon Web Services account. For more information, see [Using external IDs](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/object-ids.html#external-ids) in the IoT SiteWise User Guide.
    public var assetModelExternalId: Swift.String?
    /// The updated hierarchy definitions of the asset model. Each hierarchy specifies an asset model whose assets can be children of any other assets created from this asset model. For more information, see [Asset hierarchies](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/asset-hierarchies.html) in the IoT SiteWise User Guide. You can specify up to 10 hierarchies per asset model. For more information, see [Quotas](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/quotas.html) in the IoT SiteWise User Guide.
    public var assetModelHierarchies: [IoTSiteWiseClientTypes.AssetModelHierarchy]?
    /// The ID of the asset model to update. This can be either the actual ID in UUID format, or else externalId: followed by the external ID, if it has one. For more information, see [Referencing objects with external IDs](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/object-ids.html#external-id-references) in the IoT SiteWise User Guide.
    /// This member is required.
    public var assetModelId: Swift.String?
    /// A unique name for the asset model.
    /// This member is required.
    public var assetModelName: Swift.String?
    /// The updated property definitions of the asset model. For more information, see [Asset properties](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/asset-properties.html) in the IoT SiteWise User Guide. You can specify up to 200 properties per asset model. For more information, see [Quotas](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/quotas.html) in the IoT SiteWise User Guide.
    public var assetModelProperties: [IoTSiteWiseClientTypes.AssetModelProperty]?
    /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
    public var clientToken: Swift.String?
    /// The expected current entity tag (ETag) for the asset model’s latest or active version (specified using matchForVersionType). The update request is rejected if the tag does not match the latest or active version's current entity tag. See [Optimistic locking for asset model writes](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/opt-locking-for-model.html) in the IoT SiteWise User Guide.
    public var ifMatch: Swift.String?
    /// Accepts * to reject the update request if an active version (specified using matchForVersionType as ACTIVE) already exists for the asset model.
    public var ifNoneMatch: Swift.String?
    /// Specifies the asset model version type (LATEST or ACTIVE) used in conjunction with If-Match or If-None-Match headers to determine the target ETag for the update operation.
    public var matchForVersionType: IoTSiteWiseClientTypes.AssetModelVersionType?

    public init(
        assetModelCompositeModels: [IoTSiteWiseClientTypes.AssetModelCompositeModel]? = nil,
        assetModelDescription: Swift.String? = nil,
        assetModelExternalId: Swift.String? = nil,
        assetModelHierarchies: [IoTSiteWiseClientTypes.AssetModelHierarchy]? = nil,
        assetModelId: Swift.String? = nil,
        assetModelName: Swift.String? = nil,
        assetModelProperties: [IoTSiteWiseClientTypes.AssetModelProperty]? = nil,
        clientToken: Swift.String? = nil,
        ifMatch: Swift.String? = nil,
        ifNoneMatch: Swift.String? = nil,
        matchForVersionType: IoTSiteWiseClientTypes.AssetModelVersionType? = nil
    )
    {
        self.assetModelCompositeModels = assetModelCompositeModels
        self.assetModelDescription = assetModelDescription
        self.assetModelExternalId = assetModelExternalId
        self.assetModelHierarchies = assetModelHierarchies
        self.assetModelId = assetModelId
        self.assetModelName = assetModelName
        self.assetModelProperties = assetModelProperties
        self.clientToken = clientToken
        self.ifMatch = ifMatch
        self.ifNoneMatch = ifNoneMatch
        self.matchForVersionType = matchForVersionType
    }
}

public struct UpdateAssetModelOutput: Swift.Sendable {
    /// The status of the asset model, which contains a state (UPDATING after successfully calling this operation) and any error message.
    /// This member is required.
    public var assetModelStatus: IoTSiteWiseClientTypes.AssetModelStatus?

    public init(
        assetModelStatus: IoTSiteWiseClientTypes.AssetModelStatus? = nil
    )
    {
        self.assetModelStatus = assetModelStatus
    }
}

public struct UpdateAssetModelCompositeModelInput: Swift.Sendable {
    /// A description for the composite model.
    public var assetModelCompositeModelDescription: Swift.String?
    /// An external ID to assign to the asset model. You can only set the external ID of the asset model if it wasn't set when it was created, or you're setting it to the exact same thing as when it was created.
    public var assetModelCompositeModelExternalId: Swift.String?
    /// The ID of a composite model on this asset model.
    /// This member is required.
    public var assetModelCompositeModelId: Swift.String?
    /// A unique name for the composite model.
    /// This member is required.
    public var assetModelCompositeModelName: Swift.String?
    /// The property definitions of the composite model. For more information, see [ Inline custom composite models](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/custom-composite-models.html#inline-composite-models) in the IoT SiteWise User Guide. You can specify up to 200 properties per composite model. For more information, see [Quotas](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/quotas.html) in the IoT SiteWise User Guide.
    public var assetModelCompositeModelProperties: [IoTSiteWiseClientTypes.AssetModelProperty]?
    /// The ID of the asset model, in UUID format.
    /// This member is required.
    public var assetModelId: Swift.String?
    /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
    public var clientToken: Swift.String?
    /// The expected current entity tag (ETag) for the asset model’s latest or active version (specified using matchForVersionType). The update request is rejected if the tag does not match the latest or active version's current entity tag. See [Optimistic locking for asset model writes](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/opt-locking-for-model.html) in the IoT SiteWise User Guide.
    public var ifMatch: Swift.String?
    /// Accepts * to reject the update request if an active version (specified using matchForVersionType as ACTIVE) already exists for the asset model.
    public var ifNoneMatch: Swift.String?
    /// Specifies the asset model version type (LATEST or ACTIVE) used in conjunction with If-Match or If-None-Match headers to determine the target ETag for the update operation.
    public var matchForVersionType: IoTSiteWiseClientTypes.AssetModelVersionType?

    public init(
        assetModelCompositeModelDescription: Swift.String? = nil,
        assetModelCompositeModelExternalId: Swift.String? = nil,
        assetModelCompositeModelId: Swift.String? = nil,
        assetModelCompositeModelName: Swift.String? = nil,
        assetModelCompositeModelProperties: [IoTSiteWiseClientTypes.AssetModelProperty]? = nil,
        assetModelId: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        ifMatch: Swift.String? = nil,
        ifNoneMatch: Swift.String? = nil,
        matchForVersionType: IoTSiteWiseClientTypes.AssetModelVersionType? = nil
    )
    {
        self.assetModelCompositeModelDescription = assetModelCompositeModelDescription
        self.assetModelCompositeModelExternalId = assetModelCompositeModelExternalId
        self.assetModelCompositeModelId = assetModelCompositeModelId
        self.assetModelCompositeModelName = assetModelCompositeModelName
        self.assetModelCompositeModelProperties = assetModelCompositeModelProperties
        self.assetModelId = assetModelId
        self.clientToken = clientToken
        self.ifMatch = ifMatch
        self.ifNoneMatch = ifNoneMatch
        self.matchForVersionType = matchForVersionType
    }
}

public struct UpdateAssetModelCompositeModelOutput: Swift.Sendable {
    /// The path to the composite model listing the parent composite models.
    /// This member is required.
    public var assetModelCompositeModelPath: [IoTSiteWiseClientTypes.AssetModelCompositeModelPathSegment]?
    /// Contains current status information for an asset model. For more information, see [Asset and model states](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/asset-and-model-states.html) in the IoT SiteWise User Guide.
    /// This member is required.
    public var assetModelStatus: IoTSiteWiseClientTypes.AssetModelStatus?

    public init(
        assetModelCompositeModelPath: [IoTSiteWiseClientTypes.AssetModelCompositeModelPathSegment]? = nil,
        assetModelStatus: IoTSiteWiseClientTypes.AssetModelStatus? = nil
    )
    {
        self.assetModelCompositeModelPath = assetModelCompositeModelPath
        self.assetModelStatus = assetModelStatus
    }
}

public struct UpdateAssetPropertyInput: Swift.Sendable {
    /// The ID of the asset to be updated. This can be either the actual ID in UUID format, or else externalId: followed by the external ID, if it has one. For more information, see [Referencing objects with external IDs](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/object-ids.html#external-id-references) in the IoT SiteWise User Guide.
    /// This member is required.
    public var assetId: Swift.String?
    /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
    public var clientToken: Swift.String?
    /// The alias that identifies the property, such as an OPC-UA server data stream path (for example, /company/windfarm/3/turbine/7/temperature). For more information, see [Mapping industrial data streams to asset properties](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/connect-data-streams.html) in the IoT SiteWise User Guide. If you omit this parameter, the alias is removed from the property.
    public var propertyAlias: Swift.String?
    /// The ID of the asset property to be updated. This can be either the actual ID in UUID format, or else externalId: followed by the external ID, if it has one. For more information, see [Referencing objects with external IDs](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/object-ids.html#external-id-references) in the IoT SiteWise User Guide.
    /// This member is required.
    public var propertyId: Swift.String?
    /// The MQTT notification state (enabled or disabled) for this asset property. When the notification state is enabled, IoT SiteWise publishes property value updates to a unique MQTT topic. For more information, see [Interacting with other services](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/interact-with-other-services.html) in the IoT SiteWise User Guide. If you omit this parameter, the notification state is set to DISABLED.
    public var propertyNotificationState: IoTSiteWiseClientTypes.PropertyNotificationState?
    /// The unit of measure (such as Newtons or RPM) of the asset property. If you don't specify a value for this parameter, the service uses the value of the assetModelProperty in the asset model.
    public var propertyUnit: Swift.String?

    public init(
        assetId: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        propertyAlias: Swift.String? = nil,
        propertyId: Swift.String? = nil,
        propertyNotificationState: IoTSiteWiseClientTypes.PropertyNotificationState? = nil,
        propertyUnit: Swift.String? = nil
    )
    {
        self.assetId = assetId
        self.clientToken = clientToken
        self.propertyAlias = propertyAlias
        self.propertyId = propertyId
        self.propertyNotificationState = propertyNotificationState
        self.propertyUnit = propertyUnit
    }
}

public struct UpdateDashboardInput: Swift.Sendable {
    /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
    public var clientToken: Swift.String?
    /// The new dashboard definition, as specified in a JSON literal. For detailed information, see [Creating dashboards (CLI)](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/create-dashboards-using-aws-cli.html) in the IoT SiteWise User Guide.
    /// This member is required.
    public var dashboardDefinition: Swift.String?
    /// A new description for the dashboard.
    public var dashboardDescription: Swift.String?
    /// The ID of the dashboard to update.
    /// This member is required.
    public var dashboardId: Swift.String?
    /// A new friendly name for the dashboard.
    /// This member is required.
    public var dashboardName: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        dashboardDefinition: Swift.String? = nil,
        dashboardDescription: Swift.String? = nil,
        dashboardId: Swift.String? = nil,
        dashboardName: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.dashboardDefinition = dashboardDefinition
        self.dashboardDescription = dashboardDescription
        self.dashboardId = dashboardId
        self.dashboardName = dashboardName
    }
}

public struct UpdateDashboardOutput: Swift.Sendable {

    public init() { }
}

public struct UpdateGatewayInput: Swift.Sendable {
    /// The ID of the gateway to update.
    /// This member is required.
    public var gatewayId: Swift.String?
    /// A unique name for the gateway.
    /// This member is required.
    public var gatewayName: Swift.String?

    public init(
        gatewayId: Swift.String? = nil,
        gatewayName: Swift.String? = nil
    )
    {
        self.gatewayId = gatewayId
        self.gatewayName = gatewayName
    }
}

public struct UpdateGatewayCapabilityConfigurationInput: Swift.Sendable {
    /// The JSON document that defines the configuration for the gateway capability. For more information, see [Configuring data sources (CLI)](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/configure-sources.html#configure-source-cli) in the IoT SiteWise User Guide.
    /// This member is required.
    public var capabilityConfiguration: Swift.String?
    /// The namespace of the gateway capability configuration to be updated. For example, if you configure OPC-UA sources from the IoT SiteWise console, your OPC-UA capability configuration has the namespace iotsitewise:opcuacollector:version, where version is a number such as 1.
    /// This member is required.
    public var capabilityNamespace: Swift.String?
    /// The ID of the gateway to be updated.
    /// This member is required.
    public var gatewayId: Swift.String?

    public init(
        capabilityConfiguration: Swift.String? = nil,
        capabilityNamespace: Swift.String? = nil,
        gatewayId: Swift.String? = nil
    )
    {
        self.capabilityConfiguration = capabilityConfiguration
        self.capabilityNamespace = capabilityNamespace
        self.gatewayId = gatewayId
    }
}

public struct UpdateGatewayCapabilityConfigurationOutput: Swift.Sendable {
    /// The namespace of the gateway capability.
    /// This member is required.
    public var capabilityNamespace: Swift.String?
    /// The synchronization status of the capability configuration. The sync status can be one of the following:
    ///
    /// * IN_SYNC – The gateway is running the capability configuration.
    ///
    /// * OUT_OF_SYNC – The gateway hasn't received the capability configuration.
    ///
    /// * SYNC_FAILED – The gateway rejected the capability configuration.
    ///
    ///
    /// After you update a capability configuration, its sync status is OUT_OF_SYNC until the gateway receives and applies or rejects the updated configuration.
    /// This member is required.
    public var capabilitySyncStatus: IoTSiteWiseClientTypes.CapabilitySyncStatus?

    public init(
        capabilityNamespace: Swift.String? = nil,
        capabilitySyncStatus: IoTSiteWiseClientTypes.CapabilitySyncStatus? = nil
    )
    {
        self.capabilityNamespace = capabilityNamespace
        self.capabilitySyncStatus = capabilitySyncStatus
    }
}

extension IoTSiteWiseClientTypes {

    /// Contains an image that is one of the following:
    ///
    /// * An image file. Choose this option to upload a new image.
    ///
    /// * The ID of an existing image. Choose this option to keep an existing image.
    public struct Image: Swift.Sendable {
        /// Contains an image file.
        public var file: IoTSiteWiseClientTypes.ImageFile?
        /// The ID of an existing image. Specify this parameter to keep an existing image.
        public var id: Swift.String?

        public init(
            file: IoTSiteWiseClientTypes.ImageFile? = nil,
            id: Swift.String? = nil
        )
        {
            self.file = file
            self.id = id
        }
    }
}

public struct UpdatePortalInput: Swift.Sendable {
    /// Contains the configuration information of an alarm created in an IoT SiteWise Monitor portal. You can use the alarm to monitor an asset property and get notified when the asset property value is outside a specified range. For more information, see [Monitoring with alarms](https://docs.aws.amazon.com/iot-sitewise/latest/appguide/monitor-alarms.html) in the IoT SiteWise Application Guide.
    public var alarms: IoTSiteWiseClientTypes.Alarms?
    /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
    public var clientToken: Swift.String?
    /// The email address that sends alarm notifications.
    public var notificationSenderEmail: Swift.String?
    /// The Amazon Web Services administrator's contact email address.
    /// This member is required.
    public var portalContactEmail: Swift.String?
    /// A new description for the portal.
    public var portalDescription: Swift.String?
    /// The ID of the portal to update.
    /// This member is required.
    public var portalId: Swift.String?
    /// Contains an image that is one of the following:
    ///
    /// * An image file. Choose this option to upload a new image.
    ///
    /// * The ID of an existing image. Choose this option to keep an existing image.
    public var portalLogoImage: IoTSiteWiseClientTypes.Image?
    /// A new friendly name for the portal.
    /// This member is required.
    public var portalName: Swift.String?
    /// The [ARN](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of a service role that allows the portal's users to access your IoT SiteWise resources on your behalf. For more information, see [Using service roles for IoT SiteWise Monitor](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/monitor-service-role.html) in the IoT SiteWise User Guide.
    /// This member is required.
    public var roleArn: Swift.String?

    public init(
        alarms: IoTSiteWiseClientTypes.Alarms? = nil,
        clientToken: Swift.String? = nil,
        notificationSenderEmail: Swift.String? = nil,
        portalContactEmail: Swift.String? = nil,
        portalDescription: Swift.String? = nil,
        portalId: Swift.String? = nil,
        portalLogoImage: IoTSiteWiseClientTypes.Image? = nil,
        portalName: Swift.String? = nil,
        roleArn: Swift.String? = nil
    )
    {
        self.alarms = alarms
        self.clientToken = clientToken
        self.notificationSenderEmail = notificationSenderEmail
        self.portalContactEmail = portalContactEmail
        self.portalDescription = portalDescription
        self.portalId = portalId
        self.portalLogoImage = portalLogoImage
        self.portalName = portalName
        self.roleArn = roleArn
    }
}

public struct UpdatePortalOutput: Swift.Sendable {
    /// The status of the portal, which contains a state (UPDATING after successfully calling this operation) and any error message.
    /// This member is required.
    public var portalStatus: IoTSiteWiseClientTypes.PortalStatus?

    public init(
        portalStatus: IoTSiteWiseClientTypes.PortalStatus? = nil
    )
    {
        self.portalStatus = portalStatus
    }
}

public struct UpdateProjectInput: Swift.Sendable {
    /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
    public var clientToken: Swift.String?
    /// A new description for the project.
    public var projectDescription: Swift.String?
    /// The ID of the project to update.
    /// This member is required.
    public var projectId: Swift.String?
    /// A new friendly name for the project.
    /// This member is required.
    public var projectName: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        projectDescription: Swift.String? = nil,
        projectId: Swift.String? = nil,
        projectName: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.projectDescription = projectDescription
        self.projectId = projectId
        self.projectName = projectName
    }
}

public struct UpdateProjectOutput: Swift.Sendable {

    public init() { }
}

extension IoTSiteWiseClientTypes {

    /// Represents a single data point in a query result.
    public struct Datum: Swift.Sendable {
        /// Indicates if the data point is an array.
        public var arrayValue: [IoTSiteWiseClientTypes.Datum]?
        /// Indicates if the data point is null.
        public var nullValue: Swift.Bool?
        /// Indicates if the data point is a row.
        public var rowValue: IoTSiteWiseClientTypes.Row?
        /// Indicates if the data point is a scalar value such as integer, string, double, or Boolean.
        public var scalarValue: Swift.String?

        public init(
            arrayValue: [IoTSiteWiseClientTypes.Datum]? = nil,
            nullValue: Swift.Bool? = nil,
            rowValue: IoTSiteWiseClientTypes.Row? = nil,
            scalarValue: Swift.String? = nil
        )
        {
            self.arrayValue = arrayValue
            self.nullValue = nullValue
            self.rowValue = rowValue
            self.scalarValue = scalarValue
        }
    }
}

extension IoTSiteWiseClientTypes {

    /// Represents a single row in the query results.
    public struct Row: Swift.Sendable {
        /// List of data points in a single row of the result set.
        /// This member is required.
        public var data: [IoTSiteWiseClientTypes.Datum]?

        public init(
            data: [IoTSiteWiseClientTypes.Datum]? = nil
        )
        {
            self.data = data
        }
    }
}

public struct ExecuteQueryOutput: Swift.Sendable {
    /// Represents a single column in the query results.
    public var columns: [IoTSiteWiseClientTypes.ColumnInfo]?
    /// The string that specifies the next page of results.
    public var nextToken: Swift.String?
    /// Represents a single row in the query results.
    public var rows: [IoTSiteWiseClientTypes.Row]?

    public init(
        columns: [IoTSiteWiseClientTypes.ColumnInfo]? = nil,
        nextToken: Swift.String? = nil,
        rows: [IoTSiteWiseClientTypes.Row]? = nil
    )
    {
        self.columns = columns
        self.nextToken = nextToken
        self.rows = rows
    }
}

extension AssociateAssetsInput {

    static func urlPathProvider(_ value: AssociateAssetsInput) -> Swift.String? {
        guard let assetId = value.assetId else {
            return nil
        }
        return "/assets/\(assetId.urlPercentEncoding())/associate"
    }
}

extension AssociateTimeSeriesToAssetPropertyInput {

    static func urlPathProvider(_ value: AssociateTimeSeriesToAssetPropertyInput) -> Swift.String? {
        return "/timeseries/associate"
    }
}

extension AssociateTimeSeriesToAssetPropertyInput {

    static func queryItemProvider(_ value: AssociateTimeSeriesToAssetPropertyInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let assetId = value.assetId else {
            let message = "Creating a URL Query Item failed. assetId is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let assetIdQueryItem = Smithy.URIQueryItem(name: "assetId".urlPercentEncoding(), value: Swift.String(assetId).urlPercentEncoding())
        items.append(assetIdQueryItem)
        guard let alias = value.alias else {
            let message = "Creating a URL Query Item failed. alias is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let aliasQueryItem = Smithy.URIQueryItem(name: "alias".urlPercentEncoding(), value: Swift.String(alias).urlPercentEncoding())
        items.append(aliasQueryItem)
        guard let propertyId = value.propertyId else {
            let message = "Creating a URL Query Item failed. propertyId is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let propertyIdQueryItem = Smithy.URIQueryItem(name: "propertyId".urlPercentEncoding(), value: Swift.String(propertyId).urlPercentEncoding())
        items.append(propertyIdQueryItem)
        return items
    }
}

extension BatchAssociateProjectAssetsInput {

    static func urlPathProvider(_ value: BatchAssociateProjectAssetsInput) -> Swift.String? {
        guard let projectId = value.projectId else {
            return nil
        }
        return "/projects/\(projectId.urlPercentEncoding())/assets/associate"
    }
}

extension BatchDisassociateProjectAssetsInput {

    static func urlPathProvider(_ value: BatchDisassociateProjectAssetsInput) -> Swift.String? {
        guard let projectId = value.projectId else {
            return nil
        }
        return "/projects/\(projectId.urlPercentEncoding())/assets/disassociate"
    }
}

extension BatchGetAssetPropertyAggregatesInput {

    static func urlPathProvider(_ value: BatchGetAssetPropertyAggregatesInput) -> Swift.String? {
        return "/properties/batch/aggregates"
    }
}

extension BatchGetAssetPropertyValueInput {

    static func urlPathProvider(_ value: BatchGetAssetPropertyValueInput) -> Swift.String? {
        return "/properties/batch/latest"
    }
}

extension BatchGetAssetPropertyValueHistoryInput {

    static func urlPathProvider(_ value: BatchGetAssetPropertyValueHistoryInput) -> Swift.String? {
        return "/properties/batch/history"
    }
}

extension BatchPutAssetPropertyValueInput {

    static func urlPathProvider(_ value: BatchPutAssetPropertyValueInput) -> Swift.String? {
        return "/properties"
    }
}

extension CreateAccessPolicyInput {

    static func urlPathProvider(_ value: CreateAccessPolicyInput) -> Swift.String? {
        return "/access-policies"
    }
}

extension CreateAssetInput {

    static func urlPathProvider(_ value: CreateAssetInput) -> Swift.String? {
        return "/assets"
    }
}

extension CreateAssetModelInput {

    static func urlPathProvider(_ value: CreateAssetModelInput) -> Swift.String? {
        return "/asset-models"
    }
}

extension CreateAssetModelCompositeModelInput {

    static func urlPathProvider(_ value: CreateAssetModelCompositeModelInput) -> Swift.String? {
        guard let assetModelId = value.assetModelId else {
            return nil
        }
        return "/asset-models/\(assetModelId.urlPercentEncoding())/composite-models"
    }
}

extension CreateAssetModelCompositeModelInput {

    static func headerProvider(_ value: CreateAssetModelCompositeModelInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let ifMatch = value.ifMatch {
            items.add(SmithyHTTPAPI.Header(name: "If-Match", value: Swift.String(ifMatch)))
        }
        if let ifNoneMatch = value.ifNoneMatch {
            items.add(SmithyHTTPAPI.Header(name: "If-None-Match", value: Swift.String(ifNoneMatch)))
        }
        if let matchForVersionType = value.matchForVersionType {
            items.add(SmithyHTTPAPI.Header(name: "Match-For-Version-Type", value: Swift.String(matchForVersionType.rawValue)))
        }
        return items
    }
}

extension CreateBulkImportJobInput {

    static func urlPathProvider(_ value: CreateBulkImportJobInput) -> Swift.String? {
        return "/jobs"
    }
}

extension CreateDashboardInput {

    static func urlPathProvider(_ value: CreateDashboardInput) -> Swift.String? {
        return "/dashboards"
    }
}

extension CreateGatewayInput {

    static func urlPathProvider(_ value: CreateGatewayInput) -> Swift.String? {
        return "/20200301/gateways"
    }
}

extension CreatePortalInput {

    static func urlPathProvider(_ value: CreatePortalInput) -> Swift.String? {
        return "/portals"
    }
}

extension CreateProjectInput {

    static func urlPathProvider(_ value: CreateProjectInput) -> Swift.String? {
        return "/projects"
    }
}

extension DeleteAccessPolicyInput {

    static func urlPathProvider(_ value: DeleteAccessPolicyInput) -> Swift.String? {
        guard let accessPolicyId = value.accessPolicyId else {
            return nil
        }
        return "/access-policies/\(accessPolicyId.urlPercentEncoding())"
    }
}

extension DeleteAccessPolicyInput {

    static func queryItemProvider(_ value: DeleteAccessPolicyInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let clientToken = value.clientToken {
            let clientTokenQueryItem = Smithy.URIQueryItem(name: "clientToken".urlPercentEncoding(), value: Swift.String(clientToken).urlPercentEncoding())
            items.append(clientTokenQueryItem)
        }
        return items
    }
}

extension DeleteAssetInput {

    static func urlPathProvider(_ value: DeleteAssetInput) -> Swift.String? {
        guard let assetId = value.assetId else {
            return nil
        }
        return "/assets/\(assetId.urlPercentEncoding())"
    }
}

extension DeleteAssetInput {

    static func queryItemProvider(_ value: DeleteAssetInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let clientToken = value.clientToken {
            let clientTokenQueryItem = Smithy.URIQueryItem(name: "clientToken".urlPercentEncoding(), value: Swift.String(clientToken).urlPercentEncoding())
            items.append(clientTokenQueryItem)
        }
        return items
    }
}

extension DeleteAssetModelInput {

    static func urlPathProvider(_ value: DeleteAssetModelInput) -> Swift.String? {
        guard let assetModelId = value.assetModelId else {
            return nil
        }
        return "/asset-models/\(assetModelId.urlPercentEncoding())"
    }
}

extension DeleteAssetModelInput {

    static func headerProvider(_ value: DeleteAssetModelInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let ifMatch = value.ifMatch {
            items.add(SmithyHTTPAPI.Header(name: "If-Match", value: Swift.String(ifMatch)))
        }
        if let ifNoneMatch = value.ifNoneMatch {
            items.add(SmithyHTTPAPI.Header(name: "If-None-Match", value: Swift.String(ifNoneMatch)))
        }
        if let matchForVersionType = value.matchForVersionType {
            items.add(SmithyHTTPAPI.Header(name: "Match-For-Version-Type", value: Swift.String(matchForVersionType.rawValue)))
        }
        return items
    }
}

extension DeleteAssetModelInput {

    static func queryItemProvider(_ value: DeleteAssetModelInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let clientToken = value.clientToken {
            let clientTokenQueryItem = Smithy.URIQueryItem(name: "clientToken".urlPercentEncoding(), value: Swift.String(clientToken).urlPercentEncoding())
            items.append(clientTokenQueryItem)
        }
        return items
    }
}

extension DeleteAssetModelCompositeModelInput {

    static func urlPathProvider(_ value: DeleteAssetModelCompositeModelInput) -> Swift.String? {
        guard let assetModelId = value.assetModelId else {
            return nil
        }
        guard let assetModelCompositeModelId = value.assetModelCompositeModelId else {
            return nil
        }
        return "/asset-models/\(assetModelId.urlPercentEncoding())/composite-models/\(assetModelCompositeModelId.urlPercentEncoding())"
    }
}

extension DeleteAssetModelCompositeModelInput {

    static func headerProvider(_ value: DeleteAssetModelCompositeModelInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let ifMatch = value.ifMatch {
            items.add(SmithyHTTPAPI.Header(name: "If-Match", value: Swift.String(ifMatch)))
        }
        if let ifNoneMatch = value.ifNoneMatch {
            items.add(SmithyHTTPAPI.Header(name: "If-None-Match", value: Swift.String(ifNoneMatch)))
        }
        if let matchForVersionType = value.matchForVersionType {
            items.add(SmithyHTTPAPI.Header(name: "Match-For-Version-Type", value: Swift.String(matchForVersionType.rawValue)))
        }
        return items
    }
}

extension DeleteAssetModelCompositeModelInput {

    static func queryItemProvider(_ value: DeleteAssetModelCompositeModelInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let clientToken = value.clientToken {
            let clientTokenQueryItem = Smithy.URIQueryItem(name: "clientToken".urlPercentEncoding(), value: Swift.String(clientToken).urlPercentEncoding())
            items.append(clientTokenQueryItem)
        }
        return items
    }
}

extension DeleteDashboardInput {

    static func urlPathProvider(_ value: DeleteDashboardInput) -> Swift.String? {
        guard let dashboardId = value.dashboardId else {
            return nil
        }
        return "/dashboards/\(dashboardId.urlPercentEncoding())"
    }
}

extension DeleteDashboardInput {

    static func queryItemProvider(_ value: DeleteDashboardInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let clientToken = value.clientToken {
            let clientTokenQueryItem = Smithy.URIQueryItem(name: "clientToken".urlPercentEncoding(), value: Swift.String(clientToken).urlPercentEncoding())
            items.append(clientTokenQueryItem)
        }
        return items
    }
}

extension DeleteGatewayInput {

    static func urlPathProvider(_ value: DeleteGatewayInput) -> Swift.String? {
        guard let gatewayId = value.gatewayId else {
            return nil
        }
        return "/20200301/gateways/\(gatewayId.urlPercentEncoding())"
    }
}

extension DeletePortalInput {

    static func urlPathProvider(_ value: DeletePortalInput) -> Swift.String? {
        guard let portalId = value.portalId else {
            return nil
        }
        return "/portals/\(portalId.urlPercentEncoding())"
    }
}

extension DeletePortalInput {

    static func queryItemProvider(_ value: DeletePortalInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let clientToken = value.clientToken {
            let clientTokenQueryItem = Smithy.URIQueryItem(name: "clientToken".urlPercentEncoding(), value: Swift.String(clientToken).urlPercentEncoding())
            items.append(clientTokenQueryItem)
        }
        return items
    }
}

extension DeleteProjectInput {

    static func urlPathProvider(_ value: DeleteProjectInput) -> Swift.String? {
        guard let projectId = value.projectId else {
            return nil
        }
        return "/projects/\(projectId.urlPercentEncoding())"
    }
}

extension DeleteProjectInput {

    static func queryItemProvider(_ value: DeleteProjectInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let clientToken = value.clientToken {
            let clientTokenQueryItem = Smithy.URIQueryItem(name: "clientToken".urlPercentEncoding(), value: Swift.String(clientToken).urlPercentEncoding())
            items.append(clientTokenQueryItem)
        }
        return items
    }
}

extension DeleteTimeSeriesInput {

    static func urlPathProvider(_ value: DeleteTimeSeriesInput) -> Swift.String? {
        return "/timeseries/delete"
    }
}

extension DeleteTimeSeriesInput {

    static func queryItemProvider(_ value: DeleteTimeSeriesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let assetId = value.assetId {
            let assetIdQueryItem = Smithy.URIQueryItem(name: "assetId".urlPercentEncoding(), value: Swift.String(assetId).urlPercentEncoding())
            items.append(assetIdQueryItem)
        }
        if let alias = value.alias {
            let aliasQueryItem = Smithy.URIQueryItem(name: "alias".urlPercentEncoding(), value: Swift.String(alias).urlPercentEncoding())
            items.append(aliasQueryItem)
        }
        if let propertyId = value.propertyId {
            let propertyIdQueryItem = Smithy.URIQueryItem(name: "propertyId".urlPercentEncoding(), value: Swift.String(propertyId).urlPercentEncoding())
            items.append(propertyIdQueryItem)
        }
        return items
    }
}

extension DescribeAccessPolicyInput {

    static func urlPathProvider(_ value: DescribeAccessPolicyInput) -> Swift.String? {
        guard let accessPolicyId = value.accessPolicyId else {
            return nil
        }
        return "/access-policies/\(accessPolicyId.urlPercentEncoding())"
    }
}

extension DescribeActionInput {

    static func urlPathProvider(_ value: DescribeActionInput) -> Swift.String? {
        guard let actionId = value.actionId else {
            return nil
        }
        return "/actions/\(actionId.urlPercentEncoding())"
    }
}

extension DescribeAssetInput {

    static func urlPathProvider(_ value: DescribeAssetInput) -> Swift.String? {
        guard let assetId = value.assetId else {
            return nil
        }
        return "/assets/\(assetId.urlPercentEncoding())"
    }
}

extension DescribeAssetInput {

    static func queryItemProvider(_ value: DescribeAssetInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let excludeProperties = value.excludeProperties {
            let excludePropertiesQueryItem = Smithy.URIQueryItem(name: "excludeProperties".urlPercentEncoding(), value: Swift.String(excludeProperties).urlPercentEncoding())
            items.append(excludePropertiesQueryItem)
        }
        return items
    }
}

extension DescribeAssetCompositeModelInput {

    static func urlPathProvider(_ value: DescribeAssetCompositeModelInput) -> Swift.String? {
        guard let assetId = value.assetId else {
            return nil
        }
        guard let assetCompositeModelId = value.assetCompositeModelId else {
            return nil
        }
        return "/assets/\(assetId.urlPercentEncoding())/composite-models/\(assetCompositeModelId.urlPercentEncoding())"
    }
}

extension DescribeAssetModelInput {

    static func urlPathProvider(_ value: DescribeAssetModelInput) -> Swift.String? {
        guard let assetModelId = value.assetModelId else {
            return nil
        }
        return "/asset-models/\(assetModelId.urlPercentEncoding())"
    }
}

extension DescribeAssetModelInput {

    static func queryItemProvider(_ value: DescribeAssetModelInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let assetModelVersion = value.assetModelVersion {
            let assetModelVersionQueryItem = Smithy.URIQueryItem(name: "assetModelVersion".urlPercentEncoding(), value: Swift.String(assetModelVersion).urlPercentEncoding())
            items.append(assetModelVersionQueryItem)
        }
        if let excludeProperties = value.excludeProperties {
            let excludePropertiesQueryItem = Smithy.URIQueryItem(name: "excludeProperties".urlPercentEncoding(), value: Swift.String(excludeProperties).urlPercentEncoding())
            items.append(excludePropertiesQueryItem)
        }
        return items
    }
}

extension DescribeAssetModelCompositeModelInput {

    static func urlPathProvider(_ value: DescribeAssetModelCompositeModelInput) -> Swift.String? {
        guard let assetModelId = value.assetModelId else {
            return nil
        }
        guard let assetModelCompositeModelId = value.assetModelCompositeModelId else {
            return nil
        }
        return "/asset-models/\(assetModelId.urlPercentEncoding())/composite-models/\(assetModelCompositeModelId.urlPercentEncoding())"
    }
}

extension DescribeAssetModelCompositeModelInput {

    static func queryItemProvider(_ value: DescribeAssetModelCompositeModelInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let assetModelVersion = value.assetModelVersion {
            let assetModelVersionQueryItem = Smithy.URIQueryItem(name: "assetModelVersion".urlPercentEncoding(), value: Swift.String(assetModelVersion).urlPercentEncoding())
            items.append(assetModelVersionQueryItem)
        }
        return items
    }
}

extension DescribeAssetPropertyInput {

    static func urlPathProvider(_ value: DescribeAssetPropertyInput) -> Swift.String? {
        guard let assetId = value.assetId else {
            return nil
        }
        guard let propertyId = value.propertyId else {
            return nil
        }
        return "/assets/\(assetId.urlPercentEncoding())/properties/\(propertyId.urlPercentEncoding())"
    }
}

extension DescribeBulkImportJobInput {

    static func urlPathProvider(_ value: DescribeBulkImportJobInput) -> Swift.String? {
        guard let jobId = value.jobId else {
            return nil
        }
        return "/jobs/\(jobId.urlPercentEncoding())"
    }
}

extension DescribeDashboardInput {

    static func urlPathProvider(_ value: DescribeDashboardInput) -> Swift.String? {
        guard let dashboardId = value.dashboardId else {
            return nil
        }
        return "/dashboards/\(dashboardId.urlPercentEncoding())"
    }
}

extension DescribeDefaultEncryptionConfigurationInput {

    static func urlPathProvider(_ value: DescribeDefaultEncryptionConfigurationInput) -> Swift.String? {
        return "/configuration/account/encryption"
    }
}

extension DescribeGatewayInput {

    static func urlPathProvider(_ value: DescribeGatewayInput) -> Swift.String? {
        guard let gatewayId = value.gatewayId else {
            return nil
        }
        return "/20200301/gateways/\(gatewayId.urlPercentEncoding())"
    }
}

extension DescribeGatewayCapabilityConfigurationInput {

    static func urlPathProvider(_ value: DescribeGatewayCapabilityConfigurationInput) -> Swift.String? {
        guard let gatewayId = value.gatewayId else {
            return nil
        }
        guard let capabilityNamespace = value.capabilityNamespace else {
            return nil
        }
        return "/20200301/gateways/\(gatewayId.urlPercentEncoding())/capability/\(capabilityNamespace.urlPercentEncoding())"
    }
}

extension DescribeLoggingOptionsInput {

    static func urlPathProvider(_ value: DescribeLoggingOptionsInput) -> Swift.String? {
        return "/logging"
    }
}

extension DescribePortalInput {

    static func urlPathProvider(_ value: DescribePortalInput) -> Swift.String? {
        guard let portalId = value.portalId else {
            return nil
        }
        return "/portals/\(portalId.urlPercentEncoding())"
    }
}

extension DescribeProjectInput {

    static func urlPathProvider(_ value: DescribeProjectInput) -> Swift.String? {
        guard let projectId = value.projectId else {
            return nil
        }
        return "/projects/\(projectId.urlPercentEncoding())"
    }
}

extension DescribeStorageConfigurationInput {

    static func urlPathProvider(_ value: DescribeStorageConfigurationInput) -> Swift.String? {
        return "/configuration/account/storage"
    }
}

extension DescribeTimeSeriesInput {

    static func urlPathProvider(_ value: DescribeTimeSeriesInput) -> Swift.String? {
        return "/timeseries/describe"
    }
}

extension DescribeTimeSeriesInput {

    static func queryItemProvider(_ value: DescribeTimeSeriesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let assetId = value.assetId {
            let assetIdQueryItem = Smithy.URIQueryItem(name: "assetId".urlPercentEncoding(), value: Swift.String(assetId).urlPercentEncoding())
            items.append(assetIdQueryItem)
        }
        if let alias = value.alias {
            let aliasQueryItem = Smithy.URIQueryItem(name: "alias".urlPercentEncoding(), value: Swift.String(alias).urlPercentEncoding())
            items.append(aliasQueryItem)
        }
        if let propertyId = value.propertyId {
            let propertyIdQueryItem = Smithy.URIQueryItem(name: "propertyId".urlPercentEncoding(), value: Swift.String(propertyId).urlPercentEncoding())
            items.append(propertyIdQueryItem)
        }
        return items
    }
}

extension DisassociateAssetsInput {

    static func urlPathProvider(_ value: DisassociateAssetsInput) -> Swift.String? {
        guard let assetId = value.assetId else {
            return nil
        }
        return "/assets/\(assetId.urlPercentEncoding())/disassociate"
    }
}

extension DisassociateTimeSeriesFromAssetPropertyInput {

    static func urlPathProvider(_ value: DisassociateTimeSeriesFromAssetPropertyInput) -> Swift.String? {
        return "/timeseries/disassociate"
    }
}

extension DisassociateTimeSeriesFromAssetPropertyInput {

    static func queryItemProvider(_ value: DisassociateTimeSeriesFromAssetPropertyInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let assetId = value.assetId else {
            let message = "Creating a URL Query Item failed. assetId is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let assetIdQueryItem = Smithy.URIQueryItem(name: "assetId".urlPercentEncoding(), value: Swift.String(assetId).urlPercentEncoding())
        items.append(assetIdQueryItem)
        guard let alias = value.alias else {
            let message = "Creating a URL Query Item failed. alias is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let aliasQueryItem = Smithy.URIQueryItem(name: "alias".urlPercentEncoding(), value: Swift.String(alias).urlPercentEncoding())
        items.append(aliasQueryItem)
        guard let propertyId = value.propertyId else {
            let message = "Creating a URL Query Item failed. propertyId is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let propertyIdQueryItem = Smithy.URIQueryItem(name: "propertyId".urlPercentEncoding(), value: Swift.String(propertyId).urlPercentEncoding())
        items.append(propertyIdQueryItem)
        return items
    }
}

extension ExecuteActionInput {

    static func urlPathProvider(_ value: ExecuteActionInput) -> Swift.String? {
        return "/actions"
    }
}

extension ExecuteQueryInput {

    static func urlPathProvider(_ value: ExecuteQueryInput) -> Swift.String? {
        return "/queries/execution"
    }
}

extension GetAssetPropertyAggregatesInput {

    static func urlPathProvider(_ value: GetAssetPropertyAggregatesInput) -> Swift.String? {
        return "/properties/aggregates"
    }
}

extension GetAssetPropertyAggregatesInput {

    static func queryItemProvider(_ value: GetAssetPropertyAggregatesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let aggregateTypes = value.aggregateTypes else {
            let message = "Creating a URL Query Item failed. aggregateTypes is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        aggregateTypes.forEach { queryItemValue in
            let queryItem = Smithy.URIQueryItem(name: "aggregateTypes".urlPercentEncoding(), value: Swift.String(queryItemValue.rawValue).urlPercentEncoding())
            items.append(queryItem)
        }
        guard let endDate = value.endDate else {
            let message = "Creating a URL Query Item failed. endDate is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let endDateQueryItem = Smithy.URIQueryItem(name: "endDate".urlPercentEncoding(), value: Swift.String(SmithyTimestamps.TimestampFormatter(format: .dateTime).string(from: endDate)).urlPercentEncoding())
        items.append(endDateQueryItem)
        if let assetId = value.assetId {
            let assetIdQueryItem = Smithy.URIQueryItem(name: "assetId".urlPercentEncoding(), value: Swift.String(assetId).urlPercentEncoding())
            items.append(assetIdQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let propertyAlias = value.propertyAlias {
            let propertyAliasQueryItem = Smithy.URIQueryItem(name: "propertyAlias".urlPercentEncoding(), value: Swift.String(propertyAlias).urlPercentEncoding())
            items.append(propertyAliasQueryItem)
        }
        if let qualities = value.qualities {
            qualities.forEach { queryItemValue in
                let queryItem = Smithy.URIQueryItem(name: "qualities".urlPercentEncoding(), value: Swift.String(queryItemValue.rawValue).urlPercentEncoding())
                items.append(queryItem)
            }
        }
        if let timeOrdering = value.timeOrdering {
            let timeOrderingQueryItem = Smithy.URIQueryItem(name: "timeOrdering".urlPercentEncoding(), value: Swift.String(timeOrdering.rawValue).urlPercentEncoding())
            items.append(timeOrderingQueryItem)
        }
        if let propertyId = value.propertyId {
            let propertyIdQueryItem = Smithy.URIQueryItem(name: "propertyId".urlPercentEncoding(), value: Swift.String(propertyId).urlPercentEncoding())
            items.append(propertyIdQueryItem)
        }
        guard let resolution = value.resolution else {
            let message = "Creating a URL Query Item failed. resolution is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let resolutionQueryItem = Smithy.URIQueryItem(name: "resolution".urlPercentEncoding(), value: Swift.String(resolution).urlPercentEncoding())
        items.append(resolutionQueryItem)
        guard let startDate = value.startDate else {
            let message = "Creating a URL Query Item failed. startDate is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let startDateQueryItem = Smithy.URIQueryItem(name: "startDate".urlPercentEncoding(), value: Swift.String(SmithyTimestamps.TimestampFormatter(format: .dateTime).string(from: startDate)).urlPercentEncoding())
        items.append(startDateQueryItem)
        return items
    }
}

extension GetAssetPropertyValueInput {

    static func urlPathProvider(_ value: GetAssetPropertyValueInput) -> Swift.String? {
        return "/properties/latest"
    }
}

extension GetAssetPropertyValueInput {

    static func queryItemProvider(_ value: GetAssetPropertyValueInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let assetId = value.assetId {
            let assetIdQueryItem = Smithy.URIQueryItem(name: "assetId".urlPercentEncoding(), value: Swift.String(assetId).urlPercentEncoding())
            items.append(assetIdQueryItem)
        }
        if let propertyAlias = value.propertyAlias {
            let propertyAliasQueryItem = Smithy.URIQueryItem(name: "propertyAlias".urlPercentEncoding(), value: Swift.String(propertyAlias).urlPercentEncoding())
            items.append(propertyAliasQueryItem)
        }
        if let propertyId = value.propertyId {
            let propertyIdQueryItem = Smithy.URIQueryItem(name: "propertyId".urlPercentEncoding(), value: Swift.String(propertyId).urlPercentEncoding())
            items.append(propertyIdQueryItem)
        }
        return items
    }
}

extension GetAssetPropertyValueHistoryInput {

    static func urlPathProvider(_ value: GetAssetPropertyValueHistoryInput) -> Swift.String? {
        return "/properties/history"
    }
}

extension GetAssetPropertyValueHistoryInput {

    static func queryItemProvider(_ value: GetAssetPropertyValueHistoryInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let endDate = value.endDate {
            let endDateQueryItem = Smithy.URIQueryItem(name: "endDate".urlPercentEncoding(), value: Swift.String(SmithyTimestamps.TimestampFormatter(format: .dateTime).string(from: endDate)).urlPercentEncoding())
            items.append(endDateQueryItem)
        }
        if let assetId = value.assetId {
            let assetIdQueryItem = Smithy.URIQueryItem(name: "assetId".urlPercentEncoding(), value: Swift.String(assetId).urlPercentEncoding())
            items.append(assetIdQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let propertyAlias = value.propertyAlias {
            let propertyAliasQueryItem = Smithy.URIQueryItem(name: "propertyAlias".urlPercentEncoding(), value: Swift.String(propertyAlias).urlPercentEncoding())
            items.append(propertyAliasQueryItem)
        }
        if let qualities = value.qualities {
            qualities.forEach { queryItemValue in
                let queryItem = Smithy.URIQueryItem(name: "qualities".urlPercentEncoding(), value: Swift.String(queryItemValue.rawValue).urlPercentEncoding())
                items.append(queryItem)
            }
        }
        if let timeOrdering = value.timeOrdering {
            let timeOrderingQueryItem = Smithy.URIQueryItem(name: "timeOrdering".urlPercentEncoding(), value: Swift.String(timeOrdering.rawValue).urlPercentEncoding())
            items.append(timeOrderingQueryItem)
        }
        if let propertyId = value.propertyId {
            let propertyIdQueryItem = Smithy.URIQueryItem(name: "propertyId".urlPercentEncoding(), value: Swift.String(propertyId).urlPercentEncoding())
            items.append(propertyIdQueryItem)
        }
        if let startDate = value.startDate {
            let startDateQueryItem = Smithy.URIQueryItem(name: "startDate".urlPercentEncoding(), value: Swift.String(SmithyTimestamps.TimestampFormatter(format: .dateTime).string(from: startDate)).urlPercentEncoding())
            items.append(startDateQueryItem)
        }
        return items
    }
}

extension GetInterpolatedAssetPropertyValuesInput {

    static func urlPathProvider(_ value: GetInterpolatedAssetPropertyValuesInput) -> Swift.String? {
        return "/properties/interpolated"
    }
}

extension GetInterpolatedAssetPropertyValuesInput {

    static func queryItemProvider(_ value: GetInterpolatedAssetPropertyValuesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let startTimeOffsetInNanos = value.startTimeOffsetInNanos {
            let startTimeOffsetInNanosQueryItem = Smithy.URIQueryItem(name: "startTimeOffsetInNanos".urlPercentEncoding(), value: Swift.String(startTimeOffsetInNanos).urlPercentEncoding())
            items.append(startTimeOffsetInNanosQueryItem)
        }
        guard let endTimeInSeconds = value.endTimeInSeconds else {
            let message = "Creating a URL Query Item failed. endTimeInSeconds is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let endTimeInSecondsQueryItem = Smithy.URIQueryItem(name: "endTimeInSeconds".urlPercentEncoding(), value: Swift.String(endTimeInSeconds).urlPercentEncoding())
        items.append(endTimeInSecondsQueryItem)
        if let endTimeOffsetInNanos = value.endTimeOffsetInNanos {
            let endTimeOffsetInNanosQueryItem = Smithy.URIQueryItem(name: "endTimeOffsetInNanos".urlPercentEncoding(), value: Swift.String(endTimeOffsetInNanos).urlPercentEncoding())
            items.append(endTimeOffsetInNanosQueryItem)
        }
        if let propertyAlias = value.propertyAlias {
            let propertyAliasQueryItem = Smithy.URIQueryItem(name: "propertyAlias".urlPercentEncoding(), value: Swift.String(propertyAlias).urlPercentEncoding())
            items.append(propertyAliasQueryItem)
        }
        if let intervalWindowInSeconds = value.intervalWindowInSeconds {
            let intervalWindowInSecondsQueryItem = Smithy.URIQueryItem(name: "intervalWindowInSeconds".urlPercentEncoding(), value: Swift.String(intervalWindowInSeconds).urlPercentEncoding())
            items.append(intervalWindowInSecondsQueryItem)
        }
        guard let type = value.type else {
            let message = "Creating a URL Query Item failed. type is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let typeQueryItem = Smithy.URIQueryItem(name: "type".urlPercentEncoding(), value: Swift.String(type).urlPercentEncoding())
        items.append(typeQueryItem)
        guard let quality = value.quality else {
            let message = "Creating a URL Query Item failed. quality is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let qualityQueryItem = Smithy.URIQueryItem(name: "quality".urlPercentEncoding(), value: Swift.String(quality.rawValue).urlPercentEncoding())
        items.append(qualityQueryItem)
        guard let startTimeInSeconds = value.startTimeInSeconds else {
            let message = "Creating a URL Query Item failed. startTimeInSeconds is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let startTimeInSecondsQueryItem = Smithy.URIQueryItem(name: "startTimeInSeconds".urlPercentEncoding(), value: Swift.String(startTimeInSeconds).urlPercentEncoding())
        items.append(startTimeInSecondsQueryItem)
        if let assetId = value.assetId {
            let assetIdQueryItem = Smithy.URIQueryItem(name: "assetId".urlPercentEncoding(), value: Swift.String(assetId).urlPercentEncoding())
            items.append(assetIdQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        guard let intervalInSeconds = value.intervalInSeconds else {
            let message = "Creating a URL Query Item failed. intervalInSeconds is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let intervalInSecondsQueryItem = Smithy.URIQueryItem(name: "intervalInSeconds".urlPercentEncoding(), value: Swift.String(intervalInSeconds).urlPercentEncoding())
        items.append(intervalInSecondsQueryItem)
        if let propertyId = value.propertyId {
            let propertyIdQueryItem = Smithy.URIQueryItem(name: "propertyId".urlPercentEncoding(), value: Swift.String(propertyId).urlPercentEncoding())
            items.append(propertyIdQueryItem)
        }
        return items
    }
}

extension ListAccessPoliciesInput {

    static func urlPathProvider(_ value: ListAccessPoliciesInput) -> Swift.String? {
        return "/access-policies"
    }
}

extension ListAccessPoliciesInput {

    static func queryItemProvider(_ value: ListAccessPoliciesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let resourceId = value.resourceId {
            let resourceIdQueryItem = Smithy.URIQueryItem(name: "resourceId".urlPercentEncoding(), value: Swift.String(resourceId).urlPercentEncoding())
            items.append(resourceIdQueryItem)
        }
        if let identityType = value.identityType {
            let identityTypeQueryItem = Smithy.URIQueryItem(name: "identityType".urlPercentEncoding(), value: Swift.String(identityType.rawValue).urlPercentEncoding())
            items.append(identityTypeQueryItem)
        }
        if let identityId = value.identityId {
            let identityIdQueryItem = Smithy.URIQueryItem(name: "identityId".urlPercentEncoding(), value: Swift.String(identityId).urlPercentEncoding())
            items.append(identityIdQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let iamArn = value.iamArn {
            let iamArnQueryItem = Smithy.URIQueryItem(name: "iamArn".urlPercentEncoding(), value: Swift.String(iamArn).urlPercentEncoding())
            items.append(iamArnQueryItem)
        }
        if let resourceType = value.resourceType {
            let resourceTypeQueryItem = Smithy.URIQueryItem(name: "resourceType".urlPercentEncoding(), value: Swift.String(resourceType.rawValue).urlPercentEncoding())
            items.append(resourceTypeQueryItem)
        }
        return items
    }
}

extension ListActionsInput {

    static func urlPathProvider(_ value: ListActionsInput) -> Swift.String? {
        return "/actions"
    }
}

extension ListActionsInput {

    static func queryItemProvider(_ value: ListActionsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let targetResourceId = value.targetResourceId else {
            let message = "Creating a URL Query Item failed. targetResourceId is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let targetResourceIdQueryItem = Smithy.URIQueryItem(name: "targetResourceId".urlPercentEncoding(), value: Swift.String(targetResourceId).urlPercentEncoding())
        items.append(targetResourceIdQueryItem)
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        guard let targetResourceType = value.targetResourceType else {
            let message = "Creating a URL Query Item failed. targetResourceType is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let targetResourceTypeQueryItem = Smithy.URIQueryItem(name: "targetResourceType".urlPercentEncoding(), value: Swift.String(targetResourceType.rawValue).urlPercentEncoding())
        items.append(targetResourceTypeQueryItem)
        return items
    }
}

extension ListAssetModelCompositeModelsInput {

    static func urlPathProvider(_ value: ListAssetModelCompositeModelsInput) -> Swift.String? {
        guard let assetModelId = value.assetModelId else {
            return nil
        }
        return "/asset-models/\(assetModelId.urlPercentEncoding())/composite-models"
    }
}

extension ListAssetModelCompositeModelsInput {

    static func queryItemProvider(_ value: ListAssetModelCompositeModelsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let assetModelVersion = value.assetModelVersion {
            let assetModelVersionQueryItem = Smithy.URIQueryItem(name: "assetModelVersion".urlPercentEncoding(), value: Swift.String(assetModelVersion).urlPercentEncoding())
            items.append(assetModelVersionQueryItem)
        }
        return items
    }
}

extension ListAssetModelPropertiesInput {

    static func urlPathProvider(_ value: ListAssetModelPropertiesInput) -> Swift.String? {
        guard let assetModelId = value.assetModelId else {
            return nil
        }
        return "/asset-models/\(assetModelId.urlPercentEncoding())/properties"
    }
}

extension ListAssetModelPropertiesInput {

    static func queryItemProvider(_ value: ListAssetModelPropertiesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let filter = value.filter {
            let filterQueryItem = Smithy.URIQueryItem(name: "filter".urlPercentEncoding(), value: Swift.String(filter.rawValue).urlPercentEncoding())
            items.append(filterQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let assetModelVersion = value.assetModelVersion {
            let assetModelVersionQueryItem = Smithy.URIQueryItem(name: "assetModelVersion".urlPercentEncoding(), value: Swift.String(assetModelVersion).urlPercentEncoding())
            items.append(assetModelVersionQueryItem)
        }
        return items
    }
}

extension ListAssetModelsInput {

    static func urlPathProvider(_ value: ListAssetModelsInput) -> Swift.String? {
        return "/asset-models"
    }
}

extension ListAssetModelsInput {

    static func queryItemProvider(_ value: ListAssetModelsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let assetModelVersion = value.assetModelVersion {
            let assetModelVersionQueryItem = Smithy.URIQueryItem(name: "assetModelVersion".urlPercentEncoding(), value: Swift.String(assetModelVersion).urlPercentEncoding())
            items.append(assetModelVersionQueryItem)
        }
        if let assetModelTypes = value.assetModelTypes {
            assetModelTypes.forEach { queryItemValue in
                let queryItem = Smithy.URIQueryItem(name: "assetModelTypes".urlPercentEncoding(), value: Swift.String(queryItemValue.rawValue).urlPercentEncoding())
                items.append(queryItem)
            }
        }
        return items
    }
}

extension ListAssetPropertiesInput {

    static func urlPathProvider(_ value: ListAssetPropertiesInput) -> Swift.String? {
        guard let assetId = value.assetId else {
            return nil
        }
        return "/assets/\(assetId.urlPercentEncoding())/properties"
    }
}

extension ListAssetPropertiesInput {

    static func queryItemProvider(_ value: ListAssetPropertiesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let filter = value.filter {
            let filterQueryItem = Smithy.URIQueryItem(name: "filter".urlPercentEncoding(), value: Swift.String(filter.rawValue).urlPercentEncoding())
            items.append(filterQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListAssetRelationshipsInput {

    static func urlPathProvider(_ value: ListAssetRelationshipsInput) -> Swift.String? {
        guard let assetId = value.assetId else {
            return nil
        }
        return "/assets/\(assetId.urlPercentEncoding())/assetRelationships"
    }
}

extension ListAssetRelationshipsInput {

    static func queryItemProvider(_ value: ListAssetRelationshipsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let traversalType = value.traversalType else {
            let message = "Creating a URL Query Item failed. traversalType is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let traversalTypeQueryItem = Smithy.URIQueryItem(name: "traversalType".urlPercentEncoding(), value: Swift.String(traversalType.rawValue).urlPercentEncoding())
        items.append(traversalTypeQueryItem)
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListAssetsInput {

    static func urlPathProvider(_ value: ListAssetsInput) -> Swift.String? {
        return "/assets"
    }
}

extension ListAssetsInput {

    static func queryItemProvider(_ value: ListAssetsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let filter = value.filter {
            let filterQueryItem = Smithy.URIQueryItem(name: "filter".urlPercentEncoding(), value: Swift.String(filter.rawValue).urlPercentEncoding())
            items.append(filterQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let assetModelId = value.assetModelId {
            let assetModelIdQueryItem = Smithy.URIQueryItem(name: "assetModelId".urlPercentEncoding(), value: Swift.String(assetModelId).urlPercentEncoding())
            items.append(assetModelIdQueryItem)
        }
        return items
    }
}

extension ListAssociatedAssetsInput {

    static func urlPathProvider(_ value: ListAssociatedAssetsInput) -> Swift.String? {
        guard let assetId = value.assetId else {
            return nil
        }
        return "/assets/\(assetId.urlPercentEncoding())/hierarchies"
    }
}

extension ListAssociatedAssetsInput {

    static func queryItemProvider(_ value: ListAssociatedAssetsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let traversalDirection = value.traversalDirection {
            let traversalDirectionQueryItem = Smithy.URIQueryItem(name: "traversalDirection".urlPercentEncoding(), value: Swift.String(traversalDirection.rawValue).urlPercentEncoding())
            items.append(traversalDirectionQueryItem)
        }
        if let hierarchyId = value.hierarchyId {
            let hierarchyIdQueryItem = Smithy.URIQueryItem(name: "hierarchyId".urlPercentEncoding(), value: Swift.String(hierarchyId).urlPercentEncoding())
            items.append(hierarchyIdQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListBulkImportJobsInput {

    static func urlPathProvider(_ value: ListBulkImportJobsInput) -> Swift.String? {
        return "/jobs"
    }
}

extension ListBulkImportJobsInput {

    static func queryItemProvider(_ value: ListBulkImportJobsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let filter = value.filter {
            let filterQueryItem = Smithy.URIQueryItem(name: "filter".urlPercentEncoding(), value: Swift.String(filter.rawValue).urlPercentEncoding())
            items.append(filterQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListCompositionRelationshipsInput {

    static func urlPathProvider(_ value: ListCompositionRelationshipsInput) -> Swift.String? {
        guard let assetModelId = value.assetModelId else {
            return nil
        }
        return "/asset-models/\(assetModelId.urlPercentEncoding())/composition-relationships"
    }
}

extension ListCompositionRelationshipsInput {

    static func queryItemProvider(_ value: ListCompositionRelationshipsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListDashboardsInput {

    static func urlPathProvider(_ value: ListDashboardsInput) -> Swift.String? {
        return "/dashboards"
    }
}

extension ListDashboardsInput {

    static func queryItemProvider(_ value: ListDashboardsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        guard let projectId = value.projectId else {
            let message = "Creating a URL Query Item failed. projectId is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let projectIdQueryItem = Smithy.URIQueryItem(name: "projectId".urlPercentEncoding(), value: Swift.String(projectId).urlPercentEncoding())
        items.append(projectIdQueryItem)
        return items
    }
}

extension ListGatewaysInput {

    static func urlPathProvider(_ value: ListGatewaysInput) -> Swift.String? {
        return "/20200301/gateways"
    }
}

extension ListGatewaysInput {

    static func queryItemProvider(_ value: ListGatewaysInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListPortalsInput {

    static func urlPathProvider(_ value: ListPortalsInput) -> Swift.String? {
        return "/portals"
    }
}

extension ListPortalsInput {

    static func queryItemProvider(_ value: ListPortalsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListProjectAssetsInput {

    static func urlPathProvider(_ value: ListProjectAssetsInput) -> Swift.String? {
        guard let projectId = value.projectId else {
            return nil
        }
        return "/projects/\(projectId.urlPercentEncoding())/assets"
    }
}

extension ListProjectAssetsInput {

    static func queryItemProvider(_ value: ListProjectAssetsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListProjectsInput {

    static func urlPathProvider(_ value: ListProjectsInput) -> Swift.String? {
        return "/projects"
    }
}

extension ListProjectsInput {

    static func queryItemProvider(_ value: ListProjectsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        guard let portalId = value.portalId else {
            let message = "Creating a URL Query Item failed. portalId is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let portalIdQueryItem = Smithy.URIQueryItem(name: "portalId".urlPercentEncoding(), value: Swift.String(portalId).urlPercentEncoding())
        items.append(portalIdQueryItem)
        return items
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        return "/tags"
    }
}

extension ListTagsForResourceInput {

    static func queryItemProvider(_ value: ListTagsForResourceInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let resourceArn = value.resourceArn else {
            let message = "Creating a URL Query Item failed. resourceArn is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let resourceArnQueryItem = Smithy.URIQueryItem(name: "resourceArn".urlPercentEncoding(), value: Swift.String(resourceArn).urlPercentEncoding())
        items.append(resourceArnQueryItem)
        return items
    }
}

extension ListTimeSeriesInput {

    static func urlPathProvider(_ value: ListTimeSeriesInput) -> Swift.String? {
        return "/timeseries"
    }
}

extension ListTimeSeriesInput {

    static func queryItemProvider(_ value: ListTimeSeriesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let assetId = value.assetId {
            let assetIdQueryItem = Smithy.URIQueryItem(name: "assetId".urlPercentEncoding(), value: Swift.String(assetId).urlPercentEncoding())
            items.append(assetIdQueryItem)
        }
        if let timeSeriesType = value.timeSeriesType {
            let timeSeriesTypeQueryItem = Smithy.URIQueryItem(name: "timeSeriesType".urlPercentEncoding(), value: Swift.String(timeSeriesType.rawValue).urlPercentEncoding())
            items.append(timeSeriesTypeQueryItem)
        }
        if let aliasPrefix = value.aliasPrefix {
            let aliasPrefixQueryItem = Smithy.URIQueryItem(name: "aliasPrefix".urlPercentEncoding(), value: Swift.String(aliasPrefix).urlPercentEncoding())
            items.append(aliasPrefixQueryItem)
        }
        return items
    }
}

extension PutDefaultEncryptionConfigurationInput {

    static func urlPathProvider(_ value: PutDefaultEncryptionConfigurationInput) -> Swift.String? {
        return "/configuration/account/encryption"
    }
}

extension PutLoggingOptionsInput {

    static func urlPathProvider(_ value: PutLoggingOptionsInput) -> Swift.String? {
        return "/logging"
    }
}

extension PutStorageConfigurationInput {

    static func urlPathProvider(_ value: PutStorageConfigurationInput) -> Swift.String? {
        return "/configuration/account/storage"
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        return "/tags"
    }
}

extension TagResourceInput {

    static func queryItemProvider(_ value: TagResourceInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let resourceArn = value.resourceArn else {
            let message = "Creating a URL Query Item failed. resourceArn is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let resourceArnQueryItem = Smithy.URIQueryItem(name: "resourceArn".urlPercentEncoding(), value: Swift.String(resourceArn).urlPercentEncoding())
        items.append(resourceArnQueryItem)
        return items
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        return "/tags"
    }
}

extension UntagResourceInput {

    static func queryItemProvider(_ value: UntagResourceInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let tagKeys = value.tagKeys else {
            let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        tagKeys.forEach { queryItemValue in
            let queryItem = Smithy.URIQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
            items.append(queryItem)
        }
        guard let resourceArn = value.resourceArn else {
            let message = "Creating a URL Query Item failed. resourceArn is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        let resourceArnQueryItem = Smithy.URIQueryItem(name: "resourceArn".urlPercentEncoding(), value: Swift.String(resourceArn).urlPercentEncoding())
        items.append(resourceArnQueryItem)
        return items
    }
}

extension UpdateAccessPolicyInput {

    static func urlPathProvider(_ value: UpdateAccessPolicyInput) -> Swift.String? {
        guard let accessPolicyId = value.accessPolicyId else {
            return nil
        }
        return "/access-policies/\(accessPolicyId.urlPercentEncoding())"
    }
}

extension UpdateAssetInput {

    static func urlPathProvider(_ value: UpdateAssetInput) -> Swift.String? {
        guard let assetId = value.assetId else {
            return nil
        }
        return "/assets/\(assetId.urlPercentEncoding())"
    }
}

extension UpdateAssetModelInput {

    static func urlPathProvider(_ value: UpdateAssetModelInput) -> Swift.String? {
        guard let assetModelId = value.assetModelId else {
            return nil
        }
        return "/asset-models/\(assetModelId.urlPercentEncoding())"
    }
}

extension UpdateAssetModelInput {

    static func headerProvider(_ value: UpdateAssetModelInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let ifMatch = value.ifMatch {
            items.add(SmithyHTTPAPI.Header(name: "If-Match", value: Swift.String(ifMatch)))
        }
        if let ifNoneMatch = value.ifNoneMatch {
            items.add(SmithyHTTPAPI.Header(name: "If-None-Match", value: Swift.String(ifNoneMatch)))
        }
        if let matchForVersionType = value.matchForVersionType {
            items.add(SmithyHTTPAPI.Header(name: "Match-For-Version-Type", value: Swift.String(matchForVersionType.rawValue)))
        }
        return items
    }
}

extension UpdateAssetModelCompositeModelInput {

    static func urlPathProvider(_ value: UpdateAssetModelCompositeModelInput) -> Swift.String? {
        guard let assetModelId = value.assetModelId else {
            return nil
        }
        guard let assetModelCompositeModelId = value.assetModelCompositeModelId else {
            return nil
        }
        return "/asset-models/\(assetModelId.urlPercentEncoding())/composite-models/\(assetModelCompositeModelId.urlPercentEncoding())"
    }
}

extension UpdateAssetModelCompositeModelInput {

    static func headerProvider(_ value: UpdateAssetModelCompositeModelInput) -> SmithyHTTPAPI.Headers {
        var items = SmithyHTTPAPI.Headers()
        if let ifMatch = value.ifMatch {
            items.add(SmithyHTTPAPI.Header(name: "If-Match", value: Swift.String(ifMatch)))
        }
        if let ifNoneMatch = value.ifNoneMatch {
            items.add(SmithyHTTPAPI.Header(name: "If-None-Match", value: Swift.String(ifNoneMatch)))
        }
        if let matchForVersionType = value.matchForVersionType {
            items.add(SmithyHTTPAPI.Header(name: "Match-For-Version-Type", value: Swift.String(matchForVersionType.rawValue)))
        }
        return items
    }
}

extension UpdateAssetPropertyInput {

    static func urlPathProvider(_ value: UpdateAssetPropertyInput) -> Swift.String? {
        guard let assetId = value.assetId else {
            return nil
        }
        guard let propertyId = value.propertyId else {
            return nil
        }
        return "/assets/\(assetId.urlPercentEncoding())/properties/\(propertyId.urlPercentEncoding())"
    }
}

extension UpdateDashboardInput {

    static func urlPathProvider(_ value: UpdateDashboardInput) -> Swift.String? {
        guard let dashboardId = value.dashboardId else {
            return nil
        }
        return "/dashboards/\(dashboardId.urlPercentEncoding())"
    }
}

extension UpdateGatewayInput {

    static func urlPathProvider(_ value: UpdateGatewayInput) -> Swift.String? {
        guard let gatewayId = value.gatewayId else {
            return nil
        }
        return "/20200301/gateways/\(gatewayId.urlPercentEncoding())"
    }
}

extension UpdateGatewayCapabilityConfigurationInput {

    static func urlPathProvider(_ value: UpdateGatewayCapabilityConfigurationInput) -> Swift.String? {
        guard let gatewayId = value.gatewayId else {
            return nil
        }
        return "/20200301/gateways/\(gatewayId.urlPercentEncoding())/capability"
    }
}

extension UpdatePortalInput {

    static func urlPathProvider(_ value: UpdatePortalInput) -> Swift.String? {
        guard let portalId = value.portalId else {
            return nil
        }
        return "/portals/\(portalId.urlPercentEncoding())"
    }
}

extension UpdateProjectInput {

    static func urlPathProvider(_ value: UpdateProjectInput) -> Swift.String? {
        guard let projectId = value.projectId else {
            return nil
        }
        return "/projects/\(projectId.urlPercentEncoding())"
    }
}

extension AssociateAssetsInput {

    static func write(value: AssociateAssetsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["childAssetId"].write(value.childAssetId)
        try writer["clientToken"].write(value.clientToken)
        try writer["hierarchyId"].write(value.hierarchyId)
    }
}

extension AssociateTimeSeriesToAssetPropertyInput {

    static func write(value: AssociateTimeSeriesToAssetPropertyInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
    }
}

extension BatchAssociateProjectAssetsInput {

    static func write(value: BatchAssociateProjectAssetsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["assetIds"].writeList(value.assetIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["clientToken"].write(value.clientToken)
    }
}

extension BatchDisassociateProjectAssetsInput {

    static func write(value: BatchDisassociateProjectAssetsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["assetIds"].writeList(value.assetIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["clientToken"].write(value.clientToken)
    }
}

extension BatchGetAssetPropertyAggregatesInput {

    static func write(value: BatchGetAssetPropertyAggregatesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["entries"].writeList(value.entries, memberWritingClosure: IoTSiteWiseClientTypes.BatchGetAssetPropertyAggregatesEntry.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension BatchGetAssetPropertyValueInput {

    static func write(value: BatchGetAssetPropertyValueInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["entries"].writeList(value.entries, memberWritingClosure: IoTSiteWiseClientTypes.BatchGetAssetPropertyValueEntry.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension BatchGetAssetPropertyValueHistoryInput {

    static func write(value: BatchGetAssetPropertyValueHistoryInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["entries"].writeList(value.entries, memberWritingClosure: IoTSiteWiseClientTypes.BatchGetAssetPropertyValueHistoryEntry.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension BatchPutAssetPropertyValueInput {

    static func write(value: BatchPutAssetPropertyValueInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["entries"].writeList(value.entries, memberWritingClosure: IoTSiteWiseClientTypes.PutAssetPropertyValueEntry.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateAccessPolicyInput {

    static func write(value: CreateAccessPolicyInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["accessPolicyIdentity"].write(value.accessPolicyIdentity, with: IoTSiteWiseClientTypes.Identity.write(value:to:))
        try writer["accessPolicyPermission"].write(value.accessPolicyPermission)
        try writer["accessPolicyResource"].write(value.accessPolicyResource, with: IoTSiteWiseClientTypes.Resource.write(value:to:))
        try writer["clientToken"].write(value.clientToken)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreateAssetInput {

    static func write(value: CreateAssetInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["assetDescription"].write(value.assetDescription)
        try writer["assetExternalId"].write(value.assetExternalId)
        try writer["assetId"].write(value.assetId)
        try writer["assetModelId"].write(value.assetModelId)
        try writer["assetName"].write(value.assetName)
        try writer["clientToken"].write(value.clientToken)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreateAssetModelInput {

    static func write(value: CreateAssetModelInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["assetModelCompositeModels"].writeList(value.assetModelCompositeModels, memberWritingClosure: IoTSiteWiseClientTypes.AssetModelCompositeModelDefinition.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["assetModelDescription"].write(value.assetModelDescription)
        try writer["assetModelExternalId"].write(value.assetModelExternalId)
        try writer["assetModelHierarchies"].writeList(value.assetModelHierarchies, memberWritingClosure: IoTSiteWiseClientTypes.AssetModelHierarchyDefinition.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["assetModelId"].write(value.assetModelId)
        try writer["assetModelName"].write(value.assetModelName)
        try writer["assetModelProperties"].writeList(value.assetModelProperties, memberWritingClosure: IoTSiteWiseClientTypes.AssetModelPropertyDefinition.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["assetModelType"].write(value.assetModelType)
        try writer["clientToken"].write(value.clientToken)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreateAssetModelCompositeModelInput {

    static func write(value: CreateAssetModelCompositeModelInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["assetModelCompositeModelDescription"].write(value.assetModelCompositeModelDescription)
        try writer["assetModelCompositeModelExternalId"].write(value.assetModelCompositeModelExternalId)
        try writer["assetModelCompositeModelId"].write(value.assetModelCompositeModelId)
        try writer["assetModelCompositeModelName"].write(value.assetModelCompositeModelName)
        try writer["assetModelCompositeModelProperties"].writeList(value.assetModelCompositeModelProperties, memberWritingClosure: IoTSiteWiseClientTypes.AssetModelPropertyDefinition.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["assetModelCompositeModelType"].write(value.assetModelCompositeModelType)
        try writer["clientToken"].write(value.clientToken)
        try writer["composedAssetModelId"].write(value.composedAssetModelId)
        try writer["parentAssetModelCompositeModelId"].write(value.parentAssetModelCompositeModelId)
    }
}

extension CreateBulkImportJobInput {

    static func write(value: CreateBulkImportJobInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["adaptiveIngestion"].write(value.adaptiveIngestion)
        try writer["deleteFilesAfterImport"].write(value.deleteFilesAfterImport)
        try writer["errorReportLocation"].write(value.errorReportLocation, with: IoTSiteWiseClientTypes.ErrorReportLocation.write(value:to:))
        try writer["files"].writeList(value.files, memberWritingClosure: IoTSiteWiseClientTypes.File.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["jobConfiguration"].write(value.jobConfiguration, with: IoTSiteWiseClientTypes.JobConfiguration.write(value:to:))
        try writer["jobName"].write(value.jobName)
        try writer["jobRoleArn"].write(value.jobRoleArn)
    }
}

extension CreateDashboardInput {

    static func write(value: CreateDashboardInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["dashboardDefinition"].write(value.dashboardDefinition)
        try writer["dashboardDescription"].write(value.dashboardDescription)
        try writer["dashboardName"].write(value.dashboardName)
        try writer["projectId"].write(value.projectId)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreateGatewayInput {

    static func write(value: CreateGatewayInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["gatewayName"].write(value.gatewayName)
        try writer["gatewayPlatform"].write(value.gatewayPlatform, with: IoTSiteWiseClientTypes.GatewayPlatform.write(value:to:))
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreatePortalInput {

    static func write(value: CreatePortalInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["alarms"].write(value.alarms, with: IoTSiteWiseClientTypes.Alarms.write(value:to:))
        try writer["clientToken"].write(value.clientToken)
        try writer["notificationSenderEmail"].write(value.notificationSenderEmail)
        try writer["portalAuthMode"].write(value.portalAuthMode)
        try writer["portalContactEmail"].write(value.portalContactEmail)
        try writer["portalDescription"].write(value.portalDescription)
        try writer["portalLogoImageFile"].write(value.portalLogoImageFile, with: IoTSiteWiseClientTypes.ImageFile.write(value:to:))
        try writer["portalName"].write(value.portalName)
        try writer["roleArn"].write(value.roleArn)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension CreateProjectInput {

    static func write(value: CreateProjectInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["portalId"].write(value.portalId)
        try writer["projectDescription"].write(value.projectDescription)
        try writer["projectName"].write(value.projectName)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension DeleteTimeSeriesInput {

    static func write(value: DeleteTimeSeriesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
    }
}

extension DisassociateAssetsInput {

    static func write(value: DisassociateAssetsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["childAssetId"].write(value.childAssetId)
        try writer["clientToken"].write(value.clientToken)
        try writer["hierarchyId"].write(value.hierarchyId)
    }
}

extension DisassociateTimeSeriesFromAssetPropertyInput {

    static func write(value: DisassociateTimeSeriesFromAssetPropertyInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
    }
}

extension ExecuteActionInput {

    static func write(value: ExecuteActionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["actionDefinitionId"].write(value.actionDefinitionId)
        try writer["actionPayload"].write(value.actionPayload, with: IoTSiteWiseClientTypes.ActionPayload.write(value:to:))
        try writer["clientToken"].write(value.clientToken)
        try writer["targetResource"].write(value.targetResource, with: IoTSiteWiseClientTypes.TargetResource.write(value:to:))
    }
}

extension ExecuteQueryInput {

    static func write(value: ExecuteQueryInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
        try writer["queryStatement"].write(value.queryStatement)
    }
}

extension PutDefaultEncryptionConfigurationInput {

    static func write(value: PutDefaultEncryptionConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["encryptionType"].write(value.encryptionType)
        try writer["kmsKeyId"].write(value.kmsKeyId)
    }
}

extension PutLoggingOptionsInput {

    static func write(value: PutLoggingOptionsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["loggingOptions"].write(value.loggingOptions, with: IoTSiteWiseClientTypes.LoggingOptions.write(value:to:))
    }
}

extension PutStorageConfigurationInput {

    static func write(value: PutStorageConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["disassociatedDataStorage"].write(value.disassociatedDataStorage)
        try writer["multiLayerStorage"].write(value.multiLayerStorage, with: IoTSiteWiseClientTypes.MultiLayerStorage.write(value:to:))
        try writer["retentionPeriod"].write(value.retentionPeriod, with: IoTSiteWiseClientTypes.RetentionPeriod.write(value:to:))
        try writer["storageType"].write(value.storageType)
        try writer["warmTier"].write(value.warmTier)
        try writer["warmTierRetentionPeriod"].write(value.warmTierRetentionPeriod, with: IoTSiteWiseClientTypes.WarmTierRetentionPeriod.write(value:to:))
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension UpdateAccessPolicyInput {

    static func write(value: UpdateAccessPolicyInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["accessPolicyIdentity"].write(value.accessPolicyIdentity, with: IoTSiteWiseClientTypes.Identity.write(value:to:))
        try writer["accessPolicyPermission"].write(value.accessPolicyPermission)
        try writer["accessPolicyResource"].write(value.accessPolicyResource, with: IoTSiteWiseClientTypes.Resource.write(value:to:))
        try writer["clientToken"].write(value.clientToken)
    }
}

extension UpdateAssetInput {

    static func write(value: UpdateAssetInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["assetDescription"].write(value.assetDescription)
        try writer["assetExternalId"].write(value.assetExternalId)
        try writer["assetName"].write(value.assetName)
        try writer["clientToken"].write(value.clientToken)
    }
}

extension UpdateAssetModelInput {

    static func write(value: UpdateAssetModelInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["assetModelCompositeModels"].writeList(value.assetModelCompositeModels, memberWritingClosure: IoTSiteWiseClientTypes.AssetModelCompositeModel.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["assetModelDescription"].write(value.assetModelDescription)
        try writer["assetModelExternalId"].write(value.assetModelExternalId)
        try writer["assetModelHierarchies"].writeList(value.assetModelHierarchies, memberWritingClosure: IoTSiteWiseClientTypes.AssetModelHierarchy.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["assetModelName"].write(value.assetModelName)
        try writer["assetModelProperties"].writeList(value.assetModelProperties, memberWritingClosure: IoTSiteWiseClientTypes.AssetModelProperty.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["clientToken"].write(value.clientToken)
    }
}

extension UpdateAssetModelCompositeModelInput {

    static func write(value: UpdateAssetModelCompositeModelInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["assetModelCompositeModelDescription"].write(value.assetModelCompositeModelDescription)
        try writer["assetModelCompositeModelExternalId"].write(value.assetModelCompositeModelExternalId)
        try writer["assetModelCompositeModelName"].write(value.assetModelCompositeModelName)
        try writer["assetModelCompositeModelProperties"].writeList(value.assetModelCompositeModelProperties, memberWritingClosure: IoTSiteWiseClientTypes.AssetModelProperty.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["clientToken"].write(value.clientToken)
    }
}

extension UpdateAssetPropertyInput {

    static func write(value: UpdateAssetPropertyInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["propertyAlias"].write(value.propertyAlias)
        try writer["propertyNotificationState"].write(value.propertyNotificationState)
        try writer["propertyUnit"].write(value.propertyUnit)
    }
}

extension UpdateDashboardInput {

    static func write(value: UpdateDashboardInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["dashboardDefinition"].write(value.dashboardDefinition)
        try writer["dashboardDescription"].write(value.dashboardDescription)
        try writer["dashboardName"].write(value.dashboardName)
    }
}

extension UpdateGatewayInput {

    static func write(value: UpdateGatewayInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["gatewayName"].write(value.gatewayName)
    }
}

extension UpdateGatewayCapabilityConfigurationInput {

    static func write(value: UpdateGatewayCapabilityConfigurationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["capabilityConfiguration"].write(value.capabilityConfiguration)
        try writer["capabilityNamespace"].write(value.capabilityNamespace)
    }
}

extension UpdatePortalInput {

    static func write(value: UpdatePortalInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["alarms"].write(value.alarms, with: IoTSiteWiseClientTypes.Alarms.write(value:to:))
        try writer["clientToken"].write(value.clientToken)
        try writer["notificationSenderEmail"].write(value.notificationSenderEmail)
        try writer["portalContactEmail"].write(value.portalContactEmail)
        try writer["portalDescription"].write(value.portalDescription)
        try writer["portalLogoImage"].write(value.portalLogoImage, with: IoTSiteWiseClientTypes.Image.write(value:to:))
        try writer["portalName"].write(value.portalName)
        try writer["roleArn"].write(value.roleArn)
    }
}

extension UpdateProjectInput {

    static func write(value: UpdateProjectInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["projectDescription"].write(value.projectDescription)
        try writer["projectName"].write(value.projectName)
    }
}

extension AssociateAssetsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AssociateAssetsOutput {
        return AssociateAssetsOutput()
    }
}

extension AssociateTimeSeriesToAssetPropertyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AssociateTimeSeriesToAssetPropertyOutput {
        return AssociateTimeSeriesToAssetPropertyOutput()
    }
}

extension BatchAssociateProjectAssetsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> BatchAssociateProjectAssetsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = BatchAssociateProjectAssetsOutput()
        value.errors = try reader["errors"].readListIfPresent(memberReadingClosure: IoTSiteWiseClientTypes.AssetErrorDetails.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BatchDisassociateProjectAssetsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> BatchDisassociateProjectAssetsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = BatchDisassociateProjectAssetsOutput()
        value.errors = try reader["errors"].readListIfPresent(memberReadingClosure: IoTSiteWiseClientTypes.AssetErrorDetails.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BatchGetAssetPropertyAggregatesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> BatchGetAssetPropertyAggregatesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = BatchGetAssetPropertyAggregatesOutput()
        value.errorEntries = try reader["errorEntries"].readListIfPresent(memberReadingClosure: IoTSiteWiseClientTypes.BatchGetAssetPropertyAggregatesErrorEntry.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.skippedEntries = try reader["skippedEntries"].readListIfPresent(memberReadingClosure: IoTSiteWiseClientTypes.BatchGetAssetPropertyAggregatesSkippedEntry.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.successEntries = try reader["successEntries"].readListIfPresent(memberReadingClosure: IoTSiteWiseClientTypes.BatchGetAssetPropertyAggregatesSuccessEntry.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension BatchGetAssetPropertyValueOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> BatchGetAssetPropertyValueOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = BatchGetAssetPropertyValueOutput()
        value.errorEntries = try reader["errorEntries"].readListIfPresent(memberReadingClosure: IoTSiteWiseClientTypes.BatchGetAssetPropertyValueErrorEntry.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.skippedEntries = try reader["skippedEntries"].readListIfPresent(memberReadingClosure: IoTSiteWiseClientTypes.BatchGetAssetPropertyValueSkippedEntry.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.successEntries = try reader["successEntries"].readListIfPresent(memberReadingClosure: IoTSiteWiseClientTypes.BatchGetAssetPropertyValueSuccessEntry.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension BatchGetAssetPropertyValueHistoryOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> BatchGetAssetPropertyValueHistoryOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = BatchGetAssetPropertyValueHistoryOutput()
        value.errorEntries = try reader["errorEntries"].readListIfPresent(memberReadingClosure: IoTSiteWiseClientTypes.BatchGetAssetPropertyValueHistoryErrorEntry.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.skippedEntries = try reader["skippedEntries"].readListIfPresent(memberReadingClosure: IoTSiteWiseClientTypes.BatchGetAssetPropertyValueHistorySkippedEntry.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.successEntries = try reader["successEntries"].readListIfPresent(memberReadingClosure: IoTSiteWiseClientTypes.BatchGetAssetPropertyValueHistorySuccessEntry.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension BatchPutAssetPropertyValueOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> BatchPutAssetPropertyValueOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = BatchPutAssetPropertyValueOutput()
        value.errorEntries = try reader["errorEntries"].readListIfPresent(memberReadingClosure: IoTSiteWiseClientTypes.BatchPutAssetPropertyErrorEntry.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension CreateAccessPolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateAccessPolicyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateAccessPolicyOutput()
        value.accessPolicyArn = try reader["accessPolicyArn"].readIfPresent() ?? ""
        value.accessPolicyId = try reader["accessPolicyId"].readIfPresent() ?? ""
        return value
    }
}

extension CreateAssetOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateAssetOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateAssetOutput()
        value.assetArn = try reader["assetArn"].readIfPresent() ?? ""
        value.assetId = try reader["assetId"].readIfPresent() ?? ""
        value.assetStatus = try reader["assetStatus"].readIfPresent(with: IoTSiteWiseClientTypes.AssetStatus.read(from:))
        return value
    }
}

extension CreateAssetModelOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateAssetModelOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateAssetModelOutput()
        value.assetModelArn = try reader["assetModelArn"].readIfPresent() ?? ""
        value.assetModelId = try reader["assetModelId"].readIfPresent() ?? ""
        value.assetModelStatus = try reader["assetModelStatus"].readIfPresent(with: IoTSiteWiseClientTypes.AssetModelStatus.read(from:))
        return value
    }
}

extension CreateAssetModelCompositeModelOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateAssetModelCompositeModelOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateAssetModelCompositeModelOutput()
        value.assetModelCompositeModelId = try reader["assetModelCompositeModelId"].readIfPresent() ?? ""
        value.assetModelCompositeModelPath = try reader["assetModelCompositeModelPath"].readListIfPresent(memberReadingClosure: IoTSiteWiseClientTypes.AssetModelCompositeModelPathSegment.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.assetModelStatus = try reader["assetModelStatus"].readIfPresent(with: IoTSiteWiseClientTypes.AssetModelStatus.read(from:))
        return value
    }
}

extension CreateBulkImportJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateBulkImportJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateBulkImportJobOutput()
        value.jobId = try reader["jobId"].readIfPresent() ?? ""
        value.jobName = try reader["jobName"].readIfPresent() ?? ""
        value.jobStatus = try reader["jobStatus"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension CreateDashboardOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateDashboardOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateDashboardOutput()
        value.dashboardArn = try reader["dashboardArn"].readIfPresent() ?? ""
        value.dashboardId = try reader["dashboardId"].readIfPresent() ?? ""
        return value
    }
}

extension CreateGatewayOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateGatewayOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateGatewayOutput()
        value.gatewayArn = try reader["gatewayArn"].readIfPresent() ?? ""
        value.gatewayId = try reader["gatewayId"].readIfPresent() ?? ""
        return value
    }
}

extension CreatePortalOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreatePortalOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreatePortalOutput()
        value.portalArn = try reader["portalArn"].readIfPresent() ?? ""
        value.portalId = try reader["portalId"].readIfPresent() ?? ""
        value.portalStartUrl = try reader["portalStartUrl"].readIfPresent() ?? ""
        value.portalStatus = try reader["portalStatus"].readIfPresent(with: IoTSiteWiseClientTypes.PortalStatus.read(from:))
        value.ssoApplicationId = try reader["ssoApplicationId"].readIfPresent() ?? ""
        return value
    }
}

extension CreateProjectOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateProjectOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateProjectOutput()
        value.projectArn = try reader["projectArn"].readIfPresent() ?? ""
        value.projectId = try reader["projectId"].readIfPresent() ?? ""
        return value
    }
}

extension DeleteAccessPolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteAccessPolicyOutput {
        return DeleteAccessPolicyOutput()
    }
}

extension DeleteAssetOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteAssetOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteAssetOutput()
        value.assetStatus = try reader["assetStatus"].readIfPresent(with: IoTSiteWiseClientTypes.AssetStatus.read(from:))
        return value
    }
}

extension DeleteAssetModelOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteAssetModelOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteAssetModelOutput()
        value.assetModelStatus = try reader["assetModelStatus"].readIfPresent(with: IoTSiteWiseClientTypes.AssetModelStatus.read(from:))
        return value
    }
}

extension DeleteAssetModelCompositeModelOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteAssetModelCompositeModelOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteAssetModelCompositeModelOutput()
        value.assetModelStatus = try reader["assetModelStatus"].readIfPresent(with: IoTSiteWiseClientTypes.AssetModelStatus.read(from:))
        return value
    }
}

extension DeleteDashboardOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteDashboardOutput {
        return DeleteDashboardOutput()
    }
}

extension DeleteGatewayOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteGatewayOutput {
        return DeleteGatewayOutput()
    }
}

extension DeletePortalOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeletePortalOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeletePortalOutput()
        value.portalStatus = try reader["portalStatus"].readIfPresent(with: IoTSiteWiseClientTypes.PortalStatus.read(from:))
        return value
    }
}

extension DeleteProjectOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteProjectOutput {
        return DeleteProjectOutput()
    }
}

extension DeleteTimeSeriesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteTimeSeriesOutput {
        return DeleteTimeSeriesOutput()
    }
}

extension DescribeAccessPolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeAccessPolicyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeAccessPolicyOutput()
        value.accessPolicyArn = try reader["accessPolicyArn"].readIfPresent() ?? ""
        value.accessPolicyCreationDate = try reader["accessPolicyCreationDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.accessPolicyId = try reader["accessPolicyId"].readIfPresent() ?? ""
        value.accessPolicyIdentity = try reader["accessPolicyIdentity"].readIfPresent(with: IoTSiteWiseClientTypes.Identity.read(from:))
        value.accessPolicyLastUpdateDate = try reader["accessPolicyLastUpdateDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.accessPolicyPermission = try reader["accessPolicyPermission"].readIfPresent() ?? .sdkUnknown("")
        value.accessPolicyResource = try reader["accessPolicyResource"].readIfPresent(with: IoTSiteWiseClientTypes.Resource.read(from:))
        return value
    }
}

extension DescribeActionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeActionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeActionOutput()
        value.actionDefinitionId = try reader["actionDefinitionId"].readIfPresent() ?? ""
        value.actionId = try reader["actionId"].readIfPresent() ?? ""
        value.actionPayload = try reader["actionPayload"].readIfPresent(with: IoTSiteWiseClientTypes.ActionPayload.read(from:))
        value.executionTime = try reader["executionTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.targetResource = try reader["targetResource"].readIfPresent(with: IoTSiteWiseClientTypes.TargetResource.read(from:))
        return value
    }
}

extension DescribeAssetOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeAssetOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeAssetOutput()
        value.assetArn = try reader["assetArn"].readIfPresent() ?? ""
        value.assetCompositeModelSummaries = try reader["assetCompositeModelSummaries"].readListIfPresent(memberReadingClosure: IoTSiteWiseClientTypes.AssetCompositeModelSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.assetCompositeModels = try reader["assetCompositeModels"].readListIfPresent(memberReadingClosure: IoTSiteWiseClientTypes.AssetCompositeModel.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.assetCreationDate = try reader["assetCreationDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.assetDescription = try reader["assetDescription"].readIfPresent()
        value.assetExternalId = try reader["assetExternalId"].readIfPresent()
        value.assetHierarchies = try reader["assetHierarchies"].readListIfPresent(memberReadingClosure: IoTSiteWiseClientTypes.AssetHierarchy.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.assetId = try reader["assetId"].readIfPresent() ?? ""
        value.assetLastUpdateDate = try reader["assetLastUpdateDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.assetModelId = try reader["assetModelId"].readIfPresent() ?? ""
        value.assetName = try reader["assetName"].readIfPresent() ?? ""
        value.assetProperties = try reader["assetProperties"].readListIfPresent(memberReadingClosure: IoTSiteWiseClientTypes.AssetProperty.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.assetStatus = try reader["assetStatus"].readIfPresent(with: IoTSiteWiseClientTypes.AssetStatus.read(from:))
        return value
    }
}

extension DescribeAssetCompositeModelOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeAssetCompositeModelOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeAssetCompositeModelOutput()
        value.actionDefinitions = try reader["actionDefinitions"].readListIfPresent(memberReadingClosure: IoTSiteWiseClientTypes.ActionDefinition.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.assetCompositeModelDescription = try reader["assetCompositeModelDescription"].readIfPresent() ?? ""
        value.assetCompositeModelExternalId = try reader["assetCompositeModelExternalId"].readIfPresent()
        value.assetCompositeModelId = try reader["assetCompositeModelId"].readIfPresent() ?? ""
        value.assetCompositeModelName = try reader["assetCompositeModelName"].readIfPresent() ?? ""
        value.assetCompositeModelPath = try reader["assetCompositeModelPath"].readListIfPresent(memberReadingClosure: IoTSiteWiseClientTypes.AssetCompositeModelPathSegment.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.assetCompositeModelProperties = try reader["assetCompositeModelProperties"].readListIfPresent(memberReadingClosure: IoTSiteWiseClientTypes.AssetProperty.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.assetCompositeModelSummaries = try reader["assetCompositeModelSummaries"].readListIfPresent(memberReadingClosure: IoTSiteWiseClientTypes.AssetCompositeModelSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.assetCompositeModelType = try reader["assetCompositeModelType"].readIfPresent() ?? ""
        value.assetId = try reader["assetId"].readIfPresent() ?? ""
        return value
    }
}

extension DescribeAssetModelOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeAssetModelOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeAssetModelOutput()
        if let eTagHeaderValue = httpResponse.headers.value(for: "ETag") {
            value.eTag = eTagHeaderValue
        }
        value.assetModelArn = try reader["assetModelArn"].readIfPresent() ?? ""
        value.assetModelCompositeModelSummaries = try reader["assetModelCompositeModelSummaries"].readListIfPresent(memberReadingClosure: IoTSiteWiseClientTypes.AssetModelCompositeModelSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.assetModelCompositeModels = try reader["assetModelCompositeModels"].readListIfPresent(memberReadingClosure: IoTSiteWiseClientTypes.AssetModelCompositeModel.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.assetModelCreationDate = try reader["assetModelCreationDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.assetModelDescription = try reader["assetModelDescription"].readIfPresent() ?? ""
        value.assetModelExternalId = try reader["assetModelExternalId"].readIfPresent()
        value.assetModelHierarchies = try reader["assetModelHierarchies"].readListIfPresent(memberReadingClosure: IoTSiteWiseClientTypes.AssetModelHierarchy.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.assetModelId = try reader["assetModelId"].readIfPresent() ?? ""
        value.assetModelLastUpdateDate = try reader["assetModelLastUpdateDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.assetModelName = try reader["assetModelName"].readIfPresent() ?? ""
        value.assetModelProperties = try reader["assetModelProperties"].readListIfPresent(memberReadingClosure: IoTSiteWiseClientTypes.AssetModelProperty.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.assetModelStatus = try reader["assetModelStatus"].readIfPresent(with: IoTSiteWiseClientTypes.AssetModelStatus.read(from:))
        value.assetModelType = try reader["assetModelType"].readIfPresent()
        value.assetModelVersion = try reader["assetModelVersion"].readIfPresent()
        return value
    }
}

extension DescribeAssetModelCompositeModelOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeAssetModelCompositeModelOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeAssetModelCompositeModelOutput()
        value.actionDefinitions = try reader["actionDefinitions"].readListIfPresent(memberReadingClosure: IoTSiteWiseClientTypes.ActionDefinition.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.assetModelCompositeModelDescription = try reader["assetModelCompositeModelDescription"].readIfPresent() ?? ""
        value.assetModelCompositeModelExternalId = try reader["assetModelCompositeModelExternalId"].readIfPresent()
        value.assetModelCompositeModelId = try reader["assetModelCompositeModelId"].readIfPresent() ?? ""
        value.assetModelCompositeModelName = try reader["assetModelCompositeModelName"].readIfPresent() ?? ""
        value.assetModelCompositeModelPath = try reader["assetModelCompositeModelPath"].readListIfPresent(memberReadingClosure: IoTSiteWiseClientTypes.AssetModelCompositeModelPathSegment.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.assetModelCompositeModelProperties = try reader["assetModelCompositeModelProperties"].readListIfPresent(memberReadingClosure: IoTSiteWiseClientTypes.AssetModelProperty.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.assetModelCompositeModelSummaries = try reader["assetModelCompositeModelSummaries"].readListIfPresent(memberReadingClosure: IoTSiteWiseClientTypes.AssetModelCompositeModelSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.assetModelCompositeModelType = try reader["assetModelCompositeModelType"].readIfPresent() ?? ""
        value.assetModelId = try reader["assetModelId"].readIfPresent() ?? ""
        value.compositionDetails = try reader["compositionDetails"].readIfPresent(with: IoTSiteWiseClientTypes.CompositionDetails.read(from:))
        return value
    }
}

extension DescribeAssetPropertyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeAssetPropertyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeAssetPropertyOutput()
        value.assetExternalId = try reader["assetExternalId"].readIfPresent()
        value.assetId = try reader["assetId"].readIfPresent() ?? ""
        value.assetModelId = try reader["assetModelId"].readIfPresent() ?? ""
        value.assetName = try reader["assetName"].readIfPresent() ?? ""
        value.assetProperty = try reader["assetProperty"].readIfPresent(with: IoTSiteWiseClientTypes.Property.read(from:))
        value.compositeModel = try reader["compositeModel"].readIfPresent(with: IoTSiteWiseClientTypes.CompositeModelProperty.read(from:))
        return value
    }
}

extension DescribeBulkImportJobOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeBulkImportJobOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeBulkImportJobOutput()
        value.adaptiveIngestion = try reader["adaptiveIngestion"].readIfPresent()
        value.deleteFilesAfterImport = try reader["deleteFilesAfterImport"].readIfPresent()
        value.errorReportLocation = try reader["errorReportLocation"].readIfPresent(with: IoTSiteWiseClientTypes.ErrorReportLocation.read(from:))
        value.files = try reader["files"].readListIfPresent(memberReadingClosure: IoTSiteWiseClientTypes.File.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.jobConfiguration = try reader["jobConfiguration"].readIfPresent(with: IoTSiteWiseClientTypes.JobConfiguration.read(from:))
        value.jobCreationDate = try reader["jobCreationDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.jobId = try reader["jobId"].readIfPresent() ?? ""
        value.jobLastUpdateDate = try reader["jobLastUpdateDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.jobName = try reader["jobName"].readIfPresent() ?? ""
        value.jobRoleArn = try reader["jobRoleArn"].readIfPresent() ?? ""
        value.jobStatus = try reader["jobStatus"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension DescribeDashboardOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeDashboardOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeDashboardOutput()
        value.dashboardArn = try reader["dashboardArn"].readIfPresent() ?? ""
        value.dashboardCreationDate = try reader["dashboardCreationDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.dashboardDefinition = try reader["dashboardDefinition"].readIfPresent() ?? ""
        value.dashboardDescription = try reader["dashboardDescription"].readIfPresent()
        value.dashboardId = try reader["dashboardId"].readIfPresent() ?? ""
        value.dashboardLastUpdateDate = try reader["dashboardLastUpdateDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.dashboardName = try reader["dashboardName"].readIfPresent() ?? ""
        value.projectId = try reader["projectId"].readIfPresent() ?? ""
        return value
    }
}

extension DescribeDefaultEncryptionConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeDefaultEncryptionConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeDefaultEncryptionConfigurationOutput()
        value.configurationStatus = try reader["configurationStatus"].readIfPresent(with: IoTSiteWiseClientTypes.ConfigurationStatus.read(from:))
        value.encryptionType = try reader["encryptionType"].readIfPresent() ?? .sdkUnknown("")
        value.kmsKeyArn = try reader["kmsKeyArn"].readIfPresent()
        return value
    }
}

extension DescribeGatewayOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeGatewayOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeGatewayOutput()
        value.creationDate = try reader["creationDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.gatewayArn = try reader["gatewayArn"].readIfPresent() ?? ""
        value.gatewayCapabilitySummaries = try reader["gatewayCapabilitySummaries"].readListIfPresent(memberReadingClosure: IoTSiteWiseClientTypes.GatewayCapabilitySummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.gatewayId = try reader["gatewayId"].readIfPresent() ?? ""
        value.gatewayName = try reader["gatewayName"].readIfPresent() ?? ""
        value.gatewayPlatform = try reader["gatewayPlatform"].readIfPresent(with: IoTSiteWiseClientTypes.GatewayPlatform.read(from:))
        value.lastUpdateDate = try reader["lastUpdateDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension DescribeGatewayCapabilityConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeGatewayCapabilityConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeGatewayCapabilityConfigurationOutput()
        value.capabilityConfiguration = try reader["capabilityConfiguration"].readIfPresent() ?? ""
        value.capabilityNamespace = try reader["capabilityNamespace"].readIfPresent() ?? ""
        value.capabilitySyncStatus = try reader["capabilitySyncStatus"].readIfPresent() ?? .sdkUnknown("")
        value.gatewayId = try reader["gatewayId"].readIfPresent() ?? ""
        return value
    }
}

extension DescribeLoggingOptionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeLoggingOptionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeLoggingOptionsOutput()
        value.loggingOptions = try reader["loggingOptions"].readIfPresent(with: IoTSiteWiseClientTypes.LoggingOptions.read(from:))
        return value
    }
}

extension DescribePortalOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribePortalOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribePortalOutput()
        value.alarms = try reader["alarms"].readIfPresent(with: IoTSiteWiseClientTypes.Alarms.read(from:))
        value.notificationSenderEmail = try reader["notificationSenderEmail"].readIfPresent()
        value.portalArn = try reader["portalArn"].readIfPresent() ?? ""
        value.portalAuthMode = try reader["portalAuthMode"].readIfPresent()
        value.portalClientId = try reader["portalClientId"].readIfPresent() ?? ""
        value.portalContactEmail = try reader["portalContactEmail"].readIfPresent() ?? ""
        value.portalCreationDate = try reader["portalCreationDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.portalDescription = try reader["portalDescription"].readIfPresent()
        value.portalId = try reader["portalId"].readIfPresent() ?? ""
        value.portalLastUpdateDate = try reader["portalLastUpdateDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.portalLogoImageLocation = try reader["portalLogoImageLocation"].readIfPresent(with: IoTSiteWiseClientTypes.ImageLocation.read(from:))
        value.portalName = try reader["portalName"].readIfPresent() ?? ""
        value.portalStartUrl = try reader["portalStartUrl"].readIfPresent() ?? ""
        value.portalStatus = try reader["portalStatus"].readIfPresent(with: IoTSiteWiseClientTypes.PortalStatus.read(from:))
        value.roleArn = try reader["roleArn"].readIfPresent()
        return value
    }
}

extension DescribeProjectOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeProjectOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeProjectOutput()
        value.portalId = try reader["portalId"].readIfPresent() ?? ""
        value.projectArn = try reader["projectArn"].readIfPresent() ?? ""
        value.projectCreationDate = try reader["projectCreationDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.projectDescription = try reader["projectDescription"].readIfPresent()
        value.projectId = try reader["projectId"].readIfPresent() ?? ""
        value.projectLastUpdateDate = try reader["projectLastUpdateDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.projectName = try reader["projectName"].readIfPresent() ?? ""
        return value
    }
}

extension DescribeStorageConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeStorageConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeStorageConfigurationOutput()
        value.configurationStatus = try reader["configurationStatus"].readIfPresent(with: IoTSiteWiseClientTypes.ConfigurationStatus.read(from:))
        value.disassociatedDataStorage = try reader["disassociatedDataStorage"].readIfPresent()
        value.lastUpdateDate = try reader["lastUpdateDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.multiLayerStorage = try reader["multiLayerStorage"].readIfPresent(with: IoTSiteWiseClientTypes.MultiLayerStorage.read(from:))
        value.retentionPeriod = try reader["retentionPeriod"].readIfPresent(with: IoTSiteWiseClientTypes.RetentionPeriod.read(from:))
        value.storageType = try reader["storageType"].readIfPresent() ?? .sdkUnknown("")
        value.warmTier = try reader["warmTier"].readIfPresent()
        value.warmTierRetentionPeriod = try reader["warmTierRetentionPeriod"].readIfPresent(with: IoTSiteWiseClientTypes.WarmTierRetentionPeriod.read(from:))
        return value
    }
}

extension DescribeTimeSeriesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeTimeSeriesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeTimeSeriesOutput()
        value.alias = try reader["alias"].readIfPresent()
        value.assetId = try reader["assetId"].readIfPresent()
        value.dataType = try reader["dataType"].readIfPresent() ?? .sdkUnknown("")
        value.dataTypeSpec = try reader["dataTypeSpec"].readIfPresent()
        value.propertyId = try reader["propertyId"].readIfPresent()
        value.timeSeriesArn = try reader["timeSeriesArn"].readIfPresent() ?? ""
        value.timeSeriesCreationDate = try reader["timeSeriesCreationDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.timeSeriesId = try reader["timeSeriesId"].readIfPresent() ?? ""
        value.timeSeriesLastUpdateDate = try reader["timeSeriesLastUpdateDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension DisassociateAssetsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DisassociateAssetsOutput {
        return DisassociateAssetsOutput()
    }
}

extension DisassociateTimeSeriesFromAssetPropertyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DisassociateTimeSeriesFromAssetPropertyOutput {
        return DisassociateTimeSeriesFromAssetPropertyOutput()
    }
}

extension ExecuteActionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ExecuteActionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ExecuteActionOutput()
        value.actionId = try reader["actionId"].readIfPresent() ?? ""
        return value
    }
}

extension ExecuteQueryOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ExecuteQueryOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ExecuteQueryOutput()
        value.columns = try reader["columns"].readListIfPresent(memberReadingClosure: IoTSiteWiseClientTypes.ColumnInfo.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.rows = try reader["rows"].readListIfPresent(memberReadingClosure: IoTSiteWiseClientTypes.Row.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension GetAssetPropertyAggregatesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetAssetPropertyAggregatesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetAssetPropertyAggregatesOutput()
        value.aggregatedValues = try reader["aggregatedValues"].readListIfPresent(memberReadingClosure: IoTSiteWiseClientTypes.AggregatedValue.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension GetAssetPropertyValueOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetAssetPropertyValueOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetAssetPropertyValueOutput()
        value.propertyValue = try reader["propertyValue"].readIfPresent(with: IoTSiteWiseClientTypes.AssetPropertyValue.read(from:))
        return value
    }
}

extension GetAssetPropertyValueHistoryOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetAssetPropertyValueHistoryOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetAssetPropertyValueHistoryOutput()
        value.assetPropertyValueHistory = try reader["assetPropertyValueHistory"].readListIfPresent(memberReadingClosure: IoTSiteWiseClientTypes.AssetPropertyValue.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension GetInterpolatedAssetPropertyValuesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetInterpolatedAssetPropertyValuesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetInterpolatedAssetPropertyValuesOutput()
        value.interpolatedAssetPropertyValues = try reader["interpolatedAssetPropertyValues"].readListIfPresent(memberReadingClosure: IoTSiteWiseClientTypes.InterpolatedAssetPropertyValue.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListAccessPoliciesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListAccessPoliciesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListAccessPoliciesOutput()
        value.accessPolicySummaries = try reader["accessPolicySummaries"].readListIfPresent(memberReadingClosure: IoTSiteWiseClientTypes.AccessPolicySummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListActionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListActionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListActionsOutput()
        value.actionSummaries = try reader["actionSummaries"].readListIfPresent(memberReadingClosure: IoTSiteWiseClientTypes.ActionSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent() ?? ""
        return value
    }
}

extension ListAssetModelCompositeModelsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListAssetModelCompositeModelsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListAssetModelCompositeModelsOutput()
        value.assetModelCompositeModelSummaries = try reader["assetModelCompositeModelSummaries"].readListIfPresent(memberReadingClosure: IoTSiteWiseClientTypes.AssetModelCompositeModelSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListAssetModelPropertiesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListAssetModelPropertiesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListAssetModelPropertiesOutput()
        value.assetModelPropertySummaries = try reader["assetModelPropertySummaries"].readListIfPresent(memberReadingClosure: IoTSiteWiseClientTypes.AssetModelPropertySummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListAssetModelsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListAssetModelsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListAssetModelsOutput()
        value.assetModelSummaries = try reader["assetModelSummaries"].readListIfPresent(memberReadingClosure: IoTSiteWiseClientTypes.AssetModelSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListAssetPropertiesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListAssetPropertiesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListAssetPropertiesOutput()
        value.assetPropertySummaries = try reader["assetPropertySummaries"].readListIfPresent(memberReadingClosure: IoTSiteWiseClientTypes.AssetPropertySummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListAssetRelationshipsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListAssetRelationshipsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListAssetRelationshipsOutput()
        value.assetRelationshipSummaries = try reader["assetRelationshipSummaries"].readListIfPresent(memberReadingClosure: IoTSiteWiseClientTypes.AssetRelationshipSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListAssetsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListAssetsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListAssetsOutput()
        value.assetSummaries = try reader["assetSummaries"].readListIfPresent(memberReadingClosure: IoTSiteWiseClientTypes.AssetSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListAssociatedAssetsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListAssociatedAssetsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListAssociatedAssetsOutput()
        value.assetSummaries = try reader["assetSummaries"].readListIfPresent(memberReadingClosure: IoTSiteWiseClientTypes.AssociatedAssetsSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListBulkImportJobsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListBulkImportJobsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListBulkImportJobsOutput()
        value.jobSummaries = try reader["jobSummaries"].readListIfPresent(memberReadingClosure: IoTSiteWiseClientTypes.JobSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListCompositionRelationshipsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListCompositionRelationshipsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListCompositionRelationshipsOutput()
        value.compositionRelationshipSummaries = try reader["compositionRelationshipSummaries"].readListIfPresent(memberReadingClosure: IoTSiteWiseClientTypes.CompositionRelationshipSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListDashboardsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListDashboardsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListDashboardsOutput()
        value.dashboardSummaries = try reader["dashboardSummaries"].readListIfPresent(memberReadingClosure: IoTSiteWiseClientTypes.DashboardSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListGatewaysOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListGatewaysOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListGatewaysOutput()
        value.gatewaySummaries = try reader["gatewaySummaries"].readListIfPresent(memberReadingClosure: IoTSiteWiseClientTypes.GatewaySummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListPortalsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListPortalsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListPortalsOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.portalSummaries = try reader["portalSummaries"].readListIfPresent(memberReadingClosure: IoTSiteWiseClientTypes.PortalSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListProjectAssetsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListProjectAssetsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListProjectAssetsOutput()
        value.assetIds = try reader["assetIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListProjectsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListProjectsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListProjectsOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.projectSummaries = try reader["projectSummaries"].readListIfPresent(memberReadingClosure: IoTSiteWiseClientTypes.ProjectSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension ListTimeSeriesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTimeSeriesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTimeSeriesOutput()
        value.timeSeriesSummaries = try reader["TimeSeriesSummaries"].readListIfPresent(memberReadingClosure: IoTSiteWiseClientTypes.TimeSeriesSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension PutDefaultEncryptionConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutDefaultEncryptionConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = PutDefaultEncryptionConfigurationOutput()
        value.configurationStatus = try reader["configurationStatus"].readIfPresent(with: IoTSiteWiseClientTypes.ConfigurationStatus.read(from:))
        value.encryptionType = try reader["encryptionType"].readIfPresent() ?? .sdkUnknown("")
        value.kmsKeyArn = try reader["kmsKeyArn"].readIfPresent()
        return value
    }
}

extension PutLoggingOptionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutLoggingOptionsOutput {
        return PutLoggingOptionsOutput()
    }
}

extension PutStorageConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutStorageConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = PutStorageConfigurationOutput()
        value.configurationStatus = try reader["configurationStatus"].readIfPresent(with: IoTSiteWiseClientTypes.ConfigurationStatus.read(from:))
        value.disassociatedDataStorage = try reader["disassociatedDataStorage"].readIfPresent()
        value.multiLayerStorage = try reader["multiLayerStorage"].readIfPresent(with: IoTSiteWiseClientTypes.MultiLayerStorage.read(from:))
        value.retentionPeriod = try reader["retentionPeriod"].readIfPresent(with: IoTSiteWiseClientTypes.RetentionPeriod.read(from:))
        value.storageType = try reader["storageType"].readIfPresent() ?? .sdkUnknown("")
        value.warmTier = try reader["warmTier"].readIfPresent()
        value.warmTierRetentionPeriod = try reader["warmTierRetentionPeriod"].readIfPresent(with: IoTSiteWiseClientTypes.WarmTierRetentionPeriod.read(from:))
        return value
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

extension UpdateAccessPolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateAccessPolicyOutput {
        return UpdateAccessPolicyOutput()
    }
}

extension UpdateAssetOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateAssetOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateAssetOutput()
        value.assetStatus = try reader["assetStatus"].readIfPresent(with: IoTSiteWiseClientTypes.AssetStatus.read(from:))
        return value
    }
}

extension UpdateAssetModelOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateAssetModelOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateAssetModelOutput()
        value.assetModelStatus = try reader["assetModelStatus"].readIfPresent(with: IoTSiteWiseClientTypes.AssetModelStatus.read(from:))
        return value
    }
}

extension UpdateAssetModelCompositeModelOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateAssetModelCompositeModelOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateAssetModelCompositeModelOutput()
        value.assetModelCompositeModelPath = try reader["assetModelCompositeModelPath"].readListIfPresent(memberReadingClosure: IoTSiteWiseClientTypes.AssetModelCompositeModelPathSegment.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.assetModelStatus = try reader["assetModelStatus"].readIfPresent(with: IoTSiteWiseClientTypes.AssetModelStatus.read(from:))
        return value
    }
}

extension UpdateAssetPropertyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateAssetPropertyOutput {
        return UpdateAssetPropertyOutput()
    }
}

extension UpdateDashboardOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateDashboardOutput {
        return UpdateDashboardOutput()
    }
}

extension UpdateGatewayOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateGatewayOutput {
        return UpdateGatewayOutput()
    }
}

extension UpdateGatewayCapabilityConfigurationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateGatewayCapabilityConfigurationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateGatewayCapabilityConfigurationOutput()
        value.capabilityNamespace = try reader["capabilityNamespace"].readIfPresent() ?? ""
        value.capabilitySyncStatus = try reader["capabilitySyncStatus"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension UpdatePortalOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdatePortalOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdatePortalOutput()
        value.portalStatus = try reader["portalStatus"].readIfPresent(with: IoTSiteWiseClientTypes.PortalStatus.read(from:))
        return value
    }
}

extension UpdateProjectOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateProjectOutput {
        return UpdateProjectOutput()
    }
}

enum AssociateAssetsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictingOperationException": return try ConflictingOperationException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceAlreadyExistsException": return try ResourceAlreadyExistsException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum AssociateTimeSeriesToAssetPropertyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictingOperationException": return try ConflictingOperationException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum BatchAssociateProjectAssetsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum BatchDisassociateProjectAssetsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum BatchGetAssetPropertyAggregatesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum BatchGetAssetPropertyValueOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum BatchGetAssetPropertyValueHistoryOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum BatchPutAssetPropertyValueOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictingOperationException": return try ConflictingOperationException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateAccessPolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateAssetOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictingOperationException": return try ConflictingOperationException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceAlreadyExistsException": return try ResourceAlreadyExistsException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateAssetModelOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictingOperationException": return try ConflictingOperationException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceAlreadyExistsException": return try ResourceAlreadyExistsException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateAssetModelCompositeModelOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictingOperationException": return try ConflictingOperationException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "PreconditionFailedException": return try PreconditionFailedException.makeError(baseError: baseError)
            case "ResourceAlreadyExistsException": return try ResourceAlreadyExistsException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateBulkImportJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictingOperationException": return try ConflictingOperationException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceAlreadyExistsException": return try ResourceAlreadyExistsException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateDashboardOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateGatewayOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceAlreadyExistsException": return try ResourceAlreadyExistsException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreatePortalOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateProjectOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteAccessPolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteAssetOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictingOperationException": return try ConflictingOperationException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteAssetModelOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictingOperationException": return try ConflictingOperationException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "PreconditionFailedException": return try PreconditionFailedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteAssetModelCompositeModelOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictingOperationException": return try ConflictingOperationException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "PreconditionFailedException": return try PreconditionFailedException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteDashboardOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteGatewayOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictingOperationException": return try ConflictingOperationException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeletePortalOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictingOperationException": return try ConflictingOperationException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteProjectOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteTimeSeriesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictingOperationException": return try ConflictingOperationException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeAccessPolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeActionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeAssetOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeAssetCompositeModelOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeAssetModelOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeAssetModelCompositeModelOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeAssetPropertyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeBulkImportJobOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeDashboardOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeDefaultEncryptionConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeGatewayOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeGatewayCapabilityConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeLoggingOptionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribePortalOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeProjectOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeStorageConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictingOperationException": return try ConflictingOperationException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeTimeSeriesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DisassociateAssetsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictingOperationException": return try ConflictingOperationException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DisassociateTimeSeriesFromAssetPropertyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictingOperationException": return try ConflictingOperationException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ExecuteActionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictingOperationException": return try ConflictingOperationException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ExecuteQueryOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "QueryTimeoutException": return try QueryTimeoutException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetAssetPropertyAggregatesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetAssetPropertyValueOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetAssetPropertyValueHistoryOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetInterpolatedAssetPropertyValuesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceUnavailableException": return try ServiceUnavailableException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListAccessPoliciesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListActionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListAssetModelCompositeModelsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListAssetModelPropertiesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListAssetModelsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListAssetPropertiesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListAssetRelationshipsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListAssetsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListAssociatedAssetsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListBulkImportJobsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListCompositionRelationshipsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListDashboardsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListGatewaysOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListPortalsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListProjectAssetsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListProjectsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictingOperationException": return try ConflictingOperationException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTimeSeriesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutDefaultEncryptionConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictingOperationException": return try ConflictingOperationException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutLoggingOptionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictingOperationException": return try ConflictingOperationException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutStorageConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictingOperationException": return try ConflictingOperationException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceAlreadyExistsException": return try ResourceAlreadyExistsException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictingOperationException": return try ConflictingOperationException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "TooManyTagsException": return try TooManyTagsException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictingOperationException": return try ConflictingOperationException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "UnauthorizedException": return try UnauthorizedException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateAccessPolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateAssetOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictingOperationException": return try ConflictingOperationException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceAlreadyExistsException": return try ResourceAlreadyExistsException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateAssetModelOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictingOperationException": return try ConflictingOperationException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "PreconditionFailedException": return try PreconditionFailedException.makeError(baseError: baseError)
            case "ResourceAlreadyExistsException": return try ResourceAlreadyExistsException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateAssetModelCompositeModelOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictingOperationException": return try ConflictingOperationException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "PreconditionFailedException": return try PreconditionFailedException.makeError(baseError: baseError)
            case "ResourceAlreadyExistsException": return try ResourceAlreadyExistsException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateAssetPropertyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictingOperationException": return try ConflictingOperationException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateDashboardOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateGatewayOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictingOperationException": return try ConflictingOperationException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateGatewayCapabilityConfigurationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictingOperationException": return try ConflictingOperationException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdatePortalOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ConflictingOperationException": return try ConflictingOperationException.makeError(baseError: baseError)
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateProjectOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalFailureException": return try InternalFailureException.makeError(baseError: baseError)
            case "InvalidRequestException": return try InvalidRequestException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ResourceAlreadyExistsException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ResourceAlreadyExistsException {
        let reader = baseError.errorBodyReader
        var value = ResourceAlreadyExistsException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.properties.resourceArn = try reader["resourceArn"].readIfPresent() ?? ""
        value.properties.resourceId = try reader["resourceId"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidRequestException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InvalidRequestException {
        let reader = baseError.errorBodyReader
        var value = InvalidRequestException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ConflictingOperationException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ConflictingOperationException {
        let reader = baseError.errorBodyReader
        var value = ConflictingOperationException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.properties.resourceArn = try reader["resourceArn"].readIfPresent() ?? ""
        value.properties.resourceId = try reader["resourceId"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension LimitExceededException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> LimitExceededException {
        let reader = baseError.errorBodyReader
        var value = LimitExceededException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ThrottlingException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ThrottlingException {
        let reader = baseError.errorBodyReader
        var value = ThrottlingException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InternalFailureException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InternalFailureException {
        let reader = baseError.errorBodyReader
        var value = InternalFailureException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ServiceUnavailableException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ServiceUnavailableException {
        let reader = baseError.errorBodyReader
        var value = ServiceUnavailableException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension PreconditionFailedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> PreconditionFailedException {
        let reader = baseError.errorBodyReader
        var value = PreconditionFailedException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.properties.resourceArn = try reader["resourceArn"].readIfPresent() ?? ""
        value.properties.resourceId = try reader["resourceId"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension QueryTimeoutException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> QueryTimeoutException {
        let reader = baseError.errorBodyReader
        var value = QueryTimeoutException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ValidationException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ValidationException {
        let reader = baseError.errorBodyReader
        var value = ValidationException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension AccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> AccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = AccessDeniedException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension UnauthorizedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> UnauthorizedException {
        let reader = baseError.errorBodyReader
        var value = UnauthorizedException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension TooManyTagsException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> TooManyTagsException {
        let reader = baseError.errorBodyReader
        var value = TooManyTagsException()
        value.properties.message = try reader["message"].readIfPresent()
        value.properties.resourceName = try reader["resourceName"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension IoTSiteWiseClientTypes.AssetErrorDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTSiteWiseClientTypes.AssetErrorDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTSiteWiseClientTypes.AssetErrorDetails()
        value.assetId = try reader["assetId"].readIfPresent() ?? ""
        value.code = try reader["code"].readIfPresent() ?? .sdkUnknown("")
        value.message = try reader["message"].readIfPresent() ?? ""
        return value
    }
}

extension IoTSiteWiseClientTypes.BatchGetAssetPropertyAggregatesErrorEntry {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTSiteWiseClientTypes.BatchGetAssetPropertyAggregatesErrorEntry {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTSiteWiseClientTypes.BatchGetAssetPropertyAggregatesErrorEntry()
        value.errorCode = try reader["errorCode"].readIfPresent() ?? .sdkUnknown("")
        value.errorMessage = try reader["errorMessage"].readIfPresent() ?? ""
        value.entryId = try reader["entryId"].readIfPresent() ?? ""
        return value
    }
}

extension IoTSiteWiseClientTypes.BatchGetAssetPropertyAggregatesSuccessEntry {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTSiteWiseClientTypes.BatchGetAssetPropertyAggregatesSuccessEntry {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTSiteWiseClientTypes.BatchGetAssetPropertyAggregatesSuccessEntry()
        value.entryId = try reader["entryId"].readIfPresent() ?? ""
        value.aggregatedValues = try reader["aggregatedValues"].readListIfPresent(memberReadingClosure: IoTSiteWiseClientTypes.AggregatedValue.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension IoTSiteWiseClientTypes.AggregatedValue {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTSiteWiseClientTypes.AggregatedValue {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTSiteWiseClientTypes.AggregatedValue()
        value.timestamp = try reader["timestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.quality = try reader["quality"].readIfPresent()
        value.value = try reader["value"].readIfPresent(with: IoTSiteWiseClientTypes.Aggregates.read(from:))
        return value
    }
}

extension IoTSiteWiseClientTypes.Aggregates {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTSiteWiseClientTypes.Aggregates {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTSiteWiseClientTypes.Aggregates()
        value.average = try reader["average"].readIfPresent()
        value.count = try reader["count"].readIfPresent()
        value.maximum = try reader["maximum"].readIfPresent()
        value.minimum = try reader["minimum"].readIfPresent()
        value.sum = try reader["sum"].readIfPresent()
        value.standardDeviation = try reader["standardDeviation"].readIfPresent()
        return value
    }
}

extension IoTSiteWiseClientTypes.BatchGetAssetPropertyAggregatesSkippedEntry {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTSiteWiseClientTypes.BatchGetAssetPropertyAggregatesSkippedEntry {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTSiteWiseClientTypes.BatchGetAssetPropertyAggregatesSkippedEntry()
        value.entryId = try reader["entryId"].readIfPresent() ?? ""
        value.completionStatus = try reader["completionStatus"].readIfPresent() ?? .sdkUnknown("")
        value.errorInfo = try reader["errorInfo"].readIfPresent(with: IoTSiteWiseClientTypes.BatchGetAssetPropertyAggregatesErrorInfo.read(from:))
        return value
    }
}

extension IoTSiteWiseClientTypes.BatchGetAssetPropertyAggregatesErrorInfo {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTSiteWiseClientTypes.BatchGetAssetPropertyAggregatesErrorInfo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTSiteWiseClientTypes.BatchGetAssetPropertyAggregatesErrorInfo()
        value.errorCode = try reader["errorCode"].readIfPresent() ?? .sdkUnknown("")
        value.errorTimestamp = try reader["errorTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension IoTSiteWiseClientTypes.BatchGetAssetPropertyValueErrorEntry {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTSiteWiseClientTypes.BatchGetAssetPropertyValueErrorEntry {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTSiteWiseClientTypes.BatchGetAssetPropertyValueErrorEntry()
        value.errorCode = try reader["errorCode"].readIfPresent() ?? .sdkUnknown("")
        value.errorMessage = try reader["errorMessage"].readIfPresent() ?? ""
        value.entryId = try reader["entryId"].readIfPresent() ?? ""
        return value
    }
}

extension IoTSiteWiseClientTypes.BatchGetAssetPropertyValueSuccessEntry {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTSiteWiseClientTypes.BatchGetAssetPropertyValueSuccessEntry {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTSiteWiseClientTypes.BatchGetAssetPropertyValueSuccessEntry()
        value.entryId = try reader["entryId"].readIfPresent() ?? ""
        value.assetPropertyValue = try reader["assetPropertyValue"].readIfPresent(with: IoTSiteWiseClientTypes.AssetPropertyValue.read(from:))
        return value
    }
}

extension IoTSiteWiseClientTypes.AssetPropertyValue {

    static func write(value: IoTSiteWiseClientTypes.AssetPropertyValue?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["quality"].write(value.quality)
        try writer["timestamp"].write(value.timestamp, with: IoTSiteWiseClientTypes.TimeInNanos.write(value:to:))
        try writer["value"].write(value.value, with: IoTSiteWiseClientTypes.Variant.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTSiteWiseClientTypes.AssetPropertyValue {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTSiteWiseClientTypes.AssetPropertyValue()
        value.value = try reader["value"].readIfPresent(with: IoTSiteWiseClientTypes.Variant.read(from:))
        value.timestamp = try reader["timestamp"].readIfPresent(with: IoTSiteWiseClientTypes.TimeInNanos.read(from:))
        value.quality = try reader["quality"].readIfPresent()
        return value
    }
}

extension IoTSiteWiseClientTypes.TimeInNanos {

    static func write(value: IoTSiteWiseClientTypes.TimeInNanos?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["offsetInNanos"].write(value.offsetInNanos)
        try writer["timeInSeconds"].write(value.timeInSeconds)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTSiteWiseClientTypes.TimeInNanos {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTSiteWiseClientTypes.TimeInNanos()
        value.timeInSeconds = try reader["timeInSeconds"].readIfPresent() ?? 0
        value.offsetInNanos = try reader["offsetInNanos"].readIfPresent()
        return value
    }
}

extension IoTSiteWiseClientTypes.Variant {

    static func write(value: IoTSiteWiseClientTypes.Variant?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["booleanValue"].write(value.booleanValue)
        try writer["doubleValue"].write(value.doubleValue)
        try writer["integerValue"].write(value.integerValue)
        try writer["stringValue"].write(value.stringValue)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTSiteWiseClientTypes.Variant {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTSiteWiseClientTypes.Variant()
        value.stringValue = try reader["stringValue"].readIfPresent()
        value.integerValue = try reader["integerValue"].readIfPresent()
        value.doubleValue = try reader["doubleValue"].readIfPresent()
        value.booleanValue = try reader["booleanValue"].readIfPresent()
        return value
    }
}

extension IoTSiteWiseClientTypes.BatchGetAssetPropertyValueSkippedEntry {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTSiteWiseClientTypes.BatchGetAssetPropertyValueSkippedEntry {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTSiteWiseClientTypes.BatchGetAssetPropertyValueSkippedEntry()
        value.entryId = try reader["entryId"].readIfPresent() ?? ""
        value.completionStatus = try reader["completionStatus"].readIfPresent() ?? .sdkUnknown("")
        value.errorInfo = try reader["errorInfo"].readIfPresent(with: IoTSiteWiseClientTypes.BatchGetAssetPropertyValueErrorInfo.read(from:))
        return value
    }
}

extension IoTSiteWiseClientTypes.BatchGetAssetPropertyValueErrorInfo {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTSiteWiseClientTypes.BatchGetAssetPropertyValueErrorInfo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTSiteWiseClientTypes.BatchGetAssetPropertyValueErrorInfo()
        value.errorCode = try reader["errorCode"].readIfPresent() ?? .sdkUnknown("")
        value.errorTimestamp = try reader["errorTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension IoTSiteWiseClientTypes.BatchGetAssetPropertyValueHistoryErrorEntry {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTSiteWiseClientTypes.BatchGetAssetPropertyValueHistoryErrorEntry {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTSiteWiseClientTypes.BatchGetAssetPropertyValueHistoryErrorEntry()
        value.errorCode = try reader["errorCode"].readIfPresent() ?? .sdkUnknown("")
        value.errorMessage = try reader["errorMessage"].readIfPresent() ?? ""
        value.entryId = try reader["entryId"].readIfPresent() ?? ""
        return value
    }
}

extension IoTSiteWiseClientTypes.BatchGetAssetPropertyValueHistorySuccessEntry {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTSiteWiseClientTypes.BatchGetAssetPropertyValueHistorySuccessEntry {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTSiteWiseClientTypes.BatchGetAssetPropertyValueHistorySuccessEntry()
        value.entryId = try reader["entryId"].readIfPresent() ?? ""
        value.assetPropertyValueHistory = try reader["assetPropertyValueHistory"].readListIfPresent(memberReadingClosure: IoTSiteWiseClientTypes.AssetPropertyValue.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension IoTSiteWiseClientTypes.BatchGetAssetPropertyValueHistorySkippedEntry {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTSiteWiseClientTypes.BatchGetAssetPropertyValueHistorySkippedEntry {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTSiteWiseClientTypes.BatchGetAssetPropertyValueHistorySkippedEntry()
        value.entryId = try reader["entryId"].readIfPresent() ?? ""
        value.completionStatus = try reader["completionStatus"].readIfPresent() ?? .sdkUnknown("")
        value.errorInfo = try reader["errorInfo"].readIfPresent(with: IoTSiteWiseClientTypes.BatchGetAssetPropertyValueHistoryErrorInfo.read(from:))
        return value
    }
}

extension IoTSiteWiseClientTypes.BatchGetAssetPropertyValueHistoryErrorInfo {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTSiteWiseClientTypes.BatchGetAssetPropertyValueHistoryErrorInfo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTSiteWiseClientTypes.BatchGetAssetPropertyValueHistoryErrorInfo()
        value.errorCode = try reader["errorCode"].readIfPresent() ?? .sdkUnknown("")
        value.errorTimestamp = try reader["errorTimestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension IoTSiteWiseClientTypes.BatchPutAssetPropertyErrorEntry {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTSiteWiseClientTypes.BatchPutAssetPropertyErrorEntry {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTSiteWiseClientTypes.BatchPutAssetPropertyErrorEntry()
        value.entryId = try reader["entryId"].readIfPresent() ?? ""
        value.errors = try reader["errors"].readListIfPresent(memberReadingClosure: IoTSiteWiseClientTypes.BatchPutAssetPropertyError.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension IoTSiteWiseClientTypes.BatchPutAssetPropertyError {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTSiteWiseClientTypes.BatchPutAssetPropertyError {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTSiteWiseClientTypes.BatchPutAssetPropertyError()
        value.errorCode = try reader["errorCode"].readIfPresent() ?? .sdkUnknown("")
        value.errorMessage = try reader["errorMessage"].readIfPresent() ?? ""
        value.timestamps = try reader["timestamps"].readListIfPresent(memberReadingClosure: IoTSiteWiseClientTypes.TimeInNanos.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension IoTSiteWiseClientTypes.AssetStatus {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTSiteWiseClientTypes.AssetStatus {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTSiteWiseClientTypes.AssetStatus()
        value.state = try reader["state"].readIfPresent() ?? .sdkUnknown("")
        value.error = try reader["error"].readIfPresent(with: IoTSiteWiseClientTypes.ErrorDetails.read(from:))
        return value
    }
}

extension IoTSiteWiseClientTypes.ErrorDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTSiteWiseClientTypes.ErrorDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTSiteWiseClientTypes.ErrorDetails()
        value.code = try reader["code"].readIfPresent() ?? .sdkUnknown("")
        value.message = try reader["message"].readIfPresent() ?? ""
        value.details = try reader["details"].readListIfPresent(memberReadingClosure: IoTSiteWiseClientTypes.DetailedError.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension IoTSiteWiseClientTypes.DetailedError {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTSiteWiseClientTypes.DetailedError {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTSiteWiseClientTypes.DetailedError()
        value.code = try reader["code"].readIfPresent() ?? .sdkUnknown("")
        value.message = try reader["message"].readIfPresent() ?? ""
        return value
    }
}

extension IoTSiteWiseClientTypes.AssetModelStatus {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTSiteWiseClientTypes.AssetModelStatus {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTSiteWiseClientTypes.AssetModelStatus()
        value.state = try reader["state"].readIfPresent() ?? .sdkUnknown("")
        value.error = try reader["error"].readIfPresent(with: IoTSiteWiseClientTypes.ErrorDetails.read(from:))
        return value
    }
}

extension IoTSiteWiseClientTypes.AssetModelCompositeModelPathSegment {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTSiteWiseClientTypes.AssetModelCompositeModelPathSegment {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTSiteWiseClientTypes.AssetModelCompositeModelPathSegment()
        value.id = try reader["id"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        return value
    }
}

extension IoTSiteWiseClientTypes.PortalStatus {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTSiteWiseClientTypes.PortalStatus {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTSiteWiseClientTypes.PortalStatus()
        value.state = try reader["state"].readIfPresent() ?? .sdkUnknown("")
        value.error = try reader["error"].readIfPresent(with: IoTSiteWiseClientTypes.MonitorErrorDetails.read(from:))
        return value
    }
}

extension IoTSiteWiseClientTypes.MonitorErrorDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTSiteWiseClientTypes.MonitorErrorDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTSiteWiseClientTypes.MonitorErrorDetails()
        value.code = try reader["code"].readIfPresent()
        value.message = try reader["message"].readIfPresent()
        return value
    }
}

extension IoTSiteWiseClientTypes.Identity {

    static func write(value: IoTSiteWiseClientTypes.Identity?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["group"].write(value.group, with: IoTSiteWiseClientTypes.GroupIdentity.write(value:to:))
        try writer["iamRole"].write(value.iamRole, with: IoTSiteWiseClientTypes.IAMRoleIdentity.write(value:to:))
        try writer["iamUser"].write(value.iamUser, with: IoTSiteWiseClientTypes.IAMUserIdentity.write(value:to:))
        try writer["user"].write(value.user, with: IoTSiteWiseClientTypes.UserIdentity.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTSiteWiseClientTypes.Identity {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTSiteWiseClientTypes.Identity()
        value.user = try reader["user"].readIfPresent(with: IoTSiteWiseClientTypes.UserIdentity.read(from:))
        value.group = try reader["group"].readIfPresent(with: IoTSiteWiseClientTypes.GroupIdentity.read(from:))
        value.iamUser = try reader["iamUser"].readIfPresent(with: IoTSiteWiseClientTypes.IAMUserIdentity.read(from:))
        value.iamRole = try reader["iamRole"].readIfPresent(with: IoTSiteWiseClientTypes.IAMRoleIdentity.read(from:))
        return value
    }
}

extension IoTSiteWiseClientTypes.IAMRoleIdentity {

    static func write(value: IoTSiteWiseClientTypes.IAMRoleIdentity?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["arn"].write(value.arn)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTSiteWiseClientTypes.IAMRoleIdentity {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTSiteWiseClientTypes.IAMRoleIdentity()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        return value
    }
}

extension IoTSiteWiseClientTypes.IAMUserIdentity {

    static func write(value: IoTSiteWiseClientTypes.IAMUserIdentity?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["arn"].write(value.arn)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTSiteWiseClientTypes.IAMUserIdentity {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTSiteWiseClientTypes.IAMUserIdentity()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        return value
    }
}

extension IoTSiteWiseClientTypes.GroupIdentity {

    static func write(value: IoTSiteWiseClientTypes.GroupIdentity?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["id"].write(value.id)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTSiteWiseClientTypes.GroupIdentity {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTSiteWiseClientTypes.GroupIdentity()
        value.id = try reader["id"].readIfPresent() ?? ""
        return value
    }
}

extension IoTSiteWiseClientTypes.UserIdentity {

    static func write(value: IoTSiteWiseClientTypes.UserIdentity?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["id"].write(value.id)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTSiteWiseClientTypes.UserIdentity {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTSiteWiseClientTypes.UserIdentity()
        value.id = try reader["id"].readIfPresent() ?? ""
        return value
    }
}

extension IoTSiteWiseClientTypes.Resource {

    static func write(value: IoTSiteWiseClientTypes.Resource?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["portal"].write(value.portal, with: IoTSiteWiseClientTypes.PortalResource.write(value:to:))
        try writer["project"].write(value.project, with: IoTSiteWiseClientTypes.ProjectResource.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTSiteWiseClientTypes.Resource {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTSiteWiseClientTypes.Resource()
        value.portal = try reader["portal"].readIfPresent(with: IoTSiteWiseClientTypes.PortalResource.read(from:))
        value.project = try reader["project"].readIfPresent(with: IoTSiteWiseClientTypes.ProjectResource.read(from:))
        return value
    }
}

extension IoTSiteWiseClientTypes.ProjectResource {

    static func write(value: IoTSiteWiseClientTypes.ProjectResource?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["id"].write(value.id)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTSiteWiseClientTypes.ProjectResource {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTSiteWiseClientTypes.ProjectResource()
        value.id = try reader["id"].readIfPresent() ?? ""
        return value
    }
}

extension IoTSiteWiseClientTypes.PortalResource {

    static func write(value: IoTSiteWiseClientTypes.PortalResource?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["id"].write(value.id)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTSiteWiseClientTypes.PortalResource {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTSiteWiseClientTypes.PortalResource()
        value.id = try reader["id"].readIfPresent() ?? ""
        return value
    }
}

extension IoTSiteWiseClientTypes.TargetResource {

    static func write(value: IoTSiteWiseClientTypes.TargetResource?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["assetId"].write(value.assetId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTSiteWiseClientTypes.TargetResource {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTSiteWiseClientTypes.TargetResource()
        value.assetId = try reader["assetId"].readIfPresent() ?? ""
        return value
    }
}

extension IoTSiteWiseClientTypes.ActionPayload {

    static func write(value: IoTSiteWiseClientTypes.ActionPayload?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["stringValue"].write(value.stringValue)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTSiteWiseClientTypes.ActionPayload {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTSiteWiseClientTypes.ActionPayload()
        value.stringValue = try reader["stringValue"].readIfPresent() ?? ""
        return value
    }
}

extension IoTSiteWiseClientTypes.AssetProperty {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTSiteWiseClientTypes.AssetProperty {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTSiteWiseClientTypes.AssetProperty()
        value.id = try reader["id"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.alias = try reader["alias"].readIfPresent()
        value.notification = try reader["notification"].readIfPresent(with: IoTSiteWiseClientTypes.PropertyNotification.read(from:))
        value.dataType = try reader["dataType"].readIfPresent() ?? .sdkUnknown("")
        value.dataTypeSpec = try reader["dataTypeSpec"].readIfPresent()
        value.unit = try reader["unit"].readIfPresent()
        value.path = try reader["path"].readListIfPresent(memberReadingClosure: IoTSiteWiseClientTypes.AssetPropertyPathSegment.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.externalId = try reader["externalId"].readIfPresent()
        return value
    }
}

extension IoTSiteWiseClientTypes.AssetPropertyPathSegment {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTSiteWiseClientTypes.AssetPropertyPathSegment {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTSiteWiseClientTypes.AssetPropertyPathSegment()
        value.id = try reader["id"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        return value
    }
}

extension IoTSiteWiseClientTypes.PropertyNotification {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTSiteWiseClientTypes.PropertyNotification {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTSiteWiseClientTypes.PropertyNotification()
        value.topic = try reader["topic"].readIfPresent() ?? ""
        value.state = try reader["state"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension IoTSiteWiseClientTypes.AssetHierarchy {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTSiteWiseClientTypes.AssetHierarchy {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTSiteWiseClientTypes.AssetHierarchy()
        value.id = try reader["id"].readIfPresent()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.externalId = try reader["externalId"].readIfPresent()
        return value
    }
}

extension IoTSiteWiseClientTypes.AssetCompositeModel {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTSiteWiseClientTypes.AssetCompositeModel {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTSiteWiseClientTypes.AssetCompositeModel()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.description = try reader["description"].readIfPresent()
        value.type = try reader["type"].readIfPresent() ?? ""
        value.properties = try reader["properties"].readListIfPresent(memberReadingClosure: IoTSiteWiseClientTypes.AssetProperty.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.id = try reader["id"].readIfPresent()
        value.externalId = try reader["externalId"].readIfPresent()
        return value
    }
}

extension IoTSiteWiseClientTypes.AssetCompositeModelSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTSiteWiseClientTypes.AssetCompositeModelSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTSiteWiseClientTypes.AssetCompositeModelSummary()
        value.id = try reader["id"].readIfPresent() ?? ""
        value.externalId = try reader["externalId"].readIfPresent()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.type = try reader["type"].readIfPresent() ?? ""
        value.description = try reader["description"].readIfPresent() ?? ""
        value.path = try reader["path"].readListIfPresent(memberReadingClosure: IoTSiteWiseClientTypes.AssetCompositeModelPathSegment.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension IoTSiteWiseClientTypes.AssetCompositeModelPathSegment {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTSiteWiseClientTypes.AssetCompositeModelPathSegment {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTSiteWiseClientTypes.AssetCompositeModelPathSegment()
        value.id = try reader["id"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        return value
    }
}

extension IoTSiteWiseClientTypes.ActionDefinition {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTSiteWiseClientTypes.ActionDefinition {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTSiteWiseClientTypes.ActionDefinition()
        value.actionDefinitionId = try reader["actionDefinitionId"].readIfPresent() ?? ""
        value.actionName = try reader["actionName"].readIfPresent() ?? ""
        value.actionType = try reader["actionType"].readIfPresent() ?? ""
        return value
    }
}

extension IoTSiteWiseClientTypes.AssetModelProperty {

    static func write(value: IoTSiteWiseClientTypes.AssetModelProperty?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["dataType"].write(value.dataType)
        try writer["dataTypeSpec"].write(value.dataTypeSpec)
        try writer["externalId"].write(value.externalId)
        try writer["id"].write(value.id)
        try writer["name"].write(value.name)
        try writer["path"].writeList(value.path, memberWritingClosure: IoTSiteWiseClientTypes.AssetModelPropertyPathSegment.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["type"].write(value.type, with: IoTSiteWiseClientTypes.PropertyType.write(value:to:))
        try writer["unit"].write(value.unit)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTSiteWiseClientTypes.AssetModelProperty {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTSiteWiseClientTypes.AssetModelProperty()
        value.id = try reader["id"].readIfPresent()
        value.externalId = try reader["externalId"].readIfPresent()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.dataType = try reader["dataType"].readIfPresent() ?? .sdkUnknown("")
        value.dataTypeSpec = try reader["dataTypeSpec"].readIfPresent()
        value.unit = try reader["unit"].readIfPresent()
        value.type = try reader["type"].readIfPresent(with: IoTSiteWiseClientTypes.PropertyType.read(from:))
        value.path = try reader["path"].readListIfPresent(memberReadingClosure: IoTSiteWiseClientTypes.AssetModelPropertyPathSegment.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension IoTSiteWiseClientTypes.AssetModelPropertyPathSegment {

    static func write(value: IoTSiteWiseClientTypes.AssetModelPropertyPathSegment?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["id"].write(value.id)
        try writer["name"].write(value.name)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTSiteWiseClientTypes.AssetModelPropertyPathSegment {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTSiteWiseClientTypes.AssetModelPropertyPathSegment()
        value.id = try reader["id"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        return value
    }
}

extension IoTSiteWiseClientTypes.PropertyType {

    static func write(value: IoTSiteWiseClientTypes.PropertyType?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["attribute"].write(value.attribute, with: IoTSiteWiseClientTypes.Attribute.write(value:to:))
        try writer["measurement"].write(value.measurement, with: IoTSiteWiseClientTypes.Measurement.write(value:to:))
        try writer["metric"].write(value.metric, with: IoTSiteWiseClientTypes.Metric.write(value:to:))
        try writer["transform"].write(value.transform, with: IoTSiteWiseClientTypes.Transform.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTSiteWiseClientTypes.PropertyType {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTSiteWiseClientTypes.PropertyType()
        value.attribute = try reader["attribute"].readIfPresent(with: IoTSiteWiseClientTypes.Attribute.read(from:))
        value.measurement = try reader["measurement"].readIfPresent(with: IoTSiteWiseClientTypes.Measurement.read(from:))
        value.transform = try reader["transform"].readIfPresent(with: IoTSiteWiseClientTypes.Transform.read(from:))
        value.metric = try reader["metric"].readIfPresent(with: IoTSiteWiseClientTypes.Metric.read(from:))
        return value
    }
}

extension IoTSiteWiseClientTypes.Metric {

    static func write(value: IoTSiteWiseClientTypes.Metric?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["expression"].write(value.expression)
        try writer["processingConfig"].write(value.processingConfig, with: IoTSiteWiseClientTypes.MetricProcessingConfig.write(value:to:))
        try writer["variables"].writeList(value.variables, memberWritingClosure: IoTSiteWiseClientTypes.ExpressionVariable.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["window"].write(value.window, with: IoTSiteWiseClientTypes.MetricWindow.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTSiteWiseClientTypes.Metric {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTSiteWiseClientTypes.Metric()
        value.expression = try reader["expression"].readIfPresent() ?? ""
        value.variables = try reader["variables"].readListIfPresent(memberReadingClosure: IoTSiteWiseClientTypes.ExpressionVariable.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.window = try reader["window"].readIfPresent(with: IoTSiteWiseClientTypes.MetricWindow.read(from:))
        value.processingConfig = try reader["processingConfig"].readIfPresent(with: IoTSiteWiseClientTypes.MetricProcessingConfig.read(from:))
        return value
    }
}

extension IoTSiteWiseClientTypes.MetricProcessingConfig {

    static func write(value: IoTSiteWiseClientTypes.MetricProcessingConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["computeLocation"].write(value.computeLocation)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTSiteWiseClientTypes.MetricProcessingConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTSiteWiseClientTypes.MetricProcessingConfig()
        value.computeLocation = try reader["computeLocation"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension IoTSiteWiseClientTypes.MetricWindow {

    static func write(value: IoTSiteWiseClientTypes.MetricWindow?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["tumbling"].write(value.tumbling, with: IoTSiteWiseClientTypes.TumblingWindow.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTSiteWiseClientTypes.MetricWindow {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTSiteWiseClientTypes.MetricWindow()
        value.tumbling = try reader["tumbling"].readIfPresent(with: IoTSiteWiseClientTypes.TumblingWindow.read(from:))
        return value
    }
}

extension IoTSiteWiseClientTypes.TumblingWindow {

    static func write(value: IoTSiteWiseClientTypes.TumblingWindow?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["interval"].write(value.interval)
        try writer["offset"].write(value.offset)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTSiteWiseClientTypes.TumblingWindow {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTSiteWiseClientTypes.TumblingWindow()
        value.interval = try reader["interval"].readIfPresent() ?? ""
        value.offset = try reader["offset"].readIfPresent()
        return value
    }
}

extension IoTSiteWiseClientTypes.ExpressionVariable {

    static func write(value: IoTSiteWiseClientTypes.ExpressionVariable?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["name"].write(value.name)
        try writer["value"].write(value.value, with: IoTSiteWiseClientTypes.VariableValue.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTSiteWiseClientTypes.ExpressionVariable {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTSiteWiseClientTypes.ExpressionVariable()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.value = try reader["value"].readIfPresent(with: IoTSiteWiseClientTypes.VariableValue.read(from:))
        return value
    }
}

extension IoTSiteWiseClientTypes.VariableValue {

    static func write(value: IoTSiteWiseClientTypes.VariableValue?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["hierarchyId"].write(value.hierarchyId)
        try writer["propertyId"].write(value.propertyId)
        try writer["propertyPath"].writeList(value.propertyPath, memberWritingClosure: IoTSiteWiseClientTypes.AssetModelPropertyPathSegment.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTSiteWiseClientTypes.VariableValue {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTSiteWiseClientTypes.VariableValue()
        value.propertyId = try reader["propertyId"].readIfPresent()
        value.hierarchyId = try reader["hierarchyId"].readIfPresent()
        value.propertyPath = try reader["propertyPath"].readListIfPresent(memberReadingClosure: IoTSiteWiseClientTypes.AssetModelPropertyPathSegment.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension IoTSiteWiseClientTypes.Transform {

    static func write(value: IoTSiteWiseClientTypes.Transform?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["expression"].write(value.expression)
        try writer["processingConfig"].write(value.processingConfig, with: IoTSiteWiseClientTypes.TransformProcessingConfig.write(value:to:))
        try writer["variables"].writeList(value.variables, memberWritingClosure: IoTSiteWiseClientTypes.ExpressionVariable.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTSiteWiseClientTypes.Transform {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTSiteWiseClientTypes.Transform()
        value.expression = try reader["expression"].readIfPresent() ?? ""
        value.variables = try reader["variables"].readListIfPresent(memberReadingClosure: IoTSiteWiseClientTypes.ExpressionVariable.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.processingConfig = try reader["processingConfig"].readIfPresent(with: IoTSiteWiseClientTypes.TransformProcessingConfig.read(from:))
        return value
    }
}

extension IoTSiteWiseClientTypes.TransformProcessingConfig {

    static func write(value: IoTSiteWiseClientTypes.TransformProcessingConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["computeLocation"].write(value.computeLocation)
        try writer["forwardingConfig"].write(value.forwardingConfig, with: IoTSiteWiseClientTypes.ForwardingConfig.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTSiteWiseClientTypes.TransformProcessingConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTSiteWiseClientTypes.TransformProcessingConfig()
        value.computeLocation = try reader["computeLocation"].readIfPresent() ?? .sdkUnknown("")
        value.forwardingConfig = try reader["forwardingConfig"].readIfPresent(with: IoTSiteWiseClientTypes.ForwardingConfig.read(from:))
        return value
    }
}

extension IoTSiteWiseClientTypes.ForwardingConfig {

    static func write(value: IoTSiteWiseClientTypes.ForwardingConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["state"].write(value.state)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTSiteWiseClientTypes.ForwardingConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTSiteWiseClientTypes.ForwardingConfig()
        value.state = try reader["state"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension IoTSiteWiseClientTypes.Measurement {

    static func write(value: IoTSiteWiseClientTypes.Measurement?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["processingConfig"].write(value.processingConfig, with: IoTSiteWiseClientTypes.MeasurementProcessingConfig.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTSiteWiseClientTypes.Measurement {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTSiteWiseClientTypes.Measurement()
        value.processingConfig = try reader["processingConfig"].readIfPresent(with: IoTSiteWiseClientTypes.MeasurementProcessingConfig.read(from:))
        return value
    }
}

extension IoTSiteWiseClientTypes.MeasurementProcessingConfig {

    static func write(value: IoTSiteWiseClientTypes.MeasurementProcessingConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["forwardingConfig"].write(value.forwardingConfig, with: IoTSiteWiseClientTypes.ForwardingConfig.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTSiteWiseClientTypes.MeasurementProcessingConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTSiteWiseClientTypes.MeasurementProcessingConfig()
        value.forwardingConfig = try reader["forwardingConfig"].readIfPresent(with: IoTSiteWiseClientTypes.ForwardingConfig.read(from:))
        return value
    }
}

extension IoTSiteWiseClientTypes.Attribute {

    static func write(value: IoTSiteWiseClientTypes.Attribute?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["defaultValue"].write(value.defaultValue)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTSiteWiseClientTypes.Attribute {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTSiteWiseClientTypes.Attribute()
        value.defaultValue = try reader["defaultValue"].readIfPresent()
        return value
    }
}

extension IoTSiteWiseClientTypes.AssetModelHierarchy {

    static func write(value: IoTSiteWiseClientTypes.AssetModelHierarchy?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["childAssetModelId"].write(value.childAssetModelId)
        try writer["externalId"].write(value.externalId)
        try writer["id"].write(value.id)
        try writer["name"].write(value.name)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTSiteWiseClientTypes.AssetModelHierarchy {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTSiteWiseClientTypes.AssetModelHierarchy()
        value.id = try reader["id"].readIfPresent()
        value.externalId = try reader["externalId"].readIfPresent()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.childAssetModelId = try reader["childAssetModelId"].readIfPresent() ?? ""
        return value
    }
}

extension IoTSiteWiseClientTypes.AssetModelCompositeModel {

    static func write(value: IoTSiteWiseClientTypes.AssetModelCompositeModel?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
        try writer["externalId"].write(value.externalId)
        try writer["id"].write(value.id)
        try writer["name"].write(value.name)
        try writer["properties"].writeList(value.properties, memberWritingClosure: IoTSiteWiseClientTypes.AssetModelProperty.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["type"].write(value.type)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTSiteWiseClientTypes.AssetModelCompositeModel {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTSiteWiseClientTypes.AssetModelCompositeModel()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.description = try reader["description"].readIfPresent()
        value.type = try reader["type"].readIfPresent() ?? ""
        value.properties = try reader["properties"].readListIfPresent(memberReadingClosure: IoTSiteWiseClientTypes.AssetModelProperty.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.id = try reader["id"].readIfPresent()
        value.externalId = try reader["externalId"].readIfPresent()
        return value
    }
}

extension IoTSiteWiseClientTypes.AssetModelCompositeModelSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTSiteWiseClientTypes.AssetModelCompositeModelSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTSiteWiseClientTypes.AssetModelCompositeModelSummary()
        value.id = try reader["id"].readIfPresent() ?? ""
        value.externalId = try reader["externalId"].readIfPresent()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.type = try reader["type"].readIfPresent() ?? ""
        value.description = try reader["description"].readIfPresent()
        value.path = try reader["path"].readListIfPresent(memberReadingClosure: IoTSiteWiseClientTypes.AssetModelCompositeModelPathSegment.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension IoTSiteWiseClientTypes.CompositionDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTSiteWiseClientTypes.CompositionDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTSiteWiseClientTypes.CompositionDetails()
        value.compositionRelationship = try reader["compositionRelationship"].readListIfPresent(memberReadingClosure: IoTSiteWiseClientTypes.CompositionRelationshipItem.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension IoTSiteWiseClientTypes.CompositionRelationshipItem {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTSiteWiseClientTypes.CompositionRelationshipItem {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTSiteWiseClientTypes.CompositionRelationshipItem()
        value.id = try reader["id"].readIfPresent()
        return value
    }
}

extension IoTSiteWiseClientTypes.Property {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTSiteWiseClientTypes.Property {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTSiteWiseClientTypes.Property()
        value.id = try reader["id"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.alias = try reader["alias"].readIfPresent()
        value.notification = try reader["notification"].readIfPresent(with: IoTSiteWiseClientTypes.PropertyNotification.read(from:))
        value.dataType = try reader["dataType"].readIfPresent() ?? .sdkUnknown("")
        value.unit = try reader["unit"].readIfPresent()
        value.type = try reader["type"].readIfPresent(with: IoTSiteWiseClientTypes.PropertyType.read(from:))
        value.path = try reader["path"].readListIfPresent(memberReadingClosure: IoTSiteWiseClientTypes.AssetPropertyPathSegment.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.externalId = try reader["externalId"].readIfPresent()
        return value
    }
}

extension IoTSiteWiseClientTypes.CompositeModelProperty {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTSiteWiseClientTypes.CompositeModelProperty {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTSiteWiseClientTypes.CompositeModelProperty()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.type = try reader["type"].readIfPresent() ?? ""
        value.assetProperty = try reader["assetProperty"].readIfPresent(with: IoTSiteWiseClientTypes.Property.read(from:))
        value.id = try reader["id"].readIfPresent()
        value.externalId = try reader["externalId"].readIfPresent()
        return value
    }
}

extension IoTSiteWiseClientTypes.File {

    static func write(value: IoTSiteWiseClientTypes.File?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["bucket"].write(value.bucket)
        try writer["key"].write(value.key)
        try writer["versionId"].write(value.versionId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTSiteWiseClientTypes.File {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTSiteWiseClientTypes.File()
        value.bucket = try reader["bucket"].readIfPresent() ?? ""
        value.key = try reader["key"].readIfPresent() ?? ""
        value.versionId = try reader["versionId"].readIfPresent()
        return value
    }
}

extension IoTSiteWiseClientTypes.ErrorReportLocation {

    static func write(value: IoTSiteWiseClientTypes.ErrorReportLocation?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["bucket"].write(value.bucket)
        try writer["prefix"].write(value.`prefix`)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTSiteWiseClientTypes.ErrorReportLocation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTSiteWiseClientTypes.ErrorReportLocation()
        value.bucket = try reader["bucket"].readIfPresent() ?? ""
        value.`prefix` = try reader["prefix"].readIfPresent() ?? ""
        return value
    }
}

extension IoTSiteWiseClientTypes.JobConfiguration {

    static func write(value: IoTSiteWiseClientTypes.JobConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["fileFormat"].write(value.fileFormat, with: IoTSiteWiseClientTypes.FileFormat.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTSiteWiseClientTypes.JobConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTSiteWiseClientTypes.JobConfiguration()
        value.fileFormat = try reader["fileFormat"].readIfPresent(with: IoTSiteWiseClientTypes.FileFormat.read(from:))
        return value
    }
}

extension IoTSiteWiseClientTypes.FileFormat {

    static func write(value: IoTSiteWiseClientTypes.FileFormat?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["csv"].write(value.csv, with: IoTSiteWiseClientTypes.Csv.write(value:to:))
        try writer["parquet"].write(value.parquet, with: IoTSiteWiseClientTypes.Parquet.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTSiteWiseClientTypes.FileFormat {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTSiteWiseClientTypes.FileFormat()
        value.csv = try reader["csv"].readIfPresent(with: IoTSiteWiseClientTypes.Csv.read(from:))
        value.parquet = try reader["parquet"].readIfPresent(with: IoTSiteWiseClientTypes.Parquet.read(from:))
        return value
    }
}

extension IoTSiteWiseClientTypes.Parquet {

    static func write(value: IoTSiteWiseClientTypes.Parquet?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTSiteWiseClientTypes.Parquet {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        return IoTSiteWiseClientTypes.Parquet()
    }
}

extension IoTSiteWiseClientTypes.Csv {

    static func write(value: IoTSiteWiseClientTypes.Csv?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["columnNames"].writeList(value.columnNames, memberWritingClosure: SmithyReadWrite.WritingClosureBox<IoTSiteWiseClientTypes.ColumnName>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTSiteWiseClientTypes.Csv {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTSiteWiseClientTypes.Csv()
        value.columnNames = try reader["columnNames"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<IoTSiteWiseClientTypes.ColumnName>().read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension IoTSiteWiseClientTypes.ConfigurationStatus {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTSiteWiseClientTypes.ConfigurationStatus {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTSiteWiseClientTypes.ConfigurationStatus()
        value.state = try reader["state"].readIfPresent() ?? .sdkUnknown("")
        value.error = try reader["error"].readIfPresent(with: IoTSiteWiseClientTypes.ConfigurationErrorDetails.read(from:))
        return value
    }
}

extension IoTSiteWiseClientTypes.ConfigurationErrorDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTSiteWiseClientTypes.ConfigurationErrorDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTSiteWiseClientTypes.ConfigurationErrorDetails()
        value.code = try reader["code"].readIfPresent() ?? .sdkUnknown("")
        value.message = try reader["message"].readIfPresent() ?? ""
        return value
    }
}

extension IoTSiteWiseClientTypes.GatewayPlatform {

    static func write(value: IoTSiteWiseClientTypes.GatewayPlatform?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["greengrass"].write(value.greengrass, with: IoTSiteWiseClientTypes.Greengrass.write(value:to:))
        try writer["greengrassV2"].write(value.greengrassV2, with: IoTSiteWiseClientTypes.GreengrassV2.write(value:to:))
        try writer["siemensIE"].write(value.siemensIE, with: IoTSiteWiseClientTypes.SiemensIE.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTSiteWiseClientTypes.GatewayPlatform {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTSiteWiseClientTypes.GatewayPlatform()
        value.greengrass = try reader["greengrass"].readIfPresent(with: IoTSiteWiseClientTypes.Greengrass.read(from:))
        value.greengrassV2 = try reader["greengrassV2"].readIfPresent(with: IoTSiteWiseClientTypes.GreengrassV2.read(from:))
        value.siemensIE = try reader["siemensIE"].readIfPresent(with: IoTSiteWiseClientTypes.SiemensIE.read(from:))
        return value
    }
}

extension IoTSiteWiseClientTypes.SiemensIE {

    static func write(value: IoTSiteWiseClientTypes.SiemensIE?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["iotCoreThingName"].write(value.iotCoreThingName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTSiteWiseClientTypes.SiemensIE {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTSiteWiseClientTypes.SiemensIE()
        value.iotCoreThingName = try reader["iotCoreThingName"].readIfPresent() ?? ""
        return value
    }
}

extension IoTSiteWiseClientTypes.GreengrassV2 {

    static func write(value: IoTSiteWiseClientTypes.GreengrassV2?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["coreDeviceThingName"].write(value.coreDeviceThingName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTSiteWiseClientTypes.GreengrassV2 {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTSiteWiseClientTypes.GreengrassV2()
        value.coreDeviceThingName = try reader["coreDeviceThingName"].readIfPresent() ?? ""
        return value
    }
}

extension IoTSiteWiseClientTypes.Greengrass {

    static func write(value: IoTSiteWiseClientTypes.Greengrass?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["groupArn"].write(value.groupArn)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTSiteWiseClientTypes.Greengrass {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTSiteWiseClientTypes.Greengrass()
        value.groupArn = try reader["groupArn"].readIfPresent() ?? ""
        return value
    }
}

extension IoTSiteWiseClientTypes.GatewayCapabilitySummary {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTSiteWiseClientTypes.GatewayCapabilitySummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTSiteWiseClientTypes.GatewayCapabilitySummary()
        value.capabilityNamespace = try reader["capabilityNamespace"].readIfPresent() ?? ""
        value.capabilitySyncStatus = try reader["capabilitySyncStatus"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension IoTSiteWiseClientTypes.LoggingOptions {

    static func write(value: IoTSiteWiseClientTypes.LoggingOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["level"].write(value.level)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTSiteWiseClientTypes.LoggingOptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTSiteWiseClientTypes.LoggingOptions()
        value.level = try reader["level"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension IoTSiteWiseClientTypes.ImageLocation {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTSiteWiseClientTypes.ImageLocation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTSiteWiseClientTypes.ImageLocation()
        value.id = try reader["id"].readIfPresent() ?? ""
        value.url = try reader["url"].readIfPresent() ?? ""
        return value
    }
}

extension IoTSiteWiseClientTypes.Alarms {

    static func write(value: IoTSiteWiseClientTypes.Alarms?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["alarmRoleArn"].write(value.alarmRoleArn)
        try writer["notificationLambdaArn"].write(value.notificationLambdaArn)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTSiteWiseClientTypes.Alarms {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTSiteWiseClientTypes.Alarms()
        value.alarmRoleArn = try reader["alarmRoleArn"].readIfPresent() ?? ""
        value.notificationLambdaArn = try reader["notificationLambdaArn"].readIfPresent()
        return value
    }
}

extension IoTSiteWiseClientTypes.MultiLayerStorage {

    static func write(value: IoTSiteWiseClientTypes.MultiLayerStorage?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["customerManagedS3Storage"].write(value.customerManagedS3Storage, with: IoTSiteWiseClientTypes.CustomerManagedS3Storage.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTSiteWiseClientTypes.MultiLayerStorage {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTSiteWiseClientTypes.MultiLayerStorage()
        value.customerManagedS3Storage = try reader["customerManagedS3Storage"].readIfPresent(with: IoTSiteWiseClientTypes.CustomerManagedS3Storage.read(from:))
        return value
    }
}

extension IoTSiteWiseClientTypes.CustomerManagedS3Storage {

    static func write(value: IoTSiteWiseClientTypes.CustomerManagedS3Storage?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["roleArn"].write(value.roleArn)
        try writer["s3ResourceArn"].write(value.s3ResourceArn)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTSiteWiseClientTypes.CustomerManagedS3Storage {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTSiteWiseClientTypes.CustomerManagedS3Storage()
        value.s3ResourceArn = try reader["s3ResourceArn"].readIfPresent() ?? ""
        value.roleArn = try reader["roleArn"].readIfPresent() ?? ""
        return value
    }
}

extension IoTSiteWiseClientTypes.RetentionPeriod {

    static func write(value: IoTSiteWiseClientTypes.RetentionPeriod?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["numberOfDays"].write(value.numberOfDays)
        try writer["unlimited"].write(value.unlimited)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTSiteWiseClientTypes.RetentionPeriod {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTSiteWiseClientTypes.RetentionPeriod()
        value.numberOfDays = try reader["numberOfDays"].readIfPresent()
        value.unlimited = try reader["unlimited"].readIfPresent()
        return value
    }
}

extension IoTSiteWiseClientTypes.WarmTierRetentionPeriod {

    static func write(value: IoTSiteWiseClientTypes.WarmTierRetentionPeriod?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["numberOfDays"].write(value.numberOfDays)
        try writer["unlimited"].write(value.unlimited)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> IoTSiteWiseClientTypes.WarmTierRetentionPeriod {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTSiteWiseClientTypes.WarmTierRetentionPeriod()
        value.numberOfDays = try reader["numberOfDays"].readIfPresent()
        value.unlimited = try reader["unlimited"].readIfPresent()
        return value
    }
}

extension IoTSiteWiseClientTypes.ColumnInfo {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTSiteWiseClientTypes.ColumnInfo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTSiteWiseClientTypes.ColumnInfo()
        value.name = try reader["name"].readIfPresent()
        value.type = try reader["type"].readIfPresent(with: IoTSiteWiseClientTypes.ColumnType.read(from:))
        return value
    }
}

extension IoTSiteWiseClientTypes.ColumnType {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTSiteWiseClientTypes.ColumnType {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTSiteWiseClientTypes.ColumnType()
        value.scalarType = try reader["scalarType"].readIfPresent()
        return value
    }
}

extension IoTSiteWiseClientTypes.Row {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTSiteWiseClientTypes.Row {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTSiteWiseClientTypes.Row()
        value.data = try reader["data"].readListIfPresent(memberReadingClosure: IoTSiteWiseClientTypes.Datum.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension IoTSiteWiseClientTypes.Datum {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTSiteWiseClientTypes.Datum {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTSiteWiseClientTypes.Datum()
        value.scalarValue = try reader["scalarValue"].readIfPresent()
        value.arrayValue = try reader["arrayValue"].readListIfPresent(memberReadingClosure: IoTSiteWiseClientTypes.Datum.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.rowValue = try reader["rowValue"].readIfPresent(with: IoTSiteWiseClientTypes.Row.read(from:))
        value.nullValue = try reader["nullValue"].readIfPresent()
        return value
    }
}

extension IoTSiteWiseClientTypes.InterpolatedAssetPropertyValue {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTSiteWiseClientTypes.InterpolatedAssetPropertyValue {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTSiteWiseClientTypes.InterpolatedAssetPropertyValue()
        value.timestamp = try reader["timestamp"].readIfPresent(with: IoTSiteWiseClientTypes.TimeInNanos.read(from:))
        value.value = try reader["value"].readIfPresent(with: IoTSiteWiseClientTypes.Variant.read(from:))
        return value
    }
}

extension IoTSiteWiseClientTypes.AccessPolicySummary {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTSiteWiseClientTypes.AccessPolicySummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTSiteWiseClientTypes.AccessPolicySummary()
        value.id = try reader["id"].readIfPresent() ?? ""
        value.identity = try reader["identity"].readIfPresent(with: IoTSiteWiseClientTypes.Identity.read(from:))
        value.resource = try reader["resource"].readIfPresent(with: IoTSiteWiseClientTypes.Resource.read(from:))
        value.permission = try reader["permission"].readIfPresent() ?? .sdkUnknown("")
        value.creationDate = try reader["creationDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastUpdateDate = try reader["lastUpdateDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension IoTSiteWiseClientTypes.ActionSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTSiteWiseClientTypes.ActionSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTSiteWiseClientTypes.ActionSummary()
        value.actionId = try reader["actionId"].readIfPresent()
        value.actionDefinitionId = try reader["actionDefinitionId"].readIfPresent()
        value.targetResource = try reader["targetResource"].readIfPresent(with: IoTSiteWiseClientTypes.TargetResource.read(from:))
        return value
    }
}

extension IoTSiteWiseClientTypes.AssetModelPropertySummary {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTSiteWiseClientTypes.AssetModelPropertySummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTSiteWiseClientTypes.AssetModelPropertySummary()
        value.id = try reader["id"].readIfPresent()
        value.externalId = try reader["externalId"].readIfPresent()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.dataType = try reader["dataType"].readIfPresent() ?? .sdkUnknown("")
        value.dataTypeSpec = try reader["dataTypeSpec"].readIfPresent()
        value.unit = try reader["unit"].readIfPresent()
        value.type = try reader["type"].readIfPresent(with: IoTSiteWiseClientTypes.PropertyType.read(from:))
        value.assetModelCompositeModelId = try reader["assetModelCompositeModelId"].readIfPresent()
        value.path = try reader["path"].readListIfPresent(memberReadingClosure: IoTSiteWiseClientTypes.AssetModelPropertyPathSegment.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension IoTSiteWiseClientTypes.AssetModelSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTSiteWiseClientTypes.AssetModelSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTSiteWiseClientTypes.AssetModelSummary()
        value.id = try reader["id"].readIfPresent() ?? ""
        value.externalId = try reader["externalId"].readIfPresent()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.assetModelType = try reader["assetModelType"].readIfPresent()
        value.description = try reader["description"].readIfPresent() ?? ""
        value.creationDate = try reader["creationDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.lastUpdateDate = try reader["lastUpdateDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.status = try reader["status"].readIfPresent(with: IoTSiteWiseClientTypes.AssetModelStatus.read(from:))
        value.version = try reader["version"].readIfPresent()
        return value
    }
}

extension IoTSiteWiseClientTypes.AssetPropertySummary {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTSiteWiseClientTypes.AssetPropertySummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTSiteWiseClientTypes.AssetPropertySummary()
        value.id = try reader["id"].readIfPresent() ?? ""
        value.alias = try reader["alias"].readIfPresent()
        value.unit = try reader["unit"].readIfPresent()
        value.notification = try reader["notification"].readIfPresent(with: IoTSiteWiseClientTypes.PropertyNotification.read(from:))
        value.assetCompositeModelId = try reader["assetCompositeModelId"].readIfPresent()
        value.path = try reader["path"].readListIfPresent(memberReadingClosure: IoTSiteWiseClientTypes.AssetPropertyPathSegment.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.externalId = try reader["externalId"].readIfPresent()
        return value
    }
}

extension IoTSiteWiseClientTypes.AssetRelationshipSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTSiteWiseClientTypes.AssetRelationshipSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTSiteWiseClientTypes.AssetRelationshipSummary()
        value.hierarchyInfo = try reader["hierarchyInfo"].readIfPresent(with: IoTSiteWiseClientTypes.AssetHierarchyInfo.read(from:))
        value.relationshipType = try reader["relationshipType"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension IoTSiteWiseClientTypes.AssetHierarchyInfo {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTSiteWiseClientTypes.AssetHierarchyInfo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTSiteWiseClientTypes.AssetHierarchyInfo()
        value.parentAssetId = try reader["parentAssetId"].readIfPresent()
        value.childAssetId = try reader["childAssetId"].readIfPresent()
        return value
    }
}

extension IoTSiteWiseClientTypes.AssetSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTSiteWiseClientTypes.AssetSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTSiteWiseClientTypes.AssetSummary()
        value.id = try reader["id"].readIfPresent() ?? ""
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.assetModelId = try reader["assetModelId"].readIfPresent() ?? ""
        value.creationDate = try reader["creationDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.lastUpdateDate = try reader["lastUpdateDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.status = try reader["status"].readIfPresent(with: IoTSiteWiseClientTypes.AssetStatus.read(from:))
        value.hierarchies = try reader["hierarchies"].readListIfPresent(memberReadingClosure: IoTSiteWiseClientTypes.AssetHierarchy.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.description = try reader["description"].readIfPresent()
        value.externalId = try reader["externalId"].readIfPresent()
        return value
    }
}

extension IoTSiteWiseClientTypes.AssociatedAssetsSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTSiteWiseClientTypes.AssociatedAssetsSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTSiteWiseClientTypes.AssociatedAssetsSummary()
        value.id = try reader["id"].readIfPresent() ?? ""
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.assetModelId = try reader["assetModelId"].readIfPresent() ?? ""
        value.creationDate = try reader["creationDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.lastUpdateDate = try reader["lastUpdateDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.status = try reader["status"].readIfPresent(with: IoTSiteWiseClientTypes.AssetStatus.read(from:))
        value.hierarchies = try reader["hierarchies"].readListIfPresent(memberReadingClosure: IoTSiteWiseClientTypes.AssetHierarchy.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.description = try reader["description"].readIfPresent()
        value.externalId = try reader["externalId"].readIfPresent()
        return value
    }
}

extension IoTSiteWiseClientTypes.JobSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTSiteWiseClientTypes.JobSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTSiteWiseClientTypes.JobSummary()
        value.id = try reader["id"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.status = try reader["status"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension IoTSiteWiseClientTypes.CompositionRelationshipSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTSiteWiseClientTypes.CompositionRelationshipSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTSiteWiseClientTypes.CompositionRelationshipSummary()
        value.assetModelId = try reader["assetModelId"].readIfPresent() ?? ""
        value.assetModelCompositeModelId = try reader["assetModelCompositeModelId"].readIfPresent() ?? ""
        value.assetModelCompositeModelType = try reader["assetModelCompositeModelType"].readIfPresent() ?? ""
        return value
    }
}

extension IoTSiteWiseClientTypes.DashboardSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTSiteWiseClientTypes.DashboardSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTSiteWiseClientTypes.DashboardSummary()
        value.id = try reader["id"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.description = try reader["description"].readIfPresent()
        value.creationDate = try reader["creationDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastUpdateDate = try reader["lastUpdateDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension IoTSiteWiseClientTypes.GatewaySummary {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTSiteWiseClientTypes.GatewaySummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTSiteWiseClientTypes.GatewaySummary()
        value.gatewayId = try reader["gatewayId"].readIfPresent() ?? ""
        value.gatewayName = try reader["gatewayName"].readIfPresent() ?? ""
        value.gatewayPlatform = try reader["gatewayPlatform"].readIfPresent(with: IoTSiteWiseClientTypes.GatewayPlatform.read(from:))
        value.gatewayCapabilitySummaries = try reader["gatewayCapabilitySummaries"].readListIfPresent(memberReadingClosure: IoTSiteWiseClientTypes.GatewayCapabilitySummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.creationDate = try reader["creationDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.lastUpdateDate = try reader["lastUpdateDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension IoTSiteWiseClientTypes.PortalSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTSiteWiseClientTypes.PortalSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTSiteWiseClientTypes.PortalSummary()
        value.id = try reader["id"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.description = try reader["description"].readIfPresent()
        value.startUrl = try reader["startUrl"].readIfPresent() ?? ""
        value.creationDate = try reader["creationDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastUpdateDate = try reader["lastUpdateDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.roleArn = try reader["roleArn"].readIfPresent()
        value.status = try reader["status"].readIfPresent(with: IoTSiteWiseClientTypes.PortalStatus.read(from:))
        return value
    }
}

extension IoTSiteWiseClientTypes.ProjectSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTSiteWiseClientTypes.ProjectSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTSiteWiseClientTypes.ProjectSummary()
        value.id = try reader["id"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.description = try reader["description"].readIfPresent()
        value.creationDate = try reader["creationDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastUpdateDate = try reader["lastUpdateDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension IoTSiteWiseClientTypes.TimeSeriesSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> IoTSiteWiseClientTypes.TimeSeriesSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = IoTSiteWiseClientTypes.TimeSeriesSummary()
        value.assetId = try reader["assetId"].readIfPresent()
        value.propertyId = try reader["propertyId"].readIfPresent()
        value.alias = try reader["alias"].readIfPresent()
        value.timeSeriesId = try reader["timeSeriesId"].readIfPresent() ?? ""
        value.dataType = try reader["dataType"].readIfPresent() ?? .sdkUnknown("")
        value.dataTypeSpec = try reader["dataTypeSpec"].readIfPresent()
        value.timeSeriesCreationDate = try reader["timeSeriesCreationDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.timeSeriesLastUpdateDate = try reader["timeSeriesLastUpdateDate"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.timeSeriesArn = try reader["timeSeriesArn"].readIfPresent() ?? ""
        return value
    }
}

extension IoTSiteWiseClientTypes.BatchGetAssetPropertyAggregatesEntry {

    static func write(value: IoTSiteWiseClientTypes.BatchGetAssetPropertyAggregatesEntry?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["aggregateTypes"].writeList(value.aggregateTypes, memberWritingClosure: SmithyReadWrite.WritingClosureBox<IoTSiteWiseClientTypes.AggregateType>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["assetId"].write(value.assetId)
        try writer["endDate"].writeTimestamp(value.endDate, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["entryId"].write(value.entryId)
        try writer["propertyAlias"].write(value.propertyAlias)
        try writer["propertyId"].write(value.propertyId)
        try writer["qualities"].writeList(value.qualities, memberWritingClosure: SmithyReadWrite.WritingClosureBox<IoTSiteWiseClientTypes.Quality>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["resolution"].write(value.resolution)
        try writer["startDate"].writeTimestamp(value.startDate, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["timeOrdering"].write(value.timeOrdering)
    }
}

extension IoTSiteWiseClientTypes.BatchGetAssetPropertyValueEntry {

    static func write(value: IoTSiteWiseClientTypes.BatchGetAssetPropertyValueEntry?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["assetId"].write(value.assetId)
        try writer["entryId"].write(value.entryId)
        try writer["propertyAlias"].write(value.propertyAlias)
        try writer["propertyId"].write(value.propertyId)
    }
}

extension IoTSiteWiseClientTypes.BatchGetAssetPropertyValueHistoryEntry {

    static func write(value: IoTSiteWiseClientTypes.BatchGetAssetPropertyValueHistoryEntry?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["assetId"].write(value.assetId)
        try writer["endDate"].writeTimestamp(value.endDate, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["entryId"].write(value.entryId)
        try writer["propertyAlias"].write(value.propertyAlias)
        try writer["propertyId"].write(value.propertyId)
        try writer["qualities"].writeList(value.qualities, memberWritingClosure: SmithyReadWrite.WritingClosureBox<IoTSiteWiseClientTypes.Quality>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["startDate"].writeTimestamp(value.startDate, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["timeOrdering"].write(value.timeOrdering)
    }
}

extension IoTSiteWiseClientTypes.PutAssetPropertyValueEntry {

    static func write(value: IoTSiteWiseClientTypes.PutAssetPropertyValueEntry?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["assetId"].write(value.assetId)
        try writer["entryId"].write(value.entryId)
        try writer["propertyAlias"].write(value.propertyAlias)
        try writer["propertyId"].write(value.propertyId)
        try writer["propertyValues"].writeList(value.propertyValues, memberWritingClosure: IoTSiteWiseClientTypes.AssetPropertyValue.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension IoTSiteWiseClientTypes.AssetModelPropertyDefinition {

    static func write(value: IoTSiteWiseClientTypes.AssetModelPropertyDefinition?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["dataType"].write(value.dataType)
        try writer["dataTypeSpec"].write(value.dataTypeSpec)
        try writer["externalId"].write(value.externalId)
        try writer["id"].write(value.id)
        try writer["name"].write(value.name)
        try writer["type"].write(value.type, with: IoTSiteWiseClientTypes.PropertyType.write(value:to:))
        try writer["unit"].write(value.unit)
    }
}

extension IoTSiteWiseClientTypes.AssetModelHierarchyDefinition {

    static func write(value: IoTSiteWiseClientTypes.AssetModelHierarchyDefinition?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["childAssetModelId"].write(value.childAssetModelId)
        try writer["externalId"].write(value.externalId)
        try writer["id"].write(value.id)
        try writer["name"].write(value.name)
    }
}

extension IoTSiteWiseClientTypes.AssetModelCompositeModelDefinition {

    static func write(value: IoTSiteWiseClientTypes.AssetModelCompositeModelDefinition?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
        try writer["externalId"].write(value.externalId)
        try writer["id"].write(value.id)
        try writer["name"].write(value.name)
        try writer["properties"].writeList(value.properties, memberWritingClosure: IoTSiteWiseClientTypes.AssetModelPropertyDefinition.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["type"].write(value.type)
    }
}

extension IoTSiteWiseClientTypes.ImageFile {

    static func write(value: IoTSiteWiseClientTypes.ImageFile?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["data"].write(value.data)
        try writer["type"].write(value.type)
    }
}

extension IoTSiteWiseClientTypes.Image {

    static func write(value: IoTSiteWiseClientTypes.Image?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["file"].write(value.file, with: IoTSiteWiseClientTypes.ImageFile.write(value:to:))
        try writer["id"].write(value.id)
    }
}

public enum IoTSiteWiseClientTypes {}
