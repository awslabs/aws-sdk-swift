// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension IoTSiteWiseClientTypes.AccessPolicySummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationDate
        case id
        case identity
        case lastUpdateDate
        case permission
        case resource
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationDate = self.creationDate {
            try encodeContainer.encodeTimestamp(creationDate, format: .epochSeconds, forKey: .creationDate)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let identity = self.identity {
            try encodeContainer.encode(identity, forKey: .identity)
        }
        if let lastUpdateDate = self.lastUpdateDate {
            try encodeContainer.encodeTimestamp(lastUpdateDate, format: .epochSeconds, forKey: .lastUpdateDate)
        }
        if let permission = self.permission {
            try encodeContainer.encode(permission.rawValue, forKey: .permission)
        }
        if let resource = self.resource {
            try encodeContainer.encode(resource, forKey: .resource)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let identityDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.Identity.self, forKey: .identity)
        identity = identityDecoded
        let resourceDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.Resource.self, forKey: .resource)
        resource = resourceDecoded
        let permissionDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.Permission.self, forKey: .permission)
        permission = permissionDecoded
        let creationDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDate)
        creationDate = creationDateDecoded
        let lastUpdateDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdateDate)
        lastUpdateDate = lastUpdateDateDecoded
    }
}

extension IoTSiteWiseClientTypes {
    /// Contains an access policy that defines an identity's access to an IoT SiteWise Monitor resource.
    public struct AccessPolicySummary: Swift.Equatable {
        /// The date the access policy was created, in Unix epoch time.
        public var creationDate: ClientRuntime.Date?
        /// The ID of the access policy.
        /// This member is required.
        public var id: Swift.String?
        /// The identity (an IAM Identity Center user, an IAM Identity Center group, or an IAM user).
        /// This member is required.
        public var identity: IoTSiteWiseClientTypes.Identity?
        /// The date the access policy was last updated, in Unix epoch time.
        public var lastUpdateDate: ClientRuntime.Date?
        /// The permissions for the access policy. Note that a project ADMINISTRATOR is also known as a project owner.
        /// This member is required.
        public var permission: IoTSiteWiseClientTypes.Permission?
        /// The IoT SiteWise Monitor resource (a portal or project).
        /// This member is required.
        public var resource: IoTSiteWiseClientTypes.Resource?

        public init(
            creationDate: ClientRuntime.Date? = nil,
            id: Swift.String? = nil,
            identity: IoTSiteWiseClientTypes.Identity? = nil,
            lastUpdateDate: ClientRuntime.Date? = nil,
            permission: IoTSiteWiseClientTypes.Permission? = nil,
            resource: IoTSiteWiseClientTypes.Resource? = nil
        )
        {
            self.creationDate = creationDate
            self.id = id
            self.identity = identity
            self.lastUpdateDate = lastUpdateDate
            self.permission = permission
            self.resource = resource
        }
    }

}

extension IoTSiteWiseClientTypes {
    public enum AggregateType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case average
        case count
        case maximum
        case minimum
        case standardDeviation
        case sum
        case sdkUnknown(Swift.String)

        public static var allCases: [AggregateType] {
            return [
                .average,
                .count,
                .maximum,
                .minimum,
                .standardDeviation,
                .sum,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .average: return "AVERAGE"
            case .count: return "COUNT"
            case .maximum: return "MAXIMUM"
            case .minimum: return "MINIMUM"
            case .standardDeviation: return "STANDARD_DEVIATION"
            case .sum: return "SUM"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AggregateType(rawValue: rawValue) ?? AggregateType.sdkUnknown(rawValue)
        }
    }
}

extension IoTSiteWiseClientTypes.AggregatedValue: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case quality
        case timestamp
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let quality = self.quality {
            try encodeContainer.encode(quality.rawValue, forKey: .quality)
        }
        if let timestamp = self.timestamp {
            try encodeContainer.encodeTimestamp(timestamp, format: .epochSeconds, forKey: .timestamp)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .timestamp)
        timestamp = timestampDecoded
        let qualityDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.Quality.self, forKey: .quality)
        quality = qualityDecoded
        let valueDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.Aggregates.self, forKey: .value)
        value = valueDecoded
    }
}

extension IoTSiteWiseClientTypes {
    /// Contains aggregated asset property values (for example, average, minimum, and maximum).
    public struct AggregatedValue: Swift.Equatable {
        /// The quality of the aggregated data.
        public var quality: IoTSiteWiseClientTypes.Quality?
        /// The date the aggregating computations occurred, in Unix epoch time.
        /// This member is required.
        public var timestamp: ClientRuntime.Date?
        /// The value of the aggregates.
        /// This member is required.
        public var value: IoTSiteWiseClientTypes.Aggregates?

        public init(
            quality: IoTSiteWiseClientTypes.Quality? = nil,
            timestamp: ClientRuntime.Date? = nil,
            value: IoTSiteWiseClientTypes.Aggregates? = nil
        )
        {
            self.quality = quality
            self.timestamp = timestamp
            self.value = value
        }
    }

}

extension IoTSiteWiseClientTypes.Aggregates: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case average
        case count
        case maximum
        case minimum
        case standardDeviation
        case sum
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let average = self.average {
            try encodeContainer.encode(average, forKey: .average)
        }
        if let count = self.count {
            try encodeContainer.encode(count, forKey: .count)
        }
        if let maximum = self.maximum {
            try encodeContainer.encode(maximum, forKey: .maximum)
        }
        if let minimum = self.minimum {
            try encodeContainer.encode(minimum, forKey: .minimum)
        }
        if let standardDeviation = self.standardDeviation {
            try encodeContainer.encode(standardDeviation, forKey: .standardDeviation)
        }
        if let sum = self.sum {
            try encodeContainer.encode(sum, forKey: .sum)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let averageDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .average)
        average = averageDecoded
        let countDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .count)
        count = countDecoded
        let maximumDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .maximum)
        maximum = maximumDecoded
        let minimumDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .minimum)
        minimum = minimumDecoded
        let sumDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .sum)
        sum = sumDecoded
        let standardDeviationDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .standardDeviation)
        standardDeviation = standardDeviationDecoded
    }
}

extension IoTSiteWiseClientTypes {
    /// Contains the (pre-calculated) aggregate values for an asset property.
    public struct Aggregates: Swift.Equatable {
        /// The average (mean) value of the time series over a time interval window.
        public var average: Swift.Double?
        /// The count of data points in the time series over a time interval window.
        public var count: Swift.Double?
        /// The maximum value of the time series over a time interval window.
        public var maximum: Swift.Double?
        /// The minimum value of the time series over a time interval window.
        public var minimum: Swift.Double?
        /// The standard deviation of the time series over a time interval window.
        public var standardDeviation: Swift.Double?
        /// The sum of the time series over a time interval window.
        public var sum: Swift.Double?

        public init(
            average: Swift.Double? = nil,
            count: Swift.Double? = nil,
            maximum: Swift.Double? = nil,
            minimum: Swift.Double? = nil,
            standardDeviation: Swift.Double? = nil,
            sum: Swift.Double? = nil
        )
        {
            self.average = average
            self.count = count
            self.maximum = maximum
            self.minimum = minimum
            self.standardDeviation = standardDeviation
            self.sum = sum
        }
    }

}

extension IoTSiteWiseClientTypes.Alarms: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alarmRoleArn
        case notificationLambdaArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let alarmRoleArn = self.alarmRoleArn {
            try encodeContainer.encode(alarmRoleArn, forKey: .alarmRoleArn)
        }
        if let notificationLambdaArn = self.notificationLambdaArn {
            try encodeContainer.encode(notificationLambdaArn, forKey: .notificationLambdaArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let alarmRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .alarmRoleArn)
        alarmRoleArn = alarmRoleArnDecoded
        let notificationLambdaArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .notificationLambdaArn)
        notificationLambdaArn = notificationLambdaArnDecoded
    }
}

extension IoTSiteWiseClientTypes {
    /// Contains the configuration information of an alarm created in an IoT SiteWise Monitor portal. You can use the alarm to monitor an asset property and get notified when the asset property value is outside a specified range. For more information, see [Monitoring with alarms](https://docs.aws.amazon.com/iot-sitewise/latest/appguide/monitor-alarms.html) in the IoT SiteWise Application Guide.
    public struct Alarms: Swift.Equatable {
        /// The [ARN](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the IAM role that allows the alarm to perform actions and access Amazon Web Services resources and services, such as IoT Events.
        /// This member is required.
        public var alarmRoleArn: Swift.String?
        /// The [ARN](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the Lambda function that manages alarm notifications. For more information, see [Managing alarm notifications](https://docs.aws.amazon.com/iotevents/latest/developerguide/lambda-support.html) in the IoT Events Developer Guide.
        public var notificationLambdaArn: Swift.String?

        public init(
            alarmRoleArn: Swift.String? = nil,
            notificationLambdaArn: Swift.String? = nil
        )
        {
            self.alarmRoleArn = alarmRoleArn
            self.notificationLambdaArn = notificationLambdaArn
        }
    }

}

extension IoTSiteWiseClientTypes.AssetCompositeModel: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case id
        case name
        case properties
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let properties = properties {
            var propertiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .properties)
            for assetproperty0 in properties {
                try propertiesContainer.encode(assetproperty0)
            }
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let propertiesContainer = try containerValues.decodeIfPresent([IoTSiteWiseClientTypes.AssetProperty?].self, forKey: .properties)
        var propertiesDecoded0:[IoTSiteWiseClientTypes.AssetProperty]? = nil
        if let propertiesContainer = propertiesContainer {
            propertiesDecoded0 = [IoTSiteWiseClientTypes.AssetProperty]()
            for structure0 in propertiesContainer {
                if let structure0 = structure0 {
                    propertiesDecoded0?.append(structure0)
                }
            }
        }
        properties = propertiesDecoded0
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
    }
}

extension IoTSiteWiseClientTypes {
    /// Contains information about a composite model in an asset. This object contains the asset's properties that you define in the composite model.
    public struct AssetCompositeModel: Swift.Equatable {
        /// The description of the composite model.
        public var description: Swift.String?
        /// The ID of the asset composite model.
        public var id: Swift.String?
        /// The name of the composite model.
        /// This member is required.
        public var name: Swift.String?
        /// The asset properties that this composite model defines.
        /// This member is required.
        public var properties: [IoTSiteWiseClientTypes.AssetProperty]?
        /// The type of the composite model. For alarm composite models, this type is AWS/ALARM.
        /// This member is required.
        public var type: Swift.String?

        public init(
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            properties: [IoTSiteWiseClientTypes.AssetProperty]? = nil,
            type: Swift.String? = nil
        )
        {
            self.description = description
            self.id = id
            self.name = name
            self.properties = properties
            self.type = type
        }
    }

}

extension IoTSiteWiseClientTypes {
    public enum AssetErrorCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case internalFailure
        case sdkUnknown(Swift.String)

        public static var allCases: [AssetErrorCode] {
            return [
                .internalFailure,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .internalFailure: return "INTERNAL_FAILURE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AssetErrorCode(rawValue: rawValue) ?? AssetErrorCode.sdkUnknown(rawValue)
        }
    }
}

extension IoTSiteWiseClientTypes.AssetErrorDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assetId
        case code
        case message
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assetId = self.assetId {
            try encodeContainer.encode(assetId, forKey: .assetId)
        }
        if let code = self.code {
            try encodeContainer.encode(code.rawValue, forKey: .code)
        }
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assetId)
        assetId = assetIdDecoded
        let codeDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.AssetErrorCode.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension IoTSiteWiseClientTypes {
    /// Contains error details for the requested associate project asset action.
    public struct AssetErrorDetails: Swift.Equatable {
        /// The ID of the asset.
        /// This member is required.
        public var assetId: Swift.String?
        /// The error code.
        /// This member is required.
        public var code: IoTSiteWiseClientTypes.AssetErrorCode?
        /// The error message.
        /// This member is required.
        public var message: Swift.String?

        public init(
            assetId: Swift.String? = nil,
            code: IoTSiteWiseClientTypes.AssetErrorCode? = nil,
            message: Swift.String? = nil
        )
        {
            self.assetId = assetId
            self.code = code
            self.message = message
        }
    }

}

extension IoTSiteWiseClientTypes.AssetHierarchy: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension IoTSiteWiseClientTypes {
    /// Describes an asset hierarchy that contains a hierarchy's name and ID.
    public struct AssetHierarchy: Swift.Equatable {
        /// The ID of the hierarchy. This ID is a hierarchyId.
        public var id: Swift.String?
        /// The hierarchy name provided in the [CreateAssetModel](https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_CreateAssetModel.html) or [UpdateAssetModel](https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_UpdateAssetModel.html) API operation.
        /// This member is required.
        public var name: Swift.String?

        public init(
            id: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.id = id
            self.name = name
        }
    }

}

extension IoTSiteWiseClientTypes.AssetHierarchyInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case childAssetId
        case parentAssetId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let childAssetId = self.childAssetId {
            try encodeContainer.encode(childAssetId, forKey: .childAssetId)
        }
        if let parentAssetId = self.parentAssetId {
            try encodeContainer.encode(parentAssetId, forKey: .parentAssetId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let parentAssetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parentAssetId)
        parentAssetId = parentAssetIdDecoded
        let childAssetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .childAssetId)
        childAssetId = childAssetIdDecoded
    }
}

extension IoTSiteWiseClientTypes {
    /// Contains information about a parent asset and a child asset that are related through an asset hierarchy.
    public struct AssetHierarchyInfo: Swift.Equatable {
        /// The ID of the child asset in this asset relationship.
        public var childAssetId: Swift.String?
        /// The ID of the parent asset in this asset relationship.
        public var parentAssetId: Swift.String?

        public init(
            childAssetId: Swift.String? = nil,
            parentAssetId: Swift.String? = nil
        )
        {
            self.childAssetId = childAssetId
            self.parentAssetId = parentAssetId
        }
    }

}

extension IoTSiteWiseClientTypes.AssetModelCompositeModel: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case id
        case name
        case properties
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let properties = properties {
            var propertiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .properties)
            for assetmodelproperty0 in properties {
                try propertiesContainer.encode(assetmodelproperty0)
            }
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let propertiesContainer = try containerValues.decodeIfPresent([IoTSiteWiseClientTypes.AssetModelProperty?].self, forKey: .properties)
        var propertiesDecoded0:[IoTSiteWiseClientTypes.AssetModelProperty]? = nil
        if let propertiesContainer = propertiesContainer {
            propertiesDecoded0 = [IoTSiteWiseClientTypes.AssetModelProperty]()
            for structure0 in propertiesContainer {
                if let structure0 = structure0 {
                    propertiesDecoded0?.append(structure0)
                }
            }
        }
        properties = propertiesDecoded0
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
    }
}

extension IoTSiteWiseClientTypes {
    /// Contains information about a composite model in an asset model. This object contains the asset property definitions that you define in the composite model.
    public struct AssetModelCompositeModel: Swift.Equatable {
        /// The description of the composite model.
        public var description: Swift.String?
        /// The ID of the asset model composite model.
        public var id: Swift.String?
        /// The name of the composite model.
        /// This member is required.
        public var name: Swift.String?
        /// The asset property definitions for this composite model.
        public var properties: [IoTSiteWiseClientTypes.AssetModelProperty]?
        /// The type of the composite model. For alarm composite models, this type is AWS/ALARM.
        /// This member is required.
        public var type: Swift.String?

        public init(
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            properties: [IoTSiteWiseClientTypes.AssetModelProperty]? = nil,
            type: Swift.String? = nil
        )
        {
            self.description = description
            self.id = id
            self.name = name
            self.properties = properties
            self.type = type
        }
    }

}

extension IoTSiteWiseClientTypes.AssetModelCompositeModelDefinition: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case name
        case properties
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let properties = properties {
            var propertiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .properties)
            for assetmodelpropertydefinition0 in properties {
                try propertiesContainer.encode(assetmodelpropertydefinition0)
            }
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let propertiesContainer = try containerValues.decodeIfPresent([IoTSiteWiseClientTypes.AssetModelPropertyDefinition?].self, forKey: .properties)
        var propertiesDecoded0:[IoTSiteWiseClientTypes.AssetModelPropertyDefinition]? = nil
        if let propertiesContainer = propertiesContainer {
            propertiesDecoded0 = [IoTSiteWiseClientTypes.AssetModelPropertyDefinition]()
            for structure0 in propertiesContainer {
                if let structure0 = structure0 {
                    propertiesDecoded0?.append(structure0)
                }
            }
        }
        properties = propertiesDecoded0
    }
}

extension IoTSiteWiseClientTypes {
    /// Contains a composite model definition in an asset model. This composite model definition is applied to all assets created from the asset model.
    public struct AssetModelCompositeModelDefinition: Swift.Equatable {
        /// The description of the composite model.
        public var description: Swift.String?
        /// The name of the composite model.
        /// This member is required.
        public var name: Swift.String?
        /// The asset property definitions for this composite model.
        public var properties: [IoTSiteWiseClientTypes.AssetModelPropertyDefinition]?
        /// The type of the composite model. For alarm composite models, this type is AWS/ALARM.
        /// This member is required.
        public var type: Swift.String?

        public init(
            description: Swift.String? = nil,
            name: Swift.String? = nil,
            properties: [IoTSiteWiseClientTypes.AssetModelPropertyDefinition]? = nil,
            type: Swift.String? = nil
        )
        {
            self.description = description
            self.name = name
            self.properties = properties
            self.type = type
        }
    }

}

extension IoTSiteWiseClientTypes.AssetModelHierarchy: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case childAssetModelId
        case id
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let childAssetModelId = self.childAssetModelId {
            try encodeContainer.encode(childAssetModelId, forKey: .childAssetModelId)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let childAssetModelIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .childAssetModelId)
        childAssetModelId = childAssetModelIdDecoded
    }
}

extension IoTSiteWiseClientTypes {
    /// Describes an asset hierarchy that contains a hierarchy's name, ID, and child asset model ID that specifies the type of asset that can be in this hierarchy.
    public struct AssetModelHierarchy: Swift.Equatable {
        /// The ID of the asset model. All assets in this hierarchy must be instances of the childAssetModelId asset model.
        /// This member is required.
        public var childAssetModelId: Swift.String?
        /// The ID of the asset model hierarchy. This ID is a hierarchyId.
        public var id: Swift.String?
        /// The name of the asset model hierarchy that you specify by using the [CreateAssetModel](https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_CreateAssetModel.html) or [UpdateAssetModel](https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_UpdateAssetModel.html) API operation.
        /// This member is required.
        public var name: Swift.String?

        public init(
            childAssetModelId: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.childAssetModelId = childAssetModelId
            self.id = id
            self.name = name
        }
    }

}

extension IoTSiteWiseClientTypes.AssetModelHierarchyDefinition: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case childAssetModelId
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let childAssetModelId = self.childAssetModelId {
            try encodeContainer.encode(childAssetModelId, forKey: .childAssetModelId)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let childAssetModelIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .childAssetModelId)
        childAssetModelId = childAssetModelIdDecoded
    }
}

extension IoTSiteWiseClientTypes {
    /// Contains an asset model hierarchy used in asset model creation. An asset model hierarchy determines the kind (or type) of asset that can belong to a hierarchy.
    public struct AssetModelHierarchyDefinition: Swift.Equatable {
        /// The ID of an asset model for this hierarchy.
        /// This member is required.
        public var childAssetModelId: Swift.String?
        /// The name of the asset model hierarchy definition (as specified in the [CreateAssetModel](https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_CreateAssetModel.html) or [UpdateAssetModel](https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_UpdateAssetModel.html) API operation).
        /// This member is required.
        public var name: Swift.String?

        public init(
            childAssetModelId: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.childAssetModelId = childAssetModelId
            self.name = name
        }
    }

}

extension IoTSiteWiseClientTypes.AssetModelProperty: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataType
        case dataTypeSpec
        case id
        case name
        case type
        case unit
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataType = self.dataType {
            try encodeContainer.encode(dataType.rawValue, forKey: .dataType)
        }
        if let dataTypeSpec = self.dataTypeSpec {
            try encodeContainer.encode(dataTypeSpec, forKey: .dataTypeSpec)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
        if let unit = self.unit {
            try encodeContainer.encode(unit, forKey: .unit)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let dataTypeDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.PropertyDataType.self, forKey: .dataType)
        dataType = dataTypeDecoded
        let dataTypeSpecDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataTypeSpec)
        dataTypeSpec = dataTypeSpecDecoded
        let unitDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .unit)
        unit = unitDecoded
        let typeDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.PropertyType.self, forKey: .type)
        type = typeDecoded
    }
}

extension IoTSiteWiseClientTypes {
    /// Contains information about an asset model property.
    public struct AssetModelProperty: Swift.Equatable {
        /// The data type of the asset model property.
        /// This member is required.
        public var dataType: IoTSiteWiseClientTypes.PropertyDataType?
        /// The data type of the structure for this property. This parameter exists on properties that have the STRUCT data type.
        public var dataTypeSpec: Swift.String?
        /// The ID of the asset model property.
        public var id: Swift.String?
        /// The name of the asset model property.
        /// This member is required.
        public var name: Swift.String?
        /// The property type (see PropertyType).
        /// This member is required.
        public var type: IoTSiteWiseClientTypes.PropertyType?
        /// The unit of the asset model property, such as Newtons or RPM.
        public var unit: Swift.String?

        public init(
            dataType: IoTSiteWiseClientTypes.PropertyDataType? = nil,
            dataTypeSpec: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            type: IoTSiteWiseClientTypes.PropertyType? = nil,
            unit: Swift.String? = nil
        )
        {
            self.dataType = dataType
            self.dataTypeSpec = dataTypeSpec
            self.id = id
            self.name = name
            self.type = type
            self.unit = unit
        }
    }

}

extension IoTSiteWiseClientTypes.AssetModelPropertyDefinition: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataType
        case dataTypeSpec
        case name
        case type
        case unit
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataType = self.dataType {
            try encodeContainer.encode(dataType.rawValue, forKey: .dataType)
        }
        if let dataTypeSpec = self.dataTypeSpec {
            try encodeContainer.encode(dataTypeSpec, forKey: .dataTypeSpec)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
        if let unit = self.unit {
            try encodeContainer.encode(unit, forKey: .unit)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let dataTypeDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.PropertyDataType.self, forKey: .dataType)
        dataType = dataTypeDecoded
        let dataTypeSpecDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataTypeSpec)
        dataTypeSpec = dataTypeSpecDecoded
        let unitDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .unit)
        unit = unitDecoded
        let typeDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.PropertyType.self, forKey: .type)
        type = typeDecoded
    }
}

extension IoTSiteWiseClientTypes {
    /// Contains an asset model property definition. This property definition is applied to all assets created from the asset model.
    public struct AssetModelPropertyDefinition: Swift.Equatable {
        /// The data type of the property definition. If you specify STRUCT, you must also specify dataTypeSpec to identify the type of the structure for this property.
        /// This member is required.
        public var dataType: IoTSiteWiseClientTypes.PropertyDataType?
        /// The data type of the structure for this property. This parameter is required on properties that have the STRUCT data type. The options for this parameter depend on the type of the composite model in which you define this property. Use AWS/ALARM_STATE for alarm state in alarm composite models.
        public var dataTypeSpec: Swift.String?
        /// The name of the property definition.
        /// This member is required.
        public var name: Swift.String?
        /// The property definition type (see PropertyType). You can only specify one type in a property definition.
        /// This member is required.
        public var type: IoTSiteWiseClientTypes.PropertyType?
        /// The unit of the property definition, such as Newtons or RPM.
        public var unit: Swift.String?

        public init(
            dataType: IoTSiteWiseClientTypes.PropertyDataType? = nil,
            dataTypeSpec: Swift.String? = nil,
            name: Swift.String? = nil,
            type: IoTSiteWiseClientTypes.PropertyType? = nil,
            unit: Swift.String? = nil
        )
        {
            self.dataType = dataType
            self.dataTypeSpec = dataTypeSpec
            self.name = name
            self.type = type
            self.unit = unit
        }
    }

}

extension IoTSiteWiseClientTypes.AssetModelPropertySummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assetModelCompositeModelId
        case dataType
        case dataTypeSpec
        case id
        case name
        case type
        case unit
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assetModelCompositeModelId = self.assetModelCompositeModelId {
            try encodeContainer.encode(assetModelCompositeModelId, forKey: .assetModelCompositeModelId)
        }
        if let dataType = self.dataType {
            try encodeContainer.encode(dataType.rawValue, forKey: .dataType)
        }
        if let dataTypeSpec = self.dataTypeSpec {
            try encodeContainer.encode(dataTypeSpec, forKey: .dataTypeSpec)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
        if let unit = self.unit {
            try encodeContainer.encode(unit, forKey: .unit)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let dataTypeDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.PropertyDataType.self, forKey: .dataType)
        dataType = dataTypeDecoded
        let dataTypeSpecDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataTypeSpec)
        dataTypeSpec = dataTypeSpecDecoded
        let unitDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .unit)
        unit = unitDecoded
        let typeDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.PropertyType.self, forKey: .type)
        type = typeDecoded
        let assetModelCompositeModelIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assetModelCompositeModelId)
        assetModelCompositeModelId = assetModelCompositeModelIdDecoded
    }
}

extension IoTSiteWiseClientTypes {
    /// Contains a summary of a property associated with a model.
    public struct AssetModelPropertySummary: Swift.Equatable {
        /// The ID of the composite model that contains the asset model property.
        public var assetModelCompositeModelId: Swift.String?
        /// The data type of the property.
        /// This member is required.
        public var dataType: IoTSiteWiseClientTypes.PropertyDataType?
        /// The data type of the structure for this property. This parameter exists on properties that have the STRUCT data type.
        public var dataTypeSpec: Swift.String?
        /// The ID of the property.
        public var id: Swift.String?
        /// The name of the property.
        /// This member is required.
        public var name: Swift.String?
        /// Contains a property type, which can be one of attribute, measurement, metric, or transform.
        /// This member is required.
        public var type: IoTSiteWiseClientTypes.PropertyType?
        /// The unit (such as Newtons or RPM) of the property.
        public var unit: Swift.String?

        public init(
            assetModelCompositeModelId: Swift.String? = nil,
            dataType: IoTSiteWiseClientTypes.PropertyDataType? = nil,
            dataTypeSpec: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            type: IoTSiteWiseClientTypes.PropertyType? = nil,
            unit: Swift.String? = nil
        )
        {
            self.assetModelCompositeModelId = assetModelCompositeModelId
            self.dataType = dataType
            self.dataTypeSpec = dataTypeSpec
            self.id = id
            self.name = name
            self.type = type
            self.unit = unit
        }
    }

}

extension IoTSiteWiseClientTypes {
    public enum AssetModelState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case creating
        case deleting
        case failed
        case propagating
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [AssetModelState] {
            return [
                .active,
                .creating,
                .deleting,
                .failed,
                .propagating,
                .updating,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .creating: return "CREATING"
            case .deleting: return "DELETING"
            case .failed: return "FAILED"
            case .propagating: return "PROPAGATING"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AssetModelState(rawValue: rawValue) ?? AssetModelState.sdkUnknown(rawValue)
        }
    }
}

extension IoTSiteWiseClientTypes.AssetModelStatus: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case error
        case state
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let error = self.error {
            try encodeContainer.encode(error, forKey: .error)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stateDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.AssetModelState.self, forKey: .state)
        state = stateDecoded
        let errorDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.ErrorDetails.self, forKey: .error)
        error = errorDecoded
    }
}

extension IoTSiteWiseClientTypes {
    /// Contains current status information for an asset model. For more information, see [Asset and model states](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/asset-and-model-states.html) in the IoT SiteWise User Guide.
    public struct AssetModelStatus: Swift.Equatable {
        /// Contains associated error information, if any.
        public var error: IoTSiteWiseClientTypes.ErrorDetails?
        /// The current state of the asset model.
        /// This member is required.
        public var state: IoTSiteWiseClientTypes.AssetModelState?

        public init(
            error: IoTSiteWiseClientTypes.ErrorDetails? = nil,
            state: IoTSiteWiseClientTypes.AssetModelState? = nil
        )
        {
            self.error = error
            self.state = state
        }
    }

}

extension IoTSiteWiseClientTypes.AssetModelSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case creationDate
        case description
        case id
        case lastUpdateDate
        case name
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let creationDate = self.creationDate {
            try encodeContainer.encodeTimestamp(creationDate, format: .epochSeconds, forKey: .creationDate)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let lastUpdateDate = self.lastUpdateDate {
            try encodeContainer.encodeTimestamp(lastUpdateDate, format: .epochSeconds, forKey: .lastUpdateDate)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let creationDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDate)
        creationDate = creationDateDecoded
        let lastUpdateDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdateDate)
        lastUpdateDate = lastUpdateDateDecoded
        let statusDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.AssetModelStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension IoTSiteWiseClientTypes {
    /// Contains a summary of an asset model.
    public struct AssetModelSummary: Swift.Equatable {
        /// The [ARN](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the asset model, which has the following format. arn:${Partition}:iotsitewise:${Region}:${Account}:asset-model/${AssetModelId}
        /// This member is required.
        public var arn: Swift.String?
        /// The date the asset model was created, in Unix epoch time.
        /// This member is required.
        public var creationDate: ClientRuntime.Date?
        /// The asset model description.
        /// This member is required.
        public var description: Swift.String?
        /// The ID of the asset model (used with IoT SiteWise APIs).
        /// This member is required.
        public var id: Swift.String?
        /// The date the asset model was last updated, in Unix epoch time.
        /// This member is required.
        public var lastUpdateDate: ClientRuntime.Date?
        /// The name of the asset model.
        /// This member is required.
        public var name: Swift.String?
        /// The current status of the asset model.
        /// This member is required.
        public var status: IoTSiteWiseClientTypes.AssetModelStatus?

        public init(
            arn: Swift.String? = nil,
            creationDate: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            lastUpdateDate: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            status: IoTSiteWiseClientTypes.AssetModelStatus? = nil
        )
        {
            self.arn = arn
            self.creationDate = creationDate
            self.description = description
            self.id = id
            self.lastUpdateDate = lastUpdateDate
            self.name = name
            self.status = status
        }
    }

}

extension IoTSiteWiseClientTypes.AssetProperty: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alias
        case dataType
        case dataTypeSpec
        case id
        case name
        case notification
        case unit
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let alias = self.alias {
            try encodeContainer.encode(alias, forKey: .alias)
        }
        if let dataType = self.dataType {
            try encodeContainer.encode(dataType.rawValue, forKey: .dataType)
        }
        if let dataTypeSpec = self.dataTypeSpec {
            try encodeContainer.encode(dataTypeSpec, forKey: .dataTypeSpec)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let notification = self.notification {
            try encodeContainer.encode(notification, forKey: .notification)
        }
        if let unit = self.unit {
            try encodeContainer.encode(unit, forKey: .unit)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let aliasDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .alias)
        alias = aliasDecoded
        let notificationDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.PropertyNotification.self, forKey: .notification)
        notification = notificationDecoded
        let dataTypeDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.PropertyDataType.self, forKey: .dataType)
        dataType = dataTypeDecoded
        let dataTypeSpecDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataTypeSpec)
        dataTypeSpec = dataTypeSpecDecoded
        let unitDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .unit)
        unit = unitDecoded
    }
}

extension IoTSiteWiseClientTypes {
    /// Contains asset property information.
    public struct AssetProperty: Swift.Equatable {
        /// The alias that identifies the property, such as an OPC-UA server data stream path (for example, /company/windfarm/3/turbine/7/temperature). For more information, see [Mapping industrial data streams to asset properties](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/connect-data-streams.html) in the IoT SiteWise User Guide.
        public var alias: Swift.String?
        /// The data type of the asset property.
        /// This member is required.
        public var dataType: IoTSiteWiseClientTypes.PropertyDataType?
        /// The data type of the structure for this property. This parameter exists on properties that have the STRUCT data type.
        public var dataTypeSpec: Swift.String?
        /// The ID of the asset property.
        /// This member is required.
        public var id: Swift.String?
        /// The name of the property.
        /// This member is required.
        public var name: Swift.String?
        /// The asset property's notification topic and state. For more information, see [UpdateAssetProperty](https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_UpdateAssetProperty.html).
        public var notification: IoTSiteWiseClientTypes.PropertyNotification?
        /// The unit (such as Newtons or RPM) of the asset property.
        public var unit: Swift.String?

        public init(
            alias: Swift.String? = nil,
            dataType: IoTSiteWiseClientTypes.PropertyDataType? = nil,
            dataTypeSpec: Swift.String? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            notification: IoTSiteWiseClientTypes.PropertyNotification? = nil,
            unit: Swift.String? = nil
        )
        {
            self.alias = alias
            self.dataType = dataType
            self.dataTypeSpec = dataTypeSpec
            self.id = id
            self.name = name
            self.notification = notification
            self.unit = unit
        }
    }

}

extension IoTSiteWiseClientTypes.AssetPropertySummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alias
        case assetCompositeModelId
        case id
        case notification
        case unit
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let alias = self.alias {
            try encodeContainer.encode(alias, forKey: .alias)
        }
        if let assetCompositeModelId = self.assetCompositeModelId {
            try encodeContainer.encode(assetCompositeModelId, forKey: .assetCompositeModelId)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let notification = self.notification {
            try encodeContainer.encode(notification, forKey: .notification)
        }
        if let unit = self.unit {
            try encodeContainer.encode(unit, forKey: .unit)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let aliasDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .alias)
        alias = aliasDecoded
        let unitDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .unit)
        unit = unitDecoded
        let notificationDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.PropertyNotification.self, forKey: .notification)
        notification = notificationDecoded
        let assetCompositeModelIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assetCompositeModelId)
        assetCompositeModelId = assetCompositeModelIdDecoded
    }
}

extension IoTSiteWiseClientTypes {
    /// Contains a summary of a property associated with an asset.
    public struct AssetPropertySummary: Swift.Equatable {
        /// The alias that identifies the property, such as an OPC-UA server data stream path (for example, /company/windfarm/3/turbine/7/temperature). For more information, see [Mapping industrial data streams to asset properties](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/connect-data-streams.html) in the IoT SiteWise User Guide.
        public var alias: Swift.String?
        /// The ID of the composite model that contains the asset property.
        public var assetCompositeModelId: Swift.String?
        /// The ID of the property.
        public var id: Swift.String?
        /// Contains asset property value notification information. When the notification state is enabled, IoT SiteWise publishes property value updates to a unique MQTT topic. For more information, see [Interacting with other services](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/interact-with-other-services.html) in the IoT SiteWise User Guide.
        public var notification: IoTSiteWiseClientTypes.PropertyNotification?
        /// The unit of measure (such as Newtons or RPM) of the asset property.
        public var unit: Swift.String?

        public init(
            alias: Swift.String? = nil,
            assetCompositeModelId: Swift.String? = nil,
            id: Swift.String? = nil,
            notification: IoTSiteWiseClientTypes.PropertyNotification? = nil,
            unit: Swift.String? = nil
        )
        {
            self.alias = alias
            self.assetCompositeModelId = assetCompositeModelId
            self.id = id
            self.notification = notification
            self.unit = unit
        }
    }

}

extension IoTSiteWiseClientTypes.AssetPropertyValue: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case quality
        case timestamp
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let quality = self.quality {
            try encodeContainer.encode(quality.rawValue, forKey: .quality)
        }
        if let timestamp = self.timestamp {
            try encodeContainer.encode(timestamp, forKey: .timestamp)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valueDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.Variant.self, forKey: .value)
        value = valueDecoded
        let timestampDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.TimeInNanos.self, forKey: .timestamp)
        timestamp = timestampDecoded
        let qualityDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.Quality.self, forKey: .quality)
        quality = qualityDecoded
    }
}

extension IoTSiteWiseClientTypes {
    /// Contains asset property value information.
    public struct AssetPropertyValue: Swift.Equatable {
        /// The quality of the asset property value.
        public var quality: IoTSiteWiseClientTypes.Quality?
        /// The timestamp of the asset property value.
        /// This member is required.
        public var timestamp: IoTSiteWiseClientTypes.TimeInNanos?
        /// The value of the asset property (see Variant).
        /// This member is required.
        public var value: IoTSiteWiseClientTypes.Variant?

        public init(
            quality: IoTSiteWiseClientTypes.Quality? = nil,
            timestamp: IoTSiteWiseClientTypes.TimeInNanos? = nil,
            value: IoTSiteWiseClientTypes.Variant? = nil
        )
        {
            self.quality = quality
            self.timestamp = timestamp
            self.value = value
        }
    }

}

extension IoTSiteWiseClientTypes.AssetRelationshipSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hierarchyInfo
        case relationshipType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let hierarchyInfo = self.hierarchyInfo {
            try encodeContainer.encode(hierarchyInfo, forKey: .hierarchyInfo)
        }
        if let relationshipType = self.relationshipType {
            try encodeContainer.encode(relationshipType.rawValue, forKey: .relationshipType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hierarchyInfoDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.AssetHierarchyInfo.self, forKey: .hierarchyInfo)
        hierarchyInfo = hierarchyInfoDecoded
        let relationshipTypeDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.AssetRelationshipType.self, forKey: .relationshipType)
        relationshipType = relationshipTypeDecoded
    }
}

extension IoTSiteWiseClientTypes {
    /// Contains information about assets that are related to one another.
    public struct AssetRelationshipSummary: Swift.Equatable {
        /// The assets that are related through an asset hierarchy. This object is present if the relationshipType is HIERARCHY.
        public var hierarchyInfo: IoTSiteWiseClientTypes.AssetHierarchyInfo?
        /// The relationship type of the assets in this relationship. This value is one of the following:
        ///
        /// * HIERARCHY  The assets are related through an asset hierarchy. If you specify this relationship type, this asset relationship includes the hierarchyInfo object.
        /// This member is required.
        public var relationshipType: IoTSiteWiseClientTypes.AssetRelationshipType?

        public init(
            hierarchyInfo: IoTSiteWiseClientTypes.AssetHierarchyInfo? = nil,
            relationshipType: IoTSiteWiseClientTypes.AssetRelationshipType? = nil
        )
        {
            self.hierarchyInfo = hierarchyInfo
            self.relationshipType = relationshipType
        }
    }

}

extension IoTSiteWiseClientTypes {
    public enum AssetRelationshipType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case hierarchy
        case sdkUnknown(Swift.String)

        public static var allCases: [AssetRelationshipType] {
            return [
                .hierarchy,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .hierarchy: return "HIERARCHY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AssetRelationshipType(rawValue: rawValue) ?? AssetRelationshipType.sdkUnknown(rawValue)
        }
    }
}

extension IoTSiteWiseClientTypes {
    public enum AssetState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case creating
        case deleting
        case failed
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [AssetState] {
            return [
                .active,
                .creating,
                .deleting,
                .failed,
                .updating,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .creating: return "CREATING"
            case .deleting: return "DELETING"
            case .failed: return "FAILED"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AssetState(rawValue: rawValue) ?? AssetState.sdkUnknown(rawValue)
        }
    }
}

extension IoTSiteWiseClientTypes.AssetStatus: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case error
        case state
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let error = self.error {
            try encodeContainer.encode(error, forKey: .error)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stateDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.AssetState.self, forKey: .state)
        state = stateDecoded
        let errorDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.ErrorDetails.self, forKey: .error)
        error = errorDecoded
    }
}

extension IoTSiteWiseClientTypes {
    /// Contains information about the current status of an asset. For more information, see [Asset and model states](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/asset-and-model-states.html) in the IoT SiteWise User Guide.
    public struct AssetStatus: Swift.Equatable {
        /// Contains associated error information, if any.
        public var error: IoTSiteWiseClientTypes.ErrorDetails?
        /// The current status of the asset.
        /// This member is required.
        public var state: IoTSiteWiseClientTypes.AssetState?

        public init(
            error: IoTSiteWiseClientTypes.ErrorDetails? = nil,
            state: IoTSiteWiseClientTypes.AssetState? = nil
        )
        {
            self.error = error
            self.state = state
        }
    }

}

extension IoTSiteWiseClientTypes.AssetSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case assetModelId
        case creationDate
        case description
        case hierarchies
        case id
        case lastUpdateDate
        case name
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let assetModelId = self.assetModelId {
            try encodeContainer.encode(assetModelId, forKey: .assetModelId)
        }
        if let creationDate = self.creationDate {
            try encodeContainer.encodeTimestamp(creationDate, format: .epochSeconds, forKey: .creationDate)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let hierarchies = hierarchies {
            var hierarchiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .hierarchies)
            for assethierarchy0 in hierarchies {
                try hierarchiesContainer.encode(assethierarchy0)
            }
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let lastUpdateDate = self.lastUpdateDate {
            try encodeContainer.encodeTimestamp(lastUpdateDate, format: .epochSeconds, forKey: .lastUpdateDate)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let assetModelIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assetModelId)
        assetModelId = assetModelIdDecoded
        let creationDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDate)
        creationDate = creationDateDecoded
        let lastUpdateDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdateDate)
        lastUpdateDate = lastUpdateDateDecoded
        let statusDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.AssetStatus.self, forKey: .status)
        status = statusDecoded
        let hierarchiesContainer = try containerValues.decodeIfPresent([IoTSiteWiseClientTypes.AssetHierarchy?].self, forKey: .hierarchies)
        var hierarchiesDecoded0:[IoTSiteWiseClientTypes.AssetHierarchy]? = nil
        if let hierarchiesContainer = hierarchiesContainer {
            hierarchiesDecoded0 = [IoTSiteWiseClientTypes.AssetHierarchy]()
            for structure0 in hierarchiesContainer {
                if let structure0 = structure0 {
                    hierarchiesDecoded0?.append(structure0)
                }
            }
        }
        hierarchies = hierarchiesDecoded0
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension IoTSiteWiseClientTypes {
    /// Contains a summary of an asset.
    public struct AssetSummary: Swift.Equatable {
        /// The [ARN](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the asset, which has the following format. arn:${Partition}:iotsitewise:${Region}:${Account}:asset/${AssetId}
        /// This member is required.
        public var arn: Swift.String?
        /// The ID of the asset model used to create this asset.
        /// This member is required.
        public var assetModelId: Swift.String?
        /// The date the asset was created, in Unix epoch time.
        /// This member is required.
        public var creationDate: ClientRuntime.Date?
        /// A description for the asset.
        public var description: Swift.String?
        /// A list of asset hierarchies that each contain a hierarchyId. A hierarchy specifies allowed parent/child asset relationships.
        /// This member is required.
        public var hierarchies: [IoTSiteWiseClientTypes.AssetHierarchy]?
        /// The ID of the asset.
        /// This member is required.
        public var id: Swift.String?
        /// The date the asset was last updated, in Unix epoch time.
        /// This member is required.
        public var lastUpdateDate: ClientRuntime.Date?
        /// The name of the asset.
        /// This member is required.
        public var name: Swift.String?
        /// The current status of the asset.
        /// This member is required.
        public var status: IoTSiteWiseClientTypes.AssetStatus?

        public init(
            arn: Swift.String? = nil,
            assetModelId: Swift.String? = nil,
            creationDate: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            hierarchies: [IoTSiteWiseClientTypes.AssetHierarchy]? = nil,
            id: Swift.String? = nil,
            lastUpdateDate: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            status: IoTSiteWiseClientTypes.AssetStatus? = nil
        )
        {
            self.arn = arn
            self.assetModelId = assetModelId
            self.creationDate = creationDate
            self.description = description
            self.hierarchies = hierarchies
            self.id = id
            self.lastUpdateDate = lastUpdateDate
            self.name = name
            self.status = status
        }
    }

}

extension AssociateAssetsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case childAssetId
        case clientToken
        case hierarchyId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let childAssetId = self.childAssetId {
            try encodeContainer.encode(childAssetId, forKey: .childAssetId)
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let hierarchyId = self.hierarchyId {
            try encodeContainer.encode(hierarchyId, forKey: .hierarchyId)
        }
    }
}

extension AssociateAssetsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let assetId = assetId else {
            return nil
        }
        return "/assets/\(assetId.urlPercentEncoding())/associate"
    }
}

public struct AssociateAssetsInput: Swift.Equatable {
    /// The ID of the parent asset.
    /// This member is required.
    public var assetId: Swift.String?
    /// The ID of the child asset to be associated.
    /// This member is required.
    public var childAssetId: Swift.String?
    /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
    public var clientToken: Swift.String?
    /// The ID of a hierarchy in the parent asset's model. Hierarchies allow different groupings of assets to be formed that all come from the same asset model. For more information, see [Asset hierarchies](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/asset-hierarchies.html) in the IoT SiteWise User Guide.
    /// This member is required.
    public var hierarchyId: Swift.String?

    public init(
        assetId: Swift.String? = nil,
        childAssetId: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        hierarchyId: Swift.String? = nil
    )
    {
        self.assetId = assetId
        self.childAssetId = childAssetId
        self.clientToken = clientToken
        self.hierarchyId = hierarchyId
    }
}

struct AssociateAssetsInputBody: Swift.Equatable {
    let hierarchyId: Swift.String?
    let childAssetId: Swift.String?
    let clientToken: Swift.String?
}

extension AssociateAssetsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case childAssetId
        case clientToken
        case hierarchyId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hierarchyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hierarchyId)
        hierarchyId = hierarchyIdDecoded
        let childAssetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .childAssetId)
        childAssetId = childAssetIdDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension AssociateAssetsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct AssociateAssetsOutput: Swift.Equatable {

    public init() { }
}

enum AssociateAssetsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictingOperationException": return try await ConflictingOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceAlreadyExistsException": return try await ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AssociateTimeSeriesToAssetPropertyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
    }
}

extension AssociateTimeSeriesToAssetPropertyInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let assetId = assetId else {
                let message = "Creating a URL Query Item failed. assetId is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let assetIdQueryItem = ClientRuntime.URLQueryItem(name: "assetId".urlPercentEncoding(), value: Swift.String(assetId).urlPercentEncoding())
            items.append(assetIdQueryItem)
            guard let alias = alias else {
                let message = "Creating a URL Query Item failed. alias is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let aliasQueryItem = ClientRuntime.URLQueryItem(name: "alias".urlPercentEncoding(), value: Swift.String(alias).urlPercentEncoding())
            items.append(aliasQueryItem)
            guard let propertyId = propertyId else {
                let message = "Creating a URL Query Item failed. propertyId is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let propertyIdQueryItem = ClientRuntime.URLQueryItem(name: "propertyId".urlPercentEncoding(), value: Swift.String(propertyId).urlPercentEncoding())
            items.append(propertyIdQueryItem)
            return items
        }
    }
}

extension AssociateTimeSeriesToAssetPropertyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/timeseries/associate"
    }
}

public struct AssociateTimeSeriesToAssetPropertyInput: Swift.Equatable {
    /// The alias that identifies the time series.
    /// This member is required.
    public var alias: Swift.String?
    /// The ID of the asset in which the asset property was created.
    /// This member is required.
    public var assetId: Swift.String?
    /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
    public var clientToken: Swift.String?
    /// The ID of the asset property.
    /// This member is required.
    public var propertyId: Swift.String?

    public init(
        alias: Swift.String? = nil,
        assetId: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        propertyId: Swift.String? = nil
    )
    {
        self.alias = alias
        self.assetId = assetId
        self.clientToken = clientToken
        self.propertyId = propertyId
    }
}

struct AssociateTimeSeriesToAssetPropertyInputBody: Swift.Equatable {
    let clientToken: Swift.String?
}

extension AssociateTimeSeriesToAssetPropertyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension AssociateTimeSeriesToAssetPropertyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct AssociateTimeSeriesToAssetPropertyOutput: Swift.Equatable {

    public init() { }
}

enum AssociateTimeSeriesToAssetPropertyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictingOperationException": return try await ConflictingOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension IoTSiteWiseClientTypes.AssociatedAssetsSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case assetModelId
        case creationDate
        case description
        case hierarchies
        case id
        case lastUpdateDate
        case name
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let assetModelId = self.assetModelId {
            try encodeContainer.encode(assetModelId, forKey: .assetModelId)
        }
        if let creationDate = self.creationDate {
            try encodeContainer.encodeTimestamp(creationDate, format: .epochSeconds, forKey: .creationDate)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let hierarchies = hierarchies {
            var hierarchiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .hierarchies)
            for assethierarchy0 in hierarchies {
                try hierarchiesContainer.encode(assethierarchy0)
            }
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let lastUpdateDate = self.lastUpdateDate {
            try encodeContainer.encodeTimestamp(lastUpdateDate, format: .epochSeconds, forKey: .lastUpdateDate)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let assetModelIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assetModelId)
        assetModelId = assetModelIdDecoded
        let creationDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDate)
        creationDate = creationDateDecoded
        let lastUpdateDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdateDate)
        lastUpdateDate = lastUpdateDateDecoded
        let statusDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.AssetStatus.self, forKey: .status)
        status = statusDecoded
        let hierarchiesContainer = try containerValues.decodeIfPresent([IoTSiteWiseClientTypes.AssetHierarchy?].self, forKey: .hierarchies)
        var hierarchiesDecoded0:[IoTSiteWiseClientTypes.AssetHierarchy]? = nil
        if let hierarchiesContainer = hierarchiesContainer {
            hierarchiesDecoded0 = [IoTSiteWiseClientTypes.AssetHierarchy]()
            for structure0 in hierarchiesContainer {
                if let structure0 = structure0 {
                    hierarchiesDecoded0?.append(structure0)
                }
            }
        }
        hierarchies = hierarchiesDecoded0
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension IoTSiteWiseClientTypes {
    /// Contains a summary of an associated asset.
    public struct AssociatedAssetsSummary: Swift.Equatable {
        /// The [ARN](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the asset, which has the following format. arn:${Partition}:iotsitewise:${Region}:${Account}:asset/${AssetId}
        /// This member is required.
        public var arn: Swift.String?
        /// The ID of the asset model used to create the asset.
        /// This member is required.
        public var assetModelId: Swift.String?
        /// The date the asset was created, in Unix epoch time.
        /// This member is required.
        public var creationDate: ClientRuntime.Date?
        /// A description for the asset.
        public var description: Swift.String?
        /// A list of asset hierarchies that each contain a hierarchyId. A hierarchy specifies allowed parent/child asset relationships.
        /// This member is required.
        public var hierarchies: [IoTSiteWiseClientTypes.AssetHierarchy]?
        /// The ID of the asset.
        /// This member is required.
        public var id: Swift.String?
        /// The date the asset was last updated, in Unix epoch time.
        /// This member is required.
        public var lastUpdateDate: ClientRuntime.Date?
        /// The name of the asset.
        /// This member is required.
        public var name: Swift.String?
        /// The current status of the asset.
        /// This member is required.
        public var status: IoTSiteWiseClientTypes.AssetStatus?

        public init(
            arn: Swift.String? = nil,
            assetModelId: Swift.String? = nil,
            creationDate: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            hierarchies: [IoTSiteWiseClientTypes.AssetHierarchy]? = nil,
            id: Swift.String? = nil,
            lastUpdateDate: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            status: IoTSiteWiseClientTypes.AssetStatus? = nil
        )
        {
            self.arn = arn
            self.assetModelId = assetModelId
            self.creationDate = creationDate
            self.description = description
            self.hierarchies = hierarchies
            self.id = id
            self.lastUpdateDate = lastUpdateDate
            self.name = name
            self.status = status
        }
    }

}

extension IoTSiteWiseClientTypes.Attribute: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case defaultValue
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let defaultValue = self.defaultValue {
            try encodeContainer.encode(defaultValue, forKey: .defaultValue)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let defaultValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .defaultValue)
        defaultValue = defaultValueDecoded
    }
}

extension IoTSiteWiseClientTypes {
    /// Contains an asset attribute property. For more information, see [Attributes](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/asset-properties.html#attributes) in the IoT SiteWise User Guide.
    public struct Attribute: Swift.Equatable {
        /// The default value of the asset model property attribute. All assets that you create from the asset model contain this attribute value. You can update an attribute's value after you create an asset. For more information, see [Updating attribute values](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/update-attribute-values.html) in the IoT SiteWise User Guide.
        public var defaultValue: Swift.String?

        public init(
            defaultValue: Swift.String? = nil
        )
        {
            self.defaultValue = defaultValue
        }
    }

}

extension IoTSiteWiseClientTypes {
    public enum AuthMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case iam
        case sso
        case sdkUnknown(Swift.String)

        public static var allCases: [AuthMode] {
            return [
                .iam,
                .sso,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .iam: return "IAM"
            case .sso: return "SSO"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AuthMode(rawValue: rawValue) ?? AuthMode.sdkUnknown(rawValue)
        }
    }
}

extension BatchAssociateProjectAssetsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assetIds
        case clientToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assetIds = assetIds {
            var assetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .assetIds)
            for id0 in assetIds {
                try assetIdsContainer.encode(id0)
            }
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
    }
}

extension BatchAssociateProjectAssetsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let projectId = projectId else {
            return nil
        }
        return "/projects/\(projectId.urlPercentEncoding())/assets/associate"
    }
}

public struct BatchAssociateProjectAssetsInput: Swift.Equatable {
    /// The IDs of the assets to be associated to the project.
    /// This member is required.
    public var assetIds: [Swift.String]?
    /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
    public var clientToken: Swift.String?
    /// The ID of the project to which to associate the assets.
    /// This member is required.
    public var projectId: Swift.String?

    public init(
        assetIds: [Swift.String]? = nil,
        clientToken: Swift.String? = nil,
        projectId: Swift.String? = nil
    )
    {
        self.assetIds = assetIds
        self.clientToken = clientToken
        self.projectId = projectId
    }
}

struct BatchAssociateProjectAssetsInputBody: Swift.Equatable {
    let assetIds: [Swift.String]?
    let clientToken: Swift.String?
}

extension BatchAssociateProjectAssetsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assetIds
        case clientToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assetIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .assetIds)
        var assetIdsDecoded0:[Swift.String]? = nil
        if let assetIdsContainer = assetIdsContainer {
            assetIdsDecoded0 = [Swift.String]()
            for string0 in assetIdsContainer {
                if let string0 = string0 {
                    assetIdsDecoded0?.append(string0)
                }
            }
        }
        assetIds = assetIdsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension BatchAssociateProjectAssetsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: BatchAssociateProjectAssetsOutputBody = try responseDecoder.decode(responseBody: data)
            self.errors = output.errors
        } else {
            self.errors = nil
        }
    }
}

public struct BatchAssociateProjectAssetsOutput: Swift.Equatable {
    /// A list of associated error information, if any.
    public var errors: [IoTSiteWiseClientTypes.AssetErrorDetails]?

    public init(
        errors: [IoTSiteWiseClientTypes.AssetErrorDetails]? = nil
    )
    {
        self.errors = errors
    }
}

struct BatchAssociateProjectAssetsOutputBody: Swift.Equatable {
    let errors: [IoTSiteWiseClientTypes.AssetErrorDetails]?
}

extension BatchAssociateProjectAssetsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errors
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorsContainer = try containerValues.decodeIfPresent([IoTSiteWiseClientTypes.AssetErrorDetails?].self, forKey: .errors)
        var errorsDecoded0:[IoTSiteWiseClientTypes.AssetErrorDetails]? = nil
        if let errorsContainer = errorsContainer {
            errorsDecoded0 = [IoTSiteWiseClientTypes.AssetErrorDetails]()
            for structure0 in errorsContainer {
                if let structure0 = structure0 {
                    errorsDecoded0?.append(structure0)
                }
            }
        }
        errors = errorsDecoded0
    }
}

enum BatchAssociateProjectAssetsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension BatchDisassociateProjectAssetsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assetIds
        case clientToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assetIds = assetIds {
            var assetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .assetIds)
            for id0 in assetIds {
                try assetIdsContainer.encode(id0)
            }
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
    }
}

extension BatchDisassociateProjectAssetsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let projectId = projectId else {
            return nil
        }
        return "/projects/\(projectId.urlPercentEncoding())/assets/disassociate"
    }
}

public struct BatchDisassociateProjectAssetsInput: Swift.Equatable {
    /// The IDs of the assets to be disassociated from the project.
    /// This member is required.
    public var assetIds: [Swift.String]?
    /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
    public var clientToken: Swift.String?
    /// The ID of the project from which to disassociate the assets.
    /// This member is required.
    public var projectId: Swift.String?

    public init(
        assetIds: [Swift.String]? = nil,
        clientToken: Swift.String? = nil,
        projectId: Swift.String? = nil
    )
    {
        self.assetIds = assetIds
        self.clientToken = clientToken
        self.projectId = projectId
    }
}

struct BatchDisassociateProjectAssetsInputBody: Swift.Equatable {
    let assetIds: [Swift.String]?
    let clientToken: Swift.String?
}

extension BatchDisassociateProjectAssetsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assetIds
        case clientToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assetIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .assetIds)
        var assetIdsDecoded0:[Swift.String]? = nil
        if let assetIdsContainer = assetIdsContainer {
            assetIdsDecoded0 = [Swift.String]()
            for string0 in assetIdsContainer {
                if let string0 = string0 {
                    assetIdsDecoded0?.append(string0)
                }
            }
        }
        assetIds = assetIdsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension BatchDisassociateProjectAssetsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: BatchDisassociateProjectAssetsOutputBody = try responseDecoder.decode(responseBody: data)
            self.errors = output.errors
        } else {
            self.errors = nil
        }
    }
}

public struct BatchDisassociateProjectAssetsOutput: Swift.Equatable {
    /// A list of associated error information, if any.
    public var errors: [IoTSiteWiseClientTypes.AssetErrorDetails]?

    public init(
        errors: [IoTSiteWiseClientTypes.AssetErrorDetails]? = nil
    )
    {
        self.errors = errors
    }
}

struct BatchDisassociateProjectAssetsOutputBody: Swift.Equatable {
    let errors: [IoTSiteWiseClientTypes.AssetErrorDetails]?
}

extension BatchDisassociateProjectAssetsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errors
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorsContainer = try containerValues.decodeIfPresent([IoTSiteWiseClientTypes.AssetErrorDetails?].self, forKey: .errors)
        var errorsDecoded0:[IoTSiteWiseClientTypes.AssetErrorDetails]? = nil
        if let errorsContainer = errorsContainer {
            errorsDecoded0 = [IoTSiteWiseClientTypes.AssetErrorDetails]()
            for structure0 in errorsContainer {
                if let structure0 = structure0 {
                    errorsDecoded0?.append(structure0)
                }
            }
        }
        errors = errorsDecoded0
    }
}

enum BatchDisassociateProjectAssetsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension IoTSiteWiseClientTypes {
    public enum BatchEntryCompletionStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case error
        case success
        case sdkUnknown(Swift.String)

        public static var allCases: [BatchEntryCompletionStatus] {
            return [
                .error,
                .success,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .error: return "ERROR"
            case .success: return "SUCCESS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = BatchEntryCompletionStatus(rawValue: rawValue) ?? BatchEntryCompletionStatus.sdkUnknown(rawValue)
        }
    }
}

extension IoTSiteWiseClientTypes.BatchGetAssetPropertyAggregatesEntry: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aggregateTypes
        case assetId
        case endDate
        case entryId
        case propertyAlias
        case propertyId
        case qualities
        case resolution
        case startDate
        case timeOrdering
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aggregateTypes = aggregateTypes {
            var aggregateTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .aggregateTypes)
            for aggregatetype0 in aggregateTypes {
                try aggregateTypesContainer.encode(aggregatetype0.rawValue)
            }
        }
        if let assetId = self.assetId {
            try encodeContainer.encode(assetId, forKey: .assetId)
        }
        if let endDate = self.endDate {
            try encodeContainer.encodeTimestamp(endDate, format: .epochSeconds, forKey: .endDate)
        }
        if let entryId = self.entryId {
            try encodeContainer.encode(entryId, forKey: .entryId)
        }
        if let propertyAlias = self.propertyAlias {
            try encodeContainer.encode(propertyAlias, forKey: .propertyAlias)
        }
        if let propertyId = self.propertyId {
            try encodeContainer.encode(propertyId, forKey: .propertyId)
        }
        if let qualities = qualities {
            var qualitiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .qualities)
            for quality0 in qualities {
                try qualitiesContainer.encode(quality0.rawValue)
            }
        }
        if let resolution = self.resolution {
            try encodeContainer.encode(resolution, forKey: .resolution)
        }
        if let startDate = self.startDate {
            try encodeContainer.encodeTimestamp(startDate, format: .epochSeconds, forKey: .startDate)
        }
        if let timeOrdering = self.timeOrdering {
            try encodeContainer.encode(timeOrdering.rawValue, forKey: .timeOrdering)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entryId)
        entryId = entryIdDecoded
        let assetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assetId)
        assetId = assetIdDecoded
        let propertyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .propertyId)
        propertyId = propertyIdDecoded
        let propertyAliasDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .propertyAlias)
        propertyAlias = propertyAliasDecoded
        let aggregateTypesContainer = try containerValues.decodeIfPresent([IoTSiteWiseClientTypes.AggregateType?].self, forKey: .aggregateTypes)
        var aggregateTypesDecoded0:[IoTSiteWiseClientTypes.AggregateType]? = nil
        if let aggregateTypesContainer = aggregateTypesContainer {
            aggregateTypesDecoded0 = [IoTSiteWiseClientTypes.AggregateType]()
            for enum0 in aggregateTypesContainer {
                if let enum0 = enum0 {
                    aggregateTypesDecoded0?.append(enum0)
                }
            }
        }
        aggregateTypes = aggregateTypesDecoded0
        let resolutionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resolution)
        resolution = resolutionDecoded
        let startDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startDate)
        startDate = startDateDecoded
        let endDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endDate)
        endDate = endDateDecoded
        let qualitiesContainer = try containerValues.decodeIfPresent([IoTSiteWiseClientTypes.Quality?].self, forKey: .qualities)
        var qualitiesDecoded0:[IoTSiteWiseClientTypes.Quality]? = nil
        if let qualitiesContainer = qualitiesContainer {
            qualitiesDecoded0 = [IoTSiteWiseClientTypes.Quality]()
            for enum0 in qualitiesContainer {
                if let enum0 = enum0 {
                    qualitiesDecoded0?.append(enum0)
                }
            }
        }
        qualities = qualitiesDecoded0
        let timeOrderingDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.TimeOrdering.self, forKey: .timeOrdering)
        timeOrdering = timeOrderingDecoded
    }
}

extension IoTSiteWiseClientTypes {
    /// Contains information for an asset property aggregate entry that is associated with the [BatchGetAssetPropertyAggregates](https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_BatchGetAssetPropertyAggregates.html) API. To identify an asset property, you must specify one of the following:
    ///
    /// * The assetId and propertyId of an asset property.
    ///
    /// * A propertyAlias, which is a data stream alias (for example, /company/windfarm/3/turbine/7/temperature). To define an asset property's alias, see [UpdateAssetProperty](https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_UpdateAssetProperty.html).
    public struct BatchGetAssetPropertyAggregatesEntry: Swift.Equatable {
        /// The data aggregating function.
        /// This member is required.
        public var aggregateTypes: [IoTSiteWiseClientTypes.AggregateType]?
        /// The ID of the asset in which the asset property was created.
        public var assetId: Swift.String?
        /// The inclusive end of the range from which to query historical data, expressed in seconds in Unix epoch time.
        /// This member is required.
        public var endDate: ClientRuntime.Date?
        /// The ID of the entry.
        /// This member is required.
        public var entryId: Swift.String?
        /// The alias that identifies the property, such as an OPC-UA server data stream path (for example, /company/windfarm/3/turbine/7/temperature). For more information, see [Mapping industrial data streams to asset properties](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/connect-data-streams.html) in the IoT SiteWise User Guide.
        public var propertyAlias: Swift.String?
        /// The ID of the asset property.
        public var propertyId: Swift.String?
        /// The quality by which to filter asset data.
        public var qualities: [IoTSiteWiseClientTypes.Quality]?
        /// The time interval over which to aggregate data.
        /// This member is required.
        public var resolution: Swift.String?
        /// The exclusive start of the range from which to query historical data, expressed in seconds in Unix epoch time.
        /// This member is required.
        public var startDate: ClientRuntime.Date?
        /// The chronological sorting order of the requested information. Default: ASCENDING
        public var timeOrdering: IoTSiteWiseClientTypes.TimeOrdering?

        public init(
            aggregateTypes: [IoTSiteWiseClientTypes.AggregateType]? = nil,
            assetId: Swift.String? = nil,
            endDate: ClientRuntime.Date? = nil,
            entryId: Swift.String? = nil,
            propertyAlias: Swift.String? = nil,
            propertyId: Swift.String? = nil,
            qualities: [IoTSiteWiseClientTypes.Quality]? = nil,
            resolution: Swift.String? = nil,
            startDate: ClientRuntime.Date? = nil,
            timeOrdering: IoTSiteWiseClientTypes.TimeOrdering? = nil
        )
        {
            self.aggregateTypes = aggregateTypes
            self.assetId = assetId
            self.endDate = endDate
            self.entryId = entryId
            self.propertyAlias = propertyAlias
            self.propertyId = propertyId
            self.qualities = qualities
            self.resolution = resolution
            self.startDate = startDate
            self.timeOrdering = timeOrdering
        }
    }

}

extension IoTSiteWiseClientTypes {
    public enum BatchGetAssetPropertyAggregatesErrorCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case accessdeniedexception
        case invalidrequestexception
        case resourcenotfoundexception
        case sdkUnknown(Swift.String)

        public static var allCases: [BatchGetAssetPropertyAggregatesErrorCode] {
            return [
                .accessdeniedexception,
                .invalidrequestexception,
                .resourcenotfoundexception,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .accessdeniedexception: return "AccessDeniedException"
            case .invalidrequestexception: return "InvalidRequestException"
            case .resourcenotfoundexception: return "ResourceNotFoundException"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = BatchGetAssetPropertyAggregatesErrorCode(rawValue: rawValue) ?? BatchGetAssetPropertyAggregatesErrorCode.sdkUnknown(rawValue)
        }
    }
}

extension IoTSiteWiseClientTypes.BatchGetAssetPropertyAggregatesErrorEntry: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entryId
        case errorCode
        case errorMessage
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let entryId = self.entryId {
            try encodeContainer.encode(entryId, forKey: .entryId)
        }
        if let errorCode = self.errorCode {
            try encodeContainer.encode(errorCode.rawValue, forKey: .errorCode)
        }
        if let errorMessage = self.errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.BatchGetAssetPropertyAggregatesErrorCode.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
        let entryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entryId)
        entryId = entryIdDecoded
    }
}

extension IoTSiteWiseClientTypes {
    /// Contains error information for an asset property aggregate entry that is associated with the [BatchGetAssetPropertyAggregates](https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_BatchGetAssetPropertyAggregates.html) API.
    public struct BatchGetAssetPropertyAggregatesErrorEntry: Swift.Equatable {
        /// The ID of the entry.
        /// This member is required.
        public var entryId: Swift.String?
        /// The error code.
        /// This member is required.
        public var errorCode: IoTSiteWiseClientTypes.BatchGetAssetPropertyAggregatesErrorCode?
        /// The associated error message.
        /// This member is required.
        public var errorMessage: Swift.String?

        public init(
            entryId: Swift.String? = nil,
            errorCode: IoTSiteWiseClientTypes.BatchGetAssetPropertyAggregatesErrorCode? = nil,
            errorMessage: Swift.String? = nil
        )
        {
            self.entryId = entryId
            self.errorCode = errorCode
            self.errorMessage = errorMessage
        }
    }

}

extension IoTSiteWiseClientTypes.BatchGetAssetPropertyAggregatesErrorInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode
        case errorTimestamp
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = self.errorCode {
            try encodeContainer.encode(errorCode.rawValue, forKey: .errorCode)
        }
        if let errorTimestamp = self.errorTimestamp {
            try encodeContainer.encodeTimestamp(errorTimestamp, format: .epochSeconds, forKey: .errorTimestamp)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.BatchGetAssetPropertyAggregatesErrorCode.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .errorTimestamp)
        errorTimestamp = errorTimestampDecoded
    }
}

extension IoTSiteWiseClientTypes {
    /// Contains the error code and the timestamp for an asset property aggregate entry that is associated with the [BatchGetAssetPropertyAggregates](https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_BatchGetAssetPropertyAggregates.html) API.
    public struct BatchGetAssetPropertyAggregatesErrorInfo: Swift.Equatable {
        /// The error code.
        /// This member is required.
        public var errorCode: IoTSiteWiseClientTypes.BatchGetAssetPropertyAggregatesErrorCode?
        /// The date the error occurred, in Unix epoch time.
        /// This member is required.
        public var errorTimestamp: ClientRuntime.Date?

        public init(
            errorCode: IoTSiteWiseClientTypes.BatchGetAssetPropertyAggregatesErrorCode? = nil,
            errorTimestamp: ClientRuntime.Date? = nil
        )
        {
            self.errorCode = errorCode
            self.errorTimestamp = errorTimestamp
        }
    }

}

extension BatchGetAssetPropertyAggregatesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entries
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let entries = entries {
            var entriesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .entries)
            for batchgetassetpropertyaggregatesentry0 in entries {
                try entriesContainer.encode(batchgetassetpropertyaggregatesentry0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension BatchGetAssetPropertyAggregatesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/properties/batch/aggregates"
    }
}

public struct BatchGetAssetPropertyAggregatesInput: Swift.Equatable {
    /// The list of asset property aggregate entries for the batch get request. You can specify up to 16 entries per request.
    /// This member is required.
    public var entries: [IoTSiteWiseClientTypes.BatchGetAssetPropertyAggregatesEntry]?
    /// The maximum number of results to return for each paginated request. A result set is returned in the two cases, whichever occurs first.
    ///
    /// * The size of the result set is equal to 1 MB.
    ///
    /// * The number of data points in the result set is equal to the value of maxResults. The maximum value of maxResults is 4000.
    public var maxResults: Swift.Int?
    /// The token to be used for the next set of paginated results.
    public var nextToken: Swift.String?

    public init(
        entries: [IoTSiteWiseClientTypes.BatchGetAssetPropertyAggregatesEntry]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.entries = entries
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct BatchGetAssetPropertyAggregatesInputBody: Swift.Equatable {
    let entries: [IoTSiteWiseClientTypes.BatchGetAssetPropertyAggregatesEntry]?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension BatchGetAssetPropertyAggregatesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entries
        case maxResults
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entriesContainer = try containerValues.decodeIfPresent([IoTSiteWiseClientTypes.BatchGetAssetPropertyAggregatesEntry?].self, forKey: .entries)
        var entriesDecoded0:[IoTSiteWiseClientTypes.BatchGetAssetPropertyAggregatesEntry]? = nil
        if let entriesContainer = entriesContainer {
            entriesDecoded0 = [IoTSiteWiseClientTypes.BatchGetAssetPropertyAggregatesEntry]()
            for structure0 in entriesContainer {
                if let structure0 = structure0 {
                    entriesDecoded0?.append(structure0)
                }
            }
        }
        entries = entriesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension BatchGetAssetPropertyAggregatesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: BatchGetAssetPropertyAggregatesOutputBody = try responseDecoder.decode(responseBody: data)
            self.errorEntries = output.errorEntries
            self.nextToken = output.nextToken
            self.skippedEntries = output.skippedEntries
            self.successEntries = output.successEntries
        } else {
            self.errorEntries = nil
            self.nextToken = nil
            self.skippedEntries = nil
            self.successEntries = nil
        }
    }
}

public struct BatchGetAssetPropertyAggregatesOutput: Swift.Equatable {
    /// A list of the errors (if any) associated with the batch request. Each error entry contains the entryId of the entry that failed.
    /// This member is required.
    public var errorEntries: [IoTSiteWiseClientTypes.BatchGetAssetPropertyAggregatesErrorEntry]?
    /// The token for the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?
    /// A list of entries that were not processed by this batch request. because these entries had been completely processed by previous paginated requests. Each skipped entry contains the entryId of the entry that skipped.
    /// This member is required.
    public var skippedEntries: [IoTSiteWiseClientTypes.BatchGetAssetPropertyAggregatesSkippedEntry]?
    /// A list of entries that were processed successfully by this batch request. Each success entry contains the entryId of the entry that succeeded and the latest query result.
    /// This member is required.
    public var successEntries: [IoTSiteWiseClientTypes.BatchGetAssetPropertyAggregatesSuccessEntry]?

    public init(
        errorEntries: [IoTSiteWiseClientTypes.BatchGetAssetPropertyAggregatesErrorEntry]? = nil,
        nextToken: Swift.String? = nil,
        skippedEntries: [IoTSiteWiseClientTypes.BatchGetAssetPropertyAggregatesSkippedEntry]? = nil,
        successEntries: [IoTSiteWiseClientTypes.BatchGetAssetPropertyAggregatesSuccessEntry]? = nil
    )
    {
        self.errorEntries = errorEntries
        self.nextToken = nextToken
        self.skippedEntries = skippedEntries
        self.successEntries = successEntries
    }
}

struct BatchGetAssetPropertyAggregatesOutputBody: Swift.Equatable {
    let errorEntries: [IoTSiteWiseClientTypes.BatchGetAssetPropertyAggregatesErrorEntry]?
    let successEntries: [IoTSiteWiseClientTypes.BatchGetAssetPropertyAggregatesSuccessEntry]?
    let skippedEntries: [IoTSiteWiseClientTypes.BatchGetAssetPropertyAggregatesSkippedEntry]?
    let nextToken: Swift.String?
}

extension BatchGetAssetPropertyAggregatesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorEntries
        case nextToken
        case skippedEntries
        case successEntries
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorEntriesContainer = try containerValues.decodeIfPresent([IoTSiteWiseClientTypes.BatchGetAssetPropertyAggregatesErrorEntry?].self, forKey: .errorEntries)
        var errorEntriesDecoded0:[IoTSiteWiseClientTypes.BatchGetAssetPropertyAggregatesErrorEntry]? = nil
        if let errorEntriesContainer = errorEntriesContainer {
            errorEntriesDecoded0 = [IoTSiteWiseClientTypes.BatchGetAssetPropertyAggregatesErrorEntry]()
            for structure0 in errorEntriesContainer {
                if let structure0 = structure0 {
                    errorEntriesDecoded0?.append(structure0)
                }
            }
        }
        errorEntries = errorEntriesDecoded0
        let successEntriesContainer = try containerValues.decodeIfPresent([IoTSiteWiseClientTypes.BatchGetAssetPropertyAggregatesSuccessEntry?].self, forKey: .successEntries)
        var successEntriesDecoded0:[IoTSiteWiseClientTypes.BatchGetAssetPropertyAggregatesSuccessEntry]? = nil
        if let successEntriesContainer = successEntriesContainer {
            successEntriesDecoded0 = [IoTSiteWiseClientTypes.BatchGetAssetPropertyAggregatesSuccessEntry]()
            for structure0 in successEntriesContainer {
                if let structure0 = structure0 {
                    successEntriesDecoded0?.append(structure0)
                }
            }
        }
        successEntries = successEntriesDecoded0
        let skippedEntriesContainer = try containerValues.decodeIfPresent([IoTSiteWiseClientTypes.BatchGetAssetPropertyAggregatesSkippedEntry?].self, forKey: .skippedEntries)
        var skippedEntriesDecoded0:[IoTSiteWiseClientTypes.BatchGetAssetPropertyAggregatesSkippedEntry]? = nil
        if let skippedEntriesContainer = skippedEntriesContainer {
            skippedEntriesDecoded0 = [IoTSiteWiseClientTypes.BatchGetAssetPropertyAggregatesSkippedEntry]()
            for structure0 in skippedEntriesContainer {
                if let structure0 = structure0 {
                    skippedEntriesDecoded0?.append(structure0)
                }
            }
        }
        skippedEntries = skippedEntriesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum BatchGetAssetPropertyAggregatesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension IoTSiteWiseClientTypes.BatchGetAssetPropertyAggregatesSkippedEntry: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case completionStatus
        case entryId
        case errorInfo
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let completionStatus = self.completionStatus {
            try encodeContainer.encode(completionStatus.rawValue, forKey: .completionStatus)
        }
        if let entryId = self.entryId {
            try encodeContainer.encode(entryId, forKey: .entryId)
        }
        if let errorInfo = self.errorInfo {
            try encodeContainer.encode(errorInfo, forKey: .errorInfo)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entryId)
        entryId = entryIdDecoded
        let completionStatusDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.BatchEntryCompletionStatus.self, forKey: .completionStatus)
        completionStatus = completionStatusDecoded
        let errorInfoDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.BatchGetAssetPropertyAggregatesErrorInfo.self, forKey: .errorInfo)
        errorInfo = errorInfoDecoded
    }
}

extension IoTSiteWiseClientTypes {
    /// Contains information for an entry that has been processed by the previous [BatchGetAssetPropertyAggregates](https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_BatchGetAssetPropertyAggregates.html) request.
    public struct BatchGetAssetPropertyAggregatesSkippedEntry: Swift.Equatable {
        /// The completion status of each entry that is associated with the [BatchGetAssetPropertyAggregates](https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_BatchGetAssetPropertyAggregates.html) API.
        /// This member is required.
        public var completionStatus: IoTSiteWiseClientTypes.BatchEntryCompletionStatus?
        /// The ID of the entry.
        /// This member is required.
        public var entryId: Swift.String?
        /// The error information, such as the error code and the timestamp.
        public var errorInfo: IoTSiteWiseClientTypes.BatchGetAssetPropertyAggregatesErrorInfo?

        public init(
            completionStatus: IoTSiteWiseClientTypes.BatchEntryCompletionStatus? = nil,
            entryId: Swift.String? = nil,
            errorInfo: IoTSiteWiseClientTypes.BatchGetAssetPropertyAggregatesErrorInfo? = nil
        )
        {
            self.completionStatus = completionStatus
            self.entryId = entryId
            self.errorInfo = errorInfo
        }
    }

}

extension IoTSiteWiseClientTypes.BatchGetAssetPropertyAggregatesSuccessEntry: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aggregatedValues
        case entryId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aggregatedValues = aggregatedValues {
            var aggregatedValuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .aggregatedValues)
            for aggregatedvalue0 in aggregatedValues {
                try aggregatedValuesContainer.encode(aggregatedvalue0)
            }
        }
        if let entryId = self.entryId {
            try encodeContainer.encode(entryId, forKey: .entryId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entryId)
        entryId = entryIdDecoded
        let aggregatedValuesContainer = try containerValues.decodeIfPresent([IoTSiteWiseClientTypes.AggregatedValue?].self, forKey: .aggregatedValues)
        var aggregatedValuesDecoded0:[IoTSiteWiseClientTypes.AggregatedValue]? = nil
        if let aggregatedValuesContainer = aggregatedValuesContainer {
            aggregatedValuesDecoded0 = [IoTSiteWiseClientTypes.AggregatedValue]()
            for structure0 in aggregatedValuesContainer {
                if let structure0 = structure0 {
                    aggregatedValuesDecoded0?.append(structure0)
                }
            }
        }
        aggregatedValues = aggregatedValuesDecoded0
    }
}

extension IoTSiteWiseClientTypes {
    /// Contains success information for an entry that is associated with the [BatchGetAssetPropertyAggregates](https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_BatchGetAssetPropertyAggregates.html) API.
    public struct BatchGetAssetPropertyAggregatesSuccessEntry: Swift.Equatable {
        /// The requested aggregated asset property values (for example, average, minimum, and maximum).
        /// This member is required.
        public var aggregatedValues: [IoTSiteWiseClientTypes.AggregatedValue]?
        /// The ID of the entry.
        /// This member is required.
        public var entryId: Swift.String?

        public init(
            aggregatedValues: [IoTSiteWiseClientTypes.AggregatedValue]? = nil,
            entryId: Swift.String? = nil
        )
        {
            self.aggregatedValues = aggregatedValues
            self.entryId = entryId
        }
    }

}

extension IoTSiteWiseClientTypes.BatchGetAssetPropertyValueEntry: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assetId
        case entryId
        case propertyAlias
        case propertyId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assetId = self.assetId {
            try encodeContainer.encode(assetId, forKey: .assetId)
        }
        if let entryId = self.entryId {
            try encodeContainer.encode(entryId, forKey: .entryId)
        }
        if let propertyAlias = self.propertyAlias {
            try encodeContainer.encode(propertyAlias, forKey: .propertyAlias)
        }
        if let propertyId = self.propertyId {
            try encodeContainer.encode(propertyId, forKey: .propertyId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entryId)
        entryId = entryIdDecoded
        let assetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assetId)
        assetId = assetIdDecoded
        let propertyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .propertyId)
        propertyId = propertyIdDecoded
        let propertyAliasDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .propertyAlias)
        propertyAlias = propertyAliasDecoded
    }
}

extension IoTSiteWiseClientTypes {
    /// Contains information for an asset property value entry that is associated with the [BatchGetAssetPropertyValue](https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_BatchGetAssetPropertyValue.html) API. To identify an asset property, you must specify one of the following:
    ///
    /// * The assetId and propertyId of an asset property.
    ///
    /// * A propertyAlias, which is a data stream alias (for example, /company/windfarm/3/turbine/7/temperature). To define an asset property's alias, see [UpdateAssetProperty](https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_UpdateAssetProperty.html).
    public struct BatchGetAssetPropertyValueEntry: Swift.Equatable {
        /// The ID of the asset in which the asset property was created.
        public var assetId: Swift.String?
        /// The ID of the entry.
        /// This member is required.
        public var entryId: Swift.String?
        /// The alias that identifies the property, such as an OPC-UA server data stream path (for example, /company/windfarm/3/turbine/7/temperature). For more information, see [Mapping industrial data streams to asset properties](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/connect-data-streams.html) in the IoT SiteWise User Guide.
        public var propertyAlias: Swift.String?
        /// The ID of the asset property.
        public var propertyId: Swift.String?

        public init(
            assetId: Swift.String? = nil,
            entryId: Swift.String? = nil,
            propertyAlias: Swift.String? = nil,
            propertyId: Swift.String? = nil
        )
        {
            self.assetId = assetId
            self.entryId = entryId
            self.propertyAlias = propertyAlias
            self.propertyId = propertyId
        }
    }

}

extension IoTSiteWiseClientTypes {
    public enum BatchGetAssetPropertyValueErrorCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case accessdeniedexception
        case invalidrequestexception
        case resourcenotfoundexception
        case sdkUnknown(Swift.String)

        public static var allCases: [BatchGetAssetPropertyValueErrorCode] {
            return [
                .accessdeniedexception,
                .invalidrequestexception,
                .resourcenotfoundexception,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .accessdeniedexception: return "AccessDeniedException"
            case .invalidrequestexception: return "InvalidRequestException"
            case .resourcenotfoundexception: return "ResourceNotFoundException"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = BatchGetAssetPropertyValueErrorCode(rawValue: rawValue) ?? BatchGetAssetPropertyValueErrorCode.sdkUnknown(rawValue)
        }
    }
}

extension IoTSiteWiseClientTypes.BatchGetAssetPropertyValueErrorEntry: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entryId
        case errorCode
        case errorMessage
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let entryId = self.entryId {
            try encodeContainer.encode(entryId, forKey: .entryId)
        }
        if let errorCode = self.errorCode {
            try encodeContainer.encode(errorCode.rawValue, forKey: .errorCode)
        }
        if let errorMessage = self.errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.BatchGetAssetPropertyValueErrorCode.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
        let entryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entryId)
        entryId = entryIdDecoded
    }
}

extension IoTSiteWiseClientTypes {
    /// Contains error information for an asset property value entry that is associated with the [BatchGetAssetPropertyValue](https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_BatchGetAssetPropertyValue.html) API.
    public struct BatchGetAssetPropertyValueErrorEntry: Swift.Equatable {
        /// The ID of the entry.
        /// This member is required.
        public var entryId: Swift.String?
        /// The error code.
        /// This member is required.
        public var errorCode: IoTSiteWiseClientTypes.BatchGetAssetPropertyValueErrorCode?
        /// The associated error message.
        /// This member is required.
        public var errorMessage: Swift.String?

        public init(
            entryId: Swift.String? = nil,
            errorCode: IoTSiteWiseClientTypes.BatchGetAssetPropertyValueErrorCode? = nil,
            errorMessage: Swift.String? = nil
        )
        {
            self.entryId = entryId
            self.errorCode = errorCode
            self.errorMessage = errorMessage
        }
    }

}

extension IoTSiteWiseClientTypes.BatchGetAssetPropertyValueErrorInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode
        case errorTimestamp
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = self.errorCode {
            try encodeContainer.encode(errorCode.rawValue, forKey: .errorCode)
        }
        if let errorTimestamp = self.errorTimestamp {
            try encodeContainer.encodeTimestamp(errorTimestamp, format: .epochSeconds, forKey: .errorTimestamp)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.BatchGetAssetPropertyValueErrorCode.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .errorTimestamp)
        errorTimestamp = errorTimestampDecoded
    }
}

extension IoTSiteWiseClientTypes {
    /// The error information, such as the error code and the timestamp.
    public struct BatchGetAssetPropertyValueErrorInfo: Swift.Equatable {
        /// The error code.
        /// This member is required.
        public var errorCode: IoTSiteWiseClientTypes.BatchGetAssetPropertyValueErrorCode?
        /// The date the error occurred, in Unix epoch time.
        /// This member is required.
        public var errorTimestamp: ClientRuntime.Date?

        public init(
            errorCode: IoTSiteWiseClientTypes.BatchGetAssetPropertyValueErrorCode? = nil,
            errorTimestamp: ClientRuntime.Date? = nil
        )
        {
            self.errorCode = errorCode
            self.errorTimestamp = errorTimestamp
        }
    }

}

extension IoTSiteWiseClientTypes.BatchGetAssetPropertyValueHistoryEntry: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assetId
        case endDate
        case entryId
        case propertyAlias
        case propertyId
        case qualities
        case startDate
        case timeOrdering
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assetId = self.assetId {
            try encodeContainer.encode(assetId, forKey: .assetId)
        }
        if let endDate = self.endDate {
            try encodeContainer.encodeTimestamp(endDate, format: .epochSeconds, forKey: .endDate)
        }
        if let entryId = self.entryId {
            try encodeContainer.encode(entryId, forKey: .entryId)
        }
        if let propertyAlias = self.propertyAlias {
            try encodeContainer.encode(propertyAlias, forKey: .propertyAlias)
        }
        if let propertyId = self.propertyId {
            try encodeContainer.encode(propertyId, forKey: .propertyId)
        }
        if let qualities = qualities {
            var qualitiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .qualities)
            for quality0 in qualities {
                try qualitiesContainer.encode(quality0.rawValue)
            }
        }
        if let startDate = self.startDate {
            try encodeContainer.encodeTimestamp(startDate, format: .epochSeconds, forKey: .startDate)
        }
        if let timeOrdering = self.timeOrdering {
            try encodeContainer.encode(timeOrdering.rawValue, forKey: .timeOrdering)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entryId)
        entryId = entryIdDecoded
        let assetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assetId)
        assetId = assetIdDecoded
        let propertyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .propertyId)
        propertyId = propertyIdDecoded
        let propertyAliasDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .propertyAlias)
        propertyAlias = propertyAliasDecoded
        let startDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startDate)
        startDate = startDateDecoded
        let endDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endDate)
        endDate = endDateDecoded
        let qualitiesContainer = try containerValues.decodeIfPresent([IoTSiteWiseClientTypes.Quality?].self, forKey: .qualities)
        var qualitiesDecoded0:[IoTSiteWiseClientTypes.Quality]? = nil
        if let qualitiesContainer = qualitiesContainer {
            qualitiesDecoded0 = [IoTSiteWiseClientTypes.Quality]()
            for enum0 in qualitiesContainer {
                if let enum0 = enum0 {
                    qualitiesDecoded0?.append(enum0)
                }
            }
        }
        qualities = qualitiesDecoded0
        let timeOrderingDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.TimeOrdering.self, forKey: .timeOrdering)
        timeOrdering = timeOrderingDecoded
    }
}

extension IoTSiteWiseClientTypes {
    /// Contains information for an asset property historical value entry that is associated with the [BatchGetAssetPropertyValueHistory](https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_BatchGetAssetPropertyValue.html) API. To identify an asset property, you must specify one of the following:
    ///
    /// * The assetId and propertyId of an asset property.
    ///
    /// * A propertyAlias, which is a data stream alias (for example, /company/windfarm/3/turbine/7/temperature). To define an asset property's alias, see [UpdateAssetProperty](https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_UpdateAssetProperty.html).
    public struct BatchGetAssetPropertyValueHistoryEntry: Swift.Equatable {
        /// The ID of the asset in which the asset property was created.
        public var assetId: Swift.String?
        /// The inclusive end of the range from which to query historical data, expressed in seconds in Unix epoch time.
        public var endDate: ClientRuntime.Date?
        /// The ID of the entry.
        /// This member is required.
        public var entryId: Swift.String?
        /// The alias that identifies the property, such as an OPC-UA server data stream path (for example, /company/windfarm/3/turbine/7/temperature). For more information, see [Mapping industrial data streams to asset properties](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/connect-data-streams.html) in the IoT SiteWise User Guide.
        public var propertyAlias: Swift.String?
        /// The ID of the asset property.
        public var propertyId: Swift.String?
        /// The quality by which to filter asset data.
        public var qualities: [IoTSiteWiseClientTypes.Quality]?
        /// The exclusive start of the range from which to query historical data, expressed in seconds in Unix epoch time.
        public var startDate: ClientRuntime.Date?
        /// The chronological sorting order of the requested information. Default: ASCENDING
        public var timeOrdering: IoTSiteWiseClientTypes.TimeOrdering?

        public init(
            assetId: Swift.String? = nil,
            endDate: ClientRuntime.Date? = nil,
            entryId: Swift.String? = nil,
            propertyAlias: Swift.String? = nil,
            propertyId: Swift.String? = nil,
            qualities: [IoTSiteWiseClientTypes.Quality]? = nil,
            startDate: ClientRuntime.Date? = nil,
            timeOrdering: IoTSiteWiseClientTypes.TimeOrdering? = nil
        )
        {
            self.assetId = assetId
            self.endDate = endDate
            self.entryId = entryId
            self.propertyAlias = propertyAlias
            self.propertyId = propertyId
            self.qualities = qualities
            self.startDate = startDate
            self.timeOrdering = timeOrdering
        }
    }

}

extension IoTSiteWiseClientTypes {
    public enum BatchGetAssetPropertyValueHistoryErrorCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case accessdeniedexception
        case invalidrequestexception
        case resourcenotfoundexception
        case sdkUnknown(Swift.String)

        public static var allCases: [BatchGetAssetPropertyValueHistoryErrorCode] {
            return [
                .accessdeniedexception,
                .invalidrequestexception,
                .resourcenotfoundexception,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .accessdeniedexception: return "AccessDeniedException"
            case .invalidrequestexception: return "InvalidRequestException"
            case .resourcenotfoundexception: return "ResourceNotFoundException"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = BatchGetAssetPropertyValueHistoryErrorCode(rawValue: rawValue) ?? BatchGetAssetPropertyValueHistoryErrorCode.sdkUnknown(rawValue)
        }
    }
}

extension IoTSiteWiseClientTypes.BatchGetAssetPropertyValueHistoryErrorEntry: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entryId
        case errorCode
        case errorMessage
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let entryId = self.entryId {
            try encodeContainer.encode(entryId, forKey: .entryId)
        }
        if let errorCode = self.errorCode {
            try encodeContainer.encode(errorCode.rawValue, forKey: .errorCode)
        }
        if let errorMessage = self.errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.BatchGetAssetPropertyValueHistoryErrorCode.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
        let entryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entryId)
        entryId = entryIdDecoded
    }
}

extension IoTSiteWiseClientTypes {
    /// A list of the errors (if any) associated with the batch request. Each error entry contains the entryId of the entry that failed.
    public struct BatchGetAssetPropertyValueHistoryErrorEntry: Swift.Equatable {
        /// The ID of the entry.
        /// This member is required.
        public var entryId: Swift.String?
        /// The error code.
        /// This member is required.
        public var errorCode: IoTSiteWiseClientTypes.BatchGetAssetPropertyValueHistoryErrorCode?
        /// The associated error message.
        /// This member is required.
        public var errorMessage: Swift.String?

        public init(
            entryId: Swift.String? = nil,
            errorCode: IoTSiteWiseClientTypes.BatchGetAssetPropertyValueHistoryErrorCode? = nil,
            errorMessage: Swift.String? = nil
        )
        {
            self.entryId = entryId
            self.errorCode = errorCode
            self.errorMessage = errorMessage
        }
    }

}

extension IoTSiteWiseClientTypes.BatchGetAssetPropertyValueHistoryErrorInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode
        case errorTimestamp
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = self.errorCode {
            try encodeContainer.encode(errorCode.rawValue, forKey: .errorCode)
        }
        if let errorTimestamp = self.errorTimestamp {
            try encodeContainer.encodeTimestamp(errorTimestamp, format: .epochSeconds, forKey: .errorTimestamp)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.BatchGetAssetPropertyValueHistoryErrorCode.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .errorTimestamp)
        errorTimestamp = errorTimestampDecoded
    }
}

extension IoTSiteWiseClientTypes {
    /// The error information, such as the error code and the timestamp.
    public struct BatchGetAssetPropertyValueHistoryErrorInfo: Swift.Equatable {
        /// The error code.
        /// This member is required.
        public var errorCode: IoTSiteWiseClientTypes.BatchGetAssetPropertyValueHistoryErrorCode?
        /// The date the error occurred, in Unix epoch time.
        /// This member is required.
        public var errorTimestamp: ClientRuntime.Date?

        public init(
            errorCode: IoTSiteWiseClientTypes.BatchGetAssetPropertyValueHistoryErrorCode? = nil,
            errorTimestamp: ClientRuntime.Date? = nil
        )
        {
            self.errorCode = errorCode
            self.errorTimestamp = errorTimestamp
        }
    }

}

extension BatchGetAssetPropertyValueHistoryInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entries
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let entries = entries {
            var entriesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .entries)
            for batchgetassetpropertyvaluehistoryentry0 in entries {
                try entriesContainer.encode(batchgetassetpropertyvaluehistoryentry0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension BatchGetAssetPropertyValueHistoryInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/properties/batch/history"
    }
}

public struct BatchGetAssetPropertyValueHistoryInput: Swift.Equatable {
    /// The list of asset property historical value entries for the batch get request. You can specify up to 16 entries per request.
    /// This member is required.
    public var entries: [IoTSiteWiseClientTypes.BatchGetAssetPropertyValueHistoryEntry]?
    /// The maximum number of results to return for each paginated request. A result set is returned in the two cases, whichever occurs first.
    ///
    /// * The size of the result set is equal to 4 MB.
    ///
    /// * The number of data points in the result set is equal to the value of maxResults. The maximum value of maxResults is 20000.
    public var maxResults: Swift.Int?
    /// The token to be used for the next set of paginated results.
    public var nextToken: Swift.String?

    public init(
        entries: [IoTSiteWiseClientTypes.BatchGetAssetPropertyValueHistoryEntry]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.entries = entries
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct BatchGetAssetPropertyValueHistoryInputBody: Swift.Equatable {
    let entries: [IoTSiteWiseClientTypes.BatchGetAssetPropertyValueHistoryEntry]?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension BatchGetAssetPropertyValueHistoryInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entries
        case maxResults
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entriesContainer = try containerValues.decodeIfPresent([IoTSiteWiseClientTypes.BatchGetAssetPropertyValueHistoryEntry?].self, forKey: .entries)
        var entriesDecoded0:[IoTSiteWiseClientTypes.BatchGetAssetPropertyValueHistoryEntry]? = nil
        if let entriesContainer = entriesContainer {
            entriesDecoded0 = [IoTSiteWiseClientTypes.BatchGetAssetPropertyValueHistoryEntry]()
            for structure0 in entriesContainer {
                if let structure0 = structure0 {
                    entriesDecoded0?.append(structure0)
                }
            }
        }
        entries = entriesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension BatchGetAssetPropertyValueHistoryOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: BatchGetAssetPropertyValueHistoryOutputBody = try responseDecoder.decode(responseBody: data)
            self.errorEntries = output.errorEntries
            self.nextToken = output.nextToken
            self.skippedEntries = output.skippedEntries
            self.successEntries = output.successEntries
        } else {
            self.errorEntries = nil
            self.nextToken = nil
            self.skippedEntries = nil
            self.successEntries = nil
        }
    }
}

public struct BatchGetAssetPropertyValueHistoryOutput: Swift.Equatable {
    /// A list of the errors (if any) associated with the batch request. Each error entry contains the entryId of the entry that failed.
    /// This member is required.
    public var errorEntries: [IoTSiteWiseClientTypes.BatchGetAssetPropertyValueHistoryErrorEntry]?
    /// The token for the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?
    /// A list of entries that were not processed by this batch request. because these entries had been completely processed by previous paginated requests. Each skipped entry contains the entryId of the entry that skipped.
    /// This member is required.
    public var skippedEntries: [IoTSiteWiseClientTypes.BatchGetAssetPropertyValueHistorySkippedEntry]?
    /// A list of entries that were processed successfully by this batch request. Each success entry contains the entryId of the entry that succeeded and the latest query result.
    /// This member is required.
    public var successEntries: [IoTSiteWiseClientTypes.BatchGetAssetPropertyValueHistorySuccessEntry]?

    public init(
        errorEntries: [IoTSiteWiseClientTypes.BatchGetAssetPropertyValueHistoryErrorEntry]? = nil,
        nextToken: Swift.String? = nil,
        skippedEntries: [IoTSiteWiseClientTypes.BatchGetAssetPropertyValueHistorySkippedEntry]? = nil,
        successEntries: [IoTSiteWiseClientTypes.BatchGetAssetPropertyValueHistorySuccessEntry]? = nil
    )
    {
        self.errorEntries = errorEntries
        self.nextToken = nextToken
        self.skippedEntries = skippedEntries
        self.successEntries = successEntries
    }
}

struct BatchGetAssetPropertyValueHistoryOutputBody: Swift.Equatable {
    let errorEntries: [IoTSiteWiseClientTypes.BatchGetAssetPropertyValueHistoryErrorEntry]?
    let successEntries: [IoTSiteWiseClientTypes.BatchGetAssetPropertyValueHistorySuccessEntry]?
    let skippedEntries: [IoTSiteWiseClientTypes.BatchGetAssetPropertyValueHistorySkippedEntry]?
    let nextToken: Swift.String?
}

extension BatchGetAssetPropertyValueHistoryOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorEntries
        case nextToken
        case skippedEntries
        case successEntries
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorEntriesContainer = try containerValues.decodeIfPresent([IoTSiteWiseClientTypes.BatchGetAssetPropertyValueHistoryErrorEntry?].self, forKey: .errorEntries)
        var errorEntriesDecoded0:[IoTSiteWiseClientTypes.BatchGetAssetPropertyValueHistoryErrorEntry]? = nil
        if let errorEntriesContainer = errorEntriesContainer {
            errorEntriesDecoded0 = [IoTSiteWiseClientTypes.BatchGetAssetPropertyValueHistoryErrorEntry]()
            for structure0 in errorEntriesContainer {
                if let structure0 = structure0 {
                    errorEntriesDecoded0?.append(structure0)
                }
            }
        }
        errorEntries = errorEntriesDecoded0
        let successEntriesContainer = try containerValues.decodeIfPresent([IoTSiteWiseClientTypes.BatchGetAssetPropertyValueHistorySuccessEntry?].self, forKey: .successEntries)
        var successEntriesDecoded0:[IoTSiteWiseClientTypes.BatchGetAssetPropertyValueHistorySuccessEntry]? = nil
        if let successEntriesContainer = successEntriesContainer {
            successEntriesDecoded0 = [IoTSiteWiseClientTypes.BatchGetAssetPropertyValueHistorySuccessEntry]()
            for structure0 in successEntriesContainer {
                if let structure0 = structure0 {
                    successEntriesDecoded0?.append(structure0)
                }
            }
        }
        successEntries = successEntriesDecoded0
        let skippedEntriesContainer = try containerValues.decodeIfPresent([IoTSiteWiseClientTypes.BatchGetAssetPropertyValueHistorySkippedEntry?].self, forKey: .skippedEntries)
        var skippedEntriesDecoded0:[IoTSiteWiseClientTypes.BatchGetAssetPropertyValueHistorySkippedEntry]? = nil
        if let skippedEntriesContainer = skippedEntriesContainer {
            skippedEntriesDecoded0 = [IoTSiteWiseClientTypes.BatchGetAssetPropertyValueHistorySkippedEntry]()
            for structure0 in skippedEntriesContainer {
                if let structure0 = structure0 {
                    skippedEntriesDecoded0?.append(structure0)
                }
            }
        }
        skippedEntries = skippedEntriesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum BatchGetAssetPropertyValueHistoryOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension IoTSiteWiseClientTypes.BatchGetAssetPropertyValueHistorySkippedEntry: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case completionStatus
        case entryId
        case errorInfo
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let completionStatus = self.completionStatus {
            try encodeContainer.encode(completionStatus.rawValue, forKey: .completionStatus)
        }
        if let entryId = self.entryId {
            try encodeContainer.encode(entryId, forKey: .entryId)
        }
        if let errorInfo = self.errorInfo {
            try encodeContainer.encode(errorInfo, forKey: .errorInfo)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entryId)
        entryId = entryIdDecoded
        let completionStatusDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.BatchEntryCompletionStatus.self, forKey: .completionStatus)
        completionStatus = completionStatusDecoded
        let errorInfoDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.BatchGetAssetPropertyValueHistoryErrorInfo.self, forKey: .errorInfo)
        errorInfo = errorInfoDecoded
    }
}

extension IoTSiteWiseClientTypes {
    /// Contains information for an entry that has been processed by the previous [BatchGetAssetPropertyValueHistory](https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_BatchGetAssetPropertyValue.html) request.
    public struct BatchGetAssetPropertyValueHistorySkippedEntry: Swift.Equatable {
        /// The completion status of each entry that is associated with the [BatchGetAssetPropertyValueHistory](https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_BatchGetAssetPropertyValueHistory.html) API.
        /// This member is required.
        public var completionStatus: IoTSiteWiseClientTypes.BatchEntryCompletionStatus?
        /// The ID of the entry.
        /// This member is required.
        public var entryId: Swift.String?
        /// The error information, such as the error code and the timestamp.
        public var errorInfo: IoTSiteWiseClientTypes.BatchGetAssetPropertyValueHistoryErrorInfo?

        public init(
            completionStatus: IoTSiteWiseClientTypes.BatchEntryCompletionStatus? = nil,
            entryId: Swift.String? = nil,
            errorInfo: IoTSiteWiseClientTypes.BatchGetAssetPropertyValueHistoryErrorInfo? = nil
        )
        {
            self.completionStatus = completionStatus
            self.entryId = entryId
            self.errorInfo = errorInfo
        }
    }

}

extension IoTSiteWiseClientTypes.BatchGetAssetPropertyValueHistorySuccessEntry: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assetPropertyValueHistory
        case entryId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assetPropertyValueHistory = assetPropertyValueHistory {
            var assetPropertyValueHistoryContainer = encodeContainer.nestedUnkeyedContainer(forKey: .assetPropertyValueHistory)
            for assetpropertyvalue0 in assetPropertyValueHistory {
                try assetPropertyValueHistoryContainer.encode(assetpropertyvalue0)
            }
        }
        if let entryId = self.entryId {
            try encodeContainer.encode(entryId, forKey: .entryId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entryId)
        entryId = entryIdDecoded
        let assetPropertyValueHistoryContainer = try containerValues.decodeIfPresent([IoTSiteWiseClientTypes.AssetPropertyValue?].self, forKey: .assetPropertyValueHistory)
        var assetPropertyValueHistoryDecoded0:[IoTSiteWiseClientTypes.AssetPropertyValue]? = nil
        if let assetPropertyValueHistoryContainer = assetPropertyValueHistoryContainer {
            assetPropertyValueHistoryDecoded0 = [IoTSiteWiseClientTypes.AssetPropertyValue]()
            for structure0 in assetPropertyValueHistoryContainer {
                if let structure0 = structure0 {
                    assetPropertyValueHistoryDecoded0?.append(structure0)
                }
            }
        }
        assetPropertyValueHistory = assetPropertyValueHistoryDecoded0
    }
}

extension IoTSiteWiseClientTypes {
    /// Contains success information for an entry that is associated with the [BatchGetAssetPropertyValueHistory](https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_BatchGetAssetPropertyValue.html) API.
    public struct BatchGetAssetPropertyValueHistorySuccessEntry: Swift.Equatable {
        /// The requested historical values for the specified asset property.
        /// This member is required.
        public var assetPropertyValueHistory: [IoTSiteWiseClientTypes.AssetPropertyValue]?
        /// The ID of the entry.
        /// This member is required.
        public var entryId: Swift.String?

        public init(
            assetPropertyValueHistory: [IoTSiteWiseClientTypes.AssetPropertyValue]? = nil,
            entryId: Swift.String? = nil
        )
        {
            self.assetPropertyValueHistory = assetPropertyValueHistory
            self.entryId = entryId
        }
    }

}

extension BatchGetAssetPropertyValueInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entries
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let entries = entries {
            var entriesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .entries)
            for batchgetassetpropertyvalueentry0 in entries {
                try entriesContainer.encode(batchgetassetpropertyvalueentry0)
            }
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension BatchGetAssetPropertyValueInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/properties/batch/latest"
    }
}

public struct BatchGetAssetPropertyValueInput: Swift.Equatable {
    /// The list of asset property value entries for the batch get request. You can specify up to 128 entries per request.
    /// This member is required.
    public var entries: [IoTSiteWiseClientTypes.BatchGetAssetPropertyValueEntry]?
    /// The token to be used for the next set of paginated results.
    public var nextToken: Swift.String?

    public init(
        entries: [IoTSiteWiseClientTypes.BatchGetAssetPropertyValueEntry]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.entries = entries
        self.nextToken = nextToken
    }
}

struct BatchGetAssetPropertyValueInputBody: Swift.Equatable {
    let entries: [IoTSiteWiseClientTypes.BatchGetAssetPropertyValueEntry]?
    let nextToken: Swift.String?
}

extension BatchGetAssetPropertyValueInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entries
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entriesContainer = try containerValues.decodeIfPresent([IoTSiteWiseClientTypes.BatchGetAssetPropertyValueEntry?].self, forKey: .entries)
        var entriesDecoded0:[IoTSiteWiseClientTypes.BatchGetAssetPropertyValueEntry]? = nil
        if let entriesContainer = entriesContainer {
            entriesDecoded0 = [IoTSiteWiseClientTypes.BatchGetAssetPropertyValueEntry]()
            for structure0 in entriesContainer {
                if let structure0 = structure0 {
                    entriesDecoded0?.append(structure0)
                }
            }
        }
        entries = entriesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension BatchGetAssetPropertyValueOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: BatchGetAssetPropertyValueOutputBody = try responseDecoder.decode(responseBody: data)
            self.errorEntries = output.errorEntries
            self.nextToken = output.nextToken
            self.skippedEntries = output.skippedEntries
            self.successEntries = output.successEntries
        } else {
            self.errorEntries = nil
            self.nextToken = nil
            self.skippedEntries = nil
            self.successEntries = nil
        }
    }
}

public struct BatchGetAssetPropertyValueOutput: Swift.Equatable {
    /// A list of the errors (if any) associated with the batch request. Each error entry contains the entryId of the entry that failed.
    /// This member is required.
    public var errorEntries: [IoTSiteWiseClientTypes.BatchGetAssetPropertyValueErrorEntry]?
    /// The token for the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?
    /// A list of entries that were not processed by this batch request. because these entries had been completely processed by previous paginated requests. Each skipped entry contains the entryId of the entry that skipped.
    /// This member is required.
    public var skippedEntries: [IoTSiteWiseClientTypes.BatchGetAssetPropertyValueSkippedEntry]?
    /// A list of entries that were processed successfully by this batch request. Each success entry contains the entryId of the entry that succeeded and the latest query result.
    /// This member is required.
    public var successEntries: [IoTSiteWiseClientTypes.BatchGetAssetPropertyValueSuccessEntry]?

    public init(
        errorEntries: [IoTSiteWiseClientTypes.BatchGetAssetPropertyValueErrorEntry]? = nil,
        nextToken: Swift.String? = nil,
        skippedEntries: [IoTSiteWiseClientTypes.BatchGetAssetPropertyValueSkippedEntry]? = nil,
        successEntries: [IoTSiteWiseClientTypes.BatchGetAssetPropertyValueSuccessEntry]? = nil
    )
    {
        self.errorEntries = errorEntries
        self.nextToken = nextToken
        self.skippedEntries = skippedEntries
        self.successEntries = successEntries
    }
}

struct BatchGetAssetPropertyValueOutputBody: Swift.Equatable {
    let errorEntries: [IoTSiteWiseClientTypes.BatchGetAssetPropertyValueErrorEntry]?
    let successEntries: [IoTSiteWiseClientTypes.BatchGetAssetPropertyValueSuccessEntry]?
    let skippedEntries: [IoTSiteWiseClientTypes.BatchGetAssetPropertyValueSkippedEntry]?
    let nextToken: Swift.String?
}

extension BatchGetAssetPropertyValueOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorEntries
        case nextToken
        case skippedEntries
        case successEntries
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorEntriesContainer = try containerValues.decodeIfPresent([IoTSiteWiseClientTypes.BatchGetAssetPropertyValueErrorEntry?].self, forKey: .errorEntries)
        var errorEntriesDecoded0:[IoTSiteWiseClientTypes.BatchGetAssetPropertyValueErrorEntry]? = nil
        if let errorEntriesContainer = errorEntriesContainer {
            errorEntriesDecoded0 = [IoTSiteWiseClientTypes.BatchGetAssetPropertyValueErrorEntry]()
            for structure0 in errorEntriesContainer {
                if let structure0 = structure0 {
                    errorEntriesDecoded0?.append(structure0)
                }
            }
        }
        errorEntries = errorEntriesDecoded0
        let successEntriesContainer = try containerValues.decodeIfPresent([IoTSiteWiseClientTypes.BatchGetAssetPropertyValueSuccessEntry?].self, forKey: .successEntries)
        var successEntriesDecoded0:[IoTSiteWiseClientTypes.BatchGetAssetPropertyValueSuccessEntry]? = nil
        if let successEntriesContainer = successEntriesContainer {
            successEntriesDecoded0 = [IoTSiteWiseClientTypes.BatchGetAssetPropertyValueSuccessEntry]()
            for structure0 in successEntriesContainer {
                if let structure0 = structure0 {
                    successEntriesDecoded0?.append(structure0)
                }
            }
        }
        successEntries = successEntriesDecoded0
        let skippedEntriesContainer = try containerValues.decodeIfPresent([IoTSiteWiseClientTypes.BatchGetAssetPropertyValueSkippedEntry?].self, forKey: .skippedEntries)
        var skippedEntriesDecoded0:[IoTSiteWiseClientTypes.BatchGetAssetPropertyValueSkippedEntry]? = nil
        if let skippedEntriesContainer = skippedEntriesContainer {
            skippedEntriesDecoded0 = [IoTSiteWiseClientTypes.BatchGetAssetPropertyValueSkippedEntry]()
            for structure0 in skippedEntriesContainer {
                if let structure0 = structure0 {
                    skippedEntriesDecoded0?.append(structure0)
                }
            }
        }
        skippedEntries = skippedEntriesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum BatchGetAssetPropertyValueOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension IoTSiteWiseClientTypes.BatchGetAssetPropertyValueSkippedEntry: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case completionStatus
        case entryId
        case errorInfo
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let completionStatus = self.completionStatus {
            try encodeContainer.encode(completionStatus.rawValue, forKey: .completionStatus)
        }
        if let entryId = self.entryId {
            try encodeContainer.encode(entryId, forKey: .entryId)
        }
        if let errorInfo = self.errorInfo {
            try encodeContainer.encode(errorInfo, forKey: .errorInfo)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entryId)
        entryId = entryIdDecoded
        let completionStatusDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.BatchEntryCompletionStatus.self, forKey: .completionStatus)
        completionStatus = completionStatusDecoded
        let errorInfoDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.BatchGetAssetPropertyValueErrorInfo.self, forKey: .errorInfo)
        errorInfo = errorInfoDecoded
    }
}

extension IoTSiteWiseClientTypes {
    /// Contains information for an entry that has been processed by the previous [BatchGetAssetPropertyValue](https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_BatchGetAssetPropertyValue.html) request.
    public struct BatchGetAssetPropertyValueSkippedEntry: Swift.Equatable {
        /// The completion status of each entry that is associated with the [BatchGetAssetPropertyValue](https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_BatchGetAssetPropertyValue.html) request.
        /// This member is required.
        public var completionStatus: IoTSiteWiseClientTypes.BatchEntryCompletionStatus?
        /// The ID of the entry.
        /// This member is required.
        public var entryId: Swift.String?
        /// The error information, such as the error code and the timestamp.
        public var errorInfo: IoTSiteWiseClientTypes.BatchGetAssetPropertyValueErrorInfo?

        public init(
            completionStatus: IoTSiteWiseClientTypes.BatchEntryCompletionStatus? = nil,
            entryId: Swift.String? = nil,
            errorInfo: IoTSiteWiseClientTypes.BatchGetAssetPropertyValueErrorInfo? = nil
        )
        {
            self.completionStatus = completionStatus
            self.entryId = entryId
            self.errorInfo = errorInfo
        }
    }

}

extension IoTSiteWiseClientTypes.BatchGetAssetPropertyValueSuccessEntry: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assetPropertyValue
        case entryId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assetPropertyValue = self.assetPropertyValue {
            try encodeContainer.encode(assetPropertyValue, forKey: .assetPropertyValue)
        }
        if let entryId = self.entryId {
            try encodeContainer.encode(entryId, forKey: .entryId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entryId)
        entryId = entryIdDecoded
        let assetPropertyValueDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.AssetPropertyValue.self, forKey: .assetPropertyValue)
        assetPropertyValue = assetPropertyValueDecoded
    }
}

extension IoTSiteWiseClientTypes {
    /// Contains success information for an entry that is associated with the [BatchGetAssetPropertyValue](https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_BatchGetAssetPropertyValue.html) API.
    public struct BatchGetAssetPropertyValueSuccessEntry: Swift.Equatable {
        /// Contains asset property value information.
        public var assetPropertyValue: IoTSiteWiseClientTypes.AssetPropertyValue?
        /// The ID of the entry.
        /// This member is required.
        public var entryId: Swift.String?

        public init(
            assetPropertyValue: IoTSiteWiseClientTypes.AssetPropertyValue? = nil,
            entryId: Swift.String? = nil
        )
        {
            self.assetPropertyValue = assetPropertyValue
            self.entryId = entryId
        }
    }

}

extension IoTSiteWiseClientTypes.BatchPutAssetPropertyError: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCode
        case errorMessage
        case timestamps
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCode = self.errorCode {
            try encodeContainer.encode(errorCode.rawValue, forKey: .errorCode)
        }
        if let errorMessage = self.errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let timestamps = timestamps {
            var timestampsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .timestamps)
            for timeinnanos0 in timestamps {
                try timestampsContainer.encode(timeinnanos0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorCodeDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.BatchPutAssetPropertyValueErrorCode.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
        let timestampsContainer = try containerValues.decodeIfPresent([IoTSiteWiseClientTypes.TimeInNanos?].self, forKey: .timestamps)
        var timestampsDecoded0:[IoTSiteWiseClientTypes.TimeInNanos]? = nil
        if let timestampsContainer = timestampsContainer {
            timestampsDecoded0 = [IoTSiteWiseClientTypes.TimeInNanos]()
            for structure0 in timestampsContainer {
                if let structure0 = structure0 {
                    timestampsDecoded0?.append(structure0)
                }
            }
        }
        timestamps = timestampsDecoded0
    }
}

extension IoTSiteWiseClientTypes {
    /// Contains error information from updating a batch of asset property values.
    public struct BatchPutAssetPropertyError: Swift.Equatable {
        /// The error code.
        /// This member is required.
        public var errorCode: IoTSiteWiseClientTypes.BatchPutAssetPropertyValueErrorCode?
        /// The associated error message.
        /// This member is required.
        public var errorMessage: Swift.String?
        /// A list of timestamps for each error, if any.
        /// This member is required.
        public var timestamps: [IoTSiteWiseClientTypes.TimeInNanos]?

        public init(
            errorCode: IoTSiteWiseClientTypes.BatchPutAssetPropertyValueErrorCode? = nil,
            errorMessage: Swift.String? = nil,
            timestamps: [IoTSiteWiseClientTypes.TimeInNanos]? = nil
        )
        {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
            self.timestamps = timestamps
        }
    }

}

extension IoTSiteWiseClientTypes.BatchPutAssetPropertyErrorEntry: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entryId
        case errors
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let entryId = self.entryId {
            try encodeContainer.encode(entryId, forKey: .entryId)
        }
        if let errors = errors {
            var errorsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .errors)
            for batchputassetpropertyerror0 in errors {
                try errorsContainer.encode(batchputassetpropertyerror0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entryId)
        entryId = entryIdDecoded
        let errorsContainer = try containerValues.decodeIfPresent([IoTSiteWiseClientTypes.BatchPutAssetPropertyError?].self, forKey: .errors)
        var errorsDecoded0:[IoTSiteWiseClientTypes.BatchPutAssetPropertyError]? = nil
        if let errorsContainer = errorsContainer {
            errorsDecoded0 = [IoTSiteWiseClientTypes.BatchPutAssetPropertyError]()
            for structure0 in errorsContainer {
                if let structure0 = structure0 {
                    errorsDecoded0?.append(structure0)
                }
            }
        }
        errors = errorsDecoded0
    }
}

extension IoTSiteWiseClientTypes {
    /// Contains error information for asset property value entries that are associated with the [BatchPutAssetPropertyValue](https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_BatchPutAssetPropertyValue.html) API.
    public struct BatchPutAssetPropertyErrorEntry: Swift.Equatable {
        /// The ID of the failed entry.
        /// This member is required.
        public var entryId: Swift.String?
        /// The list of update property value errors.
        /// This member is required.
        public var errors: [IoTSiteWiseClientTypes.BatchPutAssetPropertyError]?

        public init(
            entryId: Swift.String? = nil,
            errors: [IoTSiteWiseClientTypes.BatchPutAssetPropertyError]? = nil
        )
        {
            self.entryId = entryId
            self.errors = errors
        }
    }

}

extension IoTSiteWiseClientTypes {
    public enum BatchPutAssetPropertyValueErrorCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case accessdeniedexception
        case conflictingoperationexception
        case internalfailureexception
        case invalidrequestexception
        case limitexceededexception
        case resourcenotfoundexception
        case serviceunavailableexception
        case throttlingexception
        case timestampoutofrangeexception
        case sdkUnknown(Swift.String)

        public static var allCases: [BatchPutAssetPropertyValueErrorCode] {
            return [
                .accessdeniedexception,
                .conflictingoperationexception,
                .internalfailureexception,
                .invalidrequestexception,
                .limitexceededexception,
                .resourcenotfoundexception,
                .serviceunavailableexception,
                .throttlingexception,
                .timestampoutofrangeexception,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .accessdeniedexception: return "AccessDeniedException"
            case .conflictingoperationexception: return "ConflictingOperationException"
            case .internalfailureexception: return "InternalFailureException"
            case .invalidrequestexception: return "InvalidRequestException"
            case .limitexceededexception: return "LimitExceededException"
            case .resourcenotfoundexception: return "ResourceNotFoundException"
            case .serviceunavailableexception: return "ServiceUnavailableException"
            case .throttlingexception: return "ThrottlingException"
            case .timestampoutofrangeexception: return "TimestampOutOfRangeException"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = BatchPutAssetPropertyValueErrorCode(rawValue: rawValue) ?? BatchPutAssetPropertyValueErrorCode.sdkUnknown(rawValue)
        }
    }
}

extension BatchPutAssetPropertyValueInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entries
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let entries = entries {
            var entriesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .entries)
            for putassetpropertyvalueentry0 in entries {
                try entriesContainer.encode(putassetpropertyvalueentry0)
            }
        }
    }
}

extension BatchPutAssetPropertyValueInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/properties"
    }
}

public struct BatchPutAssetPropertyValueInput: Swift.Equatable {
    /// The list of asset property value entries for the batch put request. You can specify up to 10 entries per request.
    /// This member is required.
    public var entries: [IoTSiteWiseClientTypes.PutAssetPropertyValueEntry]?

    public init(
        entries: [IoTSiteWiseClientTypes.PutAssetPropertyValueEntry]? = nil
    )
    {
        self.entries = entries
    }
}

struct BatchPutAssetPropertyValueInputBody: Swift.Equatable {
    let entries: [IoTSiteWiseClientTypes.PutAssetPropertyValueEntry]?
}

extension BatchPutAssetPropertyValueInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entries
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entriesContainer = try containerValues.decodeIfPresent([IoTSiteWiseClientTypes.PutAssetPropertyValueEntry?].self, forKey: .entries)
        var entriesDecoded0:[IoTSiteWiseClientTypes.PutAssetPropertyValueEntry]? = nil
        if let entriesContainer = entriesContainer {
            entriesDecoded0 = [IoTSiteWiseClientTypes.PutAssetPropertyValueEntry]()
            for structure0 in entriesContainer {
                if let structure0 = structure0 {
                    entriesDecoded0?.append(structure0)
                }
            }
        }
        entries = entriesDecoded0
    }
}

extension BatchPutAssetPropertyValueOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: BatchPutAssetPropertyValueOutputBody = try responseDecoder.decode(responseBody: data)
            self.errorEntries = output.errorEntries
        } else {
            self.errorEntries = nil
        }
    }
}

public struct BatchPutAssetPropertyValueOutput: Swift.Equatable {
    /// A list of the errors (if any) associated with the batch put request. Each error entry contains the entryId of the entry that failed.
    /// This member is required.
    public var errorEntries: [IoTSiteWiseClientTypes.BatchPutAssetPropertyErrorEntry]?

    public init(
        errorEntries: [IoTSiteWiseClientTypes.BatchPutAssetPropertyErrorEntry]? = nil
    )
    {
        self.errorEntries = errorEntries
    }
}

struct BatchPutAssetPropertyValueOutputBody: Swift.Equatable {
    let errorEntries: [IoTSiteWiseClientTypes.BatchPutAssetPropertyErrorEntry]?
}

extension BatchPutAssetPropertyValueOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorEntries
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorEntriesContainer = try containerValues.decodeIfPresent([IoTSiteWiseClientTypes.BatchPutAssetPropertyErrorEntry?].self, forKey: .errorEntries)
        var errorEntriesDecoded0:[IoTSiteWiseClientTypes.BatchPutAssetPropertyErrorEntry]? = nil
        if let errorEntriesContainer = errorEntriesContainer {
            errorEntriesDecoded0 = [IoTSiteWiseClientTypes.BatchPutAssetPropertyErrorEntry]()
            for structure0 in errorEntriesContainer {
                if let structure0 = structure0 {
                    errorEntriesDecoded0?.append(structure0)
                }
            }
        }
        errorEntries = errorEntriesDecoded0
    }
}

enum BatchPutAssetPropertyValueOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictingOperationException": return try await ConflictingOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension IoTSiteWiseClientTypes {
    public enum CapabilitySyncStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case inSync
        case outOfSync
        case syncFailed
        case unknown
        case sdkUnknown(Swift.String)

        public static var allCases: [CapabilitySyncStatus] {
            return [
                .inSync,
                .outOfSync,
                .syncFailed,
                .unknown,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .inSync: return "IN_SYNC"
            case .outOfSync: return "OUT_OF_SYNC"
            case .syncFailed: return "SYNC_FAILED"
            case .unknown: return "UNKNOWN"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CapabilitySyncStatus(rawValue: rawValue) ?? CapabilitySyncStatus.sdkUnknown(rawValue)
        }
    }
}

extension IoTSiteWiseClientTypes {
    public enum ColumnName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case alias
        case assetId
        case dataType
        case propertyId
        case quality
        case timestampNanoOffset
        case timestampSeconds
        case value
        case sdkUnknown(Swift.String)

        public static var allCases: [ColumnName] {
            return [
                .alias,
                .assetId,
                .dataType,
                .propertyId,
                .quality,
                .timestampNanoOffset,
                .timestampSeconds,
                .value,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .alias: return "ALIAS"
            case .assetId: return "ASSET_ID"
            case .dataType: return "DATA_TYPE"
            case .propertyId: return "PROPERTY_ID"
            case .quality: return "QUALITY"
            case .timestampNanoOffset: return "TIMESTAMP_NANO_OFFSET"
            case .timestampSeconds: return "TIMESTAMP_SECONDS"
            case .value: return "VALUE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ColumnName(rawValue: rawValue) ?? ColumnName.sdkUnknown(rawValue)
        }
    }
}

extension IoTSiteWiseClientTypes.CompositeModelProperty: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assetProperty
        case id
        case name
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assetProperty = self.assetProperty {
            try encodeContainer.encode(assetProperty, forKey: .assetProperty)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let assetPropertyDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.Property.self, forKey: .assetProperty)
        assetProperty = assetPropertyDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
    }
}

extension IoTSiteWiseClientTypes {
    /// Contains information about a composite model property on an asset.
    public struct CompositeModelProperty: Swift.Equatable {
        /// Contains asset property information.
        /// This member is required.
        public var assetProperty: IoTSiteWiseClientTypes.Property?
        /// The ID of the composite model that contains the property.
        public var id: Swift.String?
        /// The name of the property.
        /// This member is required.
        public var name: Swift.String?
        /// The type of the composite model that defines this property.
        /// This member is required.
        public var type: Swift.String?

        public init(
            assetProperty: IoTSiteWiseClientTypes.Property? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            type: Swift.String? = nil
        )
        {
            self.assetProperty = assetProperty
            self.id = id
            self.name = name
            self.type = type
        }
    }

}

extension IoTSiteWiseClientTypes {
    public enum ComputeLocation: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cloud
        case edge
        case sdkUnknown(Swift.String)

        public static var allCases: [ComputeLocation] {
            return [
                .cloud,
                .edge,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cloud: return "CLOUD"
            case .edge: return "EDGE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ComputeLocation(rawValue: rawValue) ?? ComputeLocation.sdkUnknown(rawValue)
        }
    }
}

extension IoTSiteWiseClientTypes.ConfigurationErrorDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code
        case message
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let code = self.code {
            try encodeContainer.encode(code.rawValue, forKey: .code)
        }
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.ErrorCode.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension IoTSiteWiseClientTypes {
    /// Contains the details of an IoT SiteWise configuration error.
    public struct ConfigurationErrorDetails: Swift.Equatable {
        /// The error code.
        /// This member is required.
        public var code: IoTSiteWiseClientTypes.ErrorCode?
        /// The error message.
        /// This member is required.
        public var message: Swift.String?

        public init(
            code: IoTSiteWiseClientTypes.ErrorCode? = nil,
            message: Swift.String? = nil
        )
        {
            self.code = code
            self.message = message
        }
    }

}

extension IoTSiteWiseClientTypes {
    public enum ConfigurationState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case updateFailed
        case updateInProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [ConfigurationState] {
            return [
                .active,
                .updateFailed,
                .updateInProgress,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .updateFailed: return "UPDATE_FAILED"
            case .updateInProgress: return "UPDATE_IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ConfigurationState(rawValue: rawValue) ?? ConfigurationState.sdkUnknown(rawValue)
        }
    }
}

extension IoTSiteWiseClientTypes.ConfigurationStatus: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case error
        case state
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let error = self.error {
            try encodeContainer.encode(error, forKey: .error)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stateDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.ConfigurationState.self, forKey: .state)
        state = stateDecoded
        let errorDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.ConfigurationErrorDetails.self, forKey: .error)
        error = errorDecoded
    }
}

extension IoTSiteWiseClientTypes {
    /// Contains current status information for the configuration.
    public struct ConfigurationStatus: Swift.Equatable {
        /// Contains associated error information, if any.
        public var error: IoTSiteWiseClientTypes.ConfigurationErrorDetails?
        /// The current state of the configuration.
        /// This member is required.
        public var state: IoTSiteWiseClientTypes.ConfigurationState?

        public init(
            error: IoTSiteWiseClientTypes.ConfigurationErrorDetails? = nil,
            state: IoTSiteWiseClientTypes.ConfigurationState? = nil
        )
        {
            self.error = error
            self.state = state
        }
    }

}

extension ConflictingOperationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ConflictingOperationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.resourceArn = output.resourceArn
            self.properties.resourceId = output.resourceId
        } else {
            self.properties.message = nil
            self.properties.resourceArn = nil
            self.properties.resourceId = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Your request has conflicting operations. This can occur if you're trying to perform more than one operation on the same resource at the same time.
public struct ConflictingOperationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The ARN of the resource that conflicts with this operation.
        /// This member is required.
        public internal(set) var resourceArn: Swift.String? = nil
        /// The ID of the resource that conflicts with this operation.
        /// This member is required.
        public internal(set) var resourceId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictingOperationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceArn: Swift.String? = nil,
        resourceId: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceArn = resourceArn
        self.properties.resourceId = resourceId
    }
}

struct ConflictingOperationExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceId: Swift.String?
    let resourceArn: Swift.String?
}

extension ConflictingOperationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case resourceArn
        case resourceId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
    }
}

extension CreateAccessPolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessPolicyIdentity
        case accessPolicyPermission
        case accessPolicyResource
        case clientToken
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessPolicyIdentity = self.accessPolicyIdentity {
            try encodeContainer.encode(accessPolicyIdentity, forKey: .accessPolicyIdentity)
        }
        if let accessPolicyPermission = self.accessPolicyPermission {
            try encodeContainer.encode(accessPolicyPermission.rawValue, forKey: .accessPolicyPermission)
        }
        if let accessPolicyResource = self.accessPolicyResource {
            try encodeContainer.encode(accessPolicyResource, forKey: .accessPolicyResource)
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateAccessPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/access-policies"
    }
}

public struct CreateAccessPolicyInput: Swift.Equatable {
    /// The identity for this access policy. Choose an IAM Identity Center user, an IAM Identity Center group, or an IAM user.
    /// This member is required.
    public var accessPolicyIdentity: IoTSiteWiseClientTypes.Identity?
    /// The permission level for this access policy. Note that a project ADMINISTRATOR is also known as a project owner.
    /// This member is required.
    public var accessPolicyPermission: IoTSiteWiseClientTypes.Permission?
    /// The IoT SiteWise Monitor resource for this access policy. Choose either a portal or a project.
    /// This member is required.
    public var accessPolicyResource: IoTSiteWiseClientTypes.Resource?
    /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
    public var clientToken: Swift.String?
    /// A list of key-value pairs that contain metadata for the access policy. For more information, see [Tagging your IoT SiteWise resources](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/tag-resources.html) in the IoT SiteWise User Guide.
    public var tags: [Swift.String:Swift.String]?

    public init(
        accessPolicyIdentity: IoTSiteWiseClientTypes.Identity? = nil,
        accessPolicyPermission: IoTSiteWiseClientTypes.Permission? = nil,
        accessPolicyResource: IoTSiteWiseClientTypes.Resource? = nil,
        clientToken: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.accessPolicyIdentity = accessPolicyIdentity
        self.accessPolicyPermission = accessPolicyPermission
        self.accessPolicyResource = accessPolicyResource
        self.clientToken = clientToken
        self.tags = tags
    }
}

struct CreateAccessPolicyInputBody: Swift.Equatable {
    let accessPolicyIdentity: IoTSiteWiseClientTypes.Identity?
    let accessPolicyResource: IoTSiteWiseClientTypes.Resource?
    let accessPolicyPermission: IoTSiteWiseClientTypes.Permission?
    let clientToken: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateAccessPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessPolicyIdentity
        case accessPolicyPermission
        case accessPolicyResource
        case clientToken
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessPolicyIdentityDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.Identity.self, forKey: .accessPolicyIdentity)
        accessPolicyIdentity = accessPolicyIdentityDecoded
        let accessPolicyResourceDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.Resource.self, forKey: .accessPolicyResource)
        accessPolicyResource = accessPolicyResourceDecoded
        let accessPolicyPermissionDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.Permission.self, forKey: .accessPolicyPermission)
        accessPolicyPermission = accessPolicyPermissionDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateAccessPolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateAccessPolicyOutputBody = try responseDecoder.decode(responseBody: data)
            self.accessPolicyArn = output.accessPolicyArn
            self.accessPolicyId = output.accessPolicyId
        } else {
            self.accessPolicyArn = nil
            self.accessPolicyId = nil
        }
    }
}

public struct CreateAccessPolicyOutput: Swift.Equatable {
    /// The [ARN](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the access policy, which has the following format. arn:${Partition}:iotsitewise:${Region}:${Account}:access-policy/${AccessPolicyId}
    /// This member is required.
    public var accessPolicyArn: Swift.String?
    /// The ID of the access policy.
    /// This member is required.
    public var accessPolicyId: Swift.String?

    public init(
        accessPolicyArn: Swift.String? = nil,
        accessPolicyId: Swift.String? = nil
    )
    {
        self.accessPolicyArn = accessPolicyArn
        self.accessPolicyId = accessPolicyId
    }
}

struct CreateAccessPolicyOutputBody: Swift.Equatable {
    let accessPolicyId: Swift.String?
    let accessPolicyArn: Swift.String?
}

extension CreateAccessPolicyOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessPolicyArn
        case accessPolicyId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessPolicyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accessPolicyId)
        accessPolicyId = accessPolicyIdDecoded
        let accessPolicyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accessPolicyArn)
        accessPolicyArn = accessPolicyArnDecoded
    }
}

enum CreateAccessPolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateAssetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assetDescription
        case assetModelId
        case assetName
        case clientToken
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assetDescription = self.assetDescription {
            try encodeContainer.encode(assetDescription, forKey: .assetDescription)
        }
        if let assetModelId = self.assetModelId {
            try encodeContainer.encode(assetModelId, forKey: .assetModelId)
        }
        if let assetName = self.assetName {
            try encodeContainer.encode(assetName, forKey: .assetName)
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateAssetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/assets"
    }
}

public struct CreateAssetInput: Swift.Equatable {
    /// A description for the asset.
    public var assetDescription: Swift.String?
    /// The ID of the asset model from which to create the asset.
    /// This member is required.
    public var assetModelId: Swift.String?
    /// A friendly name for the asset.
    /// This member is required.
    public var assetName: Swift.String?
    /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
    public var clientToken: Swift.String?
    /// A list of key-value pairs that contain metadata for the asset. For more information, see [Tagging your IoT SiteWise resources](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/tag-resources.html) in the IoT SiteWise User Guide.
    public var tags: [Swift.String:Swift.String]?

    public init(
        assetDescription: Swift.String? = nil,
        assetModelId: Swift.String? = nil,
        assetName: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.assetDescription = assetDescription
        self.assetModelId = assetModelId
        self.assetName = assetName
        self.clientToken = clientToken
        self.tags = tags
    }
}

struct CreateAssetInputBody: Swift.Equatable {
    let assetName: Swift.String?
    let assetModelId: Swift.String?
    let clientToken: Swift.String?
    let tags: [Swift.String:Swift.String]?
    let assetDescription: Swift.String?
}

extension CreateAssetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assetDescription
        case assetModelId
        case assetName
        case clientToken
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assetName)
        assetName = assetNameDecoded
        let assetModelIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assetModelId)
        assetModelId = assetModelIdDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let assetDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assetDescription)
        assetDescription = assetDescriptionDecoded
    }
}

extension CreateAssetModelInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assetModelCompositeModels
        case assetModelDescription
        case assetModelHierarchies
        case assetModelName
        case assetModelProperties
        case clientToken
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assetModelCompositeModels = assetModelCompositeModels {
            var assetModelCompositeModelsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .assetModelCompositeModels)
            for assetmodelcompositemodeldefinition0 in assetModelCompositeModels {
                try assetModelCompositeModelsContainer.encode(assetmodelcompositemodeldefinition0)
            }
        }
        if let assetModelDescription = self.assetModelDescription {
            try encodeContainer.encode(assetModelDescription, forKey: .assetModelDescription)
        }
        if let assetModelHierarchies = assetModelHierarchies {
            var assetModelHierarchiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .assetModelHierarchies)
            for assetmodelhierarchydefinition0 in assetModelHierarchies {
                try assetModelHierarchiesContainer.encode(assetmodelhierarchydefinition0)
            }
        }
        if let assetModelName = self.assetModelName {
            try encodeContainer.encode(assetModelName, forKey: .assetModelName)
        }
        if let assetModelProperties = assetModelProperties {
            var assetModelPropertiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .assetModelProperties)
            for assetmodelpropertydefinition0 in assetModelProperties {
                try assetModelPropertiesContainer.encode(assetmodelpropertydefinition0)
            }
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateAssetModelInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/asset-models"
    }
}

public struct CreateAssetModelInput: Swift.Equatable {
    /// The composite asset models that are part of this asset model. Composite asset models are asset models that contain specific properties. Each composite model has a type that defines the properties that the composite model supports. Use composite asset models to define alarms on this asset model.
    public var assetModelCompositeModels: [IoTSiteWiseClientTypes.AssetModelCompositeModelDefinition]?
    /// A description for the asset model.
    public var assetModelDescription: Swift.String?
    /// The hierarchy definitions of the asset model. Each hierarchy specifies an asset model whose assets can be children of any other assets created from this asset model. For more information, see [Asset hierarchies](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/asset-hierarchies.html) in the IoT SiteWise User Guide. You can specify up to 10 hierarchies per asset model. For more information, see [Quotas](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/quotas.html) in the IoT SiteWise User Guide.
    public var assetModelHierarchies: [IoTSiteWiseClientTypes.AssetModelHierarchyDefinition]?
    /// A unique, friendly name for the asset model.
    /// This member is required.
    public var assetModelName: Swift.String?
    /// The property definitions of the asset model. For more information, see [Asset properties](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/asset-properties.html) in the IoT SiteWise User Guide. You can specify up to 200 properties per asset model. For more information, see [Quotas](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/quotas.html) in the IoT SiteWise User Guide.
    public var assetModelProperties: [IoTSiteWiseClientTypes.AssetModelPropertyDefinition]?
    /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
    public var clientToken: Swift.String?
    /// A list of key-value pairs that contain metadata for the asset model. For more information, see [Tagging your IoT SiteWise resources](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/tag-resources.html) in the IoT SiteWise User Guide.
    public var tags: [Swift.String:Swift.String]?

    public init(
        assetModelCompositeModels: [IoTSiteWiseClientTypes.AssetModelCompositeModelDefinition]? = nil,
        assetModelDescription: Swift.String? = nil,
        assetModelHierarchies: [IoTSiteWiseClientTypes.AssetModelHierarchyDefinition]? = nil,
        assetModelName: Swift.String? = nil,
        assetModelProperties: [IoTSiteWiseClientTypes.AssetModelPropertyDefinition]? = nil,
        clientToken: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.assetModelCompositeModels = assetModelCompositeModels
        self.assetModelDescription = assetModelDescription
        self.assetModelHierarchies = assetModelHierarchies
        self.assetModelName = assetModelName
        self.assetModelProperties = assetModelProperties
        self.clientToken = clientToken
        self.tags = tags
    }
}

struct CreateAssetModelInputBody: Swift.Equatable {
    let assetModelName: Swift.String?
    let assetModelDescription: Swift.String?
    let assetModelProperties: [IoTSiteWiseClientTypes.AssetModelPropertyDefinition]?
    let assetModelHierarchies: [IoTSiteWiseClientTypes.AssetModelHierarchyDefinition]?
    let assetModelCompositeModels: [IoTSiteWiseClientTypes.AssetModelCompositeModelDefinition]?
    let clientToken: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateAssetModelInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assetModelCompositeModels
        case assetModelDescription
        case assetModelHierarchies
        case assetModelName
        case assetModelProperties
        case clientToken
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assetModelNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assetModelName)
        assetModelName = assetModelNameDecoded
        let assetModelDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assetModelDescription)
        assetModelDescription = assetModelDescriptionDecoded
        let assetModelPropertiesContainer = try containerValues.decodeIfPresent([IoTSiteWiseClientTypes.AssetModelPropertyDefinition?].self, forKey: .assetModelProperties)
        var assetModelPropertiesDecoded0:[IoTSiteWiseClientTypes.AssetModelPropertyDefinition]? = nil
        if let assetModelPropertiesContainer = assetModelPropertiesContainer {
            assetModelPropertiesDecoded0 = [IoTSiteWiseClientTypes.AssetModelPropertyDefinition]()
            for structure0 in assetModelPropertiesContainer {
                if let structure0 = structure0 {
                    assetModelPropertiesDecoded0?.append(structure0)
                }
            }
        }
        assetModelProperties = assetModelPropertiesDecoded0
        let assetModelHierarchiesContainer = try containerValues.decodeIfPresent([IoTSiteWiseClientTypes.AssetModelHierarchyDefinition?].self, forKey: .assetModelHierarchies)
        var assetModelHierarchiesDecoded0:[IoTSiteWiseClientTypes.AssetModelHierarchyDefinition]? = nil
        if let assetModelHierarchiesContainer = assetModelHierarchiesContainer {
            assetModelHierarchiesDecoded0 = [IoTSiteWiseClientTypes.AssetModelHierarchyDefinition]()
            for structure0 in assetModelHierarchiesContainer {
                if let structure0 = structure0 {
                    assetModelHierarchiesDecoded0?.append(structure0)
                }
            }
        }
        assetModelHierarchies = assetModelHierarchiesDecoded0
        let assetModelCompositeModelsContainer = try containerValues.decodeIfPresent([IoTSiteWiseClientTypes.AssetModelCompositeModelDefinition?].self, forKey: .assetModelCompositeModels)
        var assetModelCompositeModelsDecoded0:[IoTSiteWiseClientTypes.AssetModelCompositeModelDefinition]? = nil
        if let assetModelCompositeModelsContainer = assetModelCompositeModelsContainer {
            assetModelCompositeModelsDecoded0 = [IoTSiteWiseClientTypes.AssetModelCompositeModelDefinition]()
            for structure0 in assetModelCompositeModelsContainer {
                if let structure0 = structure0 {
                    assetModelCompositeModelsDecoded0?.append(structure0)
                }
            }
        }
        assetModelCompositeModels = assetModelCompositeModelsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateAssetModelOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateAssetModelOutputBody = try responseDecoder.decode(responseBody: data)
            self.assetModelArn = output.assetModelArn
            self.assetModelId = output.assetModelId
            self.assetModelStatus = output.assetModelStatus
        } else {
            self.assetModelArn = nil
            self.assetModelId = nil
            self.assetModelStatus = nil
        }
    }
}

public struct CreateAssetModelOutput: Swift.Equatable {
    /// The [ARN](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the asset model, which has the following format. arn:${Partition}:iotsitewise:${Region}:${Account}:asset-model/${AssetModelId}
    /// This member is required.
    public var assetModelArn: Swift.String?
    /// The ID of the asset model. You can use this ID when you call other IoT SiteWise APIs.
    /// This member is required.
    public var assetModelId: Swift.String?
    /// The status of the asset model, which contains a state (CREATING after successfully calling this operation) and any error message.
    /// This member is required.
    public var assetModelStatus: IoTSiteWiseClientTypes.AssetModelStatus?

    public init(
        assetModelArn: Swift.String? = nil,
        assetModelId: Swift.String? = nil,
        assetModelStatus: IoTSiteWiseClientTypes.AssetModelStatus? = nil
    )
    {
        self.assetModelArn = assetModelArn
        self.assetModelId = assetModelId
        self.assetModelStatus = assetModelStatus
    }
}

struct CreateAssetModelOutputBody: Swift.Equatable {
    let assetModelId: Swift.String?
    let assetModelArn: Swift.String?
    let assetModelStatus: IoTSiteWiseClientTypes.AssetModelStatus?
}

extension CreateAssetModelOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assetModelArn
        case assetModelId
        case assetModelStatus
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assetModelIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assetModelId)
        assetModelId = assetModelIdDecoded
        let assetModelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assetModelArn)
        assetModelArn = assetModelArnDecoded
        let assetModelStatusDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.AssetModelStatus.self, forKey: .assetModelStatus)
        assetModelStatus = assetModelStatusDecoded
    }
}

enum CreateAssetModelOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictingOperationException": return try await ConflictingOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceAlreadyExistsException": return try await ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateAssetOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateAssetOutputBody = try responseDecoder.decode(responseBody: data)
            self.assetArn = output.assetArn
            self.assetId = output.assetId
            self.assetStatus = output.assetStatus
        } else {
            self.assetArn = nil
            self.assetId = nil
            self.assetStatus = nil
        }
    }
}

public struct CreateAssetOutput: Swift.Equatable {
    /// The [ARN](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the asset, which has the following format. arn:${Partition}:iotsitewise:${Region}:${Account}:asset/${AssetId}
    /// This member is required.
    public var assetArn: Swift.String?
    /// The ID of the asset. This ID uniquely identifies the asset within IoT SiteWise and can be used with other IoT SiteWise APIs.
    /// This member is required.
    public var assetId: Swift.String?
    /// The status of the asset, which contains a state (CREATING after successfully calling this operation) and any error message.
    /// This member is required.
    public var assetStatus: IoTSiteWiseClientTypes.AssetStatus?

    public init(
        assetArn: Swift.String? = nil,
        assetId: Swift.String? = nil,
        assetStatus: IoTSiteWiseClientTypes.AssetStatus? = nil
    )
    {
        self.assetArn = assetArn
        self.assetId = assetId
        self.assetStatus = assetStatus
    }
}

struct CreateAssetOutputBody: Swift.Equatable {
    let assetId: Swift.String?
    let assetArn: Swift.String?
    let assetStatus: IoTSiteWiseClientTypes.AssetStatus?
}

extension CreateAssetOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assetArn
        case assetId
        case assetStatus
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assetId)
        assetId = assetIdDecoded
        let assetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assetArn)
        assetArn = assetArnDecoded
        let assetStatusDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.AssetStatus.self, forKey: .assetStatus)
        assetStatus = assetStatusDecoded
    }
}

enum CreateAssetOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictingOperationException": return try await ConflictingOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceAlreadyExistsException": return try await ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateBulkImportJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorReportLocation
        case files
        case jobConfiguration
        case jobName
        case jobRoleArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorReportLocation = self.errorReportLocation {
            try encodeContainer.encode(errorReportLocation, forKey: .errorReportLocation)
        }
        if let files = files {
            var filesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .files)
            for file0 in files {
                try filesContainer.encode(file0)
            }
        }
        if let jobConfiguration = self.jobConfiguration {
            try encodeContainer.encode(jobConfiguration, forKey: .jobConfiguration)
        }
        if let jobName = self.jobName {
            try encodeContainer.encode(jobName, forKey: .jobName)
        }
        if let jobRoleArn = self.jobRoleArn {
            try encodeContainer.encode(jobRoleArn, forKey: .jobRoleArn)
        }
    }
}

extension CreateBulkImportJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/jobs"
    }
}

public struct CreateBulkImportJobInput: Swift.Equatable {
    /// The Amazon S3 destination where errors associated with the job creation request are saved.
    /// This member is required.
    public var errorReportLocation: IoTSiteWiseClientTypes.ErrorReportLocation?
    /// The files in the specified Amazon S3 bucket that contain your data.
    /// This member is required.
    public var files: [IoTSiteWiseClientTypes.File]?
    /// Contains the configuration information of a job, such as the file format used to save data in Amazon S3.
    /// This member is required.
    public var jobConfiguration: IoTSiteWiseClientTypes.JobConfiguration?
    /// The unique name that helps identify the job request.
    /// This member is required.
    public var jobName: Swift.String?
    /// The [ARN](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the IAM role that allows IoT SiteWise to read Amazon S3 data.
    /// This member is required.
    public var jobRoleArn: Swift.String?

    public init(
        errorReportLocation: IoTSiteWiseClientTypes.ErrorReportLocation? = nil,
        files: [IoTSiteWiseClientTypes.File]? = nil,
        jobConfiguration: IoTSiteWiseClientTypes.JobConfiguration? = nil,
        jobName: Swift.String? = nil,
        jobRoleArn: Swift.String? = nil
    )
    {
        self.errorReportLocation = errorReportLocation
        self.files = files
        self.jobConfiguration = jobConfiguration
        self.jobName = jobName
        self.jobRoleArn = jobRoleArn
    }
}

struct CreateBulkImportJobInputBody: Swift.Equatable {
    let jobName: Swift.String?
    let jobRoleArn: Swift.String?
    let files: [IoTSiteWiseClientTypes.File]?
    let errorReportLocation: IoTSiteWiseClientTypes.ErrorReportLocation?
    let jobConfiguration: IoTSiteWiseClientTypes.JobConfiguration?
}

extension CreateBulkImportJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorReportLocation
        case files
        case jobConfiguration
        case jobName
        case jobRoleArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobName)
        jobName = jobNameDecoded
        let jobRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobRoleArn)
        jobRoleArn = jobRoleArnDecoded
        let filesContainer = try containerValues.decodeIfPresent([IoTSiteWiseClientTypes.File?].self, forKey: .files)
        var filesDecoded0:[IoTSiteWiseClientTypes.File]? = nil
        if let filesContainer = filesContainer {
            filesDecoded0 = [IoTSiteWiseClientTypes.File]()
            for structure0 in filesContainer {
                if let structure0 = structure0 {
                    filesDecoded0?.append(structure0)
                }
            }
        }
        files = filesDecoded0
        let errorReportLocationDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.ErrorReportLocation.self, forKey: .errorReportLocation)
        errorReportLocation = errorReportLocationDecoded
        let jobConfigurationDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.JobConfiguration.self, forKey: .jobConfiguration)
        jobConfiguration = jobConfigurationDecoded
    }
}

extension CreateBulkImportJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateBulkImportJobOutputBody = try responseDecoder.decode(responseBody: data)
            self.jobId = output.jobId
            self.jobName = output.jobName
            self.jobStatus = output.jobStatus
        } else {
            self.jobId = nil
            self.jobName = nil
            self.jobStatus = nil
        }
    }
}

public struct CreateBulkImportJobOutput: Swift.Equatable {
    /// The ID of the job.
    /// This member is required.
    public var jobId: Swift.String?
    /// The unique name that helps identify the job request.
    /// This member is required.
    public var jobName: Swift.String?
    /// The status of the bulk import job can be one of following values.
    ///
    /// * PENDING  IoT SiteWise is waiting for the current bulk import job to finish.
    ///
    /// * CANCELLED  The bulk import job has been canceled.
    ///
    /// * RUNNING  IoT SiteWise is processing your request to import your data from Amazon S3.
    ///
    /// * COMPLETED  IoT SiteWise successfully completed your request to import data from Amazon S3.
    ///
    /// * FAILED  IoT SiteWise couldn't process your request to import data from Amazon S3. You can use logs saved in the specified error report location in Amazon S3 to troubleshoot issues.
    ///
    /// * COMPLETED_WITH_FAILURES  IoT SiteWise completed your request to import data from Amazon S3 with errors. You can use logs saved in the specified error report location in Amazon S3 to troubleshoot issues.
    /// This member is required.
    public var jobStatus: IoTSiteWiseClientTypes.JobStatus?

    public init(
        jobId: Swift.String? = nil,
        jobName: Swift.String? = nil,
        jobStatus: IoTSiteWiseClientTypes.JobStatus? = nil
    )
    {
        self.jobId = jobId
        self.jobName = jobName
        self.jobStatus = jobStatus
    }
}

struct CreateBulkImportJobOutputBody: Swift.Equatable {
    let jobId: Swift.String?
    let jobName: Swift.String?
    let jobStatus: IoTSiteWiseClientTypes.JobStatus?
}

extension CreateBulkImportJobOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobId
        case jobName
        case jobStatus
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let jobNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobName)
        jobName = jobNameDecoded
        let jobStatusDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.JobStatus.self, forKey: .jobStatus)
        jobStatus = jobStatusDecoded
    }
}

enum CreateBulkImportJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictingOperationException": return try await ConflictingOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceAlreadyExistsException": return try await ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateDashboardInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case dashboardDefinition
        case dashboardDescription
        case dashboardName
        case projectId
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let dashboardDefinition = self.dashboardDefinition {
            try encodeContainer.encode(dashboardDefinition, forKey: .dashboardDefinition)
        }
        if let dashboardDescription = self.dashboardDescription {
            try encodeContainer.encode(dashboardDescription, forKey: .dashboardDescription)
        }
        if let dashboardName = self.dashboardName {
            try encodeContainer.encode(dashboardName, forKey: .dashboardName)
        }
        if let projectId = self.projectId {
            try encodeContainer.encode(projectId, forKey: .projectId)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateDashboardInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/dashboards"
    }
}

public struct CreateDashboardInput: Swift.Equatable {
    /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
    public var clientToken: Swift.String?
    /// The dashboard definition specified in a JSON literal. For detailed information, see [Creating dashboards (CLI)](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/create-dashboards-using-aws-cli.html) in the IoT SiteWise User Guide.
    /// This member is required.
    public var dashboardDefinition: Swift.String?
    /// A description for the dashboard.
    public var dashboardDescription: Swift.String?
    /// A friendly name for the dashboard.
    /// This member is required.
    public var dashboardName: Swift.String?
    /// The ID of the project in which to create the dashboard.
    /// This member is required.
    public var projectId: Swift.String?
    /// A list of key-value pairs that contain metadata for the dashboard. For more information, see [Tagging your IoT SiteWise resources](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/tag-resources.html) in the IoT SiteWise User Guide.
    public var tags: [Swift.String:Swift.String]?

    public init(
        clientToken: Swift.String? = nil,
        dashboardDefinition: Swift.String? = nil,
        dashboardDescription: Swift.String? = nil,
        dashboardName: Swift.String? = nil,
        projectId: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.clientToken = clientToken
        self.dashboardDefinition = dashboardDefinition
        self.dashboardDescription = dashboardDescription
        self.dashboardName = dashboardName
        self.projectId = projectId
        self.tags = tags
    }
}

struct CreateDashboardInputBody: Swift.Equatable {
    let projectId: Swift.String?
    let dashboardName: Swift.String?
    let dashboardDescription: Swift.String?
    let dashboardDefinition: Swift.String?
    let clientToken: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateDashboardInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case dashboardDefinition
        case dashboardDescription
        case dashboardName
        case projectId
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let projectIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectId)
        projectId = projectIdDecoded
        let dashboardNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dashboardName)
        dashboardName = dashboardNameDecoded
        let dashboardDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dashboardDescription)
        dashboardDescription = dashboardDescriptionDecoded
        let dashboardDefinitionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dashboardDefinition)
        dashboardDefinition = dashboardDefinitionDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateDashboardOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateDashboardOutputBody = try responseDecoder.decode(responseBody: data)
            self.dashboardArn = output.dashboardArn
            self.dashboardId = output.dashboardId
        } else {
            self.dashboardArn = nil
            self.dashboardId = nil
        }
    }
}

public struct CreateDashboardOutput: Swift.Equatable {
    /// The [ARN](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the dashboard, which has the following format. arn:${Partition}:iotsitewise:${Region}:${Account}:dashboard/${DashboardId}
    /// This member is required.
    public var dashboardArn: Swift.String?
    /// The ID of the dashboard.
    /// This member is required.
    public var dashboardId: Swift.String?

    public init(
        dashboardArn: Swift.String? = nil,
        dashboardId: Swift.String? = nil
    )
    {
        self.dashboardArn = dashboardArn
        self.dashboardId = dashboardId
    }
}

struct CreateDashboardOutputBody: Swift.Equatable {
    let dashboardId: Swift.String?
    let dashboardArn: Swift.String?
}

extension CreateDashboardOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dashboardArn
        case dashboardId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dashboardIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dashboardId)
        dashboardId = dashboardIdDecoded
        let dashboardArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dashboardArn)
        dashboardArn = dashboardArnDecoded
    }
}

enum CreateDashboardOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateGatewayInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayName
        case gatewayPlatform
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let gatewayName = self.gatewayName {
            try encodeContainer.encode(gatewayName, forKey: .gatewayName)
        }
        if let gatewayPlatform = self.gatewayPlatform {
            try encodeContainer.encode(gatewayPlatform, forKey: .gatewayPlatform)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateGatewayInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/20200301/gateways"
    }
}

public struct CreateGatewayInput: Swift.Equatable {
    /// A unique, friendly name for the gateway.
    /// This member is required.
    public var gatewayName: Swift.String?
    /// The gateway's platform. You can only specify one platform in a gateway.
    /// This member is required.
    public var gatewayPlatform: IoTSiteWiseClientTypes.GatewayPlatform?
    /// A list of key-value pairs that contain metadata for the gateway. For more information, see [Tagging your IoT SiteWise resources](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/tag-resources.html) in the IoT SiteWise User Guide.
    public var tags: [Swift.String:Swift.String]?

    public init(
        gatewayName: Swift.String? = nil,
        gatewayPlatform: IoTSiteWiseClientTypes.GatewayPlatform? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.gatewayName = gatewayName
        self.gatewayPlatform = gatewayPlatform
        self.tags = tags
    }
}

struct CreateGatewayInputBody: Swift.Equatable {
    let gatewayName: Swift.String?
    let gatewayPlatform: IoTSiteWiseClientTypes.GatewayPlatform?
    let tags: [Swift.String:Swift.String]?
}

extension CreateGatewayInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayName
        case gatewayPlatform
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayName)
        gatewayName = gatewayNameDecoded
        let gatewayPlatformDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.GatewayPlatform.self, forKey: .gatewayPlatform)
        gatewayPlatform = gatewayPlatformDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateGatewayOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateGatewayOutputBody = try responseDecoder.decode(responseBody: data)
            self.gatewayArn = output.gatewayArn
            self.gatewayId = output.gatewayId
        } else {
            self.gatewayArn = nil
            self.gatewayId = nil
        }
    }
}

public struct CreateGatewayOutput: Swift.Equatable {
    /// The [ARN](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the gateway, which has the following format. arn:${Partition}:iotsitewise:${Region}:${Account}:gateway/${GatewayId}
    /// This member is required.
    public var gatewayArn: Swift.String?
    /// The ID of the gateway device. You can use this ID when you call other IoT SiteWise APIs.
    /// This member is required.
    public var gatewayId: Swift.String?

    public init(
        gatewayArn: Swift.String? = nil,
        gatewayId: Swift.String? = nil
    )
    {
        self.gatewayArn = gatewayArn
        self.gatewayId = gatewayId
    }
}

struct CreateGatewayOutputBody: Swift.Equatable {
    let gatewayId: Swift.String?
    let gatewayArn: Swift.String?
}

extension CreateGatewayOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayArn
        case gatewayId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayId)
        gatewayId = gatewayIdDecoded
        let gatewayArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayArn)
        gatewayArn = gatewayArnDecoded
    }
}

enum CreateGatewayOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceAlreadyExistsException": return try await ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreatePortalInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alarms
        case clientToken
        case notificationSenderEmail
        case portalAuthMode
        case portalContactEmail
        case portalDescription
        case portalLogoImageFile
        case portalName
        case roleArn
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let alarms = self.alarms {
            try encodeContainer.encode(alarms, forKey: .alarms)
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let notificationSenderEmail = self.notificationSenderEmail {
            try encodeContainer.encode(notificationSenderEmail, forKey: .notificationSenderEmail)
        }
        if let portalAuthMode = self.portalAuthMode {
            try encodeContainer.encode(portalAuthMode.rawValue, forKey: .portalAuthMode)
        }
        if let portalContactEmail = self.portalContactEmail {
            try encodeContainer.encode(portalContactEmail, forKey: .portalContactEmail)
        }
        if let portalDescription = self.portalDescription {
            try encodeContainer.encode(portalDescription, forKey: .portalDescription)
        }
        if let portalLogoImageFile = self.portalLogoImageFile {
            try encodeContainer.encode(portalLogoImageFile, forKey: .portalLogoImageFile)
        }
        if let portalName = self.portalName {
            try encodeContainer.encode(portalName, forKey: .portalName)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreatePortalInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/portals"
    }
}

public struct CreatePortalInput: Swift.Equatable {
    /// Contains the configuration information of an alarm created in an IoT SiteWise Monitor portal. You can use the alarm to monitor an asset property and get notified when the asset property value is outside a specified range. For more information, see [Monitoring with alarms](https://docs.aws.amazon.com/iot-sitewise/latest/appguide/monitor-alarms.html) in the IoT SiteWise Application Guide.
    public var alarms: IoTSiteWiseClientTypes.Alarms?
    /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
    public var clientToken: Swift.String?
    /// The email address that sends alarm notifications. If you use the [IoT Events managed Lambda function](https://docs.aws.amazon.com/iotevents/latest/developerguide/lambda-support.html) to manage your emails, you must [verify the sender email address in Amazon SES](https://docs.aws.amazon.com/ses/latest/DeveloperGuide/verify-email-addresses.html).
    public var notificationSenderEmail: Swift.String?
    /// The service to use to authenticate users to the portal. Choose from the following options:
    ///
    /// * SSO  The portal uses IAM Identity Center (successor to Single Sign-On) to authenticate users and manage user permissions. Before you can create a portal that uses IAM Identity Center, you must enable IAM Identity Center. For more information, see [Enabling IAM Identity Center](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/monitor-get-started.html#mon-gs-sso) in the IoT SiteWise User Guide. This option is only available in Amazon Web Services Regions other than the China Regions.
    ///
    /// * IAM  The portal uses Identity and Access Management to authenticate users and manage user permissions.
    ///
    ///
    /// You can't change this value after you create a portal. Default: SSO
    public var portalAuthMode: IoTSiteWiseClientTypes.AuthMode?
    /// The Amazon Web Services administrator's contact email address.
    /// This member is required.
    public var portalContactEmail: Swift.String?
    /// A description for the portal.
    public var portalDescription: Swift.String?
    /// A logo image to display in the portal. Upload a square, high-resolution image. The image is displayed on a dark background.
    public var portalLogoImageFile: IoTSiteWiseClientTypes.ImageFile?
    /// A friendly name for the portal.
    /// This member is required.
    public var portalName: Swift.String?
    /// The [ARN](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of a service role that allows the portal's users to access your IoT SiteWise resources on your behalf. For more information, see [Using service roles for IoT SiteWise Monitor](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/monitor-service-role.html) in the IoT SiteWise User Guide.
    /// This member is required.
    public var roleArn: Swift.String?
    /// A list of key-value pairs that contain metadata for the portal. For more information, see [Tagging your IoT SiteWise resources](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/tag-resources.html) in the IoT SiteWise User Guide.
    public var tags: [Swift.String:Swift.String]?

    public init(
        alarms: IoTSiteWiseClientTypes.Alarms? = nil,
        clientToken: Swift.String? = nil,
        notificationSenderEmail: Swift.String? = nil,
        portalAuthMode: IoTSiteWiseClientTypes.AuthMode? = nil,
        portalContactEmail: Swift.String? = nil,
        portalDescription: Swift.String? = nil,
        portalLogoImageFile: IoTSiteWiseClientTypes.ImageFile? = nil,
        portalName: Swift.String? = nil,
        roleArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.alarms = alarms
        self.clientToken = clientToken
        self.notificationSenderEmail = notificationSenderEmail
        self.portalAuthMode = portalAuthMode
        self.portalContactEmail = portalContactEmail
        self.portalDescription = portalDescription
        self.portalLogoImageFile = portalLogoImageFile
        self.portalName = portalName
        self.roleArn = roleArn
        self.tags = tags
    }
}

struct CreatePortalInputBody: Swift.Equatable {
    let portalName: Swift.String?
    let portalDescription: Swift.String?
    let portalContactEmail: Swift.String?
    let clientToken: Swift.String?
    let portalLogoImageFile: IoTSiteWiseClientTypes.ImageFile?
    let roleArn: Swift.String?
    let tags: [Swift.String:Swift.String]?
    let portalAuthMode: IoTSiteWiseClientTypes.AuthMode?
    let notificationSenderEmail: Swift.String?
    let alarms: IoTSiteWiseClientTypes.Alarms?
}

extension CreatePortalInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alarms
        case clientToken
        case notificationSenderEmail
        case portalAuthMode
        case portalContactEmail
        case portalDescription
        case portalLogoImageFile
        case portalName
        case roleArn
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let portalNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .portalName)
        portalName = portalNameDecoded
        let portalDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .portalDescription)
        portalDescription = portalDescriptionDecoded
        let portalContactEmailDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .portalContactEmail)
        portalContactEmail = portalContactEmailDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let portalLogoImageFileDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.ImageFile.self, forKey: .portalLogoImageFile)
        portalLogoImageFile = portalLogoImageFileDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let portalAuthModeDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.AuthMode.self, forKey: .portalAuthMode)
        portalAuthMode = portalAuthModeDecoded
        let notificationSenderEmailDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .notificationSenderEmail)
        notificationSenderEmail = notificationSenderEmailDecoded
        let alarmsDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.Alarms.self, forKey: .alarms)
        alarms = alarmsDecoded
    }
}

extension CreatePortalOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreatePortalOutputBody = try responseDecoder.decode(responseBody: data)
            self.portalArn = output.portalArn
            self.portalId = output.portalId
            self.portalStartUrl = output.portalStartUrl
            self.portalStatus = output.portalStatus
            self.ssoApplicationId = output.ssoApplicationId
        } else {
            self.portalArn = nil
            self.portalId = nil
            self.portalStartUrl = nil
            self.portalStatus = nil
            self.ssoApplicationId = nil
        }
    }
}

public struct CreatePortalOutput: Swift.Equatable {
    /// The [ARN](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the portal, which has the following format. arn:${Partition}:iotsitewise:${Region}:${Account}:portal/${PortalId}
    /// This member is required.
    public var portalArn: Swift.String?
    /// The ID of the created portal.
    /// This member is required.
    public var portalId: Swift.String?
    /// The URL for the IoT SiteWise Monitor portal. You can use this URL to access portals that use IAM Identity Center for authentication. For portals that use IAM for authentication, you must use the IoT SiteWise console to get a URL that you can use to access the portal.
    /// This member is required.
    public var portalStartUrl: Swift.String?
    /// The status of the portal, which contains a state (CREATING after successfully calling this operation) and any error message.
    /// This member is required.
    public var portalStatus: IoTSiteWiseClientTypes.PortalStatus?
    /// The associated IAM Identity Center application ID, if the portal uses IAM Identity Center.
    /// This member is required.
    public var ssoApplicationId: Swift.String?

    public init(
        portalArn: Swift.String? = nil,
        portalId: Swift.String? = nil,
        portalStartUrl: Swift.String? = nil,
        portalStatus: IoTSiteWiseClientTypes.PortalStatus? = nil,
        ssoApplicationId: Swift.String? = nil
    )
    {
        self.portalArn = portalArn
        self.portalId = portalId
        self.portalStartUrl = portalStartUrl
        self.portalStatus = portalStatus
        self.ssoApplicationId = ssoApplicationId
    }
}

struct CreatePortalOutputBody: Swift.Equatable {
    let portalId: Swift.String?
    let portalArn: Swift.String?
    let portalStartUrl: Swift.String?
    let portalStatus: IoTSiteWiseClientTypes.PortalStatus?
    let ssoApplicationId: Swift.String?
}

extension CreatePortalOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case portalArn
        case portalId
        case portalStartUrl
        case portalStatus
        case ssoApplicationId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let portalIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .portalId)
        portalId = portalIdDecoded
        let portalArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .portalArn)
        portalArn = portalArnDecoded
        let portalStartUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .portalStartUrl)
        portalStartUrl = portalStartUrlDecoded
        let portalStatusDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.PortalStatus.self, forKey: .portalStatus)
        portalStatus = portalStatusDecoded
        let ssoApplicationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ssoApplicationId)
        ssoApplicationId = ssoApplicationIdDecoded
    }
}

enum CreatePortalOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateProjectInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case portalId
        case projectDescription
        case projectName
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let portalId = self.portalId {
            try encodeContainer.encode(portalId, forKey: .portalId)
        }
        if let projectDescription = self.projectDescription {
            try encodeContainer.encode(projectDescription, forKey: .projectDescription)
        }
        if let projectName = self.projectName {
            try encodeContainer.encode(projectName, forKey: .projectName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateProjectInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/projects"
    }
}

public struct CreateProjectInput: Swift.Equatable {
    /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
    public var clientToken: Swift.String?
    /// The ID of the portal in which to create the project.
    /// This member is required.
    public var portalId: Swift.String?
    /// A description for the project.
    public var projectDescription: Swift.String?
    /// A friendly name for the project.
    /// This member is required.
    public var projectName: Swift.String?
    /// A list of key-value pairs that contain metadata for the project. For more information, see [Tagging your IoT SiteWise resources](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/tag-resources.html) in the IoT SiteWise User Guide.
    public var tags: [Swift.String:Swift.String]?

    public init(
        clientToken: Swift.String? = nil,
        portalId: Swift.String? = nil,
        projectDescription: Swift.String? = nil,
        projectName: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.clientToken = clientToken
        self.portalId = portalId
        self.projectDescription = projectDescription
        self.projectName = projectName
        self.tags = tags
    }
}

struct CreateProjectInputBody: Swift.Equatable {
    let portalId: Swift.String?
    let projectName: Swift.String?
    let projectDescription: Swift.String?
    let clientToken: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateProjectInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case portalId
        case projectDescription
        case projectName
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let portalIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .portalId)
        portalId = portalIdDecoded
        let projectNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectName)
        projectName = projectNameDecoded
        let projectDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectDescription)
        projectDescription = projectDescriptionDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateProjectOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateProjectOutputBody = try responseDecoder.decode(responseBody: data)
            self.projectArn = output.projectArn
            self.projectId = output.projectId
        } else {
            self.projectArn = nil
            self.projectId = nil
        }
    }
}

public struct CreateProjectOutput: Swift.Equatable {
    /// The [ARN](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the project, which has the following format. arn:${Partition}:iotsitewise:${Region}:${Account}:project/${ProjectId}
    /// This member is required.
    public var projectArn: Swift.String?
    /// The ID of the project.
    /// This member is required.
    public var projectId: Swift.String?

    public init(
        projectArn: Swift.String? = nil,
        projectId: Swift.String? = nil
    )
    {
        self.projectArn = projectArn
        self.projectId = projectId
    }
}

struct CreateProjectOutputBody: Swift.Equatable {
    let projectId: Swift.String?
    let projectArn: Swift.String?
}

extension CreateProjectOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case projectArn
        case projectId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let projectIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectId)
        projectId = projectIdDecoded
        let projectArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectArn)
        projectArn = projectArnDecoded
    }
}

enum CreateProjectOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension IoTSiteWiseClientTypes.Csv: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case columnNames
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let columnNames = columnNames {
            var columnNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .columnNames)
            for columnname0 in columnNames {
                try columnNamesContainer.encode(columnname0.rawValue)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let columnNamesContainer = try containerValues.decodeIfPresent([IoTSiteWiseClientTypes.ColumnName?].self, forKey: .columnNames)
        var columnNamesDecoded0:[IoTSiteWiseClientTypes.ColumnName]? = nil
        if let columnNamesContainer = columnNamesContainer {
            columnNamesDecoded0 = [IoTSiteWiseClientTypes.ColumnName]()
            for enum0 in columnNamesContainer {
                if let enum0 = enum0 {
                    columnNamesDecoded0?.append(enum0)
                }
            }
        }
        columnNames = columnNamesDecoded0
    }
}

extension IoTSiteWiseClientTypes {
    /// A .csv file.
    public struct Csv: Swift.Equatable {
        /// The column names specified in the .csv file.
        public var columnNames: [IoTSiteWiseClientTypes.ColumnName]?

        public init(
            columnNames: [IoTSiteWiseClientTypes.ColumnName]? = nil
        )
        {
            self.columnNames = columnNames
        }
    }

}

extension IoTSiteWiseClientTypes.CustomerManagedS3Storage: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case roleArn
        case s3ResourceArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let s3ResourceArn = self.s3ResourceArn {
            try encodeContainer.encode(s3ResourceArn, forKey: .s3ResourceArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3ResourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3ResourceArn)
        s3ResourceArn = s3ResourceArnDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
    }
}

extension IoTSiteWiseClientTypes {
    /// Contains information about a customer managed Amazon S3 bucket.
    public struct CustomerManagedS3Storage: Swift.Equatable {
        /// The [ARN](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the Identity and Access Management role that allows IoT SiteWise to send data to Amazon S3.
        /// This member is required.
        public var roleArn: Swift.String?
        /// The [ARN](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the Amazon S3 object. For more information about how to find the ARN for an Amazon S3 object, see [Amazon S3 resources](https://docs.aws.amazon.com/AmazonS3/latest/userguide/s3-arn-format.html) in the Amazon Simple Storage Service User Guide.
        /// This member is required.
        public var s3ResourceArn: Swift.String?

        public init(
            roleArn: Swift.String? = nil,
            s3ResourceArn: Swift.String? = nil
        )
        {
            self.roleArn = roleArn
            self.s3ResourceArn = s3ResourceArn
        }
    }

}

extension IoTSiteWiseClientTypes.DashboardSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationDate
        case description
        case id
        case lastUpdateDate
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationDate = self.creationDate {
            try encodeContainer.encodeTimestamp(creationDate, format: .epochSeconds, forKey: .creationDate)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let lastUpdateDate = self.lastUpdateDate {
            try encodeContainer.encodeTimestamp(lastUpdateDate, format: .epochSeconds, forKey: .lastUpdateDate)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let creationDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDate)
        creationDate = creationDateDecoded
        let lastUpdateDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdateDate)
        lastUpdateDate = lastUpdateDateDecoded
    }
}

extension IoTSiteWiseClientTypes {
    /// Contains a dashboard summary.
    public struct DashboardSummary: Swift.Equatable {
        /// The date the dashboard was created, in Unix epoch time.
        public var creationDate: ClientRuntime.Date?
        /// The dashboard's description.
        public var description: Swift.String?
        /// The ID of the dashboard.
        /// This member is required.
        public var id: Swift.String?
        /// The date the dashboard was last updated, in Unix epoch time.
        public var lastUpdateDate: ClientRuntime.Date?
        /// The name of the dashboard
        /// This member is required.
        public var name: Swift.String?

        public init(
            creationDate: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            lastUpdateDate: ClientRuntime.Date? = nil,
            name: Swift.String? = nil
        )
        {
            self.creationDate = creationDate
            self.description = description
            self.id = id
            self.lastUpdateDate = lastUpdateDate
            self.name = name
        }
    }

}

extension DeleteAccessPolicyInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let clientToken = clientToken {
                let clientTokenQueryItem = ClientRuntime.URLQueryItem(name: "clientToken".urlPercentEncoding(), value: Swift.String(clientToken).urlPercentEncoding())
                items.append(clientTokenQueryItem)
            }
            return items
        }
    }
}

extension DeleteAccessPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let accessPolicyId = accessPolicyId else {
            return nil
        }
        return "/access-policies/\(accessPolicyId.urlPercentEncoding())"
    }
}

public struct DeleteAccessPolicyInput: Swift.Equatable {
    /// The ID of the access policy to be deleted.
    /// This member is required.
    public var accessPolicyId: Swift.String?
    /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
    public var clientToken: Swift.String?

    public init(
        accessPolicyId: Swift.String? = nil,
        clientToken: Swift.String? = nil
    )
    {
        self.accessPolicyId = accessPolicyId
        self.clientToken = clientToken
    }
}

struct DeleteAccessPolicyInputBody: Swift.Equatable {
}

extension DeleteAccessPolicyInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteAccessPolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteAccessPolicyOutput: Swift.Equatable {

    public init() { }
}

enum DeleteAccessPolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteAssetInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let clientToken = clientToken {
                let clientTokenQueryItem = ClientRuntime.URLQueryItem(name: "clientToken".urlPercentEncoding(), value: Swift.String(clientToken).urlPercentEncoding())
                items.append(clientTokenQueryItem)
            }
            return items
        }
    }
}

extension DeleteAssetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let assetId = assetId else {
            return nil
        }
        return "/assets/\(assetId.urlPercentEncoding())"
    }
}

public struct DeleteAssetInput: Swift.Equatable {
    /// The ID of the asset to delete.
    /// This member is required.
    public var assetId: Swift.String?
    /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
    public var clientToken: Swift.String?

    public init(
        assetId: Swift.String? = nil,
        clientToken: Swift.String? = nil
    )
    {
        self.assetId = assetId
        self.clientToken = clientToken
    }
}

struct DeleteAssetInputBody: Swift.Equatable {
}

extension DeleteAssetInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteAssetModelInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let clientToken = clientToken {
                let clientTokenQueryItem = ClientRuntime.URLQueryItem(name: "clientToken".urlPercentEncoding(), value: Swift.String(clientToken).urlPercentEncoding())
                items.append(clientTokenQueryItem)
            }
            return items
        }
    }
}

extension DeleteAssetModelInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let assetModelId = assetModelId else {
            return nil
        }
        return "/asset-models/\(assetModelId.urlPercentEncoding())"
    }
}

public struct DeleteAssetModelInput: Swift.Equatable {
    /// The ID of the asset model to delete.
    /// This member is required.
    public var assetModelId: Swift.String?
    /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
    public var clientToken: Swift.String?

    public init(
        assetModelId: Swift.String? = nil,
        clientToken: Swift.String? = nil
    )
    {
        self.assetModelId = assetModelId
        self.clientToken = clientToken
    }
}

struct DeleteAssetModelInputBody: Swift.Equatable {
}

extension DeleteAssetModelInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteAssetModelOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteAssetModelOutputBody = try responseDecoder.decode(responseBody: data)
            self.assetModelStatus = output.assetModelStatus
        } else {
            self.assetModelStatus = nil
        }
    }
}

public struct DeleteAssetModelOutput: Swift.Equatable {
    /// The status of the asset model, which contains a state (DELETING after successfully calling this operation) and any error message.
    /// This member is required.
    public var assetModelStatus: IoTSiteWiseClientTypes.AssetModelStatus?

    public init(
        assetModelStatus: IoTSiteWiseClientTypes.AssetModelStatus? = nil
    )
    {
        self.assetModelStatus = assetModelStatus
    }
}

struct DeleteAssetModelOutputBody: Swift.Equatable {
    let assetModelStatus: IoTSiteWiseClientTypes.AssetModelStatus?
}

extension DeleteAssetModelOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assetModelStatus
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assetModelStatusDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.AssetModelStatus.self, forKey: .assetModelStatus)
        assetModelStatus = assetModelStatusDecoded
    }
}

enum DeleteAssetModelOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictingOperationException": return try await ConflictingOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteAssetOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteAssetOutputBody = try responseDecoder.decode(responseBody: data)
            self.assetStatus = output.assetStatus
        } else {
            self.assetStatus = nil
        }
    }
}

public struct DeleteAssetOutput: Swift.Equatable {
    /// The status of the asset, which contains a state (DELETING after successfully calling this operation) and any error message.
    /// This member is required.
    public var assetStatus: IoTSiteWiseClientTypes.AssetStatus?

    public init(
        assetStatus: IoTSiteWiseClientTypes.AssetStatus? = nil
    )
    {
        self.assetStatus = assetStatus
    }
}

struct DeleteAssetOutputBody: Swift.Equatable {
    let assetStatus: IoTSiteWiseClientTypes.AssetStatus?
}

extension DeleteAssetOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assetStatus
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assetStatusDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.AssetStatus.self, forKey: .assetStatus)
        assetStatus = assetStatusDecoded
    }
}

enum DeleteAssetOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictingOperationException": return try await ConflictingOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteDashboardInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let clientToken = clientToken {
                let clientTokenQueryItem = ClientRuntime.URLQueryItem(name: "clientToken".urlPercentEncoding(), value: Swift.String(clientToken).urlPercentEncoding())
                items.append(clientTokenQueryItem)
            }
            return items
        }
    }
}

extension DeleteDashboardInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let dashboardId = dashboardId else {
            return nil
        }
        return "/dashboards/\(dashboardId.urlPercentEncoding())"
    }
}

public struct DeleteDashboardInput: Swift.Equatable {
    /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
    public var clientToken: Swift.String?
    /// The ID of the dashboard to delete.
    /// This member is required.
    public var dashboardId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        dashboardId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.dashboardId = dashboardId
    }
}

struct DeleteDashboardInputBody: Swift.Equatable {
}

extension DeleteDashboardInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteDashboardOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteDashboardOutput: Swift.Equatable {

    public init() { }
}

enum DeleteDashboardOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteGatewayInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let gatewayId = gatewayId else {
            return nil
        }
        return "/20200301/gateways/\(gatewayId.urlPercentEncoding())"
    }
}

public struct DeleteGatewayInput: Swift.Equatable {
    /// The ID of the gateway to delete.
    /// This member is required.
    public var gatewayId: Swift.String?

    public init(
        gatewayId: Swift.String? = nil
    )
    {
        self.gatewayId = gatewayId
    }
}

struct DeleteGatewayInputBody: Swift.Equatable {
}

extension DeleteGatewayInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteGatewayOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteGatewayOutput: Swift.Equatable {

    public init() { }
}

enum DeleteGatewayOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeletePortalInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let clientToken = clientToken {
                let clientTokenQueryItem = ClientRuntime.URLQueryItem(name: "clientToken".urlPercentEncoding(), value: Swift.String(clientToken).urlPercentEncoding())
                items.append(clientTokenQueryItem)
            }
            return items
        }
    }
}

extension DeletePortalInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let portalId = portalId else {
            return nil
        }
        return "/portals/\(portalId.urlPercentEncoding())"
    }
}

public struct DeletePortalInput: Swift.Equatable {
    /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
    public var clientToken: Swift.String?
    /// The ID of the portal to delete.
    /// This member is required.
    public var portalId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        portalId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.portalId = portalId
    }
}

struct DeletePortalInputBody: Swift.Equatable {
}

extension DeletePortalInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeletePortalOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeletePortalOutputBody = try responseDecoder.decode(responseBody: data)
            self.portalStatus = output.portalStatus
        } else {
            self.portalStatus = nil
        }
    }
}

public struct DeletePortalOutput: Swift.Equatable {
    /// The status of the portal, which contains a state (DELETING after successfully calling this operation) and any error message.
    /// This member is required.
    public var portalStatus: IoTSiteWiseClientTypes.PortalStatus?

    public init(
        portalStatus: IoTSiteWiseClientTypes.PortalStatus? = nil
    )
    {
        self.portalStatus = portalStatus
    }
}

struct DeletePortalOutputBody: Swift.Equatable {
    let portalStatus: IoTSiteWiseClientTypes.PortalStatus?
}

extension DeletePortalOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case portalStatus
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let portalStatusDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.PortalStatus.self, forKey: .portalStatus)
        portalStatus = portalStatusDecoded
    }
}

enum DeletePortalOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictingOperationException": return try await ConflictingOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteProjectInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let clientToken = clientToken {
                let clientTokenQueryItem = ClientRuntime.URLQueryItem(name: "clientToken".urlPercentEncoding(), value: Swift.String(clientToken).urlPercentEncoding())
                items.append(clientTokenQueryItem)
            }
            return items
        }
    }
}

extension DeleteProjectInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let projectId = projectId else {
            return nil
        }
        return "/projects/\(projectId.urlPercentEncoding())"
    }
}

public struct DeleteProjectInput: Swift.Equatable {
    /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
    public var clientToken: Swift.String?
    /// The ID of the project.
    /// This member is required.
    public var projectId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        projectId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.projectId = projectId
    }
}

struct DeleteProjectInputBody: Swift.Equatable {
}

extension DeleteProjectInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteProjectOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteProjectOutput: Swift.Equatable {

    public init() { }
}

enum DeleteProjectOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteTimeSeriesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
    }
}

extension DeleteTimeSeriesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let assetId = assetId {
                let assetIdQueryItem = ClientRuntime.URLQueryItem(name: "assetId".urlPercentEncoding(), value: Swift.String(assetId).urlPercentEncoding())
                items.append(assetIdQueryItem)
            }
            if let alias = alias {
                let aliasQueryItem = ClientRuntime.URLQueryItem(name: "alias".urlPercentEncoding(), value: Swift.String(alias).urlPercentEncoding())
                items.append(aliasQueryItem)
            }
            if let propertyId = propertyId {
                let propertyIdQueryItem = ClientRuntime.URLQueryItem(name: "propertyId".urlPercentEncoding(), value: Swift.String(propertyId).urlPercentEncoding())
                items.append(propertyIdQueryItem)
            }
            return items
        }
    }
}

extension DeleteTimeSeriesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/timeseries/delete"
    }
}

public struct DeleteTimeSeriesInput: Swift.Equatable {
    /// The alias that identifies the time series.
    public var alias: Swift.String?
    /// The ID of the asset in which the asset property was created.
    public var assetId: Swift.String?
    /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
    public var clientToken: Swift.String?
    /// The ID of the asset property.
    public var propertyId: Swift.String?

    public init(
        alias: Swift.String? = nil,
        assetId: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        propertyId: Swift.String? = nil
    )
    {
        self.alias = alias
        self.assetId = assetId
        self.clientToken = clientToken
        self.propertyId = propertyId
    }
}

struct DeleteTimeSeriesInputBody: Swift.Equatable {
    let clientToken: Swift.String?
}

extension DeleteTimeSeriesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension DeleteTimeSeriesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteTimeSeriesOutput: Swift.Equatable {

    public init() { }
}

enum DeleteTimeSeriesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictingOperationException": return try await ConflictingOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeAccessPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let accessPolicyId = accessPolicyId else {
            return nil
        }
        return "/access-policies/\(accessPolicyId.urlPercentEncoding())"
    }
}

public struct DescribeAccessPolicyInput: Swift.Equatable {
    /// The ID of the access policy.
    /// This member is required.
    public var accessPolicyId: Swift.String?

    public init(
        accessPolicyId: Swift.String? = nil
    )
    {
        self.accessPolicyId = accessPolicyId
    }
}

struct DescribeAccessPolicyInputBody: Swift.Equatable {
}

extension DescribeAccessPolicyInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeAccessPolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeAccessPolicyOutputBody = try responseDecoder.decode(responseBody: data)
            self.accessPolicyArn = output.accessPolicyArn
            self.accessPolicyCreationDate = output.accessPolicyCreationDate
            self.accessPolicyId = output.accessPolicyId
            self.accessPolicyIdentity = output.accessPolicyIdentity
            self.accessPolicyLastUpdateDate = output.accessPolicyLastUpdateDate
            self.accessPolicyPermission = output.accessPolicyPermission
            self.accessPolicyResource = output.accessPolicyResource
        } else {
            self.accessPolicyArn = nil
            self.accessPolicyCreationDate = nil
            self.accessPolicyId = nil
            self.accessPolicyIdentity = nil
            self.accessPolicyLastUpdateDate = nil
            self.accessPolicyPermission = nil
            self.accessPolicyResource = nil
        }
    }
}

public struct DescribeAccessPolicyOutput: Swift.Equatable {
    /// The [ARN](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the access policy, which has the following format. arn:${Partition}:iotsitewise:${Region}:${Account}:access-policy/${AccessPolicyId}
    /// This member is required.
    public var accessPolicyArn: Swift.String?
    /// The date the access policy was created, in Unix epoch time.
    /// This member is required.
    public var accessPolicyCreationDate: ClientRuntime.Date?
    /// The ID of the access policy.
    /// This member is required.
    public var accessPolicyId: Swift.String?
    /// The identity (IAM Identity Center user, IAM Identity Center group, or IAM user) to which this access policy applies.
    /// This member is required.
    public var accessPolicyIdentity: IoTSiteWiseClientTypes.Identity?
    /// The date the access policy was last updated, in Unix epoch time.
    /// This member is required.
    public var accessPolicyLastUpdateDate: ClientRuntime.Date?
    /// The access policy permission. Note that a project ADMINISTRATOR is also known as a project owner.
    /// This member is required.
    public var accessPolicyPermission: IoTSiteWiseClientTypes.Permission?
    /// The IoT SiteWise Monitor resource (portal or project) to which this access policy provides access.
    /// This member is required.
    public var accessPolicyResource: IoTSiteWiseClientTypes.Resource?

    public init(
        accessPolicyArn: Swift.String? = nil,
        accessPolicyCreationDate: ClientRuntime.Date? = nil,
        accessPolicyId: Swift.String? = nil,
        accessPolicyIdentity: IoTSiteWiseClientTypes.Identity? = nil,
        accessPolicyLastUpdateDate: ClientRuntime.Date? = nil,
        accessPolicyPermission: IoTSiteWiseClientTypes.Permission? = nil,
        accessPolicyResource: IoTSiteWiseClientTypes.Resource? = nil
    )
    {
        self.accessPolicyArn = accessPolicyArn
        self.accessPolicyCreationDate = accessPolicyCreationDate
        self.accessPolicyId = accessPolicyId
        self.accessPolicyIdentity = accessPolicyIdentity
        self.accessPolicyLastUpdateDate = accessPolicyLastUpdateDate
        self.accessPolicyPermission = accessPolicyPermission
        self.accessPolicyResource = accessPolicyResource
    }
}

struct DescribeAccessPolicyOutputBody: Swift.Equatable {
    let accessPolicyId: Swift.String?
    let accessPolicyArn: Swift.String?
    let accessPolicyIdentity: IoTSiteWiseClientTypes.Identity?
    let accessPolicyResource: IoTSiteWiseClientTypes.Resource?
    let accessPolicyPermission: IoTSiteWiseClientTypes.Permission?
    let accessPolicyCreationDate: ClientRuntime.Date?
    let accessPolicyLastUpdateDate: ClientRuntime.Date?
}

extension DescribeAccessPolicyOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessPolicyArn
        case accessPolicyCreationDate
        case accessPolicyId
        case accessPolicyIdentity
        case accessPolicyLastUpdateDate
        case accessPolicyPermission
        case accessPolicyResource
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessPolicyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accessPolicyId)
        accessPolicyId = accessPolicyIdDecoded
        let accessPolicyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accessPolicyArn)
        accessPolicyArn = accessPolicyArnDecoded
        let accessPolicyIdentityDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.Identity.self, forKey: .accessPolicyIdentity)
        accessPolicyIdentity = accessPolicyIdentityDecoded
        let accessPolicyResourceDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.Resource.self, forKey: .accessPolicyResource)
        accessPolicyResource = accessPolicyResourceDecoded
        let accessPolicyPermissionDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.Permission.self, forKey: .accessPolicyPermission)
        accessPolicyPermission = accessPolicyPermissionDecoded
        let accessPolicyCreationDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .accessPolicyCreationDate)
        accessPolicyCreationDate = accessPolicyCreationDateDecoded
        let accessPolicyLastUpdateDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .accessPolicyLastUpdateDate)
        accessPolicyLastUpdateDate = accessPolicyLastUpdateDateDecoded
    }
}

enum DescribeAccessPolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeAssetInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let excludeProperties = excludeProperties {
                let excludePropertiesQueryItem = ClientRuntime.URLQueryItem(name: "excludeProperties".urlPercentEncoding(), value: Swift.String(excludeProperties).urlPercentEncoding())
                items.append(excludePropertiesQueryItem)
            }
            return items
        }
    }
}

extension DescribeAssetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let assetId = assetId else {
            return nil
        }
        return "/assets/\(assetId.urlPercentEncoding())"
    }
}

public struct DescribeAssetInput: Swift.Equatable {
    /// The ID of the asset.
    /// This member is required.
    public var assetId: Swift.String?
    /// Whether or not to exclude asset properties from the response.
    public var excludeProperties: Swift.Bool?

    public init(
        assetId: Swift.String? = nil,
        excludeProperties: Swift.Bool? = nil
    )
    {
        self.assetId = assetId
        self.excludeProperties = excludeProperties
    }
}

struct DescribeAssetInputBody: Swift.Equatable {
}

extension DescribeAssetInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeAssetModelInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let excludeProperties = excludeProperties {
                let excludePropertiesQueryItem = ClientRuntime.URLQueryItem(name: "excludeProperties".urlPercentEncoding(), value: Swift.String(excludeProperties).urlPercentEncoding())
                items.append(excludePropertiesQueryItem)
            }
            return items
        }
    }
}

extension DescribeAssetModelInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let assetModelId = assetModelId else {
            return nil
        }
        return "/asset-models/\(assetModelId.urlPercentEncoding())"
    }
}

public struct DescribeAssetModelInput: Swift.Equatable {
    /// The ID of the asset model.
    /// This member is required.
    public var assetModelId: Swift.String?
    /// Whether or not to exclude asset model properties from the response.
    public var excludeProperties: Swift.Bool?

    public init(
        assetModelId: Swift.String? = nil,
        excludeProperties: Swift.Bool? = nil
    )
    {
        self.assetModelId = assetModelId
        self.excludeProperties = excludeProperties
    }
}

struct DescribeAssetModelInputBody: Swift.Equatable {
}

extension DescribeAssetModelInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeAssetModelOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeAssetModelOutputBody = try responseDecoder.decode(responseBody: data)
            self.assetModelArn = output.assetModelArn
            self.assetModelCompositeModels = output.assetModelCompositeModels
            self.assetModelCreationDate = output.assetModelCreationDate
            self.assetModelDescription = output.assetModelDescription
            self.assetModelHierarchies = output.assetModelHierarchies
            self.assetModelId = output.assetModelId
            self.assetModelLastUpdateDate = output.assetModelLastUpdateDate
            self.assetModelName = output.assetModelName
            self.assetModelProperties = output.assetModelProperties
            self.assetModelStatus = output.assetModelStatus
        } else {
            self.assetModelArn = nil
            self.assetModelCompositeModels = nil
            self.assetModelCreationDate = nil
            self.assetModelDescription = nil
            self.assetModelHierarchies = nil
            self.assetModelId = nil
            self.assetModelLastUpdateDate = nil
            self.assetModelName = nil
            self.assetModelProperties = nil
            self.assetModelStatus = nil
        }
    }
}

public struct DescribeAssetModelOutput: Swift.Equatable {
    /// The [ARN](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the asset model, which has the following format. arn:${Partition}:iotsitewise:${Region}:${Account}:asset-model/${AssetModelId}
    /// This member is required.
    public var assetModelArn: Swift.String?
    /// The list of composite asset models for the asset model.
    public var assetModelCompositeModels: [IoTSiteWiseClientTypes.AssetModelCompositeModel]?
    /// The date the asset model was created, in Unix epoch time.
    /// This member is required.
    public var assetModelCreationDate: ClientRuntime.Date?
    /// The asset model's description.
    /// This member is required.
    public var assetModelDescription: Swift.String?
    /// A list of asset model hierarchies that each contain a childAssetModelId and a hierarchyId (named id). A hierarchy specifies allowed parent/child asset relationships for an asset model.
    /// This member is required.
    public var assetModelHierarchies: [IoTSiteWiseClientTypes.AssetModelHierarchy]?
    /// The ID of the asset model.
    /// This member is required.
    public var assetModelId: Swift.String?
    /// The date the asset model was last updated, in Unix epoch time.
    /// This member is required.
    public var assetModelLastUpdateDate: ClientRuntime.Date?
    /// The name of the asset model.
    /// This member is required.
    public var assetModelName: Swift.String?
    /// The list of asset properties for the asset model. This object doesn't include properties that you define in composite models. You can find composite model properties in the assetModelCompositeModels object.
    /// This member is required.
    public var assetModelProperties: [IoTSiteWiseClientTypes.AssetModelProperty]?
    /// The current status of the asset model, which contains a state and any error message.
    /// This member is required.
    public var assetModelStatus: IoTSiteWiseClientTypes.AssetModelStatus?

    public init(
        assetModelArn: Swift.String? = nil,
        assetModelCompositeModels: [IoTSiteWiseClientTypes.AssetModelCompositeModel]? = nil,
        assetModelCreationDate: ClientRuntime.Date? = nil,
        assetModelDescription: Swift.String? = nil,
        assetModelHierarchies: [IoTSiteWiseClientTypes.AssetModelHierarchy]? = nil,
        assetModelId: Swift.String? = nil,
        assetModelLastUpdateDate: ClientRuntime.Date? = nil,
        assetModelName: Swift.String? = nil,
        assetModelProperties: [IoTSiteWiseClientTypes.AssetModelProperty]? = nil,
        assetModelStatus: IoTSiteWiseClientTypes.AssetModelStatus? = nil
    )
    {
        self.assetModelArn = assetModelArn
        self.assetModelCompositeModels = assetModelCompositeModels
        self.assetModelCreationDate = assetModelCreationDate
        self.assetModelDescription = assetModelDescription
        self.assetModelHierarchies = assetModelHierarchies
        self.assetModelId = assetModelId
        self.assetModelLastUpdateDate = assetModelLastUpdateDate
        self.assetModelName = assetModelName
        self.assetModelProperties = assetModelProperties
        self.assetModelStatus = assetModelStatus
    }
}

struct DescribeAssetModelOutputBody: Swift.Equatable {
    let assetModelId: Swift.String?
    let assetModelArn: Swift.String?
    let assetModelName: Swift.String?
    let assetModelDescription: Swift.String?
    let assetModelProperties: [IoTSiteWiseClientTypes.AssetModelProperty]?
    let assetModelHierarchies: [IoTSiteWiseClientTypes.AssetModelHierarchy]?
    let assetModelCompositeModels: [IoTSiteWiseClientTypes.AssetModelCompositeModel]?
    let assetModelCreationDate: ClientRuntime.Date?
    let assetModelLastUpdateDate: ClientRuntime.Date?
    let assetModelStatus: IoTSiteWiseClientTypes.AssetModelStatus?
}

extension DescribeAssetModelOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assetModelArn
        case assetModelCompositeModels
        case assetModelCreationDate
        case assetModelDescription
        case assetModelHierarchies
        case assetModelId
        case assetModelLastUpdateDate
        case assetModelName
        case assetModelProperties
        case assetModelStatus
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assetModelIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assetModelId)
        assetModelId = assetModelIdDecoded
        let assetModelArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assetModelArn)
        assetModelArn = assetModelArnDecoded
        let assetModelNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assetModelName)
        assetModelName = assetModelNameDecoded
        let assetModelDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assetModelDescription)
        assetModelDescription = assetModelDescriptionDecoded
        let assetModelPropertiesContainer = try containerValues.decodeIfPresent([IoTSiteWiseClientTypes.AssetModelProperty?].self, forKey: .assetModelProperties)
        var assetModelPropertiesDecoded0:[IoTSiteWiseClientTypes.AssetModelProperty]? = nil
        if let assetModelPropertiesContainer = assetModelPropertiesContainer {
            assetModelPropertiesDecoded0 = [IoTSiteWiseClientTypes.AssetModelProperty]()
            for structure0 in assetModelPropertiesContainer {
                if let structure0 = structure0 {
                    assetModelPropertiesDecoded0?.append(structure0)
                }
            }
        }
        assetModelProperties = assetModelPropertiesDecoded0
        let assetModelHierarchiesContainer = try containerValues.decodeIfPresent([IoTSiteWiseClientTypes.AssetModelHierarchy?].self, forKey: .assetModelHierarchies)
        var assetModelHierarchiesDecoded0:[IoTSiteWiseClientTypes.AssetModelHierarchy]? = nil
        if let assetModelHierarchiesContainer = assetModelHierarchiesContainer {
            assetModelHierarchiesDecoded0 = [IoTSiteWiseClientTypes.AssetModelHierarchy]()
            for structure0 in assetModelHierarchiesContainer {
                if let structure0 = structure0 {
                    assetModelHierarchiesDecoded0?.append(structure0)
                }
            }
        }
        assetModelHierarchies = assetModelHierarchiesDecoded0
        let assetModelCompositeModelsContainer = try containerValues.decodeIfPresent([IoTSiteWiseClientTypes.AssetModelCompositeModel?].self, forKey: .assetModelCompositeModels)
        var assetModelCompositeModelsDecoded0:[IoTSiteWiseClientTypes.AssetModelCompositeModel]? = nil
        if let assetModelCompositeModelsContainer = assetModelCompositeModelsContainer {
            assetModelCompositeModelsDecoded0 = [IoTSiteWiseClientTypes.AssetModelCompositeModel]()
            for structure0 in assetModelCompositeModelsContainer {
                if let structure0 = structure0 {
                    assetModelCompositeModelsDecoded0?.append(structure0)
                }
            }
        }
        assetModelCompositeModels = assetModelCompositeModelsDecoded0
        let assetModelCreationDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .assetModelCreationDate)
        assetModelCreationDate = assetModelCreationDateDecoded
        let assetModelLastUpdateDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .assetModelLastUpdateDate)
        assetModelLastUpdateDate = assetModelLastUpdateDateDecoded
        let assetModelStatusDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.AssetModelStatus.self, forKey: .assetModelStatus)
        assetModelStatus = assetModelStatusDecoded
    }
}

enum DescribeAssetModelOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeAssetOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeAssetOutputBody = try responseDecoder.decode(responseBody: data)
            self.assetArn = output.assetArn
            self.assetCompositeModels = output.assetCompositeModels
            self.assetCreationDate = output.assetCreationDate
            self.assetDescription = output.assetDescription
            self.assetHierarchies = output.assetHierarchies
            self.assetId = output.assetId
            self.assetLastUpdateDate = output.assetLastUpdateDate
            self.assetModelId = output.assetModelId
            self.assetName = output.assetName
            self.assetProperties = output.assetProperties
            self.assetStatus = output.assetStatus
        } else {
            self.assetArn = nil
            self.assetCompositeModels = nil
            self.assetCreationDate = nil
            self.assetDescription = nil
            self.assetHierarchies = nil
            self.assetId = nil
            self.assetLastUpdateDate = nil
            self.assetModelId = nil
            self.assetName = nil
            self.assetProperties = nil
            self.assetStatus = nil
        }
    }
}

public struct DescribeAssetOutput: Swift.Equatable {
    /// The [ARN](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the asset, which has the following format. arn:${Partition}:iotsitewise:${Region}:${Account}:asset/${AssetId}
    /// This member is required.
    public var assetArn: Swift.String?
    /// The composite models for the asset.
    public var assetCompositeModels: [IoTSiteWiseClientTypes.AssetCompositeModel]?
    /// The date the asset was created, in Unix epoch time.
    /// This member is required.
    public var assetCreationDate: ClientRuntime.Date?
    /// A description for the asset.
    public var assetDescription: Swift.String?
    /// A list of asset hierarchies that each contain a hierarchyId. A hierarchy specifies allowed parent/child asset relationships.
    /// This member is required.
    public var assetHierarchies: [IoTSiteWiseClientTypes.AssetHierarchy]?
    /// The ID of the asset.
    /// This member is required.
    public var assetId: Swift.String?
    /// The date the asset was last updated, in Unix epoch time.
    /// This member is required.
    public var assetLastUpdateDate: ClientRuntime.Date?
    /// The ID of the asset model that was used to create the asset.
    /// This member is required.
    public var assetModelId: Swift.String?
    /// The name of the asset.
    /// This member is required.
    public var assetName: Swift.String?
    /// The list of asset properties for the asset. This object doesn't include properties that you define in composite models. You can find composite model properties in the assetCompositeModels object.
    /// This member is required.
    public var assetProperties: [IoTSiteWiseClientTypes.AssetProperty]?
    /// The current status of the asset, which contains a state and any error message.
    /// This member is required.
    public var assetStatus: IoTSiteWiseClientTypes.AssetStatus?

    public init(
        assetArn: Swift.String? = nil,
        assetCompositeModels: [IoTSiteWiseClientTypes.AssetCompositeModel]? = nil,
        assetCreationDate: ClientRuntime.Date? = nil,
        assetDescription: Swift.String? = nil,
        assetHierarchies: [IoTSiteWiseClientTypes.AssetHierarchy]? = nil,
        assetId: Swift.String? = nil,
        assetLastUpdateDate: ClientRuntime.Date? = nil,
        assetModelId: Swift.String? = nil,
        assetName: Swift.String? = nil,
        assetProperties: [IoTSiteWiseClientTypes.AssetProperty]? = nil,
        assetStatus: IoTSiteWiseClientTypes.AssetStatus? = nil
    )
    {
        self.assetArn = assetArn
        self.assetCompositeModels = assetCompositeModels
        self.assetCreationDate = assetCreationDate
        self.assetDescription = assetDescription
        self.assetHierarchies = assetHierarchies
        self.assetId = assetId
        self.assetLastUpdateDate = assetLastUpdateDate
        self.assetModelId = assetModelId
        self.assetName = assetName
        self.assetProperties = assetProperties
        self.assetStatus = assetStatus
    }
}

struct DescribeAssetOutputBody: Swift.Equatable {
    let assetId: Swift.String?
    let assetArn: Swift.String?
    let assetName: Swift.String?
    let assetModelId: Swift.String?
    let assetProperties: [IoTSiteWiseClientTypes.AssetProperty]?
    let assetHierarchies: [IoTSiteWiseClientTypes.AssetHierarchy]?
    let assetCompositeModels: [IoTSiteWiseClientTypes.AssetCompositeModel]?
    let assetCreationDate: ClientRuntime.Date?
    let assetLastUpdateDate: ClientRuntime.Date?
    let assetStatus: IoTSiteWiseClientTypes.AssetStatus?
    let assetDescription: Swift.String?
}

extension DescribeAssetOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assetArn
        case assetCompositeModels
        case assetCreationDate
        case assetDescription
        case assetHierarchies
        case assetId
        case assetLastUpdateDate
        case assetModelId
        case assetName
        case assetProperties
        case assetStatus
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assetId)
        assetId = assetIdDecoded
        let assetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assetArn)
        assetArn = assetArnDecoded
        let assetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assetName)
        assetName = assetNameDecoded
        let assetModelIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assetModelId)
        assetModelId = assetModelIdDecoded
        let assetPropertiesContainer = try containerValues.decodeIfPresent([IoTSiteWiseClientTypes.AssetProperty?].self, forKey: .assetProperties)
        var assetPropertiesDecoded0:[IoTSiteWiseClientTypes.AssetProperty]? = nil
        if let assetPropertiesContainer = assetPropertiesContainer {
            assetPropertiesDecoded0 = [IoTSiteWiseClientTypes.AssetProperty]()
            for structure0 in assetPropertiesContainer {
                if let structure0 = structure0 {
                    assetPropertiesDecoded0?.append(structure0)
                }
            }
        }
        assetProperties = assetPropertiesDecoded0
        let assetHierarchiesContainer = try containerValues.decodeIfPresent([IoTSiteWiseClientTypes.AssetHierarchy?].self, forKey: .assetHierarchies)
        var assetHierarchiesDecoded0:[IoTSiteWiseClientTypes.AssetHierarchy]? = nil
        if let assetHierarchiesContainer = assetHierarchiesContainer {
            assetHierarchiesDecoded0 = [IoTSiteWiseClientTypes.AssetHierarchy]()
            for structure0 in assetHierarchiesContainer {
                if let structure0 = structure0 {
                    assetHierarchiesDecoded0?.append(structure0)
                }
            }
        }
        assetHierarchies = assetHierarchiesDecoded0
        let assetCompositeModelsContainer = try containerValues.decodeIfPresent([IoTSiteWiseClientTypes.AssetCompositeModel?].self, forKey: .assetCompositeModels)
        var assetCompositeModelsDecoded0:[IoTSiteWiseClientTypes.AssetCompositeModel]? = nil
        if let assetCompositeModelsContainer = assetCompositeModelsContainer {
            assetCompositeModelsDecoded0 = [IoTSiteWiseClientTypes.AssetCompositeModel]()
            for structure0 in assetCompositeModelsContainer {
                if let structure0 = structure0 {
                    assetCompositeModelsDecoded0?.append(structure0)
                }
            }
        }
        assetCompositeModels = assetCompositeModelsDecoded0
        let assetCreationDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .assetCreationDate)
        assetCreationDate = assetCreationDateDecoded
        let assetLastUpdateDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .assetLastUpdateDate)
        assetLastUpdateDate = assetLastUpdateDateDecoded
        let assetStatusDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.AssetStatus.self, forKey: .assetStatus)
        assetStatus = assetStatusDecoded
        let assetDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assetDescription)
        assetDescription = assetDescriptionDecoded
    }
}

enum DescribeAssetOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeAssetPropertyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let assetId = assetId else {
            return nil
        }
        guard let propertyId = propertyId else {
            return nil
        }
        return "/assets/\(assetId.urlPercentEncoding())/properties/\(propertyId.urlPercentEncoding())"
    }
}

public struct DescribeAssetPropertyInput: Swift.Equatable {
    /// The ID of the asset.
    /// This member is required.
    public var assetId: Swift.String?
    /// The ID of the asset property.
    /// This member is required.
    public var propertyId: Swift.String?

    public init(
        assetId: Swift.String? = nil,
        propertyId: Swift.String? = nil
    )
    {
        self.assetId = assetId
        self.propertyId = propertyId
    }
}

struct DescribeAssetPropertyInputBody: Swift.Equatable {
}

extension DescribeAssetPropertyInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeAssetPropertyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeAssetPropertyOutputBody = try responseDecoder.decode(responseBody: data)
            self.assetId = output.assetId
            self.assetModelId = output.assetModelId
            self.assetName = output.assetName
            self.assetProperty = output.assetProperty
            self.compositeModel = output.compositeModel
        } else {
            self.assetId = nil
            self.assetModelId = nil
            self.assetName = nil
            self.assetProperty = nil
            self.compositeModel = nil
        }
    }
}

public struct DescribeAssetPropertyOutput: Swift.Equatable {
    /// The ID of the asset.
    /// This member is required.
    public var assetId: Swift.String?
    /// The ID of the asset model.
    /// This member is required.
    public var assetModelId: Swift.String?
    /// The name of the asset.
    /// This member is required.
    public var assetName: Swift.String?
    /// The asset property's definition, alias, and notification state. This response includes this object for normal asset properties. If you describe an asset property in a composite model, this response includes the asset property information in compositeModel.
    public var assetProperty: IoTSiteWiseClientTypes.Property?
    /// The composite asset model that declares this asset property, if this asset property exists in a composite model.
    public var compositeModel: IoTSiteWiseClientTypes.CompositeModelProperty?

    public init(
        assetId: Swift.String? = nil,
        assetModelId: Swift.String? = nil,
        assetName: Swift.String? = nil,
        assetProperty: IoTSiteWiseClientTypes.Property? = nil,
        compositeModel: IoTSiteWiseClientTypes.CompositeModelProperty? = nil
    )
    {
        self.assetId = assetId
        self.assetModelId = assetModelId
        self.assetName = assetName
        self.assetProperty = assetProperty
        self.compositeModel = compositeModel
    }
}

struct DescribeAssetPropertyOutputBody: Swift.Equatable {
    let assetId: Swift.String?
    let assetName: Swift.String?
    let assetModelId: Swift.String?
    let assetProperty: IoTSiteWiseClientTypes.Property?
    let compositeModel: IoTSiteWiseClientTypes.CompositeModelProperty?
}

extension DescribeAssetPropertyOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assetId
        case assetModelId
        case assetName
        case assetProperty
        case compositeModel
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assetId)
        assetId = assetIdDecoded
        let assetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assetName)
        assetName = assetNameDecoded
        let assetModelIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assetModelId)
        assetModelId = assetModelIdDecoded
        let assetPropertyDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.Property.self, forKey: .assetProperty)
        assetProperty = assetPropertyDecoded
        let compositeModelDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.CompositeModelProperty.self, forKey: .compositeModel)
        compositeModel = compositeModelDecoded
    }
}

enum DescribeAssetPropertyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeBulkImportJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let jobId = jobId else {
            return nil
        }
        return "/jobs/\(jobId.urlPercentEncoding())"
    }
}

public struct DescribeBulkImportJobInput: Swift.Equatable {
    /// The ID of the job.
    /// This member is required.
    public var jobId: Swift.String?

    public init(
        jobId: Swift.String? = nil
    )
    {
        self.jobId = jobId
    }
}

struct DescribeBulkImportJobInputBody: Swift.Equatable {
}

extension DescribeBulkImportJobInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeBulkImportJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeBulkImportJobOutputBody = try responseDecoder.decode(responseBody: data)
            self.errorReportLocation = output.errorReportLocation
            self.files = output.files
            self.jobConfiguration = output.jobConfiguration
            self.jobCreationDate = output.jobCreationDate
            self.jobId = output.jobId
            self.jobLastUpdateDate = output.jobLastUpdateDate
            self.jobName = output.jobName
            self.jobRoleArn = output.jobRoleArn
            self.jobStatus = output.jobStatus
        } else {
            self.errorReportLocation = nil
            self.files = nil
            self.jobConfiguration = nil
            self.jobCreationDate = nil
            self.jobId = nil
            self.jobLastUpdateDate = nil
            self.jobName = nil
            self.jobRoleArn = nil
            self.jobStatus = nil
        }
    }
}

public struct DescribeBulkImportJobOutput: Swift.Equatable {
    /// The Amazon S3 destination where errors associated with the job creation request are saved.
    /// This member is required.
    public var errorReportLocation: IoTSiteWiseClientTypes.ErrorReportLocation?
    /// The files in the specified Amazon S3 bucket that contain your data.
    /// This member is required.
    public var files: [IoTSiteWiseClientTypes.File]?
    /// Contains the configuration information of a job, such as the file format used to save data in Amazon S3.
    /// This member is required.
    public var jobConfiguration: IoTSiteWiseClientTypes.JobConfiguration?
    /// The date the job was created, in Unix epoch TIME.
    /// This member is required.
    public var jobCreationDate: ClientRuntime.Date?
    /// The ID of the job.
    /// This member is required.
    public var jobId: Swift.String?
    /// The date the job was last updated, in Unix epoch time.
    /// This member is required.
    public var jobLastUpdateDate: ClientRuntime.Date?
    /// The unique name that helps identify the job request.
    /// This member is required.
    public var jobName: Swift.String?
    /// The [ARN](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the IAM role that allows IoT SiteWise to read Amazon S3 data.
    /// This member is required.
    public var jobRoleArn: Swift.String?
    /// The status of the bulk import job can be one of following values.
    ///
    /// * PENDING  IoT SiteWise is waiting for the current bulk import job to finish.
    ///
    /// * CANCELLED  The bulk import job has been canceled.
    ///
    /// * RUNNING  IoT SiteWise is processing your request to import your data from Amazon S3.
    ///
    /// * COMPLETED  IoT SiteWise successfully completed your request to import data from Amazon S3.
    ///
    /// * FAILED  IoT SiteWise couldn't process your request to import data from Amazon S3. You can use logs saved in the specified error report location in Amazon S3 to troubleshoot issues.
    ///
    /// * COMPLETED_WITH_FAILURES  IoT SiteWise completed your request to import data from Amazon S3 with errors. You can use logs saved in the specified error report location in Amazon S3 to troubleshoot issues.
    /// This member is required.
    public var jobStatus: IoTSiteWiseClientTypes.JobStatus?

    public init(
        errorReportLocation: IoTSiteWiseClientTypes.ErrorReportLocation? = nil,
        files: [IoTSiteWiseClientTypes.File]? = nil,
        jobConfiguration: IoTSiteWiseClientTypes.JobConfiguration? = nil,
        jobCreationDate: ClientRuntime.Date? = nil,
        jobId: Swift.String? = nil,
        jobLastUpdateDate: ClientRuntime.Date? = nil,
        jobName: Swift.String? = nil,
        jobRoleArn: Swift.String? = nil,
        jobStatus: IoTSiteWiseClientTypes.JobStatus? = nil
    )
    {
        self.errorReportLocation = errorReportLocation
        self.files = files
        self.jobConfiguration = jobConfiguration
        self.jobCreationDate = jobCreationDate
        self.jobId = jobId
        self.jobLastUpdateDate = jobLastUpdateDate
        self.jobName = jobName
        self.jobRoleArn = jobRoleArn
        self.jobStatus = jobStatus
    }
}

struct DescribeBulkImportJobOutputBody: Swift.Equatable {
    let jobId: Swift.String?
    let jobName: Swift.String?
    let jobStatus: IoTSiteWiseClientTypes.JobStatus?
    let jobRoleArn: Swift.String?
    let files: [IoTSiteWiseClientTypes.File]?
    let errorReportLocation: IoTSiteWiseClientTypes.ErrorReportLocation?
    let jobConfiguration: IoTSiteWiseClientTypes.JobConfiguration?
    let jobCreationDate: ClientRuntime.Date?
    let jobLastUpdateDate: ClientRuntime.Date?
}

extension DescribeBulkImportJobOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorReportLocation
        case files
        case jobConfiguration
        case jobCreationDate
        case jobId
        case jobLastUpdateDate
        case jobName
        case jobRoleArn
        case jobStatus
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobId)
        jobId = jobIdDecoded
        let jobNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobName)
        jobName = jobNameDecoded
        let jobStatusDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.JobStatus.self, forKey: .jobStatus)
        jobStatus = jobStatusDecoded
        let jobRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobRoleArn)
        jobRoleArn = jobRoleArnDecoded
        let filesContainer = try containerValues.decodeIfPresent([IoTSiteWiseClientTypes.File?].self, forKey: .files)
        var filesDecoded0:[IoTSiteWiseClientTypes.File]? = nil
        if let filesContainer = filesContainer {
            filesDecoded0 = [IoTSiteWiseClientTypes.File]()
            for structure0 in filesContainer {
                if let structure0 = structure0 {
                    filesDecoded0?.append(structure0)
                }
            }
        }
        files = filesDecoded0
        let errorReportLocationDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.ErrorReportLocation.self, forKey: .errorReportLocation)
        errorReportLocation = errorReportLocationDecoded
        let jobConfigurationDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.JobConfiguration.self, forKey: .jobConfiguration)
        jobConfiguration = jobConfigurationDecoded
        let jobCreationDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .jobCreationDate)
        jobCreationDate = jobCreationDateDecoded
        let jobLastUpdateDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .jobLastUpdateDate)
        jobLastUpdateDate = jobLastUpdateDateDecoded
    }
}

enum DescribeBulkImportJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeDashboardInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let dashboardId = dashboardId else {
            return nil
        }
        return "/dashboards/\(dashboardId.urlPercentEncoding())"
    }
}

public struct DescribeDashboardInput: Swift.Equatable {
    /// The ID of the dashboard.
    /// This member is required.
    public var dashboardId: Swift.String?

    public init(
        dashboardId: Swift.String? = nil
    )
    {
        self.dashboardId = dashboardId
    }
}

struct DescribeDashboardInputBody: Swift.Equatable {
}

extension DescribeDashboardInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeDashboardOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeDashboardOutputBody = try responseDecoder.decode(responseBody: data)
            self.dashboardArn = output.dashboardArn
            self.dashboardCreationDate = output.dashboardCreationDate
            self.dashboardDefinition = output.dashboardDefinition
            self.dashboardDescription = output.dashboardDescription
            self.dashboardId = output.dashboardId
            self.dashboardLastUpdateDate = output.dashboardLastUpdateDate
            self.dashboardName = output.dashboardName
            self.projectId = output.projectId
        } else {
            self.dashboardArn = nil
            self.dashboardCreationDate = nil
            self.dashboardDefinition = nil
            self.dashboardDescription = nil
            self.dashboardId = nil
            self.dashboardLastUpdateDate = nil
            self.dashboardName = nil
            self.projectId = nil
        }
    }
}

public struct DescribeDashboardOutput: Swift.Equatable {
    /// The [ARN](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the dashboard, which has the following format. arn:${Partition}:iotsitewise:${Region}:${Account}:dashboard/${DashboardId}
    /// This member is required.
    public var dashboardArn: Swift.String?
    /// The date the dashboard was created, in Unix epoch time.
    /// This member is required.
    public var dashboardCreationDate: ClientRuntime.Date?
    /// The dashboard's definition JSON literal. For detailed information, see [Creating dashboards (CLI)](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/create-dashboards-using-aws-cli.html) in the IoT SiteWise User Guide.
    /// This member is required.
    public var dashboardDefinition: Swift.String?
    /// The dashboard's description.
    public var dashboardDescription: Swift.String?
    /// The ID of the dashboard.
    /// This member is required.
    public var dashboardId: Swift.String?
    /// The date the dashboard was last updated, in Unix epoch time.
    /// This member is required.
    public var dashboardLastUpdateDate: ClientRuntime.Date?
    /// The name of the dashboard.
    /// This member is required.
    public var dashboardName: Swift.String?
    /// The ID of the project that the dashboard is in.
    /// This member is required.
    public var projectId: Swift.String?

    public init(
        dashboardArn: Swift.String? = nil,
        dashboardCreationDate: ClientRuntime.Date? = nil,
        dashboardDefinition: Swift.String? = nil,
        dashboardDescription: Swift.String? = nil,
        dashboardId: Swift.String? = nil,
        dashboardLastUpdateDate: ClientRuntime.Date? = nil,
        dashboardName: Swift.String? = nil,
        projectId: Swift.String? = nil
    )
    {
        self.dashboardArn = dashboardArn
        self.dashboardCreationDate = dashboardCreationDate
        self.dashboardDefinition = dashboardDefinition
        self.dashboardDescription = dashboardDescription
        self.dashboardId = dashboardId
        self.dashboardLastUpdateDate = dashboardLastUpdateDate
        self.dashboardName = dashboardName
        self.projectId = projectId
    }
}

struct DescribeDashboardOutputBody: Swift.Equatable {
    let dashboardId: Swift.String?
    let dashboardArn: Swift.String?
    let dashboardName: Swift.String?
    let projectId: Swift.String?
    let dashboardDescription: Swift.String?
    let dashboardDefinition: Swift.String?
    let dashboardCreationDate: ClientRuntime.Date?
    let dashboardLastUpdateDate: ClientRuntime.Date?
}

extension DescribeDashboardOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dashboardArn
        case dashboardCreationDate
        case dashboardDefinition
        case dashboardDescription
        case dashboardId
        case dashboardLastUpdateDate
        case dashboardName
        case projectId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dashboardIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dashboardId)
        dashboardId = dashboardIdDecoded
        let dashboardArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dashboardArn)
        dashboardArn = dashboardArnDecoded
        let dashboardNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dashboardName)
        dashboardName = dashboardNameDecoded
        let projectIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectId)
        projectId = projectIdDecoded
        let dashboardDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dashboardDescription)
        dashboardDescription = dashboardDescriptionDecoded
        let dashboardDefinitionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dashboardDefinition)
        dashboardDefinition = dashboardDefinitionDecoded
        let dashboardCreationDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .dashboardCreationDate)
        dashboardCreationDate = dashboardCreationDateDecoded
        let dashboardLastUpdateDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .dashboardLastUpdateDate)
        dashboardLastUpdateDate = dashboardLastUpdateDateDecoded
    }
}

enum DescribeDashboardOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeDefaultEncryptionConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/configuration/account/encryption"
    }
}

public struct DescribeDefaultEncryptionConfigurationInput: Swift.Equatable {

    public init() { }
}

struct DescribeDefaultEncryptionConfigurationInputBody: Swift.Equatable {
}

extension DescribeDefaultEncryptionConfigurationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeDefaultEncryptionConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeDefaultEncryptionConfigurationOutputBody = try responseDecoder.decode(responseBody: data)
            self.configurationStatus = output.configurationStatus
            self.encryptionType = output.encryptionType
            self.kmsKeyArn = output.kmsKeyArn
        } else {
            self.configurationStatus = nil
            self.encryptionType = nil
            self.kmsKeyArn = nil
        }
    }
}

public struct DescribeDefaultEncryptionConfigurationOutput: Swift.Equatable {
    /// The status of the account configuration. This contains the ConfigurationState. If there's an error, it also contains the ErrorDetails.
    /// This member is required.
    public var configurationStatus: IoTSiteWiseClientTypes.ConfigurationStatus?
    /// The type of encryption used for the encryption configuration.
    /// This member is required.
    public var encryptionType: IoTSiteWiseClientTypes.EncryptionType?
    /// The key ARN of the customer managed key used for KMS encryption if you use KMS_BASED_ENCRYPTION.
    public var kmsKeyArn: Swift.String?

    public init(
        configurationStatus: IoTSiteWiseClientTypes.ConfigurationStatus? = nil,
        encryptionType: IoTSiteWiseClientTypes.EncryptionType? = nil,
        kmsKeyArn: Swift.String? = nil
    )
    {
        self.configurationStatus = configurationStatus
        self.encryptionType = encryptionType
        self.kmsKeyArn = kmsKeyArn
    }
}

struct DescribeDefaultEncryptionConfigurationOutputBody: Swift.Equatable {
    let encryptionType: IoTSiteWiseClientTypes.EncryptionType?
    let kmsKeyArn: Swift.String?
    let configurationStatus: IoTSiteWiseClientTypes.ConfigurationStatus?
}

extension DescribeDefaultEncryptionConfigurationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationStatus
        case encryptionType
        case kmsKeyArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let encryptionTypeDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.EncryptionType.self, forKey: .encryptionType)
        encryptionType = encryptionTypeDecoded
        let kmsKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyArn)
        kmsKeyArn = kmsKeyArnDecoded
        let configurationStatusDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.ConfigurationStatus.self, forKey: .configurationStatus)
        configurationStatus = configurationStatusDecoded
    }
}

enum DescribeDefaultEncryptionConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeGatewayCapabilityConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let gatewayId = gatewayId else {
            return nil
        }
        guard let capabilityNamespace = capabilityNamespace else {
            return nil
        }
        return "/20200301/gateways/\(gatewayId.urlPercentEncoding())/capability/\(capabilityNamespace.urlPercentEncoding())"
    }
}

public struct DescribeGatewayCapabilityConfigurationInput: Swift.Equatable {
    /// The namespace of the capability configuration. For example, if you configure OPC-UA sources from the IoT SiteWise console, your OPC-UA capability configuration has the namespace iotsitewise:opcuacollector:version, where version is a number such as 1.
    /// This member is required.
    public var capabilityNamespace: Swift.String?
    /// The ID of the gateway that defines the capability configuration.
    /// This member is required.
    public var gatewayId: Swift.String?

    public init(
        capabilityNamespace: Swift.String? = nil,
        gatewayId: Swift.String? = nil
    )
    {
        self.capabilityNamespace = capabilityNamespace
        self.gatewayId = gatewayId
    }
}

struct DescribeGatewayCapabilityConfigurationInputBody: Swift.Equatable {
}

extension DescribeGatewayCapabilityConfigurationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeGatewayCapabilityConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeGatewayCapabilityConfigurationOutputBody = try responseDecoder.decode(responseBody: data)
            self.capabilityConfiguration = output.capabilityConfiguration
            self.capabilityNamespace = output.capabilityNamespace
            self.capabilitySyncStatus = output.capabilitySyncStatus
            self.gatewayId = output.gatewayId
        } else {
            self.capabilityConfiguration = nil
            self.capabilityNamespace = nil
            self.capabilitySyncStatus = nil
            self.gatewayId = nil
        }
    }
}

public struct DescribeGatewayCapabilityConfigurationOutput: Swift.Equatable {
    /// The JSON document that defines the gateway capability's configuration. For more information, see [Configuring data sources (CLI)](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/configure-sources.html#configure-source-cli) in the IoT SiteWise User Guide.
    /// This member is required.
    public var capabilityConfiguration: Swift.String?
    /// The namespace of the gateway capability.
    /// This member is required.
    public var capabilityNamespace: Swift.String?
    /// The synchronization status of the capability configuration. The sync status can be one of the following:
    ///
    /// * IN_SYNC  The gateway is running the capability configuration.
    ///
    /// * OUT_OF_SYNC  The gateway hasn't received the capability configuration.
    ///
    /// * SYNC_FAILED  The gateway rejected the capability configuration.
    /// This member is required.
    public var capabilitySyncStatus: IoTSiteWiseClientTypes.CapabilitySyncStatus?
    /// The ID of the gateway that defines the capability configuration.
    /// This member is required.
    public var gatewayId: Swift.String?

    public init(
        capabilityConfiguration: Swift.String? = nil,
        capabilityNamespace: Swift.String? = nil,
        capabilitySyncStatus: IoTSiteWiseClientTypes.CapabilitySyncStatus? = nil,
        gatewayId: Swift.String? = nil
    )
    {
        self.capabilityConfiguration = capabilityConfiguration
        self.capabilityNamespace = capabilityNamespace
        self.capabilitySyncStatus = capabilitySyncStatus
        self.gatewayId = gatewayId
    }
}

struct DescribeGatewayCapabilityConfigurationOutputBody: Swift.Equatable {
    let gatewayId: Swift.String?
    let capabilityNamespace: Swift.String?
    let capabilityConfiguration: Swift.String?
    let capabilitySyncStatus: IoTSiteWiseClientTypes.CapabilitySyncStatus?
}

extension DescribeGatewayCapabilityConfigurationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case capabilityConfiguration
        case capabilityNamespace
        case capabilitySyncStatus
        case gatewayId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayId)
        gatewayId = gatewayIdDecoded
        let capabilityNamespaceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .capabilityNamespace)
        capabilityNamespace = capabilityNamespaceDecoded
        let capabilityConfigurationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .capabilityConfiguration)
        capabilityConfiguration = capabilityConfigurationDecoded
        let capabilitySyncStatusDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.CapabilitySyncStatus.self, forKey: .capabilitySyncStatus)
        capabilitySyncStatus = capabilitySyncStatusDecoded
    }
}

enum DescribeGatewayCapabilityConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeGatewayInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let gatewayId = gatewayId else {
            return nil
        }
        return "/20200301/gateways/\(gatewayId.urlPercentEncoding())"
    }
}

public struct DescribeGatewayInput: Swift.Equatable {
    /// The ID of the gateway device.
    /// This member is required.
    public var gatewayId: Swift.String?

    public init(
        gatewayId: Swift.String? = nil
    )
    {
        self.gatewayId = gatewayId
    }
}

struct DescribeGatewayInputBody: Swift.Equatable {
}

extension DescribeGatewayInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeGatewayOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeGatewayOutputBody = try responseDecoder.decode(responseBody: data)
            self.creationDate = output.creationDate
            self.gatewayArn = output.gatewayArn
            self.gatewayCapabilitySummaries = output.gatewayCapabilitySummaries
            self.gatewayId = output.gatewayId
            self.gatewayName = output.gatewayName
            self.gatewayPlatform = output.gatewayPlatform
            self.lastUpdateDate = output.lastUpdateDate
        } else {
            self.creationDate = nil
            self.gatewayArn = nil
            self.gatewayCapabilitySummaries = nil
            self.gatewayId = nil
            self.gatewayName = nil
            self.gatewayPlatform = nil
            self.lastUpdateDate = nil
        }
    }
}

public struct DescribeGatewayOutput: Swift.Equatable {
    /// The date the gateway was created, in Unix epoch time.
    /// This member is required.
    public var creationDate: ClientRuntime.Date?
    /// The [ARN](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the gateway, which has the following format. arn:${Partition}:iotsitewise:${Region}:${Account}:gateway/${GatewayId}
    /// This member is required.
    public var gatewayArn: Swift.String?
    /// A list of gateway capability summaries that each contain a namespace and status. Each gateway capability defines data sources for the gateway. To retrieve a capability configuration's definition, use [DescribeGatewayCapabilityConfiguration](https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_DescribeGatewayCapabilityConfiguration.html).
    /// This member is required.
    public var gatewayCapabilitySummaries: [IoTSiteWiseClientTypes.GatewayCapabilitySummary]?
    /// The ID of the gateway device.
    /// This member is required.
    public var gatewayId: Swift.String?
    /// The name of the gateway.
    /// This member is required.
    public var gatewayName: Swift.String?
    /// The gateway's platform.
    public var gatewayPlatform: IoTSiteWiseClientTypes.GatewayPlatform?
    /// The date the gateway was last updated, in Unix epoch time.
    /// This member is required.
    public var lastUpdateDate: ClientRuntime.Date?

    public init(
        creationDate: ClientRuntime.Date? = nil,
        gatewayArn: Swift.String? = nil,
        gatewayCapabilitySummaries: [IoTSiteWiseClientTypes.GatewayCapabilitySummary]? = nil,
        gatewayId: Swift.String? = nil,
        gatewayName: Swift.String? = nil,
        gatewayPlatform: IoTSiteWiseClientTypes.GatewayPlatform? = nil,
        lastUpdateDate: ClientRuntime.Date? = nil
    )
    {
        self.creationDate = creationDate
        self.gatewayArn = gatewayArn
        self.gatewayCapabilitySummaries = gatewayCapabilitySummaries
        self.gatewayId = gatewayId
        self.gatewayName = gatewayName
        self.gatewayPlatform = gatewayPlatform
        self.lastUpdateDate = lastUpdateDate
    }
}

struct DescribeGatewayOutputBody: Swift.Equatable {
    let gatewayId: Swift.String?
    let gatewayName: Swift.String?
    let gatewayArn: Swift.String?
    let gatewayPlatform: IoTSiteWiseClientTypes.GatewayPlatform?
    let gatewayCapabilitySummaries: [IoTSiteWiseClientTypes.GatewayCapabilitySummary]?
    let creationDate: ClientRuntime.Date?
    let lastUpdateDate: ClientRuntime.Date?
}

extension DescribeGatewayOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationDate
        case gatewayArn
        case gatewayCapabilitySummaries
        case gatewayId
        case gatewayName
        case gatewayPlatform
        case lastUpdateDate
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayId)
        gatewayId = gatewayIdDecoded
        let gatewayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayName)
        gatewayName = gatewayNameDecoded
        let gatewayArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayArn)
        gatewayArn = gatewayArnDecoded
        let gatewayPlatformDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.GatewayPlatform.self, forKey: .gatewayPlatform)
        gatewayPlatform = gatewayPlatformDecoded
        let gatewayCapabilitySummariesContainer = try containerValues.decodeIfPresent([IoTSiteWiseClientTypes.GatewayCapabilitySummary?].self, forKey: .gatewayCapabilitySummaries)
        var gatewayCapabilitySummariesDecoded0:[IoTSiteWiseClientTypes.GatewayCapabilitySummary]? = nil
        if let gatewayCapabilitySummariesContainer = gatewayCapabilitySummariesContainer {
            gatewayCapabilitySummariesDecoded0 = [IoTSiteWiseClientTypes.GatewayCapabilitySummary]()
            for structure0 in gatewayCapabilitySummariesContainer {
                if let structure0 = structure0 {
                    gatewayCapabilitySummariesDecoded0?.append(structure0)
                }
            }
        }
        gatewayCapabilitySummaries = gatewayCapabilitySummariesDecoded0
        let creationDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDate)
        creationDate = creationDateDecoded
        let lastUpdateDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdateDate)
        lastUpdateDate = lastUpdateDateDecoded
    }
}

enum DescribeGatewayOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeLoggingOptionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/logging"
    }
}

public struct DescribeLoggingOptionsInput: Swift.Equatable {

    public init() { }
}

struct DescribeLoggingOptionsInputBody: Swift.Equatable {
}

extension DescribeLoggingOptionsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeLoggingOptionsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeLoggingOptionsOutputBody = try responseDecoder.decode(responseBody: data)
            self.loggingOptions = output.loggingOptions
        } else {
            self.loggingOptions = nil
        }
    }
}

public struct DescribeLoggingOptionsOutput: Swift.Equatable {
    /// The current logging options.
    /// This member is required.
    public var loggingOptions: IoTSiteWiseClientTypes.LoggingOptions?

    public init(
        loggingOptions: IoTSiteWiseClientTypes.LoggingOptions? = nil
    )
    {
        self.loggingOptions = loggingOptions
    }
}

struct DescribeLoggingOptionsOutputBody: Swift.Equatable {
    let loggingOptions: IoTSiteWiseClientTypes.LoggingOptions?
}

extension DescribeLoggingOptionsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case loggingOptions
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let loggingOptionsDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.LoggingOptions.self, forKey: .loggingOptions)
        loggingOptions = loggingOptionsDecoded
    }
}

enum DescribeLoggingOptionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribePortalInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let portalId = portalId else {
            return nil
        }
        return "/portals/\(portalId.urlPercentEncoding())"
    }
}

public struct DescribePortalInput: Swift.Equatable {
    /// The ID of the portal.
    /// This member is required.
    public var portalId: Swift.String?

    public init(
        portalId: Swift.String? = nil
    )
    {
        self.portalId = portalId
    }
}

struct DescribePortalInputBody: Swift.Equatable {
}

extension DescribePortalInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribePortalOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribePortalOutputBody = try responseDecoder.decode(responseBody: data)
            self.alarms = output.alarms
            self.notificationSenderEmail = output.notificationSenderEmail
            self.portalArn = output.portalArn
            self.portalAuthMode = output.portalAuthMode
            self.portalClientId = output.portalClientId
            self.portalContactEmail = output.portalContactEmail
            self.portalCreationDate = output.portalCreationDate
            self.portalDescription = output.portalDescription
            self.portalId = output.portalId
            self.portalLastUpdateDate = output.portalLastUpdateDate
            self.portalLogoImageLocation = output.portalLogoImageLocation
            self.portalName = output.portalName
            self.portalStartUrl = output.portalStartUrl
            self.portalStatus = output.portalStatus
            self.roleArn = output.roleArn
        } else {
            self.alarms = nil
            self.notificationSenderEmail = nil
            self.portalArn = nil
            self.portalAuthMode = nil
            self.portalClientId = nil
            self.portalContactEmail = nil
            self.portalCreationDate = nil
            self.portalDescription = nil
            self.portalId = nil
            self.portalLastUpdateDate = nil
            self.portalLogoImageLocation = nil
            self.portalName = nil
            self.portalStartUrl = nil
            self.portalStatus = nil
            self.roleArn = nil
        }
    }
}

public struct DescribePortalOutput: Swift.Equatable {
    /// Contains the configuration information of an alarm created in an IoT SiteWise Monitor portal.
    public var alarms: IoTSiteWiseClientTypes.Alarms?
    /// The email address that sends alarm notifications.
    public var notificationSenderEmail: Swift.String?
    /// The [ARN](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the portal, which has the following format. arn:${Partition}:iotsitewise:${Region}:${Account}:portal/${PortalId}
    /// This member is required.
    public var portalArn: Swift.String?
    /// The service to use to authenticate users to the portal.
    public var portalAuthMode: IoTSiteWiseClientTypes.AuthMode?
    /// The IAM Identity Center application generated client ID (used with IAM Identity Center APIs). IoT SiteWise includes portalClientId for only portals that use IAM Identity Center to authenticate users.
    /// This member is required.
    public var portalClientId: Swift.String?
    /// The Amazon Web Services administrator's contact email address.
    /// This member is required.
    public var portalContactEmail: Swift.String?
    /// The date the portal was created, in Unix epoch time.
    /// This member is required.
    public var portalCreationDate: ClientRuntime.Date?
    /// The portal's description.
    public var portalDescription: Swift.String?
    /// The ID of the portal.
    /// This member is required.
    public var portalId: Swift.String?
    /// The date the portal was last updated, in Unix epoch time.
    /// This member is required.
    public var portalLastUpdateDate: ClientRuntime.Date?
    /// The portal's logo image, which is available at a URL.
    public var portalLogoImageLocation: IoTSiteWiseClientTypes.ImageLocation?
    /// The name of the portal.
    /// This member is required.
    public var portalName: Swift.String?
    /// The URL for the IoT SiteWise Monitor portal. You can use this URL to access portals that use IAM Identity Center for authentication. For portals that use IAM for authentication, you must use the IoT SiteWise console to get a URL that you can use to access the portal.
    /// This member is required.
    public var portalStartUrl: Swift.String?
    /// The current status of the portal, which contains a state and any error message.
    /// This member is required.
    public var portalStatus: IoTSiteWiseClientTypes.PortalStatus?
    /// The [ARN](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the service role that allows the portal's users to access your IoT SiteWise resources on your behalf. For more information, see [Using service roles for IoT SiteWise Monitor](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/monitor-service-role.html) in the IoT SiteWise User Guide.
    public var roleArn: Swift.String?

    public init(
        alarms: IoTSiteWiseClientTypes.Alarms? = nil,
        notificationSenderEmail: Swift.String? = nil,
        portalArn: Swift.String? = nil,
        portalAuthMode: IoTSiteWiseClientTypes.AuthMode? = nil,
        portalClientId: Swift.String? = nil,
        portalContactEmail: Swift.String? = nil,
        portalCreationDate: ClientRuntime.Date? = nil,
        portalDescription: Swift.String? = nil,
        portalId: Swift.String? = nil,
        portalLastUpdateDate: ClientRuntime.Date? = nil,
        portalLogoImageLocation: IoTSiteWiseClientTypes.ImageLocation? = nil,
        portalName: Swift.String? = nil,
        portalStartUrl: Swift.String? = nil,
        portalStatus: IoTSiteWiseClientTypes.PortalStatus? = nil,
        roleArn: Swift.String? = nil
    )
    {
        self.alarms = alarms
        self.notificationSenderEmail = notificationSenderEmail
        self.portalArn = portalArn
        self.portalAuthMode = portalAuthMode
        self.portalClientId = portalClientId
        self.portalContactEmail = portalContactEmail
        self.portalCreationDate = portalCreationDate
        self.portalDescription = portalDescription
        self.portalId = portalId
        self.portalLastUpdateDate = portalLastUpdateDate
        self.portalLogoImageLocation = portalLogoImageLocation
        self.portalName = portalName
        self.portalStartUrl = portalStartUrl
        self.portalStatus = portalStatus
        self.roleArn = roleArn
    }
}

struct DescribePortalOutputBody: Swift.Equatable {
    let portalId: Swift.String?
    let portalArn: Swift.String?
    let portalName: Swift.String?
    let portalDescription: Swift.String?
    let portalClientId: Swift.String?
    let portalStartUrl: Swift.String?
    let portalContactEmail: Swift.String?
    let portalStatus: IoTSiteWiseClientTypes.PortalStatus?
    let portalCreationDate: ClientRuntime.Date?
    let portalLastUpdateDate: ClientRuntime.Date?
    let portalLogoImageLocation: IoTSiteWiseClientTypes.ImageLocation?
    let roleArn: Swift.String?
    let portalAuthMode: IoTSiteWiseClientTypes.AuthMode?
    let notificationSenderEmail: Swift.String?
    let alarms: IoTSiteWiseClientTypes.Alarms?
}

extension DescribePortalOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alarms
        case notificationSenderEmail
        case portalArn
        case portalAuthMode
        case portalClientId
        case portalContactEmail
        case portalCreationDate
        case portalDescription
        case portalId
        case portalLastUpdateDate
        case portalLogoImageLocation
        case portalName
        case portalStartUrl
        case portalStatus
        case roleArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let portalIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .portalId)
        portalId = portalIdDecoded
        let portalArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .portalArn)
        portalArn = portalArnDecoded
        let portalNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .portalName)
        portalName = portalNameDecoded
        let portalDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .portalDescription)
        portalDescription = portalDescriptionDecoded
        let portalClientIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .portalClientId)
        portalClientId = portalClientIdDecoded
        let portalStartUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .portalStartUrl)
        portalStartUrl = portalStartUrlDecoded
        let portalContactEmailDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .portalContactEmail)
        portalContactEmail = portalContactEmailDecoded
        let portalStatusDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.PortalStatus.self, forKey: .portalStatus)
        portalStatus = portalStatusDecoded
        let portalCreationDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .portalCreationDate)
        portalCreationDate = portalCreationDateDecoded
        let portalLastUpdateDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .portalLastUpdateDate)
        portalLastUpdateDate = portalLastUpdateDateDecoded
        let portalLogoImageLocationDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.ImageLocation.self, forKey: .portalLogoImageLocation)
        portalLogoImageLocation = portalLogoImageLocationDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let portalAuthModeDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.AuthMode.self, forKey: .portalAuthMode)
        portalAuthMode = portalAuthModeDecoded
        let notificationSenderEmailDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .notificationSenderEmail)
        notificationSenderEmail = notificationSenderEmailDecoded
        let alarmsDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.Alarms.self, forKey: .alarms)
        alarms = alarmsDecoded
    }
}

enum DescribePortalOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeProjectInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let projectId = projectId else {
            return nil
        }
        return "/projects/\(projectId.urlPercentEncoding())"
    }
}

public struct DescribeProjectInput: Swift.Equatable {
    /// The ID of the project.
    /// This member is required.
    public var projectId: Swift.String?

    public init(
        projectId: Swift.String? = nil
    )
    {
        self.projectId = projectId
    }
}

struct DescribeProjectInputBody: Swift.Equatable {
}

extension DescribeProjectInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeProjectOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeProjectOutputBody = try responseDecoder.decode(responseBody: data)
            self.portalId = output.portalId
            self.projectArn = output.projectArn
            self.projectCreationDate = output.projectCreationDate
            self.projectDescription = output.projectDescription
            self.projectId = output.projectId
            self.projectLastUpdateDate = output.projectLastUpdateDate
            self.projectName = output.projectName
        } else {
            self.portalId = nil
            self.projectArn = nil
            self.projectCreationDate = nil
            self.projectDescription = nil
            self.projectId = nil
            self.projectLastUpdateDate = nil
            self.projectName = nil
        }
    }
}

public struct DescribeProjectOutput: Swift.Equatable {
    /// The ID of the portal that the project is in.
    /// This member is required.
    public var portalId: Swift.String?
    /// The [ARN](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the project, which has the following format. arn:${Partition}:iotsitewise:${Region}:${Account}:project/${ProjectId}
    /// This member is required.
    public var projectArn: Swift.String?
    /// The date the project was created, in Unix epoch time.
    /// This member is required.
    public var projectCreationDate: ClientRuntime.Date?
    /// The project's description.
    public var projectDescription: Swift.String?
    /// The ID of the project.
    /// This member is required.
    public var projectId: Swift.String?
    /// The date the project was last updated, in Unix epoch time.
    /// This member is required.
    public var projectLastUpdateDate: ClientRuntime.Date?
    /// The name of the project.
    /// This member is required.
    public var projectName: Swift.String?

    public init(
        portalId: Swift.String? = nil,
        projectArn: Swift.String? = nil,
        projectCreationDate: ClientRuntime.Date? = nil,
        projectDescription: Swift.String? = nil,
        projectId: Swift.String? = nil,
        projectLastUpdateDate: ClientRuntime.Date? = nil,
        projectName: Swift.String? = nil
    )
    {
        self.portalId = portalId
        self.projectArn = projectArn
        self.projectCreationDate = projectCreationDate
        self.projectDescription = projectDescription
        self.projectId = projectId
        self.projectLastUpdateDate = projectLastUpdateDate
        self.projectName = projectName
    }
}

struct DescribeProjectOutputBody: Swift.Equatable {
    let projectId: Swift.String?
    let projectArn: Swift.String?
    let projectName: Swift.String?
    let portalId: Swift.String?
    let projectDescription: Swift.String?
    let projectCreationDate: ClientRuntime.Date?
    let projectLastUpdateDate: ClientRuntime.Date?
}

extension DescribeProjectOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case portalId
        case projectArn
        case projectCreationDate
        case projectDescription
        case projectId
        case projectLastUpdateDate
        case projectName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let projectIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectId)
        projectId = projectIdDecoded
        let projectArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectArn)
        projectArn = projectArnDecoded
        let projectNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectName)
        projectName = projectNameDecoded
        let portalIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .portalId)
        portalId = portalIdDecoded
        let projectDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectDescription)
        projectDescription = projectDescriptionDecoded
        let projectCreationDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .projectCreationDate)
        projectCreationDate = projectCreationDateDecoded
        let projectLastUpdateDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .projectLastUpdateDate)
        projectLastUpdateDate = projectLastUpdateDateDecoded
    }
}

enum DescribeProjectOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeStorageConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/configuration/account/storage"
    }
}

public struct DescribeStorageConfigurationInput: Swift.Equatable {

    public init() { }
}

struct DescribeStorageConfigurationInputBody: Swift.Equatable {
}

extension DescribeStorageConfigurationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeStorageConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeStorageConfigurationOutputBody = try responseDecoder.decode(responseBody: data)
            self.configurationStatus = output.configurationStatus
            self.disassociatedDataStorage = output.disassociatedDataStorage
            self.lastUpdateDate = output.lastUpdateDate
            self.multiLayerStorage = output.multiLayerStorage
            self.retentionPeriod = output.retentionPeriod
            self.storageType = output.storageType
        } else {
            self.configurationStatus = nil
            self.disassociatedDataStorage = nil
            self.lastUpdateDate = nil
            self.multiLayerStorage = nil
            self.retentionPeriod = nil
            self.storageType = nil
        }
    }
}

public struct DescribeStorageConfigurationOutput: Swift.Equatable {
    /// Contains current status information for the configuration.
    /// This member is required.
    public var configurationStatus: IoTSiteWiseClientTypes.ConfigurationStatus?
    /// Contains the storage configuration for time series (data streams) that aren't associated with asset properties. The disassociatedDataStorage can be one of the following values:
    ///
    /// * ENABLED  IoT SiteWise accepts time series that aren't associated with asset properties. After the disassociatedDataStorage is enabled, you can't disable it.
    ///
    /// * DISABLED  IoT SiteWise doesn't accept time series (data streams) that aren't associated with asset properties.
    ///
    ///
    /// For more information, see [Data streams](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/data-streams.html) in the IoT SiteWise User Guide.
    public var disassociatedDataStorage: IoTSiteWiseClientTypes.DisassociatedDataStorageState?
    /// The date the storage configuration was last updated, in Unix epoch time.
    public var lastUpdateDate: ClientRuntime.Date?
    /// Contains information about the storage destination.
    public var multiLayerStorage: IoTSiteWiseClientTypes.MultiLayerStorage?
    /// How many days your data is kept in the hot tier. By default, your data is kept indefinitely in the hot tier.
    public var retentionPeriod: IoTSiteWiseClientTypes.RetentionPeriod?
    /// The storage tier that you specified for your data. The storageType parameter can be one of the following values:
    ///
    /// * SITEWISE_DEFAULT_STORAGE  IoT SiteWise saves your data into the hot tier. The hot tier is a service-managed database.
    ///
    /// * MULTI_LAYER_STORAGE  IoT SiteWise saves your data in both the cold tier and the hot tier. The cold tier is a customer-managed Amazon S3 bucket.
    /// This member is required.
    public var storageType: IoTSiteWiseClientTypes.StorageType?

    public init(
        configurationStatus: IoTSiteWiseClientTypes.ConfigurationStatus? = nil,
        disassociatedDataStorage: IoTSiteWiseClientTypes.DisassociatedDataStorageState? = nil,
        lastUpdateDate: ClientRuntime.Date? = nil,
        multiLayerStorage: IoTSiteWiseClientTypes.MultiLayerStorage? = nil,
        retentionPeriod: IoTSiteWiseClientTypes.RetentionPeriod? = nil,
        storageType: IoTSiteWiseClientTypes.StorageType? = nil
    )
    {
        self.configurationStatus = configurationStatus
        self.disassociatedDataStorage = disassociatedDataStorage
        self.lastUpdateDate = lastUpdateDate
        self.multiLayerStorage = multiLayerStorage
        self.retentionPeriod = retentionPeriod
        self.storageType = storageType
    }
}

struct DescribeStorageConfigurationOutputBody: Swift.Equatable {
    let storageType: IoTSiteWiseClientTypes.StorageType?
    let multiLayerStorage: IoTSiteWiseClientTypes.MultiLayerStorage?
    let disassociatedDataStorage: IoTSiteWiseClientTypes.DisassociatedDataStorageState?
    let retentionPeriod: IoTSiteWiseClientTypes.RetentionPeriod?
    let configurationStatus: IoTSiteWiseClientTypes.ConfigurationStatus?
    let lastUpdateDate: ClientRuntime.Date?
}

extension DescribeStorageConfigurationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationStatus
        case disassociatedDataStorage
        case lastUpdateDate
        case multiLayerStorage
        case retentionPeriod
        case storageType
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let storageTypeDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.StorageType.self, forKey: .storageType)
        storageType = storageTypeDecoded
        let multiLayerStorageDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.MultiLayerStorage.self, forKey: .multiLayerStorage)
        multiLayerStorage = multiLayerStorageDecoded
        let disassociatedDataStorageDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.DisassociatedDataStorageState.self, forKey: .disassociatedDataStorage)
        disassociatedDataStorage = disassociatedDataStorageDecoded
        let retentionPeriodDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.RetentionPeriod.self, forKey: .retentionPeriod)
        retentionPeriod = retentionPeriodDecoded
        let configurationStatusDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.ConfigurationStatus.self, forKey: .configurationStatus)
        configurationStatus = configurationStatusDecoded
        let lastUpdateDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdateDate)
        lastUpdateDate = lastUpdateDateDecoded
    }
}

enum DescribeStorageConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictingOperationException": return try await ConflictingOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeTimeSeriesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let assetId = assetId {
                let assetIdQueryItem = ClientRuntime.URLQueryItem(name: "assetId".urlPercentEncoding(), value: Swift.String(assetId).urlPercentEncoding())
                items.append(assetIdQueryItem)
            }
            if let alias = alias {
                let aliasQueryItem = ClientRuntime.URLQueryItem(name: "alias".urlPercentEncoding(), value: Swift.String(alias).urlPercentEncoding())
                items.append(aliasQueryItem)
            }
            if let propertyId = propertyId {
                let propertyIdQueryItem = ClientRuntime.URLQueryItem(name: "propertyId".urlPercentEncoding(), value: Swift.String(propertyId).urlPercentEncoding())
                items.append(propertyIdQueryItem)
            }
            return items
        }
    }
}

extension DescribeTimeSeriesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/timeseries/describe"
    }
}

public struct DescribeTimeSeriesInput: Swift.Equatable {
    /// The alias that identifies the time series.
    public var alias: Swift.String?
    /// The ID of the asset in which the asset property was created.
    public var assetId: Swift.String?
    /// The ID of the asset property.
    public var propertyId: Swift.String?

    public init(
        alias: Swift.String? = nil,
        assetId: Swift.String? = nil,
        propertyId: Swift.String? = nil
    )
    {
        self.alias = alias
        self.assetId = assetId
        self.propertyId = propertyId
    }
}

struct DescribeTimeSeriesInputBody: Swift.Equatable {
}

extension DescribeTimeSeriesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeTimeSeriesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeTimeSeriesOutputBody = try responseDecoder.decode(responseBody: data)
            self.alias = output.alias
            self.assetId = output.assetId
            self.dataType = output.dataType
            self.dataTypeSpec = output.dataTypeSpec
            self.propertyId = output.propertyId
            self.timeSeriesArn = output.timeSeriesArn
            self.timeSeriesCreationDate = output.timeSeriesCreationDate
            self.timeSeriesId = output.timeSeriesId
            self.timeSeriesLastUpdateDate = output.timeSeriesLastUpdateDate
        } else {
            self.alias = nil
            self.assetId = nil
            self.dataType = nil
            self.dataTypeSpec = nil
            self.propertyId = nil
            self.timeSeriesArn = nil
            self.timeSeriesCreationDate = nil
            self.timeSeriesId = nil
            self.timeSeriesLastUpdateDate = nil
        }
    }
}

public struct DescribeTimeSeriesOutput: Swift.Equatable {
    /// The alias that identifies the time series.
    public var alias: Swift.String?
    /// The ID of the asset in which the asset property was created.
    public var assetId: Swift.String?
    /// The data type of the time series. If you specify STRUCT, you must also specify dataTypeSpec to identify the type of the structure for this time series.
    /// This member is required.
    public var dataType: IoTSiteWiseClientTypes.PropertyDataType?
    /// The data type of the structure for this time series. This parameter is required for time series that have the STRUCT data type. The options for this parameter depend on the type of the composite model in which you created the asset property that is associated with your time series. Use AWS/ALARM_STATE for alarm state in alarm composite models.
    public var dataTypeSpec: Swift.String?
    /// The ID of the asset property.
    public var propertyId: Swift.String?
    /// The [ARN](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the time series, which has the following format. arn:${Partition}:iotsitewise:${Region}:${Account}:time-series/${TimeSeriesId}
    /// This member is required.
    public var timeSeriesArn: Swift.String?
    /// The date that the time series was created, in Unix epoch time.
    /// This member is required.
    public var timeSeriesCreationDate: ClientRuntime.Date?
    /// The ID of the time series.
    /// This member is required.
    public var timeSeriesId: Swift.String?
    /// The date that the time series was last updated, in Unix epoch time.
    /// This member is required.
    public var timeSeriesLastUpdateDate: ClientRuntime.Date?

    public init(
        alias: Swift.String? = nil,
        assetId: Swift.String? = nil,
        dataType: IoTSiteWiseClientTypes.PropertyDataType? = nil,
        dataTypeSpec: Swift.String? = nil,
        propertyId: Swift.String? = nil,
        timeSeriesArn: Swift.String? = nil,
        timeSeriesCreationDate: ClientRuntime.Date? = nil,
        timeSeriesId: Swift.String? = nil,
        timeSeriesLastUpdateDate: ClientRuntime.Date? = nil
    )
    {
        self.alias = alias
        self.assetId = assetId
        self.dataType = dataType
        self.dataTypeSpec = dataTypeSpec
        self.propertyId = propertyId
        self.timeSeriesArn = timeSeriesArn
        self.timeSeriesCreationDate = timeSeriesCreationDate
        self.timeSeriesId = timeSeriesId
        self.timeSeriesLastUpdateDate = timeSeriesLastUpdateDate
    }
}

struct DescribeTimeSeriesOutputBody: Swift.Equatable {
    let assetId: Swift.String?
    let propertyId: Swift.String?
    let alias: Swift.String?
    let timeSeriesId: Swift.String?
    let dataType: IoTSiteWiseClientTypes.PropertyDataType?
    let dataTypeSpec: Swift.String?
    let timeSeriesCreationDate: ClientRuntime.Date?
    let timeSeriesLastUpdateDate: ClientRuntime.Date?
    let timeSeriesArn: Swift.String?
}

extension DescribeTimeSeriesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alias
        case assetId
        case dataType
        case dataTypeSpec
        case propertyId
        case timeSeriesArn
        case timeSeriesCreationDate
        case timeSeriesId
        case timeSeriesLastUpdateDate
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assetId)
        assetId = assetIdDecoded
        let propertyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .propertyId)
        propertyId = propertyIdDecoded
        let aliasDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .alias)
        alias = aliasDecoded
        let timeSeriesIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .timeSeriesId)
        timeSeriesId = timeSeriesIdDecoded
        let dataTypeDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.PropertyDataType.self, forKey: .dataType)
        dataType = dataTypeDecoded
        let dataTypeSpecDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataTypeSpec)
        dataTypeSpec = dataTypeSpecDecoded
        let timeSeriesCreationDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .timeSeriesCreationDate)
        timeSeriesCreationDate = timeSeriesCreationDateDecoded
        let timeSeriesLastUpdateDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .timeSeriesLastUpdateDate)
        timeSeriesLastUpdateDate = timeSeriesLastUpdateDateDecoded
        let timeSeriesArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .timeSeriesArn)
        timeSeriesArn = timeSeriesArnDecoded
    }
}

enum DescribeTimeSeriesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension IoTSiteWiseClientTypes.DetailedError: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code
        case message
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let code = self.code {
            try encodeContainer.encode(code.rawValue, forKey: .code)
        }
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.DetailedErrorCode.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension IoTSiteWiseClientTypes {
    /// Contains detailed error information.
    public struct DetailedError: Swift.Equatable {
        /// The error code.
        /// This member is required.
        public var code: IoTSiteWiseClientTypes.DetailedErrorCode?
        /// The error message.
        /// This member is required.
        public var message: Swift.String?

        public init(
            code: IoTSiteWiseClientTypes.DetailedErrorCode? = nil,
            message: Swift.String? = nil
        )
        {
            self.code = code
            self.message = message
        }
    }

}

extension IoTSiteWiseClientTypes {
    public enum DetailedErrorCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case incompatibleComputeLocation
        case incompatibleForwardingConfiguration
        case sdkUnknown(Swift.String)

        public static var allCases: [DetailedErrorCode] {
            return [
                .incompatibleComputeLocation,
                .incompatibleForwardingConfiguration,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .incompatibleComputeLocation: return "INCOMPATIBLE_COMPUTE_LOCATION"
            case .incompatibleForwardingConfiguration: return "INCOMPATIBLE_FORWARDING_CONFIGURATION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DetailedErrorCode(rawValue: rawValue) ?? DetailedErrorCode.sdkUnknown(rawValue)
        }
    }
}

extension DisassociateAssetsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case childAssetId
        case clientToken
        case hierarchyId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let childAssetId = self.childAssetId {
            try encodeContainer.encode(childAssetId, forKey: .childAssetId)
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let hierarchyId = self.hierarchyId {
            try encodeContainer.encode(hierarchyId, forKey: .hierarchyId)
        }
    }
}

extension DisassociateAssetsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let assetId = assetId else {
            return nil
        }
        return "/assets/\(assetId.urlPercentEncoding())/disassociate"
    }
}

public struct DisassociateAssetsInput: Swift.Equatable {
    /// The ID of the parent asset from which to disassociate the child asset.
    /// This member is required.
    public var assetId: Swift.String?
    /// The ID of the child asset to disassociate.
    /// This member is required.
    public var childAssetId: Swift.String?
    /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
    public var clientToken: Swift.String?
    /// The ID of a hierarchy in the parent asset's model. Hierarchies allow different groupings of assets to be formed that all come from the same asset model. You can use the hierarchy ID to identify the correct asset to disassociate. For more information, see [Asset hierarchies](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/asset-hierarchies.html) in the IoT SiteWise User Guide.
    /// This member is required.
    public var hierarchyId: Swift.String?

    public init(
        assetId: Swift.String? = nil,
        childAssetId: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        hierarchyId: Swift.String? = nil
    )
    {
        self.assetId = assetId
        self.childAssetId = childAssetId
        self.clientToken = clientToken
        self.hierarchyId = hierarchyId
    }
}

struct DisassociateAssetsInputBody: Swift.Equatable {
    let hierarchyId: Swift.String?
    let childAssetId: Swift.String?
    let clientToken: Swift.String?
}

extension DisassociateAssetsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case childAssetId
        case clientToken
        case hierarchyId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hierarchyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hierarchyId)
        hierarchyId = hierarchyIdDecoded
        let childAssetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .childAssetId)
        childAssetId = childAssetIdDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension DisassociateAssetsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DisassociateAssetsOutput: Swift.Equatable {

    public init() { }
}

enum DisassociateAssetsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictingOperationException": return try await ConflictingOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DisassociateTimeSeriesFromAssetPropertyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
    }
}

extension DisassociateTimeSeriesFromAssetPropertyInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let assetId = assetId else {
                let message = "Creating a URL Query Item failed. assetId is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let assetIdQueryItem = ClientRuntime.URLQueryItem(name: "assetId".urlPercentEncoding(), value: Swift.String(assetId).urlPercentEncoding())
            items.append(assetIdQueryItem)
            guard let alias = alias else {
                let message = "Creating a URL Query Item failed. alias is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let aliasQueryItem = ClientRuntime.URLQueryItem(name: "alias".urlPercentEncoding(), value: Swift.String(alias).urlPercentEncoding())
            items.append(aliasQueryItem)
            guard let propertyId = propertyId else {
                let message = "Creating a URL Query Item failed. propertyId is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let propertyIdQueryItem = ClientRuntime.URLQueryItem(name: "propertyId".urlPercentEncoding(), value: Swift.String(propertyId).urlPercentEncoding())
            items.append(propertyIdQueryItem)
            return items
        }
    }
}

extension DisassociateTimeSeriesFromAssetPropertyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/timeseries/disassociate"
    }
}

public struct DisassociateTimeSeriesFromAssetPropertyInput: Swift.Equatable {
    /// The alias that identifies the time series.
    /// This member is required.
    public var alias: Swift.String?
    /// The ID of the asset in which the asset property was created.
    /// This member is required.
    public var assetId: Swift.String?
    /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
    public var clientToken: Swift.String?
    /// The ID of the asset property.
    /// This member is required.
    public var propertyId: Swift.String?

    public init(
        alias: Swift.String? = nil,
        assetId: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        propertyId: Swift.String? = nil
    )
    {
        self.alias = alias
        self.assetId = assetId
        self.clientToken = clientToken
        self.propertyId = propertyId
    }
}

struct DisassociateTimeSeriesFromAssetPropertyInputBody: Swift.Equatable {
    let clientToken: Swift.String?
}

extension DisassociateTimeSeriesFromAssetPropertyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension DisassociateTimeSeriesFromAssetPropertyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DisassociateTimeSeriesFromAssetPropertyOutput: Swift.Equatable {

    public init() { }
}

enum DisassociateTimeSeriesFromAssetPropertyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictingOperationException": return try await ConflictingOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension IoTSiteWiseClientTypes {
    public enum DisassociatedDataStorageState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [DisassociatedDataStorageState] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DisassociatedDataStorageState(rawValue: rawValue) ?? DisassociatedDataStorageState.sdkUnknown(rawValue)
        }
    }
}

extension IoTSiteWiseClientTypes {
    public enum EncryptionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case kmsBasedEncryption
        case sitewiseDefaultEncryption
        case sdkUnknown(Swift.String)

        public static var allCases: [EncryptionType] {
            return [
                .kmsBasedEncryption,
                .sitewiseDefaultEncryption,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .kmsBasedEncryption: return "KMS_BASED_ENCRYPTION"
            case .sitewiseDefaultEncryption: return "SITEWISE_DEFAULT_ENCRYPTION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EncryptionType(rawValue: rawValue) ?? EncryptionType.sdkUnknown(rawValue)
        }
    }
}

extension IoTSiteWiseClientTypes {
    public enum ErrorCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case internalFailure
        case validationError
        case sdkUnknown(Swift.String)

        public static var allCases: [ErrorCode] {
            return [
                .internalFailure,
                .validationError,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .internalFailure: return "INTERNAL_FAILURE"
            case .validationError: return "VALIDATION_ERROR"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ErrorCode(rawValue: rawValue) ?? ErrorCode.sdkUnknown(rawValue)
        }
    }
}

extension IoTSiteWiseClientTypes.ErrorDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code
        case details
        case message
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let code = self.code {
            try encodeContainer.encode(code.rawValue, forKey: .code)
        }
        if let details = details {
            var detailsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .details)
            for detailederror0 in details {
                try detailsContainer.encode(detailederror0)
            }
        }
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.ErrorCode.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let detailsContainer = try containerValues.decodeIfPresent([IoTSiteWiseClientTypes.DetailedError?].self, forKey: .details)
        var detailsDecoded0:[IoTSiteWiseClientTypes.DetailedError]? = nil
        if let detailsContainer = detailsContainer {
            detailsDecoded0 = [IoTSiteWiseClientTypes.DetailedError]()
            for structure0 in detailsContainer {
                if let structure0 = structure0 {
                    detailsDecoded0?.append(structure0)
                }
            }
        }
        details = detailsDecoded0
    }
}

extension IoTSiteWiseClientTypes {
    /// Contains the details of an IoT SiteWise error.
    public struct ErrorDetails: Swift.Equatable {
        /// The error code.
        /// This member is required.
        public var code: IoTSiteWiseClientTypes.ErrorCode?
        /// A list of detailed errors.
        public var details: [IoTSiteWiseClientTypes.DetailedError]?
        /// The error message.
        /// This member is required.
        public var message: Swift.String?

        public init(
            code: IoTSiteWiseClientTypes.ErrorCode? = nil,
            details: [IoTSiteWiseClientTypes.DetailedError]? = nil,
            message: Swift.String? = nil
        )
        {
            self.code = code
            self.details = details
            self.message = message
        }
    }

}

extension IoTSiteWiseClientTypes.ErrorReportLocation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucket
        case `prefix` = "prefix"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucket = self.bucket {
            try encodeContainer.encode(bucket, forKey: .bucket)
        }
        if let `prefix` = self.`prefix` {
            try encodeContainer.encode(`prefix`, forKey: .`prefix`)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucket)
        bucket = bucketDecoded
        let prefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .prefix)
        `prefix` = prefixDecoded
    }
}

extension IoTSiteWiseClientTypes {
    /// The Amazon S3 destination where errors associated with the job creation request are saved.
    public struct ErrorReportLocation: Swift.Equatable {
        /// The name of the Amazon S3 bucket to which errors associated with the bulk import job are sent.
        /// This member is required.
        public var bucket: Swift.String?
        /// Amazon S3 uses the prefix as a folder name to organize data in the bucket. Each Amazon S3 object has a key that is its unique identifier in the bucket. Each object in a bucket has exactly one key. The prefix must end with a forward slash (/). For more information, see [Organizing objects using prefixes](https://docs.aws.amazon.com/AmazonS3/latest/userguide/using-prefixes.html) in the Amazon Simple Storage Service User Guide.
        /// This member is required.
        public var `prefix`: Swift.String?

        public init(
            bucket: Swift.String? = nil,
            `prefix`: Swift.String? = nil
        )
        {
            self.bucket = bucket
            self.`prefix` = `prefix`
        }
    }

}

extension IoTSiteWiseClientTypes.ExpressionVariable: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let valueDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.VariableValue.self, forKey: .value)
        value = valueDecoded
    }
}

extension IoTSiteWiseClientTypes {
    /// Contains expression variable information.
    public struct ExpressionVariable: Swift.Equatable {
        /// The friendly name of the variable to be used in the expression.
        /// This member is required.
        public var name: Swift.String?
        /// The variable that identifies an asset property from which to use values.
        /// This member is required.
        public var value: IoTSiteWiseClientTypes.VariableValue?

        public init(
            name: Swift.String? = nil,
            value: IoTSiteWiseClientTypes.VariableValue? = nil
        )
        {
            self.name = name
            self.value = value
        }
    }

}

extension IoTSiteWiseClientTypes.File: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucket
        case key
        case versionId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucket = self.bucket {
            try encodeContainer.encode(bucket, forKey: .bucket)
        }
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let versionId = self.versionId {
            try encodeContainer.encode(versionId, forKey: .versionId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucket)
        bucket = bucketDecoded
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let versionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .versionId)
        versionId = versionIdDecoded
    }
}

extension IoTSiteWiseClientTypes {
    /// The file in Amazon S3 where your data is saved.
    public struct File: Swift.Equatable {
        /// The name of the Amazon S3 bucket from which data is imported.
        /// This member is required.
        public var bucket: Swift.String?
        /// The key of the Amazon S3 object that contains your data. Each object has a key that is a unique identifier. Each object has exactly one key.
        /// This member is required.
        public var key: Swift.String?
        /// The version ID to identify a specific version of the Amazon S3 object that contains your data.
        public var versionId: Swift.String?

        public init(
            bucket: Swift.String? = nil,
            key: Swift.String? = nil,
            versionId: Swift.String? = nil
        )
        {
            self.bucket = bucket
            self.key = key
            self.versionId = versionId
        }
    }

}

extension IoTSiteWiseClientTypes.FileFormat: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case csv
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let csv = self.csv {
            try encodeContainer.encode(csv, forKey: .csv)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let csvDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.Csv.self, forKey: .csv)
        csv = csvDecoded
    }
}

extension IoTSiteWiseClientTypes {
    /// The file format of the data.
    public struct FileFormat: Swift.Equatable {
        /// The .csv file format.
        public var csv: IoTSiteWiseClientTypes.Csv?

        public init(
            csv: IoTSiteWiseClientTypes.Csv? = nil
        )
        {
            self.csv = csv
        }
    }

}

extension IoTSiteWiseClientTypes.ForwardingConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case state
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stateDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.ForwardingConfigState.self, forKey: .state)
        state = stateDecoded
    }
}

extension IoTSiteWiseClientTypes {
    /// The forwarding configuration for a given property.
    public struct ForwardingConfig: Swift.Equatable {
        /// The forwarding state for the given property.
        /// This member is required.
        public var state: IoTSiteWiseClientTypes.ForwardingConfigState?

        public init(
            state: IoTSiteWiseClientTypes.ForwardingConfigState? = nil
        )
        {
            self.state = state
        }
    }

}

extension IoTSiteWiseClientTypes {
    public enum ForwardingConfigState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [ForwardingConfigState] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ForwardingConfigState(rawValue: rawValue) ?? ForwardingConfigState.sdkUnknown(rawValue)
        }
    }
}

extension IoTSiteWiseClientTypes.GatewayCapabilitySummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case capabilityNamespace
        case capabilitySyncStatus
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let capabilityNamespace = self.capabilityNamespace {
            try encodeContainer.encode(capabilityNamespace, forKey: .capabilityNamespace)
        }
        if let capabilitySyncStatus = self.capabilitySyncStatus {
            try encodeContainer.encode(capabilitySyncStatus.rawValue, forKey: .capabilitySyncStatus)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let capabilityNamespaceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .capabilityNamespace)
        capabilityNamespace = capabilityNamespaceDecoded
        let capabilitySyncStatusDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.CapabilitySyncStatus.self, forKey: .capabilitySyncStatus)
        capabilitySyncStatus = capabilitySyncStatusDecoded
    }
}

extension IoTSiteWiseClientTypes {
    /// Contains a summary of a gateway capability configuration.
    public struct GatewayCapabilitySummary: Swift.Equatable {
        /// The namespace of the capability configuration. For example, if you configure OPC-UA sources from the IoT SiteWise console, your OPC-UA capability configuration has the namespace iotsitewise:opcuacollector:version, where version is a number such as 1.
        /// This member is required.
        public var capabilityNamespace: Swift.String?
        /// The synchronization status of the capability configuration. The sync status can be one of the following:
        ///
        /// * IN_SYNC  The gateway is running the capability configuration.
        ///
        /// * OUT_OF_SYNC  The gateway hasn't received the capability configuration.
        ///
        /// * SYNC_FAILED  The gateway rejected the capability configuration.
        /// This member is required.
        public var capabilitySyncStatus: IoTSiteWiseClientTypes.CapabilitySyncStatus?

        public init(
            capabilityNamespace: Swift.String? = nil,
            capabilitySyncStatus: IoTSiteWiseClientTypes.CapabilitySyncStatus? = nil
        )
        {
            self.capabilityNamespace = capabilityNamespace
            self.capabilitySyncStatus = capabilitySyncStatus
        }
    }

}

extension IoTSiteWiseClientTypes.GatewayPlatform: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case greengrass
        case greengrassV2
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let greengrass = self.greengrass {
            try encodeContainer.encode(greengrass, forKey: .greengrass)
        }
        if let greengrassV2 = self.greengrassV2 {
            try encodeContainer.encode(greengrassV2, forKey: .greengrassV2)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let greengrassDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.Greengrass.self, forKey: .greengrass)
        greengrass = greengrassDecoded
        let greengrassV2Decoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.GreengrassV2.self, forKey: .greengrassV2)
        greengrassV2 = greengrassV2Decoded
    }
}

extension IoTSiteWiseClientTypes {
    /// Contains a gateway's platform information.
    public struct GatewayPlatform: Swift.Equatable {
        /// A gateway that runs on IoT Greengrass.
        public var greengrass: IoTSiteWiseClientTypes.Greengrass?
        /// A gateway that runs on IoT Greengrass V2.
        public var greengrassV2: IoTSiteWiseClientTypes.GreengrassV2?

        public init(
            greengrass: IoTSiteWiseClientTypes.Greengrass? = nil,
            greengrassV2: IoTSiteWiseClientTypes.GreengrassV2? = nil
        )
        {
            self.greengrass = greengrass
            self.greengrassV2 = greengrassV2
        }
    }

}

extension IoTSiteWiseClientTypes.GatewaySummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationDate
        case gatewayCapabilitySummaries
        case gatewayId
        case gatewayName
        case gatewayPlatform
        case lastUpdateDate
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationDate = self.creationDate {
            try encodeContainer.encodeTimestamp(creationDate, format: .epochSeconds, forKey: .creationDate)
        }
        if let gatewayCapabilitySummaries = gatewayCapabilitySummaries {
            var gatewayCapabilitySummariesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .gatewayCapabilitySummaries)
            for gatewaycapabilitysummary0 in gatewayCapabilitySummaries {
                try gatewayCapabilitySummariesContainer.encode(gatewaycapabilitysummary0)
            }
        }
        if let gatewayId = self.gatewayId {
            try encodeContainer.encode(gatewayId, forKey: .gatewayId)
        }
        if let gatewayName = self.gatewayName {
            try encodeContainer.encode(gatewayName, forKey: .gatewayName)
        }
        if let gatewayPlatform = self.gatewayPlatform {
            try encodeContainer.encode(gatewayPlatform, forKey: .gatewayPlatform)
        }
        if let lastUpdateDate = self.lastUpdateDate {
            try encodeContainer.encodeTimestamp(lastUpdateDate, format: .epochSeconds, forKey: .lastUpdateDate)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayId)
        gatewayId = gatewayIdDecoded
        let gatewayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayName)
        gatewayName = gatewayNameDecoded
        let gatewayPlatformDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.GatewayPlatform.self, forKey: .gatewayPlatform)
        gatewayPlatform = gatewayPlatformDecoded
        let gatewayCapabilitySummariesContainer = try containerValues.decodeIfPresent([IoTSiteWiseClientTypes.GatewayCapabilitySummary?].self, forKey: .gatewayCapabilitySummaries)
        var gatewayCapabilitySummariesDecoded0:[IoTSiteWiseClientTypes.GatewayCapabilitySummary]? = nil
        if let gatewayCapabilitySummariesContainer = gatewayCapabilitySummariesContainer {
            gatewayCapabilitySummariesDecoded0 = [IoTSiteWiseClientTypes.GatewayCapabilitySummary]()
            for structure0 in gatewayCapabilitySummariesContainer {
                if let structure0 = structure0 {
                    gatewayCapabilitySummariesDecoded0?.append(structure0)
                }
            }
        }
        gatewayCapabilitySummaries = gatewayCapabilitySummariesDecoded0
        let creationDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDate)
        creationDate = creationDateDecoded
        let lastUpdateDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdateDate)
        lastUpdateDate = lastUpdateDateDecoded
    }
}

extension IoTSiteWiseClientTypes {
    /// Contains a summary of a gateway.
    public struct GatewaySummary: Swift.Equatable {
        /// The date the gateway was created, in Unix epoch time.
        /// This member is required.
        public var creationDate: ClientRuntime.Date?
        /// A list of gateway capability summaries that each contain a namespace and status. Each gateway capability defines data sources for the gateway. To retrieve a capability configuration's definition, use [DescribeGatewayCapabilityConfiguration](https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_DescribeGatewayCapabilityConfiguration.html).
        public var gatewayCapabilitySummaries: [IoTSiteWiseClientTypes.GatewayCapabilitySummary]?
        /// The ID of the gateway device.
        /// This member is required.
        public var gatewayId: Swift.String?
        /// The name of the asset.
        /// This member is required.
        public var gatewayName: Swift.String?
        /// Contains a gateway's platform information.
        public var gatewayPlatform: IoTSiteWiseClientTypes.GatewayPlatform?
        /// The date the gateway was last updated, in Unix epoch time.
        /// This member is required.
        public var lastUpdateDate: ClientRuntime.Date?

        public init(
            creationDate: ClientRuntime.Date? = nil,
            gatewayCapabilitySummaries: [IoTSiteWiseClientTypes.GatewayCapabilitySummary]? = nil,
            gatewayId: Swift.String? = nil,
            gatewayName: Swift.String? = nil,
            gatewayPlatform: IoTSiteWiseClientTypes.GatewayPlatform? = nil,
            lastUpdateDate: ClientRuntime.Date? = nil
        )
        {
            self.creationDate = creationDate
            self.gatewayCapabilitySummaries = gatewayCapabilitySummaries
            self.gatewayId = gatewayId
            self.gatewayName = gatewayName
            self.gatewayPlatform = gatewayPlatform
            self.lastUpdateDate = lastUpdateDate
        }
    }

}

extension GetAssetPropertyAggregatesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let aggregateTypes = aggregateTypes else {
                let message = "Creating a URL Query Item failed. aggregateTypes is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            aggregateTypes.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "aggregateTypes".urlPercentEncoding(), value: Swift.String(queryItemValue.rawValue).urlPercentEncoding())
                items.append(queryItem)
            }
            guard let endDate = endDate else {
                let message = "Creating a URL Query Item failed. endDate is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let endDateQueryItem = ClientRuntime.URLQueryItem(name: "endDate".urlPercentEncoding(), value: Swift.String(TimestampFormatter(format: .dateTime).string(from: endDate)).urlPercentEncoding())
            items.append(endDateQueryItem)
            if let assetId = assetId {
                let assetIdQueryItem = ClientRuntime.URLQueryItem(name: "assetId".urlPercentEncoding(), value: Swift.String(assetId).urlPercentEncoding())
                items.append(assetIdQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let propertyAlias = propertyAlias {
                let propertyAliasQueryItem = ClientRuntime.URLQueryItem(name: "propertyAlias".urlPercentEncoding(), value: Swift.String(propertyAlias).urlPercentEncoding())
                items.append(propertyAliasQueryItem)
            }
            if let qualities = qualities {
                qualities.forEach { queryItemValue in
                    let queryItem = ClientRuntime.URLQueryItem(name: "qualities".urlPercentEncoding(), value: Swift.String(queryItemValue.rawValue).urlPercentEncoding())
                    items.append(queryItem)
                }
            }
            if let timeOrdering = timeOrdering {
                let timeOrderingQueryItem = ClientRuntime.URLQueryItem(name: "timeOrdering".urlPercentEncoding(), value: Swift.String(timeOrdering.rawValue).urlPercentEncoding())
                items.append(timeOrderingQueryItem)
            }
            if let propertyId = propertyId {
                let propertyIdQueryItem = ClientRuntime.URLQueryItem(name: "propertyId".urlPercentEncoding(), value: Swift.String(propertyId).urlPercentEncoding())
                items.append(propertyIdQueryItem)
            }
            guard let resolution = resolution else {
                let message = "Creating a URL Query Item failed. resolution is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let resolutionQueryItem = ClientRuntime.URLQueryItem(name: "resolution".urlPercentEncoding(), value: Swift.String(resolution).urlPercentEncoding())
            items.append(resolutionQueryItem)
            guard let startDate = startDate else {
                let message = "Creating a URL Query Item failed. startDate is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let startDateQueryItem = ClientRuntime.URLQueryItem(name: "startDate".urlPercentEncoding(), value: Swift.String(TimestampFormatter(format: .dateTime).string(from: startDate)).urlPercentEncoding())
            items.append(startDateQueryItem)
            return items
        }
    }
}

extension GetAssetPropertyAggregatesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/properties/aggregates"
    }
}

public struct GetAssetPropertyAggregatesInput: Swift.Equatable {
    /// The data aggregating function.
    /// This member is required.
    public var aggregateTypes: [IoTSiteWiseClientTypes.AggregateType]?
    /// The ID of the asset.
    public var assetId: Swift.String?
    /// The inclusive end of the range from which to query historical data, expressed in seconds in Unix epoch time.
    /// This member is required.
    public var endDate: ClientRuntime.Date?
    /// The maximum number of results to return for each paginated request. A result set is returned in the two cases, whichever occurs first.
    ///
    /// * The size of the result set is equal to 1 MB.
    ///
    /// * The number of data points in the result set is equal to the value of maxResults. The maximum value of maxResults is 250.
    public var maxResults: Swift.Int?
    /// The token to be used for the next set of paginated results.
    public var nextToken: Swift.String?
    /// The alias that identifies the property, such as an OPC-UA server data stream path (for example, /company/windfarm/3/turbine/7/temperature). For more information, see [Mapping industrial data streams to asset properties](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/connect-data-streams.html) in the IoT SiteWise User Guide.
    public var propertyAlias: Swift.String?
    /// The ID of the asset property.
    public var propertyId: Swift.String?
    /// The quality by which to filter asset data.
    public var qualities: [IoTSiteWiseClientTypes.Quality]?
    /// The time interval over which to aggregate data.
    /// This member is required.
    public var resolution: Swift.String?
    /// The exclusive start of the range from which to query historical data, expressed in seconds in Unix epoch time.
    /// This member is required.
    public var startDate: ClientRuntime.Date?
    /// The chronological sorting order of the requested information. Default: ASCENDING
    public var timeOrdering: IoTSiteWiseClientTypes.TimeOrdering?

    public init(
        aggregateTypes: [IoTSiteWiseClientTypes.AggregateType]? = nil,
        assetId: Swift.String? = nil,
        endDate: ClientRuntime.Date? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        propertyAlias: Swift.String? = nil,
        propertyId: Swift.String? = nil,
        qualities: [IoTSiteWiseClientTypes.Quality]? = nil,
        resolution: Swift.String? = nil,
        startDate: ClientRuntime.Date? = nil,
        timeOrdering: IoTSiteWiseClientTypes.TimeOrdering? = nil
    )
    {
        self.aggregateTypes = aggregateTypes
        self.assetId = assetId
        self.endDate = endDate
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.propertyAlias = propertyAlias
        self.propertyId = propertyId
        self.qualities = qualities
        self.resolution = resolution
        self.startDate = startDate
        self.timeOrdering = timeOrdering
    }
}

struct GetAssetPropertyAggregatesInputBody: Swift.Equatable {
}

extension GetAssetPropertyAggregatesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetAssetPropertyAggregatesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetAssetPropertyAggregatesOutputBody = try responseDecoder.decode(responseBody: data)
            self.aggregatedValues = output.aggregatedValues
            self.nextToken = output.nextToken
        } else {
            self.aggregatedValues = nil
            self.nextToken = nil
        }
    }
}

public struct GetAssetPropertyAggregatesOutput: Swift.Equatable {
    /// The requested aggregated values.
    /// This member is required.
    public var aggregatedValues: [IoTSiteWiseClientTypes.AggregatedValue]?
    /// The token for the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?

    public init(
        aggregatedValues: [IoTSiteWiseClientTypes.AggregatedValue]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.aggregatedValues = aggregatedValues
        self.nextToken = nextToken
    }
}

struct GetAssetPropertyAggregatesOutputBody: Swift.Equatable {
    let aggregatedValues: [IoTSiteWiseClientTypes.AggregatedValue]?
    let nextToken: Swift.String?
}

extension GetAssetPropertyAggregatesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aggregatedValues
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aggregatedValuesContainer = try containerValues.decodeIfPresent([IoTSiteWiseClientTypes.AggregatedValue?].self, forKey: .aggregatedValues)
        var aggregatedValuesDecoded0:[IoTSiteWiseClientTypes.AggregatedValue]? = nil
        if let aggregatedValuesContainer = aggregatedValuesContainer {
            aggregatedValuesDecoded0 = [IoTSiteWiseClientTypes.AggregatedValue]()
            for structure0 in aggregatedValuesContainer {
                if let structure0 = structure0 {
                    aggregatedValuesDecoded0?.append(structure0)
                }
            }
        }
        aggregatedValues = aggregatedValuesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum GetAssetPropertyAggregatesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetAssetPropertyValueHistoryInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let endDate = endDate {
                let endDateQueryItem = ClientRuntime.URLQueryItem(name: "endDate".urlPercentEncoding(), value: Swift.String(TimestampFormatter(format: .dateTime).string(from: endDate)).urlPercentEncoding())
                items.append(endDateQueryItem)
            }
            if let assetId = assetId {
                let assetIdQueryItem = ClientRuntime.URLQueryItem(name: "assetId".urlPercentEncoding(), value: Swift.String(assetId).urlPercentEncoding())
                items.append(assetIdQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let propertyAlias = propertyAlias {
                let propertyAliasQueryItem = ClientRuntime.URLQueryItem(name: "propertyAlias".urlPercentEncoding(), value: Swift.String(propertyAlias).urlPercentEncoding())
                items.append(propertyAliasQueryItem)
            }
            if let qualities = qualities {
                qualities.forEach { queryItemValue in
                    let queryItem = ClientRuntime.URLQueryItem(name: "qualities".urlPercentEncoding(), value: Swift.String(queryItemValue.rawValue).urlPercentEncoding())
                    items.append(queryItem)
                }
            }
            if let timeOrdering = timeOrdering {
                let timeOrderingQueryItem = ClientRuntime.URLQueryItem(name: "timeOrdering".urlPercentEncoding(), value: Swift.String(timeOrdering.rawValue).urlPercentEncoding())
                items.append(timeOrderingQueryItem)
            }
            if let propertyId = propertyId {
                let propertyIdQueryItem = ClientRuntime.URLQueryItem(name: "propertyId".urlPercentEncoding(), value: Swift.String(propertyId).urlPercentEncoding())
                items.append(propertyIdQueryItem)
            }
            if let startDate = startDate {
                let startDateQueryItem = ClientRuntime.URLQueryItem(name: "startDate".urlPercentEncoding(), value: Swift.String(TimestampFormatter(format: .dateTime).string(from: startDate)).urlPercentEncoding())
                items.append(startDateQueryItem)
            }
            return items
        }
    }
}

extension GetAssetPropertyValueHistoryInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/properties/history"
    }
}

public struct GetAssetPropertyValueHistoryInput: Swift.Equatable {
    /// The ID of the asset.
    public var assetId: Swift.String?
    /// The inclusive end of the range from which to query historical data, expressed in seconds in Unix epoch time.
    public var endDate: ClientRuntime.Date?
    /// The maximum number of results to return for each paginated request. A result set is returned in the two cases, whichever occurs first.
    ///
    /// * The size of the result set is equal to 4 MB.
    ///
    /// * The number of data points in the result set is equal to the value of maxResults. The maximum value of maxResults is 20000.
    public var maxResults: Swift.Int?
    /// The token to be used for the next set of paginated results.
    public var nextToken: Swift.String?
    /// The alias that identifies the property, such as an OPC-UA server data stream path (for example, /company/windfarm/3/turbine/7/temperature). For more information, see [Mapping industrial data streams to asset properties](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/connect-data-streams.html) in the IoT SiteWise User Guide.
    public var propertyAlias: Swift.String?
    /// The ID of the asset property.
    public var propertyId: Swift.String?
    /// The quality by which to filter asset data.
    public var qualities: [IoTSiteWiseClientTypes.Quality]?
    /// The exclusive start of the range from which to query historical data, expressed in seconds in Unix epoch time.
    public var startDate: ClientRuntime.Date?
    /// The chronological sorting order of the requested information. Default: ASCENDING
    public var timeOrdering: IoTSiteWiseClientTypes.TimeOrdering?

    public init(
        assetId: Swift.String? = nil,
        endDate: ClientRuntime.Date? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        propertyAlias: Swift.String? = nil,
        propertyId: Swift.String? = nil,
        qualities: [IoTSiteWiseClientTypes.Quality]? = nil,
        startDate: ClientRuntime.Date? = nil,
        timeOrdering: IoTSiteWiseClientTypes.TimeOrdering? = nil
    )
    {
        self.assetId = assetId
        self.endDate = endDate
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.propertyAlias = propertyAlias
        self.propertyId = propertyId
        self.qualities = qualities
        self.startDate = startDate
        self.timeOrdering = timeOrdering
    }
}

struct GetAssetPropertyValueHistoryInputBody: Swift.Equatable {
}

extension GetAssetPropertyValueHistoryInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetAssetPropertyValueHistoryOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetAssetPropertyValueHistoryOutputBody = try responseDecoder.decode(responseBody: data)
            self.assetPropertyValueHistory = output.assetPropertyValueHistory
            self.nextToken = output.nextToken
        } else {
            self.assetPropertyValueHistory = nil
            self.nextToken = nil
        }
    }
}

public struct GetAssetPropertyValueHistoryOutput: Swift.Equatable {
    /// The asset property's value history.
    /// This member is required.
    public var assetPropertyValueHistory: [IoTSiteWiseClientTypes.AssetPropertyValue]?
    /// The token for the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?

    public init(
        assetPropertyValueHistory: [IoTSiteWiseClientTypes.AssetPropertyValue]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.assetPropertyValueHistory = assetPropertyValueHistory
        self.nextToken = nextToken
    }
}

struct GetAssetPropertyValueHistoryOutputBody: Swift.Equatable {
    let assetPropertyValueHistory: [IoTSiteWiseClientTypes.AssetPropertyValue]?
    let nextToken: Swift.String?
}

extension GetAssetPropertyValueHistoryOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assetPropertyValueHistory
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assetPropertyValueHistoryContainer = try containerValues.decodeIfPresent([IoTSiteWiseClientTypes.AssetPropertyValue?].self, forKey: .assetPropertyValueHistory)
        var assetPropertyValueHistoryDecoded0:[IoTSiteWiseClientTypes.AssetPropertyValue]? = nil
        if let assetPropertyValueHistoryContainer = assetPropertyValueHistoryContainer {
            assetPropertyValueHistoryDecoded0 = [IoTSiteWiseClientTypes.AssetPropertyValue]()
            for structure0 in assetPropertyValueHistoryContainer {
                if let structure0 = structure0 {
                    assetPropertyValueHistoryDecoded0?.append(structure0)
                }
            }
        }
        assetPropertyValueHistory = assetPropertyValueHistoryDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum GetAssetPropertyValueHistoryOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetAssetPropertyValueInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let assetId = assetId {
                let assetIdQueryItem = ClientRuntime.URLQueryItem(name: "assetId".urlPercentEncoding(), value: Swift.String(assetId).urlPercentEncoding())
                items.append(assetIdQueryItem)
            }
            if let propertyAlias = propertyAlias {
                let propertyAliasQueryItem = ClientRuntime.URLQueryItem(name: "propertyAlias".urlPercentEncoding(), value: Swift.String(propertyAlias).urlPercentEncoding())
                items.append(propertyAliasQueryItem)
            }
            if let propertyId = propertyId {
                let propertyIdQueryItem = ClientRuntime.URLQueryItem(name: "propertyId".urlPercentEncoding(), value: Swift.String(propertyId).urlPercentEncoding())
                items.append(propertyIdQueryItem)
            }
            return items
        }
    }
}

extension GetAssetPropertyValueInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/properties/latest"
    }
}

public struct GetAssetPropertyValueInput: Swift.Equatable {
    /// The ID of the asset.
    public var assetId: Swift.String?
    /// The alias that identifies the property, such as an OPC-UA server data stream path (for example, /company/windfarm/3/turbine/7/temperature). For more information, see [Mapping industrial data streams to asset properties](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/connect-data-streams.html) in the IoT SiteWise User Guide.
    public var propertyAlias: Swift.String?
    /// The ID of the asset property.
    public var propertyId: Swift.String?

    public init(
        assetId: Swift.String? = nil,
        propertyAlias: Swift.String? = nil,
        propertyId: Swift.String? = nil
    )
    {
        self.assetId = assetId
        self.propertyAlias = propertyAlias
        self.propertyId = propertyId
    }
}

struct GetAssetPropertyValueInputBody: Swift.Equatable {
}

extension GetAssetPropertyValueInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetAssetPropertyValueOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetAssetPropertyValueOutputBody = try responseDecoder.decode(responseBody: data)
            self.propertyValue = output.propertyValue
        } else {
            self.propertyValue = nil
        }
    }
}

public struct GetAssetPropertyValueOutput: Swift.Equatable {
    /// The current asset property value.
    public var propertyValue: IoTSiteWiseClientTypes.AssetPropertyValue?

    public init(
        propertyValue: IoTSiteWiseClientTypes.AssetPropertyValue? = nil
    )
    {
        self.propertyValue = propertyValue
    }
}

struct GetAssetPropertyValueOutputBody: Swift.Equatable {
    let propertyValue: IoTSiteWiseClientTypes.AssetPropertyValue?
}

extension GetAssetPropertyValueOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case propertyValue
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let propertyValueDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.AssetPropertyValue.self, forKey: .propertyValue)
        propertyValue = propertyValueDecoded
    }
}

enum GetAssetPropertyValueOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetInterpolatedAssetPropertyValuesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let startTimeOffsetInNanos = startTimeOffsetInNanos {
                let startTimeOffsetInNanosQueryItem = ClientRuntime.URLQueryItem(name: "startTimeOffsetInNanos".urlPercentEncoding(), value: Swift.String(startTimeOffsetInNanos).urlPercentEncoding())
                items.append(startTimeOffsetInNanosQueryItem)
            }
            guard let endTimeInSeconds = endTimeInSeconds else {
                let message = "Creating a URL Query Item failed. endTimeInSeconds is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let endTimeInSecondsQueryItem = ClientRuntime.URLQueryItem(name: "endTimeInSeconds".urlPercentEncoding(), value: Swift.String(endTimeInSeconds).urlPercentEncoding())
            items.append(endTimeInSecondsQueryItem)
            if let endTimeOffsetInNanos = endTimeOffsetInNanos {
                let endTimeOffsetInNanosQueryItem = ClientRuntime.URLQueryItem(name: "endTimeOffsetInNanos".urlPercentEncoding(), value: Swift.String(endTimeOffsetInNanos).urlPercentEncoding())
                items.append(endTimeOffsetInNanosQueryItem)
            }
            if let propertyAlias = propertyAlias {
                let propertyAliasQueryItem = ClientRuntime.URLQueryItem(name: "propertyAlias".urlPercentEncoding(), value: Swift.String(propertyAlias).urlPercentEncoding())
                items.append(propertyAliasQueryItem)
            }
            if let intervalWindowInSeconds = intervalWindowInSeconds {
                let intervalWindowInSecondsQueryItem = ClientRuntime.URLQueryItem(name: "intervalWindowInSeconds".urlPercentEncoding(), value: Swift.String(intervalWindowInSeconds).urlPercentEncoding())
                items.append(intervalWindowInSecondsQueryItem)
            }
            guard let type = type else {
                let message = "Creating a URL Query Item failed. type is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let typeQueryItem = ClientRuntime.URLQueryItem(name: "type".urlPercentEncoding(), value: Swift.String(type).urlPercentEncoding())
            items.append(typeQueryItem)
            guard let quality = quality else {
                let message = "Creating a URL Query Item failed. quality is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let qualityQueryItem = ClientRuntime.URLQueryItem(name: "quality".urlPercentEncoding(), value: Swift.String(quality.rawValue).urlPercentEncoding())
            items.append(qualityQueryItem)
            guard let startTimeInSeconds = startTimeInSeconds else {
                let message = "Creating a URL Query Item failed. startTimeInSeconds is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let startTimeInSecondsQueryItem = ClientRuntime.URLQueryItem(name: "startTimeInSeconds".urlPercentEncoding(), value: Swift.String(startTimeInSeconds).urlPercentEncoding())
            items.append(startTimeInSecondsQueryItem)
            if let assetId = assetId {
                let assetIdQueryItem = ClientRuntime.URLQueryItem(name: "assetId".urlPercentEncoding(), value: Swift.String(assetId).urlPercentEncoding())
                items.append(assetIdQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            guard let intervalInSeconds = intervalInSeconds else {
                let message = "Creating a URL Query Item failed. intervalInSeconds is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let intervalInSecondsQueryItem = ClientRuntime.URLQueryItem(name: "intervalInSeconds".urlPercentEncoding(), value: Swift.String(intervalInSeconds).urlPercentEncoding())
            items.append(intervalInSecondsQueryItem)
            if let propertyId = propertyId {
                let propertyIdQueryItem = ClientRuntime.URLQueryItem(name: "propertyId".urlPercentEncoding(), value: Swift.String(propertyId).urlPercentEncoding())
                items.append(propertyIdQueryItem)
            }
            return items
        }
    }
}

extension GetInterpolatedAssetPropertyValuesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/properties/interpolated"
    }
}

public struct GetInterpolatedAssetPropertyValuesInput: Swift.Equatable {
    /// The ID of the asset.
    public var assetId: Swift.String?
    /// The inclusive end of the range from which to interpolate data, expressed in seconds in Unix epoch time.
    /// This member is required.
    public var endTimeInSeconds: Swift.Int?
    /// The nanosecond offset converted from endTimeInSeconds.
    public var endTimeOffsetInNanos: Swift.Int?
    /// The time interval in seconds over which to interpolate data. Each interval starts when the previous one ends.
    /// This member is required.
    public var intervalInSeconds: Swift.Int?
    /// The query interval for the window, in seconds. IoT SiteWise computes each interpolated value by using data points from the timestamp of each interval, minus the window to the timestamp of each interval plus the window. If not specified, the window ranges between the start time minus the interval and the end time plus the interval.
    ///
    /// * If you specify a value for the intervalWindowInSeconds parameter, the value for the type parameter must be LINEAR_INTERPOLATION.
    ///
    /// * If a data point isn't found during the specified query window, IoT SiteWise won't return an interpolated value for the interval. This indicates that there's a gap in the ingested data points.
    ///
    ///
    /// For example, you can get the interpolated temperature values for a wind turbine every 24 hours over a duration of 7 days. If the interpolation starts on July 1, 2021, at 9 AM with a window of 2 hours, IoT SiteWise uses the data points from 7 AM (9 AM minus 2 hours) to 11 AM (9 AM plus 2 hours) on July 2, 2021 to compute the first interpolated value. Next, IoT SiteWise uses the data points from 7 AM (9 AM minus 2 hours) to 11 AM (9 AM plus 2 hours) on July 3, 2021 to compute the second interpolated value, and so on.
    public var intervalWindowInSeconds: Swift.Int?
    /// The maximum number of results to return for each paginated request. If not specified, the default value is 10.
    public var maxResults: Swift.Int?
    /// The token to be used for the next set of paginated results.
    public var nextToken: Swift.String?
    /// The alias that identifies the property, such as an OPC-UA server data stream path (for example, /company/windfarm/3/turbine/7/temperature). For more information, see [Mapping industrial data streams to asset properties](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/connect-data-streams.html) in the IoT SiteWise User Guide.
    public var propertyAlias: Swift.String?
    /// The ID of the asset property.
    public var propertyId: Swift.String?
    /// The quality of the asset property value. You can use this parameter as a filter to choose only the asset property values that have a specific quality.
    /// This member is required.
    public var quality: IoTSiteWiseClientTypes.Quality?
    /// The exclusive start of the range from which to interpolate data, expressed in seconds in Unix epoch time.
    /// This member is required.
    public var startTimeInSeconds: Swift.Int?
    /// The nanosecond offset converted from startTimeInSeconds.
    public var startTimeOffsetInNanos: Swift.Int?
    /// The interpolation type. Valid values: LINEAR_INTERPOLATION | LOCF_INTERPOLATION
    ///
    /// * LINEAR_INTERPOLATION  Estimates missing data using [linear interpolation](https://en.wikipedia.org/wiki/Linear_interpolation). For example, you can use this operation to return the interpolated temperature values for a wind turbine every 24 hours over a duration of 7 days. If the interpolation starts July 1, 2021, at 9 AM, IoT SiteWise returns the first interpolated value on July 2, 2021, at 9 AM, the second interpolated value on July 3, 2021, at 9 AM, and so on.
    ///
    /// * LOCF_INTERPOLATION  Estimates missing data using last observation carried forward interpolation If no data point is found for an interval, IoT SiteWise returns the last observed data point for the previous interval and carries forward this interpolated value until a new data point is found. For example, you can get the state of an on-off valve every 24 hours over a duration of 7 days. If the interpolation starts July 1, 2021, at 9 AM, IoT SiteWise returns the last observed data point between July 1, 2021, at 9 AM and July 2, 2021, at 9 AM as the first interpolated value. If a data point isn't found after 9 AM on July 2, 2021, IoT SiteWise uses the same interpolated value for the rest of the days.
    /// This member is required.
    public var type: Swift.String?

    public init(
        assetId: Swift.String? = nil,
        endTimeInSeconds: Swift.Int? = nil,
        endTimeOffsetInNanos: Swift.Int? = nil,
        intervalInSeconds: Swift.Int? = nil,
        intervalWindowInSeconds: Swift.Int? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        propertyAlias: Swift.String? = nil,
        propertyId: Swift.String? = nil,
        quality: IoTSiteWiseClientTypes.Quality? = nil,
        startTimeInSeconds: Swift.Int? = nil,
        startTimeOffsetInNanos: Swift.Int? = nil,
        type: Swift.String? = nil
    )
    {
        self.assetId = assetId
        self.endTimeInSeconds = endTimeInSeconds
        self.endTimeOffsetInNanos = endTimeOffsetInNanos
        self.intervalInSeconds = intervalInSeconds
        self.intervalWindowInSeconds = intervalWindowInSeconds
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.propertyAlias = propertyAlias
        self.propertyId = propertyId
        self.quality = quality
        self.startTimeInSeconds = startTimeInSeconds
        self.startTimeOffsetInNanos = startTimeOffsetInNanos
        self.type = type
    }
}

struct GetInterpolatedAssetPropertyValuesInputBody: Swift.Equatable {
}

extension GetInterpolatedAssetPropertyValuesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetInterpolatedAssetPropertyValuesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetInterpolatedAssetPropertyValuesOutputBody = try responseDecoder.decode(responseBody: data)
            self.interpolatedAssetPropertyValues = output.interpolatedAssetPropertyValues
            self.nextToken = output.nextToken
        } else {
            self.interpolatedAssetPropertyValues = nil
            self.nextToken = nil
        }
    }
}

public struct GetInterpolatedAssetPropertyValuesOutput: Swift.Equatable {
    /// The requested interpolated values.
    /// This member is required.
    public var interpolatedAssetPropertyValues: [IoTSiteWiseClientTypes.InterpolatedAssetPropertyValue]?
    /// The token for the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?

    public init(
        interpolatedAssetPropertyValues: [IoTSiteWiseClientTypes.InterpolatedAssetPropertyValue]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.interpolatedAssetPropertyValues = interpolatedAssetPropertyValues
        self.nextToken = nextToken
    }
}

struct GetInterpolatedAssetPropertyValuesOutputBody: Swift.Equatable {
    let interpolatedAssetPropertyValues: [IoTSiteWiseClientTypes.InterpolatedAssetPropertyValue]?
    let nextToken: Swift.String?
}

extension GetInterpolatedAssetPropertyValuesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case interpolatedAssetPropertyValues
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let interpolatedAssetPropertyValuesContainer = try containerValues.decodeIfPresent([IoTSiteWiseClientTypes.InterpolatedAssetPropertyValue?].self, forKey: .interpolatedAssetPropertyValues)
        var interpolatedAssetPropertyValuesDecoded0:[IoTSiteWiseClientTypes.InterpolatedAssetPropertyValue]? = nil
        if let interpolatedAssetPropertyValuesContainer = interpolatedAssetPropertyValuesContainer {
            interpolatedAssetPropertyValuesDecoded0 = [IoTSiteWiseClientTypes.InterpolatedAssetPropertyValue]()
            for structure0 in interpolatedAssetPropertyValuesContainer {
                if let structure0 = structure0 {
                    interpolatedAssetPropertyValuesDecoded0?.append(structure0)
                }
            }
        }
        interpolatedAssetPropertyValues = interpolatedAssetPropertyValuesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum GetInterpolatedAssetPropertyValuesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension IoTSiteWiseClientTypes.Greengrass: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let groupArn = self.groupArn {
            try encodeContainer.encode(groupArn, forKey: .groupArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupArn)
        groupArn = groupArnDecoded
    }
}

extension IoTSiteWiseClientTypes {
    /// Contains details for a gateway that runs on IoT Greengrass. To create a gateway that runs on IoT Greengrass, you must add the IoT SiteWise connector to a Greengrass group and deploy it. Your Greengrass group must also have permissions to upload data to IoT SiteWise. For more information, see [Ingesting data using a gateway](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/gateway-connector.html) in the IoT SiteWise User Guide.
    public struct Greengrass: Swift.Equatable {
        /// The [ARN](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the Greengrass group. For more information about how to find a group's ARN, see [ListGroups](https://docs.aws.amazon.com/greengrass/latest/apireference/listgroups-get.html) and [GetGroup](https://docs.aws.amazon.com/greengrass/latest/apireference/getgroup-get.html) in the IoT Greengrass API Reference.
        /// This member is required.
        public var groupArn: Swift.String?

        public init(
            groupArn: Swift.String? = nil
        )
        {
            self.groupArn = groupArn
        }
    }

}

extension IoTSiteWiseClientTypes.GreengrassV2: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case coreDeviceThingName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let coreDeviceThingName = self.coreDeviceThingName {
            try encodeContainer.encode(coreDeviceThingName, forKey: .coreDeviceThingName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let coreDeviceThingNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .coreDeviceThingName)
        coreDeviceThingName = coreDeviceThingNameDecoded
    }
}

extension IoTSiteWiseClientTypes {
    /// Contains details for a gateway that runs on IoT Greengrass V2. To create a gateway that runs on IoT Greengrass V2, you must deploy the IoT SiteWise Edge component to your gateway device. Your [Greengrass device role](https://docs.aws.amazon.com/greengrass/v2/developerguide/device-service-role.html) must use the AWSIoTSiteWiseEdgeAccess policy. For more information, see [Using IoT SiteWise at the edge](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/sw-gateways.html) in the IoT SiteWise User Guide.
    public struct GreengrassV2: Swift.Equatable {
        /// The name of the IoT thing for your IoT Greengrass V2 core device.
        /// This member is required.
        public var coreDeviceThingName: Swift.String?

        public init(
            coreDeviceThingName: Swift.String? = nil
        )
        {
            self.coreDeviceThingName = coreDeviceThingName
        }
    }

}

extension IoTSiteWiseClientTypes.GroupIdentity: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
    }
}

extension IoTSiteWiseClientTypes {
    /// Contains information for a group identity in an access policy.
    public struct GroupIdentity: Swift.Equatable {
        /// The IAM Identity Center ID of the group.
        /// This member is required.
        public var id: Swift.String?

        public init(
            id: Swift.String? = nil
        )
        {
            self.id = id
        }
    }

}

extension IoTSiteWiseClientTypes.IAMRoleIdentity: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension IoTSiteWiseClientTypes {
    /// Contains information about an Identity and Access Management role. For more information, see [IAM roles](https://docs.aws.amazon.com/IAM/latest/UserGuide/id_roles.html) in the IAM User Guide.
    public struct IAMRoleIdentity: Swift.Equatable {
        /// The ARN of the IAM role. For more information, see [IAM ARNs](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_identifiers.html) in the IAM User Guide.
        /// This member is required.
        public var arn: Swift.String?

        public init(
            arn: Swift.String? = nil
        )
        {
            self.arn = arn
        }
    }

}

extension IoTSiteWiseClientTypes.IAMUserIdentity: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension IoTSiteWiseClientTypes {
    /// Contains information about an Identity and Access Management user.
    public struct IAMUserIdentity: Swift.Equatable {
        /// The ARN of the IAM user. For more information, see [IAM ARNs](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_identifiers.html) in the IAM User Guide. If you delete the IAM user, access policies that contain this identity include an empty arn. You can delete the access policy for the IAM user that no longer exists.
        /// This member is required.
        public var arn: Swift.String?

        public init(
            arn: Swift.String? = nil
        )
        {
            self.arn = arn
        }
    }

}

extension IoTSiteWiseClientTypes.Identity: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case group
        case iamRole
        case iamUser
        case user
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let group = self.group {
            try encodeContainer.encode(group, forKey: .group)
        }
        if let iamRole = self.iamRole {
            try encodeContainer.encode(iamRole, forKey: .iamRole)
        }
        if let iamUser = self.iamUser {
            try encodeContainer.encode(iamUser, forKey: .iamUser)
        }
        if let user = self.user {
            try encodeContainer.encode(user, forKey: .user)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.UserIdentity.self, forKey: .user)
        user = userDecoded
        let groupDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.GroupIdentity.self, forKey: .group)
        group = groupDecoded
        let iamUserDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.IAMUserIdentity.self, forKey: .iamUser)
        iamUser = iamUserDecoded
        let iamRoleDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.IAMRoleIdentity.self, forKey: .iamRole)
        iamRole = iamRoleDecoded
    }
}

extension IoTSiteWiseClientTypes {
    /// Contains an identity that can access an IoT SiteWise Monitor resource. Currently, you can't use Amazon Web Services APIs to retrieve IAM Identity Center identity IDs. You can find the IAM Identity Center identity IDs in the URL of user and group pages in the [IAM Identity Center console](https://console.aws.amazon.com/singlesignon).
    public struct Identity: Swift.Equatable {
        /// An IAM Identity Center group identity.
        public var group: IoTSiteWiseClientTypes.GroupIdentity?
        /// An IAM role identity.
        public var iamRole: IoTSiteWiseClientTypes.IAMRoleIdentity?
        /// An IAM user identity.
        public var iamUser: IoTSiteWiseClientTypes.IAMUserIdentity?
        /// An IAM Identity Center user identity.
        public var user: IoTSiteWiseClientTypes.UserIdentity?

        public init(
            group: IoTSiteWiseClientTypes.GroupIdentity? = nil,
            iamRole: IoTSiteWiseClientTypes.IAMRoleIdentity? = nil,
            iamUser: IoTSiteWiseClientTypes.IAMUserIdentity? = nil,
            user: IoTSiteWiseClientTypes.UserIdentity? = nil
        )
        {
            self.group = group
            self.iamRole = iamRole
            self.iamUser = iamUser
            self.user = user
        }
    }

}

extension IoTSiteWiseClientTypes {
    public enum IdentityType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case group
        case iam
        case user
        case sdkUnknown(Swift.String)

        public static var allCases: [IdentityType] {
            return [
                .group,
                .iam,
                .user,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .group: return "GROUP"
            case .iam: return "IAM"
            case .user: return "USER"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = IdentityType(rawValue: rawValue) ?? IdentityType.sdkUnknown(rawValue)
        }
    }
}

extension IoTSiteWiseClientTypes.Image: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case file
        case id
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let file = self.file {
            try encodeContainer.encode(file, forKey: .file)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let fileDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.ImageFile.self, forKey: .file)
        file = fileDecoded
    }
}

extension IoTSiteWiseClientTypes {
    /// Contains an image that is one of the following:
    ///
    /// * An image file. Choose this option to upload a new image.
    ///
    /// * The ID of an existing image. Choose this option to keep an existing image.
    public struct Image: Swift.Equatable {
        /// Contains an image file.
        public var file: IoTSiteWiseClientTypes.ImageFile?
        /// The ID of an existing image. Specify this parameter to keep an existing image.
        public var id: Swift.String?

        public init(
            file: IoTSiteWiseClientTypes.ImageFile? = nil,
            id: Swift.String? = nil
        )
        {
            self.file = file
            self.id = id
        }
    }

}

extension IoTSiteWiseClientTypes.ImageFile: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case data
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let data = self.data {
            try encodeContainer.encode(data.base64EncodedString(), forKey: .data)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .data)
        data = dataDecoded
        let typeDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.ImageFileType.self, forKey: .type)
        type = typeDecoded
    }
}

extension IoTSiteWiseClientTypes {
    /// Contains an image file.
    public struct ImageFile: Swift.Equatable {
        /// The image file contents, represented as a base64-encoded string. The file size must be less than 1 MB.
        /// This member is required.
        public var data: ClientRuntime.Data?
        /// The file type of the image.
        /// This member is required.
        public var type: IoTSiteWiseClientTypes.ImageFileType?

        public init(
            data: ClientRuntime.Data? = nil,
            type: IoTSiteWiseClientTypes.ImageFileType? = nil
        )
        {
            self.data = data
            self.type = type
        }
    }

}

extension IoTSiteWiseClientTypes {
    public enum ImageFileType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case png
        case sdkUnknown(Swift.String)

        public static var allCases: [ImageFileType] {
            return [
                .png,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .png: return "PNG"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ImageFileType(rawValue: rawValue) ?? ImageFileType.sdkUnknown(rawValue)
        }
    }
}

extension IoTSiteWiseClientTypes.ImageLocation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
        case url
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let url = self.url {
            try encodeContainer.encode(url, forKey: .url)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let urlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .url)
        url = urlDecoded
    }
}

extension IoTSiteWiseClientTypes {
    /// Contains an image that is uploaded to IoT SiteWise and available at a URL.
    public struct ImageLocation: Swift.Equatable {
        /// The ID of the image.
        /// This member is required.
        public var id: Swift.String?
        /// The URL where the image is available. The URL is valid for 15 minutes so that you can view and download the image
        /// This member is required.
        public var url: Swift.String?

        public init(
            id: Swift.String? = nil,
            url: Swift.String? = nil
        )
        {
            self.id = id
            self.url = url
        }
    }

}

extension InternalFailureException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InternalFailureExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// IoT SiteWise can't process your request right now. Try again later.
public struct InternalFailureException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalFailureException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InternalFailureExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalFailureExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension IoTSiteWiseClientTypes.InterpolatedAssetPropertyValue: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case timestamp
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let timestamp = self.timestamp {
            try encodeContainer.encode(timestamp, forKey: .timestamp)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timestampDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.TimeInNanos.self, forKey: .timestamp)
        timestamp = timestampDecoded
        let valueDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.Variant.self, forKey: .value)
        value = valueDecoded
    }
}

extension IoTSiteWiseClientTypes {
    /// Contains information about an interpolated asset property value.
    public struct InterpolatedAssetPropertyValue: Swift.Equatable {
        /// Contains a timestamp with optional nanosecond granularity.
        /// This member is required.
        public var timestamp: IoTSiteWiseClientTypes.TimeInNanos?
        /// Contains an asset property value (of a single type only).
        /// This member is required.
        public var value: IoTSiteWiseClientTypes.Variant?

        public init(
            timestamp: IoTSiteWiseClientTypes.TimeInNanos? = nil,
            value: IoTSiteWiseClientTypes.Variant? = nil
        )
        {
            self.timestamp = timestamp
            self.value = value
        }
    }

}

extension InvalidRequestException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidRequestExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request isn't valid. This can occur if your request contains malformed JSON or unsupported characters. Check your request and try again.
public struct InvalidRequestException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidRequestException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidRequestExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidRequestExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension IoTSiteWiseClientTypes.JobConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fileFormat
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fileFormat = self.fileFormat {
            try encodeContainer.encode(fileFormat, forKey: .fileFormat)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fileFormatDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.FileFormat.self, forKey: .fileFormat)
        fileFormat = fileFormatDecoded
    }
}

extension IoTSiteWiseClientTypes {
    /// Contains the configuration information of a job, such as the file format used to save data in Amazon S3.
    public struct JobConfiguration: Swift.Equatable {
        /// The file format of the data in Amazon S3.
        /// This member is required.
        public var fileFormat: IoTSiteWiseClientTypes.FileFormat?

        public init(
            fileFormat: IoTSiteWiseClientTypes.FileFormat? = nil
        )
        {
            self.fileFormat = fileFormat
        }
    }

}

extension IoTSiteWiseClientTypes {
    public enum JobStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cancelled
        case completed
        case completedWithFailures
        case failed
        case pending
        case running
        case sdkUnknown(Swift.String)

        public static var allCases: [JobStatus] {
            return [
                .cancelled,
                .completed,
                .completedWithFailures,
                .failed,
                .pending,
                .running,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cancelled: return "CANCELLED"
            case .completed: return "COMPLETED"
            case .completedWithFailures: return "COMPLETED_WITH_FAILURES"
            case .failed: return "FAILED"
            case .pending: return "PENDING"
            case .running: return "RUNNING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = JobStatus(rawValue: rawValue) ?? JobStatus.sdkUnknown(rawValue)
        }
    }
}

extension IoTSiteWiseClientTypes.JobSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
        case name
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.JobStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension IoTSiteWiseClientTypes {
    /// Contains a job summary information.
    public struct JobSummary: Swift.Equatable {
        /// The ID of the job.
        /// This member is required.
        public var id: Swift.String?
        /// The unique name that helps identify the job request.
        /// This member is required.
        public var name: Swift.String?
        /// The status of the bulk import job can be one of following values.
        ///
        /// * PENDING  IoT SiteWise is waiting for the current bulk import job to finish.
        ///
        /// * CANCELLED  The bulk import job has been canceled.
        ///
        /// * RUNNING  IoT SiteWise is processing your request to import your data from Amazon S3.
        ///
        /// * COMPLETED  IoT SiteWise successfully completed your request to import data from Amazon S3.
        ///
        /// * FAILED  IoT SiteWise couldn't process your request to import data from Amazon S3. You can use logs saved in the specified error report location in Amazon S3 to troubleshoot issues.
        ///
        /// * COMPLETED_WITH_FAILURES  IoT SiteWise completed your request to import data from Amazon S3 with errors. You can use logs saved in the specified error report location in Amazon S3 to troubleshoot issues.
        /// This member is required.
        public var status: IoTSiteWiseClientTypes.JobStatus?

        public init(
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            status: IoTSiteWiseClientTypes.JobStatus? = nil
        )
        {
            self.id = id
            self.name = name
            self.status = status
        }
    }

}

extension LimitExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: LimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// You've reached the limit for a resource. For example, this can occur if you're trying to associate more than the allowed number of child assets or attempting to create more than the allowed number of properties for an asset model. For more information, see [Quotas](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/quotas.html) in the IoT SiteWise User Guide.
public struct LimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "LimitExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct LimitExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension LimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListAccessPoliciesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let resourceId = resourceId {
                let resourceIdQueryItem = ClientRuntime.URLQueryItem(name: "resourceId".urlPercentEncoding(), value: Swift.String(resourceId).urlPercentEncoding())
                items.append(resourceIdQueryItem)
            }
            if let identityType = identityType {
                let identityTypeQueryItem = ClientRuntime.URLQueryItem(name: "identityType".urlPercentEncoding(), value: Swift.String(identityType.rawValue).urlPercentEncoding())
                items.append(identityTypeQueryItem)
            }
            if let identityId = identityId {
                let identityIdQueryItem = ClientRuntime.URLQueryItem(name: "identityId".urlPercentEncoding(), value: Swift.String(identityId).urlPercentEncoding())
                items.append(identityIdQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let iamArn = iamArn {
                let iamArnQueryItem = ClientRuntime.URLQueryItem(name: "iamArn".urlPercentEncoding(), value: Swift.String(iamArn).urlPercentEncoding())
                items.append(iamArnQueryItem)
            }
            if let resourceType = resourceType {
                let resourceTypeQueryItem = ClientRuntime.URLQueryItem(name: "resourceType".urlPercentEncoding(), value: Swift.String(resourceType.rawValue).urlPercentEncoding())
                items.append(resourceTypeQueryItem)
            }
            return items
        }
    }
}

extension ListAccessPoliciesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/access-policies"
    }
}

public struct ListAccessPoliciesInput: Swift.Equatable {
    /// The ARN of the IAM user. For more information, see [IAM ARNs](https://docs.aws.amazon.com/IAM/latest/UserGuide/reference_identifiers.html) in the IAM User Guide. This parameter is required if you specify IAM for identityType.
    public var iamArn: Swift.String?
    /// The ID of the identity. This parameter is required if you specify USER or GROUP for identityType.
    public var identityId: Swift.String?
    /// The type of identity (IAM Identity Center user, IAM Identity Center group, or IAM user). This parameter is required if you specify identityId.
    public var identityType: IoTSiteWiseClientTypes.IdentityType?
    /// The maximum number of results to return for each paginated request. Default: 50
    public var maxResults: Swift.Int?
    /// The token to be used for the next set of paginated results.
    public var nextToken: Swift.String?
    /// The ID of the resource. This parameter is required if you specify resourceType.
    public var resourceId: Swift.String?
    /// The type of resource (portal or project). This parameter is required if you specify resourceId.
    public var resourceType: IoTSiteWiseClientTypes.ResourceType?

    public init(
        iamArn: Swift.String? = nil,
        identityId: Swift.String? = nil,
        identityType: IoTSiteWiseClientTypes.IdentityType? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: IoTSiteWiseClientTypes.ResourceType? = nil
    )
    {
        self.iamArn = iamArn
        self.identityId = identityId
        self.identityType = identityType
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceId = resourceId
        self.resourceType = resourceType
    }
}

struct ListAccessPoliciesInputBody: Swift.Equatable {
}

extension ListAccessPoliciesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListAccessPoliciesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListAccessPoliciesOutputBody = try responseDecoder.decode(responseBody: data)
            self.accessPolicySummaries = output.accessPolicySummaries
            self.nextToken = output.nextToken
        } else {
            self.accessPolicySummaries = nil
            self.nextToken = nil
        }
    }
}

public struct ListAccessPoliciesOutput: Swift.Equatable {
    /// A list that summarizes each access policy.
    /// This member is required.
    public var accessPolicySummaries: [IoTSiteWiseClientTypes.AccessPolicySummary]?
    /// The token for the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?

    public init(
        accessPolicySummaries: [IoTSiteWiseClientTypes.AccessPolicySummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.accessPolicySummaries = accessPolicySummaries
        self.nextToken = nextToken
    }
}

struct ListAccessPoliciesOutputBody: Swift.Equatable {
    let accessPolicySummaries: [IoTSiteWiseClientTypes.AccessPolicySummary]?
    let nextToken: Swift.String?
}

extension ListAccessPoliciesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessPolicySummaries
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessPolicySummariesContainer = try containerValues.decodeIfPresent([IoTSiteWiseClientTypes.AccessPolicySummary?].self, forKey: .accessPolicySummaries)
        var accessPolicySummariesDecoded0:[IoTSiteWiseClientTypes.AccessPolicySummary]? = nil
        if let accessPolicySummariesContainer = accessPolicySummariesContainer {
            accessPolicySummariesDecoded0 = [IoTSiteWiseClientTypes.AccessPolicySummary]()
            for structure0 in accessPolicySummariesContainer {
                if let structure0 = structure0 {
                    accessPolicySummariesDecoded0?.append(structure0)
                }
            }
        }
        accessPolicySummaries = accessPolicySummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListAccessPoliciesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension IoTSiteWiseClientTypes {
    public enum ListAssetModelPropertiesFilter: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case all
        case base
        case sdkUnknown(Swift.String)

        public static var allCases: [ListAssetModelPropertiesFilter] {
            return [
                .all,
                .base,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .all: return "ALL"
            case .base: return "BASE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ListAssetModelPropertiesFilter(rawValue: rawValue) ?? ListAssetModelPropertiesFilter.sdkUnknown(rawValue)
        }
    }
}

extension ListAssetModelPropertiesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let filter = filter {
                let filterQueryItem = ClientRuntime.URLQueryItem(name: "filter".urlPercentEncoding(), value: Swift.String(filter.rawValue).urlPercentEncoding())
                items.append(filterQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListAssetModelPropertiesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let assetModelId = assetModelId else {
            return nil
        }
        return "/asset-models/\(assetModelId.urlPercentEncoding())/properties"
    }
}

public struct ListAssetModelPropertiesInput: Swift.Equatable {
    /// The ID of the asset model.
    /// This member is required.
    public var assetModelId: Swift.String?
    /// Filters the requested list of asset model properties. You can choose one of the following options:
    ///
    /// * ALL  The list includes all asset model properties for a given asset model ID.
    ///
    /// * BASE  The list includes only base asset model properties for a given asset model ID.
    ///
    ///
    /// Default: BASE
    public var filter: IoTSiteWiseClientTypes.ListAssetModelPropertiesFilter?
    /// The maximum number of results to return for each paginated request. If not specified, the default value is 50.
    public var maxResults: Swift.Int?
    /// The token to be used for the next set of paginated results.
    public var nextToken: Swift.String?

    public init(
        assetModelId: Swift.String? = nil,
        filter: IoTSiteWiseClientTypes.ListAssetModelPropertiesFilter? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.assetModelId = assetModelId
        self.filter = filter
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListAssetModelPropertiesInputBody: Swift.Equatable {
}

extension ListAssetModelPropertiesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListAssetModelPropertiesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListAssetModelPropertiesOutputBody = try responseDecoder.decode(responseBody: data)
            self.assetModelPropertySummaries = output.assetModelPropertySummaries
            self.nextToken = output.nextToken
        } else {
            self.assetModelPropertySummaries = nil
            self.nextToken = nil
        }
    }
}

public struct ListAssetModelPropertiesOutput: Swift.Equatable {
    /// A list that summarizes the properties associated with the specified asset model.
    /// This member is required.
    public var assetModelPropertySummaries: [IoTSiteWiseClientTypes.AssetModelPropertySummary]?
    /// The token for the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?

    public init(
        assetModelPropertySummaries: [IoTSiteWiseClientTypes.AssetModelPropertySummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.assetModelPropertySummaries = assetModelPropertySummaries
        self.nextToken = nextToken
    }
}

struct ListAssetModelPropertiesOutputBody: Swift.Equatable {
    let assetModelPropertySummaries: [IoTSiteWiseClientTypes.AssetModelPropertySummary]?
    let nextToken: Swift.String?
}

extension ListAssetModelPropertiesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assetModelPropertySummaries
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assetModelPropertySummariesContainer = try containerValues.decodeIfPresent([IoTSiteWiseClientTypes.AssetModelPropertySummary?].self, forKey: .assetModelPropertySummaries)
        var assetModelPropertySummariesDecoded0:[IoTSiteWiseClientTypes.AssetModelPropertySummary]? = nil
        if let assetModelPropertySummariesContainer = assetModelPropertySummariesContainer {
            assetModelPropertySummariesDecoded0 = [IoTSiteWiseClientTypes.AssetModelPropertySummary]()
            for structure0 in assetModelPropertySummariesContainer {
                if let structure0 = structure0 {
                    assetModelPropertySummariesDecoded0?.append(structure0)
                }
            }
        }
        assetModelPropertySummaries = assetModelPropertySummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListAssetModelPropertiesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListAssetModelsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListAssetModelsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/asset-models"
    }
}

public struct ListAssetModelsInput: Swift.Equatable {
    /// The maximum number of results to return for each paginated request. Default: 50
    public var maxResults: Swift.Int?
    /// The token to be used for the next set of paginated results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListAssetModelsInputBody: Swift.Equatable {
}

extension ListAssetModelsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListAssetModelsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListAssetModelsOutputBody = try responseDecoder.decode(responseBody: data)
            self.assetModelSummaries = output.assetModelSummaries
            self.nextToken = output.nextToken
        } else {
            self.assetModelSummaries = nil
            self.nextToken = nil
        }
    }
}

public struct ListAssetModelsOutput: Swift.Equatable {
    /// A list that summarizes each asset model.
    /// This member is required.
    public var assetModelSummaries: [IoTSiteWiseClientTypes.AssetModelSummary]?
    /// The token for the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?

    public init(
        assetModelSummaries: [IoTSiteWiseClientTypes.AssetModelSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.assetModelSummaries = assetModelSummaries
        self.nextToken = nextToken
    }
}

struct ListAssetModelsOutputBody: Swift.Equatable {
    let assetModelSummaries: [IoTSiteWiseClientTypes.AssetModelSummary]?
    let nextToken: Swift.String?
}

extension ListAssetModelsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assetModelSummaries
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assetModelSummariesContainer = try containerValues.decodeIfPresent([IoTSiteWiseClientTypes.AssetModelSummary?].self, forKey: .assetModelSummaries)
        var assetModelSummariesDecoded0:[IoTSiteWiseClientTypes.AssetModelSummary]? = nil
        if let assetModelSummariesContainer = assetModelSummariesContainer {
            assetModelSummariesDecoded0 = [IoTSiteWiseClientTypes.AssetModelSummary]()
            for structure0 in assetModelSummariesContainer {
                if let structure0 = structure0 {
                    assetModelSummariesDecoded0?.append(structure0)
                }
            }
        }
        assetModelSummaries = assetModelSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListAssetModelsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension IoTSiteWiseClientTypes {
    public enum ListAssetPropertiesFilter: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case all
        case base
        case sdkUnknown(Swift.String)

        public static var allCases: [ListAssetPropertiesFilter] {
            return [
                .all,
                .base,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .all: return "ALL"
            case .base: return "BASE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ListAssetPropertiesFilter(rawValue: rawValue) ?? ListAssetPropertiesFilter.sdkUnknown(rawValue)
        }
    }
}

extension ListAssetPropertiesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let filter = filter {
                let filterQueryItem = ClientRuntime.URLQueryItem(name: "filter".urlPercentEncoding(), value: Swift.String(filter.rawValue).urlPercentEncoding())
                items.append(filterQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListAssetPropertiesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let assetId = assetId else {
            return nil
        }
        return "/assets/\(assetId.urlPercentEncoding())/properties"
    }
}

public struct ListAssetPropertiesInput: Swift.Equatable {
    /// The ID of the asset.
    /// This member is required.
    public var assetId: Swift.String?
    /// Filters the requested list of asset properties. You can choose one of the following options:
    ///
    /// * ALL  The list includes all asset properties for a given asset model ID.
    ///
    /// * BASE  The list includes only base asset properties for a given asset model ID.
    ///
    ///
    /// Default: BASE
    public var filter: IoTSiteWiseClientTypes.ListAssetPropertiesFilter?
    /// The maximum number of results to return for each paginated request. If not specified, the default value is 50.
    public var maxResults: Swift.Int?
    /// The token to be used for the next set of paginated results.
    public var nextToken: Swift.String?

    public init(
        assetId: Swift.String? = nil,
        filter: IoTSiteWiseClientTypes.ListAssetPropertiesFilter? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.assetId = assetId
        self.filter = filter
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListAssetPropertiesInputBody: Swift.Equatable {
}

extension ListAssetPropertiesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListAssetPropertiesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListAssetPropertiesOutputBody = try responseDecoder.decode(responseBody: data)
            self.assetPropertySummaries = output.assetPropertySummaries
            self.nextToken = output.nextToken
        } else {
            self.assetPropertySummaries = nil
            self.nextToken = nil
        }
    }
}

public struct ListAssetPropertiesOutput: Swift.Equatable {
    /// A list that summarizes the properties associated with the specified asset.
    /// This member is required.
    public var assetPropertySummaries: [IoTSiteWiseClientTypes.AssetPropertySummary]?
    /// The token for the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?

    public init(
        assetPropertySummaries: [IoTSiteWiseClientTypes.AssetPropertySummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.assetPropertySummaries = assetPropertySummaries
        self.nextToken = nextToken
    }
}

struct ListAssetPropertiesOutputBody: Swift.Equatable {
    let assetPropertySummaries: [IoTSiteWiseClientTypes.AssetPropertySummary]?
    let nextToken: Swift.String?
}

extension ListAssetPropertiesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assetPropertySummaries
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assetPropertySummariesContainer = try containerValues.decodeIfPresent([IoTSiteWiseClientTypes.AssetPropertySummary?].self, forKey: .assetPropertySummaries)
        var assetPropertySummariesDecoded0:[IoTSiteWiseClientTypes.AssetPropertySummary]? = nil
        if let assetPropertySummariesContainer = assetPropertySummariesContainer {
            assetPropertySummariesDecoded0 = [IoTSiteWiseClientTypes.AssetPropertySummary]()
            for structure0 in assetPropertySummariesContainer {
                if let structure0 = structure0 {
                    assetPropertySummariesDecoded0?.append(structure0)
                }
            }
        }
        assetPropertySummaries = assetPropertySummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListAssetPropertiesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListAssetRelationshipsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let traversalType = traversalType else {
                let message = "Creating a URL Query Item failed. traversalType is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let traversalTypeQueryItem = ClientRuntime.URLQueryItem(name: "traversalType".urlPercentEncoding(), value: Swift.String(traversalType.rawValue).urlPercentEncoding())
            items.append(traversalTypeQueryItem)
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListAssetRelationshipsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let assetId = assetId else {
            return nil
        }
        return "/assets/\(assetId.urlPercentEncoding())/assetRelationships"
    }
}

public struct ListAssetRelationshipsInput: Swift.Equatable {
    /// The ID of the asset.
    /// This member is required.
    public var assetId: Swift.String?
    /// The maximum number of results to return for each paginated request.
    public var maxResults: Swift.Int?
    /// The token to be used for the next set of paginated results.
    public var nextToken: Swift.String?
    /// The type of traversal to use to identify asset relationships. Choose the following option:
    ///
    /// * PATH_TO_ROOT  Identify the asset's parent assets up to the root asset. The asset that you specify in assetId is the first result in the list of assetRelationshipSummaries, and the root asset is the last result.
    /// This member is required.
    public var traversalType: IoTSiteWiseClientTypes.TraversalType?

    public init(
        assetId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        traversalType: IoTSiteWiseClientTypes.TraversalType? = nil
    )
    {
        self.assetId = assetId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.traversalType = traversalType
    }
}

struct ListAssetRelationshipsInputBody: Swift.Equatable {
}

extension ListAssetRelationshipsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListAssetRelationshipsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListAssetRelationshipsOutputBody = try responseDecoder.decode(responseBody: data)
            self.assetRelationshipSummaries = output.assetRelationshipSummaries
            self.nextToken = output.nextToken
        } else {
            self.assetRelationshipSummaries = nil
            self.nextToken = nil
        }
    }
}

public struct ListAssetRelationshipsOutput: Swift.Equatable {
    /// A list that summarizes each asset relationship.
    /// This member is required.
    public var assetRelationshipSummaries: [IoTSiteWiseClientTypes.AssetRelationshipSummary]?
    /// The token for the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?

    public init(
        assetRelationshipSummaries: [IoTSiteWiseClientTypes.AssetRelationshipSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.assetRelationshipSummaries = assetRelationshipSummaries
        self.nextToken = nextToken
    }
}

struct ListAssetRelationshipsOutputBody: Swift.Equatable {
    let assetRelationshipSummaries: [IoTSiteWiseClientTypes.AssetRelationshipSummary]?
    let nextToken: Swift.String?
}

extension ListAssetRelationshipsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assetRelationshipSummaries
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assetRelationshipSummariesContainer = try containerValues.decodeIfPresent([IoTSiteWiseClientTypes.AssetRelationshipSummary?].self, forKey: .assetRelationshipSummaries)
        var assetRelationshipSummariesDecoded0:[IoTSiteWiseClientTypes.AssetRelationshipSummary]? = nil
        if let assetRelationshipSummariesContainer = assetRelationshipSummariesContainer {
            assetRelationshipSummariesDecoded0 = [IoTSiteWiseClientTypes.AssetRelationshipSummary]()
            for structure0 in assetRelationshipSummariesContainer {
                if let structure0 = structure0 {
                    assetRelationshipSummariesDecoded0?.append(structure0)
                }
            }
        }
        assetRelationshipSummaries = assetRelationshipSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListAssetRelationshipsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension IoTSiteWiseClientTypes {
    public enum ListAssetsFilter: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case all
        case topLevel
        case sdkUnknown(Swift.String)

        public static var allCases: [ListAssetsFilter] {
            return [
                .all,
                .topLevel,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .all: return "ALL"
            case .topLevel: return "TOP_LEVEL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ListAssetsFilter(rawValue: rawValue) ?? ListAssetsFilter.sdkUnknown(rawValue)
        }
    }
}

extension ListAssetsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let filter = filter {
                let filterQueryItem = ClientRuntime.URLQueryItem(name: "filter".urlPercentEncoding(), value: Swift.String(filter.rawValue).urlPercentEncoding())
                items.append(filterQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let assetModelId = assetModelId {
                let assetModelIdQueryItem = ClientRuntime.URLQueryItem(name: "assetModelId".urlPercentEncoding(), value: Swift.String(assetModelId).urlPercentEncoding())
                items.append(assetModelIdQueryItem)
            }
            return items
        }
    }
}

extension ListAssetsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/assets"
    }
}

public struct ListAssetsInput: Swift.Equatable {
    /// The ID of the asset model by which to filter the list of assets. This parameter is required if you choose ALL for filter.
    public var assetModelId: Swift.String?
    /// The filter for the requested list of assets. Choose one of the following options:
    ///
    /// * ALL  The list includes all assets for a given asset model ID. The assetModelId parameter is required if you filter by ALL.
    ///
    /// * TOP_LEVEL  The list includes only top-level assets in the asset hierarchy tree.
    ///
    ///
    /// Default: ALL
    public var filter: IoTSiteWiseClientTypes.ListAssetsFilter?
    /// The maximum number of results to return for each paginated request. Default: 50
    public var maxResults: Swift.Int?
    /// The token to be used for the next set of paginated results.
    public var nextToken: Swift.String?

    public init(
        assetModelId: Swift.String? = nil,
        filter: IoTSiteWiseClientTypes.ListAssetsFilter? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.assetModelId = assetModelId
        self.filter = filter
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListAssetsInputBody: Swift.Equatable {
}

extension ListAssetsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListAssetsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListAssetsOutputBody = try responseDecoder.decode(responseBody: data)
            self.assetSummaries = output.assetSummaries
            self.nextToken = output.nextToken
        } else {
            self.assetSummaries = nil
            self.nextToken = nil
        }
    }
}

public struct ListAssetsOutput: Swift.Equatable {
    /// A list that summarizes each asset.
    /// This member is required.
    public var assetSummaries: [IoTSiteWiseClientTypes.AssetSummary]?
    /// The token for the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?

    public init(
        assetSummaries: [IoTSiteWiseClientTypes.AssetSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.assetSummaries = assetSummaries
        self.nextToken = nextToken
    }
}

struct ListAssetsOutputBody: Swift.Equatable {
    let assetSummaries: [IoTSiteWiseClientTypes.AssetSummary]?
    let nextToken: Swift.String?
}

extension ListAssetsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assetSummaries
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assetSummariesContainer = try containerValues.decodeIfPresent([IoTSiteWiseClientTypes.AssetSummary?].self, forKey: .assetSummaries)
        var assetSummariesDecoded0:[IoTSiteWiseClientTypes.AssetSummary]? = nil
        if let assetSummariesContainer = assetSummariesContainer {
            assetSummariesDecoded0 = [IoTSiteWiseClientTypes.AssetSummary]()
            for structure0 in assetSummariesContainer {
                if let structure0 = structure0 {
                    assetSummariesDecoded0?.append(structure0)
                }
            }
        }
        assetSummaries = assetSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListAssetsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListAssociatedAssetsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let traversalDirection = traversalDirection {
                let traversalDirectionQueryItem = ClientRuntime.URLQueryItem(name: "traversalDirection".urlPercentEncoding(), value: Swift.String(traversalDirection.rawValue).urlPercentEncoding())
                items.append(traversalDirectionQueryItem)
            }
            if let hierarchyId = hierarchyId {
                let hierarchyIdQueryItem = ClientRuntime.URLQueryItem(name: "hierarchyId".urlPercentEncoding(), value: Swift.String(hierarchyId).urlPercentEncoding())
                items.append(hierarchyIdQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListAssociatedAssetsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let assetId = assetId else {
            return nil
        }
        return "/assets/\(assetId.urlPercentEncoding())/hierarchies"
    }
}

public struct ListAssociatedAssetsInput: Swift.Equatable {
    /// The ID of the asset to query.
    /// This member is required.
    public var assetId: Swift.String?
    /// The ID of the hierarchy by which child assets are associated to the asset. To find a hierarchy ID, use the [DescribeAsset](https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_DescribeAsset.html) or [DescribeAssetModel](https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_DescribeAssetModel.html) operations. This parameter is required if you choose CHILD for traversalDirection. For more information, see [Asset hierarchies](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/asset-hierarchies.html) in the IoT SiteWise User Guide.
    public var hierarchyId: Swift.String?
    /// The maximum number of results to return for each paginated request. Default: 50
    public var maxResults: Swift.Int?
    /// The token to be used for the next set of paginated results.
    public var nextToken: Swift.String?
    /// The direction to list associated assets. Choose one of the following options:
    ///
    /// * CHILD  The list includes all child assets associated to the asset. The hierarchyId parameter is required if you choose CHILD.
    ///
    /// * PARENT  The list includes the asset's parent asset.
    ///
    ///
    /// Default: CHILD
    public var traversalDirection: IoTSiteWiseClientTypes.TraversalDirection?

    public init(
        assetId: Swift.String? = nil,
        hierarchyId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        traversalDirection: IoTSiteWiseClientTypes.TraversalDirection? = nil
    )
    {
        self.assetId = assetId
        self.hierarchyId = hierarchyId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.traversalDirection = traversalDirection
    }
}

struct ListAssociatedAssetsInputBody: Swift.Equatable {
}

extension ListAssociatedAssetsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListAssociatedAssetsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListAssociatedAssetsOutputBody = try responseDecoder.decode(responseBody: data)
            self.assetSummaries = output.assetSummaries
            self.nextToken = output.nextToken
        } else {
            self.assetSummaries = nil
            self.nextToken = nil
        }
    }
}

public struct ListAssociatedAssetsOutput: Swift.Equatable {
    /// A list that summarizes the associated assets.
    /// This member is required.
    public var assetSummaries: [IoTSiteWiseClientTypes.AssociatedAssetsSummary]?
    /// The token for the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?

    public init(
        assetSummaries: [IoTSiteWiseClientTypes.AssociatedAssetsSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.assetSummaries = assetSummaries
        self.nextToken = nextToken
    }
}

struct ListAssociatedAssetsOutputBody: Swift.Equatable {
    let assetSummaries: [IoTSiteWiseClientTypes.AssociatedAssetsSummary]?
    let nextToken: Swift.String?
}

extension ListAssociatedAssetsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assetSummaries
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assetSummariesContainer = try containerValues.decodeIfPresent([IoTSiteWiseClientTypes.AssociatedAssetsSummary?].self, forKey: .assetSummaries)
        var assetSummariesDecoded0:[IoTSiteWiseClientTypes.AssociatedAssetsSummary]? = nil
        if let assetSummariesContainer = assetSummariesContainer {
            assetSummariesDecoded0 = [IoTSiteWiseClientTypes.AssociatedAssetsSummary]()
            for structure0 in assetSummariesContainer {
                if let structure0 = structure0 {
                    assetSummariesDecoded0?.append(structure0)
                }
            }
        }
        assetSummaries = assetSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListAssociatedAssetsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension IoTSiteWiseClientTypes {
    public enum ListBulkImportJobsFilter: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case all
        case cancelled
        case completed
        case completedWithFailures
        case failed
        case pending
        case running
        case sdkUnknown(Swift.String)

        public static var allCases: [ListBulkImportJobsFilter] {
            return [
                .all,
                .cancelled,
                .completed,
                .completedWithFailures,
                .failed,
                .pending,
                .running,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .all: return "ALL"
            case .cancelled: return "CANCELLED"
            case .completed: return "COMPLETED"
            case .completedWithFailures: return "COMPLETED_WITH_FAILURES"
            case .failed: return "FAILED"
            case .pending: return "PENDING"
            case .running: return "RUNNING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ListBulkImportJobsFilter(rawValue: rawValue) ?? ListBulkImportJobsFilter.sdkUnknown(rawValue)
        }
    }
}

extension ListBulkImportJobsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let filter = filter {
                let filterQueryItem = ClientRuntime.URLQueryItem(name: "filter".urlPercentEncoding(), value: Swift.String(filter.rawValue).urlPercentEncoding())
                items.append(filterQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListBulkImportJobsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/jobs"
    }
}

public struct ListBulkImportJobsInput: Swift.Equatable {
    /// You can use a filter to select the bulk import jobs that you want to retrieve.
    public var filter: IoTSiteWiseClientTypes.ListBulkImportJobsFilter?
    /// The maximum number of results to return for each paginated request.
    public var maxResults: Swift.Int?
    /// The token to be used for the next set of paginated results.
    public var nextToken: Swift.String?

    public init(
        filter: IoTSiteWiseClientTypes.ListBulkImportJobsFilter? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filter = filter
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListBulkImportJobsInputBody: Swift.Equatable {
}

extension ListBulkImportJobsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListBulkImportJobsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListBulkImportJobsOutputBody = try responseDecoder.decode(responseBody: data)
            self.jobSummaries = output.jobSummaries
            self.nextToken = output.nextToken
        } else {
            self.jobSummaries = nil
            self.nextToken = nil
        }
    }
}

public struct ListBulkImportJobsOutput: Swift.Equatable {
    /// One or more job summaries to list.
    /// This member is required.
    public var jobSummaries: [IoTSiteWiseClientTypes.JobSummary]?
    /// The token for the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?

    public init(
        jobSummaries: [IoTSiteWiseClientTypes.JobSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.jobSummaries = jobSummaries
        self.nextToken = nextToken
    }
}

struct ListBulkImportJobsOutputBody: Swift.Equatable {
    let jobSummaries: [IoTSiteWiseClientTypes.JobSummary]?
    let nextToken: Swift.String?
}

extension ListBulkImportJobsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobSummaries
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobSummariesContainer = try containerValues.decodeIfPresent([IoTSiteWiseClientTypes.JobSummary?].self, forKey: .jobSummaries)
        var jobSummariesDecoded0:[IoTSiteWiseClientTypes.JobSummary]? = nil
        if let jobSummariesContainer = jobSummariesContainer {
            jobSummariesDecoded0 = [IoTSiteWiseClientTypes.JobSummary]()
            for structure0 in jobSummariesContainer {
                if let structure0 = structure0 {
                    jobSummariesDecoded0?.append(structure0)
                }
            }
        }
        jobSummaries = jobSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListBulkImportJobsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListDashboardsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            guard let projectId = projectId else {
                let message = "Creating a URL Query Item failed. projectId is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let projectIdQueryItem = ClientRuntime.URLQueryItem(name: "projectId".urlPercentEncoding(), value: Swift.String(projectId).urlPercentEncoding())
            items.append(projectIdQueryItem)
            return items
        }
    }
}

extension ListDashboardsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/dashboards"
    }
}

public struct ListDashboardsInput: Swift.Equatable {
    /// The maximum number of results to return for each paginated request. Default: 50
    public var maxResults: Swift.Int?
    /// The token to be used for the next set of paginated results.
    public var nextToken: Swift.String?
    /// The ID of the project.
    /// This member is required.
    public var projectId: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        projectId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.projectId = projectId
    }
}

struct ListDashboardsInputBody: Swift.Equatable {
}

extension ListDashboardsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListDashboardsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListDashboardsOutputBody = try responseDecoder.decode(responseBody: data)
            self.dashboardSummaries = output.dashboardSummaries
            self.nextToken = output.nextToken
        } else {
            self.dashboardSummaries = nil
            self.nextToken = nil
        }
    }
}

public struct ListDashboardsOutput: Swift.Equatable {
    /// A list that summarizes each dashboard in the project.
    /// This member is required.
    public var dashboardSummaries: [IoTSiteWiseClientTypes.DashboardSummary]?
    /// The token for the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?

    public init(
        dashboardSummaries: [IoTSiteWiseClientTypes.DashboardSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.dashboardSummaries = dashboardSummaries
        self.nextToken = nextToken
    }
}

struct ListDashboardsOutputBody: Swift.Equatable {
    let dashboardSummaries: [IoTSiteWiseClientTypes.DashboardSummary]?
    let nextToken: Swift.String?
}

extension ListDashboardsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dashboardSummaries
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dashboardSummariesContainer = try containerValues.decodeIfPresent([IoTSiteWiseClientTypes.DashboardSummary?].self, forKey: .dashboardSummaries)
        var dashboardSummariesDecoded0:[IoTSiteWiseClientTypes.DashboardSummary]? = nil
        if let dashboardSummariesContainer = dashboardSummariesContainer {
            dashboardSummariesDecoded0 = [IoTSiteWiseClientTypes.DashboardSummary]()
            for structure0 in dashboardSummariesContainer {
                if let structure0 = structure0 {
                    dashboardSummariesDecoded0?.append(structure0)
                }
            }
        }
        dashboardSummaries = dashboardSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListDashboardsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListGatewaysInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListGatewaysInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/20200301/gateways"
    }
}

public struct ListGatewaysInput: Swift.Equatable {
    /// The maximum number of results to return for each paginated request. Default: 50
    public var maxResults: Swift.Int?
    /// The token to be used for the next set of paginated results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListGatewaysInputBody: Swift.Equatable {
}

extension ListGatewaysInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListGatewaysOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListGatewaysOutputBody = try responseDecoder.decode(responseBody: data)
            self.gatewaySummaries = output.gatewaySummaries
            self.nextToken = output.nextToken
        } else {
            self.gatewaySummaries = nil
            self.nextToken = nil
        }
    }
}

public struct ListGatewaysOutput: Swift.Equatable {
    /// A list that summarizes each gateway.
    /// This member is required.
    public var gatewaySummaries: [IoTSiteWiseClientTypes.GatewaySummary]?
    /// The token for the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?

    public init(
        gatewaySummaries: [IoTSiteWiseClientTypes.GatewaySummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.gatewaySummaries = gatewaySummaries
        self.nextToken = nextToken
    }
}

struct ListGatewaysOutputBody: Swift.Equatable {
    let gatewaySummaries: [IoTSiteWiseClientTypes.GatewaySummary]?
    let nextToken: Swift.String?
}

extension ListGatewaysOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewaySummaries
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewaySummariesContainer = try containerValues.decodeIfPresent([IoTSiteWiseClientTypes.GatewaySummary?].self, forKey: .gatewaySummaries)
        var gatewaySummariesDecoded0:[IoTSiteWiseClientTypes.GatewaySummary]? = nil
        if let gatewaySummariesContainer = gatewaySummariesContainer {
            gatewaySummariesDecoded0 = [IoTSiteWiseClientTypes.GatewaySummary]()
            for structure0 in gatewaySummariesContainer {
                if let structure0 = structure0 {
                    gatewaySummariesDecoded0?.append(structure0)
                }
            }
        }
        gatewaySummaries = gatewaySummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListGatewaysOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListPortalsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListPortalsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/portals"
    }
}

public struct ListPortalsInput: Swift.Equatable {
    /// The maximum number of results to return for each paginated request. Default: 50
    public var maxResults: Swift.Int?
    /// The token to be used for the next set of paginated results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListPortalsInputBody: Swift.Equatable {
}

extension ListPortalsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListPortalsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListPortalsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.portalSummaries = output.portalSummaries
        } else {
            self.nextToken = nil
            self.portalSummaries = nil
        }
    }
}

public struct ListPortalsOutput: Swift.Equatable {
    /// The token for the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?
    /// A list that summarizes each portal.
    public var portalSummaries: [IoTSiteWiseClientTypes.PortalSummary]?

    public init(
        nextToken: Swift.String? = nil,
        portalSummaries: [IoTSiteWiseClientTypes.PortalSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.portalSummaries = portalSummaries
    }
}

struct ListPortalsOutputBody: Swift.Equatable {
    let portalSummaries: [IoTSiteWiseClientTypes.PortalSummary]?
    let nextToken: Swift.String?
}

extension ListPortalsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case portalSummaries
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let portalSummariesContainer = try containerValues.decodeIfPresent([IoTSiteWiseClientTypes.PortalSummary?].self, forKey: .portalSummaries)
        var portalSummariesDecoded0:[IoTSiteWiseClientTypes.PortalSummary]? = nil
        if let portalSummariesContainer = portalSummariesContainer {
            portalSummariesDecoded0 = [IoTSiteWiseClientTypes.PortalSummary]()
            for structure0 in portalSummariesContainer {
                if let structure0 = structure0 {
                    portalSummariesDecoded0?.append(structure0)
                }
            }
        }
        portalSummaries = portalSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListPortalsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListProjectAssetsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListProjectAssetsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let projectId = projectId else {
            return nil
        }
        return "/projects/\(projectId.urlPercentEncoding())/assets"
    }
}

public struct ListProjectAssetsInput: Swift.Equatable {
    /// The maximum number of results to return for each paginated request. Default: 50
    public var maxResults: Swift.Int?
    /// The token to be used for the next set of paginated results.
    public var nextToken: Swift.String?
    /// The ID of the project.
    /// This member is required.
    public var projectId: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        projectId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.projectId = projectId
    }
}

struct ListProjectAssetsInputBody: Swift.Equatable {
}

extension ListProjectAssetsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListProjectAssetsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListProjectAssetsOutputBody = try responseDecoder.decode(responseBody: data)
            self.assetIds = output.assetIds
            self.nextToken = output.nextToken
        } else {
            self.assetIds = nil
            self.nextToken = nil
        }
    }
}

public struct ListProjectAssetsOutput: Swift.Equatable {
    /// A list that contains the IDs of each asset associated with the project.
    /// This member is required.
    public var assetIds: [Swift.String]?
    /// The token for the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?

    public init(
        assetIds: [Swift.String]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.assetIds = assetIds
        self.nextToken = nextToken
    }
}

struct ListProjectAssetsOutputBody: Swift.Equatable {
    let assetIds: [Swift.String]?
    let nextToken: Swift.String?
}

extension ListProjectAssetsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assetIds
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assetIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .assetIds)
        var assetIdsDecoded0:[Swift.String]? = nil
        if let assetIdsContainer = assetIdsContainer {
            assetIdsDecoded0 = [Swift.String]()
            for string0 in assetIdsContainer {
                if let string0 = string0 {
                    assetIdsDecoded0?.append(string0)
                }
            }
        }
        assetIds = assetIdsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListProjectAssetsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListProjectsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            guard let portalId = portalId else {
                let message = "Creating a URL Query Item failed. portalId is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let portalIdQueryItem = ClientRuntime.URLQueryItem(name: "portalId".urlPercentEncoding(), value: Swift.String(portalId).urlPercentEncoding())
            items.append(portalIdQueryItem)
            return items
        }
    }
}

extension ListProjectsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/projects"
    }
}

public struct ListProjectsInput: Swift.Equatable {
    /// The maximum number of results to return for each paginated request. Default: 50
    public var maxResults: Swift.Int?
    /// The token to be used for the next set of paginated results.
    public var nextToken: Swift.String?
    /// The ID of the portal.
    /// This member is required.
    public var portalId: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        portalId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.portalId = portalId
    }
}

struct ListProjectsInputBody: Swift.Equatable {
}

extension ListProjectsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListProjectsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListProjectsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.projectSummaries = output.projectSummaries
        } else {
            self.nextToken = nil
            self.projectSummaries = nil
        }
    }
}

public struct ListProjectsOutput: Swift.Equatable {
    /// The token for the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?
    /// A list that summarizes each project in the portal.
    /// This member is required.
    public var projectSummaries: [IoTSiteWiseClientTypes.ProjectSummary]?

    public init(
        nextToken: Swift.String? = nil,
        projectSummaries: [IoTSiteWiseClientTypes.ProjectSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.projectSummaries = projectSummaries
    }
}

struct ListProjectsOutputBody: Swift.Equatable {
    let projectSummaries: [IoTSiteWiseClientTypes.ProjectSummary]?
    let nextToken: Swift.String?
}

extension ListProjectsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case projectSummaries
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let projectSummariesContainer = try containerValues.decodeIfPresent([IoTSiteWiseClientTypes.ProjectSummary?].self, forKey: .projectSummaries)
        var projectSummariesDecoded0:[IoTSiteWiseClientTypes.ProjectSummary]? = nil
        if let projectSummariesContainer = projectSummariesContainer {
            projectSummariesDecoded0 = [IoTSiteWiseClientTypes.ProjectSummary]()
            for structure0 in projectSummariesContainer {
                if let structure0 = structure0 {
                    projectSummariesDecoded0?.append(structure0)
                }
            }
        }
        projectSummaries = projectSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListProjectsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTagsForResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let resourceArn = resourceArn else {
                let message = "Creating a URL Query Item failed. resourceArn is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let resourceArnQueryItem = ClientRuntime.URLQueryItem(name: "resourceArn".urlPercentEncoding(), value: Swift.String(resourceArn).urlPercentEncoding())
            items.append(resourceArnQueryItem)
            return items
        }
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/tags"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The [ARN](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutput: Swift.Equatable {
    /// The list of key-value pairs that contain metadata for the resource. For more information, see [Tagging your IoT SiteWise resources](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/tag-resources.html) in the IoT SiteWise User Guide.
    public var tags: [Swift.String:Swift.String]?

    public init(
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension ListTagsForResourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum ListTagsForResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictingOperationException": return try await ConflictingOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTimeSeriesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let assetId = assetId {
                let assetIdQueryItem = ClientRuntime.URLQueryItem(name: "assetId".urlPercentEncoding(), value: Swift.String(assetId).urlPercentEncoding())
                items.append(assetIdQueryItem)
            }
            if let timeSeriesType = timeSeriesType {
                let timeSeriesTypeQueryItem = ClientRuntime.URLQueryItem(name: "timeSeriesType".urlPercentEncoding(), value: Swift.String(timeSeriesType.rawValue).urlPercentEncoding())
                items.append(timeSeriesTypeQueryItem)
            }
            if let aliasPrefix = aliasPrefix {
                let aliasPrefixQueryItem = ClientRuntime.URLQueryItem(name: "aliasPrefix".urlPercentEncoding(), value: Swift.String(aliasPrefix).urlPercentEncoding())
                items.append(aliasPrefixQueryItem)
            }
            return items
        }
    }
}

extension ListTimeSeriesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/timeseries"
    }
}

public struct ListTimeSeriesInput: Swift.Equatable {
    /// The alias prefix of the time series.
    public var aliasPrefix: Swift.String?
    /// The ID of the asset in which the asset property was created.
    public var assetId: Swift.String?
    /// The maximum number of results to return for each paginated request.
    public var maxResults: Swift.Int?
    /// The token to be used for the next set of paginated results.
    public var nextToken: Swift.String?
    /// The type of the time series. The time series type can be one of the following values:
    ///
    /// * ASSOCIATED  The time series is associated with an asset property.
    ///
    /// * DISASSOCIATED  The time series isn't associated with any asset property.
    public var timeSeriesType: IoTSiteWiseClientTypes.ListTimeSeriesType?

    public init(
        aliasPrefix: Swift.String? = nil,
        assetId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        timeSeriesType: IoTSiteWiseClientTypes.ListTimeSeriesType? = nil
    )
    {
        self.aliasPrefix = aliasPrefix
        self.assetId = assetId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.timeSeriesType = timeSeriesType
    }
}

struct ListTimeSeriesInputBody: Swift.Equatable {
}

extension ListTimeSeriesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListTimeSeriesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTimeSeriesOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.timeSeriesSummaries = output.timeSeriesSummaries
        } else {
            self.timeSeriesSummaries = nil
            self.nextToken = nil
        }
    }
}

public struct ListTimeSeriesOutput: Swift.Equatable {
    /// The token for the next set of results, or null if there are no additional results.
    public var nextToken: Swift.String?
    /// One or more time series summaries to list.
    /// This member is required.
    public var timeSeriesSummaries: [IoTSiteWiseClientTypes.TimeSeriesSummary]?

    public init(
        nextToken: Swift.String? = nil,
        timeSeriesSummaries: [IoTSiteWiseClientTypes.TimeSeriesSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.timeSeriesSummaries = timeSeriesSummaries
    }
}

struct ListTimeSeriesOutputBody: Swift.Equatable {
    let timeSeriesSummaries: [IoTSiteWiseClientTypes.TimeSeriesSummary]?
    let nextToken: Swift.String?
}

extension ListTimeSeriesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case timeSeriesSummaries = "TimeSeriesSummaries"
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timeSeriesSummariesContainer = try containerValues.decodeIfPresent([IoTSiteWiseClientTypes.TimeSeriesSummary?].self, forKey: .timeSeriesSummaries)
        var timeSeriesSummariesDecoded0:[IoTSiteWiseClientTypes.TimeSeriesSummary]? = nil
        if let timeSeriesSummariesContainer = timeSeriesSummariesContainer {
            timeSeriesSummariesDecoded0 = [IoTSiteWiseClientTypes.TimeSeriesSummary]()
            for structure0 in timeSeriesSummariesContainer {
                if let structure0 = structure0 {
                    timeSeriesSummariesDecoded0?.append(structure0)
                }
            }
        }
        timeSeriesSummaries = timeSeriesSummariesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListTimeSeriesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension IoTSiteWiseClientTypes {
    public enum ListTimeSeriesType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case associated
        case disassociated
        case sdkUnknown(Swift.String)

        public static var allCases: [ListTimeSeriesType] {
            return [
                .associated,
                .disassociated,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .associated: return "ASSOCIATED"
            case .disassociated: return "DISASSOCIATED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ListTimeSeriesType(rawValue: rawValue) ?? ListTimeSeriesType.sdkUnknown(rawValue)
        }
    }
}

extension IoTSiteWiseClientTypes {
    public enum LoggingLevel: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case error
        case info
        case off
        case sdkUnknown(Swift.String)

        public static var allCases: [LoggingLevel] {
            return [
                .error,
                .info,
                .off,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .error: return "ERROR"
            case .info: return "INFO"
            case .off: return "OFF"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LoggingLevel(rawValue: rawValue) ?? LoggingLevel.sdkUnknown(rawValue)
        }
    }
}

extension IoTSiteWiseClientTypes.LoggingOptions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case level
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let level = self.level {
            try encodeContainer.encode(level.rawValue, forKey: .level)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let levelDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.LoggingLevel.self, forKey: .level)
        level = levelDecoded
    }
}

extension IoTSiteWiseClientTypes {
    /// Contains logging options.
    public struct LoggingOptions: Swift.Equatable {
        /// The IoT SiteWise logging verbosity level.
        /// This member is required.
        public var level: IoTSiteWiseClientTypes.LoggingLevel?

        public init(
            level: IoTSiteWiseClientTypes.LoggingLevel? = nil
        )
        {
            self.level = level
        }
    }

}

extension IoTSiteWiseClientTypes.Measurement: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case processingConfig
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let processingConfig = self.processingConfig {
            try encodeContainer.encode(processingConfig, forKey: .processingConfig)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let processingConfigDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.MeasurementProcessingConfig.self, forKey: .processingConfig)
        processingConfig = processingConfigDecoded
    }
}

extension IoTSiteWiseClientTypes {
    /// Contains an asset measurement property. For more information, see [Measurements](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/asset-properties.html#measurements) in the IoT SiteWise User Guide.
    public struct Measurement: Swift.Equatable {
        /// The processing configuration for the given measurement property. You can configure measurements to be kept at the edge or forwarded to the Amazon Web Services Cloud. By default, measurements are forwarded to the cloud.
        public var processingConfig: IoTSiteWiseClientTypes.MeasurementProcessingConfig?

        public init(
            processingConfig: IoTSiteWiseClientTypes.MeasurementProcessingConfig? = nil
        )
        {
            self.processingConfig = processingConfig
        }
    }

}

extension IoTSiteWiseClientTypes.MeasurementProcessingConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case forwardingConfig
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let forwardingConfig = self.forwardingConfig {
            try encodeContainer.encode(forwardingConfig, forKey: .forwardingConfig)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let forwardingConfigDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.ForwardingConfig.self, forKey: .forwardingConfig)
        forwardingConfig = forwardingConfigDecoded
    }
}

extension IoTSiteWiseClientTypes {
    /// The processing configuration for the given measurement property. You can configure measurements to be kept at the edge or forwarded to the Amazon Web Services Cloud. By default, measurements are forwarded to the cloud.
    public struct MeasurementProcessingConfig: Swift.Equatable {
        /// The forwarding configuration for the given measurement property.
        /// This member is required.
        public var forwardingConfig: IoTSiteWiseClientTypes.ForwardingConfig?

        public init(
            forwardingConfig: IoTSiteWiseClientTypes.ForwardingConfig? = nil
        )
        {
            self.forwardingConfig = forwardingConfig
        }
    }

}

extension IoTSiteWiseClientTypes.Metric: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case expression
        case processingConfig
        case variables
        case window
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let expression = self.expression {
            try encodeContainer.encode(expression, forKey: .expression)
        }
        if let processingConfig = self.processingConfig {
            try encodeContainer.encode(processingConfig, forKey: .processingConfig)
        }
        if let variables = variables {
            var variablesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .variables)
            for expressionvariable0 in variables {
                try variablesContainer.encode(expressionvariable0)
            }
        }
        if let window = self.window {
            try encodeContainer.encode(window, forKey: .window)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let expressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .expression)
        expression = expressionDecoded
        let variablesContainer = try containerValues.decodeIfPresent([IoTSiteWiseClientTypes.ExpressionVariable?].self, forKey: .variables)
        var variablesDecoded0:[IoTSiteWiseClientTypes.ExpressionVariable]? = nil
        if let variablesContainer = variablesContainer {
            variablesDecoded0 = [IoTSiteWiseClientTypes.ExpressionVariable]()
            for structure0 in variablesContainer {
                if let structure0 = structure0 {
                    variablesDecoded0?.append(structure0)
                }
            }
        }
        variables = variablesDecoded0
        let windowDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.MetricWindow.self, forKey: .window)
        window = windowDecoded
        let processingConfigDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.MetricProcessingConfig.self, forKey: .processingConfig)
        processingConfig = processingConfigDecoded
    }
}

extension IoTSiteWiseClientTypes {
    /// Contains an asset metric property. With metrics, you can calculate aggregate functions, such as an average, maximum, or minimum, as specified through an expression. A metric maps several values to a single value (such as a sum). The maximum number of dependent/cascading variables used in any one metric calculation is 10. Therefore, a root metric can have up to 10 cascading metrics in its computational dependency tree. Additionally, a metric can only have a data type of DOUBLE and consume properties with data types of INTEGER or DOUBLE. For more information, see [Metrics](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/asset-properties.html#metrics) in the IoT SiteWise User Guide.
    public struct Metric: Swift.Equatable {
        /// The mathematical expression that defines the metric aggregation function. You can specify up to 10 variables per expression. You can specify up to 10 functions per expression. For more information, see [Quotas](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/quotas.html) in the IoT SiteWise User Guide.
        /// This member is required.
        public var expression: Swift.String?
        /// The processing configuration for the given metric property. You can configure metrics to be computed at the edge or in the Amazon Web Services Cloud. By default, metrics are forwarded to the cloud.
        public var processingConfig: IoTSiteWiseClientTypes.MetricProcessingConfig?
        /// The list of variables used in the expression.
        /// This member is required.
        public var variables: [IoTSiteWiseClientTypes.ExpressionVariable]?
        /// The window (time interval) over which IoT SiteWise computes the metric's aggregation expression. IoT SiteWise computes one data point per window.
        /// This member is required.
        public var window: IoTSiteWiseClientTypes.MetricWindow?

        public init(
            expression: Swift.String? = nil,
            processingConfig: IoTSiteWiseClientTypes.MetricProcessingConfig? = nil,
            variables: [IoTSiteWiseClientTypes.ExpressionVariable]? = nil,
            window: IoTSiteWiseClientTypes.MetricWindow? = nil
        )
        {
            self.expression = expression
            self.processingConfig = processingConfig
            self.variables = variables
            self.window = window
        }
    }

}

extension IoTSiteWiseClientTypes.MetricProcessingConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case computeLocation
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let computeLocation = self.computeLocation {
            try encodeContainer.encode(computeLocation.rawValue, forKey: .computeLocation)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let computeLocationDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.ComputeLocation.self, forKey: .computeLocation)
        computeLocation = computeLocationDecoded
    }
}

extension IoTSiteWiseClientTypes {
    /// The processing configuration for the given metric property. You can configure metrics to be computed at the edge or in the Amazon Web Services Cloud. By default, metrics are forwarded to the cloud.
    public struct MetricProcessingConfig: Swift.Equatable {
        /// The compute location for the given metric property.
        /// This member is required.
        public var computeLocation: IoTSiteWiseClientTypes.ComputeLocation?

        public init(
            computeLocation: IoTSiteWiseClientTypes.ComputeLocation? = nil
        )
        {
            self.computeLocation = computeLocation
        }
    }

}

extension IoTSiteWiseClientTypes.MetricWindow: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tumbling
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tumbling = self.tumbling {
            try encodeContainer.encode(tumbling, forKey: .tumbling)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tumblingDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.TumblingWindow.self, forKey: .tumbling)
        tumbling = tumblingDecoded
    }
}

extension IoTSiteWiseClientTypes {
    /// Contains a time interval window used for data aggregate computations (for example, average, sum, count, and so on).
    public struct MetricWindow: Swift.Equatable {
        /// The tumbling time interval window.
        public var tumbling: IoTSiteWiseClientTypes.TumblingWindow?

        public init(
            tumbling: IoTSiteWiseClientTypes.TumblingWindow? = nil
        )
        {
            self.tumbling = tumbling
        }
    }

}

extension IoTSiteWiseClientTypes {
    public enum MonitorErrorCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case internalFailure
        case limitExceeded
        case validationError
        case sdkUnknown(Swift.String)

        public static var allCases: [MonitorErrorCode] {
            return [
                .internalFailure,
                .limitExceeded,
                .validationError,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .internalFailure: return "INTERNAL_FAILURE"
            case .limitExceeded: return "LIMIT_EXCEEDED"
            case .validationError: return "VALIDATION_ERROR"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = MonitorErrorCode(rawValue: rawValue) ?? MonitorErrorCode.sdkUnknown(rawValue)
        }
    }
}

extension IoTSiteWiseClientTypes.MonitorErrorDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code
        case message
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let code = self.code {
            try encodeContainer.encode(code.rawValue, forKey: .code)
        }
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.MonitorErrorCode.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension IoTSiteWiseClientTypes {
    /// Contains IoT SiteWise Monitor error details.
    public struct MonitorErrorDetails: Swift.Equatable {
        /// The error code.
        public var code: IoTSiteWiseClientTypes.MonitorErrorCode?
        /// The error message.
        public var message: Swift.String?

        public init(
            code: IoTSiteWiseClientTypes.MonitorErrorCode? = nil,
            message: Swift.String? = nil
        )
        {
            self.code = code
            self.message = message
        }
    }

}

extension IoTSiteWiseClientTypes.MultiLayerStorage: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case customerManagedS3Storage
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let customerManagedS3Storage = self.customerManagedS3Storage {
            try encodeContainer.encode(customerManagedS3Storage, forKey: .customerManagedS3Storage)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let customerManagedS3StorageDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.CustomerManagedS3Storage.self, forKey: .customerManagedS3Storage)
        customerManagedS3Storage = customerManagedS3StorageDecoded
    }
}

extension IoTSiteWiseClientTypes {
    /// Contains information about the storage destination.
    public struct MultiLayerStorage: Swift.Equatable {
        /// Contains information about a customer managed Amazon S3 bucket.
        /// This member is required.
        public var customerManagedS3Storage: IoTSiteWiseClientTypes.CustomerManagedS3Storage?

        public init(
            customerManagedS3Storage: IoTSiteWiseClientTypes.CustomerManagedS3Storage? = nil
        )
        {
            self.customerManagedS3Storage = customerManagedS3Storage
        }
    }

}

extension IoTSiteWiseClientTypes {
    public enum Permission: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case administrator
        case viewer
        case sdkUnknown(Swift.String)

        public static var allCases: [Permission] {
            return [
                .administrator,
                .viewer,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .administrator: return "ADMINISTRATOR"
            case .viewer: return "VIEWER"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Permission(rawValue: rawValue) ?? Permission.sdkUnknown(rawValue)
        }
    }
}

extension IoTSiteWiseClientTypes.PortalResource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
    }
}

extension IoTSiteWiseClientTypes {
    /// Identifies an IoT SiteWise Monitor portal.
    public struct PortalResource: Swift.Equatable {
        /// The ID of the portal.
        /// This member is required.
        public var id: Swift.String?

        public init(
            id: Swift.String? = nil
        )
        {
            self.id = id
        }
    }

}

extension IoTSiteWiseClientTypes {
    public enum PortalState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case creating
        case deleting
        case failed
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [PortalState] {
            return [
                .active,
                .creating,
                .deleting,
                .failed,
                .updating,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .creating: return "CREATING"
            case .deleting: return "DELETING"
            case .failed: return "FAILED"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PortalState(rawValue: rawValue) ?? PortalState.sdkUnknown(rawValue)
        }
    }
}

extension IoTSiteWiseClientTypes.PortalStatus: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case error
        case state
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let error = self.error {
            try encodeContainer.encode(error, forKey: .error)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stateDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.PortalState.self, forKey: .state)
        state = stateDecoded
        let errorDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.MonitorErrorDetails.self, forKey: .error)
        error = errorDecoded
    }
}

extension IoTSiteWiseClientTypes {
    /// Contains information about the current status of a portal.
    public struct PortalStatus: Swift.Equatable {
        /// Contains associated error information, if any.
        public var error: IoTSiteWiseClientTypes.MonitorErrorDetails?
        /// The current state of the portal.
        /// This member is required.
        public var state: IoTSiteWiseClientTypes.PortalState?

        public init(
            error: IoTSiteWiseClientTypes.MonitorErrorDetails? = nil,
            state: IoTSiteWiseClientTypes.PortalState? = nil
        )
        {
            self.error = error
            self.state = state
        }
    }

}

extension IoTSiteWiseClientTypes.PortalSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationDate
        case description
        case id
        case lastUpdateDate
        case name
        case roleArn
        case startUrl
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationDate = self.creationDate {
            try encodeContainer.encodeTimestamp(creationDate, format: .epochSeconds, forKey: .creationDate)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let lastUpdateDate = self.lastUpdateDate {
            try encodeContainer.encodeTimestamp(lastUpdateDate, format: .epochSeconds, forKey: .lastUpdateDate)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let startUrl = self.startUrl {
            try encodeContainer.encode(startUrl, forKey: .startUrl)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let startUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .startUrl)
        startUrl = startUrlDecoded
        let creationDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDate)
        creationDate = creationDateDecoded
        let lastUpdateDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdateDate)
        lastUpdateDate = lastUpdateDateDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.PortalStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension IoTSiteWiseClientTypes {
    /// Contains a portal summary.
    public struct PortalSummary: Swift.Equatable {
        /// The date the portal was created, in Unix epoch time.
        public var creationDate: ClientRuntime.Date?
        /// The portal's description.
        public var description: Swift.String?
        /// The ID of the portal.
        /// This member is required.
        public var id: Swift.String?
        /// The date the portal was last updated, in Unix epoch time.
        public var lastUpdateDate: ClientRuntime.Date?
        /// The name of the portal.
        /// This member is required.
        public var name: Swift.String?
        /// The [ARN](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the service role that allows the portal's users to access your IoT SiteWise resources on your behalf. For more information, see [Using service roles for IoT SiteWise Monitor](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/monitor-service-role.html) in the IoT SiteWise User Guide.
        public var roleArn: Swift.String?
        /// The URL for the IoT SiteWise Monitor portal. You can use this URL to access portals that use IAM Identity Center for authentication. For portals that use IAM for authentication, you must use the IoT SiteWise console to get a URL that you can use to access the portal.
        /// This member is required.
        public var startUrl: Swift.String?
        /// Contains information about the current status of a portal.
        /// This member is required.
        public var status: IoTSiteWiseClientTypes.PortalStatus?

        public init(
            creationDate: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            lastUpdateDate: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            roleArn: Swift.String? = nil,
            startUrl: Swift.String? = nil,
            status: IoTSiteWiseClientTypes.PortalStatus? = nil
        )
        {
            self.creationDate = creationDate
            self.description = description
            self.id = id
            self.lastUpdateDate = lastUpdateDate
            self.name = name
            self.roleArn = roleArn
            self.startUrl = startUrl
            self.status = status
        }
    }

}

extension IoTSiteWiseClientTypes.ProjectResource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
    }
}

extension IoTSiteWiseClientTypes {
    /// Identifies a specific IoT SiteWise Monitor project.
    public struct ProjectResource: Swift.Equatable {
        /// The ID of the project.
        /// This member is required.
        public var id: Swift.String?

        public init(
            id: Swift.String? = nil
        )
        {
            self.id = id
        }
    }

}

extension IoTSiteWiseClientTypes.ProjectSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationDate
        case description
        case id
        case lastUpdateDate
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationDate = self.creationDate {
            try encodeContainer.encodeTimestamp(creationDate, format: .epochSeconds, forKey: .creationDate)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let lastUpdateDate = self.lastUpdateDate {
            try encodeContainer.encodeTimestamp(lastUpdateDate, format: .epochSeconds, forKey: .lastUpdateDate)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let creationDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDate)
        creationDate = creationDateDecoded
        let lastUpdateDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdateDate)
        lastUpdateDate = lastUpdateDateDecoded
    }
}

extension IoTSiteWiseClientTypes {
    /// Contains project summary information.
    public struct ProjectSummary: Swift.Equatable {
        /// The date the project was created, in Unix epoch time.
        public var creationDate: ClientRuntime.Date?
        /// The project's description.
        public var description: Swift.String?
        /// The ID of the project.
        /// This member is required.
        public var id: Swift.String?
        /// The date the project was last updated, in Unix epoch time.
        public var lastUpdateDate: ClientRuntime.Date?
        /// The name of the project.
        /// This member is required.
        public var name: Swift.String?

        public init(
            creationDate: ClientRuntime.Date? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            lastUpdateDate: ClientRuntime.Date? = nil,
            name: Swift.String? = nil
        )
        {
            self.creationDate = creationDate
            self.description = description
            self.id = id
            self.lastUpdateDate = lastUpdateDate
            self.name = name
        }
    }

}

extension IoTSiteWiseClientTypes.Property: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alias
        case dataType
        case id
        case name
        case notification
        case type
        case unit
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let alias = self.alias {
            try encodeContainer.encode(alias, forKey: .alias)
        }
        if let dataType = self.dataType {
            try encodeContainer.encode(dataType.rawValue, forKey: .dataType)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let notification = self.notification {
            try encodeContainer.encode(notification, forKey: .notification)
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
        if let unit = self.unit {
            try encodeContainer.encode(unit, forKey: .unit)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let aliasDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .alias)
        alias = aliasDecoded
        let notificationDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.PropertyNotification.self, forKey: .notification)
        notification = notificationDecoded
        let dataTypeDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.PropertyDataType.self, forKey: .dataType)
        dataType = dataTypeDecoded
        let unitDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .unit)
        unit = unitDecoded
        let typeDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.PropertyType.self, forKey: .type)
        type = typeDecoded
    }
}

extension IoTSiteWiseClientTypes {
    /// Contains asset property information.
    public struct Property: Swift.Equatable {
        /// The alias that identifies the property, such as an OPC-UA server data stream path (for example, /company/windfarm/3/turbine/7/temperature). For more information, see [Mapping industrial data streams to asset properties](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/connect-data-streams.html) in the IoT SiteWise User Guide.
        public var alias: Swift.String?
        /// The property data type.
        /// This member is required.
        public var dataType: IoTSiteWiseClientTypes.PropertyDataType?
        /// The ID of the asset property.
        /// This member is required.
        public var id: Swift.String?
        /// The name of the property.
        /// This member is required.
        public var name: Swift.String?
        /// The asset property's notification topic and state. For more information, see [UpdateAssetProperty](https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_UpdateAssetProperty.html).
        public var notification: IoTSiteWiseClientTypes.PropertyNotification?
        /// The property type (see PropertyType). A property contains one type.
        public var type: IoTSiteWiseClientTypes.PropertyType?
        /// The unit (such as Newtons or RPM) of the asset property.
        public var unit: Swift.String?

        public init(
            alias: Swift.String? = nil,
            dataType: IoTSiteWiseClientTypes.PropertyDataType? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            notification: IoTSiteWiseClientTypes.PropertyNotification? = nil,
            type: IoTSiteWiseClientTypes.PropertyType? = nil,
            unit: Swift.String? = nil
        )
        {
            self.alias = alias
            self.dataType = dataType
            self.id = id
            self.name = name
            self.notification = notification
            self.type = type
            self.unit = unit
        }
    }

}

extension IoTSiteWiseClientTypes {
    public enum PropertyDataType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case boolean
        case double
        case integer
        case string
        case `struct`
        case sdkUnknown(Swift.String)

        public static var allCases: [PropertyDataType] {
            return [
                .boolean,
                .double,
                .integer,
                .string,
                .struct,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .boolean: return "BOOLEAN"
            case .double: return "DOUBLE"
            case .integer: return "INTEGER"
            case .string: return "STRING"
            case .struct: return "STRUCT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PropertyDataType(rawValue: rawValue) ?? PropertyDataType.sdkUnknown(rawValue)
        }
    }
}

extension IoTSiteWiseClientTypes.PropertyNotification: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case state
        case topic
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
        if let topic = self.topic {
            try encodeContainer.encode(topic, forKey: .topic)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let topicDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .topic)
        topic = topicDecoded
        let stateDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.PropertyNotificationState.self, forKey: .state)
        state = stateDecoded
    }
}

extension IoTSiteWiseClientTypes {
    /// Contains asset property value notification information. When the notification state is enabled, IoT SiteWise publishes property value updates to a unique MQTT topic. For more information, see [Interacting with other services](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/interact-with-other-services.html) in the IoT SiteWise User Guide.
    public struct PropertyNotification: Swift.Equatable {
        /// The current notification state.
        /// This member is required.
        public var state: IoTSiteWiseClientTypes.PropertyNotificationState?
        /// The MQTT topic to which IoT SiteWise publishes property value update notifications.
        /// This member is required.
        public var topic: Swift.String?

        public init(
            state: IoTSiteWiseClientTypes.PropertyNotificationState? = nil,
            topic: Swift.String? = nil
        )
        {
            self.state = state
            self.topic = topic
        }
    }

}

extension IoTSiteWiseClientTypes {
    public enum PropertyNotificationState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [PropertyNotificationState] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PropertyNotificationState(rawValue: rawValue) ?? PropertyNotificationState.sdkUnknown(rawValue)
        }
    }
}

extension IoTSiteWiseClientTypes.PropertyType: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attribute
        case measurement
        case metric
        case transform
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attribute = self.attribute {
            try encodeContainer.encode(attribute, forKey: .attribute)
        }
        if let measurement = self.measurement {
            try encodeContainer.encode(measurement, forKey: .measurement)
        }
        if let metric = self.metric {
            try encodeContainer.encode(metric, forKey: .metric)
        }
        if let transform = self.transform {
            try encodeContainer.encode(transform, forKey: .transform)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributeDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.Attribute.self, forKey: .attribute)
        attribute = attributeDecoded
        let measurementDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.Measurement.self, forKey: .measurement)
        measurement = measurementDecoded
        let transformDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.Transform.self, forKey: .transform)
        transform = transformDecoded
        let metricDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.Metric.self, forKey: .metric)
        metric = metricDecoded
    }
}

extension IoTSiteWiseClientTypes {
    /// Contains a property type, which can be one of attribute, measurement, metric, or transform.
    public struct PropertyType: Swift.Equatable {
        /// Specifies an asset attribute property. An attribute generally contains static information, such as the serial number of an [IIoT](https://en.wikipedia.org/wiki/Internet_of_things#Industrial_applications) wind turbine.
        public var attribute: IoTSiteWiseClientTypes.Attribute?
        /// Specifies an asset measurement property. A measurement represents a device's raw sensor data stream, such as timestamped temperature values or timestamped power values.
        public var measurement: IoTSiteWiseClientTypes.Measurement?
        /// Specifies an asset metric property. A metric contains a mathematical expression that uses aggregate functions to process all input data points over a time interval and output a single data point, such as to calculate the average hourly temperature.
        public var metric: IoTSiteWiseClientTypes.Metric?
        /// Specifies an asset transform property. A transform contains a mathematical expression that maps a property's data points from one form to another, such as a unit conversion from Celsius to Fahrenheit.
        public var transform: IoTSiteWiseClientTypes.Transform?

        public init(
            attribute: IoTSiteWiseClientTypes.Attribute? = nil,
            measurement: IoTSiteWiseClientTypes.Measurement? = nil,
            metric: IoTSiteWiseClientTypes.Metric? = nil,
            transform: IoTSiteWiseClientTypes.Transform? = nil
        )
        {
            self.attribute = attribute
            self.measurement = measurement
            self.metric = metric
            self.transform = transform
        }
    }

}

extension IoTSiteWiseClientTypes.PutAssetPropertyValueEntry: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assetId
        case entryId
        case propertyAlias
        case propertyId
        case propertyValues
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assetId = self.assetId {
            try encodeContainer.encode(assetId, forKey: .assetId)
        }
        if let entryId = self.entryId {
            try encodeContainer.encode(entryId, forKey: .entryId)
        }
        if let propertyAlias = self.propertyAlias {
            try encodeContainer.encode(propertyAlias, forKey: .propertyAlias)
        }
        if let propertyId = self.propertyId {
            try encodeContainer.encode(propertyId, forKey: .propertyId)
        }
        if let propertyValues = propertyValues {
            var propertyValuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .propertyValues)
            for assetpropertyvalue0 in propertyValues {
                try propertyValuesContainer.encode(assetpropertyvalue0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entryId)
        entryId = entryIdDecoded
        let assetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assetId)
        assetId = assetIdDecoded
        let propertyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .propertyId)
        propertyId = propertyIdDecoded
        let propertyAliasDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .propertyAlias)
        propertyAlias = propertyAliasDecoded
        let propertyValuesContainer = try containerValues.decodeIfPresent([IoTSiteWiseClientTypes.AssetPropertyValue?].self, forKey: .propertyValues)
        var propertyValuesDecoded0:[IoTSiteWiseClientTypes.AssetPropertyValue]? = nil
        if let propertyValuesContainer = propertyValuesContainer {
            propertyValuesDecoded0 = [IoTSiteWiseClientTypes.AssetPropertyValue]()
            for structure0 in propertyValuesContainer {
                if let structure0 = structure0 {
                    propertyValuesDecoded0?.append(structure0)
                }
            }
        }
        propertyValues = propertyValuesDecoded0
    }
}

extension IoTSiteWiseClientTypes {
    /// Contains a list of value updates for an asset property in the list of asset entries consumed by the [BatchPutAssetPropertyValue](https://docs.aws.amazon.com/iot-sitewise/latest/APIReference/API_BatchPutAssetPropertyValue.html) API operation.
    public struct PutAssetPropertyValueEntry: Swift.Equatable {
        /// The ID of the asset to update.
        public var assetId: Swift.String?
        /// The user specified ID for the entry. You can use this ID to identify which entries failed.
        /// This member is required.
        public var entryId: Swift.String?
        /// The alias that identifies the property, such as an OPC-UA server data stream path (for example, /company/windfarm/3/turbine/7/temperature). For more information, see [Mapping industrial data streams to asset properties](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/connect-data-streams.html) in the IoT SiteWise User Guide.
        public var propertyAlias: Swift.String?
        /// The ID of the asset property for this entry.
        public var propertyId: Swift.String?
        /// The list of property values to upload. You can specify up to 10 propertyValues array elements.
        /// This member is required.
        public var propertyValues: [IoTSiteWiseClientTypes.AssetPropertyValue]?

        public init(
            assetId: Swift.String? = nil,
            entryId: Swift.String? = nil,
            propertyAlias: Swift.String? = nil,
            propertyId: Swift.String? = nil,
            propertyValues: [IoTSiteWiseClientTypes.AssetPropertyValue]? = nil
        )
        {
            self.assetId = assetId
            self.entryId = entryId
            self.propertyAlias = propertyAlias
            self.propertyId = propertyId
            self.propertyValues = propertyValues
        }
    }

}

extension PutDefaultEncryptionConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case encryptionType
        case kmsKeyId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let encryptionType = self.encryptionType {
            try encodeContainer.encode(encryptionType.rawValue, forKey: .encryptionType)
        }
        if let kmsKeyId = self.kmsKeyId {
            try encodeContainer.encode(kmsKeyId, forKey: .kmsKeyId)
        }
    }
}

extension PutDefaultEncryptionConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/configuration/account/encryption"
    }
}

public struct PutDefaultEncryptionConfigurationInput: Swift.Equatable {
    /// The type of encryption used for the encryption configuration.
    /// This member is required.
    public var encryptionType: IoTSiteWiseClientTypes.EncryptionType?
    /// The Key ID of the customer managed key used for KMS encryption. This is required if you use KMS_BASED_ENCRYPTION.
    public var kmsKeyId: Swift.String?

    public init(
        encryptionType: IoTSiteWiseClientTypes.EncryptionType? = nil,
        kmsKeyId: Swift.String? = nil
    )
    {
        self.encryptionType = encryptionType
        self.kmsKeyId = kmsKeyId
    }
}

struct PutDefaultEncryptionConfigurationInputBody: Swift.Equatable {
    let encryptionType: IoTSiteWiseClientTypes.EncryptionType?
    let kmsKeyId: Swift.String?
}

extension PutDefaultEncryptionConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case encryptionType
        case kmsKeyId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let encryptionTypeDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.EncryptionType.self, forKey: .encryptionType)
        encryptionType = encryptionTypeDecoded
        let kmsKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyId)
        kmsKeyId = kmsKeyIdDecoded
    }
}

extension PutDefaultEncryptionConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: PutDefaultEncryptionConfigurationOutputBody = try responseDecoder.decode(responseBody: data)
            self.configurationStatus = output.configurationStatus
            self.encryptionType = output.encryptionType
            self.kmsKeyArn = output.kmsKeyArn
        } else {
            self.configurationStatus = nil
            self.encryptionType = nil
            self.kmsKeyArn = nil
        }
    }
}

public struct PutDefaultEncryptionConfigurationOutput: Swift.Equatable {
    /// The status of the account configuration. This contains the ConfigurationState. If there is an error, it also contains the ErrorDetails.
    /// This member is required.
    public var configurationStatus: IoTSiteWiseClientTypes.ConfigurationStatus?
    /// The type of encryption used for the encryption configuration.
    /// This member is required.
    public var encryptionType: IoTSiteWiseClientTypes.EncryptionType?
    /// The Key ARN of the KMS key used for KMS encryption if you use KMS_BASED_ENCRYPTION.
    public var kmsKeyArn: Swift.String?

    public init(
        configurationStatus: IoTSiteWiseClientTypes.ConfigurationStatus? = nil,
        encryptionType: IoTSiteWiseClientTypes.EncryptionType? = nil,
        kmsKeyArn: Swift.String? = nil
    )
    {
        self.configurationStatus = configurationStatus
        self.encryptionType = encryptionType
        self.kmsKeyArn = kmsKeyArn
    }
}

struct PutDefaultEncryptionConfigurationOutputBody: Swift.Equatable {
    let encryptionType: IoTSiteWiseClientTypes.EncryptionType?
    let kmsKeyArn: Swift.String?
    let configurationStatus: IoTSiteWiseClientTypes.ConfigurationStatus?
}

extension PutDefaultEncryptionConfigurationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationStatus
        case encryptionType
        case kmsKeyArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let encryptionTypeDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.EncryptionType.self, forKey: .encryptionType)
        encryptionType = encryptionTypeDecoded
        let kmsKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyArn)
        kmsKeyArn = kmsKeyArnDecoded
        let configurationStatusDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.ConfigurationStatus.self, forKey: .configurationStatus)
        configurationStatus = configurationStatusDecoded
    }
}

enum PutDefaultEncryptionConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictingOperationException": return try await ConflictingOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension PutLoggingOptionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case loggingOptions
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let loggingOptions = self.loggingOptions {
            try encodeContainer.encode(loggingOptions, forKey: .loggingOptions)
        }
    }
}

extension PutLoggingOptionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/logging"
    }
}

public struct PutLoggingOptionsInput: Swift.Equatable {
    /// The logging options to set.
    /// This member is required.
    public var loggingOptions: IoTSiteWiseClientTypes.LoggingOptions?

    public init(
        loggingOptions: IoTSiteWiseClientTypes.LoggingOptions? = nil
    )
    {
        self.loggingOptions = loggingOptions
    }
}

struct PutLoggingOptionsInputBody: Swift.Equatable {
    let loggingOptions: IoTSiteWiseClientTypes.LoggingOptions?
}

extension PutLoggingOptionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case loggingOptions
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let loggingOptionsDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.LoggingOptions.self, forKey: .loggingOptions)
        loggingOptions = loggingOptionsDecoded
    }
}

extension PutLoggingOptionsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct PutLoggingOptionsOutput: Swift.Equatable {

    public init() { }
}

enum PutLoggingOptionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictingOperationException": return try await ConflictingOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension PutStorageConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case disassociatedDataStorage
        case multiLayerStorage
        case retentionPeriod
        case storageType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let disassociatedDataStorage = self.disassociatedDataStorage {
            try encodeContainer.encode(disassociatedDataStorage.rawValue, forKey: .disassociatedDataStorage)
        }
        if let multiLayerStorage = self.multiLayerStorage {
            try encodeContainer.encode(multiLayerStorage, forKey: .multiLayerStorage)
        }
        if let retentionPeriod = self.retentionPeriod {
            try encodeContainer.encode(retentionPeriod, forKey: .retentionPeriod)
        }
        if let storageType = self.storageType {
            try encodeContainer.encode(storageType.rawValue, forKey: .storageType)
        }
    }
}

extension PutStorageConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/configuration/account/storage"
    }
}

public struct PutStorageConfigurationInput: Swift.Equatable {
    /// Contains the storage configuration for time series (data streams) that aren't associated with asset properties. The disassociatedDataStorage can be one of the following values:
    ///
    /// * ENABLED  IoT SiteWise accepts time series that aren't associated with asset properties. After the disassociatedDataStorage is enabled, you can't disable it.
    ///
    /// * DISABLED  IoT SiteWise doesn't accept time series (data streams) that aren't associated with asset properties.
    ///
    ///
    /// For more information, see [Data streams](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/data-streams.html) in the IoT SiteWise User Guide.
    public var disassociatedDataStorage: IoTSiteWiseClientTypes.DisassociatedDataStorageState?
    /// Identifies a storage destination. If you specified MULTI_LAYER_STORAGE for the storage type, you must specify a MultiLayerStorage object.
    public var multiLayerStorage: IoTSiteWiseClientTypes.MultiLayerStorage?
    /// How many days your data is kept in the hot tier. By default, your data is kept indefinitely in the hot tier.
    public var retentionPeriod: IoTSiteWiseClientTypes.RetentionPeriod?
    /// The storage tier that you specified for your data. The storageType parameter can be one of the following values:
    ///
    /// * SITEWISE_DEFAULT_STORAGE  IoT SiteWise saves your data into the hot tier. The hot tier is a service-managed database.
    ///
    /// * MULTI_LAYER_STORAGE  IoT SiteWise saves your data in both the cold tier and the hot tier. The cold tier is a customer-managed Amazon S3 bucket.
    /// This member is required.
    public var storageType: IoTSiteWiseClientTypes.StorageType?

    public init(
        disassociatedDataStorage: IoTSiteWiseClientTypes.DisassociatedDataStorageState? = nil,
        multiLayerStorage: IoTSiteWiseClientTypes.MultiLayerStorage? = nil,
        retentionPeriod: IoTSiteWiseClientTypes.RetentionPeriod? = nil,
        storageType: IoTSiteWiseClientTypes.StorageType? = nil
    )
    {
        self.disassociatedDataStorage = disassociatedDataStorage
        self.multiLayerStorage = multiLayerStorage
        self.retentionPeriod = retentionPeriod
        self.storageType = storageType
    }
}

struct PutStorageConfigurationInputBody: Swift.Equatable {
    let storageType: IoTSiteWiseClientTypes.StorageType?
    let multiLayerStorage: IoTSiteWiseClientTypes.MultiLayerStorage?
    let disassociatedDataStorage: IoTSiteWiseClientTypes.DisassociatedDataStorageState?
    let retentionPeriod: IoTSiteWiseClientTypes.RetentionPeriod?
}

extension PutStorageConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case disassociatedDataStorage
        case multiLayerStorage
        case retentionPeriod
        case storageType
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let storageTypeDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.StorageType.self, forKey: .storageType)
        storageType = storageTypeDecoded
        let multiLayerStorageDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.MultiLayerStorage.self, forKey: .multiLayerStorage)
        multiLayerStorage = multiLayerStorageDecoded
        let disassociatedDataStorageDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.DisassociatedDataStorageState.self, forKey: .disassociatedDataStorage)
        disassociatedDataStorage = disassociatedDataStorageDecoded
        let retentionPeriodDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.RetentionPeriod.self, forKey: .retentionPeriod)
        retentionPeriod = retentionPeriodDecoded
    }
}

extension PutStorageConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: PutStorageConfigurationOutputBody = try responseDecoder.decode(responseBody: data)
            self.configurationStatus = output.configurationStatus
            self.disassociatedDataStorage = output.disassociatedDataStorage
            self.multiLayerStorage = output.multiLayerStorage
            self.retentionPeriod = output.retentionPeriod
            self.storageType = output.storageType
        } else {
            self.configurationStatus = nil
            self.disassociatedDataStorage = nil
            self.multiLayerStorage = nil
            self.retentionPeriod = nil
            self.storageType = nil
        }
    }
}

public struct PutStorageConfigurationOutput: Swift.Equatable {
    /// Contains current status information for the configuration.
    /// This member is required.
    public var configurationStatus: IoTSiteWiseClientTypes.ConfigurationStatus?
    /// Contains the storage configuration for time series (data streams) that aren't associated with asset properties. The disassociatedDataStorage can be one of the following values:
    ///
    /// * ENABLED  IoT SiteWise accepts time series that aren't associated with asset properties. After the disassociatedDataStorage is enabled, you can't disable it.
    ///
    /// * DISABLED  IoT SiteWise doesn't accept time series (data streams) that aren't associated with asset properties.
    ///
    ///
    /// For more information, see [Data streams](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/data-streams.html) in the IoT SiteWise User Guide.
    public var disassociatedDataStorage: IoTSiteWiseClientTypes.DisassociatedDataStorageState?
    /// Contains information about the storage destination.
    public var multiLayerStorage: IoTSiteWiseClientTypes.MultiLayerStorage?
    /// How many days your data is kept in the hot tier. By default, your data is kept indefinitely in the hot tier.
    public var retentionPeriod: IoTSiteWiseClientTypes.RetentionPeriod?
    /// The storage tier that you specified for your data. The storageType parameter can be one of the following values:
    ///
    /// * SITEWISE_DEFAULT_STORAGE  IoT SiteWise saves your data into the hot tier. The hot tier is a service-managed database.
    ///
    /// * MULTI_LAYER_STORAGE  IoT SiteWise saves your data in both the cold tier and the hot tier. The cold tier is a customer-managed Amazon S3 bucket.
    /// This member is required.
    public var storageType: IoTSiteWiseClientTypes.StorageType?

    public init(
        configurationStatus: IoTSiteWiseClientTypes.ConfigurationStatus? = nil,
        disassociatedDataStorage: IoTSiteWiseClientTypes.DisassociatedDataStorageState? = nil,
        multiLayerStorage: IoTSiteWiseClientTypes.MultiLayerStorage? = nil,
        retentionPeriod: IoTSiteWiseClientTypes.RetentionPeriod? = nil,
        storageType: IoTSiteWiseClientTypes.StorageType? = nil
    )
    {
        self.configurationStatus = configurationStatus
        self.disassociatedDataStorage = disassociatedDataStorage
        self.multiLayerStorage = multiLayerStorage
        self.retentionPeriod = retentionPeriod
        self.storageType = storageType
    }
}

struct PutStorageConfigurationOutputBody: Swift.Equatable {
    let storageType: IoTSiteWiseClientTypes.StorageType?
    let multiLayerStorage: IoTSiteWiseClientTypes.MultiLayerStorage?
    let disassociatedDataStorage: IoTSiteWiseClientTypes.DisassociatedDataStorageState?
    let retentionPeriod: IoTSiteWiseClientTypes.RetentionPeriod?
    let configurationStatus: IoTSiteWiseClientTypes.ConfigurationStatus?
}

extension PutStorageConfigurationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configurationStatus
        case disassociatedDataStorage
        case multiLayerStorage
        case retentionPeriod
        case storageType
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let storageTypeDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.StorageType.self, forKey: .storageType)
        storageType = storageTypeDecoded
        let multiLayerStorageDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.MultiLayerStorage.self, forKey: .multiLayerStorage)
        multiLayerStorage = multiLayerStorageDecoded
        let disassociatedDataStorageDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.DisassociatedDataStorageState.self, forKey: .disassociatedDataStorage)
        disassociatedDataStorage = disassociatedDataStorageDecoded
        let retentionPeriodDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.RetentionPeriod.self, forKey: .retentionPeriod)
        retentionPeriod = retentionPeriodDecoded
        let configurationStatusDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.ConfigurationStatus.self, forKey: .configurationStatus)
        configurationStatus = configurationStatusDecoded
    }
}

enum PutStorageConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictingOperationException": return try await ConflictingOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceAlreadyExistsException": return try await ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension IoTSiteWiseClientTypes {
    public enum Quality: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case bad
        case good
        case uncertain
        case sdkUnknown(Swift.String)

        public static var allCases: [Quality] {
            return [
                .bad,
                .good,
                .uncertain,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .bad: return "BAD"
            case .good: return "GOOD"
            case .uncertain: return "UNCERTAIN"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Quality(rawValue: rawValue) ?? Quality.sdkUnknown(rawValue)
        }
    }
}

extension IoTSiteWiseClientTypes.Resource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case portal
        case project
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let portal = self.portal {
            try encodeContainer.encode(portal, forKey: .portal)
        }
        if let project = self.project {
            try encodeContainer.encode(project, forKey: .project)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let portalDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.PortalResource.self, forKey: .portal)
        portal = portalDecoded
        let projectDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.ProjectResource.self, forKey: .project)
        project = projectDecoded
    }
}

extension IoTSiteWiseClientTypes {
    /// Contains an IoT SiteWise Monitor resource ID for a portal or project.
    public struct Resource: Swift.Equatable {
        /// A portal resource.
        public var portal: IoTSiteWiseClientTypes.PortalResource?
        /// A project resource.
        public var project: IoTSiteWiseClientTypes.ProjectResource?

        public init(
            portal: IoTSiteWiseClientTypes.PortalResource? = nil,
            project: IoTSiteWiseClientTypes.ProjectResource? = nil
        )
        {
            self.portal = portal
            self.project = project
        }
    }

}

extension ResourceAlreadyExistsException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceAlreadyExistsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.resourceArn = output.resourceArn
            self.properties.resourceId = output.resourceId
        } else {
            self.properties.message = nil
            self.properties.resourceArn = nil
            self.properties.resourceId = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The resource already exists.
public struct ResourceAlreadyExistsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The ARN of the resource that already exists.
        /// This member is required.
        public internal(set) var resourceArn: Swift.String? = nil
        /// The ID of the resource that already exists.
        /// This member is required.
        public internal(set) var resourceId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceAlreadyExistsException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceArn: Swift.String? = nil,
        resourceId: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceArn = resourceArn
        self.properties.resourceId = resourceId
    }
}

struct ResourceAlreadyExistsExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceId: Swift.String?
    let resourceArn: Swift.String?
}

extension ResourceAlreadyExistsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case resourceArn
        case resourceId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
    }
}

extension ResourceNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The requested resource can't be found.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension IoTSiteWiseClientTypes {
    public enum ResourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case portal
        case project
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceType] {
            return [
                .portal,
                .project,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .portal: return "PORTAL"
            case .project: return "PROJECT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResourceType(rawValue: rawValue) ?? ResourceType.sdkUnknown(rawValue)
        }
    }
}

extension IoTSiteWiseClientTypes.RetentionPeriod: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case numberOfDays
        case unlimited
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let numberOfDays = self.numberOfDays {
            try encodeContainer.encode(numberOfDays, forKey: .numberOfDays)
        }
        if let unlimited = self.unlimited {
            try encodeContainer.encode(unlimited, forKey: .unlimited)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let numberOfDaysDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .numberOfDays)
        numberOfDays = numberOfDaysDecoded
        let unlimitedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .unlimited)
        unlimited = unlimitedDecoded
    }
}

extension IoTSiteWiseClientTypes {
    /// How many days your data is kept in the hot tier. By default, your data is kept indefinitely in the hot tier.
    public struct RetentionPeriod: Swift.Equatable {
        /// The number of days that your data is kept. If you specified a value for this parameter, the unlimited parameter must be false.
        public var numberOfDays: Swift.Int?
        /// If true, your data is kept indefinitely. If configured to true, you must not specify a value for the numberOfDays parameter.
        public var unlimited: Swift.Bool?

        public init(
            numberOfDays: Swift.Int? = nil,
            unlimited: Swift.Bool? = nil
        )
        {
            self.numberOfDays = numberOfDays
            self.unlimited = unlimited
        }
    }

}

extension ServiceUnavailableException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ServiceUnavailableExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The requested service is unavailable.
public struct ServiceUnavailableException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceUnavailableException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ServiceUnavailableExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ServiceUnavailableExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension IoTSiteWiseClientTypes {
    public enum StorageType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case multiLayerStorage
        case sitewiseDefaultStorage
        case sdkUnknown(Swift.String)

        public static var allCases: [StorageType] {
            return [
                .multiLayerStorage,
                .sitewiseDefaultStorage,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .multiLayerStorage: return "MULTI_LAYER_STORAGE"
            case .sitewiseDefaultStorage: return "SITEWISE_DEFAULT_STORAGE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = StorageType(rawValue: rawValue) ?? StorageType.sdkUnknown(rawValue)
        }
    }
}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let resourceArn = resourceArn else {
                let message = "Creating a URL Query Item failed. resourceArn is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let resourceArnQueryItem = ClientRuntime.URLQueryItem(name: "resourceArn".urlPercentEncoding(), value: Swift.String(resourceArn).urlPercentEncoding())
            items.append(resourceArnQueryItem)
            return items
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/tags"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The [ARN](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the resource to tag.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// A list of key-value pairs that contain metadata for the resource. For more information, see [Tagging your IoT SiteWise resources](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/tag-resources.html) in the IoT SiteWise User Guide.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct TagResourceOutput: Swift.Equatable {

    public init() { }
}

enum TagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictingOperationException": return try await ConflictingOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyTagsException": return try await TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ThrottlingException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Your request exceeded a rate limit. For example, you might have exceeded the number of IoT SiteWise assets that can be created per second, the allowed number of messages per second, and so on. For more information, see [Quotas](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/quotas.html) in the IoT SiteWise User Guide.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension IoTSiteWiseClientTypes.TimeInNanos: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case offsetInNanos
        case timeInSeconds
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let offsetInNanos = self.offsetInNanos {
            try encodeContainer.encode(offsetInNanos, forKey: .offsetInNanos)
        }
        if let timeInSeconds = self.timeInSeconds {
            try encodeContainer.encode(timeInSeconds, forKey: .timeInSeconds)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timeInSecondsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .timeInSeconds)
        timeInSeconds = timeInSecondsDecoded
        let offsetInNanosDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .offsetInNanos)
        offsetInNanos = offsetInNanosDecoded
    }
}

extension IoTSiteWiseClientTypes {
    /// Contains a timestamp with optional nanosecond granularity.
    public struct TimeInNanos: Swift.Equatable {
        /// The nanosecond offset from timeInSeconds.
        public var offsetInNanos: Swift.Int?
        /// The timestamp date, in seconds, in the Unix epoch format. Fractional nanosecond data is provided by offsetInNanos.
        /// This member is required.
        public var timeInSeconds: Swift.Int?

        public init(
            offsetInNanos: Swift.Int? = nil,
            timeInSeconds: Swift.Int? = nil
        )
        {
            self.offsetInNanos = offsetInNanos
            self.timeInSeconds = timeInSeconds
        }
    }

}

extension IoTSiteWiseClientTypes {
    public enum TimeOrdering: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ascending
        case descending
        case sdkUnknown(Swift.String)

        public static var allCases: [TimeOrdering] {
            return [
                .ascending,
                .descending,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ascending: return "ASCENDING"
            case .descending: return "DESCENDING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TimeOrdering(rawValue: rawValue) ?? TimeOrdering.sdkUnknown(rawValue)
        }
    }
}

extension IoTSiteWiseClientTypes.TimeSeriesSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alias
        case assetId
        case dataType
        case dataTypeSpec
        case propertyId
        case timeSeriesArn
        case timeSeriesCreationDate
        case timeSeriesId
        case timeSeriesLastUpdateDate
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let alias = self.alias {
            try encodeContainer.encode(alias, forKey: .alias)
        }
        if let assetId = self.assetId {
            try encodeContainer.encode(assetId, forKey: .assetId)
        }
        if let dataType = self.dataType {
            try encodeContainer.encode(dataType.rawValue, forKey: .dataType)
        }
        if let dataTypeSpec = self.dataTypeSpec {
            try encodeContainer.encode(dataTypeSpec, forKey: .dataTypeSpec)
        }
        if let propertyId = self.propertyId {
            try encodeContainer.encode(propertyId, forKey: .propertyId)
        }
        if let timeSeriesArn = self.timeSeriesArn {
            try encodeContainer.encode(timeSeriesArn, forKey: .timeSeriesArn)
        }
        if let timeSeriesCreationDate = self.timeSeriesCreationDate {
            try encodeContainer.encodeTimestamp(timeSeriesCreationDate, format: .epochSeconds, forKey: .timeSeriesCreationDate)
        }
        if let timeSeriesId = self.timeSeriesId {
            try encodeContainer.encode(timeSeriesId, forKey: .timeSeriesId)
        }
        if let timeSeriesLastUpdateDate = self.timeSeriesLastUpdateDate {
            try encodeContainer.encodeTimestamp(timeSeriesLastUpdateDate, format: .epochSeconds, forKey: .timeSeriesLastUpdateDate)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assetId)
        assetId = assetIdDecoded
        let propertyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .propertyId)
        propertyId = propertyIdDecoded
        let aliasDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .alias)
        alias = aliasDecoded
        let timeSeriesIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .timeSeriesId)
        timeSeriesId = timeSeriesIdDecoded
        let dataTypeDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.PropertyDataType.self, forKey: .dataType)
        dataType = dataTypeDecoded
        let dataTypeSpecDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataTypeSpec)
        dataTypeSpec = dataTypeSpecDecoded
        let timeSeriesCreationDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .timeSeriesCreationDate)
        timeSeriesCreationDate = timeSeriesCreationDateDecoded
        let timeSeriesLastUpdateDateDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .timeSeriesLastUpdateDate)
        timeSeriesLastUpdateDate = timeSeriesLastUpdateDateDecoded
        let timeSeriesArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .timeSeriesArn)
        timeSeriesArn = timeSeriesArnDecoded
    }
}

extension IoTSiteWiseClientTypes {
    /// Contains a summary of a time series (data stream).
    public struct TimeSeriesSummary: Swift.Equatable {
        /// The alias that identifies the time series.
        public var alias: Swift.String?
        /// The ID of the asset in which the asset property was created.
        public var assetId: Swift.String?
        /// The data type of the time series. If you specify STRUCT, you must also specify dataTypeSpec to identify the type of the structure for this time series.
        /// This member is required.
        public var dataType: IoTSiteWiseClientTypes.PropertyDataType?
        /// The data type of the structure for this time series. This parameter is required for time series that have the STRUCT data type. The options for this parameter depend on the type of the composite model in which you created the asset property that is associated with your time series. Use AWS/ALARM_STATE for alarm state in alarm composite models.
        public var dataTypeSpec: Swift.String?
        /// The ID of the asset property.
        public var propertyId: Swift.String?
        /// The [ARN](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the time series, which has the following format. arn:${Partition}:iotsitewise:${Region}:${Account}:time-series/${TimeSeriesId}
        /// This member is required.
        public var timeSeriesArn: Swift.String?
        /// The date that the time series was created, in Unix epoch time.
        /// This member is required.
        public var timeSeriesCreationDate: ClientRuntime.Date?
        /// The ID of the time series.
        /// This member is required.
        public var timeSeriesId: Swift.String?
        /// The date that the time series was last updated, in Unix epoch time.
        /// This member is required.
        public var timeSeriesLastUpdateDate: ClientRuntime.Date?

        public init(
            alias: Swift.String? = nil,
            assetId: Swift.String? = nil,
            dataType: IoTSiteWiseClientTypes.PropertyDataType? = nil,
            dataTypeSpec: Swift.String? = nil,
            propertyId: Swift.String? = nil,
            timeSeriesArn: Swift.String? = nil,
            timeSeriesCreationDate: ClientRuntime.Date? = nil,
            timeSeriesId: Swift.String? = nil,
            timeSeriesLastUpdateDate: ClientRuntime.Date? = nil
        )
        {
            self.alias = alias
            self.assetId = assetId
            self.dataType = dataType
            self.dataTypeSpec = dataTypeSpec
            self.propertyId = propertyId
            self.timeSeriesArn = timeSeriesArn
            self.timeSeriesCreationDate = timeSeriesCreationDate
            self.timeSeriesId = timeSeriesId
            self.timeSeriesLastUpdateDate = timeSeriesLastUpdateDate
        }
    }

}

extension TooManyTagsException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: TooManyTagsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.resourceName = output.resourceName
        } else {
            self.properties.message = nil
            self.properties.resourceName = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// You've reached the limit for the number of tags allowed for a resource. For more information, see [Tag naming limits and requirements](https://docs.aws.amazon.com/general/latest/gr/aws_tagging.html#tag-conventions) in the Amazon Web Services General Reference.
public struct TooManyTagsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        /// The name of the resource with too many tags.
        public internal(set) var resourceName: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyTagsException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceName: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceName = resourceName
    }
}

struct TooManyTagsExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceName: Swift.String?
}

extension TooManyTagsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case resourceName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
    }
}

extension IoTSiteWiseClientTypes.Transform: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case expression
        case processingConfig
        case variables
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let expression = self.expression {
            try encodeContainer.encode(expression, forKey: .expression)
        }
        if let processingConfig = self.processingConfig {
            try encodeContainer.encode(processingConfig, forKey: .processingConfig)
        }
        if let variables = variables {
            var variablesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .variables)
            for expressionvariable0 in variables {
                try variablesContainer.encode(expressionvariable0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let expressionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .expression)
        expression = expressionDecoded
        let variablesContainer = try containerValues.decodeIfPresent([IoTSiteWiseClientTypes.ExpressionVariable?].self, forKey: .variables)
        var variablesDecoded0:[IoTSiteWiseClientTypes.ExpressionVariable]? = nil
        if let variablesContainer = variablesContainer {
            variablesDecoded0 = [IoTSiteWiseClientTypes.ExpressionVariable]()
            for structure0 in variablesContainer {
                if let structure0 = structure0 {
                    variablesDecoded0?.append(structure0)
                }
            }
        }
        variables = variablesDecoded0
        let processingConfigDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.TransformProcessingConfig.self, forKey: .processingConfig)
        processingConfig = processingConfigDecoded
    }
}

extension IoTSiteWiseClientTypes {
    /// Contains an asset transform property. A transform is a one-to-one mapping of a property's data points from one form to another. For example, you can use a transform to convert a Celsius data stream to Fahrenheit by applying the transformation expression to each data point of the Celsius stream. A transform can only have a data type of DOUBLE and consume properties with data types of INTEGER or DOUBLE. For more information, see [Transforms](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/asset-properties.html#transforms) in the IoT SiteWise User Guide.
    public struct Transform: Swift.Equatable {
        /// The mathematical expression that defines the transformation function. You can specify up to 10 variables per expression. You can specify up to 10 functions per expression. For more information, see [Quotas](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/quotas.html) in the IoT SiteWise User Guide.
        /// This member is required.
        public var expression: Swift.String?
        /// The processing configuration for the given transform property. You can configure transforms to be kept at the edge or forwarded to the Amazon Web Services Cloud. You can also configure transforms to be computed at the edge or in the cloud.
        public var processingConfig: IoTSiteWiseClientTypes.TransformProcessingConfig?
        /// The list of variables used in the expression.
        /// This member is required.
        public var variables: [IoTSiteWiseClientTypes.ExpressionVariable]?

        public init(
            expression: Swift.String? = nil,
            processingConfig: IoTSiteWiseClientTypes.TransformProcessingConfig? = nil,
            variables: [IoTSiteWiseClientTypes.ExpressionVariable]? = nil
        )
        {
            self.expression = expression
            self.processingConfig = processingConfig
            self.variables = variables
        }
    }

}

extension IoTSiteWiseClientTypes.TransformProcessingConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case computeLocation
        case forwardingConfig
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let computeLocation = self.computeLocation {
            try encodeContainer.encode(computeLocation.rawValue, forKey: .computeLocation)
        }
        if let forwardingConfig = self.forwardingConfig {
            try encodeContainer.encode(forwardingConfig, forKey: .forwardingConfig)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let computeLocationDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.ComputeLocation.self, forKey: .computeLocation)
        computeLocation = computeLocationDecoded
        let forwardingConfigDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.ForwardingConfig.self, forKey: .forwardingConfig)
        forwardingConfig = forwardingConfigDecoded
    }
}

extension IoTSiteWiseClientTypes {
    /// The processing configuration for the given transform property. You can configure transforms to be kept at the edge or forwarded to the Amazon Web Services Cloud. You can also configure transforms to be computed at the edge or in the cloud.
    public struct TransformProcessingConfig: Swift.Equatable {
        /// The compute location for the given transform property.
        /// This member is required.
        public var computeLocation: IoTSiteWiseClientTypes.ComputeLocation?
        /// The forwarding configuration for a given property.
        public var forwardingConfig: IoTSiteWiseClientTypes.ForwardingConfig?

        public init(
            computeLocation: IoTSiteWiseClientTypes.ComputeLocation? = nil,
            forwardingConfig: IoTSiteWiseClientTypes.ForwardingConfig? = nil
        )
        {
            self.computeLocation = computeLocation
            self.forwardingConfig = forwardingConfig
        }
    }

}

extension IoTSiteWiseClientTypes {
    public enum TraversalDirection: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case child
        case parent
        case sdkUnknown(Swift.String)

        public static var allCases: [TraversalDirection] {
            return [
                .child,
                .parent,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .child: return "CHILD"
            case .parent: return "PARENT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TraversalDirection(rawValue: rawValue) ?? TraversalDirection.sdkUnknown(rawValue)
        }
    }
}

extension IoTSiteWiseClientTypes {
    public enum TraversalType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case pathToRoot
        case sdkUnknown(Swift.String)

        public static var allCases: [TraversalType] {
            return [
                .pathToRoot,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .pathToRoot: return "PATH_TO_ROOT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TraversalType(rawValue: rawValue) ?? TraversalType.sdkUnknown(rawValue)
        }
    }
}

extension IoTSiteWiseClientTypes.TumblingWindow: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case interval
        case offset
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let interval = self.interval {
            try encodeContainer.encode(interval, forKey: .interval)
        }
        if let offset = self.offset {
            try encodeContainer.encode(offset, forKey: .offset)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let intervalDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .interval)
        interval = intervalDecoded
        let offsetDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .offset)
        offset = offsetDecoded
    }
}

extension IoTSiteWiseClientTypes {
    /// Contains a tumbling window, which is a repeating fixed-sized, non-overlapping, and contiguous time window. You can use this window in metrics to aggregate data from properties and other assets. You can use m, h, d, and w when you specify an interval or offset. Note that m represents minutes, h represents hours, d represents days, and w represents weeks. You can also use s to represent seconds in offset. The interval and offset parameters support the [ISO 8601 format](https://en.wikipedia.org/wiki/ISO_8601). For example, PT5S represents 5 seconds, PT5M represents 5 minutes, and PT5H represents 5 hours.
    public struct TumblingWindow: Swift.Equatable {
        /// The time interval for the tumbling window. The interval time must be between 1 minute and 1 week. IoT SiteWise computes the 1w interval the end of Sunday at midnight each week (UTC), the 1d interval at the end of each day at midnight (UTC), the 1h interval at the end of each hour, and so on. When IoT SiteWise aggregates data points for metric computations, the start of each interval is exclusive and the end of each interval is inclusive. IoT SiteWise places the computed data point at the end of the interval.
        /// This member is required.
        public var interval: Swift.String?
        /// The offset for the tumbling window. The offset parameter accepts the following:
        ///
        /// * The offset time. For example, if you specify 18h for offset and 1d for interval, IoT SiteWise aggregates data in one of the following ways:
        ///
        /// * If you create the metric before or at 6 PM (UTC), you get the first aggregation result at 6 PM (UTC) on the day when you create the metric.
        ///
        /// * If you create the metric after 6 PM (UTC), you get the first aggregation result at 6 PM (UTC) the next day.
        ///
        ///
        ///
        ///
        /// * The ISO 8601 format. For example, if you specify PT18H for offset and 1d for interval, IoT SiteWise aggregates data in one of the following ways:
        ///
        /// * If you create the metric before or at 6 PM (UTC), you get the first aggregation result at 6 PM (UTC) on the day when you create the metric.
        ///
        /// * If you create the metric after 6 PM (UTC), you get the first aggregation result at 6 PM (UTC) the next day.
        ///
        ///
        ///
        ///
        /// * The 24-hour clock. For example, if you specify 00:03:00 for offset, 5m for interval, and you create the metric at 2 PM (UTC), you get the first aggregation result at 2:03 PM (UTC). You get the second aggregation result at 2:08 PM (UTC).
        ///
        /// * The offset time zone. For example, if you specify 2021-07-23T18:00-08 for offset and 1d for interval, IoT SiteWise aggregates data in one of the following ways:
        ///
        /// * If you create the metric before or at 6 PM (PST), you get the first aggregation result at 6 PM (PST) on the day when you create the metric.
        ///
        /// * If you create the metric after 6 PM (PST), you get the first aggregation result at 6 PM (PST) the next day.
        public var offset: Swift.String?

        public init(
            interval: Swift.String? = nil,
            offset: Swift.String? = nil
        )
        {
            self.interval = interval
            self.offset = offset
        }
    }

}

extension UnauthorizedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UnauthorizedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// You are not authorized.
public struct UnauthorizedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "UnauthorizedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct UnauthorizedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension UnauthorizedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UntagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let tagKeys = tagKeys else {
                let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
            guard let resourceArn = resourceArn else {
                let message = "Creating a URL Query Item failed. resourceArn is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let resourceArnQueryItem = ClientRuntime.URLQueryItem(name: "resourceArn".urlPercentEncoding(), value: Swift.String(resourceArn).urlPercentEncoding())
            items.append(resourceArnQueryItem)
            return items
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/tags"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The [ARN](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of the resource to untag.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// A list of keys for tags to remove from the resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UntagResourceOutput: Swift.Equatable {

    public init() { }
}

enum UntagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictingOperationException": return try await ConflictingOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedException": return try await UnauthorizedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateAccessPolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessPolicyIdentity
        case accessPolicyPermission
        case accessPolicyResource
        case clientToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessPolicyIdentity = self.accessPolicyIdentity {
            try encodeContainer.encode(accessPolicyIdentity, forKey: .accessPolicyIdentity)
        }
        if let accessPolicyPermission = self.accessPolicyPermission {
            try encodeContainer.encode(accessPolicyPermission.rawValue, forKey: .accessPolicyPermission)
        }
        if let accessPolicyResource = self.accessPolicyResource {
            try encodeContainer.encode(accessPolicyResource, forKey: .accessPolicyResource)
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
    }
}

extension UpdateAccessPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let accessPolicyId = accessPolicyId else {
            return nil
        }
        return "/access-policies/\(accessPolicyId.urlPercentEncoding())"
    }
}

public struct UpdateAccessPolicyInput: Swift.Equatable {
    /// The ID of the access policy.
    /// This member is required.
    public var accessPolicyId: Swift.String?
    /// The identity for this access policy. Choose an IAM Identity Center user, an IAM Identity Center group, or an IAM user.
    /// This member is required.
    public var accessPolicyIdentity: IoTSiteWiseClientTypes.Identity?
    /// The permission level for this access policy. Note that a project ADMINISTRATOR is also known as a project owner.
    /// This member is required.
    public var accessPolicyPermission: IoTSiteWiseClientTypes.Permission?
    /// The IoT SiteWise Monitor resource for this access policy. Choose either a portal or a project.
    /// This member is required.
    public var accessPolicyResource: IoTSiteWiseClientTypes.Resource?
    /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
    public var clientToken: Swift.String?

    public init(
        accessPolicyId: Swift.String? = nil,
        accessPolicyIdentity: IoTSiteWiseClientTypes.Identity? = nil,
        accessPolicyPermission: IoTSiteWiseClientTypes.Permission? = nil,
        accessPolicyResource: IoTSiteWiseClientTypes.Resource? = nil,
        clientToken: Swift.String? = nil
    )
    {
        self.accessPolicyId = accessPolicyId
        self.accessPolicyIdentity = accessPolicyIdentity
        self.accessPolicyPermission = accessPolicyPermission
        self.accessPolicyResource = accessPolicyResource
        self.clientToken = clientToken
    }
}

struct UpdateAccessPolicyInputBody: Swift.Equatable {
    let accessPolicyIdentity: IoTSiteWiseClientTypes.Identity?
    let accessPolicyResource: IoTSiteWiseClientTypes.Resource?
    let accessPolicyPermission: IoTSiteWiseClientTypes.Permission?
    let clientToken: Swift.String?
}

extension UpdateAccessPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessPolicyIdentity
        case accessPolicyPermission
        case accessPolicyResource
        case clientToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessPolicyIdentityDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.Identity.self, forKey: .accessPolicyIdentity)
        accessPolicyIdentity = accessPolicyIdentityDecoded
        let accessPolicyResourceDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.Resource.self, forKey: .accessPolicyResource)
        accessPolicyResource = accessPolicyResourceDecoded
        let accessPolicyPermissionDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.Permission.self, forKey: .accessPolicyPermission)
        accessPolicyPermission = accessPolicyPermissionDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension UpdateAccessPolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateAccessPolicyOutput: Swift.Equatable {

    public init() { }
}

enum UpdateAccessPolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateAssetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assetDescription
        case assetName
        case clientToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assetDescription = self.assetDescription {
            try encodeContainer.encode(assetDescription, forKey: .assetDescription)
        }
        if let assetName = self.assetName {
            try encodeContainer.encode(assetName, forKey: .assetName)
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
    }
}

extension UpdateAssetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let assetId = assetId else {
            return nil
        }
        return "/assets/\(assetId.urlPercentEncoding())"
    }
}

public struct UpdateAssetInput: Swift.Equatable {
    /// A description for the asset.
    public var assetDescription: Swift.String?
    /// The ID of the asset to update.
    /// This member is required.
    public var assetId: Swift.String?
    /// A friendly name for the asset.
    /// This member is required.
    public var assetName: Swift.String?
    /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
    public var clientToken: Swift.String?

    public init(
        assetDescription: Swift.String? = nil,
        assetId: Swift.String? = nil,
        assetName: Swift.String? = nil,
        clientToken: Swift.String? = nil
    )
    {
        self.assetDescription = assetDescription
        self.assetId = assetId
        self.assetName = assetName
        self.clientToken = clientToken
    }
}

struct UpdateAssetInputBody: Swift.Equatable {
    let assetName: Swift.String?
    let clientToken: Swift.String?
    let assetDescription: Swift.String?
}

extension UpdateAssetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assetDescription
        case assetName
        case clientToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assetName)
        assetName = assetNameDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let assetDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assetDescription)
        assetDescription = assetDescriptionDecoded
    }
}

extension UpdateAssetModelInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assetModelCompositeModels
        case assetModelDescription
        case assetModelHierarchies
        case assetModelName
        case assetModelProperties
        case clientToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let assetModelCompositeModels = assetModelCompositeModels {
            var assetModelCompositeModelsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .assetModelCompositeModels)
            for assetmodelcompositemodel0 in assetModelCompositeModels {
                try assetModelCompositeModelsContainer.encode(assetmodelcompositemodel0)
            }
        }
        if let assetModelDescription = self.assetModelDescription {
            try encodeContainer.encode(assetModelDescription, forKey: .assetModelDescription)
        }
        if let assetModelHierarchies = assetModelHierarchies {
            var assetModelHierarchiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .assetModelHierarchies)
            for assetmodelhierarchy0 in assetModelHierarchies {
                try assetModelHierarchiesContainer.encode(assetmodelhierarchy0)
            }
        }
        if let assetModelName = self.assetModelName {
            try encodeContainer.encode(assetModelName, forKey: .assetModelName)
        }
        if let assetModelProperties = assetModelProperties {
            var assetModelPropertiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .assetModelProperties)
            for assetmodelproperty0 in assetModelProperties {
                try assetModelPropertiesContainer.encode(assetmodelproperty0)
            }
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
    }
}

extension UpdateAssetModelInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let assetModelId = assetModelId else {
            return nil
        }
        return "/asset-models/\(assetModelId.urlPercentEncoding())"
    }
}

public struct UpdateAssetModelInput: Swift.Equatable {
    /// The composite asset models that are part of this asset model. Composite asset models are asset models that contain specific properties. Each composite model has a type that defines the properties that the composite model supports. Use composite asset models to define alarms on this asset model.
    public var assetModelCompositeModels: [IoTSiteWiseClientTypes.AssetModelCompositeModel]?
    /// A description for the asset model.
    public var assetModelDescription: Swift.String?
    /// The updated hierarchy definitions of the asset model. Each hierarchy specifies an asset model whose assets can be children of any other assets created from this asset model. For more information, see [Asset hierarchies](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/asset-hierarchies.html) in the IoT SiteWise User Guide. You can specify up to 10 hierarchies per asset model. For more information, see [Quotas](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/quotas.html) in the IoT SiteWise User Guide.
    public var assetModelHierarchies: [IoTSiteWiseClientTypes.AssetModelHierarchy]?
    /// The ID of the asset model to update.
    /// This member is required.
    public var assetModelId: Swift.String?
    /// A unique, friendly name for the asset model.
    /// This member is required.
    public var assetModelName: Swift.String?
    /// The updated property definitions of the asset model. For more information, see [Asset properties](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/asset-properties.html) in the IoT SiteWise User Guide. You can specify up to 200 properties per asset model. For more information, see [Quotas](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/quotas.html) in the IoT SiteWise User Guide.
    public var assetModelProperties: [IoTSiteWiseClientTypes.AssetModelProperty]?
    /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
    public var clientToken: Swift.String?

    public init(
        assetModelCompositeModels: [IoTSiteWiseClientTypes.AssetModelCompositeModel]? = nil,
        assetModelDescription: Swift.String? = nil,
        assetModelHierarchies: [IoTSiteWiseClientTypes.AssetModelHierarchy]? = nil,
        assetModelId: Swift.String? = nil,
        assetModelName: Swift.String? = nil,
        assetModelProperties: [IoTSiteWiseClientTypes.AssetModelProperty]? = nil,
        clientToken: Swift.String? = nil
    )
    {
        self.assetModelCompositeModels = assetModelCompositeModels
        self.assetModelDescription = assetModelDescription
        self.assetModelHierarchies = assetModelHierarchies
        self.assetModelId = assetModelId
        self.assetModelName = assetModelName
        self.assetModelProperties = assetModelProperties
        self.clientToken = clientToken
    }
}

struct UpdateAssetModelInputBody: Swift.Equatable {
    let assetModelName: Swift.String?
    let assetModelDescription: Swift.String?
    let assetModelProperties: [IoTSiteWiseClientTypes.AssetModelProperty]?
    let assetModelHierarchies: [IoTSiteWiseClientTypes.AssetModelHierarchy]?
    let assetModelCompositeModels: [IoTSiteWiseClientTypes.AssetModelCompositeModel]?
    let clientToken: Swift.String?
}

extension UpdateAssetModelInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assetModelCompositeModels
        case assetModelDescription
        case assetModelHierarchies
        case assetModelName
        case assetModelProperties
        case clientToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assetModelNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assetModelName)
        assetModelName = assetModelNameDecoded
        let assetModelDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .assetModelDescription)
        assetModelDescription = assetModelDescriptionDecoded
        let assetModelPropertiesContainer = try containerValues.decodeIfPresent([IoTSiteWiseClientTypes.AssetModelProperty?].self, forKey: .assetModelProperties)
        var assetModelPropertiesDecoded0:[IoTSiteWiseClientTypes.AssetModelProperty]? = nil
        if let assetModelPropertiesContainer = assetModelPropertiesContainer {
            assetModelPropertiesDecoded0 = [IoTSiteWiseClientTypes.AssetModelProperty]()
            for structure0 in assetModelPropertiesContainer {
                if let structure0 = structure0 {
                    assetModelPropertiesDecoded0?.append(structure0)
                }
            }
        }
        assetModelProperties = assetModelPropertiesDecoded0
        let assetModelHierarchiesContainer = try containerValues.decodeIfPresent([IoTSiteWiseClientTypes.AssetModelHierarchy?].self, forKey: .assetModelHierarchies)
        var assetModelHierarchiesDecoded0:[IoTSiteWiseClientTypes.AssetModelHierarchy]? = nil
        if let assetModelHierarchiesContainer = assetModelHierarchiesContainer {
            assetModelHierarchiesDecoded0 = [IoTSiteWiseClientTypes.AssetModelHierarchy]()
            for structure0 in assetModelHierarchiesContainer {
                if let structure0 = structure0 {
                    assetModelHierarchiesDecoded0?.append(structure0)
                }
            }
        }
        assetModelHierarchies = assetModelHierarchiesDecoded0
        let assetModelCompositeModelsContainer = try containerValues.decodeIfPresent([IoTSiteWiseClientTypes.AssetModelCompositeModel?].self, forKey: .assetModelCompositeModels)
        var assetModelCompositeModelsDecoded0:[IoTSiteWiseClientTypes.AssetModelCompositeModel]? = nil
        if let assetModelCompositeModelsContainer = assetModelCompositeModelsContainer {
            assetModelCompositeModelsDecoded0 = [IoTSiteWiseClientTypes.AssetModelCompositeModel]()
            for structure0 in assetModelCompositeModelsContainer {
                if let structure0 = structure0 {
                    assetModelCompositeModelsDecoded0?.append(structure0)
                }
            }
        }
        assetModelCompositeModels = assetModelCompositeModelsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension UpdateAssetModelOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateAssetModelOutputBody = try responseDecoder.decode(responseBody: data)
            self.assetModelStatus = output.assetModelStatus
        } else {
            self.assetModelStatus = nil
        }
    }
}

public struct UpdateAssetModelOutput: Swift.Equatable {
    /// The status of the asset model, which contains a state (UPDATING after successfully calling this operation) and any error message.
    /// This member is required.
    public var assetModelStatus: IoTSiteWiseClientTypes.AssetModelStatus?

    public init(
        assetModelStatus: IoTSiteWiseClientTypes.AssetModelStatus? = nil
    )
    {
        self.assetModelStatus = assetModelStatus
    }
}

struct UpdateAssetModelOutputBody: Swift.Equatable {
    let assetModelStatus: IoTSiteWiseClientTypes.AssetModelStatus?
}

extension UpdateAssetModelOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assetModelStatus
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assetModelStatusDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.AssetModelStatus.self, forKey: .assetModelStatus)
        assetModelStatus = assetModelStatusDecoded
    }
}

enum UpdateAssetModelOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictingOperationException": return try await ConflictingOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceAlreadyExistsException": return try await ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateAssetOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateAssetOutputBody = try responseDecoder.decode(responseBody: data)
            self.assetStatus = output.assetStatus
        } else {
            self.assetStatus = nil
        }
    }
}

public struct UpdateAssetOutput: Swift.Equatable {
    /// The status of the asset, which contains a state (UPDATING after successfully calling this operation) and any error message.
    /// This member is required.
    public var assetStatus: IoTSiteWiseClientTypes.AssetStatus?

    public init(
        assetStatus: IoTSiteWiseClientTypes.AssetStatus? = nil
    )
    {
        self.assetStatus = assetStatus
    }
}

struct UpdateAssetOutputBody: Swift.Equatable {
    let assetStatus: IoTSiteWiseClientTypes.AssetStatus?
}

extension UpdateAssetOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case assetStatus
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let assetStatusDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.AssetStatus.self, forKey: .assetStatus)
        assetStatus = assetStatusDecoded
    }
}

enum UpdateAssetOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictingOperationException": return try await ConflictingOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceAlreadyExistsException": return try await ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateAssetPropertyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case propertyAlias
        case propertyNotificationState
        case propertyUnit
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let propertyAlias = self.propertyAlias {
            try encodeContainer.encode(propertyAlias, forKey: .propertyAlias)
        }
        if let propertyNotificationState = self.propertyNotificationState {
            try encodeContainer.encode(propertyNotificationState.rawValue, forKey: .propertyNotificationState)
        }
        if let propertyUnit = self.propertyUnit {
            try encodeContainer.encode(propertyUnit, forKey: .propertyUnit)
        }
    }
}

extension UpdateAssetPropertyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let assetId = assetId else {
            return nil
        }
        guard let propertyId = propertyId else {
            return nil
        }
        return "/assets/\(assetId.urlPercentEncoding())/properties/\(propertyId.urlPercentEncoding())"
    }
}

public struct UpdateAssetPropertyInput: Swift.Equatable {
    /// The ID of the asset to be updated.
    /// This member is required.
    public var assetId: Swift.String?
    /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
    public var clientToken: Swift.String?
    /// The alias that identifies the property, such as an OPC-UA server data stream path (for example, /company/windfarm/3/turbine/7/temperature). For more information, see [Mapping industrial data streams to asset properties](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/connect-data-streams.html) in the IoT SiteWise User Guide. If you omit this parameter, the alias is removed from the property.
    public var propertyAlias: Swift.String?
    /// The ID of the asset property to be updated.
    /// This member is required.
    public var propertyId: Swift.String?
    /// The MQTT notification state (enabled or disabled) for this asset property. When the notification state is enabled, IoT SiteWise publishes property value updates to a unique MQTT topic. For more information, see [Interacting with other services](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/interact-with-other-services.html) in the IoT SiteWise User Guide. If you omit this parameter, the notification state is set to DISABLED.
    public var propertyNotificationState: IoTSiteWiseClientTypes.PropertyNotificationState?
    /// The unit of measure (such as Newtons or RPM) of the asset property. If you don't specify a value for this parameter, the service uses the value of the assetModelProperty in the asset model.
    public var propertyUnit: Swift.String?

    public init(
        assetId: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        propertyAlias: Swift.String? = nil,
        propertyId: Swift.String? = nil,
        propertyNotificationState: IoTSiteWiseClientTypes.PropertyNotificationState? = nil,
        propertyUnit: Swift.String? = nil
    )
    {
        self.assetId = assetId
        self.clientToken = clientToken
        self.propertyAlias = propertyAlias
        self.propertyId = propertyId
        self.propertyNotificationState = propertyNotificationState
        self.propertyUnit = propertyUnit
    }
}

struct UpdateAssetPropertyInputBody: Swift.Equatable {
    let propertyAlias: Swift.String?
    let propertyNotificationState: IoTSiteWiseClientTypes.PropertyNotificationState?
    let clientToken: Swift.String?
    let propertyUnit: Swift.String?
}

extension UpdateAssetPropertyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case propertyAlias
        case propertyNotificationState
        case propertyUnit
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let propertyAliasDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .propertyAlias)
        propertyAlias = propertyAliasDecoded
        let propertyNotificationStateDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.PropertyNotificationState.self, forKey: .propertyNotificationState)
        propertyNotificationState = propertyNotificationStateDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let propertyUnitDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .propertyUnit)
        propertyUnit = propertyUnitDecoded
    }
}

extension UpdateAssetPropertyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateAssetPropertyOutput: Swift.Equatable {

    public init() { }
}

enum UpdateAssetPropertyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictingOperationException": return try await ConflictingOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateDashboardInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case dashboardDefinition
        case dashboardDescription
        case dashboardName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let dashboardDefinition = self.dashboardDefinition {
            try encodeContainer.encode(dashboardDefinition, forKey: .dashboardDefinition)
        }
        if let dashboardDescription = self.dashboardDescription {
            try encodeContainer.encode(dashboardDescription, forKey: .dashboardDescription)
        }
        if let dashboardName = self.dashboardName {
            try encodeContainer.encode(dashboardName, forKey: .dashboardName)
        }
    }
}

extension UpdateDashboardInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let dashboardId = dashboardId else {
            return nil
        }
        return "/dashboards/\(dashboardId.urlPercentEncoding())"
    }
}

public struct UpdateDashboardInput: Swift.Equatable {
    /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
    public var clientToken: Swift.String?
    /// The new dashboard definition, as specified in a JSON literal. For detailed information, see [Creating dashboards (CLI)](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/create-dashboards-using-aws-cli.html) in the IoT SiteWise User Guide.
    /// This member is required.
    public var dashboardDefinition: Swift.String?
    /// A new description for the dashboard.
    public var dashboardDescription: Swift.String?
    /// The ID of the dashboard to update.
    /// This member is required.
    public var dashboardId: Swift.String?
    /// A new friendly name for the dashboard.
    /// This member is required.
    public var dashboardName: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        dashboardDefinition: Swift.String? = nil,
        dashboardDescription: Swift.String? = nil,
        dashboardId: Swift.String? = nil,
        dashboardName: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.dashboardDefinition = dashboardDefinition
        self.dashboardDescription = dashboardDescription
        self.dashboardId = dashboardId
        self.dashboardName = dashboardName
    }
}

struct UpdateDashboardInputBody: Swift.Equatable {
    let dashboardName: Swift.String?
    let dashboardDescription: Swift.String?
    let dashboardDefinition: Swift.String?
    let clientToken: Swift.String?
}

extension UpdateDashboardInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case dashboardDefinition
        case dashboardDescription
        case dashboardName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dashboardNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dashboardName)
        dashboardName = dashboardNameDecoded
        let dashboardDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dashboardDescription)
        dashboardDescription = dashboardDescriptionDecoded
        let dashboardDefinitionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dashboardDefinition)
        dashboardDefinition = dashboardDefinitionDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension UpdateDashboardOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateDashboardOutput: Swift.Equatable {

    public init() { }
}

enum UpdateDashboardOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateGatewayCapabilityConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case capabilityConfiguration
        case capabilityNamespace
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let capabilityConfiguration = self.capabilityConfiguration {
            try encodeContainer.encode(capabilityConfiguration, forKey: .capabilityConfiguration)
        }
        if let capabilityNamespace = self.capabilityNamespace {
            try encodeContainer.encode(capabilityNamespace, forKey: .capabilityNamespace)
        }
    }
}

extension UpdateGatewayCapabilityConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let gatewayId = gatewayId else {
            return nil
        }
        return "/20200301/gateways/\(gatewayId.urlPercentEncoding())/capability"
    }
}

public struct UpdateGatewayCapabilityConfigurationInput: Swift.Equatable {
    /// The JSON document that defines the configuration for the gateway capability. For more information, see [Configuring data sources (CLI)](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/configure-sources.html#configure-source-cli) in the IoT SiteWise User Guide.
    /// This member is required.
    public var capabilityConfiguration: Swift.String?
    /// The namespace of the gateway capability configuration to be updated. For example, if you configure OPC-UA sources from the IoT SiteWise console, your OPC-UA capability configuration has the namespace iotsitewise:opcuacollector:version, where version is a number such as 1.
    /// This member is required.
    public var capabilityNamespace: Swift.String?
    /// The ID of the gateway to be updated.
    /// This member is required.
    public var gatewayId: Swift.String?

    public init(
        capabilityConfiguration: Swift.String? = nil,
        capabilityNamespace: Swift.String? = nil,
        gatewayId: Swift.String? = nil
    )
    {
        self.capabilityConfiguration = capabilityConfiguration
        self.capabilityNamespace = capabilityNamespace
        self.gatewayId = gatewayId
    }
}

struct UpdateGatewayCapabilityConfigurationInputBody: Swift.Equatable {
    let capabilityNamespace: Swift.String?
    let capabilityConfiguration: Swift.String?
}

extension UpdateGatewayCapabilityConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case capabilityConfiguration
        case capabilityNamespace
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let capabilityNamespaceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .capabilityNamespace)
        capabilityNamespace = capabilityNamespaceDecoded
        let capabilityConfigurationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .capabilityConfiguration)
        capabilityConfiguration = capabilityConfigurationDecoded
    }
}

extension UpdateGatewayCapabilityConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateGatewayCapabilityConfigurationOutputBody = try responseDecoder.decode(responseBody: data)
            self.capabilityNamespace = output.capabilityNamespace
            self.capabilitySyncStatus = output.capabilitySyncStatus
        } else {
            self.capabilityNamespace = nil
            self.capabilitySyncStatus = nil
        }
    }
}

public struct UpdateGatewayCapabilityConfigurationOutput: Swift.Equatable {
    /// The namespace of the gateway capability.
    /// This member is required.
    public var capabilityNamespace: Swift.String?
    /// The synchronization status of the capability configuration. The sync status can be one of the following:
    ///
    /// * IN_SYNC  The gateway is running the capability configuration.
    ///
    /// * OUT_OF_SYNC  The gateway hasn't received the capability configuration.
    ///
    /// * SYNC_FAILED  The gateway rejected the capability configuration.
    ///
    ///
    /// After you update a capability configuration, its sync status is OUT_OF_SYNC until the gateway receives and applies or rejects the updated configuration.
    /// This member is required.
    public var capabilitySyncStatus: IoTSiteWiseClientTypes.CapabilitySyncStatus?

    public init(
        capabilityNamespace: Swift.String? = nil,
        capabilitySyncStatus: IoTSiteWiseClientTypes.CapabilitySyncStatus? = nil
    )
    {
        self.capabilityNamespace = capabilityNamespace
        self.capabilitySyncStatus = capabilitySyncStatus
    }
}

struct UpdateGatewayCapabilityConfigurationOutputBody: Swift.Equatable {
    let capabilityNamespace: Swift.String?
    let capabilitySyncStatus: IoTSiteWiseClientTypes.CapabilitySyncStatus?
}

extension UpdateGatewayCapabilityConfigurationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case capabilityNamespace
        case capabilitySyncStatus
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let capabilityNamespaceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .capabilityNamespace)
        capabilityNamespace = capabilityNamespaceDecoded
        let capabilitySyncStatusDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.CapabilitySyncStatus.self, forKey: .capabilitySyncStatus)
        capabilitySyncStatus = capabilitySyncStatusDecoded
    }
}

enum UpdateGatewayCapabilityConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictingOperationException": return try await ConflictingOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateGatewayInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let gatewayName = self.gatewayName {
            try encodeContainer.encode(gatewayName, forKey: .gatewayName)
        }
    }
}

extension UpdateGatewayInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let gatewayId = gatewayId else {
            return nil
        }
        return "/20200301/gateways/\(gatewayId.urlPercentEncoding())"
    }
}

public struct UpdateGatewayInput: Swift.Equatable {
    /// The ID of the gateway to update.
    /// This member is required.
    public var gatewayId: Swift.String?
    /// A unique, friendly name for the gateway.
    /// This member is required.
    public var gatewayName: Swift.String?

    public init(
        gatewayId: Swift.String? = nil,
        gatewayName: Swift.String? = nil
    )
    {
        self.gatewayId = gatewayId
        self.gatewayName = gatewayName
    }
}

struct UpdateGatewayInputBody: Swift.Equatable {
    let gatewayName: Swift.String?
}

extension UpdateGatewayInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case gatewayName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let gatewayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .gatewayName)
        gatewayName = gatewayNameDecoded
    }
}

extension UpdateGatewayOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateGatewayOutput: Swift.Equatable {

    public init() { }
}

enum UpdateGatewayOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictingOperationException": return try await ConflictingOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdatePortalInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alarms
        case clientToken
        case notificationSenderEmail
        case portalContactEmail
        case portalDescription
        case portalLogoImage
        case portalName
        case roleArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let alarms = self.alarms {
            try encodeContainer.encode(alarms, forKey: .alarms)
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let notificationSenderEmail = self.notificationSenderEmail {
            try encodeContainer.encode(notificationSenderEmail, forKey: .notificationSenderEmail)
        }
        if let portalContactEmail = self.portalContactEmail {
            try encodeContainer.encode(portalContactEmail, forKey: .portalContactEmail)
        }
        if let portalDescription = self.portalDescription {
            try encodeContainer.encode(portalDescription, forKey: .portalDescription)
        }
        if let portalLogoImage = self.portalLogoImage {
            try encodeContainer.encode(portalLogoImage, forKey: .portalLogoImage)
        }
        if let portalName = self.portalName {
            try encodeContainer.encode(portalName, forKey: .portalName)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
    }
}

extension UpdatePortalInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let portalId = portalId else {
            return nil
        }
        return "/portals/\(portalId.urlPercentEncoding())"
    }
}

public struct UpdatePortalInput: Swift.Equatable {
    /// Contains the configuration information of an alarm created in an IoT SiteWise Monitor portal. You can use the alarm to monitor an asset property and get notified when the asset property value is outside a specified range. For more information, see [Monitoring with alarms](https://docs.aws.amazon.com/iot-sitewise/latest/appguide/monitor-alarms.html) in the IoT SiteWise Application Guide.
    public var alarms: IoTSiteWiseClientTypes.Alarms?
    /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
    public var clientToken: Swift.String?
    /// The email address that sends alarm notifications.
    public var notificationSenderEmail: Swift.String?
    /// The Amazon Web Services administrator's contact email address.
    /// This member is required.
    public var portalContactEmail: Swift.String?
    /// A new description for the portal.
    public var portalDescription: Swift.String?
    /// The ID of the portal to update.
    /// This member is required.
    public var portalId: Swift.String?
    /// Contains an image that is one of the following:
    ///
    /// * An image file. Choose this option to upload a new image.
    ///
    /// * The ID of an existing image. Choose this option to keep an existing image.
    public var portalLogoImage: IoTSiteWiseClientTypes.Image?
    /// A new friendly name for the portal.
    /// This member is required.
    public var portalName: Swift.String?
    /// The [ARN](https://docs.aws.amazon.com/general/latest/gr/aws-arns-and-namespaces.html) of a service role that allows the portal's users to access your IoT SiteWise resources on your behalf. For more information, see [Using service roles for IoT SiteWise Monitor](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/monitor-service-role.html) in the IoT SiteWise User Guide.
    /// This member is required.
    public var roleArn: Swift.String?

    public init(
        alarms: IoTSiteWiseClientTypes.Alarms? = nil,
        clientToken: Swift.String? = nil,
        notificationSenderEmail: Swift.String? = nil,
        portalContactEmail: Swift.String? = nil,
        portalDescription: Swift.String? = nil,
        portalId: Swift.String? = nil,
        portalLogoImage: IoTSiteWiseClientTypes.Image? = nil,
        portalName: Swift.String? = nil,
        roleArn: Swift.String? = nil
    )
    {
        self.alarms = alarms
        self.clientToken = clientToken
        self.notificationSenderEmail = notificationSenderEmail
        self.portalContactEmail = portalContactEmail
        self.portalDescription = portalDescription
        self.portalId = portalId
        self.portalLogoImage = portalLogoImage
        self.portalName = portalName
        self.roleArn = roleArn
    }
}

struct UpdatePortalInputBody: Swift.Equatable {
    let portalName: Swift.String?
    let portalDescription: Swift.String?
    let portalContactEmail: Swift.String?
    let portalLogoImage: IoTSiteWiseClientTypes.Image?
    let roleArn: Swift.String?
    let clientToken: Swift.String?
    let notificationSenderEmail: Swift.String?
    let alarms: IoTSiteWiseClientTypes.Alarms?
}

extension UpdatePortalInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alarms
        case clientToken
        case notificationSenderEmail
        case portalContactEmail
        case portalDescription
        case portalLogoImage
        case portalName
        case roleArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let portalNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .portalName)
        portalName = portalNameDecoded
        let portalDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .portalDescription)
        portalDescription = portalDescriptionDecoded
        let portalContactEmailDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .portalContactEmail)
        portalContactEmail = portalContactEmailDecoded
        let portalLogoImageDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.Image.self, forKey: .portalLogoImage)
        portalLogoImage = portalLogoImageDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let notificationSenderEmailDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .notificationSenderEmail)
        notificationSenderEmail = notificationSenderEmailDecoded
        let alarmsDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.Alarms.self, forKey: .alarms)
        alarms = alarmsDecoded
    }
}

extension UpdatePortalOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdatePortalOutputBody = try responseDecoder.decode(responseBody: data)
            self.portalStatus = output.portalStatus
        } else {
            self.portalStatus = nil
        }
    }
}

public struct UpdatePortalOutput: Swift.Equatable {
    /// The status of the portal, which contains a state (UPDATING after successfully calling this operation) and any error message.
    /// This member is required.
    public var portalStatus: IoTSiteWiseClientTypes.PortalStatus?

    public init(
        portalStatus: IoTSiteWiseClientTypes.PortalStatus? = nil
    )
    {
        self.portalStatus = portalStatus
    }
}

struct UpdatePortalOutputBody: Swift.Equatable {
    let portalStatus: IoTSiteWiseClientTypes.PortalStatus?
}

extension UpdatePortalOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case portalStatus
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let portalStatusDecoded = try containerValues.decodeIfPresent(IoTSiteWiseClientTypes.PortalStatus.self, forKey: .portalStatus)
        portalStatus = portalStatusDecoded
    }
}

enum UpdatePortalOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictingOperationException": return try await ConflictingOperationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateProjectInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case projectDescription
        case projectName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let projectDescription = self.projectDescription {
            try encodeContainer.encode(projectDescription, forKey: .projectDescription)
        }
        if let projectName = self.projectName {
            try encodeContainer.encode(projectName, forKey: .projectName)
        }
    }
}

extension UpdateProjectInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let projectId = projectId else {
            return nil
        }
        return "/projects/\(projectId.urlPercentEncoding())"
    }
}

public struct UpdateProjectInput: Swift.Equatable {
    /// A unique case-sensitive identifier that you can provide to ensure the idempotency of the request. Don't reuse this client token if a new idempotent request is required.
    public var clientToken: Swift.String?
    /// A new description for the project.
    public var projectDescription: Swift.String?
    /// The ID of the project to update.
    /// This member is required.
    public var projectId: Swift.String?
    /// A new friendly name for the project.
    /// This member is required.
    public var projectName: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        projectDescription: Swift.String? = nil,
        projectId: Swift.String? = nil,
        projectName: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.projectDescription = projectDescription
        self.projectId = projectId
        self.projectName = projectName
    }
}

struct UpdateProjectInputBody: Swift.Equatable {
    let projectName: Swift.String?
    let projectDescription: Swift.String?
    let clientToken: Swift.String?
}

extension UpdateProjectInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case projectDescription
        case projectName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let projectNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectName)
        projectName = projectNameDecoded
        let projectDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .projectDescription)
        projectDescription = projectDescriptionDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension UpdateProjectOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateProjectOutput: Swift.Equatable {

    public init() { }
}

enum UpdateProjectOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalFailureException": return try await InternalFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidRequestException": return try await InvalidRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension IoTSiteWiseClientTypes.UserIdentity: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
    }
}

extension IoTSiteWiseClientTypes {
    /// Contains information for a user identity in an access policy.
    public struct UserIdentity: Swift.Equatable {
        /// The IAM Identity Center ID of the user.
        /// This member is required.
        public var id: Swift.String?

        public init(
            id: Swift.String? = nil
        )
        {
            self.id = id
        }
    }

}

extension IoTSiteWiseClientTypes.VariableValue: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hierarchyId
        case propertyId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let hierarchyId = self.hierarchyId {
            try encodeContainer.encode(hierarchyId, forKey: .hierarchyId)
        }
        if let propertyId = self.propertyId {
            try encodeContainer.encode(propertyId, forKey: .propertyId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let propertyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .propertyId)
        propertyId = propertyIdDecoded
        let hierarchyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hierarchyId)
        hierarchyId = hierarchyIdDecoded
    }
}

extension IoTSiteWiseClientTypes {
    /// Identifies a property value used in an expression.
    public struct VariableValue: Swift.Equatable {
        /// The ID of the hierarchy to query for the property ID. You can use the hierarchy's name instead of the hierarchy's ID. You use a hierarchy ID instead of a model ID because you can have several hierarchies using the same model and therefore the same propertyId. For example, you might have separately grouped assets that come from the same asset model. For more information, see [Asset hierarchies](https://docs.aws.amazon.com/iot-sitewise/latest/userguide/asset-hierarchies.html) in the IoT SiteWise User Guide.
        public var hierarchyId: Swift.String?
        /// The ID of the property to use as the variable. You can use the property name if it's from the same asset model.
        /// This member is required.
        public var propertyId: Swift.String?

        public init(
            hierarchyId: Swift.String? = nil,
            propertyId: Swift.String? = nil
        )
        {
            self.hierarchyId = hierarchyId
            self.propertyId = propertyId
        }
    }

}

extension IoTSiteWiseClientTypes.Variant: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case booleanValue
        case doubleValue
        case integerValue
        case stringValue
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let booleanValue = self.booleanValue {
            try encodeContainer.encode(booleanValue, forKey: .booleanValue)
        }
        if let doubleValue = self.doubleValue {
            try encodeContainer.encode(doubleValue, forKey: .doubleValue)
        }
        if let integerValue = self.integerValue {
            try encodeContainer.encode(integerValue, forKey: .integerValue)
        }
        if let stringValue = self.stringValue {
            try encodeContainer.encode(stringValue, forKey: .stringValue)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stringValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stringValue)
        stringValue = stringValueDecoded
        let integerValueDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .integerValue)
        integerValue = integerValueDecoded
        let doubleValueDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .doubleValue)
        doubleValue = doubleValueDecoded
        let booleanValueDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .booleanValue)
        booleanValue = booleanValueDecoded
    }
}

extension IoTSiteWiseClientTypes {
    /// Contains an asset property value (of a single type only).
    public struct Variant: Swift.Equatable {
        /// Asset property data of type Boolean (true or false).
        public var booleanValue: Swift.Bool?
        /// Asset property data of type double (floating point number).
        public var doubleValue: Swift.Double?
        /// Asset property data of type integer (whole number).
        public var integerValue: Swift.Int?
        /// Asset property data of type string (sequence of characters).
        public var stringValue: Swift.String?

        public init(
            booleanValue: Swift.Bool? = nil,
            doubleValue: Swift.Double? = nil,
            integerValue: Swift.Int? = nil,
            stringValue: Swift.String? = nil
        )
        {
            self.booleanValue = booleanValue
            self.doubleValue = doubleValue
            self.integerValue = integerValue
            self.stringValue = stringValue
        }
    }

}
