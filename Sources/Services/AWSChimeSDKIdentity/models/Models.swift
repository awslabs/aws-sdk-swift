// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension ChimeSDKIdentityClientTypes {
    public enum AllowMessages: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case all
        case `none`
        case sdkUnknown(Swift.String)

        public static var allCases: [AllowMessages] {
            return [
                .all,
                .none,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .all: return "ALL"
            case .none: return "NONE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AllowMessages(rawValue: rawValue) ?? AllowMessages.sdkUnknown(rawValue)
        }
    }
}

extension ChimeSDKIdentityClientTypes.AppInstance: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appInstanceArn = "AppInstanceArn"
        case createdTimestamp = "CreatedTimestamp"
        case lastUpdatedTimestamp = "LastUpdatedTimestamp"
        case metadata = "Metadata"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appInstanceArn = self.appInstanceArn {
            try encodeContainer.encode(appInstanceArn, forKey: .appInstanceArn)
        }
        if let createdTimestamp = self.createdTimestamp {
            try encodeContainer.encodeTimestamp(createdTimestamp, format: .epochSeconds, forKey: .createdTimestamp)
        }
        if let lastUpdatedTimestamp = self.lastUpdatedTimestamp {
            try encodeContainer.encodeTimestamp(lastUpdatedTimestamp, format: .epochSeconds, forKey: .lastUpdatedTimestamp)
        }
        if let metadata = self.metadata {
            try encodeContainer.encode(metadata, forKey: .metadata)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appInstanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appInstanceArn)
        appInstanceArn = appInstanceArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let createdTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
        let lastUpdatedTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedTimestamp)
        lastUpdatedTimestamp = lastUpdatedTimestampDecoded
        let metadataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metadata)
        metadata = metadataDecoded
    }
}

extension ChimeSDKIdentityClientTypes.AppInstance: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AppInstance(appInstanceArn: \(Swift.String(describing: appInstanceArn)), createdTimestamp: \(Swift.String(describing: createdTimestamp)), lastUpdatedTimestamp: \(Swift.String(describing: lastUpdatedTimestamp)), metadata: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension ChimeSDKIdentityClientTypes {
    /// The details of an AppInstance, an instance of an Amazon Chime SDK messaging application.
    public struct AppInstance: Swift.Equatable {
        /// The ARN of the messaging instance.
        public var appInstanceArn: Swift.String?
        /// The time at which an AppInstance was created. In epoch milliseconds.
        public var createdTimestamp: ClientRuntime.Date?
        /// The time an AppInstance was last updated. In epoch milliseconds.
        public var lastUpdatedTimestamp: ClientRuntime.Date?
        /// The metadata of an AppInstance.
        public var metadata: Swift.String?
        /// The name of an AppInstance.
        public var name: Swift.String?

        public init(
            appInstanceArn: Swift.String? = nil,
            createdTimestamp: ClientRuntime.Date? = nil,
            lastUpdatedTimestamp: ClientRuntime.Date? = nil,
            metadata: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.appInstanceArn = appInstanceArn
            self.createdTimestamp = createdTimestamp
            self.lastUpdatedTimestamp = lastUpdatedTimestamp
            self.metadata = metadata
            self.name = name
        }
    }

}

extension ChimeSDKIdentityClientTypes.AppInstanceAdmin: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case admin = "Admin"
        case appInstanceArn = "AppInstanceArn"
        case createdTimestamp = "CreatedTimestamp"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let admin = self.admin {
            try encodeContainer.encode(admin, forKey: .admin)
        }
        if let appInstanceArn = self.appInstanceArn {
            try encodeContainer.encode(appInstanceArn, forKey: .appInstanceArn)
        }
        if let createdTimestamp = self.createdTimestamp {
            try encodeContainer.encodeTimestamp(createdTimestamp, format: .epochSeconds, forKey: .createdTimestamp)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let adminDecoded = try containerValues.decodeIfPresent(ChimeSDKIdentityClientTypes.Identity.self, forKey: .admin)
        admin = adminDecoded
        let appInstanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appInstanceArn)
        appInstanceArn = appInstanceArnDecoded
        let createdTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
    }
}

extension ChimeSDKIdentityClientTypes {
    /// The name and ARN of the admin for the AppInstance.
    public struct AppInstanceAdmin: Swift.Equatable {
        /// The AppInstanceAdmin data.
        public var admin: ChimeSDKIdentityClientTypes.Identity?
        /// The ARN of the AppInstance for which the user is an administrator.
        public var appInstanceArn: Swift.String?
        /// The time at which an administrator was created.
        public var createdTimestamp: ClientRuntime.Date?

        public init(
            admin: ChimeSDKIdentityClientTypes.Identity? = nil,
            appInstanceArn: Swift.String? = nil,
            createdTimestamp: ClientRuntime.Date? = nil
        )
        {
            self.admin = admin
            self.appInstanceArn = appInstanceArn
            self.createdTimestamp = createdTimestamp
        }
    }

}

extension ChimeSDKIdentityClientTypes.AppInstanceAdminSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case admin = "Admin"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let admin = self.admin {
            try encodeContainer.encode(admin, forKey: .admin)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let adminDecoded = try containerValues.decodeIfPresent(ChimeSDKIdentityClientTypes.Identity.self, forKey: .admin)
        admin = adminDecoded
    }
}

extension ChimeSDKIdentityClientTypes {
    /// Summary of the details of an AppInstanceAdmin.
    public struct AppInstanceAdminSummary: Swift.Equatable {
        /// The details of the AppInstanceAdmin.
        public var admin: ChimeSDKIdentityClientTypes.Identity?

        public init(
            admin: ChimeSDKIdentityClientTypes.Identity? = nil
        )
        {
            self.admin = admin
        }
    }

}

extension ChimeSDKIdentityClientTypes.AppInstanceBot: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appInstanceBotArn = "AppInstanceBotArn"
        case configuration = "Configuration"
        case createdTimestamp = "CreatedTimestamp"
        case lastUpdatedTimestamp = "LastUpdatedTimestamp"
        case metadata = "Metadata"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appInstanceBotArn = self.appInstanceBotArn {
            try encodeContainer.encode(appInstanceBotArn, forKey: .appInstanceBotArn)
        }
        if let configuration = self.configuration {
            try encodeContainer.encode(configuration, forKey: .configuration)
        }
        if let createdTimestamp = self.createdTimestamp {
            try encodeContainer.encodeTimestamp(createdTimestamp, format: .epochSeconds, forKey: .createdTimestamp)
        }
        if let lastUpdatedTimestamp = self.lastUpdatedTimestamp {
            try encodeContainer.encodeTimestamp(lastUpdatedTimestamp, format: .epochSeconds, forKey: .lastUpdatedTimestamp)
        }
        if let metadata = self.metadata {
            try encodeContainer.encode(metadata, forKey: .metadata)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appInstanceBotArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appInstanceBotArn)
        appInstanceBotArn = appInstanceBotArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let configurationDecoded = try containerValues.decodeIfPresent(ChimeSDKIdentityClientTypes.Configuration.self, forKey: .configuration)
        configuration = configurationDecoded
        let createdTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
        let lastUpdatedTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedTimestamp)
        lastUpdatedTimestamp = lastUpdatedTimestampDecoded
        let metadataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metadata)
        metadata = metadataDecoded
    }
}

extension ChimeSDKIdentityClientTypes.AppInstanceBot: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AppInstanceBot(appInstanceBotArn: \(Swift.String(describing: appInstanceBotArn)), configuration: \(Swift.String(describing: configuration)), createdTimestamp: \(Swift.String(describing: createdTimestamp)), lastUpdatedTimestamp: \(Swift.String(describing: lastUpdatedTimestamp)), metadata: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension ChimeSDKIdentityClientTypes {
    /// An Amazon Lex V2 chat bot created under an AppInstance.
    public struct AppInstanceBot: Swift.Equatable {
        /// The ARN of the AppInstanceBot.
        public var appInstanceBotArn: Swift.String?
        /// The data processing instructions for an AppInstanceBot.
        public var configuration: ChimeSDKIdentityClientTypes.Configuration?
        /// The time at which the AppInstanceBot was created.
        public var createdTimestamp: ClientRuntime.Date?
        /// The time at which the AppInstanceBot was last updated.
        public var lastUpdatedTimestamp: ClientRuntime.Date?
        /// The metadata for an AppInstanceBot.
        public var metadata: Swift.String?
        /// The name of the AppInstanceBot.
        public var name: Swift.String?

        public init(
            appInstanceBotArn: Swift.String? = nil,
            configuration: ChimeSDKIdentityClientTypes.Configuration? = nil,
            createdTimestamp: ClientRuntime.Date? = nil,
            lastUpdatedTimestamp: ClientRuntime.Date? = nil,
            metadata: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.appInstanceBotArn = appInstanceBotArn
            self.configuration = configuration
            self.createdTimestamp = createdTimestamp
            self.lastUpdatedTimestamp = lastUpdatedTimestamp
            self.metadata = metadata
            self.name = name
        }
    }

}

extension ChimeSDKIdentityClientTypes.AppInstanceBotSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appInstanceBotArn = "AppInstanceBotArn"
        case metadata = "Metadata"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appInstanceBotArn = self.appInstanceBotArn {
            try encodeContainer.encode(appInstanceBotArn, forKey: .appInstanceBotArn)
        }
        if let metadata = self.metadata {
            try encodeContainer.encode(metadata, forKey: .metadata)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appInstanceBotArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appInstanceBotArn)
        appInstanceBotArn = appInstanceBotArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let metadataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metadata)
        metadata = metadataDecoded
    }
}

extension ChimeSDKIdentityClientTypes.AppInstanceBotSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AppInstanceBotSummary(appInstanceBotArn: \(Swift.String(describing: appInstanceBotArn)), metadata: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension ChimeSDKIdentityClientTypes {
    /// High-level information about an AppInstanceBot.
    public struct AppInstanceBotSummary: Swift.Equatable {
        /// The ARN of the AppInstanceBot.
        public var appInstanceBotArn: Swift.String?
        /// The metadata of the AppInstanceBot.
        public var metadata: Swift.String?
        /// The name of the AppInstanceBox.
        public var name: Swift.String?

        public init(
            appInstanceBotArn: Swift.String? = nil,
            metadata: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.appInstanceBotArn = appInstanceBotArn
            self.metadata = metadata
            self.name = name
        }
    }

}

extension ChimeSDKIdentityClientTypes.AppInstanceRetentionSettings: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case channelRetentionSettings = "ChannelRetentionSettings"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let channelRetentionSettings = self.channelRetentionSettings {
            try encodeContainer.encode(channelRetentionSettings, forKey: .channelRetentionSettings)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let channelRetentionSettingsDecoded = try containerValues.decodeIfPresent(ChimeSDKIdentityClientTypes.ChannelRetentionSettings.self, forKey: .channelRetentionSettings)
        channelRetentionSettings = channelRetentionSettingsDecoded
    }
}

extension ChimeSDKIdentityClientTypes {
    /// The details of the data-retention settings for an AppInstance.
    public struct AppInstanceRetentionSettings: Swift.Equatable {
        /// The length of time in days to retain the messages in a channel.
        public var channelRetentionSettings: ChimeSDKIdentityClientTypes.ChannelRetentionSettings?

        public init(
            channelRetentionSettings: ChimeSDKIdentityClientTypes.ChannelRetentionSettings? = nil
        )
        {
            self.channelRetentionSettings = channelRetentionSettings
        }
    }

}

extension ChimeSDKIdentityClientTypes.AppInstanceSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appInstanceArn = "AppInstanceArn"
        case metadata = "Metadata"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appInstanceArn = self.appInstanceArn {
            try encodeContainer.encode(appInstanceArn, forKey: .appInstanceArn)
        }
        if let metadata = self.metadata {
            try encodeContainer.encode(metadata, forKey: .metadata)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appInstanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appInstanceArn)
        appInstanceArn = appInstanceArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let metadataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metadata)
        metadata = metadataDecoded
    }
}

extension ChimeSDKIdentityClientTypes.AppInstanceSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AppInstanceSummary(appInstanceArn: \(Swift.String(describing: appInstanceArn)), metadata: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension ChimeSDKIdentityClientTypes {
    /// Summary of the data for an AppInstance.
    public struct AppInstanceSummary: Swift.Equatable {
        /// The AppInstance ARN.
        public var appInstanceArn: Swift.String?
        /// The metadata of the AppInstance.
        public var metadata: Swift.String?
        /// The name of the AppInstance.
        public var name: Swift.String?

        public init(
            appInstanceArn: Swift.String? = nil,
            metadata: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.appInstanceArn = appInstanceArn
            self.metadata = metadata
            self.name = name
        }
    }

}

extension ChimeSDKIdentityClientTypes.AppInstanceUser: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appInstanceUserArn = "AppInstanceUserArn"
        case createdTimestamp = "CreatedTimestamp"
        case expirationSettings = "ExpirationSettings"
        case lastUpdatedTimestamp = "LastUpdatedTimestamp"
        case metadata = "Metadata"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appInstanceUserArn = self.appInstanceUserArn {
            try encodeContainer.encode(appInstanceUserArn, forKey: .appInstanceUserArn)
        }
        if let createdTimestamp = self.createdTimestamp {
            try encodeContainer.encodeTimestamp(createdTimestamp, format: .epochSeconds, forKey: .createdTimestamp)
        }
        if let expirationSettings = self.expirationSettings {
            try encodeContainer.encode(expirationSettings, forKey: .expirationSettings)
        }
        if let lastUpdatedTimestamp = self.lastUpdatedTimestamp {
            try encodeContainer.encodeTimestamp(lastUpdatedTimestamp, format: .epochSeconds, forKey: .lastUpdatedTimestamp)
        }
        if let metadata = self.metadata {
            try encodeContainer.encode(metadata, forKey: .metadata)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appInstanceUserArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appInstanceUserArn)
        appInstanceUserArn = appInstanceUserArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let metadataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metadata)
        metadata = metadataDecoded
        let createdTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
        let lastUpdatedTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedTimestamp)
        lastUpdatedTimestamp = lastUpdatedTimestampDecoded
        let expirationSettingsDecoded = try containerValues.decodeIfPresent(ChimeSDKIdentityClientTypes.ExpirationSettings.self, forKey: .expirationSettings)
        expirationSettings = expirationSettingsDecoded
    }
}

extension ChimeSDKIdentityClientTypes.AppInstanceUser: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AppInstanceUser(appInstanceUserArn: \(Swift.String(describing: appInstanceUserArn)), createdTimestamp: \(Swift.String(describing: createdTimestamp)), expirationSettings: \(Swift.String(describing: expirationSettings)), lastUpdatedTimestamp: \(Swift.String(describing: lastUpdatedTimestamp)), metadata: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension ChimeSDKIdentityClientTypes {
    /// The details of an AppInstanceUser.
    public struct AppInstanceUser: Swift.Equatable {
        /// The ARN of the AppInstanceUser.
        public var appInstanceUserArn: Swift.String?
        /// The time at which the AppInstanceUser was created.
        public var createdTimestamp: ClientRuntime.Date?
        /// The interval after which an AppInstanceUser is automatically deleted.
        public var expirationSettings: ChimeSDKIdentityClientTypes.ExpirationSettings?
        /// The time at which the AppInstanceUser was last updated.
        public var lastUpdatedTimestamp: ClientRuntime.Date?
        /// The metadata of the AppInstanceUser.
        public var metadata: Swift.String?
        /// The name of the AppInstanceUser.
        public var name: Swift.String?

        public init(
            appInstanceUserArn: Swift.String? = nil,
            createdTimestamp: ClientRuntime.Date? = nil,
            expirationSettings: ChimeSDKIdentityClientTypes.ExpirationSettings? = nil,
            lastUpdatedTimestamp: ClientRuntime.Date? = nil,
            metadata: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.appInstanceUserArn = appInstanceUserArn
            self.createdTimestamp = createdTimestamp
            self.expirationSettings = expirationSettings
            self.lastUpdatedTimestamp = lastUpdatedTimestamp
            self.metadata = metadata
            self.name = name
        }
    }

}

extension ChimeSDKIdentityClientTypes.AppInstanceUserEndpoint: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowMessages = "AllowMessages"
        case appInstanceUserArn = "AppInstanceUserArn"
        case createdTimestamp = "CreatedTimestamp"
        case endpointAttributes = "EndpointAttributes"
        case endpointId = "EndpointId"
        case endpointState = "EndpointState"
        case lastUpdatedTimestamp = "LastUpdatedTimestamp"
        case name = "Name"
        case resourceArn = "ResourceArn"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowMessages = self.allowMessages {
            try encodeContainer.encode(allowMessages.rawValue, forKey: .allowMessages)
        }
        if let appInstanceUserArn = self.appInstanceUserArn {
            try encodeContainer.encode(appInstanceUserArn, forKey: .appInstanceUserArn)
        }
        if let createdTimestamp = self.createdTimestamp {
            try encodeContainer.encodeTimestamp(createdTimestamp, format: .epochSeconds, forKey: .createdTimestamp)
        }
        if let endpointAttributes = self.endpointAttributes {
            try encodeContainer.encode(endpointAttributes, forKey: .endpointAttributes)
        }
        if let endpointId = self.endpointId {
            try encodeContainer.encode(endpointId, forKey: .endpointId)
        }
        if let endpointState = self.endpointState {
            try encodeContainer.encode(endpointState, forKey: .endpointState)
        }
        if let lastUpdatedTimestamp = self.lastUpdatedTimestamp {
            try encodeContainer.encodeTimestamp(lastUpdatedTimestamp, format: .epochSeconds, forKey: .lastUpdatedTimestamp)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appInstanceUserArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appInstanceUserArn)
        appInstanceUserArn = appInstanceUserArnDecoded
        let endpointIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointId)
        endpointId = endpointIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ChimeSDKIdentityClientTypes.AppInstanceUserEndpointType.self, forKey: .type)
        type = typeDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let endpointAttributesDecoded = try containerValues.decodeIfPresent(ChimeSDKIdentityClientTypes.EndpointAttributes.self, forKey: .endpointAttributes)
        endpointAttributes = endpointAttributesDecoded
        let createdTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdTimestamp)
        createdTimestamp = createdTimestampDecoded
        let lastUpdatedTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedTimestamp)
        lastUpdatedTimestamp = lastUpdatedTimestampDecoded
        let allowMessagesDecoded = try containerValues.decodeIfPresent(ChimeSDKIdentityClientTypes.AllowMessages.self, forKey: .allowMessages)
        allowMessages = allowMessagesDecoded
        let endpointStateDecoded = try containerValues.decodeIfPresent(ChimeSDKIdentityClientTypes.EndpointState.self, forKey: .endpointState)
        endpointState = endpointStateDecoded
    }
}

extension ChimeSDKIdentityClientTypes.AppInstanceUserEndpoint: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AppInstanceUserEndpoint(allowMessages: \(Swift.String(describing: allowMessages)), appInstanceUserArn: \(Swift.String(describing: appInstanceUserArn)), createdTimestamp: \(Swift.String(describing: createdTimestamp)), endpointAttributes: \(Swift.String(describing: endpointAttributes)), endpointId: \(Swift.String(describing: endpointId)), endpointState: \(Swift.String(describing: endpointState)), lastUpdatedTimestamp: \(Swift.String(describing: lastUpdatedTimestamp)), resourceArn: \(Swift.String(describing: resourceArn)), type: \(Swift.String(describing: type)), name: \"CONTENT_REDACTED\")"}
}

extension ChimeSDKIdentityClientTypes {
    /// An endpoint under an Amazon Chime AppInstanceUser that receives messages for a user. For push notifications, the endpoint is a mobile device used to receive mobile push notifications for a user.
    public struct AppInstanceUserEndpoint: Swift.Equatable {
        /// Boolean that controls whether the AppInstanceUserEndpoint is opted in to receive messages. ALL indicates the endpoint will receive all messages. NONE indicates the endpoint will receive no messages.
        public var allowMessages: ChimeSDKIdentityClientTypes.AllowMessages?
        /// The ARN of the AppInstanceUser.
        public var appInstanceUserArn: Swift.String?
        /// The time at which an AppInstanceUserEndpoint was created.
        public var createdTimestamp: ClientRuntime.Date?
        /// The attributes of an Endpoint.
        public var endpointAttributes: ChimeSDKIdentityClientTypes.EndpointAttributes?
        /// The unique identifier of the AppInstanceUserEndpoint.
        public var endpointId: Swift.String?
        /// A read-only field that represents the state of an AppInstanceUserEndpoint. Supported values:
        ///
        /// * ACTIVE: The AppInstanceUserEndpoint is active and able to receive messages. When ACTIVE, the EndpointStatusReason remains empty.
        ///
        /// * INACTIVE: The AppInstanceUserEndpoint is inactive and can't receive message. When INACTIVE, the corresponding reason will be conveyed through EndpointStatusReason.
        ///
        /// * INVALID_DEVICE_TOKEN indicates that an AppInstanceUserEndpoint is INACTIVE due to invalid device token
        ///
        /// * INVALID_PINPOINT_ARN indicates that an AppInstanceUserEndpoint is INACTIVE due to an invalid pinpoint ARN that was input through the ResourceArn field.
        public var endpointState: ChimeSDKIdentityClientTypes.EndpointState?
        /// The time at which an AppInstanceUserEndpoint was last updated.
        public var lastUpdatedTimestamp: ClientRuntime.Date?
        /// The name of the AppInstanceUserEndpoint.
        public var name: Swift.String?
        /// The ARN of the resource to which the endpoint belongs.
        public var resourceArn: Swift.String?
        /// The type of the AppInstanceUserEndpoint.
        public var type: ChimeSDKIdentityClientTypes.AppInstanceUserEndpointType?

        public init(
            allowMessages: ChimeSDKIdentityClientTypes.AllowMessages? = nil,
            appInstanceUserArn: Swift.String? = nil,
            createdTimestamp: ClientRuntime.Date? = nil,
            endpointAttributes: ChimeSDKIdentityClientTypes.EndpointAttributes? = nil,
            endpointId: Swift.String? = nil,
            endpointState: ChimeSDKIdentityClientTypes.EndpointState? = nil,
            lastUpdatedTimestamp: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            resourceArn: Swift.String? = nil,
            type: ChimeSDKIdentityClientTypes.AppInstanceUserEndpointType? = nil
        )
        {
            self.allowMessages = allowMessages
            self.appInstanceUserArn = appInstanceUserArn
            self.createdTimestamp = createdTimestamp
            self.endpointAttributes = endpointAttributes
            self.endpointId = endpointId
            self.endpointState = endpointState
            self.lastUpdatedTimestamp = lastUpdatedTimestamp
            self.name = name
            self.resourceArn = resourceArn
            self.type = type
        }
    }

}

extension ChimeSDKIdentityClientTypes.AppInstanceUserEndpointSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowMessages = "AllowMessages"
        case appInstanceUserArn = "AppInstanceUserArn"
        case endpointId = "EndpointId"
        case endpointState = "EndpointState"
        case name = "Name"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowMessages = self.allowMessages {
            try encodeContainer.encode(allowMessages.rawValue, forKey: .allowMessages)
        }
        if let appInstanceUserArn = self.appInstanceUserArn {
            try encodeContainer.encode(appInstanceUserArn, forKey: .appInstanceUserArn)
        }
        if let endpointId = self.endpointId {
            try encodeContainer.encode(endpointId, forKey: .endpointId)
        }
        if let endpointState = self.endpointState {
            try encodeContainer.encode(endpointState, forKey: .endpointState)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appInstanceUserArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appInstanceUserArn)
        appInstanceUserArn = appInstanceUserArnDecoded
        let endpointIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointId)
        endpointId = endpointIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ChimeSDKIdentityClientTypes.AppInstanceUserEndpointType.self, forKey: .type)
        type = typeDecoded
        let allowMessagesDecoded = try containerValues.decodeIfPresent(ChimeSDKIdentityClientTypes.AllowMessages.self, forKey: .allowMessages)
        allowMessages = allowMessagesDecoded
        let endpointStateDecoded = try containerValues.decodeIfPresent(ChimeSDKIdentityClientTypes.EndpointState.self, forKey: .endpointState)
        endpointState = endpointStateDecoded
    }
}

extension ChimeSDKIdentityClientTypes.AppInstanceUserEndpointSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AppInstanceUserEndpointSummary(allowMessages: \(Swift.String(describing: allowMessages)), appInstanceUserArn: \(Swift.String(describing: appInstanceUserArn)), endpointId: \(Swift.String(describing: endpointId)), endpointState: \(Swift.String(describing: endpointState)), type: \(Swift.String(describing: type)), name: \"CONTENT_REDACTED\")"}
}

extension ChimeSDKIdentityClientTypes {
    /// Summary of the details of an AppInstanceUserEndpoint.
    public struct AppInstanceUserEndpointSummary: Swift.Equatable {
        /// BBoolean that controls whether the AppInstanceUserEndpoint is opted in to receive messages. ALL indicates the endpoint will receive all messages. NONE indicates the endpoint will receive no messages.
        public var allowMessages: ChimeSDKIdentityClientTypes.AllowMessages?
        /// The ARN of the AppInstanceUser.
        public var appInstanceUserArn: Swift.String?
        /// The unique identifier of the AppInstanceUserEndpoint.
        public var endpointId: Swift.String?
        /// A read-only field that represent the state of an AppInstanceUserEndpoint.
        public var endpointState: ChimeSDKIdentityClientTypes.EndpointState?
        /// The name of the AppInstanceUserEndpoint.
        public var name: Swift.String?
        /// The type of the AppInstanceUserEndpoint.
        public var type: ChimeSDKIdentityClientTypes.AppInstanceUserEndpointType?

        public init(
            allowMessages: ChimeSDKIdentityClientTypes.AllowMessages? = nil,
            appInstanceUserArn: Swift.String? = nil,
            endpointId: Swift.String? = nil,
            endpointState: ChimeSDKIdentityClientTypes.EndpointState? = nil,
            name: Swift.String? = nil,
            type: ChimeSDKIdentityClientTypes.AppInstanceUserEndpointType? = nil
        )
        {
            self.allowMessages = allowMessages
            self.appInstanceUserArn = appInstanceUserArn
            self.endpointId = endpointId
            self.endpointState = endpointState
            self.name = name
            self.type = type
        }
    }

}

extension ChimeSDKIdentityClientTypes {
    public enum AppInstanceUserEndpointType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case apns
        case apnsSandbox
        case gcm
        case sdkUnknown(Swift.String)

        public static var allCases: [AppInstanceUserEndpointType] {
            return [
                .apns,
                .apnsSandbox,
                .gcm,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .apns: return "APNS"
            case .apnsSandbox: return "APNS_SANDBOX"
            case .gcm: return "GCM"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AppInstanceUserEndpointType(rawValue: rawValue) ?? AppInstanceUserEndpointType.sdkUnknown(rawValue)
        }
    }
}

extension ChimeSDKIdentityClientTypes.AppInstanceUserSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appInstanceUserArn = "AppInstanceUserArn"
        case metadata = "Metadata"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appInstanceUserArn = self.appInstanceUserArn {
            try encodeContainer.encode(appInstanceUserArn, forKey: .appInstanceUserArn)
        }
        if let metadata = self.metadata {
            try encodeContainer.encode(metadata, forKey: .metadata)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appInstanceUserArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appInstanceUserArn)
        appInstanceUserArn = appInstanceUserArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let metadataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metadata)
        metadata = metadataDecoded
    }
}

extension ChimeSDKIdentityClientTypes.AppInstanceUserSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AppInstanceUserSummary(appInstanceUserArn: \(Swift.String(describing: appInstanceUserArn)), metadata: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension ChimeSDKIdentityClientTypes {
    /// Summary of the details of an AppInstanceUser.
    public struct AppInstanceUserSummary: Swift.Equatable {
        /// The ARN of the AppInstanceUser.
        public var appInstanceUserArn: Swift.String?
        /// The metadata of the AppInstanceUser.
        public var metadata: Swift.String?
        /// The name of an AppInstanceUser.
        public var name: Swift.String?

        public init(
            appInstanceUserArn: Swift.String? = nil,
            metadata: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.appInstanceUserArn = appInstanceUserArn
            self.metadata = metadata
            self.name = name
        }
    }

}

extension BadRequestException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: BadRequestExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.code = output.code
            self.properties.message = output.message
        } else {
            self.properties.code = nil
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The input parameters don't match the service's restrictions.
public struct BadRequestException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var code: ChimeSDKIdentityClientTypes.ErrorCode? = nil
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "BadRequestException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: ChimeSDKIdentityClientTypes.ErrorCode? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
    }
}

struct BadRequestExceptionBody: Swift.Equatable {
    let code: ChimeSDKIdentityClientTypes.ErrorCode?
    let message: Swift.String?
}

extension BadRequestExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(ChimeSDKIdentityClientTypes.ErrorCode.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ChimeSDKIdentityClientTypes.ChannelRetentionSettings: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case retentionDays = "RetentionDays"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let retentionDays = self.retentionDays {
            try encodeContainer.encode(retentionDays, forKey: .retentionDays)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let retentionDaysDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .retentionDays)
        retentionDays = retentionDaysDecoded
    }
}

extension ChimeSDKIdentityClientTypes {
    /// The details of the retention settings for a channel.
    public struct ChannelRetentionSettings: Swift.Equatable {
        /// The time in days to retain the messages in a channel.
        public var retentionDays: Swift.Int?

        public init(
            retentionDays: Swift.Int? = nil
        )
        {
            self.retentionDays = retentionDays
        }
    }

}

extension ChimeSDKIdentityClientTypes.Configuration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lex = "Lex"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lex = self.lex {
            try encodeContainer.encode(lex, forKey: .lex)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lexDecoded = try containerValues.decodeIfPresent(ChimeSDKIdentityClientTypes.LexConfiguration.self, forKey: .lex)
        lex = lexDecoded
    }
}

extension ChimeSDKIdentityClientTypes {
    /// A structure that contains configuration data.
    public struct Configuration: Swift.Equatable {
        /// The configuration for an Amazon Lex V2 bot.
        /// This member is required.
        public var lex: ChimeSDKIdentityClientTypes.LexConfiguration?

        public init(
            lex: ChimeSDKIdentityClientTypes.LexConfiguration? = nil
        )
        {
            self.lex = lex
        }
    }

}

extension ConflictException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.code = output.code
            self.properties.message = output.message
        } else {
            self.properties.code = nil
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request could not be processed because of conflict in the current state of the resource.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var code: ChimeSDKIdentityClientTypes.ErrorCode? = nil
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: ChimeSDKIdentityClientTypes.ErrorCode? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let code: ChimeSDKIdentityClientTypes.ErrorCode?
    let message: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(ChimeSDKIdentityClientTypes.ErrorCode.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension CreateAppInstanceAdminInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appInstanceAdminArn = "AppInstanceAdminArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appInstanceAdminArn = self.appInstanceAdminArn {
            try encodeContainer.encode(appInstanceAdminArn, forKey: .appInstanceAdminArn)
        }
    }
}

extension CreateAppInstanceAdminInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appInstanceArn = appInstanceArn else {
            return nil
        }
        return "/app-instances/\(appInstanceArn.urlPercentEncoding())/admins"
    }
}

public struct CreateAppInstanceAdminInput: Swift.Equatable {
    /// The ARN of the administrator of the current AppInstance.
    /// This member is required.
    public var appInstanceAdminArn: Swift.String?
    /// The ARN of the AppInstance.
    /// This member is required.
    public var appInstanceArn: Swift.String?

    public init(
        appInstanceAdminArn: Swift.String? = nil,
        appInstanceArn: Swift.String? = nil
    )
    {
        self.appInstanceAdminArn = appInstanceAdminArn
        self.appInstanceArn = appInstanceArn
    }
}

struct CreateAppInstanceAdminInputBody: Swift.Equatable {
    let appInstanceAdminArn: Swift.String?
}

extension CreateAppInstanceAdminInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appInstanceAdminArn = "AppInstanceAdminArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appInstanceAdminArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appInstanceAdminArn)
        appInstanceAdminArn = appInstanceAdminArnDecoded
    }
}

extension CreateAppInstanceAdminOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateAppInstanceAdminOutputBody = try responseDecoder.decode(responseBody: data)
            self.appInstanceAdmin = output.appInstanceAdmin
            self.appInstanceArn = output.appInstanceArn
        } else {
            self.appInstanceAdmin = nil
            self.appInstanceArn = nil
        }
    }
}

public struct CreateAppInstanceAdminOutput: Swift.Equatable {
    /// The ARN and name of the administrator, the ARN of the AppInstance, and the created and last-updated timestamps. All timestamps use epoch milliseconds.
    public var appInstanceAdmin: ChimeSDKIdentityClientTypes.Identity?
    /// The ARN of the of the admin for the AppInstance.
    public var appInstanceArn: Swift.String?

    public init(
        appInstanceAdmin: ChimeSDKIdentityClientTypes.Identity? = nil,
        appInstanceArn: Swift.String? = nil
    )
    {
        self.appInstanceAdmin = appInstanceAdmin
        self.appInstanceArn = appInstanceArn
    }
}

struct CreateAppInstanceAdminOutputBody: Swift.Equatable {
    let appInstanceAdmin: ChimeSDKIdentityClientTypes.Identity?
    let appInstanceArn: Swift.String?
}

extension CreateAppInstanceAdminOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appInstanceAdmin = "AppInstanceAdmin"
        case appInstanceArn = "AppInstanceArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appInstanceAdminDecoded = try containerValues.decodeIfPresent(ChimeSDKIdentityClientTypes.Identity.self, forKey: .appInstanceAdmin)
        appInstanceAdmin = appInstanceAdminDecoded
        let appInstanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appInstanceArn)
        appInstanceArn = appInstanceArnDecoded
    }
}

enum CreateAppInstanceAdminOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceLimitExceededException": return try await ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateAppInstanceBotInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateAppInstanceBotInput(appInstanceArn: \(Swift.String(describing: appInstanceArn)), clientRequestToken: \(Swift.String(describing: clientRequestToken)), configuration: \(Swift.String(describing: configuration)), tags: \(Swift.String(describing: tags)), metadata: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension CreateAppInstanceBotInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appInstanceArn = "AppInstanceArn"
        case clientRequestToken = "ClientRequestToken"
        case configuration = "Configuration"
        case metadata = "Metadata"
        case name = "Name"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appInstanceArn = self.appInstanceArn {
            try encodeContainer.encode(appInstanceArn, forKey: .appInstanceArn)
        }
        if let clientRequestToken = self.clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let configuration = self.configuration {
            try encodeContainer.encode(configuration, forKey: .configuration)
        }
        if let metadata = self.metadata {
            try encodeContainer.encode(metadata, forKey: .metadata)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateAppInstanceBotInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/app-instance-bots"
    }
}

public struct CreateAppInstanceBotInput: Swift.Equatable {
    /// The ARN of the AppInstance request.
    /// This member is required.
    public var appInstanceArn: Swift.String?
    /// The unique ID for the client making the request. Use different tokens for different AppInstanceBots.
    /// This member is required.
    public var clientRequestToken: Swift.String?
    /// Configuration information about the Amazon Lex V2 V2 bot.
    /// This member is required.
    public var configuration: ChimeSDKIdentityClientTypes.Configuration?
    /// The request metadata. Limited to a 1KB string in UTF-8.
    public var metadata: Swift.String?
    /// The user's name.
    public var name: Swift.String?
    /// The tags assigned to the AppInstanceBot.
    public var tags: [ChimeSDKIdentityClientTypes.Tag]?

    public init(
        appInstanceArn: Swift.String? = nil,
        clientRequestToken: Swift.String? = nil,
        configuration: ChimeSDKIdentityClientTypes.Configuration? = nil,
        metadata: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [ChimeSDKIdentityClientTypes.Tag]? = nil
    )
    {
        self.appInstanceArn = appInstanceArn
        self.clientRequestToken = clientRequestToken
        self.configuration = configuration
        self.metadata = metadata
        self.name = name
        self.tags = tags
    }
}

struct CreateAppInstanceBotInputBody: Swift.Equatable {
    let appInstanceArn: Swift.String?
    let name: Swift.String?
    let metadata: Swift.String?
    let clientRequestToken: Swift.String?
    let tags: [ChimeSDKIdentityClientTypes.Tag]?
    let configuration: ChimeSDKIdentityClientTypes.Configuration?
}

extension CreateAppInstanceBotInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appInstanceArn = "AppInstanceArn"
        case clientRequestToken = "ClientRequestToken"
        case configuration = "Configuration"
        case metadata = "Metadata"
        case name = "Name"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appInstanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appInstanceArn)
        appInstanceArn = appInstanceArnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let metadataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metadata)
        metadata = metadataDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([ChimeSDKIdentityClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ChimeSDKIdentityClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ChimeSDKIdentityClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let configurationDecoded = try containerValues.decodeIfPresent(ChimeSDKIdentityClientTypes.Configuration.self, forKey: .configuration)
        configuration = configurationDecoded
    }
}

extension CreateAppInstanceBotOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateAppInstanceBotOutputBody = try responseDecoder.decode(responseBody: data)
            self.appInstanceBotArn = output.appInstanceBotArn
        } else {
            self.appInstanceBotArn = nil
        }
    }
}

public struct CreateAppInstanceBotOutput: Swift.Equatable {
    /// The ARN of the AppinstanceBot.
    public var appInstanceBotArn: Swift.String?

    public init(
        appInstanceBotArn: Swift.String? = nil
    )
    {
        self.appInstanceBotArn = appInstanceBotArn
    }
}

struct CreateAppInstanceBotOutputBody: Swift.Equatable {
    let appInstanceBotArn: Swift.String?
}

extension CreateAppInstanceBotOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appInstanceBotArn = "AppInstanceBotArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appInstanceBotArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appInstanceBotArn)
        appInstanceBotArn = appInstanceBotArnDecoded
    }
}

enum CreateAppInstanceBotOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceLimitExceededException": return try await ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateAppInstanceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateAppInstanceInput(clientRequestToken: \(Swift.String(describing: clientRequestToken)), tags: \(Swift.String(describing: tags)), metadata: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension CreateAppInstanceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case metadata = "Metadata"
        case name = "Name"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientRequestToken = self.clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let metadata = self.metadata {
            try encodeContainer.encode(metadata, forKey: .metadata)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateAppInstanceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/app-instances"
    }
}

public struct CreateAppInstanceInput: Swift.Equatable {
    /// The unique ID of the request. Use different tokens to create different AppInstances.
    /// This member is required.
    public var clientRequestToken: Swift.String?
    /// The metadata of the AppInstance. Limited to a 1KB string in UTF-8.
    public var metadata: Swift.String?
    /// The name of the AppInstance.
    /// This member is required.
    public var name: Swift.String?
    /// Tags assigned to the AppInstance.
    public var tags: [ChimeSDKIdentityClientTypes.Tag]?

    public init(
        clientRequestToken: Swift.String? = nil,
        metadata: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [ChimeSDKIdentityClientTypes.Tag]? = nil
    )
    {
        self.clientRequestToken = clientRequestToken
        self.metadata = metadata
        self.name = name
        self.tags = tags
    }
}

struct CreateAppInstanceInputBody: Swift.Equatable {
    let name: Swift.String?
    let metadata: Swift.String?
    let clientRequestToken: Swift.String?
    let tags: [ChimeSDKIdentityClientTypes.Tag]?
}

extension CreateAppInstanceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientRequestToken = "ClientRequestToken"
        case metadata = "Metadata"
        case name = "Name"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let metadataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metadata)
        metadata = metadataDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([ChimeSDKIdentityClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ChimeSDKIdentityClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ChimeSDKIdentityClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateAppInstanceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateAppInstanceOutputBody = try responseDecoder.decode(responseBody: data)
            self.appInstanceArn = output.appInstanceArn
        } else {
            self.appInstanceArn = nil
        }
    }
}

public struct CreateAppInstanceOutput: Swift.Equatable {
    /// The Amazon Resource Number (ARN) of the AppInstance.
    public var appInstanceArn: Swift.String?

    public init(
        appInstanceArn: Swift.String? = nil
    )
    {
        self.appInstanceArn = appInstanceArn
    }
}

struct CreateAppInstanceOutputBody: Swift.Equatable {
    let appInstanceArn: Swift.String?
}

extension CreateAppInstanceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appInstanceArn = "AppInstanceArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appInstanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appInstanceArn)
        appInstanceArn = appInstanceArnDecoded
    }
}

enum CreateAppInstanceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceLimitExceededException": return try await ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateAppInstanceUserInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateAppInstanceUserInput(appInstanceArn: \(Swift.String(describing: appInstanceArn)), clientRequestToken: \(Swift.String(describing: clientRequestToken)), expirationSettings: \(Swift.String(describing: expirationSettings)), tags: \(Swift.String(describing: tags)), appInstanceUserId: \"CONTENT_REDACTED\", metadata: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension CreateAppInstanceUserInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appInstanceArn = "AppInstanceArn"
        case appInstanceUserId = "AppInstanceUserId"
        case clientRequestToken = "ClientRequestToken"
        case expirationSettings = "ExpirationSettings"
        case metadata = "Metadata"
        case name = "Name"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appInstanceArn = self.appInstanceArn {
            try encodeContainer.encode(appInstanceArn, forKey: .appInstanceArn)
        }
        if let appInstanceUserId = self.appInstanceUserId {
            try encodeContainer.encode(appInstanceUserId, forKey: .appInstanceUserId)
        }
        if let clientRequestToken = self.clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let expirationSettings = self.expirationSettings {
            try encodeContainer.encode(expirationSettings, forKey: .expirationSettings)
        }
        if let metadata = self.metadata {
            try encodeContainer.encode(metadata, forKey: .metadata)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateAppInstanceUserInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/app-instance-users"
    }
}

public struct CreateAppInstanceUserInput: Swift.Equatable {
    /// The ARN of the AppInstance request.
    /// This member is required.
    public var appInstanceArn: Swift.String?
    /// The user ID of the AppInstance.
    /// This member is required.
    public var appInstanceUserId: Swift.String?
    /// The unique ID of the request. Use different tokens to request additional AppInstances.
    /// This member is required.
    public var clientRequestToken: Swift.String?
    /// Settings that control the interval after which the AppInstanceUser is automatically deleted.
    public var expirationSettings: ChimeSDKIdentityClientTypes.ExpirationSettings?
    /// The request's metadata. Limited to a 1KB string in UTF-8.
    public var metadata: Swift.String?
    /// The user's name.
    /// This member is required.
    public var name: Swift.String?
    /// Tags assigned to the AppInstanceUser.
    public var tags: [ChimeSDKIdentityClientTypes.Tag]?

    public init(
        appInstanceArn: Swift.String? = nil,
        appInstanceUserId: Swift.String? = nil,
        clientRequestToken: Swift.String? = nil,
        expirationSettings: ChimeSDKIdentityClientTypes.ExpirationSettings? = nil,
        metadata: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [ChimeSDKIdentityClientTypes.Tag]? = nil
    )
    {
        self.appInstanceArn = appInstanceArn
        self.appInstanceUserId = appInstanceUserId
        self.clientRequestToken = clientRequestToken
        self.expirationSettings = expirationSettings
        self.metadata = metadata
        self.name = name
        self.tags = tags
    }
}

struct CreateAppInstanceUserInputBody: Swift.Equatable {
    let appInstanceArn: Swift.String?
    let appInstanceUserId: Swift.String?
    let name: Swift.String?
    let metadata: Swift.String?
    let clientRequestToken: Swift.String?
    let tags: [ChimeSDKIdentityClientTypes.Tag]?
    let expirationSettings: ChimeSDKIdentityClientTypes.ExpirationSettings?
}

extension CreateAppInstanceUserInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appInstanceArn = "AppInstanceArn"
        case appInstanceUserId = "AppInstanceUserId"
        case clientRequestToken = "ClientRequestToken"
        case expirationSettings = "ExpirationSettings"
        case metadata = "Metadata"
        case name = "Name"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appInstanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appInstanceArn)
        appInstanceArn = appInstanceArnDecoded
        let appInstanceUserIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appInstanceUserId)
        appInstanceUserId = appInstanceUserIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let metadataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metadata)
        metadata = metadataDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([ChimeSDKIdentityClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ChimeSDKIdentityClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ChimeSDKIdentityClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let expirationSettingsDecoded = try containerValues.decodeIfPresent(ChimeSDKIdentityClientTypes.ExpirationSettings.self, forKey: .expirationSettings)
        expirationSettings = expirationSettingsDecoded
    }
}

extension CreateAppInstanceUserOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateAppInstanceUserOutputBody = try responseDecoder.decode(responseBody: data)
            self.appInstanceUserArn = output.appInstanceUserArn
        } else {
            self.appInstanceUserArn = nil
        }
    }
}

public struct CreateAppInstanceUserOutput: Swift.Equatable {
    /// The user's ARN.
    public var appInstanceUserArn: Swift.String?

    public init(
        appInstanceUserArn: Swift.String? = nil
    )
    {
        self.appInstanceUserArn = appInstanceUserArn
    }
}

struct CreateAppInstanceUserOutputBody: Swift.Equatable {
    let appInstanceUserArn: Swift.String?
}

extension CreateAppInstanceUserOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appInstanceUserArn = "AppInstanceUserArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appInstanceUserArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appInstanceUserArn)
        appInstanceUserArn = appInstanceUserArnDecoded
    }
}

enum CreateAppInstanceUserOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceLimitExceededException": return try await ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteAppInstanceAdminInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appInstanceArn = appInstanceArn else {
            return nil
        }
        guard let appInstanceAdminArn = appInstanceAdminArn else {
            return nil
        }
        return "/app-instances/\(appInstanceArn.urlPercentEncoding())/admins/\(appInstanceAdminArn.urlPercentEncoding())"
    }
}

public struct DeleteAppInstanceAdminInput: Swift.Equatable {
    /// The ARN of the AppInstance's administrator.
    /// This member is required.
    public var appInstanceAdminArn: Swift.String?
    /// The ARN of the AppInstance.
    /// This member is required.
    public var appInstanceArn: Swift.String?

    public init(
        appInstanceAdminArn: Swift.String? = nil,
        appInstanceArn: Swift.String? = nil
    )
    {
        self.appInstanceAdminArn = appInstanceAdminArn
        self.appInstanceArn = appInstanceArn
    }
}

struct DeleteAppInstanceAdminInputBody: Swift.Equatable {
}

extension DeleteAppInstanceAdminInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteAppInstanceAdminOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteAppInstanceAdminOutput: Swift.Equatable {

    public init() { }
}

enum DeleteAppInstanceAdminOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceLimitExceededException": return try await ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteAppInstanceBotInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appInstanceBotArn = appInstanceBotArn else {
            return nil
        }
        return "/app-instance-bots/\(appInstanceBotArn.urlPercentEncoding())"
    }
}

public struct DeleteAppInstanceBotInput: Swift.Equatable {
    /// The ARN of the AppInstanceBot being deleted.
    /// This member is required.
    public var appInstanceBotArn: Swift.String?

    public init(
        appInstanceBotArn: Swift.String? = nil
    )
    {
        self.appInstanceBotArn = appInstanceBotArn
    }
}

struct DeleteAppInstanceBotInputBody: Swift.Equatable {
}

extension DeleteAppInstanceBotInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteAppInstanceBotOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteAppInstanceBotOutput: Swift.Equatable {

    public init() { }
}

enum DeleteAppInstanceBotOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceLimitExceededException": return try await ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteAppInstanceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appInstanceArn = appInstanceArn else {
            return nil
        }
        return "/app-instances/\(appInstanceArn.urlPercentEncoding())"
    }
}

public struct DeleteAppInstanceInput: Swift.Equatable {
    /// The ARN of the AppInstance.
    /// This member is required.
    public var appInstanceArn: Swift.String?

    public init(
        appInstanceArn: Swift.String? = nil
    )
    {
        self.appInstanceArn = appInstanceArn
    }
}

struct DeleteAppInstanceInputBody: Swift.Equatable {
}

extension DeleteAppInstanceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteAppInstanceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteAppInstanceOutput: Swift.Equatable {

    public init() { }
}

enum DeleteAppInstanceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceLimitExceededException": return try await ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteAppInstanceUserInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appInstanceUserArn = appInstanceUserArn else {
            return nil
        }
        return "/app-instance-users/\(appInstanceUserArn.urlPercentEncoding())"
    }
}

public struct DeleteAppInstanceUserInput: Swift.Equatable {
    /// The ARN of the user request being deleted.
    /// This member is required.
    public var appInstanceUserArn: Swift.String?

    public init(
        appInstanceUserArn: Swift.String? = nil
    )
    {
        self.appInstanceUserArn = appInstanceUserArn
    }
}

struct DeleteAppInstanceUserInputBody: Swift.Equatable {
}

extension DeleteAppInstanceUserInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteAppInstanceUserOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteAppInstanceUserOutput: Swift.Equatable {

    public init() { }
}

enum DeleteAppInstanceUserOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceLimitExceededException": return try await ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeregisterAppInstanceUserEndpointInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appInstanceUserArn = appInstanceUserArn else {
            return nil
        }
        guard let endpointId = endpointId else {
            return nil
        }
        return "/app-instance-users/\(appInstanceUserArn.urlPercentEncoding())/endpoints/\(endpointId.urlPercentEncoding())"
    }
}

public struct DeregisterAppInstanceUserEndpointInput: Swift.Equatable {
    /// The ARN of the AppInstanceUser.
    /// This member is required.
    public var appInstanceUserArn: Swift.String?
    /// The unique identifier of the AppInstanceUserEndpoint.
    /// This member is required.
    public var endpointId: Swift.String?

    public init(
        appInstanceUserArn: Swift.String? = nil,
        endpointId: Swift.String? = nil
    )
    {
        self.appInstanceUserArn = appInstanceUserArn
        self.endpointId = endpointId
    }
}

struct DeregisterAppInstanceUserEndpointInputBody: Swift.Equatable {
}

extension DeregisterAppInstanceUserEndpointInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeregisterAppInstanceUserEndpointOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeregisterAppInstanceUserEndpointOutput: Swift.Equatable {

    public init() { }
}

enum DeregisterAppInstanceUserEndpointOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeAppInstanceAdminInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appInstanceArn = appInstanceArn else {
            return nil
        }
        guard let appInstanceAdminArn = appInstanceAdminArn else {
            return nil
        }
        return "/app-instances/\(appInstanceArn.urlPercentEncoding())/admins/\(appInstanceAdminArn.urlPercentEncoding())"
    }
}

public struct DescribeAppInstanceAdminInput: Swift.Equatable {
    /// The ARN of the AppInstanceAdmin.
    /// This member is required.
    public var appInstanceAdminArn: Swift.String?
    /// The ARN of the AppInstance.
    /// This member is required.
    public var appInstanceArn: Swift.String?

    public init(
        appInstanceAdminArn: Swift.String? = nil,
        appInstanceArn: Swift.String? = nil
    )
    {
        self.appInstanceAdminArn = appInstanceAdminArn
        self.appInstanceArn = appInstanceArn
    }
}

struct DescribeAppInstanceAdminInputBody: Swift.Equatable {
}

extension DescribeAppInstanceAdminInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeAppInstanceAdminOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeAppInstanceAdminOutputBody = try responseDecoder.decode(responseBody: data)
            self.appInstanceAdmin = output.appInstanceAdmin
        } else {
            self.appInstanceAdmin = nil
        }
    }
}

public struct DescribeAppInstanceAdminOutput: Swift.Equatable {
    /// The ARN and name of the AppInstanceUser, the ARN of the AppInstance, and the created and last-updated timestamps. All timestamps use epoch milliseconds.
    public var appInstanceAdmin: ChimeSDKIdentityClientTypes.AppInstanceAdmin?

    public init(
        appInstanceAdmin: ChimeSDKIdentityClientTypes.AppInstanceAdmin? = nil
    )
    {
        self.appInstanceAdmin = appInstanceAdmin
    }
}

struct DescribeAppInstanceAdminOutputBody: Swift.Equatable {
    let appInstanceAdmin: ChimeSDKIdentityClientTypes.AppInstanceAdmin?
}

extension DescribeAppInstanceAdminOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appInstanceAdmin = "AppInstanceAdmin"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appInstanceAdminDecoded = try containerValues.decodeIfPresent(ChimeSDKIdentityClientTypes.AppInstanceAdmin.self, forKey: .appInstanceAdmin)
        appInstanceAdmin = appInstanceAdminDecoded
    }
}

enum DescribeAppInstanceAdminOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeAppInstanceBotInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appInstanceBotArn = appInstanceBotArn else {
            return nil
        }
        return "/app-instance-bots/\(appInstanceBotArn.urlPercentEncoding())"
    }
}

public struct DescribeAppInstanceBotInput: Swift.Equatable {
    /// The ARN of the AppInstanceBot.
    /// This member is required.
    public var appInstanceBotArn: Swift.String?

    public init(
        appInstanceBotArn: Swift.String? = nil
    )
    {
        self.appInstanceBotArn = appInstanceBotArn
    }
}

struct DescribeAppInstanceBotInputBody: Swift.Equatable {
}

extension DescribeAppInstanceBotInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeAppInstanceBotOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeAppInstanceBotOutputBody = try responseDecoder.decode(responseBody: data)
            self.appInstanceBot = output.appInstanceBot
        } else {
            self.appInstanceBot = nil
        }
    }
}

public struct DescribeAppInstanceBotOutput: Swift.Equatable {
    /// The detials of the AppInstanceBot.
    public var appInstanceBot: ChimeSDKIdentityClientTypes.AppInstanceBot?

    public init(
        appInstanceBot: ChimeSDKIdentityClientTypes.AppInstanceBot? = nil
    )
    {
        self.appInstanceBot = appInstanceBot
    }
}

struct DescribeAppInstanceBotOutputBody: Swift.Equatable {
    let appInstanceBot: ChimeSDKIdentityClientTypes.AppInstanceBot?
}

extension DescribeAppInstanceBotOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appInstanceBot = "AppInstanceBot"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appInstanceBotDecoded = try containerValues.decodeIfPresent(ChimeSDKIdentityClientTypes.AppInstanceBot.self, forKey: .appInstanceBot)
        appInstanceBot = appInstanceBotDecoded
    }
}

enum DescribeAppInstanceBotOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeAppInstanceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appInstanceArn = appInstanceArn else {
            return nil
        }
        return "/app-instances/\(appInstanceArn.urlPercentEncoding())"
    }
}

public struct DescribeAppInstanceInput: Swift.Equatable {
    /// The ARN of the AppInstance.
    /// This member is required.
    public var appInstanceArn: Swift.String?

    public init(
        appInstanceArn: Swift.String? = nil
    )
    {
        self.appInstanceArn = appInstanceArn
    }
}

struct DescribeAppInstanceInputBody: Swift.Equatable {
}

extension DescribeAppInstanceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeAppInstanceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeAppInstanceOutputBody = try responseDecoder.decode(responseBody: data)
            self.appInstance = output.appInstance
        } else {
            self.appInstance = nil
        }
    }
}

public struct DescribeAppInstanceOutput: Swift.Equatable {
    /// The ARN, metadata, created and last-updated timestamps, and the name of the AppInstance. All timestamps use epoch milliseconds.
    public var appInstance: ChimeSDKIdentityClientTypes.AppInstance?

    public init(
        appInstance: ChimeSDKIdentityClientTypes.AppInstance? = nil
    )
    {
        self.appInstance = appInstance
    }
}

struct DescribeAppInstanceOutputBody: Swift.Equatable {
    let appInstance: ChimeSDKIdentityClientTypes.AppInstance?
}

extension DescribeAppInstanceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appInstance = "AppInstance"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appInstanceDecoded = try containerValues.decodeIfPresent(ChimeSDKIdentityClientTypes.AppInstance.self, forKey: .appInstance)
        appInstance = appInstanceDecoded
    }
}

enum DescribeAppInstanceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeAppInstanceUserEndpointInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appInstanceUserArn = appInstanceUserArn else {
            return nil
        }
        guard let endpointId = endpointId else {
            return nil
        }
        return "/app-instance-users/\(appInstanceUserArn.urlPercentEncoding())/endpoints/\(endpointId.urlPercentEncoding())"
    }
}

public struct DescribeAppInstanceUserEndpointInput: Swift.Equatable {
    /// The ARN of the AppInstanceUser.
    /// This member is required.
    public var appInstanceUserArn: Swift.String?
    /// The unique identifier of the AppInstanceUserEndpoint.
    /// This member is required.
    public var endpointId: Swift.String?

    public init(
        appInstanceUserArn: Swift.String? = nil,
        endpointId: Swift.String? = nil
    )
    {
        self.appInstanceUserArn = appInstanceUserArn
        self.endpointId = endpointId
    }
}

struct DescribeAppInstanceUserEndpointInputBody: Swift.Equatable {
}

extension DescribeAppInstanceUserEndpointInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeAppInstanceUserEndpointOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeAppInstanceUserEndpointOutputBody = try responseDecoder.decode(responseBody: data)
            self.appInstanceUserEndpoint = output.appInstanceUserEndpoint
        } else {
            self.appInstanceUserEndpoint = nil
        }
    }
}

public struct DescribeAppInstanceUserEndpointOutput: Swift.Equatable {
    /// The full details of an AppInstanceUserEndpoint: the AppInstanceUserArn, ID, name, type, resource ARN, attributes, allow messages, state, and created and last updated timestamps. All timestamps use epoch milliseconds.
    public var appInstanceUserEndpoint: ChimeSDKIdentityClientTypes.AppInstanceUserEndpoint?

    public init(
        appInstanceUserEndpoint: ChimeSDKIdentityClientTypes.AppInstanceUserEndpoint? = nil
    )
    {
        self.appInstanceUserEndpoint = appInstanceUserEndpoint
    }
}

struct DescribeAppInstanceUserEndpointOutputBody: Swift.Equatable {
    let appInstanceUserEndpoint: ChimeSDKIdentityClientTypes.AppInstanceUserEndpoint?
}

extension DescribeAppInstanceUserEndpointOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appInstanceUserEndpoint = "AppInstanceUserEndpoint"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appInstanceUserEndpointDecoded = try containerValues.decodeIfPresent(ChimeSDKIdentityClientTypes.AppInstanceUserEndpoint.self, forKey: .appInstanceUserEndpoint)
        appInstanceUserEndpoint = appInstanceUserEndpointDecoded
    }
}

enum DescribeAppInstanceUserEndpointOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeAppInstanceUserInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appInstanceUserArn = appInstanceUserArn else {
            return nil
        }
        return "/app-instance-users/\(appInstanceUserArn.urlPercentEncoding())"
    }
}

public struct DescribeAppInstanceUserInput: Swift.Equatable {
    /// The ARN of the AppInstanceUser.
    /// This member is required.
    public var appInstanceUserArn: Swift.String?

    public init(
        appInstanceUserArn: Swift.String? = nil
    )
    {
        self.appInstanceUserArn = appInstanceUserArn
    }
}

struct DescribeAppInstanceUserInputBody: Swift.Equatable {
}

extension DescribeAppInstanceUserInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeAppInstanceUserOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeAppInstanceUserOutputBody = try responseDecoder.decode(responseBody: data)
            self.appInstanceUser = output.appInstanceUser
        } else {
            self.appInstanceUser = nil
        }
    }
}

public struct DescribeAppInstanceUserOutput: Swift.Equatable {
    /// The name of the AppInstanceUser.
    public var appInstanceUser: ChimeSDKIdentityClientTypes.AppInstanceUser?

    public init(
        appInstanceUser: ChimeSDKIdentityClientTypes.AppInstanceUser? = nil
    )
    {
        self.appInstanceUser = appInstanceUser
    }
}

struct DescribeAppInstanceUserOutputBody: Swift.Equatable {
    let appInstanceUser: ChimeSDKIdentityClientTypes.AppInstanceUser?
}

extension DescribeAppInstanceUserOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appInstanceUser = "AppInstanceUser"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appInstanceUserDecoded = try containerValues.decodeIfPresent(ChimeSDKIdentityClientTypes.AppInstanceUser.self, forKey: .appInstanceUser)
        appInstanceUser = appInstanceUserDecoded
    }
}

enum DescribeAppInstanceUserOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ChimeSDKIdentityClientTypes.EndpointAttributes: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceToken = "DeviceToken"
        case voipDeviceToken = "VoipDeviceToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deviceToken = self.deviceToken {
            try encodeContainer.encode(deviceToken, forKey: .deviceToken)
        }
        if let voipDeviceToken = self.voipDeviceToken {
            try encodeContainer.encode(voipDeviceToken, forKey: .voipDeviceToken)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceToken)
        deviceToken = deviceTokenDecoded
        let voipDeviceTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .voipDeviceToken)
        voipDeviceToken = voipDeviceTokenDecoded
    }
}

extension ChimeSDKIdentityClientTypes.EndpointAttributes: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EndpointAttributes(deviceToken: \"CONTENT_REDACTED\", voipDeviceToken: \"CONTENT_REDACTED\")"}
}

extension ChimeSDKIdentityClientTypes {
    /// The attributes of an Endpoint.
    public struct EndpointAttributes: Swift.Equatable {
        /// The device token for the GCM, APNS, and APNS_SANDBOX endpoint types.
        /// This member is required.
        public var deviceToken: Swift.String?
        /// The VOIP device token for the APNS and APNS_SANDBOX endpoint types.
        public var voipDeviceToken: Swift.String?

        public init(
            deviceToken: Swift.String? = nil,
            voipDeviceToken: Swift.String? = nil
        )
        {
            self.deviceToken = deviceToken
            self.voipDeviceToken = voipDeviceToken
        }
    }

}

extension ChimeSDKIdentityClientTypes.EndpointState: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status = "Status"
        case statusReason = "StatusReason"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let statusReason = self.statusReason {
            try encodeContainer.encode(statusReason.rawValue, forKey: .statusReason)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(ChimeSDKIdentityClientTypes.EndpointStatus.self, forKey: .status)
        status = statusDecoded
        let statusReasonDecoded = try containerValues.decodeIfPresent(ChimeSDKIdentityClientTypes.EndpointStatusReason.self, forKey: .statusReason)
        statusReason = statusReasonDecoded
    }
}

extension ChimeSDKIdentityClientTypes {
    /// A read-only field that represents the state of an AppInstanceUserEndpoint. Supported values:
    ///
    /// * ACTIVE: The AppInstanceUserEndpoint is active and able to receive messages. When ACTIVE, the EndpointStatusReason remains empty.
    ///
    /// * INACTIVE: The AppInstanceUserEndpoint is inactive and can't receive message. When INACTIVE, the corresponding reason will be conveyed through EndpointStatusReason.
    ///
    /// * INVALID_DEVICE_TOKEN indicates that an AppInstanceUserEndpoint is INACTIVE due to invalid device token
    ///
    /// * INVALID_PINPOINT_ARN indicates that an AppInstanceUserEndpoint is INACTIVE due to an invalid pinpoint ARN that was input through the ResourceArn field.
    public struct EndpointState: Swift.Equatable {
        /// Enum that indicates the Status of an AppInstanceUserEndpoint.
        /// This member is required.
        public var status: ChimeSDKIdentityClientTypes.EndpointStatus?
        /// The reason for the EndpointStatus.
        public var statusReason: ChimeSDKIdentityClientTypes.EndpointStatusReason?

        public init(
            status: ChimeSDKIdentityClientTypes.EndpointStatus? = nil,
            statusReason: ChimeSDKIdentityClientTypes.EndpointStatusReason? = nil
        )
        {
            self.status = status
            self.statusReason = statusReason
        }
    }

}

extension ChimeSDKIdentityClientTypes {
    public enum EndpointStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case inactive
        case sdkUnknown(Swift.String)

        public static var allCases: [EndpointStatus] {
            return [
                .active,
                .inactive,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .inactive: return "INACTIVE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EndpointStatus(rawValue: rawValue) ?? EndpointStatus.sdkUnknown(rawValue)
        }
    }
}

extension ChimeSDKIdentityClientTypes {
    public enum EndpointStatusReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case invalidDeviceToken
        case invalidPinpointArn
        case sdkUnknown(Swift.String)

        public static var allCases: [EndpointStatusReason] {
            return [
                .invalidDeviceToken,
                .invalidPinpointArn,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .invalidDeviceToken: return "INVALID_DEVICE_TOKEN"
            case .invalidPinpointArn: return "INVALID_PINPOINT_ARN"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EndpointStatusReason(rawValue: rawValue) ?? EndpointStatusReason.sdkUnknown(rawValue)
        }
    }
}

extension ChimeSDKIdentityClientTypes {
    public enum ErrorCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case accessdenied
        case badrequest
        case conflict
        case forbidden
        case notfound
        case phonenumberassociationsexist
        case preconditionfailed
        case resourcelimitexceeded
        case servicefailure
        case serviceunavailable
        case throttled
        case throttling
        case unauthorized
        case unprocessable
        case voiceconnectorgroupassociationsexist
        case sdkUnknown(Swift.String)

        public static var allCases: [ErrorCode] {
            return [
                .accessdenied,
                .badrequest,
                .conflict,
                .forbidden,
                .notfound,
                .phonenumberassociationsexist,
                .preconditionfailed,
                .resourcelimitexceeded,
                .servicefailure,
                .serviceunavailable,
                .throttled,
                .throttling,
                .unauthorized,
                .unprocessable,
                .voiceconnectorgroupassociationsexist,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .accessdenied: return "AccessDenied"
            case .badrequest: return "BadRequest"
            case .conflict: return "Conflict"
            case .forbidden: return "Forbidden"
            case .notfound: return "NotFound"
            case .phonenumberassociationsexist: return "PhoneNumberAssociationsExist"
            case .preconditionfailed: return "PreconditionFailed"
            case .resourcelimitexceeded: return "ResourceLimitExceeded"
            case .servicefailure: return "ServiceFailure"
            case .serviceunavailable: return "ServiceUnavailable"
            case .throttled: return "Throttled"
            case .throttling: return "Throttling"
            case .unauthorized: return "Unauthorized"
            case .unprocessable: return "Unprocessable"
            case .voiceconnectorgroupassociationsexist: return "VoiceConnectorGroupAssociationsExist"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ErrorCode(rawValue: rawValue) ?? ErrorCode.sdkUnknown(rawValue)
        }
    }
}

extension ChimeSDKIdentityClientTypes {
    public enum ExpirationCriterion: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case createdTimestamp
        case sdkUnknown(Swift.String)

        public static var allCases: [ExpirationCriterion] {
            return [
                .createdTimestamp,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .createdTimestamp: return "CREATED_TIMESTAMP"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ExpirationCriterion(rawValue: rawValue) ?? ExpirationCriterion.sdkUnknown(rawValue)
        }
    }
}

extension ChimeSDKIdentityClientTypes.ExpirationSettings: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case expirationCriterion = "ExpirationCriterion"
        case expirationDays = "ExpirationDays"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let expirationCriterion = self.expirationCriterion {
            try encodeContainer.encode(expirationCriterion.rawValue, forKey: .expirationCriterion)
        }
        if let expirationDays = self.expirationDays {
            try encodeContainer.encode(expirationDays, forKey: .expirationDays)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let expirationDaysDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .expirationDays)
        expirationDays = expirationDaysDecoded
        let expirationCriterionDecoded = try containerValues.decodeIfPresent(ChimeSDKIdentityClientTypes.ExpirationCriterion.self, forKey: .expirationCriterion)
        expirationCriterion = expirationCriterionDecoded
    }
}

extension ChimeSDKIdentityClientTypes {
    /// Determines the interval after which an AppInstanceUser is automatically deleted.
    public struct ExpirationSettings: Swift.Equatable {
        /// Specifies the conditions under which an AppInstanceUser will expire.
        /// This member is required.
        public var expirationCriterion: ChimeSDKIdentityClientTypes.ExpirationCriterion?
        /// The period in days after which an AppInstanceUser will be automatically deleted.
        /// This member is required.
        public var expirationDays: Swift.Int?

        public init(
            expirationCriterion: ChimeSDKIdentityClientTypes.ExpirationCriterion? = nil,
            expirationDays: Swift.Int? = nil
        )
        {
            self.expirationCriterion = expirationCriterion
            self.expirationDays = expirationDays
        }
    }

}

extension ForbiddenException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ForbiddenExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.code = output.code
            self.properties.message = output.message
        } else {
            self.properties.code = nil
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The client is permanently forbidden from making the request.
public struct ForbiddenException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var code: ChimeSDKIdentityClientTypes.ErrorCode? = nil
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ForbiddenException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: ChimeSDKIdentityClientTypes.ErrorCode? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
    }
}

struct ForbiddenExceptionBody: Swift.Equatable {
    let code: ChimeSDKIdentityClientTypes.ErrorCode?
    let message: Swift.String?
}

extension ForbiddenExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(ChimeSDKIdentityClientTypes.ErrorCode.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension GetAppInstanceRetentionSettingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appInstanceArn = appInstanceArn else {
            return nil
        }
        return "/app-instances/\(appInstanceArn.urlPercentEncoding())/retention-settings"
    }
}

public struct GetAppInstanceRetentionSettingsInput: Swift.Equatable {
    /// The ARN of the AppInstance.
    /// This member is required.
    public var appInstanceArn: Swift.String?

    public init(
        appInstanceArn: Swift.String? = nil
    )
    {
        self.appInstanceArn = appInstanceArn
    }
}

struct GetAppInstanceRetentionSettingsInputBody: Swift.Equatable {
}

extension GetAppInstanceRetentionSettingsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetAppInstanceRetentionSettingsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetAppInstanceRetentionSettingsOutputBody = try responseDecoder.decode(responseBody: data)
            self.appInstanceRetentionSettings = output.appInstanceRetentionSettings
            self.initiateDeletionTimestamp = output.initiateDeletionTimestamp
        } else {
            self.appInstanceRetentionSettings = nil
            self.initiateDeletionTimestamp = nil
        }
    }
}

public struct GetAppInstanceRetentionSettingsOutput: Swift.Equatable {
    /// The retention settings for the AppInstance.
    public var appInstanceRetentionSettings: ChimeSDKIdentityClientTypes.AppInstanceRetentionSettings?
    /// The timestamp representing the time at which the specified items are retained, in Epoch Seconds.
    public var initiateDeletionTimestamp: ClientRuntime.Date?

    public init(
        appInstanceRetentionSettings: ChimeSDKIdentityClientTypes.AppInstanceRetentionSettings? = nil,
        initiateDeletionTimestamp: ClientRuntime.Date? = nil
    )
    {
        self.appInstanceRetentionSettings = appInstanceRetentionSettings
        self.initiateDeletionTimestamp = initiateDeletionTimestamp
    }
}

struct GetAppInstanceRetentionSettingsOutputBody: Swift.Equatable {
    let appInstanceRetentionSettings: ChimeSDKIdentityClientTypes.AppInstanceRetentionSettings?
    let initiateDeletionTimestamp: ClientRuntime.Date?
}

extension GetAppInstanceRetentionSettingsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appInstanceRetentionSettings = "AppInstanceRetentionSettings"
        case initiateDeletionTimestamp = "InitiateDeletionTimestamp"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appInstanceRetentionSettingsDecoded = try containerValues.decodeIfPresent(ChimeSDKIdentityClientTypes.AppInstanceRetentionSettings.self, forKey: .appInstanceRetentionSettings)
        appInstanceRetentionSettings = appInstanceRetentionSettingsDecoded
        let initiateDeletionTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .initiateDeletionTimestamp)
        initiateDeletionTimestamp = initiateDeletionTimestampDecoded
    }
}

enum GetAppInstanceRetentionSettingsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ChimeSDKIdentityClientTypes.Identity: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension ChimeSDKIdentityClientTypes.Identity: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Identity(arn: \(Swift.String(describing: arn)), name: \"CONTENT_REDACTED\")"}
}

extension ChimeSDKIdentityClientTypes {
    /// The details of a user or bot.
    public struct Identity: Swift.Equatable {
        /// The ARN in an Identity.
        public var arn: Swift.String?
        /// The name in an Identity.
        public var name: Swift.String?

        public init(
            arn: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.arn = arn
            self.name = name
        }
    }

}

extension ChimeSDKIdentityClientTypes.InvokedBy: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case standardMessages = "StandardMessages"
        case targetedMessages = "TargetedMessages"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let standardMessages = self.standardMessages {
            try encodeContainer.encode(standardMessages.rawValue, forKey: .standardMessages)
        }
        if let targetedMessages = self.targetedMessages {
            try encodeContainer.encode(targetedMessages.rawValue, forKey: .targetedMessages)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let standardMessagesDecoded = try containerValues.decodeIfPresent(ChimeSDKIdentityClientTypes.StandardMessages.self, forKey: .standardMessages)
        standardMessages = standardMessagesDecoded
        let targetedMessagesDecoded = try containerValues.decodeIfPresent(ChimeSDKIdentityClientTypes.TargetedMessages.self, forKey: .targetedMessages)
        targetedMessages = targetedMessagesDecoded
    }
}

extension ChimeSDKIdentityClientTypes {
    /// Specifies the type of message that triggers a bot.
    public struct InvokedBy: Swift.Equatable {
        /// Sets standard messages as the bot trigger. For standard messages:
        ///
        /// * ALL: The bot processes all standard messages.
        ///
        /// * AUTO: The bot responds to ALL messages when the channel has one other non-hidden member, and responds to MENTIONS when the channel has more than one other non-hidden member.
        ///
        /// * MENTIONS: The bot processes all standard messages that have a message attribute with CHIME.mentions and a value of the bot ARN.
        ///
        /// * NONE: The bot processes no standard messages.
        /// This member is required.
        public var standardMessages: ChimeSDKIdentityClientTypes.StandardMessages?
        /// Sets targeted messages as the bot trigger. For targeted messages:
        ///
        /// * ALL: The bot processes all TargetedMessages sent to it. The bot then responds with a targeted message back to the sender.
        ///
        /// * NONE: The bot processes no targeted messages.
        /// This member is required.
        public var targetedMessages: ChimeSDKIdentityClientTypes.TargetedMessages?

        public init(
            standardMessages: ChimeSDKIdentityClientTypes.StandardMessages? = nil,
            targetedMessages: ChimeSDKIdentityClientTypes.TargetedMessages? = nil
        )
        {
            self.standardMessages = standardMessages
            self.targetedMessages = targetedMessages
        }
    }

}

extension ChimeSDKIdentityClientTypes.LexConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case invokedBy = "InvokedBy"
        case lexBotAliasArn = "LexBotAliasArn"
        case localeId = "LocaleId"
        case respondsTo = "RespondsTo"
        case welcomeIntent = "WelcomeIntent"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let invokedBy = self.invokedBy {
            try encodeContainer.encode(invokedBy, forKey: .invokedBy)
        }
        if let lexBotAliasArn = self.lexBotAliasArn {
            try encodeContainer.encode(lexBotAliasArn, forKey: .lexBotAliasArn)
        }
        if let localeId = self.localeId {
            try encodeContainer.encode(localeId, forKey: .localeId)
        }
        if let respondsTo = self.respondsTo {
            try encodeContainer.encode(respondsTo.rawValue, forKey: .respondsTo)
        }
        if let welcomeIntent = self.welcomeIntent {
            try encodeContainer.encode(welcomeIntent, forKey: .welcomeIntent)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let respondsToDecoded = try containerValues.decodeIfPresent(ChimeSDKIdentityClientTypes.RespondsTo.self, forKey: .respondsTo)
        respondsTo = respondsToDecoded
        let invokedByDecoded = try containerValues.decodeIfPresent(ChimeSDKIdentityClientTypes.InvokedBy.self, forKey: .invokedBy)
        invokedBy = invokedByDecoded
        let lexBotAliasArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lexBotAliasArn)
        lexBotAliasArn = lexBotAliasArnDecoded
        let localeIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .localeId)
        localeId = localeIdDecoded
        let welcomeIntentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .welcomeIntent)
        welcomeIntent = welcomeIntentDecoded
    }
}

extension ChimeSDKIdentityClientTypes {
    /// The configuration for an Amazon Lex V2 bot.
    public struct LexConfiguration: Swift.Equatable {
        /// Specifies the type of message that triggers a bot.
        public var invokedBy: ChimeSDKIdentityClientTypes.InvokedBy?
        /// The ARN of the Amazon Lex V2 bot's alias. The ARN uses this format: arn:aws:lex:REGION:ACCOUNT:bot-alias/MYBOTID/MYBOTALIAS
        /// This member is required.
        public var lexBotAliasArn: Swift.String?
        /// Identifies the Amazon Lex V2 bot's language and locale. The string must match one of the supported locales in Amazon Lex V2. All of the intents, slot types, and slots used in the bot must have the same locale. For more information, see [Supported languages](https://docs.aws.amazon.com/lexv2/latest/dg/how-languages.html) in the Amazon Lex V2 Developer Guide.
        /// This member is required.
        public var localeId: Swift.String?
        /// Deprecated. Use InvokedBy instead. Determines whether the Amazon Lex V2 bot responds to all standard messages. Control messages are not supported.
        public var respondsTo: ChimeSDKIdentityClientTypes.RespondsTo?
        /// The name of the welcome intent configured in the Amazon Lex V2 bot.
        public var welcomeIntent: Swift.String?

        public init(
            invokedBy: ChimeSDKIdentityClientTypes.InvokedBy? = nil,
            lexBotAliasArn: Swift.String? = nil,
            localeId: Swift.String? = nil,
            respondsTo: ChimeSDKIdentityClientTypes.RespondsTo? = nil,
            welcomeIntent: Swift.String? = nil
        )
        {
            self.invokedBy = invokedBy
            self.lexBotAliasArn = lexBotAliasArn
            self.localeId = localeId
            self.respondsTo = respondsTo
            self.welcomeIntent = welcomeIntent
        }
    }

}

extension ListAppInstanceAdminsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListAppInstanceAdminsInput(appInstanceArn: \(Swift.String(describing: appInstanceArn)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \"CONTENT_REDACTED\")"}
}

extension ListAppInstanceAdminsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListAppInstanceAdminsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appInstanceArn = appInstanceArn else {
            return nil
        }
        return "/app-instances/\(appInstanceArn.urlPercentEncoding())/admins"
    }
}

public struct ListAppInstanceAdminsInput: Swift.Equatable {
    /// The ARN of the AppInstance.
    /// This member is required.
    public var appInstanceArn: Swift.String?
    /// The maximum number of administrators that you want to return.
    public var maxResults: Swift.Int?
    /// The token returned from previous API requests until the number of administrators is reached.
    public var nextToken: Swift.String?

    public init(
        appInstanceArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.appInstanceArn = appInstanceArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListAppInstanceAdminsInputBody: Swift.Equatable {
}

extension ListAppInstanceAdminsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListAppInstanceAdminsOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListAppInstanceAdminsOutput(appInstanceAdmins: \(Swift.String(describing: appInstanceAdmins)), appInstanceArn: \(Swift.String(describing: appInstanceArn)), nextToken: \"CONTENT_REDACTED\")"}
}

extension ListAppInstanceAdminsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListAppInstanceAdminsOutputBody = try responseDecoder.decode(responseBody: data)
            self.appInstanceAdmins = output.appInstanceAdmins
            self.appInstanceArn = output.appInstanceArn
            self.nextToken = output.nextToken
        } else {
            self.appInstanceAdmins = nil
            self.appInstanceArn = nil
            self.nextToken = nil
        }
    }
}

public struct ListAppInstanceAdminsOutput: Swift.Equatable {
    /// The information for each administrator.
    public var appInstanceAdmins: [ChimeSDKIdentityClientTypes.AppInstanceAdminSummary]?
    /// The ARN of the AppInstance.
    public var appInstanceArn: Swift.String?
    /// The token returned from previous API requests until the number of administrators is reached.
    public var nextToken: Swift.String?

    public init(
        appInstanceAdmins: [ChimeSDKIdentityClientTypes.AppInstanceAdminSummary]? = nil,
        appInstanceArn: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.appInstanceAdmins = appInstanceAdmins
        self.appInstanceArn = appInstanceArn
        self.nextToken = nextToken
    }
}

struct ListAppInstanceAdminsOutputBody: Swift.Equatable {
    let appInstanceArn: Swift.String?
    let appInstanceAdmins: [ChimeSDKIdentityClientTypes.AppInstanceAdminSummary]?
    let nextToken: Swift.String?
}

extension ListAppInstanceAdminsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appInstanceAdmins = "AppInstanceAdmins"
        case appInstanceArn = "AppInstanceArn"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appInstanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appInstanceArn)
        appInstanceArn = appInstanceArnDecoded
        let appInstanceAdminsContainer = try containerValues.decodeIfPresent([ChimeSDKIdentityClientTypes.AppInstanceAdminSummary?].self, forKey: .appInstanceAdmins)
        var appInstanceAdminsDecoded0:[ChimeSDKIdentityClientTypes.AppInstanceAdminSummary]? = nil
        if let appInstanceAdminsContainer = appInstanceAdminsContainer {
            appInstanceAdminsDecoded0 = [ChimeSDKIdentityClientTypes.AppInstanceAdminSummary]()
            for structure0 in appInstanceAdminsContainer {
                if let structure0 = structure0 {
                    appInstanceAdminsDecoded0?.append(structure0)
                }
            }
        }
        appInstanceAdmins = appInstanceAdminsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListAppInstanceAdminsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceLimitExceededException": return try await ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListAppInstanceBotsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListAppInstanceBotsInput(appInstanceArn: \(Swift.String(describing: appInstanceArn)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \"CONTENT_REDACTED\")"}
}

extension ListAppInstanceBotsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            guard let appInstanceArn = appInstanceArn else {
                let message = "Creating a URL Query Item failed. appInstanceArn is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let appInstanceArnQueryItem = ClientRuntime.URLQueryItem(name: "app-instance-arn".urlPercentEncoding(), value: Swift.String(appInstanceArn).urlPercentEncoding())
            items.append(appInstanceArnQueryItem)
            return items
        }
    }
}

extension ListAppInstanceBotsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/app-instance-bots"
    }
}

public struct ListAppInstanceBotsInput: Swift.Equatable {
    /// The ARN of the AppInstance.
    /// This member is required.
    public var appInstanceArn: Swift.String?
    /// The maximum number of requests to return.
    public var maxResults: Swift.Int?
    /// The token passed by previous API calls until all requested bots are returned.
    public var nextToken: Swift.String?

    public init(
        appInstanceArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.appInstanceArn = appInstanceArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListAppInstanceBotsInputBody: Swift.Equatable {
}

extension ListAppInstanceBotsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListAppInstanceBotsOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListAppInstanceBotsOutput(appInstanceArn: \(Swift.String(describing: appInstanceArn)), appInstanceBots: \(Swift.String(describing: appInstanceBots)), nextToken: \"CONTENT_REDACTED\")"}
}

extension ListAppInstanceBotsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListAppInstanceBotsOutputBody = try responseDecoder.decode(responseBody: data)
            self.appInstanceArn = output.appInstanceArn
            self.appInstanceBots = output.appInstanceBots
            self.nextToken = output.nextToken
        } else {
            self.appInstanceArn = nil
            self.appInstanceBots = nil
            self.nextToken = nil
        }
    }
}

public struct ListAppInstanceBotsOutput: Swift.Equatable {
    /// The ARN of the AppInstance.
    public var appInstanceArn: Swift.String?
    /// The information for each requested AppInstanceBot.
    public var appInstanceBots: [ChimeSDKIdentityClientTypes.AppInstanceBotSummary]?
    /// The token passed by previous API calls until all requested bots are returned.
    public var nextToken: Swift.String?

    public init(
        appInstanceArn: Swift.String? = nil,
        appInstanceBots: [ChimeSDKIdentityClientTypes.AppInstanceBotSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.appInstanceArn = appInstanceArn
        self.appInstanceBots = appInstanceBots
        self.nextToken = nextToken
    }
}

struct ListAppInstanceBotsOutputBody: Swift.Equatable {
    let appInstanceArn: Swift.String?
    let appInstanceBots: [ChimeSDKIdentityClientTypes.AppInstanceBotSummary]?
    let nextToken: Swift.String?
}

extension ListAppInstanceBotsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appInstanceArn = "AppInstanceArn"
        case appInstanceBots = "AppInstanceBots"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appInstanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appInstanceArn)
        appInstanceArn = appInstanceArnDecoded
        let appInstanceBotsContainer = try containerValues.decodeIfPresent([ChimeSDKIdentityClientTypes.AppInstanceBotSummary?].self, forKey: .appInstanceBots)
        var appInstanceBotsDecoded0:[ChimeSDKIdentityClientTypes.AppInstanceBotSummary]? = nil
        if let appInstanceBotsContainer = appInstanceBotsContainer {
            appInstanceBotsDecoded0 = [ChimeSDKIdentityClientTypes.AppInstanceBotSummary]()
            for structure0 in appInstanceBotsContainer {
                if let structure0 = structure0 {
                    appInstanceBotsDecoded0?.append(structure0)
                }
            }
        }
        appInstanceBots = appInstanceBotsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListAppInstanceBotsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceLimitExceededException": return try await ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListAppInstanceUserEndpointsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListAppInstanceUserEndpointsInput(maxResults: \(Swift.String(describing: maxResults)), appInstanceUserArn: \"CONTENT_REDACTED\", nextToken: \"CONTENT_REDACTED\")"}
}

extension ListAppInstanceUserEndpointsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListAppInstanceUserEndpointsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appInstanceUserArn = appInstanceUserArn else {
            return nil
        }
        return "/app-instance-users/\(appInstanceUserArn.urlPercentEncoding())/endpoints"
    }
}

public struct ListAppInstanceUserEndpointsInput: Swift.Equatable {
    /// The ARN of the AppInstanceUser.
    /// This member is required.
    public var appInstanceUserArn: Swift.String?
    /// The maximum number of endpoints that you want to return.
    public var maxResults: Swift.Int?
    /// The token passed by previous API calls until all requested endpoints are returned.
    public var nextToken: Swift.String?

    public init(
        appInstanceUserArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.appInstanceUserArn = appInstanceUserArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListAppInstanceUserEndpointsInputBody: Swift.Equatable {
}

extension ListAppInstanceUserEndpointsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListAppInstanceUserEndpointsOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListAppInstanceUserEndpointsOutput(appInstanceUserEndpoints: \(Swift.String(describing: appInstanceUserEndpoints)), nextToken: \"CONTENT_REDACTED\")"}
}

extension ListAppInstanceUserEndpointsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListAppInstanceUserEndpointsOutputBody = try responseDecoder.decode(responseBody: data)
            self.appInstanceUserEndpoints = output.appInstanceUserEndpoints
            self.nextToken = output.nextToken
        } else {
            self.appInstanceUserEndpoints = nil
            self.nextToken = nil
        }
    }
}

public struct ListAppInstanceUserEndpointsOutput: Swift.Equatable {
    /// The information for each requested AppInstanceUserEndpoint.
    public var appInstanceUserEndpoints: [ChimeSDKIdentityClientTypes.AppInstanceUserEndpointSummary]?
    /// The token passed by previous API calls until all requested endpoints are returned.
    public var nextToken: Swift.String?

    public init(
        appInstanceUserEndpoints: [ChimeSDKIdentityClientTypes.AppInstanceUserEndpointSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.appInstanceUserEndpoints = appInstanceUserEndpoints
        self.nextToken = nextToken
    }
}

struct ListAppInstanceUserEndpointsOutputBody: Swift.Equatable {
    let appInstanceUserEndpoints: [ChimeSDKIdentityClientTypes.AppInstanceUserEndpointSummary]?
    let nextToken: Swift.String?
}

extension ListAppInstanceUserEndpointsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appInstanceUserEndpoints = "AppInstanceUserEndpoints"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appInstanceUserEndpointsContainer = try containerValues.decodeIfPresent([ChimeSDKIdentityClientTypes.AppInstanceUserEndpointSummary?].self, forKey: .appInstanceUserEndpoints)
        var appInstanceUserEndpointsDecoded0:[ChimeSDKIdentityClientTypes.AppInstanceUserEndpointSummary]? = nil
        if let appInstanceUserEndpointsContainer = appInstanceUserEndpointsContainer {
            appInstanceUserEndpointsDecoded0 = [ChimeSDKIdentityClientTypes.AppInstanceUserEndpointSummary]()
            for structure0 in appInstanceUserEndpointsContainer {
                if let structure0 = structure0 {
                    appInstanceUserEndpointsDecoded0?.append(structure0)
                }
            }
        }
        appInstanceUserEndpoints = appInstanceUserEndpointsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListAppInstanceUserEndpointsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListAppInstanceUsersInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListAppInstanceUsersInput(appInstanceArn: \(Swift.String(describing: appInstanceArn)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \"CONTENT_REDACTED\")"}
}

extension ListAppInstanceUsersInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            guard let appInstanceArn = appInstanceArn else {
                let message = "Creating a URL Query Item failed. appInstanceArn is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let appInstanceArnQueryItem = ClientRuntime.URLQueryItem(name: "app-instance-arn".urlPercentEncoding(), value: Swift.String(appInstanceArn).urlPercentEncoding())
            items.append(appInstanceArnQueryItem)
            return items
        }
    }
}

extension ListAppInstanceUsersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/app-instance-users"
    }
}

public struct ListAppInstanceUsersInput: Swift.Equatable {
    /// The ARN of the AppInstance.
    /// This member is required.
    public var appInstanceArn: Swift.String?
    /// The maximum number of requests that you want returned.
    public var maxResults: Swift.Int?
    /// The token passed by previous API calls until all requested users are returned.
    public var nextToken: Swift.String?

    public init(
        appInstanceArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.appInstanceArn = appInstanceArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListAppInstanceUsersInputBody: Swift.Equatable {
}

extension ListAppInstanceUsersInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListAppInstanceUsersOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListAppInstanceUsersOutput(appInstanceArn: \(Swift.String(describing: appInstanceArn)), appInstanceUsers: \(Swift.String(describing: appInstanceUsers)), nextToken: \"CONTENT_REDACTED\")"}
}

extension ListAppInstanceUsersOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListAppInstanceUsersOutputBody = try responseDecoder.decode(responseBody: data)
            self.appInstanceArn = output.appInstanceArn
            self.appInstanceUsers = output.appInstanceUsers
            self.nextToken = output.nextToken
        } else {
            self.appInstanceArn = nil
            self.appInstanceUsers = nil
            self.nextToken = nil
        }
    }
}

public struct ListAppInstanceUsersOutput: Swift.Equatable {
    /// The ARN of the AppInstance.
    public var appInstanceArn: Swift.String?
    /// The information for each requested AppInstanceUser.
    public var appInstanceUsers: [ChimeSDKIdentityClientTypes.AppInstanceUserSummary]?
    /// The token passed by previous API calls until all requested users are returned.
    public var nextToken: Swift.String?

    public init(
        appInstanceArn: Swift.String? = nil,
        appInstanceUsers: [ChimeSDKIdentityClientTypes.AppInstanceUserSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.appInstanceArn = appInstanceArn
        self.appInstanceUsers = appInstanceUsers
        self.nextToken = nextToken
    }
}

struct ListAppInstanceUsersOutputBody: Swift.Equatable {
    let appInstanceArn: Swift.String?
    let appInstanceUsers: [ChimeSDKIdentityClientTypes.AppInstanceUserSummary]?
    let nextToken: Swift.String?
}

extension ListAppInstanceUsersOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appInstanceArn = "AppInstanceArn"
        case appInstanceUsers = "AppInstanceUsers"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appInstanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appInstanceArn)
        appInstanceArn = appInstanceArnDecoded
        let appInstanceUsersContainer = try containerValues.decodeIfPresent([ChimeSDKIdentityClientTypes.AppInstanceUserSummary?].self, forKey: .appInstanceUsers)
        var appInstanceUsersDecoded0:[ChimeSDKIdentityClientTypes.AppInstanceUserSummary]? = nil
        if let appInstanceUsersContainer = appInstanceUsersContainer {
            appInstanceUsersDecoded0 = [ChimeSDKIdentityClientTypes.AppInstanceUserSummary]()
            for structure0 in appInstanceUsersContainer {
                if let structure0 = structure0 {
                    appInstanceUsersDecoded0?.append(structure0)
                }
            }
        }
        appInstanceUsers = appInstanceUsersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListAppInstanceUsersOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListAppInstancesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListAppInstancesInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \"CONTENT_REDACTED\")"}
}

extension ListAppInstancesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next-token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max-results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListAppInstancesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/app-instances"
    }
}

public struct ListAppInstancesInput: Swift.Equatable {
    /// The maximum number of AppInstances that you want to return.
    public var maxResults: Swift.Int?
    /// The token passed by previous API requests until you reach the maximum number of AppInstances.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListAppInstancesInputBody: Swift.Equatable {
}

extension ListAppInstancesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListAppInstancesOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListAppInstancesOutput(appInstances: \(Swift.String(describing: appInstances)), nextToken: \"CONTENT_REDACTED\")"}
}

extension ListAppInstancesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListAppInstancesOutputBody = try responseDecoder.decode(responseBody: data)
            self.appInstances = output.appInstances
            self.nextToken = output.nextToken
        } else {
            self.appInstances = nil
            self.nextToken = nil
        }
    }
}

public struct ListAppInstancesOutput: Swift.Equatable {
    /// The information for each AppInstance.
    public var appInstances: [ChimeSDKIdentityClientTypes.AppInstanceSummary]?
    /// The token passed by previous API requests until the maximum number of AppInstances is reached.
    public var nextToken: Swift.String?

    public init(
        appInstances: [ChimeSDKIdentityClientTypes.AppInstanceSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.appInstances = appInstances
        self.nextToken = nextToken
    }
}

struct ListAppInstancesOutputBody: Swift.Equatable {
    let appInstances: [ChimeSDKIdentityClientTypes.AppInstanceSummary]?
    let nextToken: Swift.String?
}

extension ListAppInstancesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appInstances = "AppInstances"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appInstancesContainer = try containerValues.decodeIfPresent([ChimeSDKIdentityClientTypes.AppInstanceSummary?].self, forKey: .appInstances)
        var appInstancesDecoded0:[ChimeSDKIdentityClientTypes.AppInstanceSummary]? = nil
        if let appInstancesContainer = appInstancesContainer {
            appInstancesDecoded0 = [ChimeSDKIdentityClientTypes.AppInstanceSummary]()
            for structure0 in appInstancesContainer {
                if let structure0 = structure0 {
                    appInstancesDecoded0?.append(structure0)
                }
            }
        }
        appInstances = appInstancesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListAppInstancesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTagsForResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let resourceARN = resourceARN else {
                let message = "Creating a URL Query Item failed. resourceARN is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let resourceARNQueryItem = ClientRuntime.URLQueryItem(name: "arn".urlPercentEncoding(), value: Swift.String(resourceARN).urlPercentEncoding())
            items.append(resourceARNQueryItem)
            return items
        }
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/tags"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The ARN of the resource.
    /// This member is required.
    public var resourceARN: Swift.String?

    public init(
        resourceARN: Swift.String? = nil
    )
    {
        self.resourceARN = resourceARN
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutput: Swift.Equatable {
    /// The tag key-value pairs.
    public var tags: [ChimeSDKIdentityClientTypes.Tag]?

    public init(
        tags: [ChimeSDKIdentityClientTypes.Tag]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputBody: Swift.Equatable {
    let tags: [ChimeSDKIdentityClientTypes.Tag]?
}

extension ListTagsForResourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([ChimeSDKIdentityClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ChimeSDKIdentityClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ChimeSDKIdentityClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum ListTagsForResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension NotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: NotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.code = output.code
            self.properties.message = output.message
        } else {
            self.properties.code = nil
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// One or more of the resources in the request does not exist in the system.
public struct NotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var code: ChimeSDKIdentityClientTypes.ErrorCode? = nil
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: ChimeSDKIdentityClientTypes.ErrorCode? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
    }
}

struct NotFoundExceptionBody: Swift.Equatable {
    let code: ChimeSDKIdentityClientTypes.ErrorCode?
    let message: Swift.String?
}

extension NotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(ChimeSDKIdentityClientTypes.ErrorCode.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension PutAppInstanceRetentionSettingsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appInstanceRetentionSettings = "AppInstanceRetentionSettings"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appInstanceRetentionSettings = self.appInstanceRetentionSettings {
            try encodeContainer.encode(appInstanceRetentionSettings, forKey: .appInstanceRetentionSettings)
        }
    }
}

extension PutAppInstanceRetentionSettingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appInstanceArn = appInstanceArn else {
            return nil
        }
        return "/app-instances/\(appInstanceArn.urlPercentEncoding())/retention-settings"
    }
}

public struct PutAppInstanceRetentionSettingsInput: Swift.Equatable {
    /// The ARN of the AppInstance.
    /// This member is required.
    public var appInstanceArn: Swift.String?
    /// The time in days to retain data. Data type: number.
    /// This member is required.
    public var appInstanceRetentionSettings: ChimeSDKIdentityClientTypes.AppInstanceRetentionSettings?

    public init(
        appInstanceArn: Swift.String? = nil,
        appInstanceRetentionSettings: ChimeSDKIdentityClientTypes.AppInstanceRetentionSettings? = nil
    )
    {
        self.appInstanceArn = appInstanceArn
        self.appInstanceRetentionSettings = appInstanceRetentionSettings
    }
}

struct PutAppInstanceRetentionSettingsInputBody: Swift.Equatable {
    let appInstanceRetentionSettings: ChimeSDKIdentityClientTypes.AppInstanceRetentionSettings?
}

extension PutAppInstanceRetentionSettingsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appInstanceRetentionSettings = "AppInstanceRetentionSettings"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appInstanceRetentionSettingsDecoded = try containerValues.decodeIfPresent(ChimeSDKIdentityClientTypes.AppInstanceRetentionSettings.self, forKey: .appInstanceRetentionSettings)
        appInstanceRetentionSettings = appInstanceRetentionSettingsDecoded
    }
}

extension PutAppInstanceRetentionSettingsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: PutAppInstanceRetentionSettingsOutputBody = try responseDecoder.decode(responseBody: data)
            self.appInstanceRetentionSettings = output.appInstanceRetentionSettings
            self.initiateDeletionTimestamp = output.initiateDeletionTimestamp
        } else {
            self.appInstanceRetentionSettings = nil
            self.initiateDeletionTimestamp = nil
        }
    }
}

public struct PutAppInstanceRetentionSettingsOutput: Swift.Equatable {
    /// The time in days to retain data. Data type: number.
    public var appInstanceRetentionSettings: ChimeSDKIdentityClientTypes.AppInstanceRetentionSettings?
    /// The time at which the API deletes data.
    public var initiateDeletionTimestamp: ClientRuntime.Date?

    public init(
        appInstanceRetentionSettings: ChimeSDKIdentityClientTypes.AppInstanceRetentionSettings? = nil,
        initiateDeletionTimestamp: ClientRuntime.Date? = nil
    )
    {
        self.appInstanceRetentionSettings = appInstanceRetentionSettings
        self.initiateDeletionTimestamp = initiateDeletionTimestamp
    }
}

struct PutAppInstanceRetentionSettingsOutputBody: Swift.Equatable {
    let appInstanceRetentionSettings: ChimeSDKIdentityClientTypes.AppInstanceRetentionSettings?
    let initiateDeletionTimestamp: ClientRuntime.Date?
}

extension PutAppInstanceRetentionSettingsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appInstanceRetentionSettings = "AppInstanceRetentionSettings"
        case initiateDeletionTimestamp = "InitiateDeletionTimestamp"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appInstanceRetentionSettingsDecoded = try containerValues.decodeIfPresent(ChimeSDKIdentityClientTypes.AppInstanceRetentionSettings.self, forKey: .appInstanceRetentionSettings)
        appInstanceRetentionSettings = appInstanceRetentionSettingsDecoded
        let initiateDeletionTimestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .initiateDeletionTimestamp)
        initiateDeletionTimestamp = initiateDeletionTimestampDecoded
    }
}

enum PutAppInstanceRetentionSettingsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension PutAppInstanceUserExpirationSettingsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case expirationSettings = "ExpirationSettings"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let expirationSettings = self.expirationSettings {
            try encodeContainer.encode(expirationSettings, forKey: .expirationSettings)
        }
    }
}

extension PutAppInstanceUserExpirationSettingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appInstanceUserArn = appInstanceUserArn else {
            return nil
        }
        return "/app-instance-users/\(appInstanceUserArn.urlPercentEncoding())/expiration-settings"
    }
}

public struct PutAppInstanceUserExpirationSettingsInput: Swift.Equatable {
    /// The ARN of the AppInstanceUser.
    /// This member is required.
    public var appInstanceUserArn: Swift.String?
    /// Settings that control the interval after which an AppInstanceUser is automatically deleted.
    public var expirationSettings: ChimeSDKIdentityClientTypes.ExpirationSettings?

    public init(
        appInstanceUserArn: Swift.String? = nil,
        expirationSettings: ChimeSDKIdentityClientTypes.ExpirationSettings? = nil
    )
    {
        self.appInstanceUserArn = appInstanceUserArn
        self.expirationSettings = expirationSettings
    }
}

struct PutAppInstanceUserExpirationSettingsInputBody: Swift.Equatable {
    let expirationSettings: ChimeSDKIdentityClientTypes.ExpirationSettings?
}

extension PutAppInstanceUserExpirationSettingsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case expirationSettings = "ExpirationSettings"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let expirationSettingsDecoded = try containerValues.decodeIfPresent(ChimeSDKIdentityClientTypes.ExpirationSettings.self, forKey: .expirationSettings)
        expirationSettings = expirationSettingsDecoded
    }
}

extension PutAppInstanceUserExpirationSettingsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: PutAppInstanceUserExpirationSettingsOutputBody = try responseDecoder.decode(responseBody: data)
            self.appInstanceUserArn = output.appInstanceUserArn
            self.expirationSettings = output.expirationSettings
        } else {
            self.appInstanceUserArn = nil
            self.expirationSettings = nil
        }
    }
}

public struct PutAppInstanceUserExpirationSettingsOutput: Swift.Equatable {
    /// The ARN of the AppInstanceUser.
    public var appInstanceUserArn: Swift.String?
    /// Settings that control the interval after which an AppInstanceUser is automatically deleted.
    public var expirationSettings: ChimeSDKIdentityClientTypes.ExpirationSettings?

    public init(
        appInstanceUserArn: Swift.String? = nil,
        expirationSettings: ChimeSDKIdentityClientTypes.ExpirationSettings? = nil
    )
    {
        self.appInstanceUserArn = appInstanceUserArn
        self.expirationSettings = expirationSettings
    }
}

struct PutAppInstanceUserExpirationSettingsOutputBody: Swift.Equatable {
    let appInstanceUserArn: Swift.String?
    let expirationSettings: ChimeSDKIdentityClientTypes.ExpirationSettings?
}

extension PutAppInstanceUserExpirationSettingsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appInstanceUserArn = "AppInstanceUserArn"
        case expirationSettings = "ExpirationSettings"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appInstanceUserArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appInstanceUserArn)
        appInstanceUserArn = appInstanceUserArnDecoded
        let expirationSettingsDecoded = try containerValues.decodeIfPresent(ChimeSDKIdentityClientTypes.ExpirationSettings.self, forKey: .expirationSettings)
        expirationSettings = expirationSettingsDecoded
    }
}

enum PutAppInstanceUserExpirationSettingsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension RegisterAppInstanceUserEndpointInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RegisterAppInstanceUserEndpointInput(allowMessages: \(Swift.String(describing: allowMessages)), clientRequestToken: \(Swift.String(describing: clientRequestToken)), endpointAttributes: \(Swift.String(describing: endpointAttributes)), resourceArn: \(Swift.String(describing: resourceArn)), type: \(Swift.String(describing: type)), appInstanceUserArn: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension RegisterAppInstanceUserEndpointInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowMessages = "AllowMessages"
        case clientRequestToken = "ClientRequestToken"
        case endpointAttributes = "EndpointAttributes"
        case name = "Name"
        case resourceArn = "ResourceArn"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowMessages = self.allowMessages {
            try encodeContainer.encode(allowMessages.rawValue, forKey: .allowMessages)
        }
        if let clientRequestToken = self.clientRequestToken {
            try encodeContainer.encode(clientRequestToken, forKey: .clientRequestToken)
        }
        if let endpointAttributes = self.endpointAttributes {
            try encodeContainer.encode(endpointAttributes, forKey: .endpointAttributes)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

extension RegisterAppInstanceUserEndpointInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appInstanceUserArn = appInstanceUserArn else {
            return nil
        }
        return "/app-instance-users/\(appInstanceUserArn.urlPercentEncoding())/endpoints"
    }
}

public struct RegisterAppInstanceUserEndpointInput: Swift.Equatable {
    /// Boolean that controls whether the AppInstanceUserEndpoint is opted in to receive messages. ALL indicates the endpoint receives all messages. NONE indicates the endpoint receives no messages.
    public var allowMessages: ChimeSDKIdentityClientTypes.AllowMessages?
    /// The ARN of the AppInstanceUser.
    /// This member is required.
    public var appInstanceUserArn: Swift.String?
    /// The unique ID assigned to the request. Use different tokens to register other endpoints.
    /// This member is required.
    public var clientRequestToken: Swift.String?
    /// The attributes of an Endpoint.
    /// This member is required.
    public var endpointAttributes: ChimeSDKIdentityClientTypes.EndpointAttributes?
    /// The name of the AppInstanceUserEndpoint.
    public var name: Swift.String?
    /// The ARN of the resource to which the endpoint belongs.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The type of the AppInstanceUserEndpoint. Supported types:
    ///
    /// * APNS: The mobile notification service for an Apple device.
    ///
    /// * APNS_SANDBOX: The sandbox environment of the mobile notification service for an Apple device.
    ///
    /// * GCM: The mobile notification service for an Android device.
    ///
    ///
    /// Populate the ResourceArn value of each type as PinpointAppArn.
    /// This member is required.
    public var type: ChimeSDKIdentityClientTypes.AppInstanceUserEndpointType?

    public init(
        allowMessages: ChimeSDKIdentityClientTypes.AllowMessages? = nil,
        appInstanceUserArn: Swift.String? = nil,
        clientRequestToken: Swift.String? = nil,
        endpointAttributes: ChimeSDKIdentityClientTypes.EndpointAttributes? = nil,
        name: Swift.String? = nil,
        resourceArn: Swift.String? = nil,
        type: ChimeSDKIdentityClientTypes.AppInstanceUserEndpointType? = nil
    )
    {
        self.allowMessages = allowMessages
        self.appInstanceUserArn = appInstanceUserArn
        self.clientRequestToken = clientRequestToken
        self.endpointAttributes = endpointAttributes
        self.name = name
        self.resourceArn = resourceArn
        self.type = type
    }
}

struct RegisterAppInstanceUserEndpointInputBody: Swift.Equatable {
    let name: Swift.String?
    let type: ChimeSDKIdentityClientTypes.AppInstanceUserEndpointType?
    let resourceArn: Swift.String?
    let endpointAttributes: ChimeSDKIdentityClientTypes.EndpointAttributes?
    let clientRequestToken: Swift.String?
    let allowMessages: ChimeSDKIdentityClientTypes.AllowMessages?
}

extension RegisterAppInstanceUserEndpointInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowMessages = "AllowMessages"
        case clientRequestToken = "ClientRequestToken"
        case endpointAttributes = "EndpointAttributes"
        case name = "Name"
        case resourceArn = "ResourceArn"
        case type = "Type"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ChimeSDKIdentityClientTypes.AppInstanceUserEndpointType.self, forKey: .type)
        type = typeDecoded
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let endpointAttributesDecoded = try containerValues.decodeIfPresent(ChimeSDKIdentityClientTypes.EndpointAttributes.self, forKey: .endpointAttributes)
        endpointAttributes = endpointAttributesDecoded
        let clientRequestTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientRequestToken)
        clientRequestToken = clientRequestTokenDecoded
        let allowMessagesDecoded = try containerValues.decodeIfPresent(ChimeSDKIdentityClientTypes.AllowMessages.self, forKey: .allowMessages)
        allowMessages = allowMessagesDecoded
    }
}

extension RegisterAppInstanceUserEndpointOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: RegisterAppInstanceUserEndpointOutputBody = try responseDecoder.decode(responseBody: data)
            self.appInstanceUserArn = output.appInstanceUserArn
            self.endpointId = output.endpointId
        } else {
            self.appInstanceUserArn = nil
            self.endpointId = nil
        }
    }
}

public struct RegisterAppInstanceUserEndpointOutput: Swift.Equatable {
    /// The ARN of the AppInstanceUser.
    public var appInstanceUserArn: Swift.String?
    /// The unique identifier of the AppInstanceUserEndpoint.
    public var endpointId: Swift.String?

    public init(
        appInstanceUserArn: Swift.String? = nil,
        endpointId: Swift.String? = nil
    )
    {
        self.appInstanceUserArn = appInstanceUserArn
        self.endpointId = endpointId
    }
}

struct RegisterAppInstanceUserEndpointOutputBody: Swift.Equatable {
    let appInstanceUserArn: Swift.String?
    let endpointId: Swift.String?
}

extension RegisterAppInstanceUserEndpointOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appInstanceUserArn = "AppInstanceUserArn"
        case endpointId = "EndpointId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appInstanceUserArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appInstanceUserArn)
        appInstanceUserArn = appInstanceUserArnDecoded
        let endpointIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointId)
        endpointId = endpointIdDecoded
    }
}

enum RegisterAppInstanceUserEndpointOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceLimitExceededException": return try await ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ResourceLimitExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceLimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.code = output.code
            self.properties.message = output.message
        } else {
            self.properties.code = nil
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request exceeds the resource limit.
public struct ResourceLimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var code: ChimeSDKIdentityClientTypes.ErrorCode? = nil
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceLimitExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: ChimeSDKIdentityClientTypes.ErrorCode? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
    }
}

struct ResourceLimitExceededExceptionBody: Swift.Equatable {
    let code: ChimeSDKIdentityClientTypes.ErrorCode?
    let message: Swift.String?
}

extension ResourceLimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(ChimeSDKIdentityClientTypes.ErrorCode.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ChimeSDKIdentityClientTypes {
    public enum RespondsTo: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case standardMessages
        case sdkUnknown(Swift.String)

        public static var allCases: [RespondsTo] {
            return [
                .standardMessages,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .standardMessages: return "STANDARD_MESSAGES"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RespondsTo(rawValue: rawValue) ?? RespondsTo.sdkUnknown(rawValue)
        }
    }
}

extension ServiceFailureException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ServiceFailureExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.code = output.code
            self.properties.message = output.message
        } else {
            self.properties.code = nil
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The service encountered an unexpected error.
public struct ServiceFailureException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var code: ChimeSDKIdentityClientTypes.ErrorCode? = nil
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceFailureException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: ChimeSDKIdentityClientTypes.ErrorCode? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
    }
}

struct ServiceFailureExceptionBody: Swift.Equatable {
    let code: ChimeSDKIdentityClientTypes.ErrorCode?
    let message: Swift.String?
}

extension ServiceFailureExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(ChimeSDKIdentityClientTypes.ErrorCode.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ServiceUnavailableException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ServiceUnavailableExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.code = output.code
            self.properties.message = output.message
        } else {
            self.properties.code = nil
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The service is currently unavailable.
public struct ServiceUnavailableException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var code: ChimeSDKIdentityClientTypes.ErrorCode? = nil
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceUnavailableException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: ChimeSDKIdentityClientTypes.ErrorCode? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
    }
}

struct ServiceUnavailableExceptionBody: Swift.Equatable {
    let code: ChimeSDKIdentityClientTypes.ErrorCode?
    let message: Swift.String?
}

extension ServiceUnavailableExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(ChimeSDKIdentityClientTypes.ErrorCode.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ChimeSDKIdentityClientTypes {
    public enum StandardMessages: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case all
        case auto
        case mentions
        case `none`
        case sdkUnknown(Swift.String)

        public static var allCases: [StandardMessages] {
            return [
                .all,
                .auto,
                .mentions,
                .none,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .all: return "ALL"
            case .auto: return "AUTO"
            case .mentions: return "MENTIONS"
            case .none: return "NONE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = StandardMessages(rawValue: rawValue) ?? StandardMessages.sdkUnknown(rawValue)
        }
    }
}

extension ChimeSDKIdentityClientTypes.Tag: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension ChimeSDKIdentityClientTypes.Tag: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Tag(key: \"CONTENT_REDACTED\", value: \"CONTENT_REDACTED\")"}
}

extension ChimeSDKIdentityClientTypes {
    /// A tag object containing a key-value pair.
    public struct Tag: Swift.Equatable {
        /// The key in a tag.
        /// This member is required.
        public var key: Swift.String?
        /// The value in a tag.
        /// This member is required.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = self.resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            items.append(ClientRuntime.URLQueryItem(name: "operation", value: "tag-resource"))
            return items
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/tags"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The resource ARN.
    /// This member is required.
    public var resourceARN: Swift.String?
    /// The tag key-value pairs.
    /// This member is required.
    public var tags: [ChimeSDKIdentityClientTypes.Tag]?

    public init(
        resourceARN: Swift.String? = nil,
        tags: [ChimeSDKIdentityClientTypes.Tag]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let resourceARN: Swift.String?
    let tags: [ChimeSDKIdentityClientTypes.Tag]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let tagsContainer = try containerValues.decodeIfPresent([ChimeSDKIdentityClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ChimeSDKIdentityClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ChimeSDKIdentityClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct TagResourceOutput: Swift.Equatable {

    public init() { }
}

enum TagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceLimitExceededException": return try await ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ChimeSDKIdentityClientTypes {
    public enum TargetedMessages: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case all
        case `none`
        case sdkUnknown(Swift.String)

        public static var allCases: [TargetedMessages] {
            return [
                .all,
                .none,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .all: return "ALL"
            case .none: return "NONE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TargetedMessages(rawValue: rawValue) ?? TargetedMessages.sdkUnknown(rawValue)
        }
    }
}

extension ThrottledClientException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ThrottledClientExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.code = output.code
            self.properties.message = output.message
        } else {
            self.properties.code = nil
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The client exceeded its request rate limit.
public struct ThrottledClientException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var code: ChimeSDKIdentityClientTypes.ErrorCode? = nil
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottledClientException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: ChimeSDKIdentityClientTypes.ErrorCode? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
    }
}

struct ThrottledClientExceptionBody: Swift.Equatable {
    let code: ChimeSDKIdentityClientTypes.ErrorCode?
    let message: Swift.String?
}

extension ThrottledClientExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(ChimeSDKIdentityClientTypes.ErrorCode.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UnauthorizedClientException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UnauthorizedClientExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.code = output.code
            self.properties.message = output.message
        } else {
            self.properties.code = nil
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The client is not currently authorized to make the request.
public struct UnauthorizedClientException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var code: ChimeSDKIdentityClientTypes.ErrorCode? = nil
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "UnauthorizedClientException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: ChimeSDKIdentityClientTypes.ErrorCode? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
    }
}

struct UnauthorizedClientExceptionBody: Swift.Equatable {
    let code: ChimeSDKIdentityClientTypes.ErrorCode?
    let message: Swift.String?
}

extension UnauthorizedClientExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "Code"
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(ChimeSDKIdentityClientTypes.ErrorCode.self, forKey: .code)
        code = codeDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UntagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tagKeys = "TagKeys"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceARN = self.resourceARN {
            try encodeContainer.encode(resourceARN, forKey: .resourceARN)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkey0 in tagKeys {
                try tagKeysContainer.encode(tagkey0)
            }
        }
    }
}

extension UntagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            items.append(ClientRuntime.URLQueryItem(name: "operation", value: "untag-resource"))
            return items
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/tags"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The resource ARN.
    /// This member is required.
    public var resourceARN: Swift.String?
    /// The tag keys.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceARN: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
    let resourceARN: Swift.String?
    let tagKeys: [Swift.String]?
}

extension UntagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceARN = "ResourceARN"
        case tagKeys = "TagKeys"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceARNDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceARN)
        resourceARN = resourceARNDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[Swift.String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [Swift.String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension UntagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UntagResourceOutput: Swift.Equatable {

    public init() { }
}

enum UntagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateAppInstanceBotInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateAppInstanceBotInput(appInstanceBotArn: \(Swift.String(describing: appInstanceBotArn)), configuration: \(Swift.String(describing: configuration)), metadata: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension UpdateAppInstanceBotInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configuration = "Configuration"
        case metadata = "Metadata"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let configuration = self.configuration {
            try encodeContainer.encode(configuration, forKey: .configuration)
        }
        if let metadata = self.metadata {
            try encodeContainer.encode(metadata, forKey: .metadata)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension UpdateAppInstanceBotInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appInstanceBotArn = appInstanceBotArn else {
            return nil
        }
        return "/app-instance-bots/\(appInstanceBotArn.urlPercentEncoding())"
    }
}

public struct UpdateAppInstanceBotInput: Swift.Equatable {
    /// The ARN of the AppInstanceBot.
    /// This member is required.
    public var appInstanceBotArn: Swift.String?
    /// The configuration for the bot update.
    public var configuration: ChimeSDKIdentityClientTypes.Configuration?
    /// The metadata of the AppInstanceBot.
    /// This member is required.
    public var metadata: Swift.String?
    /// The name of the AppInstanceBot.
    /// This member is required.
    public var name: Swift.String?

    public init(
        appInstanceBotArn: Swift.String? = nil,
        configuration: ChimeSDKIdentityClientTypes.Configuration? = nil,
        metadata: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.appInstanceBotArn = appInstanceBotArn
        self.configuration = configuration
        self.metadata = metadata
        self.name = name
    }
}

struct UpdateAppInstanceBotInputBody: Swift.Equatable {
    let name: Swift.String?
    let metadata: Swift.String?
    let configuration: ChimeSDKIdentityClientTypes.Configuration?
}

extension UpdateAppInstanceBotInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case configuration = "Configuration"
        case metadata = "Metadata"
        case name = "Name"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let metadataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metadata)
        metadata = metadataDecoded
        let configurationDecoded = try containerValues.decodeIfPresent(ChimeSDKIdentityClientTypes.Configuration.self, forKey: .configuration)
        configuration = configurationDecoded
    }
}

extension UpdateAppInstanceBotOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateAppInstanceBotOutputBody = try responseDecoder.decode(responseBody: data)
            self.appInstanceBotArn = output.appInstanceBotArn
        } else {
            self.appInstanceBotArn = nil
        }
    }
}

public struct UpdateAppInstanceBotOutput: Swift.Equatable {
    /// The ARN of the AppInstanceBot.
    public var appInstanceBotArn: Swift.String?

    public init(
        appInstanceBotArn: Swift.String? = nil
    )
    {
        self.appInstanceBotArn = appInstanceBotArn
    }
}

struct UpdateAppInstanceBotOutputBody: Swift.Equatable {
    let appInstanceBotArn: Swift.String?
}

extension UpdateAppInstanceBotOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appInstanceBotArn = "AppInstanceBotArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appInstanceBotArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appInstanceBotArn)
        appInstanceBotArn = appInstanceBotArnDecoded
    }
}

enum UpdateAppInstanceBotOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceLimitExceededException": return try await ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateAppInstanceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateAppInstanceInput(appInstanceArn: \(Swift.String(describing: appInstanceArn)), metadata: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension UpdateAppInstanceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case metadata = "Metadata"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let metadata = self.metadata {
            try encodeContainer.encode(metadata, forKey: .metadata)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension UpdateAppInstanceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appInstanceArn = appInstanceArn else {
            return nil
        }
        return "/app-instances/\(appInstanceArn.urlPercentEncoding())"
    }
}

public struct UpdateAppInstanceInput: Swift.Equatable {
    /// The ARN of the AppInstance.
    /// This member is required.
    public var appInstanceArn: Swift.String?
    /// The metadata that you want to change.
    /// This member is required.
    public var metadata: Swift.String?
    /// The name that you want to change.
    /// This member is required.
    public var name: Swift.String?

    public init(
        appInstanceArn: Swift.String? = nil,
        metadata: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.appInstanceArn = appInstanceArn
        self.metadata = metadata
        self.name = name
    }
}

struct UpdateAppInstanceInputBody: Swift.Equatable {
    let name: Swift.String?
    let metadata: Swift.String?
}

extension UpdateAppInstanceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case metadata = "Metadata"
        case name = "Name"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let metadataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metadata)
        metadata = metadataDecoded
    }
}

extension UpdateAppInstanceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateAppInstanceOutputBody = try responseDecoder.decode(responseBody: data)
            self.appInstanceArn = output.appInstanceArn
        } else {
            self.appInstanceArn = nil
        }
    }
}

public struct UpdateAppInstanceOutput: Swift.Equatable {
    /// The ARN of the AppInstance.
    public var appInstanceArn: Swift.String?

    public init(
        appInstanceArn: Swift.String? = nil
    )
    {
        self.appInstanceArn = appInstanceArn
    }
}

struct UpdateAppInstanceOutputBody: Swift.Equatable {
    let appInstanceArn: Swift.String?
}

extension UpdateAppInstanceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appInstanceArn = "AppInstanceArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appInstanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appInstanceArn)
        appInstanceArn = appInstanceArnDecoded
    }
}

enum UpdateAppInstanceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateAppInstanceUserEndpointInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateAppInstanceUserEndpointInput(allowMessages: \(Swift.String(describing: allowMessages)), appInstanceUserArn: \(Swift.String(describing: appInstanceUserArn)), endpointId: \(Swift.String(describing: endpointId)), name: \"CONTENT_REDACTED\")"}
}

extension UpdateAppInstanceUserEndpointInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowMessages = "AllowMessages"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let allowMessages = self.allowMessages {
            try encodeContainer.encode(allowMessages.rawValue, forKey: .allowMessages)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension UpdateAppInstanceUserEndpointInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appInstanceUserArn = appInstanceUserArn else {
            return nil
        }
        guard let endpointId = endpointId else {
            return nil
        }
        return "/app-instance-users/\(appInstanceUserArn.urlPercentEncoding())/endpoints/\(endpointId.urlPercentEncoding())"
    }
}

public struct UpdateAppInstanceUserEndpointInput: Swift.Equatable {
    /// Boolean that controls whether the AppInstanceUserEndpoint is opted in to receive messages. ALL indicates the endpoint will receive all messages. NONE indicates the endpoint will receive no messages.
    public var allowMessages: ChimeSDKIdentityClientTypes.AllowMessages?
    /// The ARN of the AppInstanceUser.
    /// This member is required.
    public var appInstanceUserArn: Swift.String?
    /// The unique identifier of the AppInstanceUserEndpoint.
    /// This member is required.
    public var endpointId: Swift.String?
    /// The name of the AppInstanceUserEndpoint.
    public var name: Swift.String?

    public init(
        allowMessages: ChimeSDKIdentityClientTypes.AllowMessages? = nil,
        appInstanceUserArn: Swift.String? = nil,
        endpointId: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.allowMessages = allowMessages
        self.appInstanceUserArn = appInstanceUserArn
        self.endpointId = endpointId
        self.name = name
    }
}

struct UpdateAppInstanceUserEndpointInputBody: Swift.Equatable {
    let name: Swift.String?
    let allowMessages: ChimeSDKIdentityClientTypes.AllowMessages?
}

extension UpdateAppInstanceUserEndpointInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowMessages = "AllowMessages"
        case name = "Name"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let allowMessagesDecoded = try containerValues.decodeIfPresent(ChimeSDKIdentityClientTypes.AllowMessages.self, forKey: .allowMessages)
        allowMessages = allowMessagesDecoded
    }
}

extension UpdateAppInstanceUserEndpointOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateAppInstanceUserEndpointOutputBody = try responseDecoder.decode(responseBody: data)
            self.appInstanceUserArn = output.appInstanceUserArn
            self.endpointId = output.endpointId
        } else {
            self.appInstanceUserArn = nil
            self.endpointId = nil
        }
    }
}

public struct UpdateAppInstanceUserEndpointOutput: Swift.Equatable {
    /// The ARN of the AppInstanceUser.
    public var appInstanceUserArn: Swift.String?
    /// The unique identifier of the AppInstanceUserEndpoint.
    public var endpointId: Swift.String?

    public init(
        appInstanceUserArn: Swift.String? = nil,
        endpointId: Swift.String? = nil
    )
    {
        self.appInstanceUserArn = appInstanceUserArn
        self.endpointId = endpointId
    }
}

struct UpdateAppInstanceUserEndpointOutputBody: Swift.Equatable {
    let appInstanceUserArn: Swift.String?
    let endpointId: Swift.String?
}

extension UpdateAppInstanceUserEndpointOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appInstanceUserArn = "AppInstanceUserArn"
        case endpointId = "EndpointId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appInstanceUserArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appInstanceUserArn)
        appInstanceUserArn = appInstanceUserArnDecoded
        let endpointIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endpointId)
        endpointId = endpointIdDecoded
    }
}

enum UpdateAppInstanceUserEndpointOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateAppInstanceUserInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateAppInstanceUserInput(appInstanceUserArn: \(Swift.String(describing: appInstanceUserArn)), metadata: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension UpdateAppInstanceUserInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case metadata = "Metadata"
        case name = "Name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let metadata = self.metadata {
            try encodeContainer.encode(metadata, forKey: .metadata)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension UpdateAppInstanceUserInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let appInstanceUserArn = appInstanceUserArn else {
            return nil
        }
        return "/app-instance-users/\(appInstanceUserArn.urlPercentEncoding())"
    }
}

public struct UpdateAppInstanceUserInput: Swift.Equatable {
    /// The ARN of the AppInstanceUser.
    /// This member is required.
    public var appInstanceUserArn: Swift.String?
    /// The metadata of the AppInstanceUser.
    /// This member is required.
    public var metadata: Swift.String?
    /// The name of the AppInstanceUser.
    /// This member is required.
    public var name: Swift.String?

    public init(
        appInstanceUserArn: Swift.String? = nil,
        metadata: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.appInstanceUserArn = appInstanceUserArn
        self.metadata = metadata
        self.name = name
    }
}

struct UpdateAppInstanceUserInputBody: Swift.Equatable {
    let name: Swift.String?
    let metadata: Swift.String?
}

extension UpdateAppInstanceUserInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case metadata = "Metadata"
        case name = "Name"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let metadataDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metadata)
        metadata = metadataDecoded
    }
}

extension UpdateAppInstanceUserOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateAppInstanceUserOutputBody = try responseDecoder.decode(responseBody: data)
            self.appInstanceUserArn = output.appInstanceUserArn
        } else {
            self.appInstanceUserArn = nil
        }
    }
}

public struct UpdateAppInstanceUserOutput: Swift.Equatable {
    /// The ARN of the AppInstanceUser.
    public var appInstanceUserArn: Swift.String?

    public init(
        appInstanceUserArn: Swift.String? = nil
    )
    {
        self.appInstanceUserArn = appInstanceUserArn
    }
}

struct UpdateAppInstanceUserOutputBody: Swift.Equatable {
    let appInstanceUserArn: Swift.String?
}

extension UpdateAppInstanceUserOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appInstanceUserArn = "AppInstanceUserArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let appInstanceUserArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .appInstanceUserArn)
        appInstanceUserArn = appInstanceUserArnDecoded
    }
}

enum UpdateAppInstanceUserOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ForbiddenException": return try await ForbiddenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceLimitExceededException": return try await ResourceLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceFailureException": return try await ServiceFailureException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceUnavailableException": return try await ServiceUnavailableException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottledClientException": return try await ThrottledClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnauthorizedClientException": return try await UnauthorizedClientException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}
