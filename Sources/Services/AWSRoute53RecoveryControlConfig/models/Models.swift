// Code generated by smithy-swift-codegen. DO NOT EDIT!
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
import AWSClientRuntime
import ClientRuntime
import SmithyJSON
import SmithyReadWrite

extension AccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> AccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = AccessDeniedException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// 403 response - You do not have sufficient access to perform this action.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension Route53RecoveryControlConfigClientTypes.AssertionRule {

    static func read(from reader: SmithyJSON.Reader) throws -> Route53RecoveryControlConfigClientTypes.AssertionRule {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = Route53RecoveryControlConfigClientTypes.AssertionRule()
        value.assertedControls = try reader["AssertedControls"].readListIfPresent(memberReadingClosure: Swift.String.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.controlPanelArn = try reader["ControlPanelArn"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.ruleConfig = try reader["RuleConfig"].readIfPresent(with: Route53RecoveryControlConfigClientTypes.RuleConfig.read(from:))
        value.safetyRuleArn = try reader["SafetyRuleArn"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.waitPeriodMs = try reader["WaitPeriodMs"].readIfPresent()
        value.owner = try reader["Owner"].readIfPresent()
        return value
    }
}

extension Route53RecoveryControlConfigClientTypes {
    /// An assertion rule enforces that, when you change a routing control state, that the criteria that you set in the rule configuration is met. Otherwise, the change to the routing control is not accepted. For example, the criteria might be that at least one routing control state is On after the transaction so that traffic continues to flow to at least one cell for the application. This ensures that you avoid a fail-open scenario.
    public struct AssertionRule {
        /// The routing controls that are part of transactions that are evaluated to determine if a request to change a routing control state is allowed. For example, you might include three routing controls, one for each of three Amazon Web Services Regions.
        /// This member is required.
        public var assertedControls: [Swift.String]?
        /// The Amazon Resource Name (ARN) of the control panel.
        /// This member is required.
        public var controlPanelArn: Swift.String?
        /// Name of the assertion rule. You can use any non-white space character in the name.
        /// This member is required.
        public var name: Swift.String?
        /// The Amazon Web Services account ID of the assertion rule owner.
        public var owner: Swift.String?
        /// The criteria that you set for specific assertion routing controls (AssertedControls) that designate how many routing control states must be ON as the result of a transaction. For example, if you have three assertion routing controls, you might specify ATLEAST 2 for your rule configuration. This means that at least two assertion routing control states must be ON, so that at least two Amazon Web Services Regions have traffic flowing to them.
        /// This member is required.
        public var ruleConfig: Route53RecoveryControlConfigClientTypes.RuleConfig?
        /// The Amazon Resource Name (ARN) of the assertion rule.
        /// This member is required.
        public var safetyRuleArn: Swift.String?
        /// The deployment status of an assertion rule. Status can be one of the following: PENDING, DEPLOYED, PENDING_DELETION.
        /// This member is required.
        public var status: Route53RecoveryControlConfigClientTypes.Status?
        /// An evaluation period, in milliseconds (ms), during which any request against the target routing controls will fail. This helps prevent "flapping" of state. The wait period is 5000 ms by default, but you can choose a custom value.
        /// This member is required.
        public var waitPeriodMs: Swift.Int?

        public init(
            assertedControls: [Swift.String]? = nil,
            controlPanelArn: Swift.String? = nil,
            name: Swift.String? = nil,
            owner: Swift.String? = nil,
            ruleConfig: Route53RecoveryControlConfigClientTypes.RuleConfig? = nil,
            safetyRuleArn: Swift.String? = nil,
            status: Route53RecoveryControlConfigClientTypes.Status? = nil,
            waitPeriodMs: Swift.Int? = nil
        )
        {
            self.assertedControls = assertedControls
            self.controlPanelArn = controlPanelArn
            self.name = name
            self.owner = owner
            self.ruleConfig = ruleConfig
            self.safetyRuleArn = safetyRuleArn
            self.status = status
            self.waitPeriodMs = waitPeriodMs
        }
    }

}

extension Route53RecoveryControlConfigClientTypes.AssertionRuleUpdate {

    static func write(value: Route53RecoveryControlConfigClientTypes.AssertionRuleUpdate?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
        try writer["SafetyRuleArn"].write(value.safetyRuleArn)
        try writer["WaitPeriodMs"].write(value.waitPeriodMs)
    }
}

extension Route53RecoveryControlConfigClientTypes {
    /// An update to an assertion rule. You can update the name or the evaluation period (wait period). If you don't specify one of the items to update, the item is unchanged.
    public struct AssertionRuleUpdate {
        /// The name of the assertion rule. You can use any non-white space character in the name.
        /// This member is required.
        public var name: Swift.String?
        /// The Amazon Resource Name (ARN) of the assertion rule.
        /// This member is required.
        public var safetyRuleArn: Swift.String?
        /// An evaluation period, in milliseconds (ms), during which any request against the target routing controls will fail. This helps prevent "flapping" of state. The wait period is 5000 ms by default, but you can choose a custom value.
        /// This member is required.
        public var waitPeriodMs: Swift.Int?

        public init(
            name: Swift.String? = nil,
            safetyRuleArn: Swift.String? = nil,
            waitPeriodMs: Swift.Int? = nil
        )
        {
            self.name = name
            self.safetyRuleArn = safetyRuleArn
            self.waitPeriodMs = waitPeriodMs
        }
    }

}

extension Route53RecoveryControlConfigClientTypes.Cluster {

    static func read(from reader: SmithyJSON.Reader) throws -> Route53RecoveryControlConfigClientTypes.Cluster {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = Route53RecoveryControlConfigClientTypes.Cluster()
        value.clusterArn = try reader["ClusterArn"].readIfPresent()
        value.clusterEndpoints = try reader["ClusterEndpoints"].readListIfPresent(memberReadingClosure: Route53RecoveryControlConfigClientTypes.ClusterEndpoint.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.name = try reader["Name"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.owner = try reader["Owner"].readIfPresent()
        return value
    }
}

extension Route53RecoveryControlConfigClientTypes {
    /// A set of five redundant Regional endpoints against which you can execute API calls to update or get the state of routing controls. You can host multiple control panels and routing controls on one cluster.
    public struct Cluster {
        /// The Amazon Resource Name (ARN) of the cluster.
        public var clusterArn: Swift.String?
        /// Endpoints for a cluster. Specify one of these endpoints when you want to set or retrieve a routing control state in the cluster. To get or update the routing control state, see the Amazon Route 53 Application Recovery Controller Routing Control Actions.
        public var clusterEndpoints: [Route53RecoveryControlConfigClientTypes.ClusterEndpoint]?
        /// The name of the cluster.
        public var name: Swift.String?
        /// The Amazon Web Services account ID of the cluster owner.
        public var owner: Swift.String?
        /// Deployment status of a resource. Status can be one of the following: PENDING, DEPLOYED, PENDING_DELETION.
        public var status: Route53RecoveryControlConfigClientTypes.Status?

        public init(
            clusterArn: Swift.String? = nil,
            clusterEndpoints: [Route53RecoveryControlConfigClientTypes.ClusterEndpoint]? = nil,
            name: Swift.String? = nil,
            owner: Swift.String? = nil,
            status: Route53RecoveryControlConfigClientTypes.Status? = nil
        )
        {
            self.clusterArn = clusterArn
            self.clusterEndpoints = clusterEndpoints
            self.name = name
            self.owner = owner
            self.status = status
        }
    }

}

extension Route53RecoveryControlConfigClientTypes.ClusterEndpoint {

    static func read(from reader: SmithyJSON.Reader) throws -> Route53RecoveryControlConfigClientTypes.ClusterEndpoint {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = Route53RecoveryControlConfigClientTypes.ClusterEndpoint()
        value.endpoint = try reader["Endpoint"].readIfPresent()
        value.region = try reader["Region"].readIfPresent()
        return value
    }
}

extension Route53RecoveryControlConfigClientTypes {
    /// A cluster endpoint. Specify an endpoint when you want to set or retrieve a routing control state in the cluster.
    public struct ClusterEndpoint {
        /// A cluster endpoint. Specify an endpoint and Amazon Web Services Region when you want to set or retrieve a routing control state in the cluster. To get or update the routing control state, see the Amazon Route 53 Application Recovery Controller Routing Control Actions.
        public var endpoint: Swift.String?
        /// The Amazon Web Services Region for a cluster endpoint.
        public var region: Swift.String?

        public init(
            endpoint: Swift.String? = nil,
            region: Swift.String? = nil
        )
        {
            self.endpoint = endpoint
            self.region = region
        }
    }

}

extension ConflictException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ConflictException {
        let reader = baseError.errorBodyReader
        var value = ConflictException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// 409 response - ConflictException. You might be using a predefined variable.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension Route53RecoveryControlConfigClientTypes.ControlPanel {

    static func read(from reader: SmithyJSON.Reader) throws -> Route53RecoveryControlConfigClientTypes.ControlPanel {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = Route53RecoveryControlConfigClientTypes.ControlPanel()
        value.clusterArn = try reader["ClusterArn"].readIfPresent()
        value.controlPanelArn = try reader["ControlPanelArn"].readIfPresent()
        value.defaultControlPanel = try reader["DefaultControlPanel"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.routingControlCount = try reader["RoutingControlCount"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.owner = try reader["Owner"].readIfPresent()
        return value
    }
}

extension Route53RecoveryControlConfigClientTypes {
    /// A control panel represents a group of routing controls that can be changed together in a single transaction.
    public struct ControlPanel {
        /// The Amazon Resource Name (ARN) of the cluster that includes the control panel.
        public var clusterArn: Swift.String?
        /// The Amazon Resource Name (ARN) of the control panel.
        public var controlPanelArn: Swift.String?
        /// A flag that Amazon Route 53 Application Recovery Controller sets to true to designate the default control panel for a cluster. When you create a cluster, Amazon Route 53 Application Recovery Controller creates a control panel, and sets this flag for that control panel. If you create a control panel yourself, this flag is set to false.
        public var defaultControlPanel: Swift.Bool?
        /// The name of the control panel. You can use any non-white space character in the name.
        public var name: Swift.String?
        /// The Amazon Web Services account ID of the control panel owner.
        public var owner: Swift.String?
        /// The number of routing controls in the control panel.
        public var routingControlCount: Swift.Int?
        /// The deployment status of control panel. Status can be one of the following: PENDING, DEPLOYED, PENDING_DELETION.
        public var status: Route53RecoveryControlConfigClientTypes.Status?

        public init(
            clusterArn: Swift.String? = nil,
            controlPanelArn: Swift.String? = nil,
            defaultControlPanel: Swift.Bool? = nil,
            name: Swift.String? = nil,
            owner: Swift.String? = nil,
            routingControlCount: Swift.Int? = nil,
            status: Route53RecoveryControlConfigClientTypes.Status? = nil
        )
        {
            self.clusterArn = clusterArn
            self.controlPanelArn = controlPanelArn
            self.defaultControlPanel = defaultControlPanel
            self.name = name
            self.owner = owner
            self.routingControlCount = routingControlCount
            self.status = status
        }
    }

}

extension CreateClusterInput {

    static func urlPathProvider(_ value: CreateClusterInput) -> Swift.String? {
        return "/cluster"
    }
}

extension CreateClusterInput {

    static func write(value: CreateClusterInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClientToken"].write(value.clientToken)
        try writer["ClusterName"].write(value.clusterName)
        try writer["Tags"].writeMap(value.tags, valueWritingClosure: Swift.String.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

/// Creates a cluster.
public struct CreateClusterInput {
    /// A unique, case-sensitive string of up to 64 ASCII characters. To make an idempotent API request with an action, specify a client token in the request.
    public var clientToken: Swift.String?
    /// The name of the cluster.
    /// This member is required.
    public var clusterName: Swift.String?
    /// The tags associated with the cluster.
    public var tags: [Swift.String:Swift.String]?

    public init(
        clientToken: Swift.String? = nil,
        clusterName: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.clientToken = clientToken
        self.clusterName = clusterName
        self.tags = tags
    }
}

extension CreateClusterOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> CreateClusterOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateClusterOutput()
        value.cluster = try reader["Cluster"].readIfPresent(with: Route53RecoveryControlConfigClientTypes.Cluster.read(from:))
        return value
    }
}

public struct CreateClusterOutput {
    /// The cluster that was created.
    public var cluster: Route53RecoveryControlConfigClientTypes.Cluster?

    public init(
        cluster: Route53RecoveryControlConfigClientTypes.Cluster? = nil
    )
    {
        self.cluster = cluster
    }
}

enum CreateClusterOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension CreateControlPanelInput {

    static func urlPathProvider(_ value: CreateControlPanelInput) -> Swift.String? {
        return "/controlpanel"
    }
}

extension CreateControlPanelInput {

    static func write(value: CreateControlPanelInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClientToken"].write(value.clientToken)
        try writer["ClusterArn"].write(value.clusterArn)
        try writer["ControlPanelName"].write(value.controlPanelName)
        try writer["Tags"].writeMap(value.tags, valueWritingClosure: Swift.String.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

/// The details of the control panel that you're creating.
public struct CreateControlPanelInput {
    /// A unique, case-sensitive string of up to 64 ASCII characters. To make an idempotent API request with an action, specify a client token in the request.
    public var clientToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the cluster for the control panel.
    /// This member is required.
    public var clusterArn: Swift.String?
    /// The name of the control panel.
    /// This member is required.
    public var controlPanelName: Swift.String?
    /// The tags associated with the control panel.
    public var tags: [Swift.String:Swift.String]?

    public init(
        clientToken: Swift.String? = nil,
        clusterArn: Swift.String? = nil,
        controlPanelName: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.clientToken = clientToken
        self.clusterArn = clusterArn
        self.controlPanelName = controlPanelName
        self.tags = tags
    }
}

extension CreateControlPanelOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> CreateControlPanelOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateControlPanelOutput()
        value.controlPanel = try reader["ControlPanel"].readIfPresent(with: Route53RecoveryControlConfigClientTypes.ControlPanel.read(from:))
        return value
    }
}

public struct CreateControlPanelOutput {
    /// Information about a control panel.
    public var controlPanel: Route53RecoveryControlConfigClientTypes.ControlPanel?

    public init(
        controlPanel: Route53RecoveryControlConfigClientTypes.ControlPanel? = nil
    )
    {
        self.controlPanel = controlPanel
    }
}

enum CreateControlPanelOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension CreateRoutingControlInput {

    static func urlPathProvider(_ value: CreateRoutingControlInput) -> Swift.String? {
        return "/routingcontrol"
    }
}

extension CreateRoutingControlInput {

    static func write(value: CreateRoutingControlInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClientToken"].write(value.clientToken)
        try writer["ClusterArn"].write(value.clusterArn)
        try writer["ControlPanelArn"].write(value.controlPanelArn)
        try writer["RoutingControlName"].write(value.routingControlName)
    }
}

/// The details of the routing control that you're creating.
public struct CreateRoutingControlInput {
    /// A unique, case-sensitive string of up to 64 ASCII characters. To make an idempotent API request with an action, specify a client token in the request.
    public var clientToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the cluster that includes the routing control.
    /// This member is required.
    public var clusterArn: Swift.String?
    /// The Amazon Resource Name (ARN) of the control panel that includes the routing control.
    public var controlPanelArn: Swift.String?
    /// The name of the routing control.
    /// This member is required.
    public var routingControlName: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        clusterArn: Swift.String? = nil,
        controlPanelArn: Swift.String? = nil,
        routingControlName: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.clusterArn = clusterArn
        self.controlPanelArn = controlPanelArn
        self.routingControlName = routingControlName
    }
}

extension CreateRoutingControlOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> CreateRoutingControlOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateRoutingControlOutput()
        value.routingControl = try reader["RoutingControl"].readIfPresent(with: Route53RecoveryControlConfigClientTypes.RoutingControl.read(from:))
        return value
    }
}

public struct CreateRoutingControlOutput {
    /// The routing control that is created.
    public var routingControl: Route53RecoveryControlConfigClientTypes.RoutingControl?

    public init(
        routingControl: Route53RecoveryControlConfigClientTypes.RoutingControl? = nil
    )
    {
        self.routingControl = routingControl
    }
}

enum CreateRoutingControlOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension CreateSafetyRuleInput {

    static func urlPathProvider(_ value: CreateSafetyRuleInput) -> Swift.String? {
        return "/safetyrule"
    }
}

extension CreateSafetyRuleInput {

    static func write(value: CreateSafetyRuleInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AssertionRule"].write(value.assertionRule, with: Route53RecoveryControlConfigClientTypes.NewAssertionRule.write(value:to:))
        try writer["ClientToken"].write(value.clientToken)
        try writer["GatingRule"].write(value.gatingRule, with: Route53RecoveryControlConfigClientTypes.NewGatingRule.write(value:to:))
        try writer["Tags"].writeMap(value.tags, valueWritingClosure: Swift.String.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

/// The request body that you include when you create a safety rule.
public struct CreateSafetyRuleInput {
    /// The assertion rule requested.
    public var assertionRule: Route53RecoveryControlConfigClientTypes.NewAssertionRule?
    /// A unique, case-sensitive string of up to 64 ASCII characters. To make an idempotent API request with an action, specify a client token in the request.
    public var clientToken: Swift.String?
    /// The gating rule requested.
    public var gatingRule: Route53RecoveryControlConfigClientTypes.NewGatingRule?
    /// The tags associated with the safety rule.
    public var tags: [Swift.String:Swift.String]?

    public init(
        assertionRule: Route53RecoveryControlConfigClientTypes.NewAssertionRule? = nil,
        clientToken: Swift.String? = nil,
        gatingRule: Route53RecoveryControlConfigClientTypes.NewGatingRule? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.assertionRule = assertionRule
        self.clientToken = clientToken
        self.gatingRule = gatingRule
        self.tags = tags
    }
}

extension CreateSafetyRuleOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> CreateSafetyRuleOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateSafetyRuleOutput()
        value.assertionRule = try reader["AssertionRule"].readIfPresent(with: Route53RecoveryControlConfigClientTypes.AssertionRule.read(from:))
        value.gatingRule = try reader["GatingRule"].readIfPresent(with: Route53RecoveryControlConfigClientTypes.GatingRule.read(from:))
        return value
    }
}

public struct CreateSafetyRuleOutput {
    /// The assertion rule created.
    public var assertionRule: Route53RecoveryControlConfigClientTypes.AssertionRule?
    /// The gating rule created.
    public var gatingRule: Route53RecoveryControlConfigClientTypes.GatingRule?

    public init(
        assertionRule: Route53RecoveryControlConfigClientTypes.AssertionRule? = nil,
        gatingRule: Route53RecoveryControlConfigClientTypes.GatingRule? = nil
    )
    {
        self.assertionRule = assertionRule
        self.gatingRule = gatingRule
    }
}

enum CreateSafetyRuleOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension DeleteClusterInput {

    static func urlPathProvider(_ value: DeleteClusterInput) -> Swift.String? {
        guard let clusterArn = value.clusterArn else {
            return nil
        }
        return "/cluster/\(clusterArn.urlPercentEncoding())"
    }
}

public struct DeleteClusterInput {
    /// The Amazon Resource Name (ARN) of the cluster that you're deleting.
    /// This member is required.
    public var clusterArn: Swift.String?

    public init(
        clusterArn: Swift.String? = nil
    )
    {
        self.clusterArn = clusterArn
    }
}

extension DeleteClusterOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> DeleteClusterOutput {
        return DeleteClusterOutput()
    }
}

public struct DeleteClusterOutput {

    public init() { }
}

enum DeleteClusterOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension DeleteControlPanelInput {

    static func urlPathProvider(_ value: DeleteControlPanelInput) -> Swift.String? {
        guard let controlPanelArn = value.controlPanelArn else {
            return nil
        }
        return "/controlpanel/\(controlPanelArn.urlPercentEncoding())"
    }
}

public struct DeleteControlPanelInput {
    /// The Amazon Resource Name (ARN) of the control panel.
    /// This member is required.
    public var controlPanelArn: Swift.String?

    public init(
        controlPanelArn: Swift.String? = nil
    )
    {
        self.controlPanelArn = controlPanelArn
    }
}

extension DeleteControlPanelOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> DeleteControlPanelOutput {
        return DeleteControlPanelOutput()
    }
}

public struct DeleteControlPanelOutput {

    public init() { }
}

enum DeleteControlPanelOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension DeleteRoutingControlInput {

    static func urlPathProvider(_ value: DeleteRoutingControlInput) -> Swift.String? {
        guard let routingControlArn = value.routingControlArn else {
            return nil
        }
        return "/routingcontrol/\(routingControlArn.urlPercentEncoding())"
    }
}

public struct DeleteRoutingControlInput {
    /// The Amazon Resource Name (ARN) of the routing control that you're deleting.
    /// This member is required.
    public var routingControlArn: Swift.String?

    public init(
        routingControlArn: Swift.String? = nil
    )
    {
        self.routingControlArn = routingControlArn
    }
}

extension DeleteRoutingControlOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> DeleteRoutingControlOutput {
        return DeleteRoutingControlOutput()
    }
}

public struct DeleteRoutingControlOutput {

    public init() { }
}

enum DeleteRoutingControlOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension DeleteSafetyRuleInput {

    static func urlPathProvider(_ value: DeleteSafetyRuleInput) -> Swift.String? {
        guard let safetyRuleArn = value.safetyRuleArn else {
            return nil
        }
        return "/safetyrule/\(safetyRuleArn.urlPercentEncoding())"
    }
}

public struct DeleteSafetyRuleInput {
    /// The ARN of the safety rule.
    /// This member is required.
    public var safetyRuleArn: Swift.String?

    public init(
        safetyRuleArn: Swift.String? = nil
    )
    {
        self.safetyRuleArn = safetyRuleArn
    }
}

extension DeleteSafetyRuleOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> DeleteSafetyRuleOutput {
        return DeleteSafetyRuleOutput()
    }
}

public struct DeleteSafetyRuleOutput {

    public init() { }
}

enum DeleteSafetyRuleOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension DescribeClusterInput {

    static func urlPathProvider(_ value: DescribeClusterInput) -> Swift.String? {
        guard let clusterArn = value.clusterArn else {
            return nil
        }
        return "/cluster/\(clusterArn.urlPercentEncoding())"
    }
}

public struct DescribeClusterInput {
    /// The Amazon Resource Name (ARN) of the cluster.
    /// This member is required.
    public var clusterArn: Swift.String?

    public init(
        clusterArn: Swift.String? = nil
    )
    {
        self.clusterArn = clusterArn
    }
}

extension DescribeClusterOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> DescribeClusterOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeClusterOutput()
        value.cluster = try reader["Cluster"].readIfPresent(with: Route53RecoveryControlConfigClientTypes.Cluster.read(from:))
        return value
    }
}

public struct DescribeClusterOutput {
    /// The cluster for the DescribeCluster request.
    public var cluster: Route53RecoveryControlConfigClientTypes.Cluster?

    public init(
        cluster: Route53RecoveryControlConfigClientTypes.Cluster? = nil
    )
    {
        self.cluster = cluster
    }
}

enum DescribeClusterOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension DescribeControlPanelInput {

    static func urlPathProvider(_ value: DescribeControlPanelInput) -> Swift.String? {
        guard let controlPanelArn = value.controlPanelArn else {
            return nil
        }
        return "/controlpanel/\(controlPanelArn.urlPercentEncoding())"
    }
}

public struct DescribeControlPanelInput {
    /// The Amazon Resource Name (ARN) of the control panel.
    /// This member is required.
    public var controlPanelArn: Swift.String?

    public init(
        controlPanelArn: Swift.String? = nil
    )
    {
        self.controlPanelArn = controlPanelArn
    }
}

extension DescribeControlPanelOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> DescribeControlPanelOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeControlPanelOutput()
        value.controlPanel = try reader["ControlPanel"].readIfPresent(with: Route53RecoveryControlConfigClientTypes.ControlPanel.read(from:))
        return value
    }
}

public struct DescribeControlPanelOutput {
    /// Information about the control panel.
    public var controlPanel: Route53RecoveryControlConfigClientTypes.ControlPanel?

    public init(
        controlPanel: Route53RecoveryControlConfigClientTypes.ControlPanel? = nil
    )
    {
        self.controlPanel = controlPanel
    }
}

enum DescribeControlPanelOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension DescribeRoutingControlInput {

    static func urlPathProvider(_ value: DescribeRoutingControlInput) -> Swift.String? {
        guard let routingControlArn = value.routingControlArn else {
            return nil
        }
        return "/routingcontrol/\(routingControlArn.urlPercentEncoding())"
    }
}

public struct DescribeRoutingControlInput {
    /// The Amazon Resource Name (ARN) of the routing control.
    /// This member is required.
    public var routingControlArn: Swift.String?

    public init(
        routingControlArn: Swift.String? = nil
    )
    {
        self.routingControlArn = routingControlArn
    }
}

extension DescribeRoutingControlOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> DescribeRoutingControlOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeRoutingControlOutput()
        value.routingControl = try reader["RoutingControl"].readIfPresent(with: Route53RecoveryControlConfigClientTypes.RoutingControl.read(from:))
        return value
    }
}

public struct DescribeRoutingControlOutput {
    /// Information about the routing control.
    public var routingControl: Route53RecoveryControlConfigClientTypes.RoutingControl?

    public init(
        routingControl: Route53RecoveryControlConfigClientTypes.RoutingControl? = nil
    )
    {
        self.routingControl = routingControl
    }
}

enum DescribeRoutingControlOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension DescribeSafetyRuleInput {

    static func urlPathProvider(_ value: DescribeSafetyRuleInput) -> Swift.String? {
        guard let safetyRuleArn = value.safetyRuleArn else {
            return nil
        }
        return "/safetyrule/\(safetyRuleArn.urlPercentEncoding())"
    }
}

public struct DescribeSafetyRuleInput {
    /// The ARN of the safety rule.
    /// This member is required.
    public var safetyRuleArn: Swift.String?

    public init(
        safetyRuleArn: Swift.String? = nil
    )
    {
        self.safetyRuleArn = safetyRuleArn
    }
}

extension DescribeSafetyRuleOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> DescribeSafetyRuleOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeSafetyRuleOutput()
        value.assertionRule = try reader["AssertionRule"].readIfPresent(with: Route53RecoveryControlConfigClientTypes.AssertionRule.read(from:))
        value.gatingRule = try reader["GatingRule"].readIfPresent(with: Route53RecoveryControlConfigClientTypes.GatingRule.read(from:))
        return value
    }
}

public struct DescribeSafetyRuleOutput {
    /// The assertion rule in the response.
    public var assertionRule: Route53RecoveryControlConfigClientTypes.AssertionRule?
    /// The gating rule in the response.
    public var gatingRule: Route53RecoveryControlConfigClientTypes.GatingRule?

    public init(
        assertionRule: Route53RecoveryControlConfigClientTypes.AssertionRule? = nil,
        gatingRule: Route53RecoveryControlConfigClientTypes.GatingRule? = nil
    )
    {
        self.assertionRule = assertionRule
        self.gatingRule = gatingRule
    }
}

enum DescribeSafetyRuleOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension Route53RecoveryControlConfigClientTypes.GatingRule {

    static func read(from reader: SmithyJSON.Reader) throws -> Route53RecoveryControlConfigClientTypes.GatingRule {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = Route53RecoveryControlConfigClientTypes.GatingRule()
        value.controlPanelArn = try reader["ControlPanelArn"].readIfPresent()
        value.gatingControls = try reader["GatingControls"].readListIfPresent(memberReadingClosure: Swift.String.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.name = try reader["Name"].readIfPresent()
        value.ruleConfig = try reader["RuleConfig"].readIfPresent(with: Route53RecoveryControlConfigClientTypes.RuleConfig.read(from:))
        value.safetyRuleArn = try reader["SafetyRuleArn"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.targetControls = try reader["TargetControls"].readListIfPresent(memberReadingClosure: Swift.String.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.waitPeriodMs = try reader["WaitPeriodMs"].readIfPresent()
        value.owner = try reader["Owner"].readIfPresent()
        return value
    }
}

extension Route53RecoveryControlConfigClientTypes {
    /// A gating rule verifies that a gating routing control or set of gating routing controls, evaluates as true, based on a rule configuration that you specify, which allows a set of routing control state changes to complete. For example, if you specify one gating routing control and you set the Type in the rule configuration to OR, that indicates that you must set the gating routing control to On for the rule to evaluate as true; that is, for the gating control "switch" to be "On". When you do that, then you can update the routing control states for the target routing controls that you specify in the gating rule.
    public struct GatingRule {
        /// The Amazon Resource Name (ARN) of the control panel.
        /// This member is required.
        public var controlPanelArn: Swift.String?
        /// An array of gating routing control Amazon Resource Names (ARNs). For a simple "on/off" switch, specify the ARN for one routing control. The gating routing controls are evaluated by the rule configuration that you specify to determine if the target routing control states can be changed.
        /// This member is required.
        public var gatingControls: [Swift.String]?
        /// The name for the gating rule. You can use any non-white space character in the name.
        /// This member is required.
        public var name: Swift.String?
        /// The Amazon Web Services account ID of the gating rule owner.
        public var owner: Swift.String?
        /// The criteria that you set for gating routing controls that designate how many of the routing control states must be ON to allow you to update target routing control states.
        /// This member is required.
        public var ruleConfig: Route53RecoveryControlConfigClientTypes.RuleConfig?
        /// The Amazon Resource Name (ARN) of the gating rule.
        /// This member is required.
        public var safetyRuleArn: Swift.String?
        /// The deployment status of a gating rule. Status can be one of the following: PENDING, DEPLOYED, PENDING_DELETION.
        /// This member is required.
        public var status: Route53RecoveryControlConfigClientTypes.Status?
        /// An array of target routing control Amazon Resource Names (ARNs) for which the states can only be updated if the rule configuration that you specify evaluates to true for the gating routing control. As a simple example, if you have a single gating control, it acts as an overall "on/off" switch for a set of target routing controls. You can use this to manually override automated failover, for example.
        /// This member is required.
        public var targetControls: [Swift.String]?
        /// An evaluation period, in milliseconds (ms), during which any request against the target routing controls will fail. This helps prevent "flapping" of state. The wait period is 5000 ms by default, but you can choose a custom value.
        /// This member is required.
        public var waitPeriodMs: Swift.Int?

        public init(
            controlPanelArn: Swift.String? = nil,
            gatingControls: [Swift.String]? = nil,
            name: Swift.String? = nil,
            owner: Swift.String? = nil,
            ruleConfig: Route53RecoveryControlConfigClientTypes.RuleConfig? = nil,
            safetyRuleArn: Swift.String? = nil,
            status: Route53RecoveryControlConfigClientTypes.Status? = nil,
            targetControls: [Swift.String]? = nil,
            waitPeriodMs: Swift.Int? = nil
        )
        {
            self.controlPanelArn = controlPanelArn
            self.gatingControls = gatingControls
            self.name = name
            self.owner = owner
            self.ruleConfig = ruleConfig
            self.safetyRuleArn = safetyRuleArn
            self.status = status
            self.targetControls = targetControls
            self.waitPeriodMs = waitPeriodMs
        }
    }

}

extension Route53RecoveryControlConfigClientTypes.GatingRuleUpdate {

    static func write(value: Route53RecoveryControlConfigClientTypes.GatingRuleUpdate?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Name"].write(value.name)
        try writer["SafetyRuleArn"].write(value.safetyRuleArn)
        try writer["WaitPeriodMs"].write(value.waitPeriodMs)
    }
}

extension Route53RecoveryControlConfigClientTypes {
    /// Update to a gating rule. You can update the name or the evaluation period (wait period). If you don't specify one of the items to update, the item is unchanged.
    public struct GatingRuleUpdate {
        /// The name for the gating rule. You can use any non-white space character in the name.
        /// This member is required.
        public var name: Swift.String?
        /// The Amazon Resource Name (ARN) of the gating rule.
        /// This member is required.
        public var safetyRuleArn: Swift.String?
        /// An evaluation period, in milliseconds (ms), during which any request against the target routing controls will fail. This helps prevent "flapping" of state. The wait period is 5000 ms by default, but you can choose a custom value.
        /// This member is required.
        public var waitPeriodMs: Swift.Int?

        public init(
            name: Swift.String? = nil,
            safetyRuleArn: Swift.String? = nil,
            waitPeriodMs: Swift.Int? = nil
        )
        {
            self.name = name
            self.safetyRuleArn = safetyRuleArn
            self.waitPeriodMs = waitPeriodMs
        }
    }

}

extension GetResourcePolicyInput {

    static func urlPathProvider(_ value: GetResourcePolicyInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/resourcePolicy/\(resourceArn.urlPercentEncoding())"
    }
}

public struct GetResourcePolicyInput {
    /// The Amazon Resource Name (ARN) of the resource.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

extension GetResourcePolicyOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> GetResourcePolicyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetResourcePolicyOutput()
        value.policy = try reader["Policy"].readIfPresent()
        return value
    }
}

public struct GetResourcePolicyOutput {
    /// The resource policy.
    public var policy: Swift.String?

    public init(
        policy: Swift.String? = nil
    )
    {
        self.policy = policy
    }
}

enum GetResourcePolicyOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension InternalServerException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InternalServerException {
        let reader = baseError.errorBodyReader
        var value = InternalServerException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// 500 response - InternalServiceError. Temporary service error. Retry the request.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension ListAssociatedRoute53HealthChecksInput {

    static func queryItemProvider(_ value: ListAssociatedRoute53HealthChecksInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListAssociatedRoute53HealthChecksInput {

    static func urlPathProvider(_ value: ListAssociatedRoute53HealthChecksInput) -> Swift.String? {
        guard let routingControlArn = value.routingControlArn else {
            return nil
        }
        return "/routingcontrol/\(routingControlArn.urlPercentEncoding())/associatedRoute53HealthChecks"
    }
}

public struct ListAssociatedRoute53HealthChecksInput {
    /// The number of objects that you want to return with this call.
    public var maxResults: Swift.Int?
    /// The token that identifies which batch of results you want to see.
    public var nextToken: Swift.String?
    /// The Amazon Resource Name (ARN) of the routing control.
    /// This member is required.
    public var routingControlArn: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        routingControlArn: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.routingControlArn = routingControlArn
    }
}

extension ListAssociatedRoute53HealthChecksOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListAssociatedRoute53HealthChecksOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListAssociatedRoute53HealthChecksOutput()
        value.healthCheckIds = try reader["HealthCheckIds"].readListIfPresent(memberReadingClosure: Swift.String.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

public struct ListAssociatedRoute53HealthChecksOutput {
    /// Identifiers for the health checks.
    public var healthCheckIds: [Swift.String]?
    /// Next token for listing health checks.
    public var nextToken: Swift.String?

    public init(
        healthCheckIds: [Swift.String]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.healthCheckIds = healthCheckIds
        self.nextToken = nextToken
    }
}

enum ListAssociatedRoute53HealthChecksOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ListClustersInput {

    static func queryItemProvider(_ value: ListClustersInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListClustersInput {

    static func urlPathProvider(_ value: ListClustersInput) -> Swift.String? {
        return "/cluster"
    }
}

public struct ListClustersInput {
    /// The number of objects that you want to return with this call.
    public var maxResults: Swift.Int?
    /// The token that identifies which batch of results you want to see.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ListClustersOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListClustersOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListClustersOutput()
        value.clusters = try reader["Clusters"].readListIfPresent(memberReadingClosure: Route53RecoveryControlConfigClientTypes.Cluster.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

public struct ListClustersOutput {
    /// An array of the clusters in an account.
    public var clusters: [Route53RecoveryControlConfigClientTypes.Cluster]?
    /// The token that identifies which batch of results you want to see.
    public var nextToken: Swift.String?

    public init(
        clusters: [Route53RecoveryControlConfigClientTypes.Cluster]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.clusters = clusters
        self.nextToken = nextToken
    }
}

enum ListClustersOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ListControlPanelsInput {

    static func queryItemProvider(_ value: ListControlPanelsInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let clusterArn = value.clusterArn {
            let clusterArnQueryItem = ClientRuntime.SDKURLQueryItem(name: "ClusterArn".urlPercentEncoding(), value: Swift.String(clusterArn).urlPercentEncoding())
            items.append(clusterArnQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListControlPanelsInput {

    static func urlPathProvider(_ value: ListControlPanelsInput) -> Swift.String? {
        return "/controlpanels"
    }
}

public struct ListControlPanelsInput {
    /// The Amazon Resource Name (ARN) of a cluster.
    public var clusterArn: Swift.String?
    /// The number of objects that you want to return with this call.
    public var maxResults: Swift.Int?
    /// The token that identifies which batch of results you want to see.
    public var nextToken: Swift.String?

    public init(
        clusterArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.clusterArn = clusterArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ListControlPanelsOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListControlPanelsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListControlPanelsOutput()
        value.controlPanels = try reader["ControlPanels"].readListIfPresent(memberReadingClosure: Route53RecoveryControlConfigClientTypes.ControlPanel.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

public struct ListControlPanelsOutput {
    /// The result of a successful ListControlPanel request.
    public var controlPanels: [Route53RecoveryControlConfigClientTypes.ControlPanel]?
    /// The token that identifies which batch of results you want to see.
    public var nextToken: Swift.String?

    public init(
        controlPanels: [Route53RecoveryControlConfigClientTypes.ControlPanel]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.controlPanels = controlPanels
        self.nextToken = nextToken
    }
}

enum ListControlPanelsOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ListRoutingControlsInput {

    static func queryItemProvider(_ value: ListRoutingControlsInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListRoutingControlsInput {

    static func urlPathProvider(_ value: ListRoutingControlsInput) -> Swift.String? {
        guard let controlPanelArn = value.controlPanelArn else {
            return nil
        }
        return "/controlpanel/\(controlPanelArn.urlPercentEncoding())/routingcontrols"
    }
}

public struct ListRoutingControlsInput {
    /// The Amazon Resource Name (ARN) of the control panel.
    /// This member is required.
    public var controlPanelArn: Swift.String?
    /// The number of objects that you want to return with this call.
    public var maxResults: Swift.Int?
    /// The token that identifies which batch of results you want to see.
    public var nextToken: Swift.String?

    public init(
        controlPanelArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.controlPanelArn = controlPanelArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ListRoutingControlsOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListRoutingControlsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListRoutingControlsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.routingControls = try reader["RoutingControls"].readListIfPresent(memberReadingClosure: Route53RecoveryControlConfigClientTypes.RoutingControl.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

public struct ListRoutingControlsOutput {
    /// The token that identifies which batch of results you want to see.
    public var nextToken: Swift.String?
    /// An array of routing controls.
    public var routingControls: [Route53RecoveryControlConfigClientTypes.RoutingControl]?

    public init(
        nextToken: Swift.String? = nil,
        routingControls: [Route53RecoveryControlConfigClientTypes.RoutingControl]? = nil
    )
    {
        self.nextToken = nextToken
        self.routingControls = routingControls
    }
}

enum ListRoutingControlsOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ListSafetyRulesInput {

    static func queryItemProvider(_ value: ListSafetyRulesInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "NextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "MaxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListSafetyRulesInput {

    static func urlPathProvider(_ value: ListSafetyRulesInput) -> Swift.String? {
        guard let controlPanelArn = value.controlPanelArn else {
            return nil
        }
        return "/controlpanel/\(controlPanelArn.urlPercentEncoding())/safetyrules"
    }
}

public struct ListSafetyRulesInput {
    /// The Amazon Resource Name (ARN) of the control panel.
    /// This member is required.
    public var controlPanelArn: Swift.String?
    /// The number of objects that you want to return with this call.
    public var maxResults: Swift.Int?
    /// The token that identifies which batch of results you want to see.
    public var nextToken: Swift.String?

    public init(
        controlPanelArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.controlPanelArn = controlPanelArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ListSafetyRulesOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListSafetyRulesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListSafetyRulesOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.safetyRules = try reader["SafetyRules"].readListIfPresent(memberReadingClosure: Route53RecoveryControlConfigClientTypes.Rule.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

public struct ListSafetyRulesOutput {
    /// The token that identifies which batch of results you want to see.
    public var nextToken: Swift.String?
    /// The list of safety rules in a control panel.
    public var safetyRules: [Route53RecoveryControlConfigClientTypes.Rule]?

    public init(
        nextToken: Swift.String? = nil,
        safetyRules: [Route53RecoveryControlConfigClientTypes.Rule]? = nil
    )
    {
        self.nextToken = nextToken
        self.safetyRules = safetyRules
    }
}

enum ListSafetyRulesOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct ListTagsForResourceInput {
    /// The Amazon Resource Name (ARN) for the resource that's tagged.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.tags = try reader["Tags"].readMapIfPresent(valueReadingClosure: Swift.String.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

public struct ListTagsForResourceOutput {
    /// The tags associated with the resource.
    public var tags: [Swift.String:Swift.String]?

    public init(
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension Route53RecoveryControlConfigClientTypes.NewAssertionRule {

    static func write(value: Route53RecoveryControlConfigClientTypes.NewAssertionRule?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AssertedControls"].writeList(value.assertedControls, memberWritingClosure: Swift.String.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ControlPanelArn"].write(value.controlPanelArn)
        try writer["Name"].write(value.name)
        try writer["RuleConfig"].write(value.ruleConfig, with: Route53RecoveryControlConfigClientTypes.RuleConfig.write(value:to:))
        try writer["WaitPeriodMs"].write(value.waitPeriodMs)
    }
}

extension Route53RecoveryControlConfigClientTypes {
    /// A new assertion rule for a control panel.
    public struct NewAssertionRule {
        /// The routing controls that are part of transactions that are evaluated to determine if a request to change a routing control state is allowed. For example, you might include three routing controls, one for each of three Amazon Web Services Regions.
        /// This member is required.
        public var assertedControls: [Swift.String]?
        /// The Amazon Resource Name (ARN) for the control panel.
        /// This member is required.
        public var controlPanelArn: Swift.String?
        /// The name of the assertion rule. You can use any non-white space character in the name.
        /// This member is required.
        public var name: Swift.String?
        /// The criteria that you set for specific assertion controls (routing controls) that designate how many control states must be ON as the result of a transaction. For example, if you have three assertion controls, you might specify ATLEAST 2 for your rule configuration. This means that at least two assertion controls must be ON, so that at least two Amazon Web Services Regions have traffic flowing to them.
        /// This member is required.
        public var ruleConfig: Route53RecoveryControlConfigClientTypes.RuleConfig?
        /// An evaluation period, in milliseconds (ms), during which any request against the target routing controls will fail. This helps prevent "flapping" of state. The wait period is 5000 ms by default, but you can choose a custom value.
        /// This member is required.
        public var waitPeriodMs: Swift.Int?

        public init(
            assertedControls: [Swift.String]? = nil,
            controlPanelArn: Swift.String? = nil,
            name: Swift.String? = nil,
            ruleConfig: Route53RecoveryControlConfigClientTypes.RuleConfig? = nil,
            waitPeriodMs: Swift.Int? = nil
        )
        {
            self.assertedControls = assertedControls
            self.controlPanelArn = controlPanelArn
            self.name = name
            self.ruleConfig = ruleConfig
            self.waitPeriodMs = waitPeriodMs
        }
    }

}

extension Route53RecoveryControlConfigClientTypes.NewGatingRule {

    static func write(value: Route53RecoveryControlConfigClientTypes.NewGatingRule?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ControlPanelArn"].write(value.controlPanelArn)
        try writer["GatingControls"].writeList(value.gatingControls, memberWritingClosure: Swift.String.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Name"].write(value.name)
        try writer["RuleConfig"].write(value.ruleConfig, with: Route53RecoveryControlConfigClientTypes.RuleConfig.write(value:to:))
        try writer["TargetControls"].writeList(value.targetControls, memberWritingClosure: Swift.String.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["WaitPeriodMs"].write(value.waitPeriodMs)
    }
}

extension Route53RecoveryControlConfigClientTypes {
    /// A new gating rule for a control panel.
    public struct NewGatingRule {
        /// The Amazon Resource Name (ARN) of the control panel.
        /// This member is required.
        public var controlPanelArn: Swift.String?
        /// The gating controls for the new gating rule. That is, routing controls that are evaluated by the rule configuration that you specify.
        /// This member is required.
        public var gatingControls: [Swift.String]?
        /// The name for the new gating rule.
        /// This member is required.
        public var name: Swift.String?
        /// The criteria that you set for specific gating controls (routing controls) that designate how many control states must be ON to allow you to change (set or unset) the target control states.
        /// This member is required.
        public var ruleConfig: Route53RecoveryControlConfigClientTypes.RuleConfig?
        /// Routing controls that can only be set or unset if the specified RuleConfig evaluates to true for the specified GatingControls. For example, say you have three gating controls, one for each of three Amazon Web Services Regions. Now you specify ATLEAST 2 as your RuleConfig. With these settings, you can only change (set or unset) the routing controls that you have specified as TargetControls if that rule evaluates to true. In other words, your ability to change the routing controls that you have specified as TargetControls is gated by the rule that you set for the routing controls in GatingControls.
        /// This member is required.
        public var targetControls: [Swift.String]?
        /// An evaluation period, in milliseconds (ms), during which any request against the target routing controls will fail. This helps prevent "flapping" of state. The wait period is 5000 ms by default, but you can choose a custom value.
        /// This member is required.
        public var waitPeriodMs: Swift.Int?

        public init(
            controlPanelArn: Swift.String? = nil,
            gatingControls: [Swift.String]? = nil,
            name: Swift.String? = nil,
            ruleConfig: Route53RecoveryControlConfigClientTypes.RuleConfig? = nil,
            targetControls: [Swift.String]? = nil,
            waitPeriodMs: Swift.Int? = nil
        )
        {
            self.controlPanelArn = controlPanelArn
            self.gatingControls = gatingControls
            self.name = name
            self.ruleConfig = ruleConfig
            self.targetControls = targetControls
            self.waitPeriodMs = waitPeriodMs
        }
    }

}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// 404 response - MalformedQueryString. The query string contains a syntax error or resource not found.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public enum Route53RecoveryControlConfigClientTypes {}

extension Route53RecoveryControlConfigClientTypes.RoutingControl {

    static func read(from reader: SmithyJSON.Reader) throws -> Route53RecoveryControlConfigClientTypes.RoutingControl {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = Route53RecoveryControlConfigClientTypes.RoutingControl()
        value.controlPanelArn = try reader["ControlPanelArn"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.routingControlArn = try reader["RoutingControlArn"].readIfPresent()
        value.status = try reader["Status"].readIfPresent()
        value.owner = try reader["Owner"].readIfPresent()
        return value
    }
}

extension Route53RecoveryControlConfigClientTypes {
    /// A routing control has one of two states: ON and OFF. You can map the routing control state to the state of an Amazon Route 53 health check, which can be used to control traffic routing.
    public struct RoutingControl {
        /// The Amazon Resource Name (ARN) of the control panel that includes the routing control.
        public var controlPanelArn: Swift.String?
        /// The name of the routing control.
        public var name: Swift.String?
        /// The Amazon Web Services account ID of the routing control owner.
        public var owner: Swift.String?
        /// The Amazon Resource Name (ARN) of the routing control.
        public var routingControlArn: Swift.String?
        /// The deployment status of a routing control. Status can be one of the following: PENDING, DEPLOYED, PENDING_DELETION.
        public var status: Route53RecoveryControlConfigClientTypes.Status?

        public init(
            controlPanelArn: Swift.String? = nil,
            name: Swift.String? = nil,
            owner: Swift.String? = nil,
            routingControlArn: Swift.String? = nil,
            status: Route53RecoveryControlConfigClientTypes.Status? = nil
        )
        {
            self.controlPanelArn = controlPanelArn
            self.name = name
            self.owner = owner
            self.routingControlArn = routingControlArn
            self.status = status
        }
    }

}

extension Route53RecoveryControlConfigClientTypes.Rule {

    static func read(from reader: SmithyJSON.Reader) throws -> Route53RecoveryControlConfigClientTypes.Rule {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = Route53RecoveryControlConfigClientTypes.Rule()
        value.assertion = try reader["ASSERTION"].readIfPresent(with: Route53RecoveryControlConfigClientTypes.AssertionRule.read(from:))
        value.gating = try reader["GATING"].readIfPresent(with: Route53RecoveryControlConfigClientTypes.GatingRule.read(from:))
        return value
    }
}

extension Route53RecoveryControlConfigClientTypes {
    /// A safety rule. A safety rule can be an assertion rule or a gating rule.
    public struct Rule {
        /// An assertion rule enforces that, when a routing control state is changed, the criteria set by the rule configuration is met. Otherwise, the change to the routing control state is not accepted. For example, the criteria might be that at least one routing control state is On after the transaction so that traffic continues to flow to at least one cell for the application. This ensures that you avoid a fail-open scenario.
        public var assertion: Route53RecoveryControlConfigClientTypes.AssertionRule?
        /// A gating rule verifies that a gating routing control or set of gating routing controls, evaluates as true, based on a rule configuration that you specify, which allows a set of routing control state changes to complete. For example, if you specify one gating routing control and you set the Type in the rule configuration to OR, that indicates that you must set the gating routing control to On for the rule to evaluate as true; that is, for the gating control "switch" to be "On". When you do that, then you can update the routing control states for the target routing controls that you specify in the gating rule.
        public var gating: Route53RecoveryControlConfigClientTypes.GatingRule?

        public init(
            assertion: Route53RecoveryControlConfigClientTypes.AssertionRule? = nil,
            gating: Route53RecoveryControlConfigClientTypes.GatingRule? = nil
        )
        {
            self.assertion = assertion
            self.gating = gating
        }
    }

}

extension Route53RecoveryControlConfigClientTypes.RuleConfig {

    static func write(value: Route53RecoveryControlConfigClientTypes.RuleConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Inverted"].write(value.inverted)
        try writer["Threshold"].write(value.threshold)
        try writer["Type"].write(value.type)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> Route53RecoveryControlConfigClientTypes.RuleConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = Route53RecoveryControlConfigClientTypes.RuleConfig()
        value.inverted = try reader["Inverted"].readIfPresent()
        value.threshold = try reader["Threshold"].readIfPresent()
        value.type = try reader["Type"].readIfPresent()
        return value
    }
}

extension Route53RecoveryControlConfigClientTypes {
    /// The rule configuration for an assertion rule. That is, the criteria that you set for specific assertion controls (routing controls) that specify how many control states must be ON after a transaction completes.
    public struct RuleConfig {
        /// Logical negation of the rule. If the rule would usually evaluate true, it's evaluated as false, and vice versa.
        /// This member is required.
        public var inverted: Swift.Bool?
        /// The value of N, when you specify an ATLEAST rule type. That is, Threshold is the number of controls that must be set when you specify an ATLEAST type.
        /// This member is required.
        public var threshold: Swift.Int?
        /// A rule can be one of the following: ATLEAST, AND, or OR.
        /// This member is required.
        public var type: Route53RecoveryControlConfigClientTypes.RuleType?

        public init(
            inverted: Swift.Bool? = nil,
            threshold: Swift.Int? = nil,
            type: Route53RecoveryControlConfigClientTypes.RuleType? = nil
        )
        {
            self.inverted = inverted
            self.threshold = threshold
            self.type = type
        }
    }

}

extension Route53RecoveryControlConfigClientTypes {

    /// An enumerated type that determines how the evaluated rules are processed. RuleType can be one of the following: ATLEAST - At least N routing controls must be set. You specify N as the Threshold in the rule configuration. AND - All routing controls must be set. This is a shortcut for "At least N," where N is the total number of controls in the rule. OR - Any control must be set. This is a shortcut for "At least N," where N is 1.
    public enum RuleType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case and
        case atleast
        case or
        case sdkUnknown(Swift.String)

        public static var allCases: [RuleType] {
            return [
                .and,
                .atleast,
                .or,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .and: return "AND"
            case .atleast: return "ATLEAST"
            case .or: return "OR"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ServiceQuotaExceededException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ServiceQuotaExceededException {
        let reader = baseError.errorBodyReader
        var value = ServiceQuotaExceededException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// 402 response - You attempted to create more resources than the service allows based on service quotas.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension Route53RecoveryControlConfigClientTypes {

    /// The deployment status of a resource. Status can be one of the following: PENDING: Amazon Route 53 Application Recovery Controller is creating the resource. DEPLOYED: The resource is deployed and ready to use. PENDING_DELETION: Amazon Route 53 Application Recovery Controller is deleting the resource.
    public enum Status: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case deployed
        case pending
        case pendingDeletion
        case sdkUnknown(Swift.String)

        public static var allCases: [Status] {
            return [
                .deployed,
                .pending,
                .pendingDeletion,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .deployed: return "DEPLOYED"
            case .pending: return "PENDING"
            case .pendingDeletion: return "PENDING_DELETION"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Tags"].writeMap(value.tags, valueWritingClosure: Swift.String.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

/// Request of adding tag to the resource
public struct TagResourceInput {
    /// The Amazon Resource Name (ARN) for the resource that's tagged.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tags associated with the resource.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

public struct TagResourceOutput {

    public init() { }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ThrottlingException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ThrottlingException {
        let reader = baseError.errorBodyReader
        var value = ThrottlingException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// 429 response - LimitExceededException or TooManyRequestsException.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension UntagResourceInput {

    static func queryItemProvider(_ value: UntagResourceInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        guard let tagKeys = value.tagKeys else {
            let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
            throw ClientRuntime.ClientError.unknownError(message)
        }
        tagKeys.forEach { queryItemValue in
            let queryItem = ClientRuntime.SDKURLQueryItem(name: "TagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
            items.append(queryItem)
        }
        return items
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct UntagResourceInput {
    /// The Amazon Resource Name (ARN) for the resource that's tagged.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// Keys for the tags to be removed.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

public struct UntagResourceOutput {

    public init() { }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension UpdateControlPanelInput {

    static func urlPathProvider(_ value: UpdateControlPanelInput) -> Swift.String? {
        return "/controlpanel"
    }
}

extension UpdateControlPanelInput {

    static func write(value: UpdateControlPanelInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ControlPanelArn"].write(value.controlPanelArn)
        try writer["ControlPanelName"].write(value.controlPanelName)
    }
}

/// The details of the control panel that you're updating.
public struct UpdateControlPanelInput {
    /// The Amazon Resource Name (ARN) of the control panel.
    /// This member is required.
    public var controlPanelArn: Swift.String?
    /// The name of the control panel.
    /// This member is required.
    public var controlPanelName: Swift.String?

    public init(
        controlPanelArn: Swift.String? = nil,
        controlPanelName: Swift.String? = nil
    )
    {
        self.controlPanelArn = controlPanelArn
        self.controlPanelName = controlPanelName
    }
}

extension UpdateControlPanelOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> UpdateControlPanelOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateControlPanelOutput()
        value.controlPanel = try reader["ControlPanel"].readIfPresent(with: Route53RecoveryControlConfigClientTypes.ControlPanel.read(from:))
        return value
    }
}

public struct UpdateControlPanelOutput {
    /// The control panel to update.
    public var controlPanel: Route53RecoveryControlConfigClientTypes.ControlPanel?

    public init(
        controlPanel: Route53RecoveryControlConfigClientTypes.ControlPanel? = nil
    )
    {
        self.controlPanel = controlPanel
    }
}

enum UpdateControlPanelOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension UpdateRoutingControlInput {

    static func urlPathProvider(_ value: UpdateRoutingControlInput) -> Swift.String? {
        return "/routingcontrol"
    }
}

extension UpdateRoutingControlInput {

    static func write(value: UpdateRoutingControlInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["RoutingControlArn"].write(value.routingControlArn)
        try writer["RoutingControlName"].write(value.routingControlName)
    }
}

/// The details of the routing control that you're updating.
public struct UpdateRoutingControlInput {
    /// The Amazon Resource Name (ARN) of the routing control.
    /// This member is required.
    public var routingControlArn: Swift.String?
    /// The name of the routing control.
    /// This member is required.
    public var routingControlName: Swift.String?

    public init(
        routingControlArn: Swift.String? = nil,
        routingControlName: Swift.String? = nil
    )
    {
        self.routingControlArn = routingControlArn
        self.routingControlName = routingControlName
    }
}

extension UpdateRoutingControlOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> UpdateRoutingControlOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateRoutingControlOutput()
        value.routingControl = try reader["RoutingControl"].readIfPresent(with: Route53RecoveryControlConfigClientTypes.RoutingControl.read(from:))
        return value
    }
}

public struct UpdateRoutingControlOutput {
    /// The routing control that was updated.
    public var routingControl: Route53RecoveryControlConfigClientTypes.RoutingControl?

    public init(
        routingControl: Route53RecoveryControlConfigClientTypes.RoutingControl? = nil
    )
    {
        self.routingControl = routingControl
    }
}

enum UpdateRoutingControlOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension UpdateSafetyRuleInput {

    static func urlPathProvider(_ value: UpdateSafetyRuleInput) -> Swift.String? {
        return "/safetyrule"
    }
}

extension UpdateSafetyRuleInput {

    static func write(value: UpdateSafetyRuleInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AssertionRuleUpdate"].write(value.assertionRuleUpdate, with: Route53RecoveryControlConfigClientTypes.AssertionRuleUpdate.write(value:to:))
        try writer["GatingRuleUpdate"].write(value.gatingRuleUpdate, with: Route53RecoveryControlConfigClientTypes.GatingRuleUpdate.write(value:to:))
    }
}

/// A rule that you add to Application Recovery Controller to ensure that recovery actions don't accidentally impair your application's availability.
public struct UpdateSafetyRuleInput {
    /// The assertion rule to update.
    public var assertionRuleUpdate: Route53RecoveryControlConfigClientTypes.AssertionRuleUpdate?
    /// The gating rule to update.
    public var gatingRuleUpdate: Route53RecoveryControlConfigClientTypes.GatingRuleUpdate?

    public init(
        assertionRuleUpdate: Route53RecoveryControlConfigClientTypes.AssertionRuleUpdate? = nil,
        gatingRuleUpdate: Route53RecoveryControlConfigClientTypes.GatingRuleUpdate? = nil
    )
    {
        self.assertionRuleUpdate = assertionRuleUpdate
        self.gatingRuleUpdate = gatingRuleUpdate
    }
}

extension UpdateSafetyRuleOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> UpdateSafetyRuleOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateSafetyRuleOutput()
        value.assertionRule = try reader["AssertionRule"].readIfPresent(with: Route53RecoveryControlConfigClientTypes.AssertionRule.read(from:))
        value.gatingRule = try reader["GatingRule"].readIfPresent(with: Route53RecoveryControlConfigClientTypes.GatingRule.read(from:))
        return value
    }
}

public struct UpdateSafetyRuleOutput {
    /// The assertion rule updated.
    public var assertionRule: Route53RecoveryControlConfigClientTypes.AssertionRule?
    /// The gating rule updated.
    public var gatingRule: Route53RecoveryControlConfigClientTypes.GatingRule?

    public init(
        assertionRule: Route53RecoveryControlConfigClientTypes.AssertionRule? = nil,
        gatingRule: Route53RecoveryControlConfigClientTypes.GatingRule? = nil
    )
    {
        self.assertionRule = assertionRule
        self.gatingRule = gatingRule
    }
}

enum UpdateSafetyRuleOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ValidationException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ValidationException {
        let reader = baseError.errorBodyReader
        var value = ValidationException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// 400 response - Multiple causes. For example, you might have a malformed query string and input parameter might be out of range, or you might have used parameters together incorrectly.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}
