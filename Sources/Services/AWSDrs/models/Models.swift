// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.code = output.code
            self.properties.message = output.message
        } else {
            self.properties.code = nil
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// You do not have sufficient access to perform this action.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var code: Swift.String? = nil
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let code: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
    }
}

extension DrsClientTypes.Account: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountID
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountID = self.accountID {
            try encodeContainer.encode(accountID, forKey: .accountID)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountID)
        accountID = accountIDDecoded
    }
}

extension DrsClientTypes {
    /// AWS account.
    public struct Account: Swift.Equatable {
        /// Account ID of AWS account.
        public var accountID: Swift.String?

        public init(
            accountID: Swift.String? = nil
        )
        {
            self.accountID = accountID
        }
    }

}

extension AssociateSourceNetworkStackInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssociateSourceNetworkStackInput(sourceNetworkID: \(Swift.String(describing: sourceNetworkID)), cfnStackName: \"CONTENT_REDACTED\")"}
}

extension AssociateSourceNetworkStackInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cfnStackName
        case sourceNetworkID
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cfnStackName = self.cfnStackName {
            try encodeContainer.encode(cfnStackName, forKey: .cfnStackName)
        }
        if let sourceNetworkID = self.sourceNetworkID {
            try encodeContainer.encode(sourceNetworkID, forKey: .sourceNetworkID)
        }
    }
}

extension AssociateSourceNetworkStackInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/AssociateSourceNetworkStack"
    }
}

public struct AssociateSourceNetworkStackInput: Swift.Equatable {
    /// CloudFormation template to associate with a Source Network.
    /// This member is required.
    public var cfnStackName: Swift.String?
    /// The Source Network ID to associate with CloudFormation template.
    /// This member is required.
    public var sourceNetworkID: Swift.String?

    public init(
        cfnStackName: Swift.String? = nil,
        sourceNetworkID: Swift.String? = nil
    )
    {
        self.cfnStackName = cfnStackName
        self.sourceNetworkID = sourceNetworkID
    }
}

struct AssociateSourceNetworkStackInputBody: Swift.Equatable {
    let sourceNetworkID: Swift.String?
    let cfnStackName: Swift.String?
}

extension AssociateSourceNetworkStackInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cfnStackName
        case sourceNetworkID
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceNetworkIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceNetworkID)
        sourceNetworkID = sourceNetworkIDDecoded
        let cfnStackNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cfnStackName)
        cfnStackName = cfnStackNameDecoded
    }
}

extension AssociateSourceNetworkStackOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AssociateSourceNetworkStackOutputBody = try responseDecoder.decode(responseBody: data)
            self.job = output.job
        } else {
            self.job = nil
        }
    }
}

public struct AssociateSourceNetworkStackOutput: Swift.Equatable {
    /// The Source Network association Job.
    public var job: DrsClientTypes.Job?

    public init(
        job: DrsClientTypes.Job? = nil
    )
    {
        self.job = job
    }
}

struct AssociateSourceNetworkStackOutputBody: Swift.Equatable {
    let job: DrsClientTypes.Job?
}

extension AssociateSourceNetworkStackOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case job
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobDecoded = try containerValues.decodeIfPresent(DrsClientTypes.Job.self, forKey: .job)
        job = jobDecoded
    }
}

enum AssociateSourceNetworkStackOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UninitializedAccountException": return try await UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DrsClientTypes.CPU: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cores
        case modelName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if cores != 0 {
            try encodeContainer.encode(cores, forKey: .cores)
        }
        if let modelName = self.modelName {
            try encodeContainer.encode(modelName, forKey: .modelName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let coresDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .cores) ?? 0
        cores = coresDecoded
        let modelNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .modelName)
        modelName = modelNameDecoded
    }
}

extension DrsClientTypes {
    /// Information about a server's CPU.
    public struct CPU: Swift.Equatable {
        /// The number of CPU cores.
        public var cores: Swift.Int
        /// The model name of the CPU.
        public var modelName: Swift.String?

        public init(
            cores: Swift.Int = 0,
            modelName: Swift.String? = nil
        )
        {
            self.cores = cores
            self.modelName = modelName
        }
    }

}

extension ConflictException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.code = output.code
            self.properties.message = output.message
            self.properties.resourceId = output.resourceId
            self.properties.resourceType = output.resourceType
        } else {
            self.properties.code = nil
            self.properties.message = nil
            self.properties.resourceId = nil
            self.properties.resourceType = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request could not be completed due to a conflict with the current state of the target resource.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var code: Swift.String? = nil
        public internal(set) var message: Swift.String? = nil
        /// The ID of the resource.
        public internal(set) var resourceId: Swift.String? = nil
        /// The type of the resource.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let code: Swift.String?
    let resourceId: Swift.String?
    let resourceType: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code
        case message
        case resourceId
        case resourceType
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension DrsClientTypes.ConversionProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataTimestamp
        case forceUefi
        case rootVolumeName
        case volumeToConversionMap
        case volumeToVolumeSize
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataTimestamp = self.dataTimestamp {
            try encodeContainer.encode(dataTimestamp, forKey: .dataTimestamp)
        }
        if let forceUefi = self.forceUefi {
            try encodeContainer.encode(forceUefi, forKey: .forceUefi)
        }
        if let rootVolumeName = self.rootVolumeName {
            try encodeContainer.encode(rootVolumeName, forKey: .rootVolumeName)
        }
        if let volumeToConversionMap = volumeToConversionMap {
            var volumeToConversionMapContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .volumeToConversionMap)
            for (dictKey0, volumeToConversionMap0) in volumeToConversionMap {
                var volumeToConversionMap0Container = volumeToConversionMapContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: ClientRuntime.Key(stringValue: dictKey0))
                for (dictKey1, conversionMap1) in volumeToConversionMap0 {
                    try volumeToConversionMap0Container.encode(conversionMap1, forKey: ClientRuntime.Key(stringValue: dictKey1))
                }
            }
        }
        if let volumeToVolumeSize = volumeToVolumeSize {
            var volumeToVolumeSizeContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .volumeToVolumeSize)
            for (dictKey0, volumeToSizeMap0) in volumeToVolumeSize {
                try volumeToVolumeSizeContainer.encode(volumeToSizeMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let volumeToConversionMapContainer = try containerValues.decodeIfPresent([Swift.String: [Swift.String: Swift.String?]?].self, forKey: .volumeToConversionMap)
        var volumeToConversionMapDecoded0: [Swift.String:[Swift.String:Swift.String]]? = nil
        if let volumeToConversionMapContainer = volumeToConversionMapContainer {
            volumeToConversionMapDecoded0 = [Swift.String:[Swift.String:Swift.String]]()
            for (key0, conversionmap0) in volumeToConversionMapContainer {
                var conversionmap0Decoded0: [Swift.String: Swift.String]? = nil
                if let conversionmap0 = conversionmap0 {
                    conversionmap0Decoded0 = [Swift.String: Swift.String]()
                    for (key1, ebssnapshot1) in conversionmap0 {
                        if let ebssnapshot1 = ebssnapshot1 {
                            conversionmap0Decoded0?[key1] = ebssnapshot1
                        }
                    }
                }
                volumeToConversionMapDecoded0?[key0] = conversionmap0Decoded0
            }
        }
        volumeToConversionMap = volumeToConversionMapDecoded0
        let rootVolumeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .rootVolumeName)
        rootVolumeName = rootVolumeNameDecoded
        let forceUefiDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .forceUefi)
        forceUefi = forceUefiDecoded
        let dataTimestampDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataTimestamp)
        dataTimestamp = dataTimestampDecoded
        let volumeToVolumeSizeContainer = try containerValues.decodeIfPresent([Swift.String: Swift.Int?].self, forKey: .volumeToVolumeSize)
        var volumeToVolumeSizeDecoded0: [Swift.String:Swift.Int]? = nil
        if let volumeToVolumeSizeContainer = volumeToVolumeSizeContainer {
            volumeToVolumeSizeDecoded0 = [Swift.String:Swift.Int]()
            for (key0, positiveinteger0) in volumeToVolumeSizeContainer {
                if let positiveinteger0 = positiveinteger0 {
                    volumeToVolumeSizeDecoded0?[key0] = positiveinteger0
                }
            }
        }
        volumeToVolumeSize = volumeToVolumeSizeDecoded0
    }
}

extension DrsClientTypes {
    /// Properties of a conversion job
    public struct ConversionProperties: Swift.Equatable {
        /// The timestamp of when the snapshot being converted was taken
        public var dataTimestamp: Swift.String?
        /// Whether the volume being converted uses UEFI or not
        public var forceUefi: Swift.Bool?
        /// The root volume name of a conversion job
        public var rootVolumeName: Swift.String?
        /// A mapping between the volumes being converted and the converted snapshot ids
        public var volumeToConversionMap: [Swift.String:[Swift.String:Swift.String]]?
        /// A mapping between the volumes and their sizes
        public var volumeToVolumeSize: [Swift.String:Swift.Int]?

        public init(
            dataTimestamp: Swift.String? = nil,
            forceUefi: Swift.Bool? = nil,
            rootVolumeName: Swift.String? = nil,
            volumeToConversionMap: [Swift.String:[Swift.String:Swift.String]]? = nil,
            volumeToVolumeSize: [Swift.String:Swift.Int]? = nil
        )
        {
            self.dataTimestamp = dataTimestamp
            self.forceUefi = forceUefi
            self.rootVolumeName = rootVolumeName
            self.volumeToConversionMap = volumeToConversionMap
            self.volumeToVolumeSize = volumeToVolumeSize
        }
    }

}

extension CreateExtendedSourceServerInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateExtendedSourceServerInput(sourceServerArn: \(Swift.String(describing: sourceServerArn)), tags: \"CONTENT_REDACTED\")"}
}

extension CreateExtendedSourceServerInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sourceServerArn
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sourceServerArn = self.sourceServerArn {
            try encodeContainer.encode(sourceServerArn, forKey: .sourceServerArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagsMap0) in tags {
                try tagsContainer.encode(tagsMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateExtendedSourceServerInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/CreateExtendedSourceServer"
    }
}

public struct CreateExtendedSourceServerInput: Swift.Equatable {
    /// This defines the ARN of the source server in staging Account based on which you want to create an extended source server.
    /// This member is required.
    public var sourceServerArn: Swift.String?
    /// A list of tags associated with the extended source server.
    public var tags: [Swift.String:Swift.String]?

    public init(
        sourceServerArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.sourceServerArn = sourceServerArn
        self.tags = tags
    }
}

struct CreateExtendedSourceServerInputBody: Swift.Equatable {
    let sourceServerArn: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateExtendedSourceServerInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sourceServerArn
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceServerArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceServerArn)
        sourceServerArn = sourceServerArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateExtendedSourceServerOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateExtendedSourceServerOutputBody = try responseDecoder.decode(responseBody: data)
            self.sourceServer = output.sourceServer
        } else {
            self.sourceServer = nil
        }
    }
}

public struct CreateExtendedSourceServerOutput: Swift.Equatable {
    /// Created extended source server.
    public var sourceServer: DrsClientTypes.SourceServer?

    public init(
        sourceServer: DrsClientTypes.SourceServer? = nil
    )
    {
        self.sourceServer = sourceServer
    }
}

struct CreateExtendedSourceServerOutputBody: Swift.Equatable {
    let sourceServer: DrsClientTypes.SourceServer?
}

extension CreateExtendedSourceServerOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sourceServer
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceServerDecoded = try containerValues.decodeIfPresent(DrsClientTypes.SourceServer.self, forKey: .sourceServer)
        sourceServer = sourceServerDecoded
    }
}

enum CreateExtendedSourceServerOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UninitializedAccountException": return try await UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateLaunchConfigurationTemplateInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateLaunchConfigurationTemplateInput(copyPrivateIp: \(Swift.String(describing: copyPrivateIp)), copyTags: \(Swift.String(describing: copyTags)), exportBucketArn: \(Swift.String(describing: exportBucketArn)), launchDisposition: \(Swift.String(describing: launchDisposition)), licensing: \(Swift.String(describing: licensing)), postLaunchEnabled: \(Swift.String(describing: postLaunchEnabled)), targetInstanceTypeRightSizingMethod: \(Swift.String(describing: targetInstanceTypeRightSizingMethod)), tags: \"CONTENT_REDACTED\")"}
}

extension CreateLaunchConfigurationTemplateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case copyPrivateIp
        case copyTags
        case exportBucketArn
        case launchDisposition
        case licensing
        case postLaunchEnabled
        case tags
        case targetInstanceTypeRightSizingMethod
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let copyPrivateIp = self.copyPrivateIp {
            try encodeContainer.encode(copyPrivateIp, forKey: .copyPrivateIp)
        }
        if let copyTags = self.copyTags {
            try encodeContainer.encode(copyTags, forKey: .copyTags)
        }
        if let exportBucketArn = self.exportBucketArn {
            try encodeContainer.encode(exportBucketArn, forKey: .exportBucketArn)
        }
        if let launchDisposition = self.launchDisposition {
            try encodeContainer.encode(launchDisposition.rawValue, forKey: .launchDisposition)
        }
        if let licensing = self.licensing {
            try encodeContainer.encode(licensing, forKey: .licensing)
        }
        if let postLaunchEnabled = self.postLaunchEnabled {
            try encodeContainer.encode(postLaunchEnabled, forKey: .postLaunchEnabled)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagsMap0) in tags {
                try tagsContainer.encode(tagsMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let targetInstanceTypeRightSizingMethod = self.targetInstanceTypeRightSizingMethod {
            try encodeContainer.encode(targetInstanceTypeRightSizingMethod.rawValue, forKey: .targetInstanceTypeRightSizingMethod)
        }
    }
}

extension CreateLaunchConfigurationTemplateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/CreateLaunchConfigurationTemplate"
    }
}

public struct CreateLaunchConfigurationTemplateInput: Swift.Equatable {
    /// Copy private IP.
    public var copyPrivateIp: Swift.Bool?
    /// Copy tags.
    public var copyTags: Swift.Bool?
    /// S3 bucket ARN to export Source Network templates.
    public var exportBucketArn: Swift.String?
    /// Launch disposition.
    public var launchDisposition: DrsClientTypes.LaunchDisposition?
    /// Licensing.
    public var licensing: DrsClientTypes.Licensing?
    /// Whether we want to activate post-launch actions.
    public var postLaunchEnabled: Swift.Bool?
    /// Request to associate tags during creation of a Launch Configuration Template.
    public var tags: [Swift.String:Swift.String]?
    /// Target instance type right-sizing method.
    public var targetInstanceTypeRightSizingMethod: DrsClientTypes.TargetInstanceTypeRightSizingMethod?

    public init(
        copyPrivateIp: Swift.Bool? = nil,
        copyTags: Swift.Bool? = nil,
        exportBucketArn: Swift.String? = nil,
        launchDisposition: DrsClientTypes.LaunchDisposition? = nil,
        licensing: DrsClientTypes.Licensing? = nil,
        postLaunchEnabled: Swift.Bool? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        targetInstanceTypeRightSizingMethod: DrsClientTypes.TargetInstanceTypeRightSizingMethod? = nil
    )
    {
        self.copyPrivateIp = copyPrivateIp
        self.copyTags = copyTags
        self.exportBucketArn = exportBucketArn
        self.launchDisposition = launchDisposition
        self.licensing = licensing
        self.postLaunchEnabled = postLaunchEnabled
        self.tags = tags
        self.targetInstanceTypeRightSizingMethod = targetInstanceTypeRightSizingMethod
    }
}

struct CreateLaunchConfigurationTemplateInputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
    let launchDisposition: DrsClientTypes.LaunchDisposition?
    let targetInstanceTypeRightSizingMethod: DrsClientTypes.TargetInstanceTypeRightSizingMethod?
    let copyPrivateIp: Swift.Bool?
    let copyTags: Swift.Bool?
    let licensing: DrsClientTypes.Licensing?
    let exportBucketArn: Swift.String?
    let postLaunchEnabled: Swift.Bool?
}

extension CreateLaunchConfigurationTemplateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case copyPrivateIp
        case copyTags
        case exportBucketArn
        case launchDisposition
        case licensing
        case postLaunchEnabled
        case tags
        case targetInstanceTypeRightSizingMethod
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let launchDispositionDecoded = try containerValues.decodeIfPresent(DrsClientTypes.LaunchDisposition.self, forKey: .launchDisposition)
        launchDisposition = launchDispositionDecoded
        let targetInstanceTypeRightSizingMethodDecoded = try containerValues.decodeIfPresent(DrsClientTypes.TargetInstanceTypeRightSizingMethod.self, forKey: .targetInstanceTypeRightSizingMethod)
        targetInstanceTypeRightSizingMethod = targetInstanceTypeRightSizingMethodDecoded
        let copyPrivateIpDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .copyPrivateIp)
        copyPrivateIp = copyPrivateIpDecoded
        let copyTagsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .copyTags)
        copyTags = copyTagsDecoded
        let licensingDecoded = try containerValues.decodeIfPresent(DrsClientTypes.Licensing.self, forKey: .licensing)
        licensing = licensingDecoded
        let exportBucketArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .exportBucketArn)
        exportBucketArn = exportBucketArnDecoded
        let postLaunchEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .postLaunchEnabled)
        postLaunchEnabled = postLaunchEnabledDecoded
    }
}

extension CreateLaunchConfigurationTemplateOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateLaunchConfigurationTemplateOutputBody = try responseDecoder.decode(responseBody: data)
            self.launchConfigurationTemplate = output.launchConfigurationTemplate
        } else {
            self.launchConfigurationTemplate = nil
        }
    }
}

public struct CreateLaunchConfigurationTemplateOutput: Swift.Equatable {
    /// Created Launch Configuration Template.
    public var launchConfigurationTemplate: DrsClientTypes.LaunchConfigurationTemplate?

    public init(
        launchConfigurationTemplate: DrsClientTypes.LaunchConfigurationTemplate? = nil
    )
    {
        self.launchConfigurationTemplate = launchConfigurationTemplate
    }
}

struct CreateLaunchConfigurationTemplateOutputBody: Swift.Equatable {
    let launchConfigurationTemplate: DrsClientTypes.LaunchConfigurationTemplate?
}

extension CreateLaunchConfigurationTemplateOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case launchConfigurationTemplate
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let launchConfigurationTemplateDecoded = try containerValues.decodeIfPresent(DrsClientTypes.LaunchConfigurationTemplate.self, forKey: .launchConfigurationTemplate)
        launchConfigurationTemplate = launchConfigurationTemplateDecoded
    }
}

enum CreateLaunchConfigurationTemplateOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UninitializedAccountException": return try await UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateReplicationConfigurationTemplateInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateReplicationConfigurationTemplateInput(associateDefaultSecurityGroup: \(Swift.String(describing: associateDefaultSecurityGroup)), autoReplicateNewDisks: \(Swift.String(describing: autoReplicateNewDisks)), bandwidthThrottling: \(Swift.String(describing: bandwidthThrottling)), createPublicIP: \(Swift.String(describing: createPublicIP)), dataPlaneRouting: \(Swift.String(describing: dataPlaneRouting)), defaultLargeStagingDiskType: \(Swift.String(describing: defaultLargeStagingDiskType)), ebsEncryption: \(Swift.String(describing: ebsEncryption)), ebsEncryptionKeyArn: \(Swift.String(describing: ebsEncryptionKeyArn)), pitPolicy: \(Swift.String(describing: pitPolicy)), replicationServerInstanceType: \(Swift.String(describing: replicationServerInstanceType)), replicationServersSecurityGroupsIDs: \(Swift.String(describing: replicationServersSecurityGroupsIDs)), stagingAreaSubnetId: \(Swift.String(describing: stagingAreaSubnetId)), useDedicatedReplicationServer: \(Swift.String(describing: useDedicatedReplicationServer)), stagingAreaTags: \"CONTENT_REDACTED\", tags: \"CONTENT_REDACTED\")"}
}

extension CreateReplicationConfigurationTemplateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associateDefaultSecurityGroup
        case autoReplicateNewDisks
        case bandwidthThrottling
        case createPublicIP
        case dataPlaneRouting
        case defaultLargeStagingDiskType
        case ebsEncryption
        case ebsEncryptionKeyArn
        case pitPolicy
        case replicationServerInstanceType
        case replicationServersSecurityGroupsIDs
        case stagingAreaSubnetId
        case stagingAreaTags
        case tags
        case useDedicatedReplicationServer
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let associateDefaultSecurityGroup = self.associateDefaultSecurityGroup {
            try encodeContainer.encode(associateDefaultSecurityGroup, forKey: .associateDefaultSecurityGroup)
        }
        if let autoReplicateNewDisks = self.autoReplicateNewDisks {
            try encodeContainer.encode(autoReplicateNewDisks, forKey: .autoReplicateNewDisks)
        }
        if bandwidthThrottling != 0 {
            try encodeContainer.encode(bandwidthThrottling, forKey: .bandwidthThrottling)
        }
        if let createPublicIP = self.createPublicIP {
            try encodeContainer.encode(createPublicIP, forKey: .createPublicIP)
        }
        if let dataPlaneRouting = self.dataPlaneRouting {
            try encodeContainer.encode(dataPlaneRouting.rawValue, forKey: .dataPlaneRouting)
        }
        if let defaultLargeStagingDiskType = self.defaultLargeStagingDiskType {
            try encodeContainer.encode(defaultLargeStagingDiskType.rawValue, forKey: .defaultLargeStagingDiskType)
        }
        if let ebsEncryption = self.ebsEncryption {
            try encodeContainer.encode(ebsEncryption.rawValue, forKey: .ebsEncryption)
        }
        if let ebsEncryptionKeyArn = self.ebsEncryptionKeyArn {
            try encodeContainer.encode(ebsEncryptionKeyArn, forKey: .ebsEncryptionKeyArn)
        }
        if let pitPolicy = pitPolicy {
            var pitPolicyContainer = encodeContainer.nestedUnkeyedContainer(forKey: .pitPolicy)
            for pitpolicyrule0 in pitPolicy {
                try pitPolicyContainer.encode(pitpolicyrule0)
            }
        }
        if let replicationServerInstanceType = self.replicationServerInstanceType {
            try encodeContainer.encode(replicationServerInstanceType, forKey: .replicationServerInstanceType)
        }
        if let replicationServersSecurityGroupsIDs = replicationServersSecurityGroupsIDs {
            var replicationServersSecurityGroupsIDsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .replicationServersSecurityGroupsIDs)
            for securitygroupid0 in replicationServersSecurityGroupsIDs {
                try replicationServersSecurityGroupsIDsContainer.encode(securitygroupid0)
            }
        }
        if let stagingAreaSubnetId = self.stagingAreaSubnetId {
            try encodeContainer.encode(stagingAreaSubnetId, forKey: .stagingAreaSubnetId)
        }
        if let stagingAreaTags = stagingAreaTags {
            var stagingAreaTagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .stagingAreaTags)
            for (dictKey0, tagsMap0) in stagingAreaTags {
                try stagingAreaTagsContainer.encode(tagsMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagsMap0) in tags {
                try tagsContainer.encode(tagsMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let useDedicatedReplicationServer = self.useDedicatedReplicationServer {
            try encodeContainer.encode(useDedicatedReplicationServer, forKey: .useDedicatedReplicationServer)
        }
    }
}

extension CreateReplicationConfigurationTemplateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/CreateReplicationConfigurationTemplate"
    }
}

public struct CreateReplicationConfigurationTemplateInput: Swift.Equatable {
    /// Whether to associate the default Elastic Disaster Recovery Security group with the Replication Configuration Template.
    /// This member is required.
    public var associateDefaultSecurityGroup: Swift.Bool?
    /// Whether to allow the AWS replication agent to automatically replicate newly added disks.
    public var autoReplicateNewDisks: Swift.Bool?
    /// Configure bandwidth throttling for the outbound data transfer rate of the Source Server in Mbps.
    /// This member is required.
    public var bandwidthThrottling: Swift.Int
    /// Whether to create a Public IP for the Recovery Instance by default.
    /// This member is required.
    public var createPublicIP: Swift.Bool?
    /// The data plane routing mechanism that will be used for replication.
    /// This member is required.
    public var dataPlaneRouting: DrsClientTypes.ReplicationConfigurationDataPlaneRouting?
    /// The Staging Disk EBS volume type to be used during replication.
    /// This member is required.
    public var defaultLargeStagingDiskType: DrsClientTypes.ReplicationConfigurationDefaultLargeStagingDiskType?
    /// The type of EBS encryption to be used during replication.
    /// This member is required.
    public var ebsEncryption: DrsClientTypes.ReplicationConfigurationEbsEncryption?
    /// The ARN of the EBS encryption key to be used during replication.
    public var ebsEncryptionKeyArn: Swift.String?
    /// The Point in time (PIT) policy to manage snapshots taken during replication.
    /// This member is required.
    public var pitPolicy: [DrsClientTypes.PITPolicyRule]?
    /// The instance type to be used for the replication server.
    /// This member is required.
    public var replicationServerInstanceType: Swift.String?
    /// The security group IDs that will be used by the replication server.
    /// This member is required.
    public var replicationServersSecurityGroupsIDs: [Swift.String]?
    /// The subnet to be used by the replication staging area.
    /// This member is required.
    public var stagingAreaSubnetId: Swift.String?
    /// A set of tags to be associated with all resources created in the replication staging area: EC2 replication server, EBS volumes, EBS snapshots, etc.
    /// This member is required.
    public var stagingAreaTags: [Swift.String:Swift.String]?
    /// A set of tags to be associated with the Replication Configuration Template resource.
    public var tags: [Swift.String:Swift.String]?
    /// Whether to use a dedicated Replication Server in the replication staging area.
    /// This member is required.
    public var useDedicatedReplicationServer: Swift.Bool?

    public init(
        associateDefaultSecurityGroup: Swift.Bool? = nil,
        autoReplicateNewDisks: Swift.Bool? = nil,
        bandwidthThrottling: Swift.Int = 0,
        createPublicIP: Swift.Bool? = nil,
        dataPlaneRouting: DrsClientTypes.ReplicationConfigurationDataPlaneRouting? = nil,
        defaultLargeStagingDiskType: DrsClientTypes.ReplicationConfigurationDefaultLargeStagingDiskType? = nil,
        ebsEncryption: DrsClientTypes.ReplicationConfigurationEbsEncryption? = nil,
        ebsEncryptionKeyArn: Swift.String? = nil,
        pitPolicy: [DrsClientTypes.PITPolicyRule]? = nil,
        replicationServerInstanceType: Swift.String? = nil,
        replicationServersSecurityGroupsIDs: [Swift.String]? = nil,
        stagingAreaSubnetId: Swift.String? = nil,
        stagingAreaTags: [Swift.String:Swift.String]? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        useDedicatedReplicationServer: Swift.Bool? = nil
    )
    {
        self.associateDefaultSecurityGroup = associateDefaultSecurityGroup
        self.autoReplicateNewDisks = autoReplicateNewDisks
        self.bandwidthThrottling = bandwidthThrottling
        self.createPublicIP = createPublicIP
        self.dataPlaneRouting = dataPlaneRouting
        self.defaultLargeStagingDiskType = defaultLargeStagingDiskType
        self.ebsEncryption = ebsEncryption
        self.ebsEncryptionKeyArn = ebsEncryptionKeyArn
        self.pitPolicy = pitPolicy
        self.replicationServerInstanceType = replicationServerInstanceType
        self.replicationServersSecurityGroupsIDs = replicationServersSecurityGroupsIDs
        self.stagingAreaSubnetId = stagingAreaSubnetId
        self.stagingAreaTags = stagingAreaTags
        self.tags = tags
        self.useDedicatedReplicationServer = useDedicatedReplicationServer
    }
}

struct CreateReplicationConfigurationTemplateInputBody: Swift.Equatable {
    let stagingAreaSubnetId: Swift.String?
    let associateDefaultSecurityGroup: Swift.Bool?
    let replicationServersSecurityGroupsIDs: [Swift.String]?
    let replicationServerInstanceType: Swift.String?
    let useDedicatedReplicationServer: Swift.Bool?
    let defaultLargeStagingDiskType: DrsClientTypes.ReplicationConfigurationDefaultLargeStagingDiskType?
    let ebsEncryption: DrsClientTypes.ReplicationConfigurationEbsEncryption?
    let ebsEncryptionKeyArn: Swift.String?
    let bandwidthThrottling: Swift.Int
    let dataPlaneRouting: DrsClientTypes.ReplicationConfigurationDataPlaneRouting?
    let createPublicIP: Swift.Bool?
    let stagingAreaTags: [Swift.String:Swift.String]?
    let pitPolicy: [DrsClientTypes.PITPolicyRule]?
    let tags: [Swift.String:Swift.String]?
    let autoReplicateNewDisks: Swift.Bool?
}

extension CreateReplicationConfigurationTemplateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associateDefaultSecurityGroup
        case autoReplicateNewDisks
        case bandwidthThrottling
        case createPublicIP
        case dataPlaneRouting
        case defaultLargeStagingDiskType
        case ebsEncryption
        case ebsEncryptionKeyArn
        case pitPolicy
        case replicationServerInstanceType
        case replicationServersSecurityGroupsIDs
        case stagingAreaSubnetId
        case stagingAreaTags
        case tags
        case useDedicatedReplicationServer
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stagingAreaSubnetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stagingAreaSubnetId)
        stagingAreaSubnetId = stagingAreaSubnetIdDecoded
        let associateDefaultSecurityGroupDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .associateDefaultSecurityGroup)
        associateDefaultSecurityGroup = associateDefaultSecurityGroupDecoded
        let replicationServersSecurityGroupsIDsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .replicationServersSecurityGroupsIDs)
        var replicationServersSecurityGroupsIDsDecoded0:[Swift.String]? = nil
        if let replicationServersSecurityGroupsIDsContainer = replicationServersSecurityGroupsIDsContainer {
            replicationServersSecurityGroupsIDsDecoded0 = [Swift.String]()
            for string0 in replicationServersSecurityGroupsIDsContainer {
                if let string0 = string0 {
                    replicationServersSecurityGroupsIDsDecoded0?.append(string0)
                }
            }
        }
        replicationServersSecurityGroupsIDs = replicationServersSecurityGroupsIDsDecoded0
        let replicationServerInstanceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationServerInstanceType)
        replicationServerInstanceType = replicationServerInstanceTypeDecoded
        let useDedicatedReplicationServerDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .useDedicatedReplicationServer)
        useDedicatedReplicationServer = useDedicatedReplicationServerDecoded
        let defaultLargeStagingDiskTypeDecoded = try containerValues.decodeIfPresent(DrsClientTypes.ReplicationConfigurationDefaultLargeStagingDiskType.self, forKey: .defaultLargeStagingDiskType)
        defaultLargeStagingDiskType = defaultLargeStagingDiskTypeDecoded
        let ebsEncryptionDecoded = try containerValues.decodeIfPresent(DrsClientTypes.ReplicationConfigurationEbsEncryption.self, forKey: .ebsEncryption)
        ebsEncryption = ebsEncryptionDecoded
        let ebsEncryptionKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ebsEncryptionKeyArn)
        ebsEncryptionKeyArn = ebsEncryptionKeyArnDecoded
        let bandwidthThrottlingDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .bandwidthThrottling) ?? 0
        bandwidthThrottling = bandwidthThrottlingDecoded
        let dataPlaneRoutingDecoded = try containerValues.decodeIfPresent(DrsClientTypes.ReplicationConfigurationDataPlaneRouting.self, forKey: .dataPlaneRouting)
        dataPlaneRouting = dataPlaneRoutingDecoded
        let createPublicIPDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .createPublicIP)
        createPublicIP = createPublicIPDecoded
        let stagingAreaTagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .stagingAreaTags)
        var stagingAreaTagsDecoded0: [Swift.String:Swift.String]? = nil
        if let stagingAreaTagsContainer = stagingAreaTagsContainer {
            stagingAreaTagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in stagingAreaTagsContainer {
                if let tagvalue0 = tagvalue0 {
                    stagingAreaTagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        stagingAreaTags = stagingAreaTagsDecoded0
        let pitPolicyContainer = try containerValues.decodeIfPresent([DrsClientTypes.PITPolicyRule?].self, forKey: .pitPolicy)
        var pitPolicyDecoded0:[DrsClientTypes.PITPolicyRule]? = nil
        if let pitPolicyContainer = pitPolicyContainer {
            pitPolicyDecoded0 = [DrsClientTypes.PITPolicyRule]()
            for structure0 in pitPolicyContainer {
                if let structure0 = structure0 {
                    pitPolicyDecoded0?.append(structure0)
                }
            }
        }
        pitPolicy = pitPolicyDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let autoReplicateNewDisksDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .autoReplicateNewDisks)
        autoReplicateNewDisks = autoReplicateNewDisksDecoded
    }
}

extension CreateReplicationConfigurationTemplateOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateReplicationConfigurationTemplateOutput(arn: \(Swift.String(describing: arn)), associateDefaultSecurityGroup: \(Swift.String(describing: associateDefaultSecurityGroup)), autoReplicateNewDisks: \(Swift.String(describing: autoReplicateNewDisks)), bandwidthThrottling: \(Swift.String(describing: bandwidthThrottling)), createPublicIP: \(Swift.String(describing: createPublicIP)), dataPlaneRouting: \(Swift.String(describing: dataPlaneRouting)), defaultLargeStagingDiskType: \(Swift.String(describing: defaultLargeStagingDiskType)), ebsEncryption: \(Swift.String(describing: ebsEncryption)), ebsEncryptionKeyArn: \(Swift.String(describing: ebsEncryptionKeyArn)), pitPolicy: \(Swift.String(describing: pitPolicy)), replicationConfigurationTemplateID: \(Swift.String(describing: replicationConfigurationTemplateID)), replicationServerInstanceType: \(Swift.String(describing: replicationServerInstanceType)), replicationServersSecurityGroupsIDs: \(Swift.String(describing: replicationServersSecurityGroupsIDs)), stagingAreaSubnetId: \(Swift.String(describing: stagingAreaSubnetId)), useDedicatedReplicationServer: \(Swift.String(describing: useDedicatedReplicationServer)), stagingAreaTags: \"CONTENT_REDACTED\", tags: \"CONTENT_REDACTED\")"}
}

extension CreateReplicationConfigurationTemplateOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateReplicationConfigurationTemplateOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.associateDefaultSecurityGroup = output.associateDefaultSecurityGroup
            self.autoReplicateNewDisks = output.autoReplicateNewDisks
            self.bandwidthThrottling = output.bandwidthThrottling
            self.createPublicIP = output.createPublicIP
            self.dataPlaneRouting = output.dataPlaneRouting
            self.defaultLargeStagingDiskType = output.defaultLargeStagingDiskType
            self.ebsEncryption = output.ebsEncryption
            self.ebsEncryptionKeyArn = output.ebsEncryptionKeyArn
            self.pitPolicy = output.pitPolicy
            self.replicationConfigurationTemplateID = output.replicationConfigurationTemplateID
            self.replicationServerInstanceType = output.replicationServerInstanceType
            self.replicationServersSecurityGroupsIDs = output.replicationServersSecurityGroupsIDs
            self.stagingAreaSubnetId = output.stagingAreaSubnetId
            self.stagingAreaTags = output.stagingAreaTags
            self.tags = output.tags
            self.useDedicatedReplicationServer = output.useDedicatedReplicationServer
        } else {
            self.arn = nil
            self.associateDefaultSecurityGroup = nil
            self.autoReplicateNewDisks = nil
            self.bandwidthThrottling = 0
            self.createPublicIP = nil
            self.dataPlaneRouting = nil
            self.defaultLargeStagingDiskType = nil
            self.ebsEncryption = nil
            self.ebsEncryptionKeyArn = nil
            self.pitPolicy = nil
            self.replicationConfigurationTemplateID = nil
            self.replicationServerInstanceType = nil
            self.replicationServersSecurityGroupsIDs = nil
            self.stagingAreaSubnetId = nil
            self.stagingAreaTags = nil
            self.tags = nil
            self.useDedicatedReplicationServer = nil
        }
    }
}

public struct CreateReplicationConfigurationTemplateOutput: Swift.Equatable {
    /// The Replication Configuration Template ARN.
    public var arn: Swift.String?
    /// Whether to associate the default Elastic Disaster Recovery Security group with the Replication Configuration Template.
    public var associateDefaultSecurityGroup: Swift.Bool?
    /// Whether to allow the AWS replication agent to automatically replicate newly added disks.
    public var autoReplicateNewDisks: Swift.Bool?
    /// Configure bandwidth throttling for the outbound data transfer rate of the Source Server in Mbps.
    public var bandwidthThrottling: Swift.Int
    /// Whether to create a Public IP for the Recovery Instance by default.
    public var createPublicIP: Swift.Bool?
    /// The data plane routing mechanism that will be used for replication.
    public var dataPlaneRouting: DrsClientTypes.ReplicationConfigurationDataPlaneRouting?
    /// The Staging Disk EBS volume type to be used during replication.
    public var defaultLargeStagingDiskType: DrsClientTypes.ReplicationConfigurationDefaultLargeStagingDiskType?
    /// The type of EBS encryption to be used during replication.
    public var ebsEncryption: DrsClientTypes.ReplicationConfigurationEbsEncryption?
    /// The ARN of the EBS encryption key to be used during replication.
    public var ebsEncryptionKeyArn: Swift.String?
    /// The Point in time (PIT) policy to manage snapshots taken during replication.
    public var pitPolicy: [DrsClientTypes.PITPolicyRule]?
    /// The Replication Configuration Template ID.
    /// This member is required.
    public var replicationConfigurationTemplateID: Swift.String?
    /// The instance type to be used for the replication server.
    public var replicationServerInstanceType: Swift.String?
    /// The security group IDs that will be used by the replication server.
    public var replicationServersSecurityGroupsIDs: [Swift.String]?
    /// The subnet to be used by the replication staging area.
    public var stagingAreaSubnetId: Swift.String?
    /// A set of tags to be associated with all resources created in the replication staging area: EC2 replication server, EBS volumes, EBS snapshots, etc.
    public var stagingAreaTags: [Swift.String:Swift.String]?
    /// A set of tags to be associated with the Replication Configuration Template resource.
    public var tags: [Swift.String:Swift.String]?
    /// Whether to use a dedicated Replication Server in the replication staging area.
    public var useDedicatedReplicationServer: Swift.Bool?

    public init(
        arn: Swift.String? = nil,
        associateDefaultSecurityGroup: Swift.Bool? = nil,
        autoReplicateNewDisks: Swift.Bool? = nil,
        bandwidthThrottling: Swift.Int = 0,
        createPublicIP: Swift.Bool? = nil,
        dataPlaneRouting: DrsClientTypes.ReplicationConfigurationDataPlaneRouting? = nil,
        defaultLargeStagingDiskType: DrsClientTypes.ReplicationConfigurationDefaultLargeStagingDiskType? = nil,
        ebsEncryption: DrsClientTypes.ReplicationConfigurationEbsEncryption? = nil,
        ebsEncryptionKeyArn: Swift.String? = nil,
        pitPolicy: [DrsClientTypes.PITPolicyRule]? = nil,
        replicationConfigurationTemplateID: Swift.String? = nil,
        replicationServerInstanceType: Swift.String? = nil,
        replicationServersSecurityGroupsIDs: [Swift.String]? = nil,
        stagingAreaSubnetId: Swift.String? = nil,
        stagingAreaTags: [Swift.String:Swift.String]? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        useDedicatedReplicationServer: Swift.Bool? = nil
    )
    {
        self.arn = arn
        self.associateDefaultSecurityGroup = associateDefaultSecurityGroup
        self.autoReplicateNewDisks = autoReplicateNewDisks
        self.bandwidthThrottling = bandwidthThrottling
        self.createPublicIP = createPublicIP
        self.dataPlaneRouting = dataPlaneRouting
        self.defaultLargeStagingDiskType = defaultLargeStagingDiskType
        self.ebsEncryption = ebsEncryption
        self.ebsEncryptionKeyArn = ebsEncryptionKeyArn
        self.pitPolicy = pitPolicy
        self.replicationConfigurationTemplateID = replicationConfigurationTemplateID
        self.replicationServerInstanceType = replicationServerInstanceType
        self.replicationServersSecurityGroupsIDs = replicationServersSecurityGroupsIDs
        self.stagingAreaSubnetId = stagingAreaSubnetId
        self.stagingAreaTags = stagingAreaTags
        self.tags = tags
        self.useDedicatedReplicationServer = useDedicatedReplicationServer
    }
}

struct CreateReplicationConfigurationTemplateOutputBody: Swift.Equatable {
    let replicationConfigurationTemplateID: Swift.String?
    let arn: Swift.String?
    let stagingAreaSubnetId: Swift.String?
    let associateDefaultSecurityGroup: Swift.Bool?
    let replicationServersSecurityGroupsIDs: [Swift.String]?
    let replicationServerInstanceType: Swift.String?
    let useDedicatedReplicationServer: Swift.Bool?
    let defaultLargeStagingDiskType: DrsClientTypes.ReplicationConfigurationDefaultLargeStagingDiskType?
    let ebsEncryption: DrsClientTypes.ReplicationConfigurationEbsEncryption?
    let ebsEncryptionKeyArn: Swift.String?
    let bandwidthThrottling: Swift.Int
    let dataPlaneRouting: DrsClientTypes.ReplicationConfigurationDataPlaneRouting?
    let createPublicIP: Swift.Bool?
    let stagingAreaTags: [Swift.String:Swift.String]?
    let tags: [Swift.String:Swift.String]?
    let pitPolicy: [DrsClientTypes.PITPolicyRule]?
    let autoReplicateNewDisks: Swift.Bool?
}

extension CreateReplicationConfigurationTemplateOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case associateDefaultSecurityGroup
        case autoReplicateNewDisks
        case bandwidthThrottling
        case createPublicIP
        case dataPlaneRouting
        case defaultLargeStagingDiskType
        case ebsEncryption
        case ebsEncryptionKeyArn
        case pitPolicy
        case replicationConfigurationTemplateID
        case replicationServerInstanceType
        case replicationServersSecurityGroupsIDs
        case stagingAreaSubnetId
        case stagingAreaTags
        case tags
        case useDedicatedReplicationServer
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationConfigurationTemplateIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationConfigurationTemplateID)
        replicationConfigurationTemplateID = replicationConfigurationTemplateIDDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let stagingAreaSubnetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stagingAreaSubnetId)
        stagingAreaSubnetId = stagingAreaSubnetIdDecoded
        let associateDefaultSecurityGroupDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .associateDefaultSecurityGroup)
        associateDefaultSecurityGroup = associateDefaultSecurityGroupDecoded
        let replicationServersSecurityGroupsIDsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .replicationServersSecurityGroupsIDs)
        var replicationServersSecurityGroupsIDsDecoded0:[Swift.String]? = nil
        if let replicationServersSecurityGroupsIDsContainer = replicationServersSecurityGroupsIDsContainer {
            replicationServersSecurityGroupsIDsDecoded0 = [Swift.String]()
            for string0 in replicationServersSecurityGroupsIDsContainer {
                if let string0 = string0 {
                    replicationServersSecurityGroupsIDsDecoded0?.append(string0)
                }
            }
        }
        replicationServersSecurityGroupsIDs = replicationServersSecurityGroupsIDsDecoded0
        let replicationServerInstanceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationServerInstanceType)
        replicationServerInstanceType = replicationServerInstanceTypeDecoded
        let useDedicatedReplicationServerDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .useDedicatedReplicationServer)
        useDedicatedReplicationServer = useDedicatedReplicationServerDecoded
        let defaultLargeStagingDiskTypeDecoded = try containerValues.decodeIfPresent(DrsClientTypes.ReplicationConfigurationDefaultLargeStagingDiskType.self, forKey: .defaultLargeStagingDiskType)
        defaultLargeStagingDiskType = defaultLargeStagingDiskTypeDecoded
        let ebsEncryptionDecoded = try containerValues.decodeIfPresent(DrsClientTypes.ReplicationConfigurationEbsEncryption.self, forKey: .ebsEncryption)
        ebsEncryption = ebsEncryptionDecoded
        let ebsEncryptionKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ebsEncryptionKeyArn)
        ebsEncryptionKeyArn = ebsEncryptionKeyArnDecoded
        let bandwidthThrottlingDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .bandwidthThrottling) ?? 0
        bandwidthThrottling = bandwidthThrottlingDecoded
        let dataPlaneRoutingDecoded = try containerValues.decodeIfPresent(DrsClientTypes.ReplicationConfigurationDataPlaneRouting.self, forKey: .dataPlaneRouting)
        dataPlaneRouting = dataPlaneRoutingDecoded
        let createPublicIPDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .createPublicIP)
        createPublicIP = createPublicIPDecoded
        let stagingAreaTagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .stagingAreaTags)
        var stagingAreaTagsDecoded0: [Swift.String:Swift.String]? = nil
        if let stagingAreaTagsContainer = stagingAreaTagsContainer {
            stagingAreaTagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in stagingAreaTagsContainer {
                if let tagvalue0 = tagvalue0 {
                    stagingAreaTagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        stagingAreaTags = stagingAreaTagsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let pitPolicyContainer = try containerValues.decodeIfPresent([DrsClientTypes.PITPolicyRule?].self, forKey: .pitPolicy)
        var pitPolicyDecoded0:[DrsClientTypes.PITPolicyRule]? = nil
        if let pitPolicyContainer = pitPolicyContainer {
            pitPolicyDecoded0 = [DrsClientTypes.PITPolicyRule]()
            for structure0 in pitPolicyContainer {
                if let structure0 = structure0 {
                    pitPolicyDecoded0?.append(structure0)
                }
            }
        }
        pitPolicy = pitPolicyDecoded0
        let autoReplicateNewDisksDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .autoReplicateNewDisks)
        autoReplicateNewDisks = autoReplicateNewDisksDecoded
    }
}

enum CreateReplicationConfigurationTemplateOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UninitializedAccountException": return try await UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateSourceNetworkInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateSourceNetworkInput(originAccountID: \(Swift.String(describing: originAccountID)), originRegion: \(Swift.String(describing: originRegion)), vpcID: \(Swift.String(describing: vpcID)), tags: \"CONTENT_REDACTED\")"}
}

extension CreateSourceNetworkInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case originAccountID
        case originRegion
        case tags
        case vpcID
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let originAccountID = self.originAccountID {
            try encodeContainer.encode(originAccountID, forKey: .originAccountID)
        }
        if let originRegion = self.originRegion {
            try encodeContainer.encode(originRegion, forKey: .originRegion)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagsMap0) in tags {
                try tagsContainer.encode(tagsMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let vpcID = self.vpcID {
            try encodeContainer.encode(vpcID, forKey: .vpcID)
        }
    }
}

extension CreateSourceNetworkInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/CreateSourceNetwork"
    }
}

public struct CreateSourceNetworkInput: Swift.Equatable {
    /// Account containing the VPC to protect.
    /// This member is required.
    public var originAccountID: Swift.String?
    /// Region containing the VPC to protect.
    /// This member is required.
    public var originRegion: Swift.String?
    /// A set of tags to be associated with the Source Network resource.
    public var tags: [Swift.String:Swift.String]?
    /// Which VPC ID to protect.
    /// This member is required.
    public var vpcID: Swift.String?

    public init(
        originAccountID: Swift.String? = nil,
        originRegion: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        vpcID: Swift.String? = nil
    )
    {
        self.originAccountID = originAccountID
        self.originRegion = originRegion
        self.tags = tags
        self.vpcID = vpcID
    }
}

struct CreateSourceNetworkInputBody: Swift.Equatable {
    let vpcID: Swift.String?
    let originAccountID: Swift.String?
    let originRegion: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateSourceNetworkInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case originAccountID
        case originRegion
        case tags
        case vpcID
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let vpcIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcID)
        vpcID = vpcIDDecoded
        let originAccountIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .originAccountID)
        originAccountID = originAccountIDDecoded
        let originRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .originRegion)
        originRegion = originRegionDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateSourceNetworkOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateSourceNetworkOutputBody = try responseDecoder.decode(responseBody: data)
            self.sourceNetworkID = output.sourceNetworkID
        } else {
            self.sourceNetworkID = nil
        }
    }
}

public struct CreateSourceNetworkOutput: Swift.Equatable {
    /// ID of the created Source Network.
    public var sourceNetworkID: Swift.String?

    public init(
        sourceNetworkID: Swift.String? = nil
    )
    {
        self.sourceNetworkID = sourceNetworkID
    }
}

struct CreateSourceNetworkOutputBody: Swift.Equatable {
    let sourceNetworkID: Swift.String?
}

extension CreateSourceNetworkOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sourceNetworkID
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceNetworkIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceNetworkID)
        sourceNetworkID = sourceNetworkIDDecoded
    }
}

enum CreateSourceNetworkOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UninitializedAccountException": return try await UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DrsClientTypes.DataReplicationError: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case error
        case rawError
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let error = self.error {
            try encodeContainer.encode(error.rawValue, forKey: .error)
        }
        if let rawError = self.rawError {
            try encodeContainer.encode(rawError, forKey: .rawError)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorDecoded = try containerValues.decodeIfPresent(DrsClientTypes.DataReplicationErrorString.self, forKey: .error)
        error = errorDecoded
        let rawErrorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .rawError)
        rawError = rawErrorDecoded
    }
}

extension DrsClientTypes {
    /// Error in data replication.
    public struct DataReplicationError: Swift.Equatable {
        /// Error in data replication.
        public var error: DrsClientTypes.DataReplicationErrorString?
        /// Error in data replication.
        public var rawError: Swift.String?

        public init(
            error: DrsClientTypes.DataReplicationErrorString? = nil,
            rawError: Swift.String? = nil
        )
        {
            self.error = error
            self.rawError = rawError
        }
    }

}

extension DrsClientTypes {
    public enum DataReplicationErrorString: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case agentNotSeen
        case failedToAttachStagingDisks
        case failedToAuthenticateWithService
        case failedToBootReplicationServer
        case failedToConnectAgentToReplicationServer
        case failedToCreateSecurityGroup
        case failedToCreateStagingDisks
        case failedToDownloadReplicationSoftware
        case failedToLaunchReplicationServer
        case failedToPairReplicationServerWithAgent
        case failedToStartDataTransfer
        case notConverging
        case snapshotsFailure
        case unstableNetwork
        case sdkUnknown(Swift.String)

        public static var allCases: [DataReplicationErrorString] {
            return [
                .agentNotSeen,
                .failedToAttachStagingDisks,
                .failedToAuthenticateWithService,
                .failedToBootReplicationServer,
                .failedToConnectAgentToReplicationServer,
                .failedToCreateSecurityGroup,
                .failedToCreateStagingDisks,
                .failedToDownloadReplicationSoftware,
                .failedToLaunchReplicationServer,
                .failedToPairReplicationServerWithAgent,
                .failedToStartDataTransfer,
                .notConverging,
                .snapshotsFailure,
                .unstableNetwork,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .agentNotSeen: return "AGENT_NOT_SEEN"
            case .failedToAttachStagingDisks: return "FAILED_TO_ATTACH_STAGING_DISKS"
            case .failedToAuthenticateWithService: return "FAILED_TO_AUTHENTICATE_WITH_SERVICE"
            case .failedToBootReplicationServer: return "FAILED_TO_BOOT_REPLICATION_SERVER"
            case .failedToConnectAgentToReplicationServer: return "FAILED_TO_CONNECT_AGENT_TO_REPLICATION_SERVER"
            case .failedToCreateSecurityGroup: return "FAILED_TO_CREATE_SECURITY_GROUP"
            case .failedToCreateStagingDisks: return "FAILED_TO_CREATE_STAGING_DISKS"
            case .failedToDownloadReplicationSoftware: return "FAILED_TO_DOWNLOAD_REPLICATION_SOFTWARE"
            case .failedToLaunchReplicationServer: return "FAILED_TO_LAUNCH_REPLICATION_SERVER"
            case .failedToPairReplicationServerWithAgent: return "FAILED_TO_PAIR_REPLICATION_SERVER_WITH_AGENT"
            case .failedToStartDataTransfer: return "FAILED_TO_START_DATA_TRANSFER"
            case .notConverging: return "NOT_CONVERGING"
            case .snapshotsFailure: return "SNAPSHOTS_FAILURE"
            case .unstableNetwork: return "UNSTABLE_NETWORK"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DataReplicationErrorString(rawValue: rawValue) ?? DataReplicationErrorString.sdkUnknown(rawValue)
        }
    }
}

extension DrsClientTypes.DataReplicationInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataReplicationError
        case dataReplicationInitiation
        case dataReplicationState
        case etaDateTime
        case lagDuration
        case replicatedDisks
        case stagingAvailabilityZone
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataReplicationError = self.dataReplicationError {
            try encodeContainer.encode(dataReplicationError, forKey: .dataReplicationError)
        }
        if let dataReplicationInitiation = self.dataReplicationInitiation {
            try encodeContainer.encode(dataReplicationInitiation, forKey: .dataReplicationInitiation)
        }
        if let dataReplicationState = self.dataReplicationState {
            try encodeContainer.encode(dataReplicationState.rawValue, forKey: .dataReplicationState)
        }
        if let etaDateTime = self.etaDateTime {
            try encodeContainer.encode(etaDateTime, forKey: .etaDateTime)
        }
        if let lagDuration = self.lagDuration {
            try encodeContainer.encode(lagDuration, forKey: .lagDuration)
        }
        if let replicatedDisks = replicatedDisks {
            var replicatedDisksContainer = encodeContainer.nestedUnkeyedContainer(forKey: .replicatedDisks)
            for datareplicationinforeplicateddisk0 in replicatedDisks {
                try replicatedDisksContainer.encode(datareplicationinforeplicateddisk0)
            }
        }
        if let stagingAvailabilityZone = self.stagingAvailabilityZone {
            try encodeContainer.encode(stagingAvailabilityZone, forKey: .stagingAvailabilityZone)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lagDurationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lagDuration)
        lagDuration = lagDurationDecoded
        let etaDateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .etaDateTime)
        etaDateTime = etaDateTimeDecoded
        let replicatedDisksContainer = try containerValues.decodeIfPresent([DrsClientTypes.DataReplicationInfoReplicatedDisk?].self, forKey: .replicatedDisks)
        var replicatedDisksDecoded0:[DrsClientTypes.DataReplicationInfoReplicatedDisk]? = nil
        if let replicatedDisksContainer = replicatedDisksContainer {
            replicatedDisksDecoded0 = [DrsClientTypes.DataReplicationInfoReplicatedDisk]()
            for structure0 in replicatedDisksContainer {
                if let structure0 = structure0 {
                    replicatedDisksDecoded0?.append(structure0)
                }
            }
        }
        replicatedDisks = replicatedDisksDecoded0
        let dataReplicationStateDecoded = try containerValues.decodeIfPresent(DrsClientTypes.DataReplicationState.self, forKey: .dataReplicationState)
        dataReplicationState = dataReplicationStateDecoded
        let dataReplicationInitiationDecoded = try containerValues.decodeIfPresent(DrsClientTypes.DataReplicationInitiation.self, forKey: .dataReplicationInitiation)
        dataReplicationInitiation = dataReplicationInitiationDecoded
        let dataReplicationErrorDecoded = try containerValues.decodeIfPresent(DrsClientTypes.DataReplicationError.self, forKey: .dataReplicationError)
        dataReplicationError = dataReplicationErrorDecoded
        let stagingAvailabilityZoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stagingAvailabilityZone)
        stagingAvailabilityZone = stagingAvailabilityZoneDecoded
    }
}

extension DrsClientTypes {
    /// Information about Data Replication
    public struct DataReplicationInfo: Swift.Equatable {
        /// Error in data replication.
        public var dataReplicationError: DrsClientTypes.DataReplicationError?
        /// Information about whether the data replication has been initiated.
        public var dataReplicationInitiation: DrsClientTypes.DataReplicationInitiation?
        /// The state of the data replication.
        public var dataReplicationState: DrsClientTypes.DataReplicationState?
        /// An estimate of when the data replication will be completed.
        public var etaDateTime: Swift.String?
        /// Data replication lag duration.
        public var lagDuration: Swift.String?
        /// The disks that should be replicated.
        public var replicatedDisks: [DrsClientTypes.DataReplicationInfoReplicatedDisk]?
        /// AWS Availability zone into which data is being replicated.
        public var stagingAvailabilityZone: Swift.String?

        public init(
            dataReplicationError: DrsClientTypes.DataReplicationError? = nil,
            dataReplicationInitiation: DrsClientTypes.DataReplicationInitiation? = nil,
            dataReplicationState: DrsClientTypes.DataReplicationState? = nil,
            etaDateTime: Swift.String? = nil,
            lagDuration: Swift.String? = nil,
            replicatedDisks: [DrsClientTypes.DataReplicationInfoReplicatedDisk]? = nil,
            stagingAvailabilityZone: Swift.String? = nil
        )
        {
            self.dataReplicationError = dataReplicationError
            self.dataReplicationInitiation = dataReplicationInitiation
            self.dataReplicationState = dataReplicationState
            self.etaDateTime = etaDateTime
            self.lagDuration = lagDuration
            self.replicatedDisks = replicatedDisks
            self.stagingAvailabilityZone = stagingAvailabilityZone
        }
    }

}

extension DrsClientTypes.DataReplicationInfoReplicatedDisk: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backloggedStorageBytes
        case deviceName
        case replicatedStorageBytes
        case rescannedStorageBytes
        case totalStorageBytes
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if backloggedStorageBytes != 0 {
            try encodeContainer.encode(backloggedStorageBytes, forKey: .backloggedStorageBytes)
        }
        if let deviceName = self.deviceName {
            try encodeContainer.encode(deviceName, forKey: .deviceName)
        }
        if replicatedStorageBytes != 0 {
            try encodeContainer.encode(replicatedStorageBytes, forKey: .replicatedStorageBytes)
        }
        if rescannedStorageBytes != 0 {
            try encodeContainer.encode(rescannedStorageBytes, forKey: .rescannedStorageBytes)
        }
        if totalStorageBytes != 0 {
            try encodeContainer.encode(totalStorageBytes, forKey: .totalStorageBytes)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceName)
        deviceName = deviceNameDecoded
        let totalStorageBytesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalStorageBytes) ?? 0
        totalStorageBytes = totalStorageBytesDecoded
        let replicatedStorageBytesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .replicatedStorageBytes) ?? 0
        replicatedStorageBytes = replicatedStorageBytesDecoded
        let rescannedStorageBytesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .rescannedStorageBytes) ?? 0
        rescannedStorageBytes = rescannedStorageBytesDecoded
        let backloggedStorageBytesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .backloggedStorageBytes) ?? 0
        backloggedStorageBytes = backloggedStorageBytesDecoded
    }
}

extension DrsClientTypes {
    /// A disk that should be replicated.
    public struct DataReplicationInfoReplicatedDisk: Swift.Equatable {
        /// The size of the replication backlog in bytes.
        public var backloggedStorageBytes: Swift.Int
        /// The name of the device.
        public var deviceName: Swift.String?
        /// The amount of data replicated so far in bytes.
        public var replicatedStorageBytes: Swift.Int
        /// The amount of data to be rescanned in bytes.
        public var rescannedStorageBytes: Swift.Int
        /// The total amount of data to be replicated in bytes.
        public var totalStorageBytes: Swift.Int

        public init(
            backloggedStorageBytes: Swift.Int = 0,
            deviceName: Swift.String? = nil,
            replicatedStorageBytes: Swift.Int = 0,
            rescannedStorageBytes: Swift.Int = 0,
            totalStorageBytes: Swift.Int = 0
        )
        {
            self.backloggedStorageBytes = backloggedStorageBytes
            self.deviceName = deviceName
            self.replicatedStorageBytes = replicatedStorageBytes
            self.rescannedStorageBytes = rescannedStorageBytes
            self.totalStorageBytes = totalStorageBytes
        }
    }

}

extension DrsClientTypes.DataReplicationInitiation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextAttemptDateTime
        case startDateTime
        case steps
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let nextAttemptDateTime = self.nextAttemptDateTime {
            try encodeContainer.encode(nextAttemptDateTime, forKey: .nextAttemptDateTime)
        }
        if let startDateTime = self.startDateTime {
            try encodeContainer.encode(startDateTime, forKey: .startDateTime)
        }
        if let steps = steps {
            var stepsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .steps)
            for datareplicationinitiationstep0 in steps {
                try stepsContainer.encode(datareplicationinitiationstep0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startDateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .startDateTime)
        startDateTime = startDateTimeDecoded
        let nextAttemptDateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextAttemptDateTime)
        nextAttemptDateTime = nextAttemptDateTimeDecoded
        let stepsContainer = try containerValues.decodeIfPresent([DrsClientTypes.DataReplicationInitiationStep?].self, forKey: .steps)
        var stepsDecoded0:[DrsClientTypes.DataReplicationInitiationStep]? = nil
        if let stepsContainer = stepsContainer {
            stepsDecoded0 = [DrsClientTypes.DataReplicationInitiationStep]()
            for structure0 in stepsContainer {
                if let structure0 = structure0 {
                    stepsDecoded0?.append(structure0)
                }
            }
        }
        steps = stepsDecoded0
    }
}

extension DrsClientTypes {
    /// Data replication initiation.
    public struct DataReplicationInitiation: Swift.Equatable {
        /// The date and time of the next attempt to initiate data replication.
        public var nextAttemptDateTime: Swift.String?
        /// The date and time of the current attempt to initiate data replication.
        public var startDateTime: Swift.String?
        /// The steps of the current attempt to initiate data replication.
        public var steps: [DrsClientTypes.DataReplicationInitiationStep]?

        public init(
            nextAttemptDateTime: Swift.String? = nil,
            startDateTime: Swift.String? = nil,
            steps: [DrsClientTypes.DataReplicationInitiationStep]? = nil
        )
        {
            self.nextAttemptDateTime = nextAttemptDateTime
            self.startDateTime = startDateTime
            self.steps = steps
        }
    }

}

extension DrsClientTypes.DataReplicationInitiationStep: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(DrsClientTypes.DataReplicationInitiationStepName.self, forKey: .name)
        name = nameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(DrsClientTypes.DataReplicationInitiationStepStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension DrsClientTypes {
    /// Data replication initiation step.
    public struct DataReplicationInitiationStep: Swift.Equatable {
        /// The name of the step.
        public var name: DrsClientTypes.DataReplicationInitiationStepName?
        /// The status of the step.
        public var status: DrsClientTypes.DataReplicationInitiationStepStatus?

        public init(
            name: DrsClientTypes.DataReplicationInitiationStepName? = nil,
            status: DrsClientTypes.DataReplicationInitiationStepStatus? = nil
        )
        {
            self.name = name
            self.status = status
        }
    }

}

extension DrsClientTypes {
    public enum DataReplicationInitiationStepName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case attachStagingDisks
        case authenticateWithService
        case bootReplicationServer
        case connectAgentToReplicationServer
        case createSecurityGroup
        case createStagingDisks
        case downloadReplicationSoftware
        case launchReplicationServer
        case pairReplicationServerWithAgent
        case startDataTransfer
        case wait
        case sdkUnknown(Swift.String)

        public static var allCases: [DataReplicationInitiationStepName] {
            return [
                .attachStagingDisks,
                .authenticateWithService,
                .bootReplicationServer,
                .connectAgentToReplicationServer,
                .createSecurityGroup,
                .createStagingDisks,
                .downloadReplicationSoftware,
                .launchReplicationServer,
                .pairReplicationServerWithAgent,
                .startDataTransfer,
                .wait,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .attachStagingDisks: return "ATTACH_STAGING_DISKS"
            case .authenticateWithService: return "AUTHENTICATE_WITH_SERVICE"
            case .bootReplicationServer: return "BOOT_REPLICATION_SERVER"
            case .connectAgentToReplicationServer: return "CONNECT_AGENT_TO_REPLICATION_SERVER"
            case .createSecurityGroup: return "CREATE_SECURITY_GROUP"
            case .createStagingDisks: return "CREATE_STAGING_DISKS"
            case .downloadReplicationSoftware: return "DOWNLOAD_REPLICATION_SOFTWARE"
            case .launchReplicationServer: return "LAUNCH_REPLICATION_SERVER"
            case .pairReplicationServerWithAgent: return "PAIR_REPLICATION_SERVER_WITH_AGENT"
            case .startDataTransfer: return "START_DATA_TRANSFER"
            case .wait: return "WAIT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DataReplicationInitiationStepName(rawValue: rawValue) ?? DataReplicationInitiationStepName.sdkUnknown(rawValue)
        }
    }
}

extension DrsClientTypes {
    public enum DataReplicationInitiationStepStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failed
        case inProgress
        case notStarted
        case skipped
        case succeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [DataReplicationInitiationStepStatus] {
            return [
                .failed,
                .inProgress,
                .notStarted,
                .skipped,
                .succeeded,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .notStarted: return "NOT_STARTED"
            case .skipped: return "SKIPPED"
            case .succeeded: return "SUCCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DataReplicationInitiationStepStatus(rawValue: rawValue) ?? DataReplicationInitiationStepStatus.sdkUnknown(rawValue)
        }
    }
}

extension DrsClientTypes {
    public enum DataReplicationState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case backlog
        case continuous
        case creatingSnapshot
        case disconnected
        case initialSync
        case initiating
        case paused
        case rescan
        case stalled
        case stopped
        case sdkUnknown(Swift.String)

        public static var allCases: [DataReplicationState] {
            return [
                .backlog,
                .continuous,
                .creatingSnapshot,
                .disconnected,
                .initialSync,
                .initiating,
                .paused,
                .rescan,
                .stalled,
                .stopped,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .backlog: return "BACKLOG"
            case .continuous: return "CONTINUOUS"
            case .creatingSnapshot: return "CREATING_SNAPSHOT"
            case .disconnected: return "DISCONNECTED"
            case .initialSync: return "INITIAL_SYNC"
            case .initiating: return "INITIATING"
            case .paused: return "PAUSED"
            case .rescan: return "RESCAN"
            case .stalled: return "STALLED"
            case .stopped: return "STOPPED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DataReplicationState(rawValue: rawValue) ?? DataReplicationState.sdkUnknown(rawValue)
        }
    }
}

extension DeleteJobInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobID
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jobID = self.jobID {
            try encodeContainer.encode(jobID, forKey: .jobID)
        }
    }
}

extension DeleteJobInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/DeleteJob"
    }
}

public struct DeleteJobInput: Swift.Equatable {
    /// The ID of the Job to be deleted.
    /// This member is required.
    public var jobID: Swift.String?

    public init(
        jobID: Swift.String? = nil
    )
    {
        self.jobID = jobID
    }
}

struct DeleteJobInputBody: Swift.Equatable {
    let jobID: Swift.String?
}

extension DeleteJobInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobID
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobID)
        jobID = jobIDDecoded
    }
}

extension DeleteJobOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteJobOutput: Swift.Equatable {

    public init() { }
}

enum DeleteJobOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UninitializedAccountException": return try await UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteLaunchActionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actionId
        case resourceId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actionId = self.actionId {
            try encodeContainer.encode(actionId, forKey: .actionId)
        }
        if let resourceId = self.resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
    }
}

extension DeleteLaunchActionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/DeleteLaunchAction"
    }
}

public struct DeleteLaunchActionInput: Swift.Equatable {
    /// Launch action Id.
    /// This member is required.
    public var actionId: Swift.String?
    /// Launch configuration template Id or Source Server Id
    /// This member is required.
    public var resourceId: Swift.String?

    public init(
        actionId: Swift.String? = nil,
        resourceId: Swift.String? = nil
    )
    {
        self.actionId = actionId
        self.resourceId = resourceId
    }
}

struct DeleteLaunchActionInputBody: Swift.Equatable {
    let resourceId: Swift.String?
    let actionId: Swift.String?
}

extension DeleteLaunchActionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actionId
        case resourceId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let actionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .actionId)
        actionId = actionIdDecoded
    }
}

extension DeleteLaunchActionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteLaunchActionOutput: Swift.Equatable {

    public init() { }
}

enum DeleteLaunchActionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UninitializedAccountException": return try await UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteLaunchConfigurationTemplateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case launchConfigurationTemplateID
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let launchConfigurationTemplateID = self.launchConfigurationTemplateID {
            try encodeContainer.encode(launchConfigurationTemplateID, forKey: .launchConfigurationTemplateID)
        }
    }
}

extension DeleteLaunchConfigurationTemplateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/DeleteLaunchConfigurationTemplate"
    }
}

public struct DeleteLaunchConfigurationTemplateInput: Swift.Equatable {
    /// The ID of the Launch Configuration Template to be deleted.
    /// This member is required.
    public var launchConfigurationTemplateID: Swift.String?

    public init(
        launchConfigurationTemplateID: Swift.String? = nil
    )
    {
        self.launchConfigurationTemplateID = launchConfigurationTemplateID
    }
}

struct DeleteLaunchConfigurationTemplateInputBody: Swift.Equatable {
    let launchConfigurationTemplateID: Swift.String?
}

extension DeleteLaunchConfigurationTemplateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case launchConfigurationTemplateID
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let launchConfigurationTemplateIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .launchConfigurationTemplateID)
        launchConfigurationTemplateID = launchConfigurationTemplateIDDecoded
    }
}

extension DeleteLaunchConfigurationTemplateOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteLaunchConfigurationTemplateOutput: Swift.Equatable {

    public init() { }
}

enum DeleteLaunchConfigurationTemplateOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UninitializedAccountException": return try await UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteRecoveryInstanceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case recoveryInstanceID
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let recoveryInstanceID = self.recoveryInstanceID {
            try encodeContainer.encode(recoveryInstanceID, forKey: .recoveryInstanceID)
        }
    }
}

extension DeleteRecoveryInstanceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/DeleteRecoveryInstance"
    }
}

public struct DeleteRecoveryInstanceInput: Swift.Equatable {
    /// The ID of the Recovery Instance to be deleted.
    /// This member is required.
    public var recoveryInstanceID: Swift.String?

    public init(
        recoveryInstanceID: Swift.String? = nil
    )
    {
        self.recoveryInstanceID = recoveryInstanceID
    }
}

struct DeleteRecoveryInstanceInputBody: Swift.Equatable {
    let recoveryInstanceID: Swift.String?
}

extension DeleteRecoveryInstanceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case recoveryInstanceID
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recoveryInstanceIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recoveryInstanceID)
        recoveryInstanceID = recoveryInstanceIDDecoded
    }
}

extension DeleteRecoveryInstanceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteRecoveryInstanceOutput: Swift.Equatable {

    public init() { }
}

enum DeleteRecoveryInstanceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UninitializedAccountException": return try await UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteReplicationConfigurationTemplateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case replicationConfigurationTemplateID
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let replicationConfigurationTemplateID = self.replicationConfigurationTemplateID {
            try encodeContainer.encode(replicationConfigurationTemplateID, forKey: .replicationConfigurationTemplateID)
        }
    }
}

extension DeleteReplicationConfigurationTemplateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/DeleteReplicationConfigurationTemplate"
    }
}

public struct DeleteReplicationConfigurationTemplateInput: Swift.Equatable {
    /// The ID of the Replication Configuration Template to be deleted.
    /// This member is required.
    public var replicationConfigurationTemplateID: Swift.String?

    public init(
        replicationConfigurationTemplateID: Swift.String? = nil
    )
    {
        self.replicationConfigurationTemplateID = replicationConfigurationTemplateID
    }
}

struct DeleteReplicationConfigurationTemplateInputBody: Swift.Equatable {
    let replicationConfigurationTemplateID: Swift.String?
}

extension DeleteReplicationConfigurationTemplateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case replicationConfigurationTemplateID
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationConfigurationTemplateIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationConfigurationTemplateID)
        replicationConfigurationTemplateID = replicationConfigurationTemplateIDDecoded
    }
}

extension DeleteReplicationConfigurationTemplateOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteReplicationConfigurationTemplateOutput: Swift.Equatable {

    public init() { }
}

enum DeleteReplicationConfigurationTemplateOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UninitializedAccountException": return try await UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteSourceNetworkInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sourceNetworkID
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sourceNetworkID = self.sourceNetworkID {
            try encodeContainer.encode(sourceNetworkID, forKey: .sourceNetworkID)
        }
    }
}

extension DeleteSourceNetworkInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/DeleteSourceNetwork"
    }
}

public struct DeleteSourceNetworkInput: Swift.Equatable {
    /// ID of the Source Network to delete.
    /// This member is required.
    public var sourceNetworkID: Swift.String?

    public init(
        sourceNetworkID: Swift.String? = nil
    )
    {
        self.sourceNetworkID = sourceNetworkID
    }
}

struct DeleteSourceNetworkInputBody: Swift.Equatable {
    let sourceNetworkID: Swift.String?
}

extension DeleteSourceNetworkInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sourceNetworkID
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceNetworkIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceNetworkID)
        sourceNetworkID = sourceNetworkIDDecoded
    }
}

extension DeleteSourceNetworkOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteSourceNetworkOutput: Swift.Equatable {

    public init() { }
}

enum DeleteSourceNetworkOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UninitializedAccountException": return try await UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteSourceServerInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sourceServerID
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sourceServerID = self.sourceServerID {
            try encodeContainer.encode(sourceServerID, forKey: .sourceServerID)
        }
    }
}

extension DeleteSourceServerInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/DeleteSourceServer"
    }
}

public struct DeleteSourceServerInput: Swift.Equatable {
    /// The ID of the Source Server to be deleted.
    /// This member is required.
    public var sourceServerID: Swift.String?

    public init(
        sourceServerID: Swift.String? = nil
    )
    {
        self.sourceServerID = sourceServerID
    }
}

struct DeleteSourceServerInputBody: Swift.Equatable {
    let sourceServerID: Swift.String?
}

extension DeleteSourceServerInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sourceServerID
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceServerIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceServerID)
        sourceServerID = sourceServerIDDecoded
    }
}

extension DeleteSourceServerOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteSourceServerOutput: Swift.Equatable {

    public init() { }
}

enum DeleteSourceServerOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UninitializedAccountException": return try await UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeJobLogItemsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobID
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let jobID = self.jobID {
            try encodeContainer.encode(jobID, forKey: .jobID)
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension DescribeJobLogItemsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/DescribeJobLogItems"
    }
}

public struct DescribeJobLogItemsInput: Swift.Equatable {
    /// The ID of the Job for which Job log items will be retrieved.
    /// This member is required.
    public var jobID: Swift.String?
    /// Maximum number of Job log items to retrieve.
    public var maxResults: Swift.Int
    /// The token of the next Job log items to retrieve.
    public var nextToken: Swift.String?

    public init(
        jobID: Swift.String? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.jobID = jobID
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeJobLogItemsInputBody: Swift.Equatable {
    let jobID: Swift.String?
    let maxResults: Swift.Int
    let nextToken: Swift.String?
}

extension DescribeJobLogItemsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case jobID
        case maxResults
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobID)
        jobID = jobIDDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults) ?? 0
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeJobLogItemsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeJobLogItemsOutputBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeJobLogItemsOutput: Swift.Equatable {
    /// An array of Job log items.
    public var items: [DrsClientTypes.JobLog]?
    /// The token of the next Job log items to retrieve.
    public var nextToken: Swift.String?

    public init(
        items: [DrsClientTypes.JobLog]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct DescribeJobLogItemsOutputBody: Swift.Equatable {
    let items: [DrsClientTypes.JobLog]?
    let nextToken: Swift.String?
}

extension DescribeJobLogItemsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([DrsClientTypes.JobLog?].self, forKey: .items)
        var itemsDecoded0:[DrsClientTypes.JobLog]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [DrsClientTypes.JobLog]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum DescribeJobLogItemsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UninitializedAccountException": return try await UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeJobsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = self.filters {
            try encodeContainer.encode(filters, forKey: .filters)
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension DescribeJobsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/DescribeJobs"
    }
}

public struct DescribeJobsInput: Swift.Equatable {
    /// A set of filters by which to return Jobs.
    public var filters: DrsClientTypes.DescribeJobsRequestFilters?
    /// Maximum number of Jobs to retrieve.
    public var maxResults: Swift.Int
    /// The token of the next Job to retrieve.
    public var nextToken: Swift.String?

    public init(
        filters: DrsClientTypes.DescribeJobsRequestFilters? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeJobsInputBody: Swift.Equatable {
    let filters: DrsClientTypes.DescribeJobsRequestFilters?
    let maxResults: Swift.Int
    let nextToken: Swift.String?
}

extension DescribeJobsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersDecoded = try containerValues.decodeIfPresent(DrsClientTypes.DescribeJobsRequestFilters.self, forKey: .filters)
        filters = filtersDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults) ?? 0
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeJobsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeJobsOutputBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeJobsOutput: Swift.Equatable {
    /// An array of Jobs.
    public var items: [DrsClientTypes.Job]?
    /// The token of the next Job to retrieve.
    public var nextToken: Swift.String?

    public init(
        items: [DrsClientTypes.Job]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct DescribeJobsOutputBody: Swift.Equatable {
    let items: [DrsClientTypes.Job]?
    let nextToken: Swift.String?
}

extension DescribeJobsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([DrsClientTypes.Job?].self, forKey: .items)
        var itemsDecoded0:[DrsClientTypes.Job]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [DrsClientTypes.Job]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum DescribeJobsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UninitializedAccountException": return try await UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DrsClientTypes.DescribeJobsRequestFilters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fromDate
        case jobIDs
        case toDate
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fromDate = self.fromDate {
            try encodeContainer.encode(fromDate, forKey: .fromDate)
        }
        if let jobIDs = jobIDs {
            var jobIDsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .jobIDs)
            for jobid0 in jobIDs {
                try jobIDsContainer.encode(jobid0)
            }
        }
        if let toDate = self.toDate {
            try encodeContainer.encode(toDate, forKey: .toDate)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIDsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .jobIDs)
        var jobIDsDecoded0:[Swift.String]? = nil
        if let jobIDsContainer = jobIDsContainer {
            jobIDsDecoded0 = [Swift.String]()
            for string0 in jobIDsContainer {
                if let string0 = string0 {
                    jobIDsDecoded0?.append(string0)
                }
            }
        }
        jobIDs = jobIDsDecoded0
        let fromDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fromDate)
        fromDate = fromDateDecoded
        let toDateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .toDate)
        toDate = toDateDecoded
    }
}

extension DrsClientTypes {
    /// A set of filters by which to return Jobs.
    public struct DescribeJobsRequestFilters: Swift.Equatable {
        /// The start date in a date range query.
        public var fromDate: Swift.String?
        /// An array of Job IDs that should be returned. An empty array means all jobs.
        public var jobIDs: [Swift.String]?
        /// The end date in a date range query.
        public var toDate: Swift.String?

        public init(
            fromDate: Swift.String? = nil,
            jobIDs: [Swift.String]? = nil,
            toDate: Swift.String? = nil
        )
        {
            self.fromDate = fromDate
            self.jobIDs = jobIDs
            self.toDate = toDate
        }
    }

}

extension DescribeLaunchConfigurationTemplatesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case launchConfigurationTemplateIDs
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let launchConfigurationTemplateIDs = launchConfigurationTemplateIDs {
            var launchConfigurationTemplateIDsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .launchConfigurationTemplateIDs)
            for launchconfigurationtemplateid0 in launchConfigurationTemplateIDs {
                try launchConfigurationTemplateIDsContainer.encode(launchconfigurationtemplateid0)
            }
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension DescribeLaunchConfigurationTemplatesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/DescribeLaunchConfigurationTemplates"
    }
}

public struct DescribeLaunchConfigurationTemplatesInput: Swift.Equatable {
    /// Request to filter Launch Configuration Templates list by Launch Configuration Template ID.
    public var launchConfigurationTemplateIDs: [Swift.String]?
    /// Maximum results to be returned in DescribeLaunchConfigurationTemplates.
    public var maxResults: Swift.Int
    /// The token of the next Launch Configuration Template to retrieve.
    public var nextToken: Swift.String?

    public init(
        launchConfigurationTemplateIDs: [Swift.String]? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.launchConfigurationTemplateIDs = launchConfigurationTemplateIDs
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeLaunchConfigurationTemplatesInputBody: Swift.Equatable {
    let launchConfigurationTemplateIDs: [Swift.String]?
    let maxResults: Swift.Int
    let nextToken: Swift.String?
}

extension DescribeLaunchConfigurationTemplatesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case launchConfigurationTemplateIDs
        case maxResults
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let launchConfigurationTemplateIDsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .launchConfigurationTemplateIDs)
        var launchConfigurationTemplateIDsDecoded0:[Swift.String]? = nil
        if let launchConfigurationTemplateIDsContainer = launchConfigurationTemplateIDsContainer {
            launchConfigurationTemplateIDsDecoded0 = [Swift.String]()
            for string0 in launchConfigurationTemplateIDsContainer {
                if let string0 = string0 {
                    launchConfigurationTemplateIDsDecoded0?.append(string0)
                }
            }
        }
        launchConfigurationTemplateIDs = launchConfigurationTemplateIDsDecoded0
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults) ?? 0
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeLaunchConfigurationTemplatesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeLaunchConfigurationTemplatesOutputBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeLaunchConfigurationTemplatesOutput: Swift.Equatable {
    /// List of items returned by DescribeLaunchConfigurationTemplates.
    public var items: [DrsClientTypes.LaunchConfigurationTemplate]?
    /// The token of the next Launch Configuration Template to retrieve.
    public var nextToken: Swift.String?

    public init(
        items: [DrsClientTypes.LaunchConfigurationTemplate]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct DescribeLaunchConfigurationTemplatesOutputBody: Swift.Equatable {
    let items: [DrsClientTypes.LaunchConfigurationTemplate]?
    let nextToken: Swift.String?
}

extension DescribeLaunchConfigurationTemplatesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([DrsClientTypes.LaunchConfigurationTemplate?].self, forKey: .items)
        var itemsDecoded0:[DrsClientTypes.LaunchConfigurationTemplate]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [DrsClientTypes.LaunchConfigurationTemplate]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum DescribeLaunchConfigurationTemplatesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UninitializedAccountException": return try await UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeRecoveryInstancesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = self.filters {
            try encodeContainer.encode(filters, forKey: .filters)
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension DescribeRecoveryInstancesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/DescribeRecoveryInstances"
    }
}

public struct DescribeRecoveryInstancesInput: Swift.Equatable {
    /// A set of filters by which to return Recovery Instances.
    public var filters: DrsClientTypes.DescribeRecoveryInstancesRequestFilters?
    /// Maximum number of Recovery Instances to retrieve.
    public var maxResults: Swift.Int
    /// The token of the next Recovery Instance to retrieve.
    public var nextToken: Swift.String?

    public init(
        filters: DrsClientTypes.DescribeRecoveryInstancesRequestFilters? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeRecoveryInstancesInputBody: Swift.Equatable {
    let filters: DrsClientTypes.DescribeRecoveryInstancesRequestFilters?
    let maxResults: Swift.Int
    let nextToken: Swift.String?
}

extension DescribeRecoveryInstancesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersDecoded = try containerValues.decodeIfPresent(DrsClientTypes.DescribeRecoveryInstancesRequestFilters.self, forKey: .filters)
        filters = filtersDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults) ?? 0
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeRecoveryInstancesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeRecoveryInstancesOutputBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeRecoveryInstancesOutput: Swift.Equatable {
    /// An array of Recovery Instances.
    public var items: [DrsClientTypes.RecoveryInstance]?
    /// The token of the next Recovery Instance to retrieve.
    public var nextToken: Swift.String?

    public init(
        items: [DrsClientTypes.RecoveryInstance]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct DescribeRecoveryInstancesOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let items: [DrsClientTypes.RecoveryInstance]?
}

extension DescribeRecoveryInstancesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let itemsContainer = try containerValues.decodeIfPresent([DrsClientTypes.RecoveryInstance?].self, forKey: .items)
        var itemsDecoded0:[DrsClientTypes.RecoveryInstance]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [DrsClientTypes.RecoveryInstance]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
    }
}

enum DescribeRecoveryInstancesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UninitializedAccountException": return try await UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DrsClientTypes.DescribeRecoveryInstancesRequestFilters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case recoveryInstanceIDs
        case sourceServerIDs
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let recoveryInstanceIDs = recoveryInstanceIDs {
            var recoveryInstanceIDsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .recoveryInstanceIDs)
            for recoveryinstanceid0 in recoveryInstanceIDs {
                try recoveryInstanceIDsContainer.encode(recoveryinstanceid0)
            }
        }
        if let sourceServerIDs = sourceServerIDs {
            var sourceServerIDsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sourceServerIDs)
            for sourceserverid0 in sourceServerIDs {
                try sourceServerIDsContainer.encode(sourceserverid0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recoveryInstanceIDsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .recoveryInstanceIDs)
        var recoveryInstanceIDsDecoded0:[Swift.String]? = nil
        if let recoveryInstanceIDsContainer = recoveryInstanceIDsContainer {
            recoveryInstanceIDsDecoded0 = [Swift.String]()
            for string0 in recoveryInstanceIDsContainer {
                if let string0 = string0 {
                    recoveryInstanceIDsDecoded0?.append(string0)
                }
            }
        }
        recoveryInstanceIDs = recoveryInstanceIDsDecoded0
        let sourceServerIDsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .sourceServerIDs)
        var sourceServerIDsDecoded0:[Swift.String]? = nil
        if let sourceServerIDsContainer = sourceServerIDsContainer {
            sourceServerIDsDecoded0 = [Swift.String]()
            for string0 in sourceServerIDsContainer {
                if let string0 = string0 {
                    sourceServerIDsDecoded0?.append(string0)
                }
            }
        }
        sourceServerIDs = sourceServerIDsDecoded0
    }
}

extension DrsClientTypes {
    /// A set of filters by which to return Recovery Instances.
    public struct DescribeRecoveryInstancesRequestFilters: Swift.Equatable {
        /// An array of Recovery Instance IDs that should be returned. An empty array means all Recovery Instances.
        public var recoveryInstanceIDs: [Swift.String]?
        /// An array of Source Server IDs for which associated Recovery Instances should be returned.
        public var sourceServerIDs: [Swift.String]?

        public init(
            recoveryInstanceIDs: [Swift.String]? = nil,
            sourceServerIDs: [Swift.String]? = nil
        )
        {
            self.recoveryInstanceIDs = recoveryInstanceIDs
            self.sourceServerIDs = sourceServerIDs
        }
    }

}

extension DescribeRecoverySnapshotsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
        case order
        case sourceServerID
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = self.filters {
            try encodeContainer.encode(filters, forKey: .filters)
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let order = self.order {
            try encodeContainer.encode(order.rawValue, forKey: .order)
        }
        if let sourceServerID = self.sourceServerID {
            try encodeContainer.encode(sourceServerID, forKey: .sourceServerID)
        }
    }
}

extension DescribeRecoverySnapshotsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/DescribeRecoverySnapshots"
    }
}

public struct DescribeRecoverySnapshotsInput: Swift.Equatable {
    /// A set of filters by which to return Recovery Snapshots.
    public var filters: DrsClientTypes.DescribeRecoverySnapshotsRequestFilters?
    /// Maximum number of Recovery Snapshots to retrieve.
    public var maxResults: Swift.Int
    /// The token of the next Recovery Snapshot to retrieve.
    public var nextToken: Swift.String?
    /// The sorted ordering by which to return Recovery Snapshots.
    public var order: DrsClientTypes.RecoverySnapshotsOrder?
    /// Filter Recovery Snapshots by Source Server ID.
    /// This member is required.
    public var sourceServerID: Swift.String?

    public init(
        filters: DrsClientTypes.DescribeRecoverySnapshotsRequestFilters? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil,
        order: DrsClientTypes.RecoverySnapshotsOrder? = nil,
        sourceServerID: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.order = order
        self.sourceServerID = sourceServerID
    }
}

struct DescribeRecoverySnapshotsInputBody: Swift.Equatable {
    let sourceServerID: Swift.String?
    let filters: DrsClientTypes.DescribeRecoverySnapshotsRequestFilters?
    let order: DrsClientTypes.RecoverySnapshotsOrder?
    let maxResults: Swift.Int
    let nextToken: Swift.String?
}

extension DescribeRecoverySnapshotsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
        case order
        case sourceServerID
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceServerIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceServerID)
        sourceServerID = sourceServerIDDecoded
        let filtersDecoded = try containerValues.decodeIfPresent(DrsClientTypes.DescribeRecoverySnapshotsRequestFilters.self, forKey: .filters)
        filters = filtersDecoded
        let orderDecoded = try containerValues.decodeIfPresent(DrsClientTypes.RecoverySnapshotsOrder.self, forKey: .order)
        order = orderDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults) ?? 0
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeRecoverySnapshotsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeRecoverySnapshotsOutputBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeRecoverySnapshotsOutput: Swift.Equatable {
    /// An array of Recovery Snapshots.
    public var items: [DrsClientTypes.RecoverySnapshot]?
    /// The token of the next Recovery Snapshot to retrieve.
    public var nextToken: Swift.String?

    public init(
        items: [DrsClientTypes.RecoverySnapshot]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct DescribeRecoverySnapshotsOutputBody: Swift.Equatable {
    let items: [DrsClientTypes.RecoverySnapshot]?
    let nextToken: Swift.String?
}

extension DescribeRecoverySnapshotsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([DrsClientTypes.RecoverySnapshot?].self, forKey: .items)
        var itemsDecoded0:[DrsClientTypes.RecoverySnapshot]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [DrsClientTypes.RecoverySnapshot]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum DescribeRecoverySnapshotsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UninitializedAccountException": return try await UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DrsClientTypes.DescribeRecoverySnapshotsRequestFilters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fromDateTime
        case toDateTime
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fromDateTime = self.fromDateTime {
            try encodeContainer.encode(fromDateTime, forKey: .fromDateTime)
        }
        if let toDateTime = self.toDateTime {
            try encodeContainer.encode(toDateTime, forKey: .toDateTime)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fromDateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fromDateTime)
        fromDateTime = fromDateTimeDecoded
        let toDateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .toDateTime)
        toDateTime = toDateTimeDecoded
    }
}

extension DrsClientTypes {
    /// A set of filters by which to return Recovery Snapshots.
    public struct DescribeRecoverySnapshotsRequestFilters: Swift.Equatable {
        /// The start date in a date range query.
        public var fromDateTime: Swift.String?
        /// The end date in a date range query.
        public var toDateTime: Swift.String?

        public init(
            fromDateTime: Swift.String? = nil,
            toDateTime: Swift.String? = nil
        )
        {
            self.fromDateTime = fromDateTime
            self.toDateTime = toDateTime
        }
    }

}

extension DescribeReplicationConfigurationTemplatesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case replicationConfigurationTemplateIDs
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let replicationConfigurationTemplateIDs = replicationConfigurationTemplateIDs {
            var replicationConfigurationTemplateIDsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .replicationConfigurationTemplateIDs)
            for replicationconfigurationtemplateid0 in replicationConfigurationTemplateIDs {
                try replicationConfigurationTemplateIDsContainer.encode(replicationconfigurationtemplateid0)
            }
        }
    }
}

extension DescribeReplicationConfigurationTemplatesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/DescribeReplicationConfigurationTemplates"
    }
}

public struct DescribeReplicationConfigurationTemplatesInput: Swift.Equatable {
    /// Maximum number of Replication Configuration Templates to retrieve.
    public var maxResults: Swift.Int
    /// The token of the next Replication Configuration Template to retrieve.
    public var nextToken: Swift.String?
    /// The IDs of the Replication Configuration Templates to retrieve. An empty list means all Replication Configuration Templates.
    public var replicationConfigurationTemplateIDs: [Swift.String]?

    public init(
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil,
        replicationConfigurationTemplateIDs: [Swift.String]? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.replicationConfigurationTemplateIDs = replicationConfigurationTemplateIDs
    }
}

struct DescribeReplicationConfigurationTemplatesInputBody: Swift.Equatable {
    let replicationConfigurationTemplateIDs: [Swift.String]?
    let maxResults: Swift.Int
    let nextToken: Swift.String?
}

extension DescribeReplicationConfigurationTemplatesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case replicationConfigurationTemplateIDs
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationConfigurationTemplateIDsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .replicationConfigurationTemplateIDs)
        var replicationConfigurationTemplateIDsDecoded0:[Swift.String]? = nil
        if let replicationConfigurationTemplateIDsContainer = replicationConfigurationTemplateIDsContainer {
            replicationConfigurationTemplateIDsDecoded0 = [Swift.String]()
            for string0 in replicationConfigurationTemplateIDsContainer {
                if let string0 = string0 {
                    replicationConfigurationTemplateIDsDecoded0?.append(string0)
                }
            }
        }
        replicationConfigurationTemplateIDs = replicationConfigurationTemplateIDsDecoded0
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults) ?? 0
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeReplicationConfigurationTemplatesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeReplicationConfigurationTemplatesOutputBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeReplicationConfigurationTemplatesOutput: Swift.Equatable {
    /// An array of Replication Configuration Templates.
    public var items: [DrsClientTypes.ReplicationConfigurationTemplate]?
    /// The token of the next Replication Configuration Template to retrieve.
    public var nextToken: Swift.String?

    public init(
        items: [DrsClientTypes.ReplicationConfigurationTemplate]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct DescribeReplicationConfigurationTemplatesOutputBody: Swift.Equatable {
    let items: [DrsClientTypes.ReplicationConfigurationTemplate]?
    let nextToken: Swift.String?
}

extension DescribeReplicationConfigurationTemplatesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([DrsClientTypes.ReplicationConfigurationTemplate?].self, forKey: .items)
        var itemsDecoded0:[DrsClientTypes.ReplicationConfigurationTemplate]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [DrsClientTypes.ReplicationConfigurationTemplate]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum DescribeReplicationConfigurationTemplatesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UninitializedAccountException": return try await UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeSourceNetworksInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = self.filters {
            try encodeContainer.encode(filters, forKey: .filters)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension DescribeSourceNetworksInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/DescribeSourceNetworks"
    }
}

public struct DescribeSourceNetworksInput: Swift.Equatable {
    /// A set of filters by which to return Source Networks.
    public var filters: DrsClientTypes.DescribeSourceNetworksRequestFilters?
    /// Maximum number of Source Networks to retrieve.
    public var maxResults: Swift.Int?
    /// The token of the next Source Networks to retrieve.
    public var nextToken: Swift.String?

    public init(
        filters: DrsClientTypes.DescribeSourceNetworksRequestFilters? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeSourceNetworksInputBody: Swift.Equatable {
    let filters: DrsClientTypes.DescribeSourceNetworksRequestFilters?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension DescribeSourceNetworksInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersDecoded = try containerValues.decodeIfPresent(DrsClientTypes.DescribeSourceNetworksRequestFilters.self, forKey: .filters)
        filters = filtersDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeSourceNetworksOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeSourceNetworksOutputBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeSourceNetworksOutput: Swift.Equatable {
    /// An array of Source Networks.
    public var items: [DrsClientTypes.SourceNetwork]?
    /// The token of the next Source Networks to retrieve.
    public var nextToken: Swift.String?

    public init(
        items: [DrsClientTypes.SourceNetwork]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct DescribeSourceNetworksOutputBody: Swift.Equatable {
    let items: [DrsClientTypes.SourceNetwork]?
    let nextToken: Swift.String?
}

extension DescribeSourceNetworksOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([DrsClientTypes.SourceNetwork?].self, forKey: .items)
        var itemsDecoded0:[DrsClientTypes.SourceNetwork]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [DrsClientTypes.SourceNetwork]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum DescribeSourceNetworksOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UninitializedAccountException": return try await UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DrsClientTypes.DescribeSourceNetworksRequestFilters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case originAccountID
        case originRegion
        case sourceNetworkIDs
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let originAccountID = self.originAccountID {
            try encodeContainer.encode(originAccountID, forKey: .originAccountID)
        }
        if let originRegion = self.originRegion {
            try encodeContainer.encode(originRegion, forKey: .originRegion)
        }
        if let sourceNetworkIDs = sourceNetworkIDs {
            var sourceNetworkIDsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sourceNetworkIDs)
            for sourcenetworkid0 in sourceNetworkIDs {
                try sourceNetworkIDsContainer.encode(sourcenetworkid0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceNetworkIDsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .sourceNetworkIDs)
        var sourceNetworkIDsDecoded0:[Swift.String]? = nil
        if let sourceNetworkIDsContainer = sourceNetworkIDsContainer {
            sourceNetworkIDsDecoded0 = [Swift.String]()
            for string0 in sourceNetworkIDsContainer {
                if let string0 = string0 {
                    sourceNetworkIDsDecoded0?.append(string0)
                }
            }
        }
        sourceNetworkIDs = sourceNetworkIDsDecoded0
        let originAccountIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .originAccountID)
        originAccountID = originAccountIDDecoded
        let originRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .originRegion)
        originRegion = originRegionDecoded
    }
}

extension DrsClientTypes {
    /// A set of filters by which to return Source Networks.
    public struct DescribeSourceNetworksRequestFilters: Swift.Equatable {
        /// Filter Source Networks by account ID containing the protected VPCs.
        public var originAccountID: Swift.String?
        /// Filter Source Networks by the region containing the protected VPCs.
        public var originRegion: Swift.String?
        /// An array of Source Network IDs that should be returned. An empty array means all Source Networks.
        public var sourceNetworkIDs: [Swift.String]?

        public init(
            originAccountID: Swift.String? = nil,
            originRegion: Swift.String? = nil,
            sourceNetworkIDs: [Swift.String]? = nil
        )
        {
            self.originAccountID = originAccountID
            self.originRegion = originRegion
            self.sourceNetworkIDs = sourceNetworkIDs
        }
    }

}

extension DescribeSourceServersInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = self.filters {
            try encodeContainer.encode(filters, forKey: .filters)
        }
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension DescribeSourceServersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/DescribeSourceServers"
    }
}

public struct DescribeSourceServersInput: Swift.Equatable {
    /// A set of filters by which to return Source Servers.
    public var filters: DrsClientTypes.DescribeSourceServersRequestFilters?
    /// Maximum number of Source Servers to retrieve.
    public var maxResults: Swift.Int
    /// The token of the next Source Server to retrieve.
    public var nextToken: Swift.String?

    public init(
        filters: DrsClientTypes.DescribeSourceServersRequestFilters? = nil,
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeSourceServersInputBody: Swift.Equatable {
    let filters: DrsClientTypes.DescribeSourceServersRequestFilters?
    let maxResults: Swift.Int
    let nextToken: Swift.String?
}

extension DescribeSourceServersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filtersDecoded = try containerValues.decodeIfPresent(DrsClientTypes.DescribeSourceServersRequestFilters.self, forKey: .filters)
        filters = filtersDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults) ?? 0
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeSourceServersOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeSourceServersOutputBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeSourceServersOutput: Swift.Equatable {
    /// An array of Source Servers.
    public var items: [DrsClientTypes.SourceServer]?
    /// The token of the next Source Server to retrieve.
    public var nextToken: Swift.String?

    public init(
        items: [DrsClientTypes.SourceServer]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct DescribeSourceServersOutputBody: Swift.Equatable {
    let items: [DrsClientTypes.SourceServer]?
    let nextToken: Swift.String?
}

extension DescribeSourceServersOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([DrsClientTypes.SourceServer?].self, forKey: .items)
        var itemsDecoded0:[DrsClientTypes.SourceServer]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [DrsClientTypes.SourceServer]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum DescribeSourceServersOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UninitializedAccountException": return try await UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DrsClientTypes.DescribeSourceServersRequestFilters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hardwareId
        case sourceServerIDs
        case stagingAccountIDs
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let hardwareId = self.hardwareId {
            try encodeContainer.encode(hardwareId, forKey: .hardwareId)
        }
        if let sourceServerIDs = sourceServerIDs {
            var sourceServerIDsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sourceServerIDs)
            for sourceserverid0 in sourceServerIDs {
                try sourceServerIDsContainer.encode(sourceserverid0)
            }
        }
        if let stagingAccountIDs = stagingAccountIDs {
            var stagingAccountIDsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .stagingAccountIDs)
            for accountid0 in stagingAccountIDs {
                try stagingAccountIDsContainer.encode(accountid0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceServerIDsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .sourceServerIDs)
        var sourceServerIDsDecoded0:[Swift.String]? = nil
        if let sourceServerIDsContainer = sourceServerIDsContainer {
            sourceServerIDsDecoded0 = [Swift.String]()
            for string0 in sourceServerIDsContainer {
                if let string0 = string0 {
                    sourceServerIDsDecoded0?.append(string0)
                }
            }
        }
        sourceServerIDs = sourceServerIDsDecoded0
        let hardwareIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hardwareId)
        hardwareId = hardwareIdDecoded
        let stagingAccountIDsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .stagingAccountIDs)
        var stagingAccountIDsDecoded0:[Swift.String]? = nil
        if let stagingAccountIDsContainer = stagingAccountIDsContainer {
            stagingAccountIDsDecoded0 = [Swift.String]()
            for string0 in stagingAccountIDsContainer {
                if let string0 = string0 {
                    stagingAccountIDsDecoded0?.append(string0)
                }
            }
        }
        stagingAccountIDs = stagingAccountIDsDecoded0
    }
}

extension DrsClientTypes {
    /// A set of filters by which to return Source Servers.
    public struct DescribeSourceServersRequestFilters: Swift.Equatable {
        /// An ID that describes the hardware of the Source Server. This is either an EC2 instance id, a VMware uuid or a mac address.
        public var hardwareId: Swift.String?
        /// An array of Source Servers IDs that should be returned. An empty array means all Source Servers.
        public var sourceServerIDs: [Swift.String]?
        /// An array of staging account IDs that extended source servers belong to. An empty array means all source servers will be shown.
        public var stagingAccountIDs: [Swift.String]?

        public init(
            hardwareId: Swift.String? = nil,
            sourceServerIDs: [Swift.String]? = nil,
            stagingAccountIDs: [Swift.String]? = nil
        )
        {
            self.hardwareId = hardwareId
            self.sourceServerIDs = sourceServerIDs
            self.stagingAccountIDs = stagingAccountIDs
        }
    }

}

extension DisconnectRecoveryInstanceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case recoveryInstanceID
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let recoveryInstanceID = self.recoveryInstanceID {
            try encodeContainer.encode(recoveryInstanceID, forKey: .recoveryInstanceID)
        }
    }
}

extension DisconnectRecoveryInstanceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/DisconnectRecoveryInstance"
    }
}

public struct DisconnectRecoveryInstanceInput: Swift.Equatable {
    /// The ID of the Recovery Instance to disconnect.
    /// This member is required.
    public var recoveryInstanceID: Swift.String?

    public init(
        recoveryInstanceID: Swift.String? = nil
    )
    {
        self.recoveryInstanceID = recoveryInstanceID
    }
}

struct DisconnectRecoveryInstanceInputBody: Swift.Equatable {
    let recoveryInstanceID: Swift.String?
}

extension DisconnectRecoveryInstanceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case recoveryInstanceID
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recoveryInstanceIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recoveryInstanceID)
        recoveryInstanceID = recoveryInstanceIDDecoded
    }
}

extension DisconnectRecoveryInstanceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DisconnectRecoveryInstanceOutput: Swift.Equatable {

    public init() { }
}

enum DisconnectRecoveryInstanceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UninitializedAccountException": return try await UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DisconnectSourceServerInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sourceServerID
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sourceServerID = self.sourceServerID {
            try encodeContainer.encode(sourceServerID, forKey: .sourceServerID)
        }
    }
}

extension DisconnectSourceServerInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/DisconnectSourceServer"
    }
}

public struct DisconnectSourceServerInput: Swift.Equatable {
    /// The ID of the Source Server to disconnect.
    /// This member is required.
    public var sourceServerID: Swift.String?

    public init(
        sourceServerID: Swift.String? = nil
    )
    {
        self.sourceServerID = sourceServerID
    }
}

struct DisconnectSourceServerInputBody: Swift.Equatable {
    let sourceServerID: Swift.String?
}

extension DisconnectSourceServerInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sourceServerID
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceServerIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceServerID)
        sourceServerID = sourceServerIDDecoded
    }
}

extension DisconnectSourceServerOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DisconnectSourceServerOutput(arn: \(Swift.String(describing: arn)), dataReplicationInfo: \(Swift.String(describing: dataReplicationInfo)), lastLaunchResult: \(Swift.String(describing: lastLaunchResult)), lifeCycle: \(Swift.String(describing: lifeCycle)), recoveryInstanceId: \(Swift.String(describing: recoveryInstanceId)), replicationDirection: \(Swift.String(describing: replicationDirection)), reversedDirectionSourceServerArn: \(Swift.String(describing: reversedDirectionSourceServerArn)), sourceCloudProperties: \(Swift.String(describing: sourceCloudProperties)), sourceNetworkID: \(Swift.String(describing: sourceNetworkID)), sourceProperties: \(Swift.String(describing: sourceProperties)), sourceServerID: \(Swift.String(describing: sourceServerID)), stagingArea: \(Swift.String(describing: stagingArea)), tags: \"CONTENT_REDACTED\")"}
}

extension DisconnectSourceServerOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DisconnectSourceServerOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.dataReplicationInfo = output.dataReplicationInfo
            self.lastLaunchResult = output.lastLaunchResult
            self.lifeCycle = output.lifeCycle
            self.recoveryInstanceId = output.recoveryInstanceId
            self.replicationDirection = output.replicationDirection
            self.reversedDirectionSourceServerArn = output.reversedDirectionSourceServerArn
            self.sourceCloudProperties = output.sourceCloudProperties
            self.sourceNetworkID = output.sourceNetworkID
            self.sourceProperties = output.sourceProperties
            self.sourceServerID = output.sourceServerID
            self.stagingArea = output.stagingArea
            self.tags = output.tags
        } else {
            self.arn = nil
            self.dataReplicationInfo = nil
            self.lastLaunchResult = nil
            self.lifeCycle = nil
            self.recoveryInstanceId = nil
            self.replicationDirection = nil
            self.reversedDirectionSourceServerArn = nil
            self.sourceCloudProperties = nil
            self.sourceNetworkID = nil
            self.sourceProperties = nil
            self.sourceServerID = nil
            self.stagingArea = nil
            self.tags = nil
        }
    }
}

public struct DisconnectSourceServerOutput: Swift.Equatable {
    /// The ARN of the Source Server.
    public var arn: Swift.String?
    /// The Data Replication Info of the Source Server.
    public var dataReplicationInfo: DrsClientTypes.DataReplicationInfo?
    /// The status of the last recovery launch of this Source Server.
    public var lastLaunchResult: DrsClientTypes.LastLaunchResult?
    /// The lifecycle information of this Source Server.
    public var lifeCycle: DrsClientTypes.LifeCycle?
    /// The ID of the Recovery Instance associated with this Source Server.
    public var recoveryInstanceId: Swift.String?
    /// Replication direction of the Source Server.
    public var replicationDirection: DrsClientTypes.ReplicationDirection?
    /// For EC2-originated Source Servers which have been failed over and then failed back, this value will mean the ARN of the Source Server on the opposite replication direction.
    public var reversedDirectionSourceServerArn: Swift.String?
    /// Source cloud properties of the Source Server.
    public var sourceCloudProperties: DrsClientTypes.SourceCloudProperties?
    /// ID of the Source Network which is protecting this Source Server's network.
    public var sourceNetworkID: Swift.String?
    /// The source properties of the Source Server.
    public var sourceProperties: DrsClientTypes.SourceProperties?
    /// The ID of the Source Server.
    public var sourceServerID: Swift.String?
    /// The staging area of the source server.
    public var stagingArea: DrsClientTypes.StagingArea?
    /// The tags associated with the Source Server.
    public var tags: [Swift.String:Swift.String]?

    public init(
        arn: Swift.String? = nil,
        dataReplicationInfo: DrsClientTypes.DataReplicationInfo? = nil,
        lastLaunchResult: DrsClientTypes.LastLaunchResult? = nil,
        lifeCycle: DrsClientTypes.LifeCycle? = nil,
        recoveryInstanceId: Swift.String? = nil,
        replicationDirection: DrsClientTypes.ReplicationDirection? = nil,
        reversedDirectionSourceServerArn: Swift.String? = nil,
        sourceCloudProperties: DrsClientTypes.SourceCloudProperties? = nil,
        sourceNetworkID: Swift.String? = nil,
        sourceProperties: DrsClientTypes.SourceProperties? = nil,
        sourceServerID: Swift.String? = nil,
        stagingArea: DrsClientTypes.StagingArea? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.arn = arn
        self.dataReplicationInfo = dataReplicationInfo
        self.lastLaunchResult = lastLaunchResult
        self.lifeCycle = lifeCycle
        self.recoveryInstanceId = recoveryInstanceId
        self.replicationDirection = replicationDirection
        self.reversedDirectionSourceServerArn = reversedDirectionSourceServerArn
        self.sourceCloudProperties = sourceCloudProperties
        self.sourceNetworkID = sourceNetworkID
        self.sourceProperties = sourceProperties
        self.sourceServerID = sourceServerID
        self.stagingArea = stagingArea
        self.tags = tags
    }
}

struct DisconnectSourceServerOutputBody: Swift.Equatable {
    let sourceServerID: Swift.String?
    let arn: Swift.String?
    let tags: [Swift.String:Swift.String]?
    let recoveryInstanceId: Swift.String?
    let lastLaunchResult: DrsClientTypes.LastLaunchResult?
    let dataReplicationInfo: DrsClientTypes.DataReplicationInfo?
    let lifeCycle: DrsClientTypes.LifeCycle?
    let sourceProperties: DrsClientTypes.SourceProperties?
    let stagingArea: DrsClientTypes.StagingArea?
    let sourceCloudProperties: DrsClientTypes.SourceCloudProperties?
    let replicationDirection: DrsClientTypes.ReplicationDirection?
    let reversedDirectionSourceServerArn: Swift.String?
    let sourceNetworkID: Swift.String?
}

extension DisconnectSourceServerOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case dataReplicationInfo
        case lastLaunchResult
        case lifeCycle
        case recoveryInstanceId
        case replicationDirection
        case reversedDirectionSourceServerArn
        case sourceCloudProperties
        case sourceNetworkID
        case sourceProperties
        case sourceServerID
        case stagingArea
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceServerIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceServerID)
        sourceServerID = sourceServerIDDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let recoveryInstanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recoveryInstanceId)
        recoveryInstanceId = recoveryInstanceIdDecoded
        let lastLaunchResultDecoded = try containerValues.decodeIfPresent(DrsClientTypes.LastLaunchResult.self, forKey: .lastLaunchResult)
        lastLaunchResult = lastLaunchResultDecoded
        let dataReplicationInfoDecoded = try containerValues.decodeIfPresent(DrsClientTypes.DataReplicationInfo.self, forKey: .dataReplicationInfo)
        dataReplicationInfo = dataReplicationInfoDecoded
        let lifeCycleDecoded = try containerValues.decodeIfPresent(DrsClientTypes.LifeCycle.self, forKey: .lifeCycle)
        lifeCycle = lifeCycleDecoded
        let sourcePropertiesDecoded = try containerValues.decodeIfPresent(DrsClientTypes.SourceProperties.self, forKey: .sourceProperties)
        sourceProperties = sourcePropertiesDecoded
        let stagingAreaDecoded = try containerValues.decodeIfPresent(DrsClientTypes.StagingArea.self, forKey: .stagingArea)
        stagingArea = stagingAreaDecoded
        let sourceCloudPropertiesDecoded = try containerValues.decodeIfPresent(DrsClientTypes.SourceCloudProperties.self, forKey: .sourceCloudProperties)
        sourceCloudProperties = sourceCloudPropertiesDecoded
        let replicationDirectionDecoded = try containerValues.decodeIfPresent(DrsClientTypes.ReplicationDirection.self, forKey: .replicationDirection)
        replicationDirection = replicationDirectionDecoded
        let reversedDirectionSourceServerArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reversedDirectionSourceServerArn)
        reversedDirectionSourceServerArn = reversedDirectionSourceServerArnDecoded
        let sourceNetworkIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceNetworkID)
        sourceNetworkID = sourceNetworkIDDecoded
    }
}

enum DisconnectSourceServerOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UninitializedAccountException": return try await UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DrsClientTypes.Disk: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bytes
        case deviceName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if bytes != 0 {
            try encodeContainer.encode(bytes, forKey: .bytes)
        }
        if let deviceName = self.deviceName {
            try encodeContainer.encode(deviceName, forKey: .deviceName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceName)
        deviceName = deviceNameDecoded
        let bytesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .bytes) ?? 0
        bytes = bytesDecoded
    }
}

extension DrsClientTypes {
    /// An object representing a data storage device on a server.
    public struct Disk: Swift.Equatable {
        /// The amount of storage on the disk in bytes.
        public var bytes: Swift.Int
        /// The disk or device name.
        public var deviceName: Swift.String?

        public init(
            bytes: Swift.Int = 0,
            deviceName: Swift.String? = nil
        )
        {
            self.bytes = bytes
            self.deviceName = deviceName
        }
    }

}

extension DrsClientTypes {
    public enum EC2InstanceState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case notFound
        case pending
        case running
        case shuttingDown
        case stopped
        case stopping
        case terminated
        case sdkUnknown(Swift.String)

        public static var allCases: [EC2InstanceState] {
            return [
                .notFound,
                .pending,
                .running,
                .shuttingDown,
                .stopped,
                .stopping,
                .terminated,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .notFound: return "NOT_FOUND"
            case .pending: return "PENDING"
            case .running: return "RUNNING"
            case .shuttingDown: return "SHUTTING-DOWN"
            case .stopped: return "STOPPED"
            case .stopping: return "STOPPING"
            case .terminated: return "TERMINATED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EC2InstanceState(rawValue: rawValue) ?? EC2InstanceState.sdkUnknown(rawValue)
        }
    }
}

extension DrsClientTypes.EventResourceData: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sdkUnknown
        case sourcenetworkdata = "sourceNetworkData"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .sourcenetworkdata(sourcenetworkdata):
                try container.encode(sourcenetworkdata, forKey: .sourcenetworkdata)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let sourcenetworkdataDecoded = try values.decodeIfPresent(DrsClientTypes.SourceNetworkData.self, forKey: .sourcenetworkdata)
        if let sourcenetworkdata = sourcenetworkdataDecoded {
            self = .sourcenetworkdata(sourcenetworkdata)
            return
        }
        self = .sdkUnknown("")
    }
}

extension DrsClientTypes {
    /// Properties of resource related to a job event.
    public enum EventResourceData: Swift.Equatable {
        /// Source Network properties.
        case sourcenetworkdata(DrsClientTypes.SourceNetworkData)
        case sdkUnknown(Swift.String)
    }

}

extension ExportSourceNetworkCfnTemplateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sourceNetworkID
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sourceNetworkID = self.sourceNetworkID {
            try encodeContainer.encode(sourceNetworkID, forKey: .sourceNetworkID)
        }
    }
}

extension ExportSourceNetworkCfnTemplateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/ExportSourceNetworkCfnTemplate"
    }
}

public struct ExportSourceNetworkCfnTemplateInput: Swift.Equatable {
    /// The Source Network ID to export its CloudFormation template to an S3 bucket.
    /// This member is required.
    public var sourceNetworkID: Swift.String?

    public init(
        sourceNetworkID: Swift.String? = nil
    )
    {
        self.sourceNetworkID = sourceNetworkID
    }
}

struct ExportSourceNetworkCfnTemplateInputBody: Swift.Equatable {
    let sourceNetworkID: Swift.String?
}

extension ExportSourceNetworkCfnTemplateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sourceNetworkID
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceNetworkIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceNetworkID)
        sourceNetworkID = sourceNetworkIDDecoded
    }
}

extension ExportSourceNetworkCfnTemplateOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ExportSourceNetworkCfnTemplateOutputBody = try responseDecoder.decode(responseBody: data)
            self.s3DestinationUrl = output.s3DestinationUrl
        } else {
            self.s3DestinationUrl = nil
        }
    }
}

public struct ExportSourceNetworkCfnTemplateOutput: Swift.Equatable {
    /// S3 bucket URL where the Source Network CloudFormation template was exported to.
    public var s3DestinationUrl: Swift.String?

    public init(
        s3DestinationUrl: Swift.String? = nil
    )
    {
        self.s3DestinationUrl = s3DestinationUrl
    }
}

struct ExportSourceNetworkCfnTemplateOutputBody: Swift.Equatable {
    let s3DestinationUrl: Swift.String?
}

extension ExportSourceNetworkCfnTemplateOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3DestinationUrl
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3DestinationUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3DestinationUrl)
        s3DestinationUrl = s3DestinationUrlDecoded
    }
}

enum ExportSourceNetworkCfnTemplateOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UninitializedAccountException": return try await UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DrsClientTypes {
    public enum ExtensionStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case extended
        case extensionError
        case notExtended
        case sdkUnknown(Swift.String)

        public static var allCases: [ExtensionStatus] {
            return [
                .extended,
                .extensionError,
                .notExtended,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .extended: return "EXTENDED"
            case .extensionError: return "EXTENSION_ERROR"
            case .notExtended: return "NOT_EXTENDED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ExtensionStatus(rawValue: rawValue) ?? ExtensionStatus.sdkUnknown(rawValue)
        }
    }
}

extension DrsClientTypes {
    public enum FailbackLaunchType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case drill
        case recovery
        case sdkUnknown(Swift.String)

        public static var allCases: [FailbackLaunchType] {
            return [
                .drill,
                .recovery,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .drill: return "DRILL"
            case .recovery: return "RECOVERY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FailbackLaunchType(rawValue: rawValue) ?? FailbackLaunchType.sdkUnknown(rawValue)
        }
    }
}

extension DrsClientTypes {
    public enum FailbackReplicationError: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case agentNotSeen
        case failbackClientNotSeen
        case failedGettingReplicationState
        case failedToAttachStagingDisks
        case failedToAuthenticateWithService
        case failedToBootReplicationServer
        case failedToConfigureReplicationSoftware
        case failedToConnectAgentToReplicationServer
        case failedToCreateSecurityGroup
        case failedToCreateStagingDisks
        case failedToDownloadReplicationSoftware
        case failedToDownloadReplicationSoftwareToFailbackClient
        case failedToEstablishAgentReplicatorSoftwareCommunication
        case failedToEstablishRecoveryInstanceCommunication
        case failedToLaunchReplicationServer
        case failedToPairAgentWithReplicationSoftware
        case failedToPairReplicationServerWithAgent
        case failedToStartDataTransfer
        case notConverging
        case snapshotsFailure
        case unstableNetwork
        case sdkUnknown(Swift.String)

        public static var allCases: [FailbackReplicationError] {
            return [
                .agentNotSeen,
                .failbackClientNotSeen,
                .failedGettingReplicationState,
                .failedToAttachStagingDisks,
                .failedToAuthenticateWithService,
                .failedToBootReplicationServer,
                .failedToConfigureReplicationSoftware,
                .failedToConnectAgentToReplicationServer,
                .failedToCreateSecurityGroup,
                .failedToCreateStagingDisks,
                .failedToDownloadReplicationSoftware,
                .failedToDownloadReplicationSoftwareToFailbackClient,
                .failedToEstablishAgentReplicatorSoftwareCommunication,
                .failedToEstablishRecoveryInstanceCommunication,
                .failedToLaunchReplicationServer,
                .failedToPairAgentWithReplicationSoftware,
                .failedToPairReplicationServerWithAgent,
                .failedToStartDataTransfer,
                .notConverging,
                .snapshotsFailure,
                .unstableNetwork,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .agentNotSeen: return "AGENT_NOT_SEEN"
            case .failbackClientNotSeen: return "FAILBACK_CLIENT_NOT_SEEN"
            case .failedGettingReplicationState: return "FAILED_GETTING_REPLICATION_STATE"
            case .failedToAttachStagingDisks: return "FAILED_TO_ATTACH_STAGING_DISKS"
            case .failedToAuthenticateWithService: return "FAILED_TO_AUTHENTICATE_WITH_SERVICE"
            case .failedToBootReplicationServer: return "FAILED_TO_BOOT_REPLICATION_SERVER"
            case .failedToConfigureReplicationSoftware: return "FAILED_TO_CONFIGURE_REPLICATION_SOFTWARE"
            case .failedToConnectAgentToReplicationServer: return "FAILED_TO_CONNECT_AGENT_TO_REPLICATION_SERVER"
            case .failedToCreateSecurityGroup: return "FAILED_TO_CREATE_SECURITY_GROUP"
            case .failedToCreateStagingDisks: return "FAILED_TO_CREATE_STAGING_DISKS"
            case .failedToDownloadReplicationSoftware: return "FAILED_TO_DOWNLOAD_REPLICATION_SOFTWARE"
            case .failedToDownloadReplicationSoftwareToFailbackClient: return "FAILED_TO_DOWNLOAD_REPLICATION_SOFTWARE_TO_FAILBACK_CLIENT"
            case .failedToEstablishAgentReplicatorSoftwareCommunication: return "FAILED_TO_ESTABLISH_AGENT_REPLICATOR_SOFTWARE_COMMUNICATION"
            case .failedToEstablishRecoveryInstanceCommunication: return "FAILED_TO_ESTABLISH_RECOVERY_INSTANCE_COMMUNICATION"
            case .failedToLaunchReplicationServer: return "FAILED_TO_LAUNCH_REPLICATION_SERVER"
            case .failedToPairAgentWithReplicationSoftware: return "FAILED_TO_PAIR_AGENT_WITH_REPLICATION_SOFTWARE"
            case .failedToPairReplicationServerWithAgent: return "FAILED_TO_PAIR_REPLICATION_SERVER_WITH_AGENT"
            case .failedToStartDataTransfer: return "FAILED_TO_START_DATA_TRANSFER"
            case .notConverging: return "NOT_CONVERGING"
            case .snapshotsFailure: return "SNAPSHOTS_FAILURE"
            case .unstableNetwork: return "UNSTABLE_NETWORK"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FailbackReplicationError(rawValue: rawValue) ?? FailbackReplicationError.sdkUnknown(rawValue)
        }
    }
}

extension DrsClientTypes {
    public enum FailbackState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failbackCompleted
        case failbackError
        case failbackInProgress
        case failbackLaunchStateNotAvailable
        case failbackNotReadyForLaunch
        case failbackNotStarted
        case failbackReadyForLaunch
        case sdkUnknown(Swift.String)

        public static var allCases: [FailbackState] {
            return [
                .failbackCompleted,
                .failbackError,
                .failbackInProgress,
                .failbackLaunchStateNotAvailable,
                .failbackNotReadyForLaunch,
                .failbackNotStarted,
                .failbackReadyForLaunch,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failbackCompleted: return "FAILBACK_COMPLETED"
            case .failbackError: return "FAILBACK_ERROR"
            case .failbackInProgress: return "FAILBACK_IN_PROGRESS"
            case .failbackLaunchStateNotAvailable: return "FAILBACK_LAUNCH_STATE_NOT_AVAILABLE"
            case .failbackNotReadyForLaunch: return "FAILBACK_NOT_READY_FOR_LAUNCH"
            case .failbackNotStarted: return "FAILBACK_NOT_STARTED"
            case .failbackReadyForLaunch: return "FAILBACK_READY_FOR_LAUNCH"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FailbackState(rawValue: rawValue) ?? FailbackState.sdkUnknown(rawValue)
        }
    }
}

extension GetFailbackReplicationConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case recoveryInstanceID
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let recoveryInstanceID = self.recoveryInstanceID {
            try encodeContainer.encode(recoveryInstanceID, forKey: .recoveryInstanceID)
        }
    }
}

extension GetFailbackReplicationConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/GetFailbackReplicationConfiguration"
    }
}

public struct GetFailbackReplicationConfigurationInput: Swift.Equatable {
    /// The ID of the Recovery Instance whose failback replication configuration should be returned.
    /// This member is required.
    public var recoveryInstanceID: Swift.String?

    public init(
        recoveryInstanceID: Swift.String? = nil
    )
    {
        self.recoveryInstanceID = recoveryInstanceID
    }
}

struct GetFailbackReplicationConfigurationInputBody: Swift.Equatable {
    let recoveryInstanceID: Swift.String?
}

extension GetFailbackReplicationConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case recoveryInstanceID
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recoveryInstanceIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recoveryInstanceID)
        recoveryInstanceID = recoveryInstanceIDDecoded
    }
}

extension GetFailbackReplicationConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetFailbackReplicationConfigurationOutputBody = try responseDecoder.decode(responseBody: data)
            self.bandwidthThrottling = output.bandwidthThrottling
            self.name = output.name
            self.recoveryInstanceID = output.recoveryInstanceID
            self.usePrivateIP = output.usePrivateIP
        } else {
            self.bandwidthThrottling = 0
            self.name = nil
            self.recoveryInstanceID = nil
            self.usePrivateIP = nil
        }
    }
}

public struct GetFailbackReplicationConfigurationOutput: Swift.Equatable {
    /// Configure bandwidth throttling for the outbound data transfer rate of the Recovery Instance in Mbps.
    public var bandwidthThrottling: Swift.Int
    /// The name of the Failback Replication Configuration.
    public var name: Swift.String?
    /// The ID of the Recovery Instance.
    /// This member is required.
    public var recoveryInstanceID: Swift.String?
    /// Whether to use Private IP for the failback replication of the Recovery Instance.
    public var usePrivateIP: Swift.Bool?

    public init(
        bandwidthThrottling: Swift.Int = 0,
        name: Swift.String? = nil,
        recoveryInstanceID: Swift.String? = nil,
        usePrivateIP: Swift.Bool? = nil
    )
    {
        self.bandwidthThrottling = bandwidthThrottling
        self.name = name
        self.recoveryInstanceID = recoveryInstanceID
        self.usePrivateIP = usePrivateIP
    }
}

struct GetFailbackReplicationConfigurationOutputBody: Swift.Equatable {
    let recoveryInstanceID: Swift.String?
    let name: Swift.String?
    let bandwidthThrottling: Swift.Int
    let usePrivateIP: Swift.Bool?
}

extension GetFailbackReplicationConfigurationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bandwidthThrottling
        case name
        case recoveryInstanceID
        case usePrivateIP
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recoveryInstanceIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recoveryInstanceID)
        recoveryInstanceID = recoveryInstanceIDDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let bandwidthThrottlingDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .bandwidthThrottling) ?? 0
        bandwidthThrottling = bandwidthThrottlingDecoded
        let usePrivateIPDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .usePrivateIP)
        usePrivateIP = usePrivateIPDecoded
    }
}

enum GetFailbackReplicationConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UninitializedAccountException": return try await UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetLaunchConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sourceServerID
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sourceServerID = self.sourceServerID {
            try encodeContainer.encode(sourceServerID, forKey: .sourceServerID)
        }
    }
}

extension GetLaunchConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/GetLaunchConfiguration"
    }
}

public struct GetLaunchConfigurationInput: Swift.Equatable {
    /// The ID of the Source Server that we want to retrieve a Launch Configuration for.
    /// This member is required.
    public var sourceServerID: Swift.String?

    public init(
        sourceServerID: Swift.String? = nil
    )
    {
        self.sourceServerID = sourceServerID
    }
}

struct GetLaunchConfigurationInputBody: Swift.Equatable {
    let sourceServerID: Swift.String?
}

extension GetLaunchConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sourceServerID
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceServerIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceServerID)
        sourceServerID = sourceServerIDDecoded
    }
}

extension GetLaunchConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetLaunchConfigurationOutputBody = try responseDecoder.decode(responseBody: data)
            self.copyPrivateIp = output.copyPrivateIp
            self.copyTags = output.copyTags
            self.ec2LaunchTemplateID = output.ec2LaunchTemplateID
            self.launchDisposition = output.launchDisposition
            self.licensing = output.licensing
            self.name = output.name
            self.postLaunchEnabled = output.postLaunchEnabled
            self.sourceServerID = output.sourceServerID
            self.targetInstanceTypeRightSizingMethod = output.targetInstanceTypeRightSizingMethod
        } else {
            self.copyPrivateIp = nil
            self.copyTags = nil
            self.ec2LaunchTemplateID = nil
            self.launchDisposition = nil
            self.licensing = nil
            self.name = nil
            self.postLaunchEnabled = nil
            self.sourceServerID = nil
            self.targetInstanceTypeRightSizingMethod = nil
        }
    }
}

public struct GetLaunchConfigurationOutput: Swift.Equatable {
    /// Whether we should copy the Private IP of the Source Server to the Recovery Instance.
    public var copyPrivateIp: Swift.Bool?
    /// Whether we want to copy the tags of the Source Server to the EC2 machine of the Recovery Instance.
    public var copyTags: Swift.Bool?
    /// The EC2 launch template ID of this launch configuration.
    public var ec2LaunchTemplateID: Swift.String?
    /// The state of the Recovery Instance in EC2 after the recovery operation.
    public var launchDisposition: DrsClientTypes.LaunchDisposition?
    /// The licensing configuration to be used for this launch configuration.
    public var licensing: DrsClientTypes.Licensing?
    /// The name of the launch configuration.
    public var name: Swift.String?
    /// Whether we want to activate post-launch actions for the Source Server.
    public var postLaunchEnabled: Swift.Bool?
    /// The ID of the Source Server for this launch configuration.
    public var sourceServerID: Swift.String?
    /// Whether Elastic Disaster Recovery should try to automatically choose the instance type that best matches the OS, CPU, and RAM of your Source Server.
    public var targetInstanceTypeRightSizingMethod: DrsClientTypes.TargetInstanceTypeRightSizingMethod?

    public init(
        copyPrivateIp: Swift.Bool? = nil,
        copyTags: Swift.Bool? = nil,
        ec2LaunchTemplateID: Swift.String? = nil,
        launchDisposition: DrsClientTypes.LaunchDisposition? = nil,
        licensing: DrsClientTypes.Licensing? = nil,
        name: Swift.String? = nil,
        postLaunchEnabled: Swift.Bool? = nil,
        sourceServerID: Swift.String? = nil,
        targetInstanceTypeRightSizingMethod: DrsClientTypes.TargetInstanceTypeRightSizingMethod? = nil
    )
    {
        self.copyPrivateIp = copyPrivateIp
        self.copyTags = copyTags
        self.ec2LaunchTemplateID = ec2LaunchTemplateID
        self.launchDisposition = launchDisposition
        self.licensing = licensing
        self.name = name
        self.postLaunchEnabled = postLaunchEnabled
        self.sourceServerID = sourceServerID
        self.targetInstanceTypeRightSizingMethod = targetInstanceTypeRightSizingMethod
    }
}

struct GetLaunchConfigurationOutputBody: Swift.Equatable {
    let sourceServerID: Swift.String?
    let name: Swift.String?
    let ec2LaunchTemplateID: Swift.String?
    let launchDisposition: DrsClientTypes.LaunchDisposition?
    let targetInstanceTypeRightSizingMethod: DrsClientTypes.TargetInstanceTypeRightSizingMethod?
    let copyPrivateIp: Swift.Bool?
    let copyTags: Swift.Bool?
    let licensing: DrsClientTypes.Licensing?
    let postLaunchEnabled: Swift.Bool?
}

extension GetLaunchConfigurationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case copyPrivateIp
        case copyTags
        case ec2LaunchTemplateID
        case launchDisposition
        case licensing
        case name
        case postLaunchEnabled
        case sourceServerID
        case targetInstanceTypeRightSizingMethod
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceServerIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceServerID)
        sourceServerID = sourceServerIDDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let ec2LaunchTemplateIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ec2LaunchTemplateID)
        ec2LaunchTemplateID = ec2LaunchTemplateIDDecoded
        let launchDispositionDecoded = try containerValues.decodeIfPresent(DrsClientTypes.LaunchDisposition.self, forKey: .launchDisposition)
        launchDisposition = launchDispositionDecoded
        let targetInstanceTypeRightSizingMethodDecoded = try containerValues.decodeIfPresent(DrsClientTypes.TargetInstanceTypeRightSizingMethod.self, forKey: .targetInstanceTypeRightSizingMethod)
        targetInstanceTypeRightSizingMethod = targetInstanceTypeRightSizingMethodDecoded
        let copyPrivateIpDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .copyPrivateIp)
        copyPrivateIp = copyPrivateIpDecoded
        let copyTagsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .copyTags)
        copyTags = copyTagsDecoded
        let licensingDecoded = try containerValues.decodeIfPresent(DrsClientTypes.Licensing.self, forKey: .licensing)
        licensing = licensingDecoded
        let postLaunchEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .postLaunchEnabled)
        postLaunchEnabled = postLaunchEnabledDecoded
    }
}

enum GetLaunchConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UninitializedAccountException": return try await UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetReplicationConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sourceServerID
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sourceServerID = self.sourceServerID {
            try encodeContainer.encode(sourceServerID, forKey: .sourceServerID)
        }
    }
}

extension GetReplicationConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/GetReplicationConfiguration"
    }
}

public struct GetReplicationConfigurationInput: Swift.Equatable {
    /// The ID of the Source Serve for this Replication Configuration.r
    /// This member is required.
    public var sourceServerID: Swift.String?

    public init(
        sourceServerID: Swift.String? = nil
    )
    {
        self.sourceServerID = sourceServerID
    }
}

struct GetReplicationConfigurationInputBody: Swift.Equatable {
    let sourceServerID: Swift.String?
}

extension GetReplicationConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sourceServerID
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceServerIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceServerID)
        sourceServerID = sourceServerIDDecoded
    }
}

extension GetReplicationConfigurationOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetReplicationConfigurationOutput(associateDefaultSecurityGroup: \(Swift.String(describing: associateDefaultSecurityGroup)), autoReplicateNewDisks: \(Swift.String(describing: autoReplicateNewDisks)), bandwidthThrottling: \(Swift.String(describing: bandwidthThrottling)), createPublicIP: \(Swift.String(describing: createPublicIP)), dataPlaneRouting: \(Swift.String(describing: dataPlaneRouting)), defaultLargeStagingDiskType: \(Swift.String(describing: defaultLargeStagingDiskType)), ebsEncryption: \(Swift.String(describing: ebsEncryption)), ebsEncryptionKeyArn: \(Swift.String(describing: ebsEncryptionKeyArn)), name: \(Swift.String(describing: name)), pitPolicy: \(Swift.String(describing: pitPolicy)), replicatedDisks: \(Swift.String(describing: replicatedDisks)), replicationServerInstanceType: \(Swift.String(describing: replicationServerInstanceType)), replicationServersSecurityGroupsIDs: \(Swift.String(describing: replicationServersSecurityGroupsIDs)), sourceServerID: \(Swift.String(describing: sourceServerID)), stagingAreaSubnetId: \(Swift.String(describing: stagingAreaSubnetId)), useDedicatedReplicationServer: \(Swift.String(describing: useDedicatedReplicationServer)), stagingAreaTags: \"CONTENT_REDACTED\")"}
}

extension GetReplicationConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetReplicationConfigurationOutputBody = try responseDecoder.decode(responseBody: data)
            self.associateDefaultSecurityGroup = output.associateDefaultSecurityGroup
            self.autoReplicateNewDisks = output.autoReplicateNewDisks
            self.bandwidthThrottling = output.bandwidthThrottling
            self.createPublicIP = output.createPublicIP
            self.dataPlaneRouting = output.dataPlaneRouting
            self.defaultLargeStagingDiskType = output.defaultLargeStagingDiskType
            self.ebsEncryption = output.ebsEncryption
            self.ebsEncryptionKeyArn = output.ebsEncryptionKeyArn
            self.name = output.name
            self.pitPolicy = output.pitPolicy
            self.replicatedDisks = output.replicatedDisks
            self.replicationServerInstanceType = output.replicationServerInstanceType
            self.replicationServersSecurityGroupsIDs = output.replicationServersSecurityGroupsIDs
            self.sourceServerID = output.sourceServerID
            self.stagingAreaSubnetId = output.stagingAreaSubnetId
            self.stagingAreaTags = output.stagingAreaTags
            self.useDedicatedReplicationServer = output.useDedicatedReplicationServer
        } else {
            self.associateDefaultSecurityGroup = nil
            self.autoReplicateNewDisks = nil
            self.bandwidthThrottling = 0
            self.createPublicIP = nil
            self.dataPlaneRouting = nil
            self.defaultLargeStagingDiskType = nil
            self.ebsEncryption = nil
            self.ebsEncryptionKeyArn = nil
            self.name = nil
            self.pitPolicy = nil
            self.replicatedDisks = nil
            self.replicationServerInstanceType = nil
            self.replicationServersSecurityGroupsIDs = nil
            self.sourceServerID = nil
            self.stagingAreaSubnetId = nil
            self.stagingAreaTags = nil
            self.useDedicatedReplicationServer = nil
        }
    }
}

public struct GetReplicationConfigurationOutput: Swift.Equatable {
    /// Whether to associate the default Elastic Disaster Recovery Security group with the Replication Configuration.
    public var associateDefaultSecurityGroup: Swift.Bool?
    /// Whether to allow the AWS replication agent to automatically replicate newly added disks.
    public var autoReplicateNewDisks: Swift.Bool?
    /// Configure bandwidth throttling for the outbound data transfer rate of the Source Server in Mbps.
    public var bandwidthThrottling: Swift.Int
    /// Whether to create a Public IP for the Recovery Instance by default.
    public var createPublicIP: Swift.Bool?
    /// The data plane routing mechanism that will be used for replication.
    public var dataPlaneRouting: DrsClientTypes.ReplicationConfigurationDataPlaneRouting?
    /// The Staging Disk EBS volume type to be used during replication.
    public var defaultLargeStagingDiskType: DrsClientTypes.ReplicationConfigurationDefaultLargeStagingDiskType?
    /// The type of EBS encryption to be used during replication.
    public var ebsEncryption: DrsClientTypes.ReplicationConfigurationEbsEncryption?
    /// The ARN of the EBS encryption key to be used during replication.
    public var ebsEncryptionKeyArn: Swift.String?
    /// The name of the Replication Configuration.
    public var name: Swift.String?
    /// The Point in time (PIT) policy to manage snapshots taken during replication.
    public var pitPolicy: [DrsClientTypes.PITPolicyRule]?
    /// The configuration of the disks of the Source Server to be replicated.
    public var replicatedDisks: [DrsClientTypes.ReplicationConfigurationReplicatedDisk]?
    /// The instance type to be used for the replication server.
    public var replicationServerInstanceType: Swift.String?
    /// The security group IDs that will be used by the replication server.
    public var replicationServersSecurityGroupsIDs: [Swift.String]?
    /// The ID of the Source Server for this Replication Configuration.
    public var sourceServerID: Swift.String?
    /// The subnet to be used by the replication staging area.
    public var stagingAreaSubnetId: Swift.String?
    /// A set of tags to be associated with all resources created in the replication staging area: EC2 replication server, EBS volumes, EBS snapshots, etc.
    public var stagingAreaTags: [Swift.String:Swift.String]?
    /// Whether to use a dedicated Replication Server in the replication staging area.
    public var useDedicatedReplicationServer: Swift.Bool?

    public init(
        associateDefaultSecurityGroup: Swift.Bool? = nil,
        autoReplicateNewDisks: Swift.Bool? = nil,
        bandwidthThrottling: Swift.Int = 0,
        createPublicIP: Swift.Bool? = nil,
        dataPlaneRouting: DrsClientTypes.ReplicationConfigurationDataPlaneRouting? = nil,
        defaultLargeStagingDiskType: DrsClientTypes.ReplicationConfigurationDefaultLargeStagingDiskType? = nil,
        ebsEncryption: DrsClientTypes.ReplicationConfigurationEbsEncryption? = nil,
        ebsEncryptionKeyArn: Swift.String? = nil,
        name: Swift.String? = nil,
        pitPolicy: [DrsClientTypes.PITPolicyRule]? = nil,
        replicatedDisks: [DrsClientTypes.ReplicationConfigurationReplicatedDisk]? = nil,
        replicationServerInstanceType: Swift.String? = nil,
        replicationServersSecurityGroupsIDs: [Swift.String]? = nil,
        sourceServerID: Swift.String? = nil,
        stagingAreaSubnetId: Swift.String? = nil,
        stagingAreaTags: [Swift.String:Swift.String]? = nil,
        useDedicatedReplicationServer: Swift.Bool? = nil
    )
    {
        self.associateDefaultSecurityGroup = associateDefaultSecurityGroup
        self.autoReplicateNewDisks = autoReplicateNewDisks
        self.bandwidthThrottling = bandwidthThrottling
        self.createPublicIP = createPublicIP
        self.dataPlaneRouting = dataPlaneRouting
        self.defaultLargeStagingDiskType = defaultLargeStagingDiskType
        self.ebsEncryption = ebsEncryption
        self.ebsEncryptionKeyArn = ebsEncryptionKeyArn
        self.name = name
        self.pitPolicy = pitPolicy
        self.replicatedDisks = replicatedDisks
        self.replicationServerInstanceType = replicationServerInstanceType
        self.replicationServersSecurityGroupsIDs = replicationServersSecurityGroupsIDs
        self.sourceServerID = sourceServerID
        self.stagingAreaSubnetId = stagingAreaSubnetId
        self.stagingAreaTags = stagingAreaTags
        self.useDedicatedReplicationServer = useDedicatedReplicationServer
    }
}

struct GetReplicationConfigurationOutputBody: Swift.Equatable {
    let sourceServerID: Swift.String?
    let name: Swift.String?
    let stagingAreaSubnetId: Swift.String?
    let associateDefaultSecurityGroup: Swift.Bool?
    let replicationServersSecurityGroupsIDs: [Swift.String]?
    let replicationServerInstanceType: Swift.String?
    let useDedicatedReplicationServer: Swift.Bool?
    let defaultLargeStagingDiskType: DrsClientTypes.ReplicationConfigurationDefaultLargeStagingDiskType?
    let replicatedDisks: [DrsClientTypes.ReplicationConfigurationReplicatedDisk]?
    let ebsEncryption: DrsClientTypes.ReplicationConfigurationEbsEncryption?
    let ebsEncryptionKeyArn: Swift.String?
    let bandwidthThrottling: Swift.Int
    let dataPlaneRouting: DrsClientTypes.ReplicationConfigurationDataPlaneRouting?
    let createPublicIP: Swift.Bool?
    let stagingAreaTags: [Swift.String:Swift.String]?
    let pitPolicy: [DrsClientTypes.PITPolicyRule]?
    let autoReplicateNewDisks: Swift.Bool?
}

extension GetReplicationConfigurationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associateDefaultSecurityGroup
        case autoReplicateNewDisks
        case bandwidthThrottling
        case createPublicIP
        case dataPlaneRouting
        case defaultLargeStagingDiskType
        case ebsEncryption
        case ebsEncryptionKeyArn
        case name
        case pitPolicy
        case replicatedDisks
        case replicationServerInstanceType
        case replicationServersSecurityGroupsIDs
        case sourceServerID
        case stagingAreaSubnetId
        case stagingAreaTags
        case useDedicatedReplicationServer
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceServerIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceServerID)
        sourceServerID = sourceServerIDDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let stagingAreaSubnetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stagingAreaSubnetId)
        stagingAreaSubnetId = stagingAreaSubnetIdDecoded
        let associateDefaultSecurityGroupDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .associateDefaultSecurityGroup)
        associateDefaultSecurityGroup = associateDefaultSecurityGroupDecoded
        let replicationServersSecurityGroupsIDsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .replicationServersSecurityGroupsIDs)
        var replicationServersSecurityGroupsIDsDecoded0:[Swift.String]? = nil
        if let replicationServersSecurityGroupsIDsContainer = replicationServersSecurityGroupsIDsContainer {
            replicationServersSecurityGroupsIDsDecoded0 = [Swift.String]()
            for string0 in replicationServersSecurityGroupsIDsContainer {
                if let string0 = string0 {
                    replicationServersSecurityGroupsIDsDecoded0?.append(string0)
                }
            }
        }
        replicationServersSecurityGroupsIDs = replicationServersSecurityGroupsIDsDecoded0
        let replicationServerInstanceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationServerInstanceType)
        replicationServerInstanceType = replicationServerInstanceTypeDecoded
        let useDedicatedReplicationServerDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .useDedicatedReplicationServer)
        useDedicatedReplicationServer = useDedicatedReplicationServerDecoded
        let defaultLargeStagingDiskTypeDecoded = try containerValues.decodeIfPresent(DrsClientTypes.ReplicationConfigurationDefaultLargeStagingDiskType.self, forKey: .defaultLargeStagingDiskType)
        defaultLargeStagingDiskType = defaultLargeStagingDiskTypeDecoded
        let replicatedDisksContainer = try containerValues.decodeIfPresent([DrsClientTypes.ReplicationConfigurationReplicatedDisk?].self, forKey: .replicatedDisks)
        var replicatedDisksDecoded0:[DrsClientTypes.ReplicationConfigurationReplicatedDisk]? = nil
        if let replicatedDisksContainer = replicatedDisksContainer {
            replicatedDisksDecoded0 = [DrsClientTypes.ReplicationConfigurationReplicatedDisk]()
            for structure0 in replicatedDisksContainer {
                if let structure0 = structure0 {
                    replicatedDisksDecoded0?.append(structure0)
                }
            }
        }
        replicatedDisks = replicatedDisksDecoded0
        let ebsEncryptionDecoded = try containerValues.decodeIfPresent(DrsClientTypes.ReplicationConfigurationEbsEncryption.self, forKey: .ebsEncryption)
        ebsEncryption = ebsEncryptionDecoded
        let ebsEncryptionKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ebsEncryptionKeyArn)
        ebsEncryptionKeyArn = ebsEncryptionKeyArnDecoded
        let bandwidthThrottlingDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .bandwidthThrottling) ?? 0
        bandwidthThrottling = bandwidthThrottlingDecoded
        let dataPlaneRoutingDecoded = try containerValues.decodeIfPresent(DrsClientTypes.ReplicationConfigurationDataPlaneRouting.self, forKey: .dataPlaneRouting)
        dataPlaneRouting = dataPlaneRoutingDecoded
        let createPublicIPDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .createPublicIP)
        createPublicIP = createPublicIPDecoded
        let stagingAreaTagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .stagingAreaTags)
        var stagingAreaTagsDecoded0: [Swift.String:Swift.String]? = nil
        if let stagingAreaTagsContainer = stagingAreaTagsContainer {
            stagingAreaTagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in stagingAreaTagsContainer {
                if let tagvalue0 = tagvalue0 {
                    stagingAreaTagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        stagingAreaTags = stagingAreaTagsDecoded0
        let pitPolicyContainer = try containerValues.decodeIfPresent([DrsClientTypes.PITPolicyRule?].self, forKey: .pitPolicy)
        var pitPolicyDecoded0:[DrsClientTypes.PITPolicyRule]? = nil
        if let pitPolicyContainer = pitPolicyContainer {
            pitPolicyDecoded0 = [DrsClientTypes.PITPolicyRule]()
            for structure0 in pitPolicyContainer {
                if let structure0 = structure0 {
                    pitPolicyDecoded0?.append(structure0)
                }
            }
        }
        pitPolicy = pitPolicyDecoded0
        let autoReplicateNewDisksDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .autoReplicateNewDisks)
        autoReplicateNewDisks = autoReplicateNewDisksDecoded
    }
}

enum GetReplicationConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UninitializedAccountException": return try await UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DrsClientTypes.IdentificationHints: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsInstanceID
        case fqdn
        case hostname
        case vmWareUuid
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let awsInstanceID = self.awsInstanceID {
            try encodeContainer.encode(awsInstanceID, forKey: .awsInstanceID)
        }
        if let fqdn = self.fqdn {
            try encodeContainer.encode(fqdn, forKey: .fqdn)
        }
        if let hostname = self.hostname {
            try encodeContainer.encode(hostname, forKey: .hostname)
        }
        if let vmWareUuid = self.vmWareUuid {
            try encodeContainer.encode(vmWareUuid, forKey: .vmWareUuid)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fqdnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fqdn)
        fqdn = fqdnDecoded
        let hostnameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hostname)
        hostname = hostnameDecoded
        let vmWareUuidDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vmWareUuid)
        vmWareUuid = vmWareUuidDecoded
        let awsInstanceIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsInstanceID)
        awsInstanceID = awsInstanceIDDecoded
    }
}

extension DrsClientTypes {
    /// Hints used to uniquely identify a machine.
    public struct IdentificationHints: Swift.Equatable {
        /// AWS Instance ID identification hint.
        public var awsInstanceID: Swift.String?
        /// Fully Qualified Domain Name identification hint.
        public var fqdn: Swift.String?
        /// Hostname identification hint.
        public var hostname: Swift.String?
        /// vCenter VM path identification hint.
        public var vmWareUuid: Swift.String?

        public init(
            awsInstanceID: Swift.String? = nil,
            fqdn: Swift.String? = nil,
            hostname: Swift.String? = nil,
            vmWareUuid: Swift.String? = nil
        )
        {
            self.awsInstanceID = awsInstanceID
            self.fqdn = fqdn
            self.hostname = hostname
            self.vmWareUuid = vmWareUuid
        }
    }

}

extension InitializeServiceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/InitializeService"
    }
}

public struct InitializeServiceInput: Swift.Equatable {

    public init() { }
}

struct InitializeServiceInputBody: Swift.Equatable {
}

extension InitializeServiceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension InitializeServiceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct InitializeServiceOutput: Swift.Equatable {

    public init() { }
}

enum InitializeServiceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DrsClientTypes {
    public enum InitiatedBy: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case associateNetworkRecovery
        case createNetworkRecovery
        case diagnostic
        case failback
        case startDrill
        case startRecovery
        case targetAccount
        case terminateRecoveryInstances
        case updateNetworkRecovery
        case sdkUnknown(Swift.String)

        public static var allCases: [InitiatedBy] {
            return [
                .associateNetworkRecovery,
                .createNetworkRecovery,
                .diagnostic,
                .failback,
                .startDrill,
                .startRecovery,
                .targetAccount,
                .terminateRecoveryInstances,
                .updateNetworkRecovery,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .associateNetworkRecovery: return "ASSOCIATE_NETWORK_RECOVERY"
            case .createNetworkRecovery: return "CREATE_NETWORK_RECOVERY"
            case .diagnostic: return "DIAGNOSTIC"
            case .failback: return "FAILBACK"
            case .startDrill: return "START_DRILL"
            case .startRecovery: return "START_RECOVERY"
            case .targetAccount: return "TARGET_ACCOUNT"
            case .terminateRecoveryInstances: return "TERMINATE_RECOVERY_INSTANCES"
            case .updateNetworkRecovery: return "UPDATE_NETWORK_RECOVERY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = InitiatedBy(rawValue: rawValue) ?? InitiatedBy.sdkUnknown(rawValue)
        }
    }
}

extension InternalServerException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            self.properties.retryAfterSeconds = Swift.Int(retryAfterSecondsHeaderValue) ?? 0
        } else {
            self.properties.retryAfterSeconds = 0
        }
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request processing has failed because of an unknown error, exception or failure.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The number of seconds after which the request should be safe to retry.
        public internal(set) var retryAfterSeconds: Swift.Int = 0
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        retryAfterSeconds: Swift.Int = 0
    )
    {
        self.properties.message = message
        self.properties.retryAfterSeconds = retryAfterSeconds
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DrsClientTypes.Job: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case creationDateTime
        case endDateTime
        case initiatedBy
        case jobID
        case participatingResources
        case participatingServers
        case status
        case tags
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let creationDateTime = self.creationDateTime {
            try encodeContainer.encode(creationDateTime, forKey: .creationDateTime)
        }
        if let endDateTime = self.endDateTime {
            try encodeContainer.encode(endDateTime, forKey: .endDateTime)
        }
        if let initiatedBy = self.initiatedBy {
            try encodeContainer.encode(initiatedBy.rawValue, forKey: .initiatedBy)
        }
        if let jobID = self.jobID {
            try encodeContainer.encode(jobID, forKey: .jobID)
        }
        if let participatingResources = participatingResources {
            var participatingResourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .participatingResources)
            for participatingresource0 in participatingResources {
                try participatingResourcesContainer.encode(participatingresource0)
            }
        }
        if let participatingServers = participatingServers {
            var participatingServersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .participatingServers)
            for participatingserver0 in participatingServers {
                try participatingServersContainer.encode(participatingserver0)
            }
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagsMap0) in tags {
                try tagsContainer.encode(tagsMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobID)
        jobID = jobIDDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let typeDecoded = try containerValues.decodeIfPresent(DrsClientTypes.JobType.self, forKey: .type)
        type = typeDecoded
        let initiatedByDecoded = try containerValues.decodeIfPresent(DrsClientTypes.InitiatedBy.self, forKey: .initiatedBy)
        initiatedBy = initiatedByDecoded
        let creationDateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let endDateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .endDateTime)
        endDateTime = endDateTimeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(DrsClientTypes.JobStatus.self, forKey: .status)
        status = statusDecoded
        let participatingServersContainer = try containerValues.decodeIfPresent([DrsClientTypes.ParticipatingServer?].self, forKey: .participatingServers)
        var participatingServersDecoded0:[DrsClientTypes.ParticipatingServer]? = nil
        if let participatingServersContainer = participatingServersContainer {
            participatingServersDecoded0 = [DrsClientTypes.ParticipatingServer]()
            for structure0 in participatingServersContainer {
                if let structure0 = structure0 {
                    participatingServersDecoded0?.append(structure0)
                }
            }
        }
        participatingServers = participatingServersDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let participatingResourcesContainer = try containerValues.decodeIfPresent([DrsClientTypes.ParticipatingResource?].self, forKey: .participatingResources)
        var participatingResourcesDecoded0:[DrsClientTypes.ParticipatingResource]? = nil
        if let participatingResourcesContainer = participatingResourcesContainer {
            participatingResourcesDecoded0 = [DrsClientTypes.ParticipatingResource]()
            for structure0 in participatingResourcesContainer {
                if let structure0 = structure0 {
                    participatingResourcesDecoded0?.append(structure0)
                }
            }
        }
        participatingResources = participatingResourcesDecoded0
    }
}

extension DrsClientTypes.Job: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Job(arn: \(Swift.String(describing: arn)), creationDateTime: \(Swift.String(describing: creationDateTime)), endDateTime: \(Swift.String(describing: endDateTime)), initiatedBy: \(Swift.String(describing: initiatedBy)), jobID: \(Swift.String(describing: jobID)), participatingResources: \(Swift.String(describing: participatingResources)), participatingServers: \(Swift.String(describing: participatingServers)), status: \(Swift.String(describing: status)), type: \(Swift.String(describing: type)), tags: \"CONTENT_REDACTED\")"}
}

extension DrsClientTypes {
    /// A job is an asynchronous workflow.
    public struct Job: Swift.Equatable {
        /// The ARN of a Job.
        public var arn: Swift.String?
        /// The date and time of when the Job was created.
        public var creationDateTime: Swift.String?
        /// The date and time of when the Job ended.
        public var endDateTime: Swift.String?
        /// A string representing who initiated the Job.
        public var initiatedBy: DrsClientTypes.InitiatedBy?
        /// The ID of the Job.
        /// This member is required.
        public var jobID: Swift.String?
        /// A list of resources that the Job is acting upon.
        public var participatingResources: [DrsClientTypes.ParticipatingResource]?
        /// A list of servers that the Job is acting upon.
        public var participatingServers: [DrsClientTypes.ParticipatingServer]?
        /// The status of the Job.
        public var status: DrsClientTypes.JobStatus?
        /// A list of tags associated with the Job.
        public var tags: [Swift.String:Swift.String]?
        /// The type of the Job.
        public var type: DrsClientTypes.JobType?

        public init(
            arn: Swift.String? = nil,
            creationDateTime: Swift.String? = nil,
            endDateTime: Swift.String? = nil,
            initiatedBy: DrsClientTypes.InitiatedBy? = nil,
            jobID: Swift.String? = nil,
            participatingResources: [DrsClientTypes.ParticipatingResource]? = nil,
            participatingServers: [DrsClientTypes.ParticipatingServer]? = nil,
            status: DrsClientTypes.JobStatus? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            type: DrsClientTypes.JobType? = nil
        )
        {
            self.arn = arn
            self.creationDateTime = creationDateTime
            self.endDateTime = endDateTime
            self.initiatedBy = initiatedBy
            self.jobID = jobID
            self.participatingResources = participatingResources
            self.participatingServers = participatingServers
            self.status = status
            self.tags = tags
            self.type = type
        }
    }

}

extension DrsClientTypes.JobLog: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case event
        case eventData
        case logDateTime
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let event = self.event {
            try encodeContainer.encode(event.rawValue, forKey: .event)
        }
        if let eventData = self.eventData {
            try encodeContainer.encode(eventData, forKey: .eventData)
        }
        if let logDateTime = self.logDateTime {
            try encodeContainer.encode(logDateTime, forKey: .logDateTime)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let logDateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .logDateTime)
        logDateTime = logDateTimeDecoded
        let eventDecoded = try containerValues.decodeIfPresent(DrsClientTypes.JobLogEvent.self, forKey: .event)
        event = eventDecoded
        let eventDataDecoded = try containerValues.decodeIfPresent(DrsClientTypes.JobLogEventData.self, forKey: .eventData)
        eventData = eventDataDecoded
    }
}

extension DrsClientTypes {
    /// A log outputted by a Job.
    public struct JobLog: Swift.Equatable {
        /// The event represents the type of a log.
        public var event: DrsClientTypes.JobLogEvent?
        /// Metadata associated with a Job log.
        public var eventData: DrsClientTypes.JobLogEventData?
        /// The date and time the log was taken.
        public var logDateTime: Swift.String?

        public init(
            event: DrsClientTypes.JobLogEvent? = nil,
            eventData: DrsClientTypes.JobLogEventData? = nil,
            logDateTime: Swift.String? = nil
        )
        {
            self.event = event
            self.eventData = eventData
            self.logDateTime = logDateTime
        }
    }

}

extension DrsClientTypes {
    public enum JobLogEvent: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cleanupEnd
        case cleanupFail
        case cleanupStart
        case conversionEnd
        case conversionFail
        case conversionStart
        case deployNetworkConfigurationEnd
        case deployNetworkConfigurationFailed
        case deployNetworkConfigurationStart
        case jobCancel
        case jobEnd
        case jobStart
        case launchFailed
        case launchStart
        case networkRecoveryFail
        case serverSkipped
        case snapshotEnd
        case snapshotFail
        case snapshotStart
        case updateLaunchTemplateEnd
        case updateLaunchTemplateFailed
        case updateLaunchTemplateStart
        case updateNetworkConfigurationEnd
        case updateNetworkConfigurationFailed
        case updateNetworkConfigurationStart
        case usingPreviousSnapshot
        case usingPreviousSnapshotFailed
        case sdkUnknown(Swift.String)

        public static var allCases: [JobLogEvent] {
            return [
                .cleanupEnd,
                .cleanupFail,
                .cleanupStart,
                .conversionEnd,
                .conversionFail,
                .conversionStart,
                .deployNetworkConfigurationEnd,
                .deployNetworkConfigurationFailed,
                .deployNetworkConfigurationStart,
                .jobCancel,
                .jobEnd,
                .jobStart,
                .launchFailed,
                .launchStart,
                .networkRecoveryFail,
                .serverSkipped,
                .snapshotEnd,
                .snapshotFail,
                .snapshotStart,
                .updateLaunchTemplateEnd,
                .updateLaunchTemplateFailed,
                .updateLaunchTemplateStart,
                .updateNetworkConfigurationEnd,
                .updateNetworkConfigurationFailed,
                .updateNetworkConfigurationStart,
                .usingPreviousSnapshot,
                .usingPreviousSnapshotFailed,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cleanupEnd: return "CLEANUP_END"
            case .cleanupFail: return "CLEANUP_FAIL"
            case .cleanupStart: return "CLEANUP_START"
            case .conversionEnd: return "CONVERSION_END"
            case .conversionFail: return "CONVERSION_FAIL"
            case .conversionStart: return "CONVERSION_START"
            case .deployNetworkConfigurationEnd: return "DEPLOY_NETWORK_CONFIGURATION_END"
            case .deployNetworkConfigurationFailed: return "DEPLOY_NETWORK_CONFIGURATION_FAILED"
            case .deployNetworkConfigurationStart: return "DEPLOY_NETWORK_CONFIGURATION_START"
            case .jobCancel: return "JOB_CANCEL"
            case .jobEnd: return "JOB_END"
            case .jobStart: return "JOB_START"
            case .launchFailed: return "LAUNCH_FAILED"
            case .launchStart: return "LAUNCH_START"
            case .networkRecoveryFail: return "NETWORK_RECOVERY_FAIL"
            case .serverSkipped: return "SERVER_SKIPPED"
            case .snapshotEnd: return "SNAPSHOT_END"
            case .snapshotFail: return "SNAPSHOT_FAIL"
            case .snapshotStart: return "SNAPSHOT_START"
            case .updateLaunchTemplateEnd: return "UPDATE_LAUNCH_TEMPLATE_END"
            case .updateLaunchTemplateFailed: return "UPDATE_LAUNCH_TEMPLATE_FAILED"
            case .updateLaunchTemplateStart: return "UPDATE_LAUNCH_TEMPLATE_START"
            case .updateNetworkConfigurationEnd: return "UPDATE_NETWORK_CONFIGURATION_END"
            case .updateNetworkConfigurationFailed: return "UPDATE_NETWORK_CONFIGURATION_FAILED"
            case .updateNetworkConfigurationStart: return "UPDATE_NETWORK_CONFIGURATION_START"
            case .usingPreviousSnapshot: return "USING_PREVIOUS_SNAPSHOT"
            case .usingPreviousSnapshotFailed: return "USING_PREVIOUS_SNAPSHOT_FAILED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = JobLogEvent(rawValue: rawValue) ?? JobLogEvent.sdkUnknown(rawValue)
        }
    }
}

extension DrsClientTypes.JobLogEventData: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case conversionProperties
        case conversionServerID
        case eventResourceData
        case rawError
        case sourceServerID
        case targetInstanceID
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let conversionProperties = self.conversionProperties {
            try encodeContainer.encode(conversionProperties, forKey: .conversionProperties)
        }
        if let conversionServerID = self.conversionServerID {
            try encodeContainer.encode(conversionServerID, forKey: .conversionServerID)
        }
        if let eventResourceData = self.eventResourceData {
            try encodeContainer.encode(eventResourceData, forKey: .eventResourceData)
        }
        if let rawError = self.rawError {
            try encodeContainer.encode(rawError, forKey: .rawError)
        }
        if let sourceServerID = self.sourceServerID {
            try encodeContainer.encode(sourceServerID, forKey: .sourceServerID)
        }
        if let targetInstanceID = self.targetInstanceID {
            try encodeContainer.encode(targetInstanceID, forKey: .targetInstanceID)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceServerIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceServerID)
        sourceServerID = sourceServerIDDecoded
        let conversionServerIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .conversionServerID)
        conversionServerID = conversionServerIDDecoded
        let targetInstanceIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetInstanceID)
        targetInstanceID = targetInstanceIDDecoded
        let rawErrorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .rawError)
        rawError = rawErrorDecoded
        let conversionPropertiesDecoded = try containerValues.decodeIfPresent(DrsClientTypes.ConversionProperties.self, forKey: .conversionProperties)
        conversionProperties = conversionPropertiesDecoded
        let eventResourceDataDecoded = try containerValues.decodeIfPresent(DrsClientTypes.EventResourceData.self, forKey: .eventResourceData)
        eventResourceData = eventResourceDataDecoded
    }
}

extension DrsClientTypes {
    /// Metadata associated with a Job log.
    public struct JobLogEventData: Swift.Equatable {
        /// Properties of a conversion job
        public var conversionProperties: DrsClientTypes.ConversionProperties?
        /// The ID of a conversion server.
        public var conversionServerID: Swift.String?
        /// Properties of resource related to a job event.
        public var eventResourceData: DrsClientTypes.EventResourceData?
        /// A string representing a job error.
        public var rawError: Swift.String?
        /// The ID of a Source Server.
        public var sourceServerID: Swift.String?
        /// The ID of a Recovery Instance.
        public var targetInstanceID: Swift.String?

        public init(
            conversionProperties: DrsClientTypes.ConversionProperties? = nil,
            conversionServerID: Swift.String? = nil,
            eventResourceData: DrsClientTypes.EventResourceData? = nil,
            rawError: Swift.String? = nil,
            sourceServerID: Swift.String? = nil,
            targetInstanceID: Swift.String? = nil
        )
        {
            self.conversionProperties = conversionProperties
            self.conversionServerID = conversionServerID
            self.eventResourceData = eventResourceData
            self.rawError = rawError
            self.sourceServerID = sourceServerID
            self.targetInstanceID = targetInstanceID
        }
    }

}

extension DrsClientTypes {
    public enum JobStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case completed
        case pending
        case started
        case sdkUnknown(Swift.String)

        public static var allCases: [JobStatus] {
            return [
                .completed,
                .pending,
                .started,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .completed: return "COMPLETED"
            case .pending: return "PENDING"
            case .started: return "STARTED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = JobStatus(rawValue: rawValue) ?? JobStatus.sdkUnknown(rawValue)
        }
    }
}

extension DrsClientTypes {
    public enum JobType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case createConvertedSnapshot
        case launch
        case terminate
        case sdkUnknown(Swift.String)

        public static var allCases: [JobType] {
            return [
                .createConvertedSnapshot,
                .launch,
                .terminate,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .createConvertedSnapshot: return "CREATE_CONVERTED_SNAPSHOT"
            case .launch: return "LAUNCH"
            case .terminate: return "TERMINATE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = JobType(rawValue: rawValue) ?? JobType.sdkUnknown(rawValue)
        }
    }
}

extension DrsClientTypes {
    public enum LastLaunchResult: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failed
        case notStarted
        case pending
        case succeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [LastLaunchResult] {
            return [
                .failed,
                .notStarted,
                .pending,
                .succeeded,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .notStarted: return "NOT_STARTED"
            case .pending: return "PENDING"
            case .succeeded: return "SUCCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LastLaunchResult(rawValue: rawValue) ?? LastLaunchResult.sdkUnknown(rawValue)
        }
    }
}

extension DrsClientTypes {
    public enum LastLaunchType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case drill
        case recovery
        case sdkUnknown(Swift.String)

        public static var allCases: [LastLaunchType] {
            return [
                .drill,
                .recovery,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .drill: return "DRILL"
            case .recovery: return "RECOVERY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LastLaunchType(rawValue: rawValue) ?? LastLaunchType.sdkUnknown(rawValue)
        }
    }
}

extension DrsClientTypes.LaunchAction: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actionCode
        case actionId
        case actionVersion
        case active
        case category
        case description
        case name
        case `optional` = "optional"
        case order
        case parameters
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actionCode = self.actionCode {
            try encodeContainer.encode(actionCode, forKey: .actionCode)
        }
        if let actionId = self.actionId {
            try encodeContainer.encode(actionId, forKey: .actionId)
        }
        if let actionVersion = self.actionVersion {
            try encodeContainer.encode(actionVersion, forKey: .actionVersion)
        }
        if let active = self.active {
            try encodeContainer.encode(active, forKey: .active)
        }
        if let category = self.category {
            try encodeContainer.encode(category.rawValue, forKey: .category)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let `optional` = self.`optional` {
            try encodeContainer.encode(`optional`, forKey: .`optional`)
        }
        if order != 0 {
            try encodeContainer.encode(order, forKey: .order)
        }
        if let parameters = parameters {
            var parametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .parameters)
            for (dictKey0, launchActionParameters0) in parameters {
                try parametersContainer.encode(launchActionParameters0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .actionId)
        actionId = actionIdDecoded
        let actionCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .actionCode)
        actionCode = actionCodeDecoded
        let typeDecoded = try containerValues.decodeIfPresent(DrsClientTypes.LaunchActionType.self, forKey: .type)
        type = typeDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let activeDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .active)
        active = activeDecoded
        let orderDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .order) ?? 0
        order = orderDecoded
        let actionVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .actionVersion)
        actionVersion = actionVersionDecoded
        let optionalDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .optional)
        `optional` = optionalDecoded
        let parametersContainer = try containerValues.decodeIfPresent([Swift.String: DrsClientTypes.LaunchActionParameter?].self, forKey: .parameters)
        var parametersDecoded0: [Swift.String:DrsClientTypes.LaunchActionParameter]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [Swift.String:DrsClientTypes.LaunchActionParameter]()
            for (key0, launchactionparameter0) in parametersContainer {
                if let launchactionparameter0 = launchactionparameter0 {
                    parametersDecoded0?[key0] = launchactionparameter0
                }
            }
        }
        parameters = parametersDecoded0
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let categoryDecoded = try containerValues.decodeIfPresent(DrsClientTypes.LaunchActionCategory.self, forKey: .category)
        category = categoryDecoded
    }
}

extension DrsClientTypes {
    /// Launch action.
    public struct LaunchAction: Swift.Equatable {
        /// Launch action code.
        public var actionCode: Swift.String?
        /// Launch action Id.
        public var actionId: Swift.String?
        /// Launch action version.
        public var actionVersion: Swift.String?
        /// Whether the launch action is active.
        public var active: Swift.Bool?
        /// Launch action category.
        public var category: DrsClientTypes.LaunchActionCategory?
        /// Launch action description.
        public var description: Swift.String?
        /// Launch action name.
        public var name: Swift.String?
        /// Whether the launch will not be marked as failed if this action fails.
        public var `optional`: Swift.Bool?
        /// Launch action order.
        public var order: Swift.Int
        /// Launch action parameters.
        public var parameters: [Swift.String:DrsClientTypes.LaunchActionParameter]?
        /// Launch action type.
        public var type: DrsClientTypes.LaunchActionType?

        public init(
            actionCode: Swift.String? = nil,
            actionId: Swift.String? = nil,
            actionVersion: Swift.String? = nil,
            active: Swift.Bool? = nil,
            category: DrsClientTypes.LaunchActionCategory? = nil,
            description: Swift.String? = nil,
            name: Swift.String? = nil,
            `optional`: Swift.Bool? = nil,
            order: Swift.Int = 0,
            parameters: [Swift.String:DrsClientTypes.LaunchActionParameter]? = nil,
            type: DrsClientTypes.LaunchActionType? = nil
        )
        {
            self.actionCode = actionCode
            self.actionId = actionId
            self.actionVersion = actionVersion
            self.active = active
            self.category = category
            self.description = description
            self.name = name
            self.`optional` = `optional`
            self.order = order
            self.parameters = parameters
            self.type = type
        }
    }

}

extension DrsClientTypes {
    /// Launch action category.
    public enum LaunchActionCategory: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case configuration
        case monitoring
        case other
        case security
        case validation
        case sdkUnknown(Swift.String)

        public static var allCases: [LaunchActionCategory] {
            return [
                .configuration,
                .monitoring,
                .other,
                .security,
                .validation,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .configuration: return "CONFIGURATION"
            case .monitoring: return "MONITORING"
            case .other: return "OTHER"
            case .security: return "SECURITY"
            case .validation: return "VALIDATION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LaunchActionCategory(rawValue: rawValue) ?? LaunchActionCategory.sdkUnknown(rawValue)
        }
    }
}

extension DrsClientTypes.LaunchActionParameter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case type
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
        let typeDecoded = try containerValues.decodeIfPresent(DrsClientTypes.LaunchActionParameterType.self, forKey: .type)
        type = typeDecoded
    }
}

extension DrsClientTypes {
    /// Launch action parameter.
    public struct LaunchActionParameter: Swift.Equatable {
        /// Type.
        public var type: DrsClientTypes.LaunchActionParameterType?
        /// Value.
        public var value: Swift.String?

        public init(
            type: DrsClientTypes.LaunchActionParameterType? = nil,
            value: Swift.String? = nil
        )
        {
            self.type = type
            self.value = value
        }
    }

}

extension DrsClientTypes {
    public enum LaunchActionParameterType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case `dynamic`
        case ssmStore
        case sdkUnknown(Swift.String)

        public static var allCases: [LaunchActionParameterType] {
            return [
                .dynamic,
                .ssmStore,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .dynamic: return "DYNAMIC"
            case .ssmStore: return "SSM_STORE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LaunchActionParameterType(rawValue: rawValue) ?? LaunchActionParameterType.sdkUnknown(rawValue)
        }
    }
}

extension DrsClientTypes.LaunchActionRun: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action
        case failureReason
        case runId
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = self.action {
            try encodeContainer.encode(action, forKey: .action)
        }
        if let failureReason = self.failureReason {
            try encodeContainer.encode(failureReason, forKey: .failureReason)
        }
        if let runId = self.runId {
            try encodeContainer.encode(runId, forKey: .runId)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionDecoded = try containerValues.decodeIfPresent(DrsClientTypes.LaunchAction.self, forKey: .action)
        action = actionDecoded
        let runIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .runId)
        runId = runIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(DrsClientTypes.LaunchActionRunStatus.self, forKey: .status)
        status = statusDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
    }
}

extension DrsClientTypes {
    /// Launch action run.
    public struct LaunchActionRun: Swift.Equatable {
        /// Action.
        public var action: DrsClientTypes.LaunchAction?
        /// Failure reason.
        public var failureReason: Swift.String?
        /// Run Id.
        public var runId: Swift.String?
        /// Run status.
        public var status: DrsClientTypes.LaunchActionRunStatus?

        public init(
            action: DrsClientTypes.LaunchAction? = nil,
            failureReason: Swift.String? = nil,
            runId: Swift.String? = nil,
            status: DrsClientTypes.LaunchActionRunStatus? = nil
        )
        {
            self.action = action
            self.failureReason = failureReason
            self.runId = runId
            self.status = status
        }
    }

}

extension DrsClientTypes {
    public enum LaunchActionRunStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failed
        case inProgress
        case succeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [LaunchActionRunStatus] {
            return [
                .failed,
                .inProgress,
                .succeeded,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .succeeded: return "SUCCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LaunchActionRunStatus(rawValue: rawValue) ?? LaunchActionRunStatus.sdkUnknown(rawValue)
        }
    }
}

extension DrsClientTypes {
    public enum LaunchActionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ssmAutomation
        case ssmCommand
        case sdkUnknown(Swift.String)

        public static var allCases: [LaunchActionType] {
            return [
                .ssmAutomation,
                .ssmCommand,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ssmAutomation: return "SSM_AUTOMATION"
            case .ssmCommand: return "SSM_COMMAND"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LaunchActionType(rawValue: rawValue) ?? LaunchActionType.sdkUnknown(rawValue)
        }
    }
}

extension DrsClientTypes.LaunchActionsRequestFilters: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actionIds
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actionIds = actionIds {
            var actionIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .actionIds)
            for launchactionid0 in actionIds {
                try actionIdsContainer.encode(launchactionid0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .actionIds)
        var actionIdsDecoded0:[Swift.String]? = nil
        if let actionIdsContainer = actionIdsContainer {
            actionIdsDecoded0 = [Swift.String]()
            for string0 in actionIdsContainer {
                if let string0 = string0 {
                    actionIdsDecoded0?.append(string0)
                }
            }
        }
        actionIds = actionIdsDecoded0
    }
}

extension DrsClientTypes {
    /// Resource launch actions filter.
    public struct LaunchActionsRequestFilters: Swift.Equatable {
        /// Launch actions Ids.
        public var actionIds: [Swift.String]?

        public init(
            actionIds: [Swift.String]? = nil
        )
        {
            self.actionIds = actionIds
        }
    }

}

extension DrsClientTypes.LaunchActionsStatus: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case runs
        case ssmAgentDiscoveryDatetime
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let runs = runs {
            var runsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .runs)
            for launchactionrun0 in runs {
                try runsContainer.encode(launchactionrun0)
            }
        }
        if let ssmAgentDiscoveryDatetime = self.ssmAgentDiscoveryDatetime {
            try encodeContainer.encode(ssmAgentDiscoveryDatetime, forKey: .ssmAgentDiscoveryDatetime)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ssmAgentDiscoveryDatetimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ssmAgentDiscoveryDatetime)
        ssmAgentDiscoveryDatetime = ssmAgentDiscoveryDatetimeDecoded
        let runsContainer = try containerValues.decodeIfPresent([DrsClientTypes.LaunchActionRun?].self, forKey: .runs)
        var runsDecoded0:[DrsClientTypes.LaunchActionRun]? = nil
        if let runsContainer = runsContainer {
            runsDecoded0 = [DrsClientTypes.LaunchActionRun]()
            for structure0 in runsContainer {
                if let structure0 = structure0 {
                    runsDecoded0?.append(structure0)
                }
            }
        }
        runs = runsDecoded0
    }
}

extension DrsClientTypes {
    /// Launch actions status.
    public struct LaunchActionsStatus: Swift.Equatable {
        /// List of post launch action status.
        public var runs: [DrsClientTypes.LaunchActionRun]?
        /// Time where the AWS Systems Manager was detected as running on the launched instance.
        public var ssmAgentDiscoveryDatetime: Swift.String?

        public init(
            runs: [DrsClientTypes.LaunchActionRun]? = nil,
            ssmAgentDiscoveryDatetime: Swift.String? = nil
        )
        {
            self.runs = runs
            self.ssmAgentDiscoveryDatetime = ssmAgentDiscoveryDatetime
        }
    }

}

extension DrsClientTypes.LaunchConfigurationTemplate: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case copyPrivateIp
        case copyTags
        case exportBucketArn
        case launchConfigurationTemplateID
        case launchDisposition
        case licensing
        case postLaunchEnabled
        case tags
        case targetInstanceTypeRightSizingMethod
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let copyPrivateIp = self.copyPrivateIp {
            try encodeContainer.encode(copyPrivateIp, forKey: .copyPrivateIp)
        }
        if let copyTags = self.copyTags {
            try encodeContainer.encode(copyTags, forKey: .copyTags)
        }
        if let exportBucketArn = self.exportBucketArn {
            try encodeContainer.encode(exportBucketArn, forKey: .exportBucketArn)
        }
        if let launchConfigurationTemplateID = self.launchConfigurationTemplateID {
            try encodeContainer.encode(launchConfigurationTemplateID, forKey: .launchConfigurationTemplateID)
        }
        if let launchDisposition = self.launchDisposition {
            try encodeContainer.encode(launchDisposition.rawValue, forKey: .launchDisposition)
        }
        if let licensing = self.licensing {
            try encodeContainer.encode(licensing, forKey: .licensing)
        }
        if let postLaunchEnabled = self.postLaunchEnabled {
            try encodeContainer.encode(postLaunchEnabled, forKey: .postLaunchEnabled)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagsMap0) in tags {
                try tagsContainer.encode(tagsMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let targetInstanceTypeRightSizingMethod = self.targetInstanceTypeRightSizingMethod {
            try encodeContainer.encode(targetInstanceTypeRightSizingMethod.rawValue, forKey: .targetInstanceTypeRightSizingMethod)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let launchConfigurationTemplateIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .launchConfigurationTemplateID)
        launchConfigurationTemplateID = launchConfigurationTemplateIDDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let launchDispositionDecoded = try containerValues.decodeIfPresent(DrsClientTypes.LaunchDisposition.self, forKey: .launchDisposition)
        launchDisposition = launchDispositionDecoded
        let targetInstanceTypeRightSizingMethodDecoded = try containerValues.decodeIfPresent(DrsClientTypes.TargetInstanceTypeRightSizingMethod.self, forKey: .targetInstanceTypeRightSizingMethod)
        targetInstanceTypeRightSizingMethod = targetInstanceTypeRightSizingMethodDecoded
        let copyPrivateIpDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .copyPrivateIp)
        copyPrivateIp = copyPrivateIpDecoded
        let copyTagsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .copyTags)
        copyTags = copyTagsDecoded
        let licensingDecoded = try containerValues.decodeIfPresent(DrsClientTypes.Licensing.self, forKey: .licensing)
        licensing = licensingDecoded
        let exportBucketArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .exportBucketArn)
        exportBucketArn = exportBucketArnDecoded
        let postLaunchEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .postLaunchEnabled)
        postLaunchEnabled = postLaunchEnabledDecoded
    }
}

extension DrsClientTypes.LaunchConfigurationTemplate: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "LaunchConfigurationTemplate(arn: \(Swift.String(describing: arn)), copyPrivateIp: \(Swift.String(describing: copyPrivateIp)), copyTags: \(Swift.String(describing: copyTags)), exportBucketArn: \(Swift.String(describing: exportBucketArn)), launchConfigurationTemplateID: \(Swift.String(describing: launchConfigurationTemplateID)), launchDisposition: \(Swift.String(describing: launchDisposition)), licensing: \(Swift.String(describing: licensing)), postLaunchEnabled: \(Swift.String(describing: postLaunchEnabled)), targetInstanceTypeRightSizingMethod: \(Swift.String(describing: targetInstanceTypeRightSizingMethod)), tags: \"CONTENT_REDACTED\")"}
}

extension DrsClientTypes {
    /// Account level Launch Configuration Template.
    public struct LaunchConfigurationTemplate: Swift.Equatable {
        /// ARN of the Launch Configuration Template.
        public var arn: Swift.String?
        /// Copy private IP.
        public var copyPrivateIp: Swift.Bool?
        /// Copy tags.
        public var copyTags: Swift.Bool?
        /// S3 bucket ARN to export Source Network templates.
        public var exportBucketArn: Swift.String?
        /// ID of the Launch Configuration Template.
        public var launchConfigurationTemplateID: Swift.String?
        /// Launch disposition.
        public var launchDisposition: DrsClientTypes.LaunchDisposition?
        /// Licensing.
        public var licensing: DrsClientTypes.Licensing?
        /// Post-launch actions activated.
        public var postLaunchEnabled: Swift.Bool?
        /// Tags of the Launch Configuration Template.
        public var tags: [Swift.String:Swift.String]?
        /// Target instance type right-sizing method.
        public var targetInstanceTypeRightSizingMethod: DrsClientTypes.TargetInstanceTypeRightSizingMethod?

        public init(
            arn: Swift.String? = nil,
            copyPrivateIp: Swift.Bool? = nil,
            copyTags: Swift.Bool? = nil,
            exportBucketArn: Swift.String? = nil,
            launchConfigurationTemplateID: Swift.String? = nil,
            launchDisposition: DrsClientTypes.LaunchDisposition? = nil,
            licensing: DrsClientTypes.Licensing? = nil,
            postLaunchEnabled: Swift.Bool? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            targetInstanceTypeRightSizingMethod: DrsClientTypes.TargetInstanceTypeRightSizingMethod? = nil
        )
        {
            self.arn = arn
            self.copyPrivateIp = copyPrivateIp
            self.copyTags = copyTags
            self.exportBucketArn = exportBucketArn
            self.launchConfigurationTemplateID = launchConfigurationTemplateID
            self.launchDisposition = launchDisposition
            self.licensing = licensing
            self.postLaunchEnabled = postLaunchEnabled
            self.tags = tags
            self.targetInstanceTypeRightSizingMethod = targetInstanceTypeRightSizingMethod
        }
    }

}

extension DrsClientTypes {
    public enum LaunchDisposition: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case started
        case stopped
        case sdkUnknown(Swift.String)

        public static var allCases: [LaunchDisposition] {
            return [
                .started,
                .stopped,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .started: return "STARTED"
            case .stopped: return "STOPPED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LaunchDisposition(rawValue: rawValue) ?? LaunchDisposition.sdkUnknown(rawValue)
        }
    }
}

extension DrsClientTypes {
    public enum LaunchStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failed
        case inProgress
        case launched
        case pending
        case terminated
        case sdkUnknown(Swift.String)

        public static var allCases: [LaunchStatus] {
            return [
                .failed,
                .inProgress,
                .launched,
                .pending,
                .terminated,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .launched: return "LAUNCHED"
            case .pending: return "PENDING"
            case .terminated: return "TERMINATED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LaunchStatus(rawValue: rawValue) ?? LaunchStatus.sdkUnknown(rawValue)
        }
    }
}

extension DrsClientTypes.Licensing: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case osByol
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let osByol = self.osByol {
            try encodeContainer.encode(osByol, forKey: .osByol)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let osByolDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .osByol)
        osByol = osByolDecoded
    }
}

extension DrsClientTypes {
    /// Configuration of a machine's license.
    public struct Licensing: Swift.Equatable {
        /// Whether to enable "Bring your own license" or not.
        public var osByol: Swift.Bool?

        public init(
            osByol: Swift.Bool? = nil
        )
        {
            self.osByol = osByol
        }
    }

}

extension DrsClientTypes.LifeCycle: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addedToServiceDateTime
        case elapsedReplicationDuration
        case firstByteDateTime
        case lastLaunch
        case lastSeenByServiceDateTime
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let addedToServiceDateTime = self.addedToServiceDateTime {
            try encodeContainer.encode(addedToServiceDateTime, forKey: .addedToServiceDateTime)
        }
        if let elapsedReplicationDuration = self.elapsedReplicationDuration {
            try encodeContainer.encode(elapsedReplicationDuration, forKey: .elapsedReplicationDuration)
        }
        if let firstByteDateTime = self.firstByteDateTime {
            try encodeContainer.encode(firstByteDateTime, forKey: .firstByteDateTime)
        }
        if let lastLaunch = self.lastLaunch {
            try encodeContainer.encode(lastLaunch, forKey: .lastLaunch)
        }
        if let lastSeenByServiceDateTime = self.lastSeenByServiceDateTime {
            try encodeContainer.encode(lastSeenByServiceDateTime, forKey: .lastSeenByServiceDateTime)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let addedToServiceDateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .addedToServiceDateTime)
        addedToServiceDateTime = addedToServiceDateTimeDecoded
        let firstByteDateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .firstByteDateTime)
        firstByteDateTime = firstByteDateTimeDecoded
        let elapsedReplicationDurationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .elapsedReplicationDuration)
        elapsedReplicationDuration = elapsedReplicationDurationDecoded
        let lastSeenByServiceDateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastSeenByServiceDateTime)
        lastSeenByServiceDateTime = lastSeenByServiceDateTimeDecoded
        let lastLaunchDecoded = try containerValues.decodeIfPresent(DrsClientTypes.LifeCycleLastLaunch.self, forKey: .lastLaunch)
        lastLaunch = lastLaunchDecoded
    }
}

extension DrsClientTypes {
    /// An object representing the Source Server Lifecycle.
    public struct LifeCycle: Swift.Equatable {
        /// The date and time of when the Source Server was added to the service.
        public var addedToServiceDateTime: Swift.String?
        /// The amount of time that the Source Server has been replicating for.
        public var elapsedReplicationDuration: Swift.String?
        /// The date and time of the first byte that was replicated from the Source Server.
        public var firstByteDateTime: Swift.String?
        /// An object containing information regarding the last launch of the Source Server.
        public var lastLaunch: DrsClientTypes.LifeCycleLastLaunch?
        /// The date and time this Source Server was last seen by the service.
        public var lastSeenByServiceDateTime: Swift.String?

        public init(
            addedToServiceDateTime: Swift.String? = nil,
            elapsedReplicationDuration: Swift.String? = nil,
            firstByteDateTime: Swift.String? = nil,
            lastLaunch: DrsClientTypes.LifeCycleLastLaunch? = nil,
            lastSeenByServiceDateTime: Swift.String? = nil
        )
        {
            self.addedToServiceDateTime = addedToServiceDateTime
            self.elapsedReplicationDuration = elapsedReplicationDuration
            self.firstByteDateTime = firstByteDateTime
            self.lastLaunch = lastLaunch
            self.lastSeenByServiceDateTime = lastSeenByServiceDateTime
        }
    }

}

extension DrsClientTypes.LifeCycleLastLaunch: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case initiated
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let initiated = self.initiated {
            try encodeContainer.encode(initiated, forKey: .initiated)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let initiatedDecoded = try containerValues.decodeIfPresent(DrsClientTypes.LifeCycleLastLaunchInitiated.self, forKey: .initiated)
        initiated = initiatedDecoded
        let statusDecoded = try containerValues.decodeIfPresent(DrsClientTypes.LaunchStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension DrsClientTypes {
    /// An object containing information regarding the last launch of a Source Server.
    public struct LifeCycleLastLaunch: Swift.Equatable {
        /// An object containing information regarding the initiation of the last launch of a Source Server.
        public var initiated: DrsClientTypes.LifeCycleLastLaunchInitiated?
        /// Status of Source Server's last launch.
        public var status: DrsClientTypes.LaunchStatus?

        public init(
            initiated: DrsClientTypes.LifeCycleLastLaunchInitiated? = nil,
            status: DrsClientTypes.LaunchStatus? = nil
        )
        {
            self.initiated = initiated
            self.status = status
        }
    }

}

extension DrsClientTypes.LifeCycleLastLaunchInitiated: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiCallDateTime
        case jobID
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let apiCallDateTime = self.apiCallDateTime {
            try encodeContainer.encode(apiCallDateTime, forKey: .apiCallDateTime)
        }
        if let jobID = self.jobID {
            try encodeContainer.encode(jobID, forKey: .jobID)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiCallDateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiCallDateTime)
        apiCallDateTime = apiCallDateTimeDecoded
        let jobIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobID)
        jobID = jobIDDecoded
        let typeDecoded = try containerValues.decodeIfPresent(DrsClientTypes.LastLaunchType.self, forKey: .type)
        type = typeDecoded
    }
}

extension DrsClientTypes {
    /// An object containing information regarding the initiation of the last launch of a Source Server.
    public struct LifeCycleLastLaunchInitiated: Swift.Equatable {
        /// The date and time the last Source Server launch was initiated.
        public var apiCallDateTime: Swift.String?
        /// The ID of the Job that was used to last launch the Source Server.
        public var jobID: Swift.String?
        /// The Job type that was used to last launch the Source Server.
        public var type: DrsClientTypes.LastLaunchType?

        public init(
            apiCallDateTime: Swift.String? = nil,
            jobID: Swift.String? = nil,
            type: DrsClientTypes.LastLaunchType? = nil
        )
        {
            self.apiCallDateTime = apiCallDateTime
            self.jobID = jobID
            self.type = type
        }
    }

}

extension ListExtensibleSourceServersInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case stagingAccountID
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if maxResults != 0 {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let stagingAccountID = self.stagingAccountID {
            try encodeContainer.encode(stagingAccountID, forKey: .stagingAccountID)
        }
    }
}

extension ListExtensibleSourceServersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/ListExtensibleSourceServers"
    }
}

public struct ListExtensibleSourceServersInput: Swift.Equatable {
    /// The maximum number of extensible source servers to retrieve.
    public var maxResults: Swift.Int
    /// The token of the next extensible source server to retrieve.
    public var nextToken: Swift.String?
    /// The Id of the staging Account to retrieve extensible source servers from.
    /// This member is required.
    public var stagingAccountID: Swift.String?

    public init(
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil,
        stagingAccountID: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.stagingAccountID = stagingAccountID
    }
}

struct ListExtensibleSourceServersInputBody: Swift.Equatable {
    let stagingAccountID: Swift.String?
    let maxResults: Swift.Int
    let nextToken: Swift.String?
}

extension ListExtensibleSourceServersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case stagingAccountID
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let stagingAccountIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stagingAccountID)
        stagingAccountID = stagingAccountIDDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults) ?? 0
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListExtensibleSourceServersOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListExtensibleSourceServersOutputBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct ListExtensibleSourceServersOutput: Swift.Equatable {
    /// A list of source servers on a staging Account that are extensible.
    public var items: [DrsClientTypes.StagingSourceServer]?
    /// The token of the next extensible source server to retrieve.
    public var nextToken: Swift.String?

    public init(
        items: [DrsClientTypes.StagingSourceServer]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct ListExtensibleSourceServersOutputBody: Swift.Equatable {
    let items: [DrsClientTypes.StagingSourceServer]?
    let nextToken: Swift.String?
}

extension ListExtensibleSourceServersOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([DrsClientTypes.StagingSourceServer?].self, forKey: .items)
        var itemsDecoded0:[DrsClientTypes.StagingSourceServer]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [DrsClientTypes.StagingSourceServer]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListExtensibleSourceServersOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UninitializedAccountException": return try await UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListLaunchActionsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
        case resourceId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filters = self.filters {
            try encodeContainer.encode(filters, forKey: .filters)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let resourceId = self.resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
    }
}

extension ListLaunchActionsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/ListLaunchActions"
    }
}

public struct ListLaunchActionsInput: Swift.Equatable {
    /// Filters to apply when listing resource launch actions.
    public var filters: DrsClientTypes.LaunchActionsRequestFilters?
    /// Maximum amount of items to return when listing resource launch actions.
    public var maxResults: Swift.Int?
    /// Next token to use when listing resource launch actions.
    public var nextToken: Swift.String?
    /// Launch configuration template Id or Source Server Id
    /// This member is required.
    public var resourceId: Swift.String?

    public init(
        filters: DrsClientTypes.LaunchActionsRequestFilters? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        resourceId: Swift.String? = nil
    )
    {
        self.filters = filters
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.resourceId = resourceId
    }
}

struct ListLaunchActionsInputBody: Swift.Equatable {
    let resourceId: Swift.String?
    let filters: DrsClientTypes.LaunchActionsRequestFilters?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListLaunchActionsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filters
        case maxResults
        case nextToken
        case resourceId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let filtersDecoded = try containerValues.decodeIfPresent(DrsClientTypes.LaunchActionsRequestFilters.self, forKey: .filters)
        filters = filtersDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListLaunchActionsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListLaunchActionsOutputBody = try responseDecoder.decode(responseBody: data)
            self.items = output.items
            self.nextToken = output.nextToken
        } else {
            self.items = nil
            self.nextToken = nil
        }
    }
}

public struct ListLaunchActionsOutput: Swift.Equatable {
    /// List of resource launch actions.
    public var items: [DrsClientTypes.LaunchAction]?
    /// Next token returned when listing resource launch actions.
    public var nextToken: Swift.String?

    public init(
        items: [DrsClientTypes.LaunchAction]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.items = items
        self.nextToken = nextToken
    }
}

struct ListLaunchActionsOutputBody: Swift.Equatable {
    let items: [DrsClientTypes.LaunchAction]?
    let nextToken: Swift.String?
}

extension ListLaunchActionsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case items
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemsContainer = try containerValues.decodeIfPresent([DrsClientTypes.LaunchAction?].self, forKey: .items)
        var itemsDecoded0:[DrsClientTypes.LaunchAction]? = nil
        if let itemsContainer = itemsContainer {
            itemsDecoded0 = [DrsClientTypes.LaunchAction]()
            for structure0 in itemsContainer {
                if let structure0 = structure0 {
                    itemsDecoded0?.append(structure0)
                }
            }
        }
        items = itemsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListLaunchActionsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UninitializedAccountException": return try await UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListStagingAccountsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            return items
        }
    }
}

extension ListStagingAccountsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/ListStagingAccounts"
    }
}

public struct ListStagingAccountsInput: Swift.Equatable {
    /// The maximum number of staging Accounts to retrieve.
    public var maxResults: Swift.Int?
    /// The token of the next staging Account to retrieve.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListStagingAccountsInputBody: Swift.Equatable {
}

extension ListStagingAccountsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListStagingAccountsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListStagingAccountsOutputBody = try responseDecoder.decode(responseBody: data)
            self.accounts = output.accounts
            self.nextToken = output.nextToken
        } else {
            self.accounts = nil
            self.nextToken = nil
        }
    }
}

public struct ListStagingAccountsOutput: Swift.Equatable {
    /// An array of staging AWS Accounts.
    public var accounts: [DrsClientTypes.Account]?
    /// The token of the next staging Account to retrieve.
    public var nextToken: Swift.String?

    public init(
        accounts: [DrsClientTypes.Account]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.accounts = accounts
        self.nextToken = nextToken
    }
}

struct ListStagingAccountsOutputBody: Swift.Equatable {
    let accounts: [DrsClientTypes.Account]?
    let nextToken: Swift.String?
}

extension ListStagingAccountsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accounts
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountsContainer = try containerValues.decodeIfPresent([DrsClientTypes.Account?].self, forKey: .accounts)
        var accountsDecoded0:[DrsClientTypes.Account]? = nil
        if let accountsContainer = accountsContainer {
            accountsDecoded0 = [DrsClientTypes.Account]()
            for structure0 in accountsContainer {
                if let structure0 = structure0 {
                    accountsDecoded0?.append(structure0)
                }
            }
        }
        accounts = accountsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListStagingAccountsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UninitializedAccountException": return try await UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The ARN of the resource whose tags should be returned.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForResourceOutput(tags: \"CONTENT_REDACTED\")"}
}

extension ListTagsForResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutput: Swift.Equatable {
    /// The tags of the requested resource.
    public var tags: [Swift.String:Swift.String]?

    public init(
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension ListTagsForResourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum ListTagsForResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DrsClientTypes.NetworkInterface: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ips
        case isPrimary
        case macAddress
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ips = ips {
            var ipsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ips)
            for boundedstring0 in ips {
                try ipsContainer.encode(boundedstring0)
            }
        }
        if let isPrimary = self.isPrimary {
            try encodeContainer.encode(isPrimary, forKey: .isPrimary)
        }
        if let macAddress = self.macAddress {
            try encodeContainer.encode(macAddress, forKey: .macAddress)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let macAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .macAddress)
        macAddress = macAddressDecoded
        let ipsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .ips)
        var ipsDecoded0:[Swift.String]? = nil
        if let ipsContainer = ipsContainer {
            ipsDecoded0 = [Swift.String]()
            for string0 in ipsContainer {
                if let string0 = string0 {
                    ipsDecoded0?.append(string0)
                }
            }
        }
        ips = ipsDecoded0
        let isPrimaryDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isPrimary)
        isPrimary = isPrimaryDecoded
    }
}

extension DrsClientTypes {
    /// Network interface.
    public struct NetworkInterface: Swift.Equatable {
        /// Network interface IPs.
        public var ips: [Swift.String]?
        /// Whether this is the primary network interface.
        public var isPrimary: Swift.Bool?
        /// The MAC address of the network interface.
        public var macAddress: Swift.String?

        public init(
            ips: [Swift.String]? = nil,
            isPrimary: Swift.Bool? = nil,
            macAddress: Swift.String? = nil
        )
        {
            self.ips = ips
            self.isPrimary = isPrimary
            self.macAddress = macAddress
        }
    }

}

extension DrsClientTypes.OS: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fullString
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fullString = self.fullString {
            try encodeContainer.encode(fullString, forKey: .fullString)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fullStringDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fullString)
        fullString = fullStringDecoded
    }
}

extension DrsClientTypes {
    /// Operating System.
    public struct OS: Swift.Equatable {
        /// The long name of the Operating System.
        public var fullString: Swift.String?

        public init(
            fullString: Swift.String? = nil
        )
        {
            self.fullString = fullString
        }
    }

}

extension DrsClientTypes {
    public enum OriginEnvironment: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case aws
        case onPremises
        case sdkUnknown(Swift.String)

        public static var allCases: [OriginEnvironment] {
            return [
                .aws,
                .onPremises,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .aws: return "AWS"
            case .onPremises: return "ON_PREMISES"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OriginEnvironment(rawValue: rawValue) ?? OriginEnvironment.sdkUnknown(rawValue)
        }
    }
}

extension DrsClientTypes.PITPolicyRule: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enabled
        case interval
        case retentionDuration
        case ruleID
        case units
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let enabled = self.enabled {
            try encodeContainer.encode(enabled, forKey: .enabled)
        }
        if interval != 0 {
            try encodeContainer.encode(interval, forKey: .interval)
        }
        if retentionDuration != 0 {
            try encodeContainer.encode(retentionDuration, forKey: .retentionDuration)
        }
        if ruleID != 0 {
            try encodeContainer.encode(ruleID, forKey: .ruleID)
        }
        if let units = self.units {
            try encodeContainer.encode(units.rawValue, forKey: .units)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ruleIDDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .ruleID) ?? 0
        ruleID = ruleIDDecoded
        let unitsDecoded = try containerValues.decodeIfPresent(DrsClientTypes.PITPolicyRuleUnits.self, forKey: .units)
        units = unitsDecoded
        let intervalDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .interval) ?? 0
        interval = intervalDecoded
        let retentionDurationDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .retentionDuration) ?? 0
        retentionDuration = retentionDurationDecoded
        let enabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enabled)
        enabled = enabledDecoded
    }
}

extension DrsClientTypes {
    /// A rule in the Point in Time (PIT) policy representing when to take snapshots and how long to retain them for.
    public struct PITPolicyRule: Swift.Equatable {
        /// Whether this rule is enabled or not.
        public var enabled: Swift.Bool?
        /// How often, in the chosen units, a snapshot should be taken.
        /// This member is required.
        public var interval: Swift.Int
        /// The duration to retain a snapshot for, in the chosen units.
        /// This member is required.
        public var retentionDuration: Swift.Int
        /// The ID of the rule.
        public var ruleID: Swift.Int
        /// The units used to measure the interval and retentionDuration.
        /// This member is required.
        public var units: DrsClientTypes.PITPolicyRuleUnits?

        public init(
            enabled: Swift.Bool? = nil,
            interval: Swift.Int = 0,
            retentionDuration: Swift.Int = 0,
            ruleID: Swift.Int = 0,
            units: DrsClientTypes.PITPolicyRuleUnits? = nil
        )
        {
            self.enabled = enabled
            self.interval = interval
            self.retentionDuration = retentionDuration
            self.ruleID = ruleID
            self.units = units
        }
    }

}

extension DrsClientTypes {
    public enum PITPolicyRuleUnits: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case day
        case hour
        case minute
        case sdkUnknown(Swift.String)

        public static var allCases: [PITPolicyRuleUnits] {
            return [
                .day,
                .hour,
                .minute,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .day: return "DAY"
            case .hour: return "HOUR"
            case .minute: return "MINUTE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PITPolicyRuleUnits(rawValue: rawValue) ?? PITPolicyRuleUnits.sdkUnknown(rawValue)
        }
    }
}

extension DrsClientTypes.ParticipatingResource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case launchStatus
        case participatingResourceID
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let launchStatus = self.launchStatus {
            try encodeContainer.encode(launchStatus.rawValue, forKey: .launchStatus)
        }
        if let participatingResourceID = self.participatingResourceID {
            try encodeContainer.encode(participatingResourceID, forKey: .participatingResourceID)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let participatingResourceIDDecoded = try containerValues.decodeIfPresent(DrsClientTypes.ParticipatingResourceID.self, forKey: .participatingResourceID)
        participatingResourceID = participatingResourceIDDecoded
        let launchStatusDecoded = try containerValues.decodeIfPresent(DrsClientTypes.LaunchStatus.self, forKey: .launchStatus)
        launchStatus = launchStatusDecoded
    }
}

extension DrsClientTypes {
    /// Represents a resource participating in an asynchronous Job.
    public struct ParticipatingResource: Swift.Equatable {
        /// The launch status of a participating resource.
        public var launchStatus: DrsClientTypes.LaunchStatus?
        /// The ID of a participating resource.
        public var participatingResourceID: DrsClientTypes.ParticipatingResourceID?

        public init(
            launchStatus: DrsClientTypes.LaunchStatus? = nil,
            participatingResourceID: DrsClientTypes.ParticipatingResourceID? = nil
        )
        {
            self.launchStatus = launchStatus
            self.participatingResourceID = participatingResourceID
        }
    }

}

extension DrsClientTypes.ParticipatingResourceID: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sdkUnknown
        case sourcenetworkid = "sourceNetworkID"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.container(keyedBy: CodingKeys.self)
        switch self {
            case let .sourcenetworkid(sourcenetworkid):
                try container.encode(sourcenetworkid, forKey: .sourcenetworkid)
            case let .sdkUnknown(sdkUnknown):
                try container.encode(sdkUnknown, forKey: .sdkUnknown)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let values = try decoder.container(keyedBy: CodingKeys.self)
        let sourcenetworkidDecoded = try values.decodeIfPresent(Swift.String.self, forKey: .sourcenetworkid)
        if let sourcenetworkid = sourcenetworkidDecoded {
            self = .sourcenetworkid(sourcenetworkid)
            return
        }
        self = .sdkUnknown("")
    }
}

extension DrsClientTypes {
    /// ID of a resource participating in an asynchronous Job.
    public enum ParticipatingResourceID: Swift.Equatable {
        /// Source Network ID.
        case sourcenetworkid(Swift.String)
        case sdkUnknown(Swift.String)
    }

}

extension DrsClientTypes.ParticipatingServer: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case launchActionsStatus
        case launchStatus
        case recoveryInstanceID
        case sourceServerID
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let launchActionsStatus = self.launchActionsStatus {
            try encodeContainer.encode(launchActionsStatus, forKey: .launchActionsStatus)
        }
        if let launchStatus = self.launchStatus {
            try encodeContainer.encode(launchStatus.rawValue, forKey: .launchStatus)
        }
        if let recoveryInstanceID = self.recoveryInstanceID {
            try encodeContainer.encode(recoveryInstanceID, forKey: .recoveryInstanceID)
        }
        if let sourceServerID = self.sourceServerID {
            try encodeContainer.encode(sourceServerID, forKey: .sourceServerID)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceServerIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceServerID)
        sourceServerID = sourceServerIDDecoded
        let recoveryInstanceIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recoveryInstanceID)
        recoveryInstanceID = recoveryInstanceIDDecoded
        let launchStatusDecoded = try containerValues.decodeIfPresent(DrsClientTypes.LaunchStatus.self, forKey: .launchStatus)
        launchStatus = launchStatusDecoded
        let launchActionsStatusDecoded = try containerValues.decodeIfPresent(DrsClientTypes.LaunchActionsStatus.self, forKey: .launchActionsStatus)
        launchActionsStatus = launchActionsStatusDecoded
    }
}

extension DrsClientTypes {
    /// Represents a server participating in an asynchronous Job.
    public struct ParticipatingServer: Swift.Equatable {
        /// The post-launch action runs of a participating server.
        public var launchActionsStatus: DrsClientTypes.LaunchActionsStatus?
        /// The launch status of a participating server.
        public var launchStatus: DrsClientTypes.LaunchStatus?
        /// The Recovery Instance ID of a participating server.
        public var recoveryInstanceID: Swift.String?
        /// The Source Server ID of a participating server.
        public var sourceServerID: Swift.String?

        public init(
            launchActionsStatus: DrsClientTypes.LaunchActionsStatus? = nil,
            launchStatus: DrsClientTypes.LaunchStatus? = nil,
            recoveryInstanceID: Swift.String? = nil,
            sourceServerID: Swift.String? = nil
        )
        {
            self.launchActionsStatus = launchActionsStatus
            self.launchStatus = launchStatus
            self.recoveryInstanceID = recoveryInstanceID
            self.sourceServerID = sourceServerID
        }
    }

}

extension PutLaunchActionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actionCode
        case actionId
        case actionVersion
        case active
        case category
        case description
        case name
        case `optional` = "optional"
        case order
        case parameters
        case resourceId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actionCode = self.actionCode {
            try encodeContainer.encode(actionCode, forKey: .actionCode)
        }
        if let actionId = self.actionId {
            try encodeContainer.encode(actionId, forKey: .actionId)
        }
        if let actionVersion = self.actionVersion {
            try encodeContainer.encode(actionVersion, forKey: .actionVersion)
        }
        if let active = self.active {
            try encodeContainer.encode(active, forKey: .active)
        }
        if let category = self.category {
            try encodeContainer.encode(category.rawValue, forKey: .category)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let `optional` = self.`optional` {
            try encodeContainer.encode(`optional`, forKey: .`optional`)
        }
        if let order = self.order {
            try encodeContainer.encode(order, forKey: .order)
        }
        if let parameters = parameters {
            var parametersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .parameters)
            for (dictKey0, launchActionParameters0) in parameters {
                try parametersContainer.encode(launchActionParameters0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let resourceId = self.resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
    }
}

extension PutLaunchActionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/PutLaunchAction"
    }
}

public struct PutLaunchActionInput: Swift.Equatable {
    /// Launch action code.
    /// This member is required.
    public var actionCode: Swift.String?
    /// Launch action Id.
    /// This member is required.
    public var actionId: Swift.String?
    /// Launch action version.
    /// This member is required.
    public var actionVersion: Swift.String?
    /// Whether the launch action is active.
    /// This member is required.
    public var active: Swift.Bool?
    /// Launch action category.
    /// This member is required.
    public var category: DrsClientTypes.LaunchActionCategory?
    /// Launch action description.
    public var description: Swift.String?
    /// Launch action name.
    /// This member is required.
    public var name: Swift.String?
    /// Whether the launch will not be marked as failed if this action fails.
    /// This member is required.
    public var `optional`: Swift.Bool?
    /// Launch action order.
    /// This member is required.
    public var order: Swift.Int?
    /// Launch action parameters.
    public var parameters: [Swift.String:DrsClientTypes.LaunchActionParameter]?
    /// Launch configuration template Id or Source Server Id
    /// This member is required.
    public var resourceId: Swift.String?

    public init(
        actionCode: Swift.String? = nil,
        actionId: Swift.String? = nil,
        actionVersion: Swift.String? = nil,
        active: Swift.Bool? = nil,
        category: DrsClientTypes.LaunchActionCategory? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        `optional`: Swift.Bool? = nil,
        order: Swift.Int? = nil,
        parameters: [Swift.String:DrsClientTypes.LaunchActionParameter]? = nil,
        resourceId: Swift.String? = nil
    )
    {
        self.actionCode = actionCode
        self.actionId = actionId
        self.actionVersion = actionVersion
        self.active = active
        self.category = category
        self.description = description
        self.name = name
        self.`optional` = `optional`
        self.order = order
        self.parameters = parameters
        self.resourceId = resourceId
    }
}

struct PutLaunchActionInputBody: Swift.Equatable {
    let resourceId: Swift.String?
    let actionCode: Swift.String?
    let order: Swift.Int?
    let actionId: Swift.String?
    let `optional`: Swift.Bool?
    let active: Swift.Bool?
    let name: Swift.String?
    let actionVersion: Swift.String?
    let category: DrsClientTypes.LaunchActionCategory?
    let parameters: [Swift.String:DrsClientTypes.LaunchActionParameter]?
    let description: Swift.String?
}

extension PutLaunchActionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actionCode
        case actionId
        case actionVersion
        case active
        case category
        case description
        case name
        case `optional` = "optional"
        case order
        case parameters
        case resourceId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let actionCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .actionCode)
        actionCode = actionCodeDecoded
        let orderDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .order)
        order = orderDecoded
        let actionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .actionId)
        actionId = actionIdDecoded
        let optionalDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .optional)
        `optional` = optionalDecoded
        let activeDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .active)
        active = activeDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let actionVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .actionVersion)
        actionVersion = actionVersionDecoded
        let categoryDecoded = try containerValues.decodeIfPresent(DrsClientTypes.LaunchActionCategory.self, forKey: .category)
        category = categoryDecoded
        let parametersContainer = try containerValues.decodeIfPresent([Swift.String: DrsClientTypes.LaunchActionParameter?].self, forKey: .parameters)
        var parametersDecoded0: [Swift.String:DrsClientTypes.LaunchActionParameter]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [Swift.String:DrsClientTypes.LaunchActionParameter]()
            for (key0, launchactionparameter0) in parametersContainer {
                if let launchactionparameter0 = launchactionparameter0 {
                    parametersDecoded0?[key0] = launchactionparameter0
                }
            }
        }
        parameters = parametersDecoded0
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension PutLaunchActionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: PutLaunchActionOutputBody = try responseDecoder.decode(responseBody: data)
            self.`optional` = output.`optional`
            self.actionCode = output.actionCode
            self.actionId = output.actionId
            self.actionVersion = output.actionVersion
            self.active = output.active
            self.category = output.category
            self.description = output.description
            self.name = output.name
            self.order = output.order
            self.parameters = output.parameters
            self.resourceId = output.resourceId
            self.type = output.type
        } else {
            self.actionCode = nil
            self.actionId = nil
            self.actionVersion = nil
            self.active = nil
            self.category = nil
            self.description = nil
            self.name = nil
            self.`optional` = nil
            self.order = 0
            self.parameters = nil
            self.resourceId = nil
            self.type = nil
        }
    }
}

public struct PutLaunchActionOutput: Swift.Equatable {
    /// Launch action code.
    public var actionCode: Swift.String?
    /// Launch action Id.
    public var actionId: Swift.String?
    /// Launch action version.
    public var actionVersion: Swift.String?
    /// Whether the launch action is active.
    public var active: Swift.Bool?
    /// Launch action category.
    public var category: DrsClientTypes.LaunchActionCategory?
    /// Launch action description.
    public var description: Swift.String?
    /// Launch action name.
    public var name: Swift.String?
    /// Whether the launch will not be marked as failed if this action fails.
    public var `optional`: Swift.Bool?
    /// Launch action order.
    public var order: Swift.Int
    /// Launch action parameters.
    public var parameters: [Swift.String:DrsClientTypes.LaunchActionParameter]?
    /// Launch configuration template Id or Source Server Id
    public var resourceId: Swift.String?
    /// Launch action type.
    public var type: DrsClientTypes.LaunchActionType?

    public init(
        actionCode: Swift.String? = nil,
        actionId: Swift.String? = nil,
        actionVersion: Swift.String? = nil,
        active: Swift.Bool? = nil,
        category: DrsClientTypes.LaunchActionCategory? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        `optional`: Swift.Bool? = nil,
        order: Swift.Int = 0,
        parameters: [Swift.String:DrsClientTypes.LaunchActionParameter]? = nil,
        resourceId: Swift.String? = nil,
        type: DrsClientTypes.LaunchActionType? = nil
    )
    {
        self.actionCode = actionCode
        self.actionId = actionId
        self.actionVersion = actionVersion
        self.active = active
        self.category = category
        self.description = description
        self.name = name
        self.`optional` = `optional`
        self.order = order
        self.parameters = parameters
        self.resourceId = resourceId
        self.type = type
    }
}

struct PutLaunchActionOutputBody: Swift.Equatable {
    let resourceId: Swift.String?
    let actionId: Swift.String?
    let actionCode: Swift.String?
    let type: DrsClientTypes.LaunchActionType?
    let name: Swift.String?
    let active: Swift.Bool?
    let order: Swift.Int
    let actionVersion: Swift.String?
    let `optional`: Swift.Bool?
    let parameters: [Swift.String:DrsClientTypes.LaunchActionParameter]?
    let description: Swift.String?
    let category: DrsClientTypes.LaunchActionCategory?
}

extension PutLaunchActionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actionCode
        case actionId
        case actionVersion
        case active
        case category
        case description
        case name
        case `optional` = "optional"
        case order
        case parameters
        case resourceId
        case type
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let actionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .actionId)
        actionId = actionIdDecoded
        let actionCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .actionCode)
        actionCode = actionCodeDecoded
        let typeDecoded = try containerValues.decodeIfPresent(DrsClientTypes.LaunchActionType.self, forKey: .type)
        type = typeDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let activeDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .active)
        active = activeDecoded
        let orderDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .order) ?? 0
        order = orderDecoded
        let actionVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .actionVersion)
        actionVersion = actionVersionDecoded
        let optionalDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .optional)
        `optional` = optionalDecoded
        let parametersContainer = try containerValues.decodeIfPresent([Swift.String: DrsClientTypes.LaunchActionParameter?].self, forKey: .parameters)
        var parametersDecoded0: [Swift.String:DrsClientTypes.LaunchActionParameter]? = nil
        if let parametersContainer = parametersContainer {
            parametersDecoded0 = [Swift.String:DrsClientTypes.LaunchActionParameter]()
            for (key0, launchactionparameter0) in parametersContainer {
                if let launchactionparameter0 = launchactionparameter0 {
                    parametersDecoded0?[key0] = launchactionparameter0
                }
            }
        }
        parameters = parametersDecoded0
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let categoryDecoded = try containerValues.decodeIfPresent(DrsClientTypes.LaunchActionCategory.self, forKey: .category)
        category = categoryDecoded
    }
}

enum PutLaunchActionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UninitializedAccountException": return try await UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DrsClientTypes.RecoveryInstance: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case dataReplicationInfo
        case ec2InstanceID
        case ec2InstanceState
        case failback
        case isDrill
        case jobID
        case originAvailabilityZone
        case originEnvironment
        case pointInTimeSnapshotDateTime
        case recoveryInstanceID
        case recoveryInstanceProperties
        case sourceServerID
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let dataReplicationInfo = self.dataReplicationInfo {
            try encodeContainer.encode(dataReplicationInfo, forKey: .dataReplicationInfo)
        }
        if let ec2InstanceID = self.ec2InstanceID {
            try encodeContainer.encode(ec2InstanceID, forKey: .ec2InstanceID)
        }
        if let ec2InstanceState = self.ec2InstanceState {
            try encodeContainer.encode(ec2InstanceState.rawValue, forKey: .ec2InstanceState)
        }
        if let failback = self.failback {
            try encodeContainer.encode(failback, forKey: .failback)
        }
        if let isDrill = self.isDrill {
            try encodeContainer.encode(isDrill, forKey: .isDrill)
        }
        if let jobID = self.jobID {
            try encodeContainer.encode(jobID, forKey: .jobID)
        }
        if let originAvailabilityZone = self.originAvailabilityZone {
            try encodeContainer.encode(originAvailabilityZone, forKey: .originAvailabilityZone)
        }
        if let originEnvironment = self.originEnvironment {
            try encodeContainer.encode(originEnvironment.rawValue, forKey: .originEnvironment)
        }
        if let pointInTimeSnapshotDateTime = self.pointInTimeSnapshotDateTime {
            try encodeContainer.encode(pointInTimeSnapshotDateTime, forKey: .pointInTimeSnapshotDateTime)
        }
        if let recoveryInstanceID = self.recoveryInstanceID {
            try encodeContainer.encode(recoveryInstanceID, forKey: .recoveryInstanceID)
        }
        if let recoveryInstanceProperties = self.recoveryInstanceProperties {
            try encodeContainer.encode(recoveryInstanceProperties, forKey: .recoveryInstanceProperties)
        }
        if let sourceServerID = self.sourceServerID {
            try encodeContainer.encode(sourceServerID, forKey: .sourceServerID)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagsMap0) in tags {
                try tagsContainer.encode(tagsMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ec2InstanceIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ec2InstanceID)
        ec2InstanceID = ec2InstanceIDDecoded
        let ec2InstanceStateDecoded = try containerValues.decodeIfPresent(DrsClientTypes.EC2InstanceState.self, forKey: .ec2InstanceState)
        ec2InstanceState = ec2InstanceStateDecoded
        let jobIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobID)
        jobID = jobIDDecoded
        let recoveryInstanceIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recoveryInstanceID)
        recoveryInstanceID = recoveryInstanceIDDecoded
        let sourceServerIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceServerID)
        sourceServerID = sourceServerIDDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let failbackDecoded = try containerValues.decodeIfPresent(DrsClientTypes.RecoveryInstanceFailback.self, forKey: .failback)
        failback = failbackDecoded
        let dataReplicationInfoDecoded = try containerValues.decodeIfPresent(DrsClientTypes.RecoveryInstanceDataReplicationInfo.self, forKey: .dataReplicationInfo)
        dataReplicationInfo = dataReplicationInfoDecoded
        let recoveryInstancePropertiesDecoded = try containerValues.decodeIfPresent(DrsClientTypes.RecoveryInstanceProperties.self, forKey: .recoveryInstanceProperties)
        recoveryInstanceProperties = recoveryInstancePropertiesDecoded
        let pointInTimeSnapshotDateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pointInTimeSnapshotDateTime)
        pointInTimeSnapshotDateTime = pointInTimeSnapshotDateTimeDecoded
        let isDrillDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isDrill)
        isDrill = isDrillDecoded
        let originEnvironmentDecoded = try containerValues.decodeIfPresent(DrsClientTypes.OriginEnvironment.self, forKey: .originEnvironment)
        originEnvironment = originEnvironmentDecoded
        let originAvailabilityZoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .originAvailabilityZone)
        originAvailabilityZone = originAvailabilityZoneDecoded
    }
}

extension DrsClientTypes.RecoveryInstance: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RecoveryInstance(arn: \(Swift.String(describing: arn)), dataReplicationInfo: \(Swift.String(describing: dataReplicationInfo)), ec2InstanceID: \(Swift.String(describing: ec2InstanceID)), ec2InstanceState: \(Swift.String(describing: ec2InstanceState)), failback: \(Swift.String(describing: failback)), isDrill: \(Swift.String(describing: isDrill)), jobID: \(Swift.String(describing: jobID)), originAvailabilityZone: \(Swift.String(describing: originAvailabilityZone)), originEnvironment: \(Swift.String(describing: originEnvironment)), pointInTimeSnapshotDateTime: \(Swift.String(describing: pointInTimeSnapshotDateTime)), recoveryInstanceID: \(Swift.String(describing: recoveryInstanceID)), recoveryInstanceProperties: \(Swift.String(describing: recoveryInstanceProperties)), sourceServerID: \(Swift.String(describing: sourceServerID)), tags: \"CONTENT_REDACTED\")"}
}

extension DrsClientTypes {
    /// A Recovery Instance is a replica of a Source Server running on EC2.
    public struct RecoveryInstance: Swift.Equatable {
        /// The ARN of the Recovery Instance.
        public var arn: Swift.String?
        /// The Data Replication Info of the Recovery Instance.
        public var dataReplicationInfo: DrsClientTypes.RecoveryInstanceDataReplicationInfo?
        /// The EC2 instance ID of the Recovery Instance.
        public var ec2InstanceID: Swift.String?
        /// The state of the EC2 instance for this Recovery Instance.
        public var ec2InstanceState: DrsClientTypes.EC2InstanceState?
        /// An object representing failback related information of the Recovery Instance.
        public var failback: DrsClientTypes.RecoveryInstanceFailback?
        /// Whether this Recovery Instance was created for a drill or for an actual Recovery event.
        public var isDrill: Swift.Bool?
        /// The ID of the Job that created the Recovery Instance.
        public var jobID: Swift.String?
        /// AWS availability zone associated with the recovery instance.
        public var originAvailabilityZone: Swift.String?
        /// Environment (On Premises / AWS) of the instance that the recovery instance originated from.
        public var originEnvironment: DrsClientTypes.OriginEnvironment?
        /// The date and time of the Point in Time (PIT) snapshot that this Recovery Instance was launched from.
        public var pointInTimeSnapshotDateTime: Swift.String?
        /// The ID of the Recovery Instance.
        public var recoveryInstanceID: Swift.String?
        /// Properties of the Recovery Instance machine.
        public var recoveryInstanceProperties: DrsClientTypes.RecoveryInstanceProperties?
        /// The Source Server ID that this Recovery Instance is associated with.
        public var sourceServerID: Swift.String?
        /// An array of tags that are associated with the Recovery Instance.
        public var tags: [Swift.String:Swift.String]?

        public init(
            arn: Swift.String? = nil,
            dataReplicationInfo: DrsClientTypes.RecoveryInstanceDataReplicationInfo? = nil,
            ec2InstanceID: Swift.String? = nil,
            ec2InstanceState: DrsClientTypes.EC2InstanceState? = nil,
            failback: DrsClientTypes.RecoveryInstanceFailback? = nil,
            isDrill: Swift.Bool? = nil,
            jobID: Swift.String? = nil,
            originAvailabilityZone: Swift.String? = nil,
            originEnvironment: DrsClientTypes.OriginEnvironment? = nil,
            pointInTimeSnapshotDateTime: Swift.String? = nil,
            recoveryInstanceID: Swift.String? = nil,
            recoveryInstanceProperties: DrsClientTypes.RecoveryInstanceProperties? = nil,
            sourceServerID: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.arn = arn
            self.dataReplicationInfo = dataReplicationInfo
            self.ec2InstanceID = ec2InstanceID
            self.ec2InstanceState = ec2InstanceState
            self.failback = failback
            self.isDrill = isDrill
            self.jobID = jobID
            self.originAvailabilityZone = originAvailabilityZone
            self.originEnvironment = originEnvironment
            self.pointInTimeSnapshotDateTime = pointInTimeSnapshotDateTime
            self.recoveryInstanceID = recoveryInstanceID
            self.recoveryInstanceProperties = recoveryInstanceProperties
            self.sourceServerID = sourceServerID
            self.tags = tags
        }
    }

}

extension DrsClientTypes.RecoveryInstanceDataReplicationError: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case error
        case rawError
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let error = self.error {
            try encodeContainer.encode(error.rawValue, forKey: .error)
        }
        if let rawError = self.rawError {
            try encodeContainer.encode(rawError, forKey: .rawError)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorDecoded = try containerValues.decodeIfPresent(DrsClientTypes.FailbackReplicationError.self, forKey: .error)
        error = errorDecoded
        let rawErrorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .rawError)
        rawError = rawErrorDecoded
    }
}

extension DrsClientTypes {
    /// Error in data replication.
    public struct RecoveryInstanceDataReplicationError: Swift.Equatable {
        /// Error in data replication.
        public var error: DrsClientTypes.FailbackReplicationError?
        /// Error in data replication.
        public var rawError: Swift.String?

        public init(
            error: DrsClientTypes.FailbackReplicationError? = nil,
            rawError: Swift.String? = nil
        )
        {
            self.error = error
            self.rawError = rawError
        }
    }

}

extension DrsClientTypes.RecoveryInstanceDataReplicationInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataReplicationError
        case dataReplicationInitiation
        case dataReplicationState
        case etaDateTime
        case lagDuration
        case replicatedDisks
        case stagingAvailabilityZone
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataReplicationError = self.dataReplicationError {
            try encodeContainer.encode(dataReplicationError, forKey: .dataReplicationError)
        }
        if let dataReplicationInitiation = self.dataReplicationInitiation {
            try encodeContainer.encode(dataReplicationInitiation, forKey: .dataReplicationInitiation)
        }
        if let dataReplicationState = self.dataReplicationState {
            try encodeContainer.encode(dataReplicationState.rawValue, forKey: .dataReplicationState)
        }
        if let etaDateTime = self.etaDateTime {
            try encodeContainer.encode(etaDateTime, forKey: .etaDateTime)
        }
        if let lagDuration = self.lagDuration {
            try encodeContainer.encode(lagDuration, forKey: .lagDuration)
        }
        if let replicatedDisks = replicatedDisks {
            var replicatedDisksContainer = encodeContainer.nestedUnkeyedContainer(forKey: .replicatedDisks)
            for recoveryinstancedatareplicationinforeplicateddisk0 in replicatedDisks {
                try replicatedDisksContainer.encode(recoveryinstancedatareplicationinforeplicateddisk0)
            }
        }
        if let stagingAvailabilityZone = self.stagingAvailabilityZone {
            try encodeContainer.encode(stagingAvailabilityZone, forKey: .stagingAvailabilityZone)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lagDurationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lagDuration)
        lagDuration = lagDurationDecoded
        let etaDateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .etaDateTime)
        etaDateTime = etaDateTimeDecoded
        let replicatedDisksContainer = try containerValues.decodeIfPresent([DrsClientTypes.RecoveryInstanceDataReplicationInfoReplicatedDisk?].self, forKey: .replicatedDisks)
        var replicatedDisksDecoded0:[DrsClientTypes.RecoveryInstanceDataReplicationInfoReplicatedDisk]? = nil
        if let replicatedDisksContainer = replicatedDisksContainer {
            replicatedDisksDecoded0 = [DrsClientTypes.RecoveryInstanceDataReplicationInfoReplicatedDisk]()
            for structure0 in replicatedDisksContainer {
                if let structure0 = structure0 {
                    replicatedDisksDecoded0?.append(structure0)
                }
            }
        }
        replicatedDisks = replicatedDisksDecoded0
        let dataReplicationStateDecoded = try containerValues.decodeIfPresent(DrsClientTypes.RecoveryInstanceDataReplicationState.self, forKey: .dataReplicationState)
        dataReplicationState = dataReplicationStateDecoded
        let dataReplicationInitiationDecoded = try containerValues.decodeIfPresent(DrsClientTypes.RecoveryInstanceDataReplicationInitiation.self, forKey: .dataReplicationInitiation)
        dataReplicationInitiation = dataReplicationInitiationDecoded
        let dataReplicationErrorDecoded = try containerValues.decodeIfPresent(DrsClientTypes.RecoveryInstanceDataReplicationError.self, forKey: .dataReplicationError)
        dataReplicationError = dataReplicationErrorDecoded
        let stagingAvailabilityZoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stagingAvailabilityZone)
        stagingAvailabilityZone = stagingAvailabilityZoneDecoded
    }
}

extension DrsClientTypes {
    /// Information about Data Replication
    public struct RecoveryInstanceDataReplicationInfo: Swift.Equatable {
        /// Information about Data Replication
        public var dataReplicationError: DrsClientTypes.RecoveryInstanceDataReplicationError?
        /// Information about whether the data replication has been initiated.
        public var dataReplicationInitiation: DrsClientTypes.RecoveryInstanceDataReplicationInitiation?
        /// The state of the data replication.
        public var dataReplicationState: DrsClientTypes.RecoveryInstanceDataReplicationState?
        /// An estimate of when the data replication will be completed.
        public var etaDateTime: Swift.String?
        /// Data replication lag duration.
        public var lagDuration: Swift.String?
        /// The disks that should be replicated.
        public var replicatedDisks: [DrsClientTypes.RecoveryInstanceDataReplicationInfoReplicatedDisk]?
        /// AWS Availability zone into which data is being replicated.
        public var stagingAvailabilityZone: Swift.String?

        public init(
            dataReplicationError: DrsClientTypes.RecoveryInstanceDataReplicationError? = nil,
            dataReplicationInitiation: DrsClientTypes.RecoveryInstanceDataReplicationInitiation? = nil,
            dataReplicationState: DrsClientTypes.RecoveryInstanceDataReplicationState? = nil,
            etaDateTime: Swift.String? = nil,
            lagDuration: Swift.String? = nil,
            replicatedDisks: [DrsClientTypes.RecoveryInstanceDataReplicationInfoReplicatedDisk]? = nil,
            stagingAvailabilityZone: Swift.String? = nil
        )
        {
            self.dataReplicationError = dataReplicationError
            self.dataReplicationInitiation = dataReplicationInitiation
            self.dataReplicationState = dataReplicationState
            self.etaDateTime = etaDateTime
            self.lagDuration = lagDuration
            self.replicatedDisks = replicatedDisks
            self.stagingAvailabilityZone = stagingAvailabilityZone
        }
    }

}

extension DrsClientTypes.RecoveryInstanceDataReplicationInfoReplicatedDisk: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case backloggedStorageBytes
        case deviceName
        case replicatedStorageBytes
        case rescannedStorageBytes
        case totalStorageBytes
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if backloggedStorageBytes != 0 {
            try encodeContainer.encode(backloggedStorageBytes, forKey: .backloggedStorageBytes)
        }
        if let deviceName = self.deviceName {
            try encodeContainer.encode(deviceName, forKey: .deviceName)
        }
        if replicatedStorageBytes != 0 {
            try encodeContainer.encode(replicatedStorageBytes, forKey: .replicatedStorageBytes)
        }
        if rescannedStorageBytes != 0 {
            try encodeContainer.encode(rescannedStorageBytes, forKey: .rescannedStorageBytes)
        }
        if totalStorageBytes != 0 {
            try encodeContainer.encode(totalStorageBytes, forKey: .totalStorageBytes)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceName)
        deviceName = deviceNameDecoded
        let totalStorageBytesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalStorageBytes) ?? 0
        totalStorageBytes = totalStorageBytesDecoded
        let replicatedStorageBytesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .replicatedStorageBytes) ?? 0
        replicatedStorageBytes = replicatedStorageBytesDecoded
        let rescannedStorageBytesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .rescannedStorageBytes) ?? 0
        rescannedStorageBytes = rescannedStorageBytesDecoded
        let backloggedStorageBytesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .backloggedStorageBytes) ?? 0
        backloggedStorageBytes = backloggedStorageBytesDecoded
    }
}

extension DrsClientTypes {
    /// A disk that should be replicated.
    public struct RecoveryInstanceDataReplicationInfoReplicatedDisk: Swift.Equatable {
        /// The size of the replication backlog in bytes.
        public var backloggedStorageBytes: Swift.Int
        /// The name of the device.
        public var deviceName: Swift.String?
        /// The amount of data replicated so far in bytes.
        public var replicatedStorageBytes: Swift.Int
        /// The amount of data to be rescanned in bytes.
        public var rescannedStorageBytes: Swift.Int
        /// The total amount of data to be replicated in bytes.
        public var totalStorageBytes: Swift.Int

        public init(
            backloggedStorageBytes: Swift.Int = 0,
            deviceName: Swift.String? = nil,
            replicatedStorageBytes: Swift.Int = 0,
            rescannedStorageBytes: Swift.Int = 0,
            totalStorageBytes: Swift.Int = 0
        )
        {
            self.backloggedStorageBytes = backloggedStorageBytes
            self.deviceName = deviceName
            self.replicatedStorageBytes = replicatedStorageBytes
            self.rescannedStorageBytes = rescannedStorageBytes
            self.totalStorageBytes = totalStorageBytes
        }
    }

}

extension DrsClientTypes.RecoveryInstanceDataReplicationInitiation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case startDateTime
        case steps
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let startDateTime = self.startDateTime {
            try encodeContainer.encode(startDateTime, forKey: .startDateTime)
        }
        if let steps = steps {
            var stepsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .steps)
            for recoveryinstancedatareplicationinitiationstep0 in steps {
                try stepsContainer.encode(recoveryinstancedatareplicationinitiationstep0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startDateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .startDateTime)
        startDateTime = startDateTimeDecoded
        let stepsContainer = try containerValues.decodeIfPresent([DrsClientTypes.RecoveryInstanceDataReplicationInitiationStep?].self, forKey: .steps)
        var stepsDecoded0:[DrsClientTypes.RecoveryInstanceDataReplicationInitiationStep]? = nil
        if let stepsContainer = stepsContainer {
            stepsDecoded0 = [DrsClientTypes.RecoveryInstanceDataReplicationInitiationStep]()
            for structure0 in stepsContainer {
                if let structure0 = structure0 {
                    stepsDecoded0?.append(structure0)
                }
            }
        }
        steps = stepsDecoded0
    }
}

extension DrsClientTypes {
    /// Data replication initiation.
    public struct RecoveryInstanceDataReplicationInitiation: Swift.Equatable {
        /// The date and time of the current attempt to initiate data replication.
        public var startDateTime: Swift.String?
        /// The steps of the current attempt to initiate data replication.
        public var steps: [DrsClientTypes.RecoveryInstanceDataReplicationInitiationStep]?

        public init(
            startDateTime: Swift.String? = nil,
            steps: [DrsClientTypes.RecoveryInstanceDataReplicationInitiationStep]? = nil
        )
        {
            self.startDateTime = startDateTime
            self.steps = steps
        }
    }

}

extension DrsClientTypes.RecoveryInstanceDataReplicationInitiationStep: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(DrsClientTypes.RecoveryInstanceDataReplicationInitiationStepName.self, forKey: .name)
        name = nameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(DrsClientTypes.RecoveryInstanceDataReplicationInitiationStepStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension DrsClientTypes {
    /// Data replication initiation step.
    public struct RecoveryInstanceDataReplicationInitiationStep: Swift.Equatable {
        /// The name of the step.
        public var name: DrsClientTypes.RecoveryInstanceDataReplicationInitiationStepName?
        /// The status of the step.
        public var status: DrsClientTypes.RecoveryInstanceDataReplicationInitiationStepStatus?

        public init(
            name: DrsClientTypes.RecoveryInstanceDataReplicationInitiationStepName? = nil,
            status: DrsClientTypes.RecoveryInstanceDataReplicationInitiationStepStatus? = nil
        )
        {
            self.name = name
            self.status = status
        }
    }

}

extension DrsClientTypes {
    public enum RecoveryInstanceDataReplicationInitiationStepName: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case attachStagingDisks
        case authenticateWithService
        case bootReplicationServer
        case completeVolumeMapping
        case configureReplicationSoftware
        case connectAgentToReplicationServer
        case createSecurityGroup
        case createStagingDisks
        case downloadReplicationSoftware
        case downloadReplicationSoftwareToFailbackClient
        case establishAgentReplicatorSoftwareCommunication
        case establishRecoveryInstanceCommunication
        case launchReplicationServer
        case linkFailbackClientWithRecoveryInstance
        case pairAgentWithReplicationSoftware
        case pairReplicationServerWithAgent
        case startDataTransfer
        case wait
        case sdkUnknown(Swift.String)

        public static var allCases: [RecoveryInstanceDataReplicationInitiationStepName] {
            return [
                .attachStagingDisks,
                .authenticateWithService,
                .bootReplicationServer,
                .completeVolumeMapping,
                .configureReplicationSoftware,
                .connectAgentToReplicationServer,
                .createSecurityGroup,
                .createStagingDisks,
                .downloadReplicationSoftware,
                .downloadReplicationSoftwareToFailbackClient,
                .establishAgentReplicatorSoftwareCommunication,
                .establishRecoveryInstanceCommunication,
                .launchReplicationServer,
                .linkFailbackClientWithRecoveryInstance,
                .pairAgentWithReplicationSoftware,
                .pairReplicationServerWithAgent,
                .startDataTransfer,
                .wait,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .attachStagingDisks: return "ATTACH_STAGING_DISKS"
            case .authenticateWithService: return "AUTHENTICATE_WITH_SERVICE"
            case .bootReplicationServer: return "BOOT_REPLICATION_SERVER"
            case .completeVolumeMapping: return "COMPLETE_VOLUME_MAPPING"
            case .configureReplicationSoftware: return "CONFIGURE_REPLICATION_SOFTWARE"
            case .connectAgentToReplicationServer: return "CONNECT_AGENT_TO_REPLICATION_SERVER"
            case .createSecurityGroup: return "CREATE_SECURITY_GROUP"
            case .createStagingDisks: return "CREATE_STAGING_DISKS"
            case .downloadReplicationSoftware: return "DOWNLOAD_REPLICATION_SOFTWARE"
            case .downloadReplicationSoftwareToFailbackClient: return "DOWNLOAD_REPLICATION_SOFTWARE_TO_FAILBACK_CLIENT"
            case .establishAgentReplicatorSoftwareCommunication: return "ESTABLISH_AGENT_REPLICATOR_SOFTWARE_COMMUNICATION"
            case .establishRecoveryInstanceCommunication: return "ESTABLISH_RECOVERY_INSTANCE_COMMUNICATION"
            case .launchReplicationServer: return "LAUNCH_REPLICATION_SERVER"
            case .linkFailbackClientWithRecoveryInstance: return "LINK_FAILBACK_CLIENT_WITH_RECOVERY_INSTANCE"
            case .pairAgentWithReplicationSoftware: return "PAIR_AGENT_WITH_REPLICATION_SOFTWARE"
            case .pairReplicationServerWithAgent: return "PAIR_REPLICATION_SERVER_WITH_AGENT"
            case .startDataTransfer: return "START_DATA_TRANSFER"
            case .wait: return "WAIT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RecoveryInstanceDataReplicationInitiationStepName(rawValue: rawValue) ?? RecoveryInstanceDataReplicationInitiationStepName.sdkUnknown(rawValue)
        }
    }
}

extension DrsClientTypes {
    public enum RecoveryInstanceDataReplicationInitiationStepStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failed
        case inProgress
        case notStarted
        case skipped
        case succeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [RecoveryInstanceDataReplicationInitiationStepStatus] {
            return [
                .failed,
                .inProgress,
                .notStarted,
                .skipped,
                .succeeded,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .notStarted: return "NOT_STARTED"
            case .skipped: return "SKIPPED"
            case .succeeded: return "SUCCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RecoveryInstanceDataReplicationInitiationStepStatus(rawValue: rawValue) ?? RecoveryInstanceDataReplicationInitiationStepStatus.sdkUnknown(rawValue)
        }
    }
}

extension DrsClientTypes {
    public enum RecoveryInstanceDataReplicationState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case backlog
        case continuous
        case creatingSnapshot
        case disconnected
        case initialSync
        case initiating
        case notStarted
        case paused
        case replicationStateNotAvailable
        case rescan
        case stalled
        case stopped
        case sdkUnknown(Swift.String)

        public static var allCases: [RecoveryInstanceDataReplicationState] {
            return [
                .backlog,
                .continuous,
                .creatingSnapshot,
                .disconnected,
                .initialSync,
                .initiating,
                .notStarted,
                .paused,
                .replicationStateNotAvailable,
                .rescan,
                .stalled,
                .stopped,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .backlog: return "BACKLOG"
            case .continuous: return "CONTINUOUS"
            case .creatingSnapshot: return "CREATING_SNAPSHOT"
            case .disconnected: return "DISCONNECTED"
            case .initialSync: return "INITIAL_SYNC"
            case .initiating: return "INITIATING"
            case .notStarted: return "NOT_STARTED"
            case .paused: return "PAUSED"
            case .replicationStateNotAvailable: return "REPLICATION_STATE_NOT_AVAILABLE"
            case .rescan: return "RESCAN"
            case .stalled: return "STALLED"
            case .stopped: return "STOPPED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RecoveryInstanceDataReplicationState(rawValue: rawValue) ?? RecoveryInstanceDataReplicationState.sdkUnknown(rawValue)
        }
    }
}

extension DrsClientTypes.RecoveryInstanceDisk: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bytes
        case ebsVolumeID
        case internalDeviceName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if bytes != 0 {
            try encodeContainer.encode(bytes, forKey: .bytes)
        }
        if let ebsVolumeID = self.ebsVolumeID {
            try encodeContainer.encode(ebsVolumeID, forKey: .ebsVolumeID)
        }
        if let internalDeviceName = self.internalDeviceName {
            try encodeContainer.encode(internalDeviceName, forKey: .internalDeviceName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let internalDeviceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .internalDeviceName)
        internalDeviceName = internalDeviceNameDecoded
        let bytesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .bytes) ?? 0
        bytes = bytesDecoded
        let ebsVolumeIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ebsVolumeID)
        ebsVolumeID = ebsVolumeIDDecoded
    }
}

extension DrsClientTypes {
    /// An object representing a block storage device on the Recovery Instance.
    public struct RecoveryInstanceDisk: Swift.Equatable {
        /// The amount of storage on the disk in bytes.
        public var bytes: Swift.Int
        /// The EBS Volume ID of this disk.
        public var ebsVolumeID: Swift.String?
        /// The internal device name of this disk. This is the name that is visible on the machine itself and not from the EC2 console.
        public var internalDeviceName: Swift.String?

        public init(
            bytes: Swift.Int = 0,
            ebsVolumeID: Swift.String? = nil,
            internalDeviceName: Swift.String? = nil
        )
        {
            self.bytes = bytes
            self.ebsVolumeID = ebsVolumeID
            self.internalDeviceName = internalDeviceName
        }
    }

}

extension DrsClientTypes.RecoveryInstanceFailback: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case agentLastSeenByServiceDateTime
        case elapsedReplicationDuration
        case failbackClientID
        case failbackClientLastSeenByServiceDateTime
        case failbackInitiationTime
        case failbackJobID
        case failbackLaunchType
        case failbackToOriginalServer
        case firstByteDateTime
        case state
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let agentLastSeenByServiceDateTime = self.agentLastSeenByServiceDateTime {
            try encodeContainer.encode(agentLastSeenByServiceDateTime, forKey: .agentLastSeenByServiceDateTime)
        }
        if let elapsedReplicationDuration = self.elapsedReplicationDuration {
            try encodeContainer.encode(elapsedReplicationDuration, forKey: .elapsedReplicationDuration)
        }
        if let failbackClientID = self.failbackClientID {
            try encodeContainer.encode(failbackClientID, forKey: .failbackClientID)
        }
        if let failbackClientLastSeenByServiceDateTime = self.failbackClientLastSeenByServiceDateTime {
            try encodeContainer.encode(failbackClientLastSeenByServiceDateTime, forKey: .failbackClientLastSeenByServiceDateTime)
        }
        if let failbackInitiationTime = self.failbackInitiationTime {
            try encodeContainer.encode(failbackInitiationTime, forKey: .failbackInitiationTime)
        }
        if let failbackJobID = self.failbackJobID {
            try encodeContainer.encode(failbackJobID, forKey: .failbackJobID)
        }
        if let failbackLaunchType = self.failbackLaunchType {
            try encodeContainer.encode(failbackLaunchType.rawValue, forKey: .failbackLaunchType)
        }
        if let failbackToOriginalServer = self.failbackToOriginalServer {
            try encodeContainer.encode(failbackToOriginalServer, forKey: .failbackToOriginalServer)
        }
        if let firstByteDateTime = self.firstByteDateTime {
            try encodeContainer.encode(firstByteDateTime, forKey: .firstByteDateTime)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let failbackClientIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failbackClientID)
        failbackClientID = failbackClientIDDecoded
        let failbackJobIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failbackJobID)
        failbackJobID = failbackJobIDDecoded
        let failbackInitiationTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failbackInitiationTime)
        failbackInitiationTime = failbackInitiationTimeDecoded
        let stateDecoded = try containerValues.decodeIfPresent(DrsClientTypes.FailbackState.self, forKey: .state)
        state = stateDecoded
        let agentLastSeenByServiceDateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .agentLastSeenByServiceDateTime)
        agentLastSeenByServiceDateTime = agentLastSeenByServiceDateTimeDecoded
        let failbackClientLastSeenByServiceDateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failbackClientLastSeenByServiceDateTime)
        failbackClientLastSeenByServiceDateTime = failbackClientLastSeenByServiceDateTimeDecoded
        let failbackToOriginalServerDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .failbackToOriginalServer)
        failbackToOriginalServer = failbackToOriginalServerDecoded
        let firstByteDateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .firstByteDateTime)
        firstByteDateTime = firstByteDateTimeDecoded
        let elapsedReplicationDurationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .elapsedReplicationDuration)
        elapsedReplicationDuration = elapsedReplicationDurationDecoded
        let failbackLaunchTypeDecoded = try containerValues.decodeIfPresent(DrsClientTypes.FailbackLaunchType.self, forKey: .failbackLaunchType)
        failbackLaunchType = failbackLaunchTypeDecoded
    }
}

extension DrsClientTypes {
    /// An object representing failback related information of the Recovery Instance.
    public struct RecoveryInstanceFailback: Swift.Equatable {
        /// The date and time the agent on the Recovery Instance was last seen by the service.
        public var agentLastSeenByServiceDateTime: Swift.String?
        /// The amount of time that the Recovery Instance has been replicating for.
        public var elapsedReplicationDuration: Swift.String?
        /// The ID of the failback client that this Recovery Instance is associated with.
        public var failbackClientID: Swift.String?
        /// The date and time that the failback client was last seen by the service.
        public var failbackClientLastSeenByServiceDateTime: Swift.String?
        /// The date and time that the failback initiation started.
        public var failbackInitiationTime: Swift.String?
        /// The Job ID of the last failback log for this Recovery Instance.
        public var failbackJobID: Swift.String?
        /// The launch type (Recovery / Drill) of the last launch for the failback replication of this recovery instance.
        public var failbackLaunchType: DrsClientTypes.FailbackLaunchType?
        /// Whether we are failing back to the original Source Server for this Recovery Instance.
        public var failbackToOriginalServer: Swift.Bool?
        /// The date and time of the first byte that was replicated from the Recovery Instance.
        public var firstByteDateTime: Swift.String?
        /// The state of the failback process that this Recovery Instance is in.
        public var state: DrsClientTypes.FailbackState?

        public init(
            agentLastSeenByServiceDateTime: Swift.String? = nil,
            elapsedReplicationDuration: Swift.String? = nil,
            failbackClientID: Swift.String? = nil,
            failbackClientLastSeenByServiceDateTime: Swift.String? = nil,
            failbackInitiationTime: Swift.String? = nil,
            failbackJobID: Swift.String? = nil,
            failbackLaunchType: DrsClientTypes.FailbackLaunchType? = nil,
            failbackToOriginalServer: Swift.Bool? = nil,
            firstByteDateTime: Swift.String? = nil,
            state: DrsClientTypes.FailbackState? = nil
        )
        {
            self.agentLastSeenByServiceDateTime = agentLastSeenByServiceDateTime
            self.elapsedReplicationDuration = elapsedReplicationDuration
            self.failbackClientID = failbackClientID
            self.failbackClientLastSeenByServiceDateTime = failbackClientLastSeenByServiceDateTime
            self.failbackInitiationTime = failbackInitiationTime
            self.failbackJobID = failbackJobID
            self.failbackLaunchType = failbackLaunchType
            self.failbackToOriginalServer = failbackToOriginalServer
            self.firstByteDateTime = firstByteDateTime
            self.state = state
        }
    }

}

extension DrsClientTypes.RecoveryInstanceProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cpus
        case disks
        case identificationHints
        case lastUpdatedDateTime
        case networkInterfaces
        case os
        case ramBytes
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cpus = cpus {
            var cpusContainer = encodeContainer.nestedUnkeyedContainer(forKey: .cpus)
            for cpu0 in cpus {
                try cpusContainer.encode(cpu0)
            }
        }
        if let disks = disks {
            var disksContainer = encodeContainer.nestedUnkeyedContainer(forKey: .disks)
            for recoveryinstancedisk0 in disks {
                try disksContainer.encode(recoveryinstancedisk0)
            }
        }
        if let identificationHints = self.identificationHints {
            try encodeContainer.encode(identificationHints, forKey: .identificationHints)
        }
        if let lastUpdatedDateTime = self.lastUpdatedDateTime {
            try encodeContainer.encode(lastUpdatedDateTime, forKey: .lastUpdatedDateTime)
        }
        if let networkInterfaces = networkInterfaces {
            var networkInterfacesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .networkInterfaces)
            for networkinterface0 in networkInterfaces {
                try networkInterfacesContainer.encode(networkinterface0)
            }
        }
        if let os = self.os {
            try encodeContainer.encode(os, forKey: .os)
        }
        if ramBytes != 0 {
            try encodeContainer.encode(ramBytes, forKey: .ramBytes)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lastUpdatedDateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastUpdatedDateTime)
        lastUpdatedDateTime = lastUpdatedDateTimeDecoded
        let identificationHintsDecoded = try containerValues.decodeIfPresent(DrsClientTypes.IdentificationHints.self, forKey: .identificationHints)
        identificationHints = identificationHintsDecoded
        let networkInterfacesContainer = try containerValues.decodeIfPresent([DrsClientTypes.NetworkInterface?].self, forKey: .networkInterfaces)
        var networkInterfacesDecoded0:[DrsClientTypes.NetworkInterface]? = nil
        if let networkInterfacesContainer = networkInterfacesContainer {
            networkInterfacesDecoded0 = [DrsClientTypes.NetworkInterface]()
            for structure0 in networkInterfacesContainer {
                if let structure0 = structure0 {
                    networkInterfacesDecoded0?.append(structure0)
                }
            }
        }
        networkInterfaces = networkInterfacesDecoded0
        let disksContainer = try containerValues.decodeIfPresent([DrsClientTypes.RecoveryInstanceDisk?].self, forKey: .disks)
        var disksDecoded0:[DrsClientTypes.RecoveryInstanceDisk]? = nil
        if let disksContainer = disksContainer {
            disksDecoded0 = [DrsClientTypes.RecoveryInstanceDisk]()
            for structure0 in disksContainer {
                if let structure0 = structure0 {
                    disksDecoded0?.append(structure0)
                }
            }
        }
        disks = disksDecoded0
        let cpusContainer = try containerValues.decodeIfPresent([DrsClientTypes.CPU?].self, forKey: .cpus)
        var cpusDecoded0:[DrsClientTypes.CPU]? = nil
        if let cpusContainer = cpusContainer {
            cpusDecoded0 = [DrsClientTypes.CPU]()
            for structure0 in cpusContainer {
                if let structure0 = structure0 {
                    cpusDecoded0?.append(structure0)
                }
            }
        }
        cpus = cpusDecoded0
        let ramBytesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .ramBytes) ?? 0
        ramBytes = ramBytesDecoded
        let osDecoded = try containerValues.decodeIfPresent(DrsClientTypes.OS.self, forKey: .os)
        os = osDecoded
    }
}

extension DrsClientTypes {
    /// Properties of the Recovery Instance machine.
    public struct RecoveryInstanceProperties: Swift.Equatable {
        /// An array of CPUs.
        public var cpus: [DrsClientTypes.CPU]?
        /// An array of disks.
        public var disks: [DrsClientTypes.RecoveryInstanceDisk]?
        /// Hints used to uniquely identify a machine.
        public var identificationHints: DrsClientTypes.IdentificationHints?
        /// The date and time the Recovery Instance properties were last updated on.
        public var lastUpdatedDateTime: Swift.String?
        /// An array of network interfaces.
        public var networkInterfaces: [DrsClientTypes.NetworkInterface]?
        /// Operating system.
        public var os: DrsClientTypes.OS?
        /// The amount of RAM in bytes.
        public var ramBytes: Swift.Int

        public init(
            cpus: [DrsClientTypes.CPU]? = nil,
            disks: [DrsClientTypes.RecoveryInstanceDisk]? = nil,
            identificationHints: DrsClientTypes.IdentificationHints? = nil,
            lastUpdatedDateTime: Swift.String? = nil,
            networkInterfaces: [DrsClientTypes.NetworkInterface]? = nil,
            os: DrsClientTypes.OS? = nil,
            ramBytes: Swift.Int = 0
        )
        {
            self.cpus = cpus
            self.disks = disks
            self.identificationHints = identificationHints
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.networkInterfaces = networkInterfaces
            self.os = os
            self.ramBytes = ramBytes
        }
    }

}

extension DrsClientTypes.RecoveryLifeCycle: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiCallDateTime
        case jobID
        case lastRecoveryResult
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let apiCallDateTime = self.apiCallDateTime {
            try encodeContainer.encodeTimestamp(apiCallDateTime, format: .dateTime, forKey: .apiCallDateTime)
        }
        if let jobID = self.jobID {
            try encodeContainer.encode(jobID, forKey: .jobID)
        }
        if let lastRecoveryResult = self.lastRecoveryResult {
            try encodeContainer.encode(lastRecoveryResult.rawValue, forKey: .lastRecoveryResult)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiCallDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .apiCallDateTime)
        apiCallDateTime = apiCallDateTimeDecoded
        let jobIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .jobID)
        jobID = jobIDDecoded
        let lastRecoveryResultDecoded = try containerValues.decodeIfPresent(DrsClientTypes.RecoveryResult.self, forKey: .lastRecoveryResult)
        lastRecoveryResult = lastRecoveryResultDecoded
    }
}

extension DrsClientTypes {
    /// An object representing the Source Network recovery Lifecycle.
    public struct RecoveryLifeCycle: Swift.Equatable {
        /// The date and time the last Source Network recovery was initiated.
        public var apiCallDateTime: ClientRuntime.Date?
        /// The ID of the Job that was used to last recover the Source Network.
        public var jobID: Swift.String?
        /// The status of the last recovery status of this Source Network.
        public var lastRecoveryResult: DrsClientTypes.RecoveryResult?

        public init(
            apiCallDateTime: ClientRuntime.Date? = nil,
            jobID: Swift.String? = nil,
            lastRecoveryResult: DrsClientTypes.RecoveryResult? = nil
        )
        {
            self.apiCallDateTime = apiCallDateTime
            self.jobID = jobID
            self.lastRecoveryResult = lastRecoveryResult
        }
    }

}

extension DrsClientTypes {
    public enum RecoveryResult: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case associateFail
        case associateSuccess
        case fail
        case inProgress
        case notStarted
        case partialSuccess
        case success
        case sdkUnknown(Swift.String)

        public static var allCases: [RecoveryResult] {
            return [
                .associateFail,
                .associateSuccess,
                .fail,
                .inProgress,
                .notStarted,
                .partialSuccess,
                .success,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .associateFail: return "ASSOCIATE_FAIL"
            case .associateSuccess: return "ASSOCIATE_SUCCESS"
            case .fail: return "FAIL"
            case .inProgress: return "IN_PROGRESS"
            case .notStarted: return "NOT_STARTED"
            case .partialSuccess: return "PARTIAL_SUCCESS"
            case .success: return "SUCCESS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RecoveryResult(rawValue: rawValue) ?? RecoveryResult.sdkUnknown(rawValue)
        }
    }
}

extension DrsClientTypes.RecoverySnapshot: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ebsSnapshots
        case expectedTimestamp
        case snapshotID
        case sourceServerID
        case timestamp
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ebsSnapshots = ebsSnapshots {
            var ebsSnapshotsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ebsSnapshots)
            for ebssnapshot0 in ebsSnapshots {
                try ebsSnapshotsContainer.encode(ebssnapshot0)
            }
        }
        if let expectedTimestamp = self.expectedTimestamp {
            try encodeContainer.encode(expectedTimestamp, forKey: .expectedTimestamp)
        }
        if let snapshotID = self.snapshotID {
            try encodeContainer.encode(snapshotID, forKey: .snapshotID)
        }
        if let sourceServerID = self.sourceServerID {
            try encodeContainer.encode(sourceServerID, forKey: .sourceServerID)
        }
        if let timestamp = self.timestamp {
            try encodeContainer.encode(timestamp, forKey: .timestamp)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let snapshotIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snapshotID)
        snapshotID = snapshotIDDecoded
        let sourceServerIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceServerID)
        sourceServerID = sourceServerIDDecoded
        let expectedTimestampDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .expectedTimestamp)
        expectedTimestamp = expectedTimestampDecoded
        let timestampDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .timestamp)
        timestamp = timestampDecoded
        let ebsSnapshotsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .ebsSnapshots)
        var ebsSnapshotsDecoded0:[Swift.String]? = nil
        if let ebsSnapshotsContainer = ebsSnapshotsContainer {
            ebsSnapshotsDecoded0 = [Swift.String]()
            for string0 in ebsSnapshotsContainer {
                if let string0 = string0 {
                    ebsSnapshotsDecoded0?.append(string0)
                }
            }
        }
        ebsSnapshots = ebsSnapshotsDecoded0
    }
}

extension DrsClientTypes {
    /// A snapshot of a Source Server used during recovery.
    public struct RecoverySnapshot: Swift.Equatable {
        /// A list of EBS snapshots.
        public var ebsSnapshots: [Swift.String]?
        /// The timestamp of when we expect the snapshot to be taken.
        /// This member is required.
        public var expectedTimestamp: Swift.String?
        /// The ID of the Recovery Snapshot.
        /// This member is required.
        public var snapshotID: Swift.String?
        /// The ID of the Source Server that the snapshot was taken for.
        /// This member is required.
        public var sourceServerID: Swift.String?
        /// The actual timestamp that the snapshot was taken.
        public var timestamp: Swift.String?

        public init(
            ebsSnapshots: [Swift.String]? = nil,
            expectedTimestamp: Swift.String? = nil,
            snapshotID: Swift.String? = nil,
            sourceServerID: Swift.String? = nil,
            timestamp: Swift.String? = nil
        )
        {
            self.ebsSnapshots = ebsSnapshots
            self.expectedTimestamp = expectedTimestamp
            self.snapshotID = snapshotID
            self.sourceServerID = sourceServerID
            self.timestamp = timestamp
        }
    }

}

extension DrsClientTypes {
    public enum RecoverySnapshotsOrder: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case asc
        case desc
        case sdkUnknown(Swift.String)

        public static var allCases: [RecoverySnapshotsOrder] {
            return [
                .asc,
                .desc,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .asc: return "ASC"
            case .desc: return "DESC"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RecoverySnapshotsOrder(rawValue: rawValue) ?? RecoverySnapshotsOrder.sdkUnknown(rawValue)
        }
    }
}

extension DrsClientTypes {
    public enum ReplicationConfigurationDataPlaneRouting: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case privateIp
        case publicIp
        case sdkUnknown(Swift.String)

        public static var allCases: [ReplicationConfigurationDataPlaneRouting] {
            return [
                .privateIp,
                .publicIp,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .privateIp: return "PRIVATE_IP"
            case .publicIp: return "PUBLIC_IP"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ReplicationConfigurationDataPlaneRouting(rawValue: rawValue) ?? ReplicationConfigurationDataPlaneRouting.sdkUnknown(rawValue)
        }
    }
}

extension DrsClientTypes {
    public enum ReplicationConfigurationDefaultLargeStagingDiskType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case auto
        case gp2
        case gp3
        case st1
        case sdkUnknown(Swift.String)

        public static var allCases: [ReplicationConfigurationDefaultLargeStagingDiskType] {
            return [
                .auto,
                .gp2,
                .gp3,
                .st1,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .auto: return "AUTO"
            case .gp2: return "GP2"
            case .gp3: return "GP3"
            case .st1: return "ST1"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ReplicationConfigurationDefaultLargeStagingDiskType(rawValue: rawValue) ?? ReplicationConfigurationDefaultLargeStagingDiskType.sdkUnknown(rawValue)
        }
    }
}

extension DrsClientTypes {
    public enum ReplicationConfigurationEbsEncryption: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case custom
        case `default`
        case `none`
        case sdkUnknown(Swift.String)

        public static var allCases: [ReplicationConfigurationEbsEncryption] {
            return [
                .custom,
                .default,
                .none,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .custom: return "CUSTOM"
            case .default: return "DEFAULT"
            case .none: return "NONE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ReplicationConfigurationEbsEncryption(rawValue: rawValue) ?? ReplicationConfigurationEbsEncryption.sdkUnknown(rawValue)
        }
    }
}

extension DrsClientTypes.ReplicationConfigurationReplicatedDisk: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceName
        case iops
        case isBootDisk
        case optimizedStagingDiskType
        case stagingDiskType
        case throughput
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deviceName = self.deviceName {
            try encodeContainer.encode(deviceName, forKey: .deviceName)
        }
        if iops != 0 {
            try encodeContainer.encode(iops, forKey: .iops)
        }
        if let isBootDisk = self.isBootDisk {
            try encodeContainer.encode(isBootDisk, forKey: .isBootDisk)
        }
        if let optimizedStagingDiskType = self.optimizedStagingDiskType {
            try encodeContainer.encode(optimizedStagingDiskType.rawValue, forKey: .optimizedStagingDiskType)
        }
        if let stagingDiskType = self.stagingDiskType {
            try encodeContainer.encode(stagingDiskType.rawValue, forKey: .stagingDiskType)
        }
        if throughput != 0 {
            try encodeContainer.encode(throughput, forKey: .throughput)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceName)
        deviceName = deviceNameDecoded
        let isBootDiskDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isBootDisk)
        isBootDisk = isBootDiskDecoded
        let stagingDiskTypeDecoded = try containerValues.decodeIfPresent(DrsClientTypes.ReplicationConfigurationReplicatedDiskStagingDiskType.self, forKey: .stagingDiskType)
        stagingDiskType = stagingDiskTypeDecoded
        let iopsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .iops) ?? 0
        iops = iopsDecoded
        let throughputDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .throughput) ?? 0
        throughput = throughputDecoded
        let optimizedStagingDiskTypeDecoded = try containerValues.decodeIfPresent(DrsClientTypes.ReplicationConfigurationReplicatedDiskStagingDiskType.self, forKey: .optimizedStagingDiskType)
        optimizedStagingDiskType = optimizedStagingDiskTypeDecoded
    }
}

extension DrsClientTypes {
    /// The configuration of a disk of the Source Server to be replicated.
    public struct ReplicationConfigurationReplicatedDisk: Swift.Equatable {
        /// The name of the device.
        public var deviceName: Swift.String?
        /// The requested number of I/O operations per second (IOPS).
        public var iops: Swift.Int
        /// Whether to boot from this disk or not.
        public var isBootDisk: Swift.Bool?
        /// The Staging Disk EBS volume type to be used during replication when stagingDiskType is set to Auto. This is a read-only field.
        public var optimizedStagingDiskType: DrsClientTypes.ReplicationConfigurationReplicatedDiskStagingDiskType?
        /// The Staging Disk EBS volume type to be used during replication.
        public var stagingDiskType: DrsClientTypes.ReplicationConfigurationReplicatedDiskStagingDiskType?
        /// The throughput to use for the EBS volume in MiB/s. This parameter is valid only for gp3 volumes.
        public var throughput: Swift.Int

        public init(
            deviceName: Swift.String? = nil,
            iops: Swift.Int = 0,
            isBootDisk: Swift.Bool? = nil,
            optimizedStagingDiskType: DrsClientTypes.ReplicationConfigurationReplicatedDiskStagingDiskType? = nil,
            stagingDiskType: DrsClientTypes.ReplicationConfigurationReplicatedDiskStagingDiskType? = nil,
            throughput: Swift.Int = 0
        )
        {
            self.deviceName = deviceName
            self.iops = iops
            self.isBootDisk = isBootDisk
            self.optimizedStagingDiskType = optimizedStagingDiskType
            self.stagingDiskType = stagingDiskType
            self.throughput = throughput
        }
    }

}

extension DrsClientTypes {
    public enum ReplicationConfigurationReplicatedDiskStagingDiskType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case auto
        case gp2
        case gp3
        case io1
        case sc1
        case st1
        case standard
        case sdkUnknown(Swift.String)

        public static var allCases: [ReplicationConfigurationReplicatedDiskStagingDiskType] {
            return [
                .auto,
                .gp2,
                .gp3,
                .io1,
                .sc1,
                .st1,
                .standard,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .auto: return "AUTO"
            case .gp2: return "GP2"
            case .gp3: return "GP3"
            case .io1: return "IO1"
            case .sc1: return "SC1"
            case .st1: return "ST1"
            case .standard: return "STANDARD"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ReplicationConfigurationReplicatedDiskStagingDiskType(rawValue: rawValue) ?? ReplicationConfigurationReplicatedDiskStagingDiskType.sdkUnknown(rawValue)
        }
    }
}

extension DrsClientTypes.ReplicationConfigurationTemplate: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case associateDefaultSecurityGroup
        case autoReplicateNewDisks
        case bandwidthThrottling
        case createPublicIP
        case dataPlaneRouting
        case defaultLargeStagingDiskType
        case ebsEncryption
        case ebsEncryptionKeyArn
        case pitPolicy
        case replicationConfigurationTemplateID
        case replicationServerInstanceType
        case replicationServersSecurityGroupsIDs
        case stagingAreaSubnetId
        case stagingAreaTags
        case tags
        case useDedicatedReplicationServer
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let associateDefaultSecurityGroup = self.associateDefaultSecurityGroup {
            try encodeContainer.encode(associateDefaultSecurityGroup, forKey: .associateDefaultSecurityGroup)
        }
        if let autoReplicateNewDisks = self.autoReplicateNewDisks {
            try encodeContainer.encode(autoReplicateNewDisks, forKey: .autoReplicateNewDisks)
        }
        if bandwidthThrottling != 0 {
            try encodeContainer.encode(bandwidthThrottling, forKey: .bandwidthThrottling)
        }
        if let createPublicIP = self.createPublicIP {
            try encodeContainer.encode(createPublicIP, forKey: .createPublicIP)
        }
        if let dataPlaneRouting = self.dataPlaneRouting {
            try encodeContainer.encode(dataPlaneRouting.rawValue, forKey: .dataPlaneRouting)
        }
        if let defaultLargeStagingDiskType = self.defaultLargeStagingDiskType {
            try encodeContainer.encode(defaultLargeStagingDiskType.rawValue, forKey: .defaultLargeStagingDiskType)
        }
        if let ebsEncryption = self.ebsEncryption {
            try encodeContainer.encode(ebsEncryption.rawValue, forKey: .ebsEncryption)
        }
        if let ebsEncryptionKeyArn = self.ebsEncryptionKeyArn {
            try encodeContainer.encode(ebsEncryptionKeyArn, forKey: .ebsEncryptionKeyArn)
        }
        if let pitPolicy = pitPolicy {
            var pitPolicyContainer = encodeContainer.nestedUnkeyedContainer(forKey: .pitPolicy)
            for pitpolicyrule0 in pitPolicy {
                try pitPolicyContainer.encode(pitpolicyrule0)
            }
        }
        if let replicationConfigurationTemplateID = self.replicationConfigurationTemplateID {
            try encodeContainer.encode(replicationConfigurationTemplateID, forKey: .replicationConfigurationTemplateID)
        }
        if let replicationServerInstanceType = self.replicationServerInstanceType {
            try encodeContainer.encode(replicationServerInstanceType, forKey: .replicationServerInstanceType)
        }
        if let replicationServersSecurityGroupsIDs = replicationServersSecurityGroupsIDs {
            var replicationServersSecurityGroupsIDsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .replicationServersSecurityGroupsIDs)
            for securitygroupid0 in replicationServersSecurityGroupsIDs {
                try replicationServersSecurityGroupsIDsContainer.encode(securitygroupid0)
            }
        }
        if let stagingAreaSubnetId = self.stagingAreaSubnetId {
            try encodeContainer.encode(stagingAreaSubnetId, forKey: .stagingAreaSubnetId)
        }
        if let stagingAreaTags = stagingAreaTags {
            var stagingAreaTagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .stagingAreaTags)
            for (dictKey0, tagsMap0) in stagingAreaTags {
                try stagingAreaTagsContainer.encode(tagsMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagsMap0) in tags {
                try tagsContainer.encode(tagsMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let useDedicatedReplicationServer = self.useDedicatedReplicationServer {
            try encodeContainer.encode(useDedicatedReplicationServer, forKey: .useDedicatedReplicationServer)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationConfigurationTemplateIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationConfigurationTemplateID)
        replicationConfigurationTemplateID = replicationConfigurationTemplateIDDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let stagingAreaSubnetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stagingAreaSubnetId)
        stagingAreaSubnetId = stagingAreaSubnetIdDecoded
        let associateDefaultSecurityGroupDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .associateDefaultSecurityGroup)
        associateDefaultSecurityGroup = associateDefaultSecurityGroupDecoded
        let replicationServersSecurityGroupsIDsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .replicationServersSecurityGroupsIDs)
        var replicationServersSecurityGroupsIDsDecoded0:[Swift.String]? = nil
        if let replicationServersSecurityGroupsIDsContainer = replicationServersSecurityGroupsIDsContainer {
            replicationServersSecurityGroupsIDsDecoded0 = [Swift.String]()
            for string0 in replicationServersSecurityGroupsIDsContainer {
                if let string0 = string0 {
                    replicationServersSecurityGroupsIDsDecoded0?.append(string0)
                }
            }
        }
        replicationServersSecurityGroupsIDs = replicationServersSecurityGroupsIDsDecoded0
        let replicationServerInstanceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationServerInstanceType)
        replicationServerInstanceType = replicationServerInstanceTypeDecoded
        let useDedicatedReplicationServerDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .useDedicatedReplicationServer)
        useDedicatedReplicationServer = useDedicatedReplicationServerDecoded
        let defaultLargeStagingDiskTypeDecoded = try containerValues.decodeIfPresent(DrsClientTypes.ReplicationConfigurationDefaultLargeStagingDiskType.self, forKey: .defaultLargeStagingDiskType)
        defaultLargeStagingDiskType = defaultLargeStagingDiskTypeDecoded
        let ebsEncryptionDecoded = try containerValues.decodeIfPresent(DrsClientTypes.ReplicationConfigurationEbsEncryption.self, forKey: .ebsEncryption)
        ebsEncryption = ebsEncryptionDecoded
        let ebsEncryptionKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ebsEncryptionKeyArn)
        ebsEncryptionKeyArn = ebsEncryptionKeyArnDecoded
        let bandwidthThrottlingDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .bandwidthThrottling) ?? 0
        bandwidthThrottling = bandwidthThrottlingDecoded
        let dataPlaneRoutingDecoded = try containerValues.decodeIfPresent(DrsClientTypes.ReplicationConfigurationDataPlaneRouting.self, forKey: .dataPlaneRouting)
        dataPlaneRouting = dataPlaneRoutingDecoded
        let createPublicIPDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .createPublicIP)
        createPublicIP = createPublicIPDecoded
        let stagingAreaTagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .stagingAreaTags)
        var stagingAreaTagsDecoded0: [Swift.String:Swift.String]? = nil
        if let stagingAreaTagsContainer = stagingAreaTagsContainer {
            stagingAreaTagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in stagingAreaTagsContainer {
                if let tagvalue0 = tagvalue0 {
                    stagingAreaTagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        stagingAreaTags = stagingAreaTagsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let pitPolicyContainer = try containerValues.decodeIfPresent([DrsClientTypes.PITPolicyRule?].self, forKey: .pitPolicy)
        var pitPolicyDecoded0:[DrsClientTypes.PITPolicyRule]? = nil
        if let pitPolicyContainer = pitPolicyContainer {
            pitPolicyDecoded0 = [DrsClientTypes.PITPolicyRule]()
            for structure0 in pitPolicyContainer {
                if let structure0 = structure0 {
                    pitPolicyDecoded0?.append(structure0)
                }
            }
        }
        pitPolicy = pitPolicyDecoded0
        let autoReplicateNewDisksDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .autoReplicateNewDisks)
        autoReplicateNewDisks = autoReplicateNewDisksDecoded
    }
}

extension DrsClientTypes.ReplicationConfigurationTemplate: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ReplicationConfigurationTemplate(arn: \(Swift.String(describing: arn)), associateDefaultSecurityGroup: \(Swift.String(describing: associateDefaultSecurityGroup)), autoReplicateNewDisks: \(Swift.String(describing: autoReplicateNewDisks)), bandwidthThrottling: \(Swift.String(describing: bandwidthThrottling)), createPublicIP: \(Swift.String(describing: createPublicIP)), dataPlaneRouting: \(Swift.String(describing: dataPlaneRouting)), defaultLargeStagingDiskType: \(Swift.String(describing: defaultLargeStagingDiskType)), ebsEncryption: \(Swift.String(describing: ebsEncryption)), ebsEncryptionKeyArn: \(Swift.String(describing: ebsEncryptionKeyArn)), pitPolicy: \(Swift.String(describing: pitPolicy)), replicationConfigurationTemplateID: \(Swift.String(describing: replicationConfigurationTemplateID)), replicationServerInstanceType: \(Swift.String(describing: replicationServerInstanceType)), replicationServersSecurityGroupsIDs: \(Swift.String(describing: replicationServersSecurityGroupsIDs)), stagingAreaSubnetId: \(Swift.String(describing: stagingAreaSubnetId)), useDedicatedReplicationServer: \(Swift.String(describing: useDedicatedReplicationServer)), stagingAreaTags: \"CONTENT_REDACTED\", tags: \"CONTENT_REDACTED\")"}
}

extension DrsClientTypes {
    public struct ReplicationConfigurationTemplate: Swift.Equatable {
        /// The Replication Configuration Template ARN.
        public var arn: Swift.String?
        /// Whether to associate the default Elastic Disaster Recovery Security group with the Replication Configuration Template.
        public var associateDefaultSecurityGroup: Swift.Bool?
        /// Whether to allow the AWS replication agent to automatically replicate newly added disks.
        public var autoReplicateNewDisks: Swift.Bool?
        /// Configure bandwidth throttling for the outbound data transfer rate of the Source Server in Mbps.
        public var bandwidthThrottling: Swift.Int
        /// Whether to create a Public IP for the Recovery Instance by default.
        public var createPublicIP: Swift.Bool?
        /// The data plane routing mechanism that will be used for replication.
        public var dataPlaneRouting: DrsClientTypes.ReplicationConfigurationDataPlaneRouting?
        /// The Staging Disk EBS volume type to be used during replication.
        public var defaultLargeStagingDiskType: DrsClientTypes.ReplicationConfigurationDefaultLargeStagingDiskType?
        /// The type of EBS encryption to be used during replication.
        public var ebsEncryption: DrsClientTypes.ReplicationConfigurationEbsEncryption?
        /// The ARN of the EBS encryption key to be used during replication.
        public var ebsEncryptionKeyArn: Swift.String?
        /// The Point in time (PIT) policy to manage snapshots taken during replication.
        public var pitPolicy: [DrsClientTypes.PITPolicyRule]?
        /// The Replication Configuration Template ID.
        /// This member is required.
        public var replicationConfigurationTemplateID: Swift.String?
        /// The instance type to be used for the replication server.
        public var replicationServerInstanceType: Swift.String?
        /// The security group IDs that will be used by the replication server.
        public var replicationServersSecurityGroupsIDs: [Swift.String]?
        /// The subnet to be used by the replication staging area.
        public var stagingAreaSubnetId: Swift.String?
        /// A set of tags to be associated with all resources created in the replication staging area: EC2 replication server, EBS volumes, EBS snapshots, etc.
        public var stagingAreaTags: [Swift.String:Swift.String]?
        /// A set of tags to be associated with the Replication Configuration Template resource.
        public var tags: [Swift.String:Swift.String]?
        /// Whether to use a dedicated Replication Server in the replication staging area.
        public var useDedicatedReplicationServer: Swift.Bool?

        public init(
            arn: Swift.String? = nil,
            associateDefaultSecurityGroup: Swift.Bool? = nil,
            autoReplicateNewDisks: Swift.Bool? = nil,
            bandwidthThrottling: Swift.Int = 0,
            createPublicIP: Swift.Bool? = nil,
            dataPlaneRouting: DrsClientTypes.ReplicationConfigurationDataPlaneRouting? = nil,
            defaultLargeStagingDiskType: DrsClientTypes.ReplicationConfigurationDefaultLargeStagingDiskType? = nil,
            ebsEncryption: DrsClientTypes.ReplicationConfigurationEbsEncryption? = nil,
            ebsEncryptionKeyArn: Swift.String? = nil,
            pitPolicy: [DrsClientTypes.PITPolicyRule]? = nil,
            replicationConfigurationTemplateID: Swift.String? = nil,
            replicationServerInstanceType: Swift.String? = nil,
            replicationServersSecurityGroupsIDs: [Swift.String]? = nil,
            stagingAreaSubnetId: Swift.String? = nil,
            stagingAreaTags: [Swift.String:Swift.String]? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            useDedicatedReplicationServer: Swift.Bool? = nil
        )
        {
            self.arn = arn
            self.associateDefaultSecurityGroup = associateDefaultSecurityGroup
            self.autoReplicateNewDisks = autoReplicateNewDisks
            self.bandwidthThrottling = bandwidthThrottling
            self.createPublicIP = createPublicIP
            self.dataPlaneRouting = dataPlaneRouting
            self.defaultLargeStagingDiskType = defaultLargeStagingDiskType
            self.ebsEncryption = ebsEncryption
            self.ebsEncryptionKeyArn = ebsEncryptionKeyArn
            self.pitPolicy = pitPolicy
            self.replicationConfigurationTemplateID = replicationConfigurationTemplateID
            self.replicationServerInstanceType = replicationServerInstanceType
            self.replicationServersSecurityGroupsIDs = replicationServersSecurityGroupsIDs
            self.stagingAreaSubnetId = stagingAreaSubnetId
            self.stagingAreaTags = stagingAreaTags
            self.tags = tags
            self.useDedicatedReplicationServer = useDedicatedReplicationServer
        }
    }

}

extension DrsClientTypes {
    /// Replication direction designates if this is a failover replication, or a failback replication. When a DRS agent is installed on an instance, the replication direction is failover. In cases where a recovery launch was made in the recovery location and a new recovery instance was created, and then a failback replication was initiated from that recovery instance back to the origin location, then the replication direction will be failback.
    public enum ReplicationDirection: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failback
        case failover
        case sdkUnknown(Swift.String)

        public static var allCases: [ReplicationDirection] {
            return [
                .failback,
                .failover,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failback: return "FAILBACK"
            case .failover: return "FAILOVER"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ReplicationDirection(rawValue: rawValue) ?? ReplicationDirection.sdkUnknown(rawValue)
        }
    }
}

extension DrsClientTypes {
    public enum ReplicationStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case error
        case inProgress
        case protected
        case stopped
        case sdkUnknown(Swift.String)

        public static var allCases: [ReplicationStatus] {
            return [
                .error,
                .inProgress,
                .protected,
                .stopped,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .error: return "ERROR"
            case .inProgress: return "IN_PROGRESS"
            case .protected: return "PROTECTED"
            case .stopped: return "STOPPED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ReplicationStatus(rawValue: rawValue) ?? ReplicationStatus.sdkUnknown(rawValue)
        }
    }
}

extension ResourceNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.code = output.code
            self.properties.message = output.message
            self.properties.resourceId = output.resourceId
            self.properties.resourceType = output.resourceType
        } else {
            self.properties.code = nil
            self.properties.message = nil
            self.properties.resourceId = nil
            self.properties.resourceType = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The resource for this operation was not found.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var code: Swift.String? = nil
        public internal(set) var message: Swift.String? = nil
        /// The ID of the resource.
        public internal(set) var resourceId: Swift.String? = nil
        /// The type of the resource.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let code: Swift.String?
    let resourceId: Swift.String?
    let resourceType: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code
        case message
        case resourceId
        case resourceType
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension RetryDataReplicationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sourceServerID
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sourceServerID = self.sourceServerID {
            try encodeContainer.encode(sourceServerID, forKey: .sourceServerID)
        }
    }
}

extension RetryDataReplicationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/RetryDataReplication"
    }
}

@available(*, deprecated, message: "WARNING: RetryDataReplication is deprecated")
public struct RetryDataReplicationInput: Swift.Equatable {
    /// The ID of the Source Server whose data replication should be retried.
    /// This member is required.
    public var sourceServerID: Swift.String?

    public init(
        sourceServerID: Swift.String? = nil
    )
    {
        self.sourceServerID = sourceServerID
    }
}

struct RetryDataReplicationInputBody: Swift.Equatable {
    let sourceServerID: Swift.String?
}

extension RetryDataReplicationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sourceServerID
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceServerIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceServerID)
        sourceServerID = sourceServerIDDecoded
    }
}

extension RetryDataReplicationOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RetryDataReplicationOutput(arn: \(Swift.String(describing: arn)), dataReplicationInfo: \(Swift.String(describing: dataReplicationInfo)), lastLaunchResult: \(Swift.String(describing: lastLaunchResult)), lifeCycle: \(Swift.String(describing: lifeCycle)), recoveryInstanceId: \(Swift.String(describing: recoveryInstanceId)), replicationDirection: \(Swift.String(describing: replicationDirection)), reversedDirectionSourceServerArn: \(Swift.String(describing: reversedDirectionSourceServerArn)), sourceCloudProperties: \(Swift.String(describing: sourceCloudProperties)), sourceNetworkID: \(Swift.String(describing: sourceNetworkID)), sourceProperties: \(Swift.String(describing: sourceProperties)), sourceServerID: \(Swift.String(describing: sourceServerID)), stagingArea: \(Swift.String(describing: stagingArea)), tags: \"CONTENT_REDACTED\")"}
}

extension RetryDataReplicationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: RetryDataReplicationOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.dataReplicationInfo = output.dataReplicationInfo
            self.lastLaunchResult = output.lastLaunchResult
            self.lifeCycle = output.lifeCycle
            self.recoveryInstanceId = output.recoveryInstanceId
            self.replicationDirection = output.replicationDirection
            self.reversedDirectionSourceServerArn = output.reversedDirectionSourceServerArn
            self.sourceCloudProperties = output.sourceCloudProperties
            self.sourceNetworkID = output.sourceNetworkID
            self.sourceProperties = output.sourceProperties
            self.sourceServerID = output.sourceServerID
            self.stagingArea = output.stagingArea
            self.tags = output.tags
        } else {
            self.arn = nil
            self.dataReplicationInfo = nil
            self.lastLaunchResult = nil
            self.lifeCycle = nil
            self.recoveryInstanceId = nil
            self.replicationDirection = nil
            self.reversedDirectionSourceServerArn = nil
            self.sourceCloudProperties = nil
            self.sourceNetworkID = nil
            self.sourceProperties = nil
            self.sourceServerID = nil
            self.stagingArea = nil
            self.tags = nil
        }
    }
}

public struct RetryDataReplicationOutput: Swift.Equatable {
    /// The ARN of the Source Server.
    public var arn: Swift.String?
    /// The Data Replication Info of the Source Server.
    public var dataReplicationInfo: DrsClientTypes.DataReplicationInfo?
    /// The status of the last recovery launch of this Source Server.
    public var lastLaunchResult: DrsClientTypes.LastLaunchResult?
    /// The lifecycle information of this Source Server.
    public var lifeCycle: DrsClientTypes.LifeCycle?
    /// The ID of the Recovery Instance associated with this Source Server.
    public var recoveryInstanceId: Swift.String?
    /// Replication direction of the Source Server.
    public var replicationDirection: DrsClientTypes.ReplicationDirection?
    /// For EC2-originated Source Servers which have been failed over and then failed back, this value will mean the ARN of the Source Server on the opposite replication direction.
    public var reversedDirectionSourceServerArn: Swift.String?
    /// Source cloud properties of the Source Server.
    public var sourceCloudProperties: DrsClientTypes.SourceCloudProperties?
    /// ID of the Source Network which is protecting this Source Server's network.
    public var sourceNetworkID: Swift.String?
    /// The source properties of the Source Server.
    public var sourceProperties: DrsClientTypes.SourceProperties?
    /// The ID of the Source Server.
    public var sourceServerID: Swift.String?
    /// The staging area of the source server.
    public var stagingArea: DrsClientTypes.StagingArea?
    /// The tags associated with the Source Server.
    public var tags: [Swift.String:Swift.String]?

    public init(
        arn: Swift.String? = nil,
        dataReplicationInfo: DrsClientTypes.DataReplicationInfo? = nil,
        lastLaunchResult: DrsClientTypes.LastLaunchResult? = nil,
        lifeCycle: DrsClientTypes.LifeCycle? = nil,
        recoveryInstanceId: Swift.String? = nil,
        replicationDirection: DrsClientTypes.ReplicationDirection? = nil,
        reversedDirectionSourceServerArn: Swift.String? = nil,
        sourceCloudProperties: DrsClientTypes.SourceCloudProperties? = nil,
        sourceNetworkID: Swift.String? = nil,
        sourceProperties: DrsClientTypes.SourceProperties? = nil,
        sourceServerID: Swift.String? = nil,
        stagingArea: DrsClientTypes.StagingArea? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.arn = arn
        self.dataReplicationInfo = dataReplicationInfo
        self.lastLaunchResult = lastLaunchResult
        self.lifeCycle = lifeCycle
        self.recoveryInstanceId = recoveryInstanceId
        self.replicationDirection = replicationDirection
        self.reversedDirectionSourceServerArn = reversedDirectionSourceServerArn
        self.sourceCloudProperties = sourceCloudProperties
        self.sourceNetworkID = sourceNetworkID
        self.sourceProperties = sourceProperties
        self.sourceServerID = sourceServerID
        self.stagingArea = stagingArea
        self.tags = tags
    }
}

struct RetryDataReplicationOutputBody: Swift.Equatable {
    let sourceServerID: Swift.String?
    let arn: Swift.String?
    let tags: [Swift.String:Swift.String]?
    let recoveryInstanceId: Swift.String?
    let lastLaunchResult: DrsClientTypes.LastLaunchResult?
    let dataReplicationInfo: DrsClientTypes.DataReplicationInfo?
    let lifeCycle: DrsClientTypes.LifeCycle?
    let sourceProperties: DrsClientTypes.SourceProperties?
    let stagingArea: DrsClientTypes.StagingArea?
    let sourceCloudProperties: DrsClientTypes.SourceCloudProperties?
    let replicationDirection: DrsClientTypes.ReplicationDirection?
    let reversedDirectionSourceServerArn: Swift.String?
    let sourceNetworkID: Swift.String?
}

extension RetryDataReplicationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case dataReplicationInfo
        case lastLaunchResult
        case lifeCycle
        case recoveryInstanceId
        case replicationDirection
        case reversedDirectionSourceServerArn
        case sourceCloudProperties
        case sourceNetworkID
        case sourceProperties
        case sourceServerID
        case stagingArea
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceServerIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceServerID)
        sourceServerID = sourceServerIDDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let recoveryInstanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recoveryInstanceId)
        recoveryInstanceId = recoveryInstanceIdDecoded
        let lastLaunchResultDecoded = try containerValues.decodeIfPresent(DrsClientTypes.LastLaunchResult.self, forKey: .lastLaunchResult)
        lastLaunchResult = lastLaunchResultDecoded
        let dataReplicationInfoDecoded = try containerValues.decodeIfPresent(DrsClientTypes.DataReplicationInfo.self, forKey: .dataReplicationInfo)
        dataReplicationInfo = dataReplicationInfoDecoded
        let lifeCycleDecoded = try containerValues.decodeIfPresent(DrsClientTypes.LifeCycle.self, forKey: .lifeCycle)
        lifeCycle = lifeCycleDecoded
        let sourcePropertiesDecoded = try containerValues.decodeIfPresent(DrsClientTypes.SourceProperties.self, forKey: .sourceProperties)
        sourceProperties = sourcePropertiesDecoded
        let stagingAreaDecoded = try containerValues.decodeIfPresent(DrsClientTypes.StagingArea.self, forKey: .stagingArea)
        stagingArea = stagingAreaDecoded
        let sourceCloudPropertiesDecoded = try containerValues.decodeIfPresent(DrsClientTypes.SourceCloudProperties.self, forKey: .sourceCloudProperties)
        sourceCloudProperties = sourceCloudPropertiesDecoded
        let replicationDirectionDecoded = try containerValues.decodeIfPresent(DrsClientTypes.ReplicationDirection.self, forKey: .replicationDirection)
        replicationDirection = replicationDirectionDecoded
        let reversedDirectionSourceServerArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reversedDirectionSourceServerArn)
        reversedDirectionSourceServerArn = reversedDirectionSourceServerArnDecoded
        let sourceNetworkIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceNetworkID)
        sourceNetworkID = sourceNetworkIDDecoded
    }
}

enum RetryDataReplicationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UninitializedAccountException": return try await UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ReverseReplicationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case recoveryInstanceID
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let recoveryInstanceID = self.recoveryInstanceID {
            try encodeContainer.encode(recoveryInstanceID, forKey: .recoveryInstanceID)
        }
    }
}

extension ReverseReplicationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/ReverseReplication"
    }
}

public struct ReverseReplicationInput: Swift.Equatable {
    /// The ID of the Recovery Instance that we want to reverse the replication for.
    /// This member is required.
    public var recoveryInstanceID: Swift.String?

    public init(
        recoveryInstanceID: Swift.String? = nil
    )
    {
        self.recoveryInstanceID = recoveryInstanceID
    }
}

struct ReverseReplicationInputBody: Swift.Equatable {
    let recoveryInstanceID: Swift.String?
}

extension ReverseReplicationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case recoveryInstanceID
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recoveryInstanceIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recoveryInstanceID)
        recoveryInstanceID = recoveryInstanceIDDecoded
    }
}

extension ReverseReplicationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ReverseReplicationOutputBody = try responseDecoder.decode(responseBody: data)
            self.reversedDirectionSourceServerArn = output.reversedDirectionSourceServerArn
        } else {
            self.reversedDirectionSourceServerArn = nil
        }
    }
}

public struct ReverseReplicationOutput: Swift.Equatable {
    /// ARN of created SourceServer.
    public var reversedDirectionSourceServerArn: Swift.String?

    public init(
        reversedDirectionSourceServerArn: Swift.String? = nil
    )
    {
        self.reversedDirectionSourceServerArn = reversedDirectionSourceServerArn
    }
}

struct ReverseReplicationOutputBody: Swift.Equatable {
    let reversedDirectionSourceServerArn: Swift.String?
}

extension ReverseReplicationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case reversedDirectionSourceServerArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let reversedDirectionSourceServerArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reversedDirectionSourceServerArn)
        reversedDirectionSourceServerArn = reversedDirectionSourceServerArnDecoded
    }
}

enum ReverseReplicationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UninitializedAccountException": return try await UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ServiceQuotaExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.code = output.code
            self.properties.message = output.message
            self.properties.quotaCode = output.quotaCode
            self.properties.resourceId = output.resourceId
            self.properties.resourceType = output.resourceType
            self.properties.serviceCode = output.serviceCode
        } else {
            self.properties.code = nil
            self.properties.message = nil
            self.properties.quotaCode = nil
            self.properties.resourceId = nil
            self.properties.resourceType = nil
            self.properties.serviceCode = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request could not be completed because its exceeded the service quota.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var code: Swift.String? = nil
        public internal(set) var message: Swift.String? = nil
        /// Quota code.
        public internal(set) var quotaCode: Swift.String? = nil
        /// The ID of the resource.
        public internal(set) var resourceId: Swift.String? = nil
        /// The type of the resource.
        public internal(set) var resourceType: Swift.String? = nil
        /// Service code.
        public internal(set) var serviceCode: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        message: Swift.String? = nil,
        quotaCode: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil,
        serviceCode: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
        self.properties.quotaCode = quotaCode
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
        self.properties.serviceCode = serviceCode
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let code: Swift.String?
    let resourceId: Swift.String?
    let resourceType: Swift.String?
    let serviceCode: Swift.String?
    let quotaCode: Swift.String?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code
        case message
        case quotaCode
        case resourceId
        case resourceType
        case serviceCode
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let serviceCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
        let quotaCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .quotaCode)
        quotaCode = quotaCodeDecoded
    }
}

extension DrsClientTypes.SourceCloudProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case originAccountID
        case originAvailabilityZone
        case originRegion
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let originAccountID = self.originAccountID {
            try encodeContainer.encode(originAccountID, forKey: .originAccountID)
        }
        if let originAvailabilityZone = self.originAvailabilityZone {
            try encodeContainer.encode(originAvailabilityZone, forKey: .originAvailabilityZone)
        }
        if let originRegion = self.originRegion {
            try encodeContainer.encode(originRegion, forKey: .originRegion)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let originAccountIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .originAccountID)
        originAccountID = originAccountIDDecoded
        let originRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .originRegion)
        originRegion = originRegionDecoded
        let originAvailabilityZoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .originAvailabilityZone)
        originAvailabilityZone = originAvailabilityZoneDecoded
    }
}

extension DrsClientTypes {
    /// Properties of the cloud environment where this Source Server originated from.
    public struct SourceCloudProperties: Swift.Equatable {
        /// AWS Account ID for an EC2-originated Source Server.
        public var originAccountID: Swift.String?
        /// AWS Availability Zone for an EC2-originated Source Server.
        public var originAvailabilityZone: Swift.String?
        /// AWS Region for an EC2-originated Source Server.
        public var originRegion: Swift.String?

        public init(
            originAccountID: Swift.String? = nil,
            originAvailabilityZone: Swift.String? = nil,
            originRegion: Swift.String? = nil
        )
        {
            self.originAccountID = originAccountID
            self.originAvailabilityZone = originAvailabilityZone
            self.originRegion = originRegion
        }
    }

}

extension DrsClientTypes.SourceNetwork: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case cfnStackName
        case lastRecovery
        case launchedVpcID
        case replicationStatus
        case replicationStatusDetails
        case sourceAccountID
        case sourceNetworkID
        case sourceRegion
        case sourceVpcID
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let cfnStackName = self.cfnStackName {
            try encodeContainer.encode(cfnStackName, forKey: .cfnStackName)
        }
        if let lastRecovery = self.lastRecovery {
            try encodeContainer.encode(lastRecovery, forKey: .lastRecovery)
        }
        if let launchedVpcID = self.launchedVpcID {
            try encodeContainer.encode(launchedVpcID, forKey: .launchedVpcID)
        }
        if let replicationStatus = self.replicationStatus {
            try encodeContainer.encode(replicationStatus.rawValue, forKey: .replicationStatus)
        }
        if let replicationStatusDetails = self.replicationStatusDetails {
            try encodeContainer.encode(replicationStatusDetails, forKey: .replicationStatusDetails)
        }
        if let sourceAccountID = self.sourceAccountID {
            try encodeContainer.encode(sourceAccountID, forKey: .sourceAccountID)
        }
        if let sourceNetworkID = self.sourceNetworkID {
            try encodeContainer.encode(sourceNetworkID, forKey: .sourceNetworkID)
        }
        if let sourceRegion = self.sourceRegion {
            try encodeContainer.encode(sourceRegion, forKey: .sourceRegion)
        }
        if let sourceVpcID = self.sourceVpcID {
            try encodeContainer.encode(sourceVpcID, forKey: .sourceVpcID)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagsMap0) in tags {
                try tagsContainer.encode(tagsMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceNetworkIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceNetworkID)
        sourceNetworkID = sourceNetworkIDDecoded
        let sourceVpcIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceVpcID)
        sourceVpcID = sourceVpcIDDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let replicationStatusDecoded = try containerValues.decodeIfPresent(DrsClientTypes.ReplicationStatus.self, forKey: .replicationStatus)
        replicationStatus = replicationStatusDecoded
        let replicationStatusDetailsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationStatusDetails)
        replicationStatusDetails = replicationStatusDetailsDecoded
        let cfnStackNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cfnStackName)
        cfnStackName = cfnStackNameDecoded
        let sourceRegionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceRegion)
        sourceRegion = sourceRegionDecoded
        let sourceAccountIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceAccountID)
        sourceAccountID = sourceAccountIDDecoded
        let lastRecoveryDecoded = try containerValues.decodeIfPresent(DrsClientTypes.RecoveryLifeCycle.self, forKey: .lastRecovery)
        lastRecovery = lastRecoveryDecoded
        let launchedVpcIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .launchedVpcID)
        launchedVpcID = launchedVpcIDDecoded
    }
}

extension DrsClientTypes.SourceNetwork: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SourceNetwork(arn: \(Swift.String(describing: arn)), lastRecovery: \(Swift.String(describing: lastRecovery)), launchedVpcID: \(Swift.String(describing: launchedVpcID)), replicationStatus: \(Swift.String(describing: replicationStatus)), sourceAccountID: \(Swift.String(describing: sourceAccountID)), sourceNetworkID: \(Swift.String(describing: sourceNetworkID)), sourceRegion: \(Swift.String(describing: sourceRegion)), sourceVpcID: \(Swift.String(describing: sourceVpcID)), cfnStackName: \"CONTENT_REDACTED\", replicationStatusDetails: \"CONTENT_REDACTED\", tags: \"CONTENT_REDACTED\")"}
}

extension DrsClientTypes {
    /// The ARN of the Source Network.
    public struct SourceNetwork: Swift.Equatable {
        /// The ARN of the Source Network.
        public var arn: Swift.String?
        /// CloudFormation stack name that was deployed for recovering the Source Network.
        public var cfnStackName: Swift.String?
        /// An object containing information regarding the last recovery of the Source Network.
        public var lastRecovery: DrsClientTypes.RecoveryLifeCycle?
        /// ID of the recovered VPC following Source Network recovery.
        public var launchedVpcID: Swift.String?
        /// Status of Source Network Replication. Possible values: (a) STOPPED - Source Network is not replicating. (b) IN_PROGRESS - Source Network is being replicated. (c) PROTECTED - Source Network was replicated successfully and is being synchronized for changes. (d) ERROR - Source Network replication has failed
        public var replicationStatus: DrsClientTypes.ReplicationStatus?
        /// Error details in case Source Network replication status is ERROR.
        public var replicationStatusDetails: Swift.String?
        /// Account ID containing the VPC protected by the Source Network.
        public var sourceAccountID: Swift.String?
        /// Source Network ID.
        public var sourceNetworkID: Swift.String?
        /// Region containing the VPC protected by the Source Network.
        public var sourceRegion: Swift.String?
        /// VPC ID protected by the Source Network.
        public var sourceVpcID: Swift.String?
        /// A list of tags associated with the Source Network.
        public var tags: [Swift.String:Swift.String]?

        public init(
            arn: Swift.String? = nil,
            cfnStackName: Swift.String? = nil,
            lastRecovery: DrsClientTypes.RecoveryLifeCycle? = nil,
            launchedVpcID: Swift.String? = nil,
            replicationStatus: DrsClientTypes.ReplicationStatus? = nil,
            replicationStatusDetails: Swift.String? = nil,
            sourceAccountID: Swift.String? = nil,
            sourceNetworkID: Swift.String? = nil,
            sourceRegion: Swift.String? = nil,
            sourceVpcID: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.arn = arn
            self.cfnStackName = cfnStackName
            self.lastRecovery = lastRecovery
            self.launchedVpcID = launchedVpcID
            self.replicationStatus = replicationStatus
            self.replicationStatusDetails = replicationStatusDetails
            self.sourceAccountID = sourceAccountID
            self.sourceNetworkID = sourceNetworkID
            self.sourceRegion = sourceRegion
            self.sourceVpcID = sourceVpcID
            self.tags = tags
        }
    }

}

extension DrsClientTypes.SourceNetworkData: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sourceNetworkID
        case sourceVpc
        case stackName
        case targetVpc
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sourceNetworkID = self.sourceNetworkID {
            try encodeContainer.encode(sourceNetworkID, forKey: .sourceNetworkID)
        }
        if let sourceVpc = self.sourceVpc {
            try encodeContainer.encode(sourceVpc, forKey: .sourceVpc)
        }
        if let stackName = self.stackName {
            try encodeContainer.encode(stackName, forKey: .stackName)
        }
        if let targetVpc = self.targetVpc {
            try encodeContainer.encode(targetVpc, forKey: .targetVpc)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceNetworkIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceNetworkID)
        sourceNetworkID = sourceNetworkIDDecoded
        let sourceVpcDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceVpc)
        sourceVpc = sourceVpcDecoded
        let targetVpcDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .targetVpc)
        targetVpc = targetVpcDecoded
        let stackNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stackName)
        stackName = stackNameDecoded
    }
}

extension DrsClientTypes {
    /// Properties of Source Network related to a job event.
    public struct SourceNetworkData: Swift.Equatable {
        /// Source Network ID.
        public var sourceNetworkID: Swift.String?
        /// VPC ID protected by the Source Network.
        public var sourceVpc: Swift.String?
        /// CloudFormation stack name that was deployed for recovering the Source Network.
        public var stackName: Swift.String?
        /// ID of the recovered VPC following Source Network recovery.
        public var targetVpc: Swift.String?

        public init(
            sourceNetworkID: Swift.String? = nil,
            sourceVpc: Swift.String? = nil,
            stackName: Swift.String? = nil,
            targetVpc: Swift.String? = nil
        )
        {
            self.sourceNetworkID = sourceNetworkID
            self.sourceVpc = sourceVpc
            self.stackName = stackName
            self.targetVpc = targetVpc
        }
    }

}

extension DrsClientTypes.SourceProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cpus
        case disks
        case identificationHints
        case lastUpdatedDateTime
        case networkInterfaces
        case os
        case ramBytes
        case recommendedInstanceType
        case supportsNitroInstances
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cpus = cpus {
            var cpusContainer = encodeContainer.nestedUnkeyedContainer(forKey: .cpus)
            for cpu0 in cpus {
                try cpusContainer.encode(cpu0)
            }
        }
        if let disks = disks {
            var disksContainer = encodeContainer.nestedUnkeyedContainer(forKey: .disks)
            for disk0 in disks {
                try disksContainer.encode(disk0)
            }
        }
        if let identificationHints = self.identificationHints {
            try encodeContainer.encode(identificationHints, forKey: .identificationHints)
        }
        if let lastUpdatedDateTime = self.lastUpdatedDateTime {
            try encodeContainer.encode(lastUpdatedDateTime, forKey: .lastUpdatedDateTime)
        }
        if let networkInterfaces = networkInterfaces {
            var networkInterfacesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .networkInterfaces)
            for networkinterface0 in networkInterfaces {
                try networkInterfacesContainer.encode(networkinterface0)
            }
        }
        if let os = self.os {
            try encodeContainer.encode(os, forKey: .os)
        }
        if ramBytes != 0 {
            try encodeContainer.encode(ramBytes, forKey: .ramBytes)
        }
        if let recommendedInstanceType = self.recommendedInstanceType {
            try encodeContainer.encode(recommendedInstanceType, forKey: .recommendedInstanceType)
        }
        if let supportsNitroInstances = self.supportsNitroInstances {
            try encodeContainer.encode(supportsNitroInstances, forKey: .supportsNitroInstances)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lastUpdatedDateTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastUpdatedDateTime)
        lastUpdatedDateTime = lastUpdatedDateTimeDecoded
        let recommendedInstanceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recommendedInstanceType)
        recommendedInstanceType = recommendedInstanceTypeDecoded
        let identificationHintsDecoded = try containerValues.decodeIfPresent(DrsClientTypes.IdentificationHints.self, forKey: .identificationHints)
        identificationHints = identificationHintsDecoded
        let networkInterfacesContainer = try containerValues.decodeIfPresent([DrsClientTypes.NetworkInterface?].self, forKey: .networkInterfaces)
        var networkInterfacesDecoded0:[DrsClientTypes.NetworkInterface]? = nil
        if let networkInterfacesContainer = networkInterfacesContainer {
            networkInterfacesDecoded0 = [DrsClientTypes.NetworkInterface]()
            for structure0 in networkInterfacesContainer {
                if let structure0 = structure0 {
                    networkInterfacesDecoded0?.append(structure0)
                }
            }
        }
        networkInterfaces = networkInterfacesDecoded0
        let disksContainer = try containerValues.decodeIfPresent([DrsClientTypes.Disk?].self, forKey: .disks)
        var disksDecoded0:[DrsClientTypes.Disk]? = nil
        if let disksContainer = disksContainer {
            disksDecoded0 = [DrsClientTypes.Disk]()
            for structure0 in disksContainer {
                if let structure0 = structure0 {
                    disksDecoded0?.append(structure0)
                }
            }
        }
        disks = disksDecoded0
        let cpusContainer = try containerValues.decodeIfPresent([DrsClientTypes.CPU?].self, forKey: .cpus)
        var cpusDecoded0:[DrsClientTypes.CPU]? = nil
        if let cpusContainer = cpusContainer {
            cpusDecoded0 = [DrsClientTypes.CPU]()
            for structure0 in cpusContainer {
                if let structure0 = structure0 {
                    cpusDecoded0?.append(structure0)
                }
            }
        }
        cpus = cpusDecoded0
        let ramBytesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .ramBytes) ?? 0
        ramBytes = ramBytesDecoded
        let osDecoded = try containerValues.decodeIfPresent(DrsClientTypes.OS.self, forKey: .os)
        os = osDecoded
        let supportsNitroInstancesDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .supportsNitroInstances)
        supportsNitroInstances = supportsNitroInstancesDecoded
    }
}

extension DrsClientTypes {
    /// Properties of the Source Server machine.
    public struct SourceProperties: Swift.Equatable {
        /// An array of CPUs.
        public var cpus: [DrsClientTypes.CPU]?
        /// An array of disks.
        public var disks: [DrsClientTypes.Disk]?
        /// Hints used to uniquely identify a machine.
        public var identificationHints: DrsClientTypes.IdentificationHints?
        /// The date and time the Source Properties were last updated on.
        public var lastUpdatedDateTime: Swift.String?
        /// An array of network interfaces.
        public var networkInterfaces: [DrsClientTypes.NetworkInterface]?
        /// Operating system.
        public var os: DrsClientTypes.OS?
        /// The amount of RAM in bytes.
        public var ramBytes: Swift.Int
        /// The recommended EC2 instance type that will be used when recovering the Source Server.
        public var recommendedInstanceType: Swift.String?
        /// Are EC2 nitro instance types supported when recovering the Source Server.
        public var supportsNitroInstances: Swift.Bool?

        public init(
            cpus: [DrsClientTypes.CPU]? = nil,
            disks: [DrsClientTypes.Disk]? = nil,
            identificationHints: DrsClientTypes.IdentificationHints? = nil,
            lastUpdatedDateTime: Swift.String? = nil,
            networkInterfaces: [DrsClientTypes.NetworkInterface]? = nil,
            os: DrsClientTypes.OS? = nil,
            ramBytes: Swift.Int = 0,
            recommendedInstanceType: Swift.String? = nil,
            supportsNitroInstances: Swift.Bool? = nil
        )
        {
            self.cpus = cpus
            self.disks = disks
            self.identificationHints = identificationHints
            self.lastUpdatedDateTime = lastUpdatedDateTime
            self.networkInterfaces = networkInterfaces
            self.os = os
            self.ramBytes = ramBytes
            self.recommendedInstanceType = recommendedInstanceType
            self.supportsNitroInstances = supportsNitroInstances
        }
    }

}

extension DrsClientTypes.SourceServer: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case dataReplicationInfo
        case lastLaunchResult
        case lifeCycle
        case recoveryInstanceId
        case replicationDirection
        case reversedDirectionSourceServerArn
        case sourceCloudProperties
        case sourceNetworkID
        case sourceProperties
        case sourceServerID
        case stagingArea
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let dataReplicationInfo = self.dataReplicationInfo {
            try encodeContainer.encode(dataReplicationInfo, forKey: .dataReplicationInfo)
        }
        if let lastLaunchResult = self.lastLaunchResult {
            try encodeContainer.encode(lastLaunchResult.rawValue, forKey: .lastLaunchResult)
        }
        if let lifeCycle = self.lifeCycle {
            try encodeContainer.encode(lifeCycle, forKey: .lifeCycle)
        }
        if let recoveryInstanceId = self.recoveryInstanceId {
            try encodeContainer.encode(recoveryInstanceId, forKey: .recoveryInstanceId)
        }
        if let replicationDirection = self.replicationDirection {
            try encodeContainer.encode(replicationDirection.rawValue, forKey: .replicationDirection)
        }
        if let reversedDirectionSourceServerArn = self.reversedDirectionSourceServerArn {
            try encodeContainer.encode(reversedDirectionSourceServerArn, forKey: .reversedDirectionSourceServerArn)
        }
        if let sourceCloudProperties = self.sourceCloudProperties {
            try encodeContainer.encode(sourceCloudProperties, forKey: .sourceCloudProperties)
        }
        if let sourceNetworkID = self.sourceNetworkID {
            try encodeContainer.encode(sourceNetworkID, forKey: .sourceNetworkID)
        }
        if let sourceProperties = self.sourceProperties {
            try encodeContainer.encode(sourceProperties, forKey: .sourceProperties)
        }
        if let sourceServerID = self.sourceServerID {
            try encodeContainer.encode(sourceServerID, forKey: .sourceServerID)
        }
        if let stagingArea = self.stagingArea {
            try encodeContainer.encode(stagingArea, forKey: .stagingArea)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagsMap0) in tags {
                try tagsContainer.encode(tagsMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceServerIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceServerID)
        sourceServerID = sourceServerIDDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let recoveryInstanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recoveryInstanceId)
        recoveryInstanceId = recoveryInstanceIdDecoded
        let lastLaunchResultDecoded = try containerValues.decodeIfPresent(DrsClientTypes.LastLaunchResult.self, forKey: .lastLaunchResult)
        lastLaunchResult = lastLaunchResultDecoded
        let dataReplicationInfoDecoded = try containerValues.decodeIfPresent(DrsClientTypes.DataReplicationInfo.self, forKey: .dataReplicationInfo)
        dataReplicationInfo = dataReplicationInfoDecoded
        let lifeCycleDecoded = try containerValues.decodeIfPresent(DrsClientTypes.LifeCycle.self, forKey: .lifeCycle)
        lifeCycle = lifeCycleDecoded
        let sourcePropertiesDecoded = try containerValues.decodeIfPresent(DrsClientTypes.SourceProperties.self, forKey: .sourceProperties)
        sourceProperties = sourcePropertiesDecoded
        let stagingAreaDecoded = try containerValues.decodeIfPresent(DrsClientTypes.StagingArea.self, forKey: .stagingArea)
        stagingArea = stagingAreaDecoded
        let sourceCloudPropertiesDecoded = try containerValues.decodeIfPresent(DrsClientTypes.SourceCloudProperties.self, forKey: .sourceCloudProperties)
        sourceCloudProperties = sourceCloudPropertiesDecoded
        let replicationDirectionDecoded = try containerValues.decodeIfPresent(DrsClientTypes.ReplicationDirection.self, forKey: .replicationDirection)
        replicationDirection = replicationDirectionDecoded
        let reversedDirectionSourceServerArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reversedDirectionSourceServerArn)
        reversedDirectionSourceServerArn = reversedDirectionSourceServerArnDecoded
        let sourceNetworkIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceNetworkID)
        sourceNetworkID = sourceNetworkIDDecoded
    }
}

extension DrsClientTypes.SourceServer: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SourceServer(arn: \(Swift.String(describing: arn)), dataReplicationInfo: \(Swift.String(describing: dataReplicationInfo)), lastLaunchResult: \(Swift.String(describing: lastLaunchResult)), lifeCycle: \(Swift.String(describing: lifeCycle)), recoveryInstanceId: \(Swift.String(describing: recoveryInstanceId)), replicationDirection: \(Swift.String(describing: replicationDirection)), reversedDirectionSourceServerArn: \(Swift.String(describing: reversedDirectionSourceServerArn)), sourceCloudProperties: \(Swift.String(describing: sourceCloudProperties)), sourceNetworkID: \(Swift.String(describing: sourceNetworkID)), sourceProperties: \(Swift.String(describing: sourceProperties)), sourceServerID: \(Swift.String(describing: sourceServerID)), stagingArea: \(Swift.String(describing: stagingArea)), tags: \"CONTENT_REDACTED\")"}
}

extension DrsClientTypes {
    public struct SourceServer: Swift.Equatable {
        /// The ARN of the Source Server.
        public var arn: Swift.String?
        /// The Data Replication Info of the Source Server.
        public var dataReplicationInfo: DrsClientTypes.DataReplicationInfo?
        /// The status of the last recovery launch of this Source Server.
        public var lastLaunchResult: DrsClientTypes.LastLaunchResult?
        /// The lifecycle information of this Source Server.
        public var lifeCycle: DrsClientTypes.LifeCycle?
        /// The ID of the Recovery Instance associated with this Source Server.
        public var recoveryInstanceId: Swift.String?
        /// Replication direction of the Source Server.
        public var replicationDirection: DrsClientTypes.ReplicationDirection?
        /// For EC2-originated Source Servers which have been failed over and then failed back, this value will mean the ARN of the Source Server on the opposite replication direction.
        public var reversedDirectionSourceServerArn: Swift.String?
        /// Source cloud properties of the Source Server.
        public var sourceCloudProperties: DrsClientTypes.SourceCloudProperties?
        /// ID of the Source Network which is protecting this Source Server's network.
        public var sourceNetworkID: Swift.String?
        /// The source properties of the Source Server.
        public var sourceProperties: DrsClientTypes.SourceProperties?
        /// The ID of the Source Server.
        public var sourceServerID: Swift.String?
        /// The staging area of the source server.
        public var stagingArea: DrsClientTypes.StagingArea?
        /// The tags associated with the Source Server.
        public var tags: [Swift.String:Swift.String]?

        public init(
            arn: Swift.String? = nil,
            dataReplicationInfo: DrsClientTypes.DataReplicationInfo? = nil,
            lastLaunchResult: DrsClientTypes.LastLaunchResult? = nil,
            lifeCycle: DrsClientTypes.LifeCycle? = nil,
            recoveryInstanceId: Swift.String? = nil,
            replicationDirection: DrsClientTypes.ReplicationDirection? = nil,
            reversedDirectionSourceServerArn: Swift.String? = nil,
            sourceCloudProperties: DrsClientTypes.SourceCloudProperties? = nil,
            sourceNetworkID: Swift.String? = nil,
            sourceProperties: DrsClientTypes.SourceProperties? = nil,
            sourceServerID: Swift.String? = nil,
            stagingArea: DrsClientTypes.StagingArea? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.arn = arn
            self.dataReplicationInfo = dataReplicationInfo
            self.lastLaunchResult = lastLaunchResult
            self.lifeCycle = lifeCycle
            self.recoveryInstanceId = recoveryInstanceId
            self.replicationDirection = replicationDirection
            self.reversedDirectionSourceServerArn = reversedDirectionSourceServerArn
            self.sourceCloudProperties = sourceCloudProperties
            self.sourceNetworkID = sourceNetworkID
            self.sourceProperties = sourceProperties
            self.sourceServerID = sourceServerID
            self.stagingArea = stagingArea
            self.tags = tags
        }
    }

}

extension DrsClientTypes.StagingArea: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorMessage
        case stagingAccountID
        case stagingSourceServerArn
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorMessage = self.errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let stagingAccountID = self.stagingAccountID {
            try encodeContainer.encode(stagingAccountID, forKey: .stagingAccountID)
        }
        if let stagingSourceServerArn = self.stagingSourceServerArn {
            try encodeContainer.encode(stagingSourceServerArn, forKey: .stagingSourceServerArn)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(DrsClientTypes.ExtensionStatus.self, forKey: .status)
        status = statusDecoded
        let stagingAccountIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stagingAccountID)
        stagingAccountID = stagingAccountIDDecoded
        let stagingSourceServerArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stagingSourceServerArn)
        stagingSourceServerArn = stagingSourceServerArnDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension DrsClientTypes {
    /// Staging information related to source server.
    public struct StagingArea: Swift.Equatable {
        /// Shows an error message that occurred when DRS tried to access the staging source server. In this case StagingArea$status will have value EXTENSION_ERROR
        public var errorMessage: Swift.String?
        /// Account ID of the account to which source server belongs. If this source server is extended - shows Account ID of staging source server.
        public var stagingAccountID: Swift.String?
        /// Arn of the staging source server if this source server is extended
        public var stagingSourceServerArn: Swift.String?
        /// Status of Source server extension. Possible values: (a) NOT_EXTENDED - This is a source server that is replicating in the current account. (b) EXTENDED - Source server is extended from a staging source server. In this case, the value of stagingSourceServerArn is pointing to the Arn of the source server in the staging account. (c) EXTENSION_ERROR - Some issue occurred when accessing staging source server. In this case, errorMessage field will contain an error message that explains what happened.
        public var status: DrsClientTypes.ExtensionStatus?

        public init(
            errorMessage: Swift.String? = nil,
            stagingAccountID: Swift.String? = nil,
            stagingSourceServerArn: Swift.String? = nil,
            status: DrsClientTypes.ExtensionStatus? = nil
        )
        {
            self.errorMessage = errorMessage
            self.stagingAccountID = stagingAccountID
            self.stagingSourceServerArn = stagingSourceServerArn
            self.status = status
        }
    }

}

extension DrsClientTypes.StagingSourceServer: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case hostname
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let hostname = self.hostname {
            try encodeContainer.encode(hostname, forKey: .hostname)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagsMap0) in tags {
                try tagsContainer.encode(tagsMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let hostnameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hostname)
        hostname = hostnameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension DrsClientTypes.StagingSourceServer: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StagingSourceServer(arn: \(Swift.String(describing: arn)), hostname: \(Swift.String(describing: hostname)), tags: \"CONTENT_REDACTED\")"}
}

extension DrsClientTypes {
    /// Source server in staging account that extended source server connected to.
    public struct StagingSourceServer: Swift.Equatable {
        /// The ARN of the source server.
        public var arn: Swift.String?
        /// Hostname of staging source server.
        public var hostname: Swift.String?
        /// A list of tags associated with the staging source server.
        public var tags: [Swift.String:Swift.String]?

        public init(
            arn: Swift.String? = nil,
            hostname: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.arn = arn
            self.hostname = hostname
            self.tags = tags
        }
    }

}

extension StartFailbackLaunchInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartFailbackLaunchInput(recoveryInstanceIDs: \(Swift.String(describing: recoveryInstanceIDs)), tags: \"CONTENT_REDACTED\")"}
}

extension StartFailbackLaunchInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case recoveryInstanceIDs
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let recoveryInstanceIDs = recoveryInstanceIDs {
            var recoveryInstanceIDsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .recoveryInstanceIDs)
            for recoveryinstanceid0 in recoveryInstanceIDs {
                try recoveryInstanceIDsContainer.encode(recoveryinstanceid0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagsMap0) in tags {
                try tagsContainer.encode(tagsMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension StartFailbackLaunchInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/StartFailbackLaunch"
    }
}

public struct StartFailbackLaunchInput: Swift.Equatable {
    /// The IDs of the Recovery Instance whose failback launch we want to request.
    /// This member is required.
    public var recoveryInstanceIDs: [Swift.String]?
    /// The tags to be associated with the failback launch Job.
    public var tags: [Swift.String:Swift.String]?

    public init(
        recoveryInstanceIDs: [Swift.String]? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.recoveryInstanceIDs = recoveryInstanceIDs
        self.tags = tags
    }
}

struct StartFailbackLaunchInputBody: Swift.Equatable {
    let recoveryInstanceIDs: [Swift.String]?
    let tags: [Swift.String:Swift.String]?
}

extension StartFailbackLaunchInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case recoveryInstanceIDs
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recoveryInstanceIDsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .recoveryInstanceIDs)
        var recoveryInstanceIDsDecoded0:[Swift.String]? = nil
        if let recoveryInstanceIDsContainer = recoveryInstanceIDsContainer {
            recoveryInstanceIDsDecoded0 = [Swift.String]()
            for string0 in recoveryInstanceIDsContainer {
                if let string0 = string0 {
                    recoveryInstanceIDsDecoded0?.append(string0)
                }
            }
        }
        recoveryInstanceIDs = recoveryInstanceIDsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension StartFailbackLaunchOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StartFailbackLaunchOutputBody = try responseDecoder.decode(responseBody: data)
            self.job = output.job
        } else {
            self.job = nil
        }
    }
}

public struct StartFailbackLaunchOutput: Swift.Equatable {
    /// The failback launch Job.
    public var job: DrsClientTypes.Job?

    public init(
        job: DrsClientTypes.Job? = nil
    )
    {
        self.job = job
    }
}

struct StartFailbackLaunchOutputBody: Swift.Equatable {
    let job: DrsClientTypes.Job?
}

extension StartFailbackLaunchOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case job
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobDecoded = try containerValues.decodeIfPresent(DrsClientTypes.Job.self, forKey: .job)
        job = jobDecoded
    }
}

enum StartFailbackLaunchOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UninitializedAccountException": return try await UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension StartRecoveryInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartRecoveryInput(isDrill: \(Swift.String(describing: isDrill)), sourceServers: \(Swift.String(describing: sourceServers)), tags: \"CONTENT_REDACTED\")"}
}

extension StartRecoveryInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case isDrill
        case sourceServers
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let isDrill = self.isDrill {
            try encodeContainer.encode(isDrill, forKey: .isDrill)
        }
        if let sourceServers = sourceServers {
            var sourceServersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sourceServers)
            for startrecoveryrequestsourceserver0 in sourceServers {
                try sourceServersContainer.encode(startrecoveryrequestsourceserver0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagsMap0) in tags {
                try tagsContainer.encode(tagsMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension StartRecoveryInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/StartRecovery"
    }
}

public struct StartRecoveryInput: Swift.Equatable {
    /// Whether this Source Server Recovery operation is a drill or not.
    public var isDrill: Swift.Bool?
    /// The Source Servers that we want to start a Recovery Job for.
    /// This member is required.
    public var sourceServers: [DrsClientTypes.StartRecoveryRequestSourceServer]?
    /// The tags to be associated with the Recovery Job.
    public var tags: [Swift.String:Swift.String]?

    public init(
        isDrill: Swift.Bool? = nil,
        sourceServers: [DrsClientTypes.StartRecoveryRequestSourceServer]? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.isDrill = isDrill
        self.sourceServers = sourceServers
        self.tags = tags
    }
}

struct StartRecoveryInputBody: Swift.Equatable {
    let sourceServers: [DrsClientTypes.StartRecoveryRequestSourceServer]?
    let isDrill: Swift.Bool?
    let tags: [Swift.String:Swift.String]?
}

extension StartRecoveryInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case isDrill
        case sourceServers
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceServersContainer = try containerValues.decodeIfPresent([DrsClientTypes.StartRecoveryRequestSourceServer?].self, forKey: .sourceServers)
        var sourceServersDecoded0:[DrsClientTypes.StartRecoveryRequestSourceServer]? = nil
        if let sourceServersContainer = sourceServersContainer {
            sourceServersDecoded0 = [DrsClientTypes.StartRecoveryRequestSourceServer]()
            for structure0 in sourceServersContainer {
                if let structure0 = structure0 {
                    sourceServersDecoded0?.append(structure0)
                }
            }
        }
        sourceServers = sourceServersDecoded0
        let isDrillDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .isDrill)
        isDrill = isDrillDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension StartRecoveryOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StartRecoveryOutputBody = try responseDecoder.decode(responseBody: data)
            self.job = output.job
        } else {
            self.job = nil
        }
    }
}

public struct StartRecoveryOutput: Swift.Equatable {
    /// The Recovery Job.
    public var job: DrsClientTypes.Job?

    public init(
        job: DrsClientTypes.Job? = nil
    )
    {
        self.job = job
    }
}

struct StartRecoveryOutputBody: Swift.Equatable {
    let job: DrsClientTypes.Job?
}

extension StartRecoveryOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case job
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobDecoded = try containerValues.decodeIfPresent(DrsClientTypes.Job.self, forKey: .job)
        job = jobDecoded
    }
}

enum StartRecoveryOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UninitializedAccountException": return try await UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DrsClientTypes.StartRecoveryRequestSourceServer: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case recoverySnapshotID
        case sourceServerID
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let recoverySnapshotID = self.recoverySnapshotID {
            try encodeContainer.encode(recoverySnapshotID, forKey: .recoverySnapshotID)
        }
        if let sourceServerID = self.sourceServerID {
            try encodeContainer.encode(sourceServerID, forKey: .sourceServerID)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceServerIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceServerID)
        sourceServerID = sourceServerIDDecoded
        let recoverySnapshotIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recoverySnapshotID)
        recoverySnapshotID = recoverySnapshotIDDecoded
    }
}

extension DrsClientTypes {
    /// An object representing the Source Server to recover.
    public struct StartRecoveryRequestSourceServer: Swift.Equatable {
        /// The ID of a Recovery Snapshot we want to recover from. Omit this field to launch from the latest data by taking an on-demand snapshot.
        public var recoverySnapshotID: Swift.String?
        /// The ID of the Source Server you want to recover.
        /// This member is required.
        public var sourceServerID: Swift.String?

        public init(
            recoverySnapshotID: Swift.String? = nil,
            sourceServerID: Swift.String? = nil
        )
        {
            self.recoverySnapshotID = recoverySnapshotID
            self.sourceServerID = sourceServerID
        }
    }

}

extension StartReplicationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sourceServerID
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sourceServerID = self.sourceServerID {
            try encodeContainer.encode(sourceServerID, forKey: .sourceServerID)
        }
    }
}

extension StartReplicationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/StartReplication"
    }
}

public struct StartReplicationInput: Swift.Equatable {
    /// The ID of the Source Server to start replication for.
    /// This member is required.
    public var sourceServerID: Swift.String?

    public init(
        sourceServerID: Swift.String? = nil
    )
    {
        self.sourceServerID = sourceServerID
    }
}

struct StartReplicationInputBody: Swift.Equatable {
    let sourceServerID: Swift.String?
}

extension StartReplicationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sourceServerID
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceServerIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceServerID)
        sourceServerID = sourceServerIDDecoded
    }
}

extension StartReplicationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StartReplicationOutputBody = try responseDecoder.decode(responseBody: data)
            self.sourceServer = output.sourceServer
        } else {
            self.sourceServer = nil
        }
    }
}

public struct StartReplicationOutput: Swift.Equatable {
    /// The Source Server that this action was targeted on.
    public var sourceServer: DrsClientTypes.SourceServer?

    public init(
        sourceServer: DrsClientTypes.SourceServer? = nil
    )
    {
        self.sourceServer = sourceServer
    }
}

struct StartReplicationOutputBody: Swift.Equatable {
    let sourceServer: DrsClientTypes.SourceServer?
}

extension StartReplicationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sourceServer
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceServerDecoded = try containerValues.decodeIfPresent(DrsClientTypes.SourceServer.self, forKey: .sourceServer)
        sourceServer = sourceServerDecoded
    }
}

enum StartReplicationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UninitializedAccountException": return try await UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension StartSourceNetworkRecoveryInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartSourceNetworkRecoveryInput(deployAsNew: \(Swift.String(describing: deployAsNew)), sourceNetworks: \(Swift.String(describing: sourceNetworks)), tags: \"CONTENT_REDACTED\")"}
}

extension StartSourceNetworkRecoveryInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deployAsNew
        case sourceNetworks
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deployAsNew = self.deployAsNew {
            try encodeContainer.encode(deployAsNew, forKey: .deployAsNew)
        }
        if let sourceNetworks = sourceNetworks {
            var sourceNetworksContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sourceNetworks)
            for startsourcenetworkrecoveryrequestnetworkentry0 in sourceNetworks {
                try sourceNetworksContainer.encode(startsourcenetworkrecoveryrequestnetworkentry0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagsMap0) in tags {
                try tagsContainer.encode(tagsMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension StartSourceNetworkRecoveryInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/StartSourceNetworkRecovery"
    }
}

public struct StartSourceNetworkRecoveryInput: Swift.Equatable {
    /// Don't update existing CloudFormation Stack, recover the network using a new stack.
    public var deployAsNew: Swift.Bool?
    /// The Source Networks that we want to start a Recovery Job for.
    /// This member is required.
    public var sourceNetworks: [DrsClientTypes.StartSourceNetworkRecoveryRequestNetworkEntry]?
    /// The tags to be associated with the Source Network recovery Job.
    public var tags: [Swift.String:Swift.String]?

    public init(
        deployAsNew: Swift.Bool? = nil,
        sourceNetworks: [DrsClientTypes.StartSourceNetworkRecoveryRequestNetworkEntry]? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.deployAsNew = deployAsNew
        self.sourceNetworks = sourceNetworks
        self.tags = tags
    }
}

struct StartSourceNetworkRecoveryInputBody: Swift.Equatable {
    let sourceNetworks: [DrsClientTypes.StartSourceNetworkRecoveryRequestNetworkEntry]?
    let deployAsNew: Swift.Bool?
    let tags: [Swift.String:Swift.String]?
}

extension StartSourceNetworkRecoveryInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deployAsNew
        case sourceNetworks
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceNetworksContainer = try containerValues.decodeIfPresent([DrsClientTypes.StartSourceNetworkRecoveryRequestNetworkEntry?].self, forKey: .sourceNetworks)
        var sourceNetworksDecoded0:[DrsClientTypes.StartSourceNetworkRecoveryRequestNetworkEntry]? = nil
        if let sourceNetworksContainer = sourceNetworksContainer {
            sourceNetworksDecoded0 = [DrsClientTypes.StartSourceNetworkRecoveryRequestNetworkEntry]()
            for structure0 in sourceNetworksContainer {
                if let structure0 = structure0 {
                    sourceNetworksDecoded0?.append(structure0)
                }
            }
        }
        sourceNetworks = sourceNetworksDecoded0
        let deployAsNewDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .deployAsNew)
        deployAsNew = deployAsNewDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension StartSourceNetworkRecoveryOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StartSourceNetworkRecoveryOutputBody = try responseDecoder.decode(responseBody: data)
            self.job = output.job
        } else {
            self.job = nil
        }
    }
}

public struct StartSourceNetworkRecoveryOutput: Swift.Equatable {
    /// The Source Network recovery Job.
    public var job: DrsClientTypes.Job?

    public init(
        job: DrsClientTypes.Job? = nil
    )
    {
        self.job = job
    }
}

struct StartSourceNetworkRecoveryOutputBody: Swift.Equatable {
    let job: DrsClientTypes.Job?
}

extension StartSourceNetworkRecoveryOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case job
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobDecoded = try containerValues.decodeIfPresent(DrsClientTypes.Job.self, forKey: .job)
        job = jobDecoded
    }
}

enum StartSourceNetworkRecoveryOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UninitializedAccountException": return try await UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DrsClientTypes.StartSourceNetworkRecoveryRequestNetworkEntry: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cfnStackName
        case sourceNetworkID
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cfnStackName = self.cfnStackName {
            try encodeContainer.encode(cfnStackName, forKey: .cfnStackName)
        }
        if let sourceNetworkID = self.sourceNetworkID {
            try encodeContainer.encode(sourceNetworkID, forKey: .sourceNetworkID)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceNetworkIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceNetworkID)
        sourceNetworkID = sourceNetworkIDDecoded
        let cfnStackNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cfnStackName)
        cfnStackName = cfnStackNameDecoded
    }
}

extension DrsClientTypes.StartSourceNetworkRecoveryRequestNetworkEntry: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "StartSourceNetworkRecoveryRequestNetworkEntry(sourceNetworkID: \(Swift.String(describing: sourceNetworkID)), cfnStackName: \"CONTENT_REDACTED\")"}
}

extension DrsClientTypes {
    /// An object representing the Source Network to recover.
    public struct StartSourceNetworkRecoveryRequestNetworkEntry: Swift.Equatable {
        /// CloudFormation stack name to be used for recovering the network.
        public var cfnStackName: Swift.String?
        /// The ID of the Source Network you want to recover.
        /// This member is required.
        public var sourceNetworkID: Swift.String?

        public init(
            cfnStackName: Swift.String? = nil,
            sourceNetworkID: Swift.String? = nil
        )
        {
            self.cfnStackName = cfnStackName
            self.sourceNetworkID = sourceNetworkID
        }
    }

}

extension StartSourceNetworkReplicationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sourceNetworkID
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sourceNetworkID = self.sourceNetworkID {
            try encodeContainer.encode(sourceNetworkID, forKey: .sourceNetworkID)
        }
    }
}

extension StartSourceNetworkReplicationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/StartSourceNetworkReplication"
    }
}

public struct StartSourceNetworkReplicationInput: Swift.Equatable {
    /// ID of the Source Network to replicate.
    /// This member is required.
    public var sourceNetworkID: Swift.String?

    public init(
        sourceNetworkID: Swift.String? = nil
    )
    {
        self.sourceNetworkID = sourceNetworkID
    }
}

struct StartSourceNetworkReplicationInputBody: Swift.Equatable {
    let sourceNetworkID: Swift.String?
}

extension StartSourceNetworkReplicationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sourceNetworkID
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceNetworkIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceNetworkID)
        sourceNetworkID = sourceNetworkIDDecoded
    }
}

extension StartSourceNetworkReplicationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StartSourceNetworkReplicationOutputBody = try responseDecoder.decode(responseBody: data)
            self.sourceNetwork = output.sourceNetwork
        } else {
            self.sourceNetwork = nil
        }
    }
}

public struct StartSourceNetworkReplicationOutput: Swift.Equatable {
    /// Source Network which was requested for replication.
    public var sourceNetwork: DrsClientTypes.SourceNetwork?

    public init(
        sourceNetwork: DrsClientTypes.SourceNetwork? = nil
    )
    {
        self.sourceNetwork = sourceNetwork
    }
}

struct StartSourceNetworkReplicationOutputBody: Swift.Equatable {
    let sourceNetwork: DrsClientTypes.SourceNetwork?
}

extension StartSourceNetworkReplicationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sourceNetwork
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceNetworkDecoded = try containerValues.decodeIfPresent(DrsClientTypes.SourceNetwork.self, forKey: .sourceNetwork)
        sourceNetwork = sourceNetworkDecoded
    }
}

enum StartSourceNetworkReplicationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UninitializedAccountException": return try await UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension StopFailbackInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case recoveryInstanceID
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let recoveryInstanceID = self.recoveryInstanceID {
            try encodeContainer.encode(recoveryInstanceID, forKey: .recoveryInstanceID)
        }
    }
}

extension StopFailbackInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/StopFailback"
    }
}

public struct StopFailbackInput: Swift.Equatable {
    /// The ID of the Recovery Instance we want to stop failback for.
    /// This member is required.
    public var recoveryInstanceID: Swift.String?

    public init(
        recoveryInstanceID: Swift.String? = nil
    )
    {
        self.recoveryInstanceID = recoveryInstanceID
    }
}

struct StopFailbackInputBody: Swift.Equatable {
    let recoveryInstanceID: Swift.String?
}

extension StopFailbackInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case recoveryInstanceID
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recoveryInstanceIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recoveryInstanceID)
        recoveryInstanceID = recoveryInstanceIDDecoded
    }
}

extension StopFailbackOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct StopFailbackOutput: Swift.Equatable {

    public init() { }
}

enum StopFailbackOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UninitializedAccountException": return try await UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension StopReplicationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sourceServerID
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sourceServerID = self.sourceServerID {
            try encodeContainer.encode(sourceServerID, forKey: .sourceServerID)
        }
    }
}

extension StopReplicationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/StopReplication"
    }
}

public struct StopReplicationInput: Swift.Equatable {
    /// The ID of the Source Server to stop replication for.
    /// This member is required.
    public var sourceServerID: Swift.String?

    public init(
        sourceServerID: Swift.String? = nil
    )
    {
        self.sourceServerID = sourceServerID
    }
}

struct StopReplicationInputBody: Swift.Equatable {
    let sourceServerID: Swift.String?
}

extension StopReplicationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sourceServerID
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceServerIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceServerID)
        sourceServerID = sourceServerIDDecoded
    }
}

extension StopReplicationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StopReplicationOutputBody = try responseDecoder.decode(responseBody: data)
            self.sourceServer = output.sourceServer
        } else {
            self.sourceServer = nil
        }
    }
}

public struct StopReplicationOutput: Swift.Equatable {
    /// The Source Server that this action was targeted on.
    public var sourceServer: DrsClientTypes.SourceServer?

    public init(
        sourceServer: DrsClientTypes.SourceServer? = nil
    )
    {
        self.sourceServer = sourceServer
    }
}

struct StopReplicationOutputBody: Swift.Equatable {
    let sourceServer: DrsClientTypes.SourceServer?
}

extension StopReplicationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sourceServer
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceServerDecoded = try containerValues.decodeIfPresent(DrsClientTypes.SourceServer.self, forKey: .sourceServer)
        sourceServer = sourceServerDecoded
    }
}

enum StopReplicationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UninitializedAccountException": return try await UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension StopSourceNetworkReplicationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sourceNetworkID
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sourceNetworkID = self.sourceNetworkID {
            try encodeContainer.encode(sourceNetworkID, forKey: .sourceNetworkID)
        }
    }
}

extension StopSourceNetworkReplicationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/StopSourceNetworkReplication"
    }
}

public struct StopSourceNetworkReplicationInput: Swift.Equatable {
    /// ID of the Source Network to stop replication.
    /// This member is required.
    public var sourceNetworkID: Swift.String?

    public init(
        sourceNetworkID: Swift.String? = nil
    )
    {
        self.sourceNetworkID = sourceNetworkID
    }
}

struct StopSourceNetworkReplicationInputBody: Swift.Equatable {
    let sourceNetworkID: Swift.String?
}

extension StopSourceNetworkReplicationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sourceNetworkID
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceNetworkIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceNetworkID)
        sourceNetworkID = sourceNetworkIDDecoded
    }
}

extension StopSourceNetworkReplicationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StopSourceNetworkReplicationOutputBody = try responseDecoder.decode(responseBody: data)
            self.sourceNetwork = output.sourceNetwork
        } else {
            self.sourceNetwork = nil
        }
    }
}

public struct StopSourceNetworkReplicationOutput: Swift.Equatable {
    /// Source Network which was requested to stop replication.
    public var sourceNetwork: DrsClientTypes.SourceNetwork?

    public init(
        sourceNetwork: DrsClientTypes.SourceNetwork? = nil
    )
    {
        self.sourceNetwork = sourceNetwork
    }
}

struct StopSourceNetworkReplicationOutputBody: Swift.Equatable {
    let sourceNetwork: DrsClientTypes.SourceNetwork?
}

extension StopSourceNetworkReplicationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sourceNetwork
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceNetworkDecoded = try containerValues.decodeIfPresent(DrsClientTypes.SourceNetwork.self, forKey: .sourceNetwork)
        sourceNetwork = sourceNetworkDecoded
    }
}

enum StopSourceNetworkReplicationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UninitializedAccountException": return try await UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension TagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceInput(resourceArn: \(Swift.String(describing: resourceArn)), tags: \"CONTENT_REDACTED\")"}
}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagsMap0) in tags {
                try tagsContainer.encode(tagsMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// ARN of the resource for which tags are to be added or updated.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// Array of tags to be added or updated.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct TagResourceOutput: Swift.Equatable {

    public init() { }
}

enum TagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DrsClientTypes {
    public enum TargetInstanceTypeRightSizingMethod: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case basic
        case inAws
        case `none`
        case sdkUnknown(Swift.String)

        public static var allCases: [TargetInstanceTypeRightSizingMethod] {
            return [
                .basic,
                .inAws,
                .none,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .basic: return "BASIC"
            case .inAws: return "IN_AWS"
            case .none: return "NONE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TargetInstanceTypeRightSizingMethod(rawValue: rawValue) ?? TargetInstanceTypeRightSizingMethod.sdkUnknown(rawValue)
        }
    }
}

extension TerminateRecoveryInstancesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case recoveryInstanceIDs
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let recoveryInstanceIDs = recoveryInstanceIDs {
            var recoveryInstanceIDsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .recoveryInstanceIDs)
            for recoveryinstanceid0 in recoveryInstanceIDs {
                try recoveryInstanceIDsContainer.encode(recoveryinstanceid0)
            }
        }
    }
}

extension TerminateRecoveryInstancesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/TerminateRecoveryInstances"
    }
}

public struct TerminateRecoveryInstancesInput: Swift.Equatable {
    /// The IDs of the Recovery Instances that should be terminated.
    /// This member is required.
    public var recoveryInstanceIDs: [Swift.String]?

    public init(
        recoveryInstanceIDs: [Swift.String]? = nil
    )
    {
        self.recoveryInstanceIDs = recoveryInstanceIDs
    }
}

struct TerminateRecoveryInstancesInputBody: Swift.Equatable {
    let recoveryInstanceIDs: [Swift.String]?
}

extension TerminateRecoveryInstancesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case recoveryInstanceIDs
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recoveryInstanceIDsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .recoveryInstanceIDs)
        var recoveryInstanceIDsDecoded0:[Swift.String]? = nil
        if let recoveryInstanceIDsContainer = recoveryInstanceIDsContainer {
            recoveryInstanceIDsDecoded0 = [Swift.String]()
            for string0 in recoveryInstanceIDsContainer {
                if let string0 = string0 {
                    recoveryInstanceIDsDecoded0?.append(string0)
                }
            }
        }
        recoveryInstanceIDs = recoveryInstanceIDsDecoded0
    }
}

extension TerminateRecoveryInstancesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: TerminateRecoveryInstancesOutputBody = try responseDecoder.decode(responseBody: data)
            self.job = output.job
        } else {
            self.job = nil
        }
    }
}

public struct TerminateRecoveryInstancesOutput: Swift.Equatable {
    /// The Job for terminating the Recovery Instances.
    public var job: DrsClientTypes.Job?

    public init(
        job: DrsClientTypes.Job? = nil
    )
    {
        self.job = job
    }
}

struct TerminateRecoveryInstancesOutputBody: Swift.Equatable {
    let job: DrsClientTypes.Job?
}

extension TerminateRecoveryInstancesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case job
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let jobDecoded = try containerValues.decodeIfPresent(DrsClientTypes.Job.self, forKey: .job)
        job = jobDecoded
    }
}

enum TerminateRecoveryInstancesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UninitializedAccountException": return try await UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ThrottlingException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            self.properties.retryAfterSeconds = retryAfterSecondsHeaderValue
        } else {
            self.properties.retryAfterSeconds = nil
        }
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.quotaCode = output.quotaCode
            self.properties.serviceCode = output.serviceCode
        } else {
            self.properties.message = nil
            self.properties.quotaCode = nil
            self.properties.serviceCode = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request was denied due to request throttling.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// Quota code.
        public internal(set) var quotaCode: Swift.String? = nil
        /// The number of seconds after which the request should be safe to retry.
        public internal(set) var retryAfterSeconds: Swift.String? = nil
        /// Service code.
        public internal(set) var serviceCode: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        quotaCode: Swift.String? = nil,
        retryAfterSeconds: Swift.String? = nil,
        serviceCode: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.quotaCode = quotaCode
        self.properties.retryAfterSeconds = retryAfterSeconds
        self.properties.serviceCode = serviceCode
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let serviceCode: Swift.String?
    let quotaCode: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case quotaCode
        case serviceCode
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let serviceCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
        let quotaCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .quotaCode)
        quotaCode = quotaCodeDecoded
    }
}

extension UninitializedAccountException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UninitializedAccountExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.code = output.code
            self.properties.message = output.message
        } else {
            self.properties.code = nil
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The account performing the request has not been initialized.
public struct UninitializedAccountException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var code: Swift.String? = nil
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "UninitializedAccountException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.code = code
        self.properties.message = message
    }
}

struct UninitializedAccountExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let code: Swift.String?
}

extension UninitializedAccountExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
    }
}

extension UntagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceInput(resourceArn: \(Swift.String(describing: resourceArn)), tagKeys: \"CONTENT_REDACTED\")"}
}

extension UntagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let tagKeys = tagKeys else {
                let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
            return items
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// ARN of the resource for which tags are to be removed.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// Array of tags to be removed.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UntagResourceOutput: Swift.Equatable {

    public init() { }
}

enum UntagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateFailbackReplicationConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bandwidthThrottling
        case name
        case recoveryInstanceID
        case usePrivateIP
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if bandwidthThrottling != 0 {
            try encodeContainer.encode(bandwidthThrottling, forKey: .bandwidthThrottling)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let recoveryInstanceID = self.recoveryInstanceID {
            try encodeContainer.encode(recoveryInstanceID, forKey: .recoveryInstanceID)
        }
        if let usePrivateIP = self.usePrivateIP {
            try encodeContainer.encode(usePrivateIP, forKey: .usePrivateIP)
        }
    }
}

extension UpdateFailbackReplicationConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/UpdateFailbackReplicationConfiguration"
    }
}

public struct UpdateFailbackReplicationConfigurationInput: Swift.Equatable {
    /// Configure bandwidth throttling for the outbound data transfer rate of the Recovery Instance in Mbps.
    public var bandwidthThrottling: Swift.Int
    /// The name of the Failback Replication Configuration.
    public var name: Swift.String?
    /// The ID of the Recovery Instance.
    /// This member is required.
    public var recoveryInstanceID: Swift.String?
    /// Whether to use Private IP for the failback replication of the Recovery Instance.
    public var usePrivateIP: Swift.Bool?

    public init(
        bandwidthThrottling: Swift.Int = 0,
        name: Swift.String? = nil,
        recoveryInstanceID: Swift.String? = nil,
        usePrivateIP: Swift.Bool? = nil
    )
    {
        self.bandwidthThrottling = bandwidthThrottling
        self.name = name
        self.recoveryInstanceID = recoveryInstanceID
        self.usePrivateIP = usePrivateIP
    }
}

struct UpdateFailbackReplicationConfigurationInputBody: Swift.Equatable {
    let recoveryInstanceID: Swift.String?
    let name: Swift.String?
    let bandwidthThrottling: Swift.Int
    let usePrivateIP: Swift.Bool?
}

extension UpdateFailbackReplicationConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bandwidthThrottling
        case name
        case recoveryInstanceID
        case usePrivateIP
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recoveryInstanceIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recoveryInstanceID)
        recoveryInstanceID = recoveryInstanceIDDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let bandwidthThrottlingDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .bandwidthThrottling) ?? 0
        bandwidthThrottling = bandwidthThrottlingDecoded
        let usePrivateIPDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .usePrivateIP)
        usePrivateIP = usePrivateIPDecoded
    }
}

extension UpdateFailbackReplicationConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateFailbackReplicationConfigurationOutput: Swift.Equatable {

    public init() { }
}

enum UpdateFailbackReplicationConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UninitializedAccountException": return try await UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateLaunchConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case copyPrivateIp
        case copyTags
        case launchDisposition
        case licensing
        case name
        case postLaunchEnabled
        case sourceServerID
        case targetInstanceTypeRightSizingMethod
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let copyPrivateIp = self.copyPrivateIp {
            try encodeContainer.encode(copyPrivateIp, forKey: .copyPrivateIp)
        }
        if let copyTags = self.copyTags {
            try encodeContainer.encode(copyTags, forKey: .copyTags)
        }
        if let launchDisposition = self.launchDisposition {
            try encodeContainer.encode(launchDisposition.rawValue, forKey: .launchDisposition)
        }
        if let licensing = self.licensing {
            try encodeContainer.encode(licensing, forKey: .licensing)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let postLaunchEnabled = self.postLaunchEnabled {
            try encodeContainer.encode(postLaunchEnabled, forKey: .postLaunchEnabled)
        }
        if let sourceServerID = self.sourceServerID {
            try encodeContainer.encode(sourceServerID, forKey: .sourceServerID)
        }
        if let targetInstanceTypeRightSizingMethod = self.targetInstanceTypeRightSizingMethod {
            try encodeContainer.encode(targetInstanceTypeRightSizingMethod.rawValue, forKey: .targetInstanceTypeRightSizingMethod)
        }
    }
}

extension UpdateLaunchConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/UpdateLaunchConfiguration"
    }
}

public struct UpdateLaunchConfigurationInput: Swift.Equatable {
    /// Whether we should copy the Private IP of the Source Server to the Recovery Instance.
    public var copyPrivateIp: Swift.Bool?
    /// Whether we want to copy the tags of the Source Server to the EC2 machine of the Recovery Instance.
    public var copyTags: Swift.Bool?
    /// The state of the Recovery Instance in EC2 after the recovery operation.
    public var launchDisposition: DrsClientTypes.LaunchDisposition?
    /// The licensing configuration to be used for this launch configuration.
    public var licensing: DrsClientTypes.Licensing?
    /// The name of the launch configuration.
    public var name: Swift.String?
    /// Whether we want to enable post-launch actions for the Source Server.
    public var postLaunchEnabled: Swift.Bool?
    /// The ID of the Source Server that we want to retrieve a Launch Configuration for.
    /// This member is required.
    public var sourceServerID: Swift.String?
    /// Whether Elastic Disaster Recovery should try to automatically choose the instance type that best matches the OS, CPU, and RAM of your Source Server.
    public var targetInstanceTypeRightSizingMethod: DrsClientTypes.TargetInstanceTypeRightSizingMethod?

    public init(
        copyPrivateIp: Swift.Bool? = nil,
        copyTags: Swift.Bool? = nil,
        launchDisposition: DrsClientTypes.LaunchDisposition? = nil,
        licensing: DrsClientTypes.Licensing? = nil,
        name: Swift.String? = nil,
        postLaunchEnabled: Swift.Bool? = nil,
        sourceServerID: Swift.String? = nil,
        targetInstanceTypeRightSizingMethod: DrsClientTypes.TargetInstanceTypeRightSizingMethod? = nil
    )
    {
        self.copyPrivateIp = copyPrivateIp
        self.copyTags = copyTags
        self.launchDisposition = launchDisposition
        self.licensing = licensing
        self.name = name
        self.postLaunchEnabled = postLaunchEnabled
        self.sourceServerID = sourceServerID
        self.targetInstanceTypeRightSizingMethod = targetInstanceTypeRightSizingMethod
    }
}

struct UpdateLaunchConfigurationInputBody: Swift.Equatable {
    let sourceServerID: Swift.String?
    let name: Swift.String?
    let launchDisposition: DrsClientTypes.LaunchDisposition?
    let targetInstanceTypeRightSizingMethod: DrsClientTypes.TargetInstanceTypeRightSizingMethod?
    let copyPrivateIp: Swift.Bool?
    let copyTags: Swift.Bool?
    let licensing: DrsClientTypes.Licensing?
    let postLaunchEnabled: Swift.Bool?
}

extension UpdateLaunchConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case copyPrivateIp
        case copyTags
        case launchDisposition
        case licensing
        case name
        case postLaunchEnabled
        case sourceServerID
        case targetInstanceTypeRightSizingMethod
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceServerIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceServerID)
        sourceServerID = sourceServerIDDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let launchDispositionDecoded = try containerValues.decodeIfPresent(DrsClientTypes.LaunchDisposition.self, forKey: .launchDisposition)
        launchDisposition = launchDispositionDecoded
        let targetInstanceTypeRightSizingMethodDecoded = try containerValues.decodeIfPresent(DrsClientTypes.TargetInstanceTypeRightSizingMethod.self, forKey: .targetInstanceTypeRightSizingMethod)
        targetInstanceTypeRightSizingMethod = targetInstanceTypeRightSizingMethodDecoded
        let copyPrivateIpDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .copyPrivateIp)
        copyPrivateIp = copyPrivateIpDecoded
        let copyTagsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .copyTags)
        copyTags = copyTagsDecoded
        let licensingDecoded = try containerValues.decodeIfPresent(DrsClientTypes.Licensing.self, forKey: .licensing)
        licensing = licensingDecoded
        let postLaunchEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .postLaunchEnabled)
        postLaunchEnabled = postLaunchEnabledDecoded
    }
}

extension UpdateLaunchConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateLaunchConfigurationOutputBody = try responseDecoder.decode(responseBody: data)
            self.copyPrivateIp = output.copyPrivateIp
            self.copyTags = output.copyTags
            self.ec2LaunchTemplateID = output.ec2LaunchTemplateID
            self.launchDisposition = output.launchDisposition
            self.licensing = output.licensing
            self.name = output.name
            self.postLaunchEnabled = output.postLaunchEnabled
            self.sourceServerID = output.sourceServerID
            self.targetInstanceTypeRightSizingMethod = output.targetInstanceTypeRightSizingMethod
        } else {
            self.copyPrivateIp = nil
            self.copyTags = nil
            self.ec2LaunchTemplateID = nil
            self.launchDisposition = nil
            self.licensing = nil
            self.name = nil
            self.postLaunchEnabled = nil
            self.sourceServerID = nil
            self.targetInstanceTypeRightSizingMethod = nil
        }
    }
}

public struct UpdateLaunchConfigurationOutput: Swift.Equatable {
    /// Whether we should copy the Private IP of the Source Server to the Recovery Instance.
    public var copyPrivateIp: Swift.Bool?
    /// Whether we want to copy the tags of the Source Server to the EC2 machine of the Recovery Instance.
    public var copyTags: Swift.Bool?
    /// The EC2 launch template ID of this launch configuration.
    public var ec2LaunchTemplateID: Swift.String?
    /// The state of the Recovery Instance in EC2 after the recovery operation.
    public var launchDisposition: DrsClientTypes.LaunchDisposition?
    /// The licensing configuration to be used for this launch configuration.
    public var licensing: DrsClientTypes.Licensing?
    /// The name of the launch configuration.
    public var name: Swift.String?
    /// Whether we want to activate post-launch actions for the Source Server.
    public var postLaunchEnabled: Swift.Bool?
    /// The ID of the Source Server for this launch configuration.
    public var sourceServerID: Swift.String?
    /// Whether Elastic Disaster Recovery should try to automatically choose the instance type that best matches the OS, CPU, and RAM of your Source Server.
    public var targetInstanceTypeRightSizingMethod: DrsClientTypes.TargetInstanceTypeRightSizingMethod?

    public init(
        copyPrivateIp: Swift.Bool? = nil,
        copyTags: Swift.Bool? = nil,
        ec2LaunchTemplateID: Swift.String? = nil,
        launchDisposition: DrsClientTypes.LaunchDisposition? = nil,
        licensing: DrsClientTypes.Licensing? = nil,
        name: Swift.String? = nil,
        postLaunchEnabled: Swift.Bool? = nil,
        sourceServerID: Swift.String? = nil,
        targetInstanceTypeRightSizingMethod: DrsClientTypes.TargetInstanceTypeRightSizingMethod? = nil
    )
    {
        self.copyPrivateIp = copyPrivateIp
        self.copyTags = copyTags
        self.ec2LaunchTemplateID = ec2LaunchTemplateID
        self.launchDisposition = launchDisposition
        self.licensing = licensing
        self.name = name
        self.postLaunchEnabled = postLaunchEnabled
        self.sourceServerID = sourceServerID
        self.targetInstanceTypeRightSizingMethod = targetInstanceTypeRightSizingMethod
    }
}

struct UpdateLaunchConfigurationOutputBody: Swift.Equatable {
    let sourceServerID: Swift.String?
    let name: Swift.String?
    let ec2LaunchTemplateID: Swift.String?
    let launchDisposition: DrsClientTypes.LaunchDisposition?
    let targetInstanceTypeRightSizingMethod: DrsClientTypes.TargetInstanceTypeRightSizingMethod?
    let copyPrivateIp: Swift.Bool?
    let copyTags: Swift.Bool?
    let licensing: DrsClientTypes.Licensing?
    let postLaunchEnabled: Swift.Bool?
}

extension UpdateLaunchConfigurationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case copyPrivateIp
        case copyTags
        case ec2LaunchTemplateID
        case launchDisposition
        case licensing
        case name
        case postLaunchEnabled
        case sourceServerID
        case targetInstanceTypeRightSizingMethod
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceServerIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceServerID)
        sourceServerID = sourceServerIDDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let ec2LaunchTemplateIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ec2LaunchTemplateID)
        ec2LaunchTemplateID = ec2LaunchTemplateIDDecoded
        let launchDispositionDecoded = try containerValues.decodeIfPresent(DrsClientTypes.LaunchDisposition.self, forKey: .launchDisposition)
        launchDisposition = launchDispositionDecoded
        let targetInstanceTypeRightSizingMethodDecoded = try containerValues.decodeIfPresent(DrsClientTypes.TargetInstanceTypeRightSizingMethod.self, forKey: .targetInstanceTypeRightSizingMethod)
        targetInstanceTypeRightSizingMethod = targetInstanceTypeRightSizingMethodDecoded
        let copyPrivateIpDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .copyPrivateIp)
        copyPrivateIp = copyPrivateIpDecoded
        let copyTagsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .copyTags)
        copyTags = copyTagsDecoded
        let licensingDecoded = try containerValues.decodeIfPresent(DrsClientTypes.Licensing.self, forKey: .licensing)
        licensing = licensingDecoded
        let postLaunchEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .postLaunchEnabled)
        postLaunchEnabled = postLaunchEnabledDecoded
    }
}

enum UpdateLaunchConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UninitializedAccountException": return try await UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateLaunchConfigurationTemplateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case copyPrivateIp
        case copyTags
        case exportBucketArn
        case launchConfigurationTemplateID
        case launchDisposition
        case licensing
        case postLaunchEnabled
        case targetInstanceTypeRightSizingMethod
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let copyPrivateIp = self.copyPrivateIp {
            try encodeContainer.encode(copyPrivateIp, forKey: .copyPrivateIp)
        }
        if let copyTags = self.copyTags {
            try encodeContainer.encode(copyTags, forKey: .copyTags)
        }
        if let exportBucketArn = self.exportBucketArn {
            try encodeContainer.encode(exportBucketArn, forKey: .exportBucketArn)
        }
        if let launchConfigurationTemplateID = self.launchConfigurationTemplateID {
            try encodeContainer.encode(launchConfigurationTemplateID, forKey: .launchConfigurationTemplateID)
        }
        if let launchDisposition = self.launchDisposition {
            try encodeContainer.encode(launchDisposition.rawValue, forKey: .launchDisposition)
        }
        if let licensing = self.licensing {
            try encodeContainer.encode(licensing, forKey: .licensing)
        }
        if let postLaunchEnabled = self.postLaunchEnabled {
            try encodeContainer.encode(postLaunchEnabled, forKey: .postLaunchEnabled)
        }
        if let targetInstanceTypeRightSizingMethod = self.targetInstanceTypeRightSizingMethod {
            try encodeContainer.encode(targetInstanceTypeRightSizingMethod.rawValue, forKey: .targetInstanceTypeRightSizingMethod)
        }
    }
}

extension UpdateLaunchConfigurationTemplateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/UpdateLaunchConfigurationTemplate"
    }
}

public struct UpdateLaunchConfigurationTemplateInput: Swift.Equatable {
    /// Copy private IP.
    public var copyPrivateIp: Swift.Bool?
    /// Copy tags.
    public var copyTags: Swift.Bool?
    /// S3 bucket ARN to export Source Network templates.
    public var exportBucketArn: Swift.String?
    /// Launch Configuration Template ID.
    /// This member is required.
    public var launchConfigurationTemplateID: Swift.String?
    /// Launch disposition.
    public var launchDisposition: DrsClientTypes.LaunchDisposition?
    /// Licensing.
    public var licensing: DrsClientTypes.Licensing?
    /// Whether we want to activate post-launch actions.
    public var postLaunchEnabled: Swift.Bool?
    /// Target instance type right-sizing method.
    public var targetInstanceTypeRightSizingMethod: DrsClientTypes.TargetInstanceTypeRightSizingMethod?

    public init(
        copyPrivateIp: Swift.Bool? = nil,
        copyTags: Swift.Bool? = nil,
        exportBucketArn: Swift.String? = nil,
        launchConfigurationTemplateID: Swift.String? = nil,
        launchDisposition: DrsClientTypes.LaunchDisposition? = nil,
        licensing: DrsClientTypes.Licensing? = nil,
        postLaunchEnabled: Swift.Bool? = nil,
        targetInstanceTypeRightSizingMethod: DrsClientTypes.TargetInstanceTypeRightSizingMethod? = nil
    )
    {
        self.copyPrivateIp = copyPrivateIp
        self.copyTags = copyTags
        self.exportBucketArn = exportBucketArn
        self.launchConfigurationTemplateID = launchConfigurationTemplateID
        self.launchDisposition = launchDisposition
        self.licensing = licensing
        self.postLaunchEnabled = postLaunchEnabled
        self.targetInstanceTypeRightSizingMethod = targetInstanceTypeRightSizingMethod
    }
}

struct UpdateLaunchConfigurationTemplateInputBody: Swift.Equatable {
    let launchConfigurationTemplateID: Swift.String?
    let launchDisposition: DrsClientTypes.LaunchDisposition?
    let targetInstanceTypeRightSizingMethod: DrsClientTypes.TargetInstanceTypeRightSizingMethod?
    let copyPrivateIp: Swift.Bool?
    let copyTags: Swift.Bool?
    let licensing: DrsClientTypes.Licensing?
    let exportBucketArn: Swift.String?
    let postLaunchEnabled: Swift.Bool?
}

extension UpdateLaunchConfigurationTemplateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case copyPrivateIp
        case copyTags
        case exportBucketArn
        case launchConfigurationTemplateID
        case launchDisposition
        case licensing
        case postLaunchEnabled
        case targetInstanceTypeRightSizingMethod
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let launchConfigurationTemplateIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .launchConfigurationTemplateID)
        launchConfigurationTemplateID = launchConfigurationTemplateIDDecoded
        let launchDispositionDecoded = try containerValues.decodeIfPresent(DrsClientTypes.LaunchDisposition.self, forKey: .launchDisposition)
        launchDisposition = launchDispositionDecoded
        let targetInstanceTypeRightSizingMethodDecoded = try containerValues.decodeIfPresent(DrsClientTypes.TargetInstanceTypeRightSizingMethod.self, forKey: .targetInstanceTypeRightSizingMethod)
        targetInstanceTypeRightSizingMethod = targetInstanceTypeRightSizingMethodDecoded
        let copyPrivateIpDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .copyPrivateIp)
        copyPrivateIp = copyPrivateIpDecoded
        let copyTagsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .copyTags)
        copyTags = copyTagsDecoded
        let licensingDecoded = try containerValues.decodeIfPresent(DrsClientTypes.Licensing.self, forKey: .licensing)
        licensing = licensingDecoded
        let exportBucketArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .exportBucketArn)
        exportBucketArn = exportBucketArnDecoded
        let postLaunchEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .postLaunchEnabled)
        postLaunchEnabled = postLaunchEnabledDecoded
    }
}

extension UpdateLaunchConfigurationTemplateOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateLaunchConfigurationTemplateOutputBody = try responseDecoder.decode(responseBody: data)
            self.launchConfigurationTemplate = output.launchConfigurationTemplate
        } else {
            self.launchConfigurationTemplate = nil
        }
    }
}

public struct UpdateLaunchConfigurationTemplateOutput: Swift.Equatable {
    /// Updated Launch Configuration Template.
    public var launchConfigurationTemplate: DrsClientTypes.LaunchConfigurationTemplate?

    public init(
        launchConfigurationTemplate: DrsClientTypes.LaunchConfigurationTemplate? = nil
    )
    {
        self.launchConfigurationTemplate = launchConfigurationTemplate
    }
}

struct UpdateLaunchConfigurationTemplateOutputBody: Swift.Equatable {
    let launchConfigurationTemplate: DrsClientTypes.LaunchConfigurationTemplate?
}

extension UpdateLaunchConfigurationTemplateOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case launchConfigurationTemplate
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let launchConfigurationTemplateDecoded = try containerValues.decodeIfPresent(DrsClientTypes.LaunchConfigurationTemplate.self, forKey: .launchConfigurationTemplate)
        launchConfigurationTemplate = launchConfigurationTemplateDecoded
    }
}

enum UpdateLaunchConfigurationTemplateOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UninitializedAccountException": return try await UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateReplicationConfigurationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateReplicationConfigurationInput(associateDefaultSecurityGroup: \(Swift.String(describing: associateDefaultSecurityGroup)), autoReplicateNewDisks: \(Swift.String(describing: autoReplicateNewDisks)), bandwidthThrottling: \(Swift.String(describing: bandwidthThrottling)), createPublicIP: \(Swift.String(describing: createPublicIP)), dataPlaneRouting: \(Swift.String(describing: dataPlaneRouting)), defaultLargeStagingDiskType: \(Swift.String(describing: defaultLargeStagingDiskType)), ebsEncryption: \(Swift.String(describing: ebsEncryption)), ebsEncryptionKeyArn: \(Swift.String(describing: ebsEncryptionKeyArn)), name: \(Swift.String(describing: name)), pitPolicy: \(Swift.String(describing: pitPolicy)), replicatedDisks: \(Swift.String(describing: replicatedDisks)), replicationServerInstanceType: \(Swift.String(describing: replicationServerInstanceType)), replicationServersSecurityGroupsIDs: \(Swift.String(describing: replicationServersSecurityGroupsIDs)), sourceServerID: \(Swift.String(describing: sourceServerID)), stagingAreaSubnetId: \(Swift.String(describing: stagingAreaSubnetId)), useDedicatedReplicationServer: \(Swift.String(describing: useDedicatedReplicationServer)), stagingAreaTags: \"CONTENT_REDACTED\")"}
}

extension UpdateReplicationConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associateDefaultSecurityGroup
        case autoReplicateNewDisks
        case bandwidthThrottling
        case createPublicIP
        case dataPlaneRouting
        case defaultLargeStagingDiskType
        case ebsEncryption
        case ebsEncryptionKeyArn
        case name
        case pitPolicy
        case replicatedDisks
        case replicationServerInstanceType
        case replicationServersSecurityGroupsIDs
        case sourceServerID
        case stagingAreaSubnetId
        case stagingAreaTags
        case useDedicatedReplicationServer
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let associateDefaultSecurityGroup = self.associateDefaultSecurityGroup {
            try encodeContainer.encode(associateDefaultSecurityGroup, forKey: .associateDefaultSecurityGroup)
        }
        if let autoReplicateNewDisks = self.autoReplicateNewDisks {
            try encodeContainer.encode(autoReplicateNewDisks, forKey: .autoReplicateNewDisks)
        }
        if bandwidthThrottling != 0 {
            try encodeContainer.encode(bandwidthThrottling, forKey: .bandwidthThrottling)
        }
        if let createPublicIP = self.createPublicIP {
            try encodeContainer.encode(createPublicIP, forKey: .createPublicIP)
        }
        if let dataPlaneRouting = self.dataPlaneRouting {
            try encodeContainer.encode(dataPlaneRouting.rawValue, forKey: .dataPlaneRouting)
        }
        if let defaultLargeStagingDiskType = self.defaultLargeStagingDiskType {
            try encodeContainer.encode(defaultLargeStagingDiskType.rawValue, forKey: .defaultLargeStagingDiskType)
        }
        if let ebsEncryption = self.ebsEncryption {
            try encodeContainer.encode(ebsEncryption.rawValue, forKey: .ebsEncryption)
        }
        if let ebsEncryptionKeyArn = self.ebsEncryptionKeyArn {
            try encodeContainer.encode(ebsEncryptionKeyArn, forKey: .ebsEncryptionKeyArn)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let pitPolicy = pitPolicy {
            var pitPolicyContainer = encodeContainer.nestedUnkeyedContainer(forKey: .pitPolicy)
            for pitpolicyrule0 in pitPolicy {
                try pitPolicyContainer.encode(pitpolicyrule0)
            }
        }
        if let replicatedDisks = replicatedDisks {
            var replicatedDisksContainer = encodeContainer.nestedUnkeyedContainer(forKey: .replicatedDisks)
            for replicationconfigurationreplicateddisk0 in replicatedDisks {
                try replicatedDisksContainer.encode(replicationconfigurationreplicateddisk0)
            }
        }
        if let replicationServerInstanceType = self.replicationServerInstanceType {
            try encodeContainer.encode(replicationServerInstanceType, forKey: .replicationServerInstanceType)
        }
        if let replicationServersSecurityGroupsIDs = replicationServersSecurityGroupsIDs {
            var replicationServersSecurityGroupsIDsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .replicationServersSecurityGroupsIDs)
            for securitygroupid0 in replicationServersSecurityGroupsIDs {
                try replicationServersSecurityGroupsIDsContainer.encode(securitygroupid0)
            }
        }
        if let sourceServerID = self.sourceServerID {
            try encodeContainer.encode(sourceServerID, forKey: .sourceServerID)
        }
        if let stagingAreaSubnetId = self.stagingAreaSubnetId {
            try encodeContainer.encode(stagingAreaSubnetId, forKey: .stagingAreaSubnetId)
        }
        if let stagingAreaTags = stagingAreaTags {
            var stagingAreaTagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .stagingAreaTags)
            for (dictKey0, tagsMap0) in stagingAreaTags {
                try stagingAreaTagsContainer.encode(tagsMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let useDedicatedReplicationServer = self.useDedicatedReplicationServer {
            try encodeContainer.encode(useDedicatedReplicationServer, forKey: .useDedicatedReplicationServer)
        }
    }
}

extension UpdateReplicationConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/UpdateReplicationConfiguration"
    }
}

public struct UpdateReplicationConfigurationInput: Swift.Equatable {
    /// Whether to associate the default Elastic Disaster Recovery Security group with the Replication Configuration.
    public var associateDefaultSecurityGroup: Swift.Bool?
    /// Whether to allow the AWS replication agent to automatically replicate newly added disks.
    public var autoReplicateNewDisks: Swift.Bool?
    /// Configure bandwidth throttling for the outbound data transfer rate of the Source Server in Mbps.
    public var bandwidthThrottling: Swift.Int
    /// Whether to create a Public IP for the Recovery Instance by default.
    public var createPublicIP: Swift.Bool?
    /// The data plane routing mechanism that will be used for replication.
    public var dataPlaneRouting: DrsClientTypes.ReplicationConfigurationDataPlaneRouting?
    /// The Staging Disk EBS volume type to be used during replication.
    public var defaultLargeStagingDiskType: DrsClientTypes.ReplicationConfigurationDefaultLargeStagingDiskType?
    /// The type of EBS encryption to be used during replication.
    public var ebsEncryption: DrsClientTypes.ReplicationConfigurationEbsEncryption?
    /// The ARN of the EBS encryption key to be used during replication.
    public var ebsEncryptionKeyArn: Swift.String?
    /// The name of the Replication Configuration.
    public var name: Swift.String?
    /// The Point in time (PIT) policy to manage snapshots taken during replication.
    public var pitPolicy: [DrsClientTypes.PITPolicyRule]?
    /// The configuration of the disks of the Source Server to be replicated.
    public var replicatedDisks: [DrsClientTypes.ReplicationConfigurationReplicatedDisk]?
    /// The instance type to be used for the replication server.
    public var replicationServerInstanceType: Swift.String?
    /// The security group IDs that will be used by the replication server.
    public var replicationServersSecurityGroupsIDs: [Swift.String]?
    /// The ID of the Source Server for this Replication Configuration.
    /// This member is required.
    public var sourceServerID: Swift.String?
    /// The subnet to be used by the replication staging area.
    public var stagingAreaSubnetId: Swift.String?
    /// A set of tags to be associated with all resources created in the replication staging area: EC2 replication server, EBS volumes, EBS snapshots, etc.
    public var stagingAreaTags: [Swift.String:Swift.String]?
    /// Whether to use a dedicated Replication Server in the replication staging area.
    public var useDedicatedReplicationServer: Swift.Bool?

    public init(
        associateDefaultSecurityGroup: Swift.Bool? = nil,
        autoReplicateNewDisks: Swift.Bool? = nil,
        bandwidthThrottling: Swift.Int = 0,
        createPublicIP: Swift.Bool? = nil,
        dataPlaneRouting: DrsClientTypes.ReplicationConfigurationDataPlaneRouting? = nil,
        defaultLargeStagingDiskType: DrsClientTypes.ReplicationConfigurationDefaultLargeStagingDiskType? = nil,
        ebsEncryption: DrsClientTypes.ReplicationConfigurationEbsEncryption? = nil,
        ebsEncryptionKeyArn: Swift.String? = nil,
        name: Swift.String? = nil,
        pitPolicy: [DrsClientTypes.PITPolicyRule]? = nil,
        replicatedDisks: [DrsClientTypes.ReplicationConfigurationReplicatedDisk]? = nil,
        replicationServerInstanceType: Swift.String? = nil,
        replicationServersSecurityGroupsIDs: [Swift.String]? = nil,
        sourceServerID: Swift.String? = nil,
        stagingAreaSubnetId: Swift.String? = nil,
        stagingAreaTags: [Swift.String:Swift.String]? = nil,
        useDedicatedReplicationServer: Swift.Bool? = nil
    )
    {
        self.associateDefaultSecurityGroup = associateDefaultSecurityGroup
        self.autoReplicateNewDisks = autoReplicateNewDisks
        self.bandwidthThrottling = bandwidthThrottling
        self.createPublicIP = createPublicIP
        self.dataPlaneRouting = dataPlaneRouting
        self.defaultLargeStagingDiskType = defaultLargeStagingDiskType
        self.ebsEncryption = ebsEncryption
        self.ebsEncryptionKeyArn = ebsEncryptionKeyArn
        self.name = name
        self.pitPolicy = pitPolicy
        self.replicatedDisks = replicatedDisks
        self.replicationServerInstanceType = replicationServerInstanceType
        self.replicationServersSecurityGroupsIDs = replicationServersSecurityGroupsIDs
        self.sourceServerID = sourceServerID
        self.stagingAreaSubnetId = stagingAreaSubnetId
        self.stagingAreaTags = stagingAreaTags
        self.useDedicatedReplicationServer = useDedicatedReplicationServer
    }
}

struct UpdateReplicationConfigurationInputBody: Swift.Equatable {
    let sourceServerID: Swift.String?
    let name: Swift.String?
    let stagingAreaSubnetId: Swift.String?
    let associateDefaultSecurityGroup: Swift.Bool?
    let replicationServersSecurityGroupsIDs: [Swift.String]?
    let replicationServerInstanceType: Swift.String?
    let useDedicatedReplicationServer: Swift.Bool?
    let defaultLargeStagingDiskType: DrsClientTypes.ReplicationConfigurationDefaultLargeStagingDiskType?
    let replicatedDisks: [DrsClientTypes.ReplicationConfigurationReplicatedDisk]?
    let ebsEncryption: DrsClientTypes.ReplicationConfigurationEbsEncryption?
    let ebsEncryptionKeyArn: Swift.String?
    let bandwidthThrottling: Swift.Int
    let dataPlaneRouting: DrsClientTypes.ReplicationConfigurationDataPlaneRouting?
    let createPublicIP: Swift.Bool?
    let stagingAreaTags: [Swift.String:Swift.String]?
    let pitPolicy: [DrsClientTypes.PITPolicyRule]?
    let autoReplicateNewDisks: Swift.Bool?
}

extension UpdateReplicationConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associateDefaultSecurityGroup
        case autoReplicateNewDisks
        case bandwidthThrottling
        case createPublicIP
        case dataPlaneRouting
        case defaultLargeStagingDiskType
        case ebsEncryption
        case ebsEncryptionKeyArn
        case name
        case pitPolicy
        case replicatedDisks
        case replicationServerInstanceType
        case replicationServersSecurityGroupsIDs
        case sourceServerID
        case stagingAreaSubnetId
        case stagingAreaTags
        case useDedicatedReplicationServer
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceServerIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceServerID)
        sourceServerID = sourceServerIDDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let stagingAreaSubnetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stagingAreaSubnetId)
        stagingAreaSubnetId = stagingAreaSubnetIdDecoded
        let associateDefaultSecurityGroupDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .associateDefaultSecurityGroup)
        associateDefaultSecurityGroup = associateDefaultSecurityGroupDecoded
        let replicationServersSecurityGroupsIDsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .replicationServersSecurityGroupsIDs)
        var replicationServersSecurityGroupsIDsDecoded0:[Swift.String]? = nil
        if let replicationServersSecurityGroupsIDsContainer = replicationServersSecurityGroupsIDsContainer {
            replicationServersSecurityGroupsIDsDecoded0 = [Swift.String]()
            for string0 in replicationServersSecurityGroupsIDsContainer {
                if let string0 = string0 {
                    replicationServersSecurityGroupsIDsDecoded0?.append(string0)
                }
            }
        }
        replicationServersSecurityGroupsIDs = replicationServersSecurityGroupsIDsDecoded0
        let replicationServerInstanceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationServerInstanceType)
        replicationServerInstanceType = replicationServerInstanceTypeDecoded
        let useDedicatedReplicationServerDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .useDedicatedReplicationServer)
        useDedicatedReplicationServer = useDedicatedReplicationServerDecoded
        let defaultLargeStagingDiskTypeDecoded = try containerValues.decodeIfPresent(DrsClientTypes.ReplicationConfigurationDefaultLargeStagingDiskType.self, forKey: .defaultLargeStagingDiskType)
        defaultLargeStagingDiskType = defaultLargeStagingDiskTypeDecoded
        let replicatedDisksContainer = try containerValues.decodeIfPresent([DrsClientTypes.ReplicationConfigurationReplicatedDisk?].self, forKey: .replicatedDisks)
        var replicatedDisksDecoded0:[DrsClientTypes.ReplicationConfigurationReplicatedDisk]? = nil
        if let replicatedDisksContainer = replicatedDisksContainer {
            replicatedDisksDecoded0 = [DrsClientTypes.ReplicationConfigurationReplicatedDisk]()
            for structure0 in replicatedDisksContainer {
                if let structure0 = structure0 {
                    replicatedDisksDecoded0?.append(structure0)
                }
            }
        }
        replicatedDisks = replicatedDisksDecoded0
        let ebsEncryptionDecoded = try containerValues.decodeIfPresent(DrsClientTypes.ReplicationConfigurationEbsEncryption.self, forKey: .ebsEncryption)
        ebsEncryption = ebsEncryptionDecoded
        let ebsEncryptionKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ebsEncryptionKeyArn)
        ebsEncryptionKeyArn = ebsEncryptionKeyArnDecoded
        let bandwidthThrottlingDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .bandwidthThrottling) ?? 0
        bandwidthThrottling = bandwidthThrottlingDecoded
        let dataPlaneRoutingDecoded = try containerValues.decodeIfPresent(DrsClientTypes.ReplicationConfigurationDataPlaneRouting.self, forKey: .dataPlaneRouting)
        dataPlaneRouting = dataPlaneRoutingDecoded
        let createPublicIPDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .createPublicIP)
        createPublicIP = createPublicIPDecoded
        let stagingAreaTagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .stagingAreaTags)
        var stagingAreaTagsDecoded0: [Swift.String:Swift.String]? = nil
        if let stagingAreaTagsContainer = stagingAreaTagsContainer {
            stagingAreaTagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in stagingAreaTagsContainer {
                if let tagvalue0 = tagvalue0 {
                    stagingAreaTagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        stagingAreaTags = stagingAreaTagsDecoded0
        let pitPolicyContainer = try containerValues.decodeIfPresent([DrsClientTypes.PITPolicyRule?].self, forKey: .pitPolicy)
        var pitPolicyDecoded0:[DrsClientTypes.PITPolicyRule]? = nil
        if let pitPolicyContainer = pitPolicyContainer {
            pitPolicyDecoded0 = [DrsClientTypes.PITPolicyRule]()
            for structure0 in pitPolicyContainer {
                if let structure0 = structure0 {
                    pitPolicyDecoded0?.append(structure0)
                }
            }
        }
        pitPolicy = pitPolicyDecoded0
        let autoReplicateNewDisksDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .autoReplicateNewDisks)
        autoReplicateNewDisks = autoReplicateNewDisksDecoded
    }
}

extension UpdateReplicationConfigurationOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateReplicationConfigurationOutput(associateDefaultSecurityGroup: \(Swift.String(describing: associateDefaultSecurityGroup)), autoReplicateNewDisks: \(Swift.String(describing: autoReplicateNewDisks)), bandwidthThrottling: \(Swift.String(describing: bandwidthThrottling)), createPublicIP: \(Swift.String(describing: createPublicIP)), dataPlaneRouting: \(Swift.String(describing: dataPlaneRouting)), defaultLargeStagingDiskType: \(Swift.String(describing: defaultLargeStagingDiskType)), ebsEncryption: \(Swift.String(describing: ebsEncryption)), ebsEncryptionKeyArn: \(Swift.String(describing: ebsEncryptionKeyArn)), name: \(Swift.String(describing: name)), pitPolicy: \(Swift.String(describing: pitPolicy)), replicatedDisks: \(Swift.String(describing: replicatedDisks)), replicationServerInstanceType: \(Swift.String(describing: replicationServerInstanceType)), replicationServersSecurityGroupsIDs: \(Swift.String(describing: replicationServersSecurityGroupsIDs)), sourceServerID: \(Swift.String(describing: sourceServerID)), stagingAreaSubnetId: \(Swift.String(describing: stagingAreaSubnetId)), useDedicatedReplicationServer: \(Swift.String(describing: useDedicatedReplicationServer)), stagingAreaTags: \"CONTENT_REDACTED\")"}
}

extension UpdateReplicationConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateReplicationConfigurationOutputBody = try responseDecoder.decode(responseBody: data)
            self.associateDefaultSecurityGroup = output.associateDefaultSecurityGroup
            self.autoReplicateNewDisks = output.autoReplicateNewDisks
            self.bandwidthThrottling = output.bandwidthThrottling
            self.createPublicIP = output.createPublicIP
            self.dataPlaneRouting = output.dataPlaneRouting
            self.defaultLargeStagingDiskType = output.defaultLargeStagingDiskType
            self.ebsEncryption = output.ebsEncryption
            self.ebsEncryptionKeyArn = output.ebsEncryptionKeyArn
            self.name = output.name
            self.pitPolicy = output.pitPolicy
            self.replicatedDisks = output.replicatedDisks
            self.replicationServerInstanceType = output.replicationServerInstanceType
            self.replicationServersSecurityGroupsIDs = output.replicationServersSecurityGroupsIDs
            self.sourceServerID = output.sourceServerID
            self.stagingAreaSubnetId = output.stagingAreaSubnetId
            self.stagingAreaTags = output.stagingAreaTags
            self.useDedicatedReplicationServer = output.useDedicatedReplicationServer
        } else {
            self.associateDefaultSecurityGroup = nil
            self.autoReplicateNewDisks = nil
            self.bandwidthThrottling = 0
            self.createPublicIP = nil
            self.dataPlaneRouting = nil
            self.defaultLargeStagingDiskType = nil
            self.ebsEncryption = nil
            self.ebsEncryptionKeyArn = nil
            self.name = nil
            self.pitPolicy = nil
            self.replicatedDisks = nil
            self.replicationServerInstanceType = nil
            self.replicationServersSecurityGroupsIDs = nil
            self.sourceServerID = nil
            self.stagingAreaSubnetId = nil
            self.stagingAreaTags = nil
            self.useDedicatedReplicationServer = nil
        }
    }
}

public struct UpdateReplicationConfigurationOutput: Swift.Equatable {
    /// Whether to associate the default Elastic Disaster Recovery Security group with the Replication Configuration.
    public var associateDefaultSecurityGroup: Swift.Bool?
    /// Whether to allow the AWS replication agent to automatically replicate newly added disks.
    public var autoReplicateNewDisks: Swift.Bool?
    /// Configure bandwidth throttling for the outbound data transfer rate of the Source Server in Mbps.
    public var bandwidthThrottling: Swift.Int
    /// Whether to create a Public IP for the Recovery Instance by default.
    public var createPublicIP: Swift.Bool?
    /// The data plane routing mechanism that will be used for replication.
    public var dataPlaneRouting: DrsClientTypes.ReplicationConfigurationDataPlaneRouting?
    /// The Staging Disk EBS volume type to be used during replication.
    public var defaultLargeStagingDiskType: DrsClientTypes.ReplicationConfigurationDefaultLargeStagingDiskType?
    /// The type of EBS encryption to be used during replication.
    public var ebsEncryption: DrsClientTypes.ReplicationConfigurationEbsEncryption?
    /// The ARN of the EBS encryption key to be used during replication.
    public var ebsEncryptionKeyArn: Swift.String?
    /// The name of the Replication Configuration.
    public var name: Swift.String?
    /// The Point in time (PIT) policy to manage snapshots taken during replication.
    public var pitPolicy: [DrsClientTypes.PITPolicyRule]?
    /// The configuration of the disks of the Source Server to be replicated.
    public var replicatedDisks: [DrsClientTypes.ReplicationConfigurationReplicatedDisk]?
    /// The instance type to be used for the replication server.
    public var replicationServerInstanceType: Swift.String?
    /// The security group IDs that will be used by the replication server.
    public var replicationServersSecurityGroupsIDs: [Swift.String]?
    /// The ID of the Source Server for this Replication Configuration.
    public var sourceServerID: Swift.String?
    /// The subnet to be used by the replication staging area.
    public var stagingAreaSubnetId: Swift.String?
    /// A set of tags to be associated with all resources created in the replication staging area: EC2 replication server, EBS volumes, EBS snapshots, etc.
    public var stagingAreaTags: [Swift.String:Swift.String]?
    /// Whether to use a dedicated Replication Server in the replication staging area.
    public var useDedicatedReplicationServer: Swift.Bool?

    public init(
        associateDefaultSecurityGroup: Swift.Bool? = nil,
        autoReplicateNewDisks: Swift.Bool? = nil,
        bandwidthThrottling: Swift.Int = 0,
        createPublicIP: Swift.Bool? = nil,
        dataPlaneRouting: DrsClientTypes.ReplicationConfigurationDataPlaneRouting? = nil,
        defaultLargeStagingDiskType: DrsClientTypes.ReplicationConfigurationDefaultLargeStagingDiskType? = nil,
        ebsEncryption: DrsClientTypes.ReplicationConfigurationEbsEncryption? = nil,
        ebsEncryptionKeyArn: Swift.String? = nil,
        name: Swift.String? = nil,
        pitPolicy: [DrsClientTypes.PITPolicyRule]? = nil,
        replicatedDisks: [DrsClientTypes.ReplicationConfigurationReplicatedDisk]? = nil,
        replicationServerInstanceType: Swift.String? = nil,
        replicationServersSecurityGroupsIDs: [Swift.String]? = nil,
        sourceServerID: Swift.String? = nil,
        stagingAreaSubnetId: Swift.String? = nil,
        stagingAreaTags: [Swift.String:Swift.String]? = nil,
        useDedicatedReplicationServer: Swift.Bool? = nil
    )
    {
        self.associateDefaultSecurityGroup = associateDefaultSecurityGroup
        self.autoReplicateNewDisks = autoReplicateNewDisks
        self.bandwidthThrottling = bandwidthThrottling
        self.createPublicIP = createPublicIP
        self.dataPlaneRouting = dataPlaneRouting
        self.defaultLargeStagingDiskType = defaultLargeStagingDiskType
        self.ebsEncryption = ebsEncryption
        self.ebsEncryptionKeyArn = ebsEncryptionKeyArn
        self.name = name
        self.pitPolicy = pitPolicy
        self.replicatedDisks = replicatedDisks
        self.replicationServerInstanceType = replicationServerInstanceType
        self.replicationServersSecurityGroupsIDs = replicationServersSecurityGroupsIDs
        self.sourceServerID = sourceServerID
        self.stagingAreaSubnetId = stagingAreaSubnetId
        self.stagingAreaTags = stagingAreaTags
        self.useDedicatedReplicationServer = useDedicatedReplicationServer
    }
}

struct UpdateReplicationConfigurationOutputBody: Swift.Equatable {
    let sourceServerID: Swift.String?
    let name: Swift.String?
    let stagingAreaSubnetId: Swift.String?
    let associateDefaultSecurityGroup: Swift.Bool?
    let replicationServersSecurityGroupsIDs: [Swift.String]?
    let replicationServerInstanceType: Swift.String?
    let useDedicatedReplicationServer: Swift.Bool?
    let defaultLargeStagingDiskType: DrsClientTypes.ReplicationConfigurationDefaultLargeStagingDiskType?
    let replicatedDisks: [DrsClientTypes.ReplicationConfigurationReplicatedDisk]?
    let ebsEncryption: DrsClientTypes.ReplicationConfigurationEbsEncryption?
    let ebsEncryptionKeyArn: Swift.String?
    let bandwidthThrottling: Swift.Int
    let dataPlaneRouting: DrsClientTypes.ReplicationConfigurationDataPlaneRouting?
    let createPublicIP: Swift.Bool?
    let stagingAreaTags: [Swift.String:Swift.String]?
    let pitPolicy: [DrsClientTypes.PITPolicyRule]?
    let autoReplicateNewDisks: Swift.Bool?
}

extension UpdateReplicationConfigurationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case associateDefaultSecurityGroup
        case autoReplicateNewDisks
        case bandwidthThrottling
        case createPublicIP
        case dataPlaneRouting
        case defaultLargeStagingDiskType
        case ebsEncryption
        case ebsEncryptionKeyArn
        case name
        case pitPolicy
        case replicatedDisks
        case replicationServerInstanceType
        case replicationServersSecurityGroupsIDs
        case sourceServerID
        case stagingAreaSubnetId
        case stagingAreaTags
        case useDedicatedReplicationServer
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sourceServerIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceServerID)
        sourceServerID = sourceServerIDDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let stagingAreaSubnetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stagingAreaSubnetId)
        stagingAreaSubnetId = stagingAreaSubnetIdDecoded
        let associateDefaultSecurityGroupDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .associateDefaultSecurityGroup)
        associateDefaultSecurityGroup = associateDefaultSecurityGroupDecoded
        let replicationServersSecurityGroupsIDsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .replicationServersSecurityGroupsIDs)
        var replicationServersSecurityGroupsIDsDecoded0:[Swift.String]? = nil
        if let replicationServersSecurityGroupsIDsContainer = replicationServersSecurityGroupsIDsContainer {
            replicationServersSecurityGroupsIDsDecoded0 = [Swift.String]()
            for string0 in replicationServersSecurityGroupsIDsContainer {
                if let string0 = string0 {
                    replicationServersSecurityGroupsIDsDecoded0?.append(string0)
                }
            }
        }
        replicationServersSecurityGroupsIDs = replicationServersSecurityGroupsIDsDecoded0
        let replicationServerInstanceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationServerInstanceType)
        replicationServerInstanceType = replicationServerInstanceTypeDecoded
        let useDedicatedReplicationServerDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .useDedicatedReplicationServer)
        useDedicatedReplicationServer = useDedicatedReplicationServerDecoded
        let defaultLargeStagingDiskTypeDecoded = try containerValues.decodeIfPresent(DrsClientTypes.ReplicationConfigurationDefaultLargeStagingDiskType.self, forKey: .defaultLargeStagingDiskType)
        defaultLargeStagingDiskType = defaultLargeStagingDiskTypeDecoded
        let replicatedDisksContainer = try containerValues.decodeIfPresent([DrsClientTypes.ReplicationConfigurationReplicatedDisk?].self, forKey: .replicatedDisks)
        var replicatedDisksDecoded0:[DrsClientTypes.ReplicationConfigurationReplicatedDisk]? = nil
        if let replicatedDisksContainer = replicatedDisksContainer {
            replicatedDisksDecoded0 = [DrsClientTypes.ReplicationConfigurationReplicatedDisk]()
            for structure0 in replicatedDisksContainer {
                if let structure0 = structure0 {
                    replicatedDisksDecoded0?.append(structure0)
                }
            }
        }
        replicatedDisks = replicatedDisksDecoded0
        let ebsEncryptionDecoded = try containerValues.decodeIfPresent(DrsClientTypes.ReplicationConfigurationEbsEncryption.self, forKey: .ebsEncryption)
        ebsEncryption = ebsEncryptionDecoded
        let ebsEncryptionKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ebsEncryptionKeyArn)
        ebsEncryptionKeyArn = ebsEncryptionKeyArnDecoded
        let bandwidthThrottlingDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .bandwidthThrottling) ?? 0
        bandwidthThrottling = bandwidthThrottlingDecoded
        let dataPlaneRoutingDecoded = try containerValues.decodeIfPresent(DrsClientTypes.ReplicationConfigurationDataPlaneRouting.self, forKey: .dataPlaneRouting)
        dataPlaneRouting = dataPlaneRoutingDecoded
        let createPublicIPDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .createPublicIP)
        createPublicIP = createPublicIPDecoded
        let stagingAreaTagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .stagingAreaTags)
        var stagingAreaTagsDecoded0: [Swift.String:Swift.String]? = nil
        if let stagingAreaTagsContainer = stagingAreaTagsContainer {
            stagingAreaTagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in stagingAreaTagsContainer {
                if let tagvalue0 = tagvalue0 {
                    stagingAreaTagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        stagingAreaTags = stagingAreaTagsDecoded0
        let pitPolicyContainer = try containerValues.decodeIfPresent([DrsClientTypes.PITPolicyRule?].self, forKey: .pitPolicy)
        var pitPolicyDecoded0:[DrsClientTypes.PITPolicyRule]? = nil
        if let pitPolicyContainer = pitPolicyContainer {
            pitPolicyDecoded0 = [DrsClientTypes.PITPolicyRule]()
            for structure0 in pitPolicyContainer {
                if let structure0 = structure0 {
                    pitPolicyDecoded0?.append(structure0)
                }
            }
        }
        pitPolicy = pitPolicyDecoded0
        let autoReplicateNewDisksDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .autoReplicateNewDisks)
        autoReplicateNewDisks = autoReplicateNewDisksDecoded
    }
}

enum UpdateReplicationConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UninitializedAccountException": return try await UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateReplicationConfigurationTemplateInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateReplicationConfigurationTemplateInput(arn: \(Swift.String(describing: arn)), associateDefaultSecurityGroup: \(Swift.String(describing: associateDefaultSecurityGroup)), autoReplicateNewDisks: \(Swift.String(describing: autoReplicateNewDisks)), bandwidthThrottling: \(Swift.String(describing: bandwidthThrottling)), createPublicIP: \(Swift.String(describing: createPublicIP)), dataPlaneRouting: \(Swift.String(describing: dataPlaneRouting)), defaultLargeStagingDiskType: \(Swift.String(describing: defaultLargeStagingDiskType)), ebsEncryption: \(Swift.String(describing: ebsEncryption)), ebsEncryptionKeyArn: \(Swift.String(describing: ebsEncryptionKeyArn)), pitPolicy: \(Swift.String(describing: pitPolicy)), replicationConfigurationTemplateID: \(Swift.String(describing: replicationConfigurationTemplateID)), replicationServerInstanceType: \(Swift.String(describing: replicationServerInstanceType)), replicationServersSecurityGroupsIDs: \(Swift.String(describing: replicationServersSecurityGroupsIDs)), stagingAreaSubnetId: \(Swift.String(describing: stagingAreaSubnetId)), useDedicatedReplicationServer: \(Swift.String(describing: useDedicatedReplicationServer)), stagingAreaTags: \"CONTENT_REDACTED\")"}
}

extension UpdateReplicationConfigurationTemplateInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case associateDefaultSecurityGroup
        case autoReplicateNewDisks
        case bandwidthThrottling
        case createPublicIP
        case dataPlaneRouting
        case defaultLargeStagingDiskType
        case ebsEncryption
        case ebsEncryptionKeyArn
        case pitPolicy
        case replicationConfigurationTemplateID
        case replicationServerInstanceType
        case replicationServersSecurityGroupsIDs
        case stagingAreaSubnetId
        case stagingAreaTags
        case useDedicatedReplicationServer
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let associateDefaultSecurityGroup = self.associateDefaultSecurityGroup {
            try encodeContainer.encode(associateDefaultSecurityGroup, forKey: .associateDefaultSecurityGroup)
        }
        if let autoReplicateNewDisks = self.autoReplicateNewDisks {
            try encodeContainer.encode(autoReplicateNewDisks, forKey: .autoReplicateNewDisks)
        }
        if bandwidthThrottling != 0 {
            try encodeContainer.encode(bandwidthThrottling, forKey: .bandwidthThrottling)
        }
        if let createPublicIP = self.createPublicIP {
            try encodeContainer.encode(createPublicIP, forKey: .createPublicIP)
        }
        if let dataPlaneRouting = self.dataPlaneRouting {
            try encodeContainer.encode(dataPlaneRouting.rawValue, forKey: .dataPlaneRouting)
        }
        if let defaultLargeStagingDiskType = self.defaultLargeStagingDiskType {
            try encodeContainer.encode(defaultLargeStagingDiskType.rawValue, forKey: .defaultLargeStagingDiskType)
        }
        if let ebsEncryption = self.ebsEncryption {
            try encodeContainer.encode(ebsEncryption.rawValue, forKey: .ebsEncryption)
        }
        if let ebsEncryptionKeyArn = self.ebsEncryptionKeyArn {
            try encodeContainer.encode(ebsEncryptionKeyArn, forKey: .ebsEncryptionKeyArn)
        }
        if let pitPolicy = pitPolicy {
            var pitPolicyContainer = encodeContainer.nestedUnkeyedContainer(forKey: .pitPolicy)
            for pitpolicyrule0 in pitPolicy {
                try pitPolicyContainer.encode(pitpolicyrule0)
            }
        }
        if let replicationConfigurationTemplateID = self.replicationConfigurationTemplateID {
            try encodeContainer.encode(replicationConfigurationTemplateID, forKey: .replicationConfigurationTemplateID)
        }
        if let replicationServerInstanceType = self.replicationServerInstanceType {
            try encodeContainer.encode(replicationServerInstanceType, forKey: .replicationServerInstanceType)
        }
        if let replicationServersSecurityGroupsIDs = replicationServersSecurityGroupsIDs {
            var replicationServersSecurityGroupsIDsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .replicationServersSecurityGroupsIDs)
            for securitygroupid0 in replicationServersSecurityGroupsIDs {
                try replicationServersSecurityGroupsIDsContainer.encode(securitygroupid0)
            }
        }
        if let stagingAreaSubnetId = self.stagingAreaSubnetId {
            try encodeContainer.encode(stagingAreaSubnetId, forKey: .stagingAreaSubnetId)
        }
        if let stagingAreaTags = stagingAreaTags {
            var stagingAreaTagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .stagingAreaTags)
            for (dictKey0, tagsMap0) in stagingAreaTags {
                try stagingAreaTagsContainer.encode(tagsMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let useDedicatedReplicationServer = self.useDedicatedReplicationServer {
            try encodeContainer.encode(useDedicatedReplicationServer, forKey: .useDedicatedReplicationServer)
        }
    }
}

extension UpdateReplicationConfigurationTemplateInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/UpdateReplicationConfigurationTemplate"
    }
}

public struct UpdateReplicationConfigurationTemplateInput: Swift.Equatable {
    /// The Replication Configuration Template ARN.
    public var arn: Swift.String?
    /// Whether to associate the default Elastic Disaster Recovery Security group with the Replication Configuration Template.
    public var associateDefaultSecurityGroup: Swift.Bool?
    /// Whether to allow the AWS replication agent to automatically replicate newly added disks.
    public var autoReplicateNewDisks: Swift.Bool?
    /// Configure bandwidth throttling for the outbound data transfer rate of the Source Server in Mbps.
    public var bandwidthThrottling: Swift.Int
    /// Whether to create a Public IP for the Recovery Instance by default.
    public var createPublicIP: Swift.Bool?
    /// The data plane routing mechanism that will be used for replication.
    public var dataPlaneRouting: DrsClientTypes.ReplicationConfigurationDataPlaneRouting?
    /// The Staging Disk EBS volume type to be used during replication.
    public var defaultLargeStagingDiskType: DrsClientTypes.ReplicationConfigurationDefaultLargeStagingDiskType?
    /// The type of EBS encryption to be used during replication.
    public var ebsEncryption: DrsClientTypes.ReplicationConfigurationEbsEncryption?
    /// The ARN of the EBS encryption key to be used during replication.
    public var ebsEncryptionKeyArn: Swift.String?
    /// The Point in time (PIT) policy to manage snapshots taken during replication.
    public var pitPolicy: [DrsClientTypes.PITPolicyRule]?
    /// The Replication Configuration Template ID.
    /// This member is required.
    public var replicationConfigurationTemplateID: Swift.String?
    /// The instance type to be used for the replication server.
    public var replicationServerInstanceType: Swift.String?
    /// The security group IDs that will be used by the replication server.
    public var replicationServersSecurityGroupsIDs: [Swift.String]?
    /// The subnet to be used by the replication staging area.
    public var stagingAreaSubnetId: Swift.String?
    /// A set of tags to be associated with all resources created in the replication staging area: EC2 replication server, EBS volumes, EBS snapshots, etc.
    public var stagingAreaTags: [Swift.String:Swift.String]?
    /// Whether to use a dedicated Replication Server in the replication staging area.
    public var useDedicatedReplicationServer: Swift.Bool?

    public init(
        arn: Swift.String? = nil,
        associateDefaultSecurityGroup: Swift.Bool? = nil,
        autoReplicateNewDisks: Swift.Bool? = nil,
        bandwidthThrottling: Swift.Int = 0,
        createPublicIP: Swift.Bool? = nil,
        dataPlaneRouting: DrsClientTypes.ReplicationConfigurationDataPlaneRouting? = nil,
        defaultLargeStagingDiskType: DrsClientTypes.ReplicationConfigurationDefaultLargeStagingDiskType? = nil,
        ebsEncryption: DrsClientTypes.ReplicationConfigurationEbsEncryption? = nil,
        ebsEncryptionKeyArn: Swift.String? = nil,
        pitPolicy: [DrsClientTypes.PITPolicyRule]? = nil,
        replicationConfigurationTemplateID: Swift.String? = nil,
        replicationServerInstanceType: Swift.String? = nil,
        replicationServersSecurityGroupsIDs: [Swift.String]? = nil,
        stagingAreaSubnetId: Swift.String? = nil,
        stagingAreaTags: [Swift.String:Swift.String]? = nil,
        useDedicatedReplicationServer: Swift.Bool? = nil
    )
    {
        self.arn = arn
        self.associateDefaultSecurityGroup = associateDefaultSecurityGroup
        self.autoReplicateNewDisks = autoReplicateNewDisks
        self.bandwidthThrottling = bandwidthThrottling
        self.createPublicIP = createPublicIP
        self.dataPlaneRouting = dataPlaneRouting
        self.defaultLargeStagingDiskType = defaultLargeStagingDiskType
        self.ebsEncryption = ebsEncryption
        self.ebsEncryptionKeyArn = ebsEncryptionKeyArn
        self.pitPolicy = pitPolicy
        self.replicationConfigurationTemplateID = replicationConfigurationTemplateID
        self.replicationServerInstanceType = replicationServerInstanceType
        self.replicationServersSecurityGroupsIDs = replicationServersSecurityGroupsIDs
        self.stagingAreaSubnetId = stagingAreaSubnetId
        self.stagingAreaTags = stagingAreaTags
        self.useDedicatedReplicationServer = useDedicatedReplicationServer
    }
}

struct UpdateReplicationConfigurationTemplateInputBody: Swift.Equatable {
    let replicationConfigurationTemplateID: Swift.String?
    let arn: Swift.String?
    let stagingAreaSubnetId: Swift.String?
    let associateDefaultSecurityGroup: Swift.Bool?
    let replicationServersSecurityGroupsIDs: [Swift.String]?
    let replicationServerInstanceType: Swift.String?
    let useDedicatedReplicationServer: Swift.Bool?
    let defaultLargeStagingDiskType: DrsClientTypes.ReplicationConfigurationDefaultLargeStagingDiskType?
    let ebsEncryption: DrsClientTypes.ReplicationConfigurationEbsEncryption?
    let ebsEncryptionKeyArn: Swift.String?
    let bandwidthThrottling: Swift.Int
    let dataPlaneRouting: DrsClientTypes.ReplicationConfigurationDataPlaneRouting?
    let createPublicIP: Swift.Bool?
    let stagingAreaTags: [Swift.String:Swift.String]?
    let pitPolicy: [DrsClientTypes.PITPolicyRule]?
    let autoReplicateNewDisks: Swift.Bool?
}

extension UpdateReplicationConfigurationTemplateInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case associateDefaultSecurityGroup
        case autoReplicateNewDisks
        case bandwidthThrottling
        case createPublicIP
        case dataPlaneRouting
        case defaultLargeStagingDiskType
        case ebsEncryption
        case ebsEncryptionKeyArn
        case pitPolicy
        case replicationConfigurationTemplateID
        case replicationServerInstanceType
        case replicationServersSecurityGroupsIDs
        case stagingAreaSubnetId
        case stagingAreaTags
        case useDedicatedReplicationServer
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationConfigurationTemplateIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationConfigurationTemplateID)
        replicationConfigurationTemplateID = replicationConfigurationTemplateIDDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let stagingAreaSubnetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stagingAreaSubnetId)
        stagingAreaSubnetId = stagingAreaSubnetIdDecoded
        let associateDefaultSecurityGroupDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .associateDefaultSecurityGroup)
        associateDefaultSecurityGroup = associateDefaultSecurityGroupDecoded
        let replicationServersSecurityGroupsIDsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .replicationServersSecurityGroupsIDs)
        var replicationServersSecurityGroupsIDsDecoded0:[Swift.String]? = nil
        if let replicationServersSecurityGroupsIDsContainer = replicationServersSecurityGroupsIDsContainer {
            replicationServersSecurityGroupsIDsDecoded0 = [Swift.String]()
            for string0 in replicationServersSecurityGroupsIDsContainer {
                if let string0 = string0 {
                    replicationServersSecurityGroupsIDsDecoded0?.append(string0)
                }
            }
        }
        replicationServersSecurityGroupsIDs = replicationServersSecurityGroupsIDsDecoded0
        let replicationServerInstanceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationServerInstanceType)
        replicationServerInstanceType = replicationServerInstanceTypeDecoded
        let useDedicatedReplicationServerDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .useDedicatedReplicationServer)
        useDedicatedReplicationServer = useDedicatedReplicationServerDecoded
        let defaultLargeStagingDiskTypeDecoded = try containerValues.decodeIfPresent(DrsClientTypes.ReplicationConfigurationDefaultLargeStagingDiskType.self, forKey: .defaultLargeStagingDiskType)
        defaultLargeStagingDiskType = defaultLargeStagingDiskTypeDecoded
        let ebsEncryptionDecoded = try containerValues.decodeIfPresent(DrsClientTypes.ReplicationConfigurationEbsEncryption.self, forKey: .ebsEncryption)
        ebsEncryption = ebsEncryptionDecoded
        let ebsEncryptionKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ebsEncryptionKeyArn)
        ebsEncryptionKeyArn = ebsEncryptionKeyArnDecoded
        let bandwidthThrottlingDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .bandwidthThrottling) ?? 0
        bandwidthThrottling = bandwidthThrottlingDecoded
        let dataPlaneRoutingDecoded = try containerValues.decodeIfPresent(DrsClientTypes.ReplicationConfigurationDataPlaneRouting.self, forKey: .dataPlaneRouting)
        dataPlaneRouting = dataPlaneRoutingDecoded
        let createPublicIPDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .createPublicIP)
        createPublicIP = createPublicIPDecoded
        let stagingAreaTagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .stagingAreaTags)
        var stagingAreaTagsDecoded0: [Swift.String:Swift.String]? = nil
        if let stagingAreaTagsContainer = stagingAreaTagsContainer {
            stagingAreaTagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in stagingAreaTagsContainer {
                if let tagvalue0 = tagvalue0 {
                    stagingAreaTagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        stagingAreaTags = stagingAreaTagsDecoded0
        let pitPolicyContainer = try containerValues.decodeIfPresent([DrsClientTypes.PITPolicyRule?].self, forKey: .pitPolicy)
        var pitPolicyDecoded0:[DrsClientTypes.PITPolicyRule]? = nil
        if let pitPolicyContainer = pitPolicyContainer {
            pitPolicyDecoded0 = [DrsClientTypes.PITPolicyRule]()
            for structure0 in pitPolicyContainer {
                if let structure0 = structure0 {
                    pitPolicyDecoded0?.append(structure0)
                }
            }
        }
        pitPolicy = pitPolicyDecoded0
        let autoReplicateNewDisksDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .autoReplicateNewDisks)
        autoReplicateNewDisks = autoReplicateNewDisksDecoded
    }
}

extension UpdateReplicationConfigurationTemplateOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateReplicationConfigurationTemplateOutput(arn: \(Swift.String(describing: arn)), associateDefaultSecurityGroup: \(Swift.String(describing: associateDefaultSecurityGroup)), autoReplicateNewDisks: \(Swift.String(describing: autoReplicateNewDisks)), bandwidthThrottling: \(Swift.String(describing: bandwidthThrottling)), createPublicIP: \(Swift.String(describing: createPublicIP)), dataPlaneRouting: \(Swift.String(describing: dataPlaneRouting)), defaultLargeStagingDiskType: \(Swift.String(describing: defaultLargeStagingDiskType)), ebsEncryption: \(Swift.String(describing: ebsEncryption)), ebsEncryptionKeyArn: \(Swift.String(describing: ebsEncryptionKeyArn)), pitPolicy: \(Swift.String(describing: pitPolicy)), replicationConfigurationTemplateID: \(Swift.String(describing: replicationConfigurationTemplateID)), replicationServerInstanceType: \(Swift.String(describing: replicationServerInstanceType)), replicationServersSecurityGroupsIDs: \(Swift.String(describing: replicationServersSecurityGroupsIDs)), stagingAreaSubnetId: \(Swift.String(describing: stagingAreaSubnetId)), useDedicatedReplicationServer: \(Swift.String(describing: useDedicatedReplicationServer)), stagingAreaTags: \"CONTENT_REDACTED\", tags: \"CONTENT_REDACTED\")"}
}

extension UpdateReplicationConfigurationTemplateOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateReplicationConfigurationTemplateOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.associateDefaultSecurityGroup = output.associateDefaultSecurityGroup
            self.autoReplicateNewDisks = output.autoReplicateNewDisks
            self.bandwidthThrottling = output.bandwidthThrottling
            self.createPublicIP = output.createPublicIP
            self.dataPlaneRouting = output.dataPlaneRouting
            self.defaultLargeStagingDiskType = output.defaultLargeStagingDiskType
            self.ebsEncryption = output.ebsEncryption
            self.ebsEncryptionKeyArn = output.ebsEncryptionKeyArn
            self.pitPolicy = output.pitPolicy
            self.replicationConfigurationTemplateID = output.replicationConfigurationTemplateID
            self.replicationServerInstanceType = output.replicationServerInstanceType
            self.replicationServersSecurityGroupsIDs = output.replicationServersSecurityGroupsIDs
            self.stagingAreaSubnetId = output.stagingAreaSubnetId
            self.stagingAreaTags = output.stagingAreaTags
            self.tags = output.tags
            self.useDedicatedReplicationServer = output.useDedicatedReplicationServer
        } else {
            self.arn = nil
            self.associateDefaultSecurityGroup = nil
            self.autoReplicateNewDisks = nil
            self.bandwidthThrottling = 0
            self.createPublicIP = nil
            self.dataPlaneRouting = nil
            self.defaultLargeStagingDiskType = nil
            self.ebsEncryption = nil
            self.ebsEncryptionKeyArn = nil
            self.pitPolicy = nil
            self.replicationConfigurationTemplateID = nil
            self.replicationServerInstanceType = nil
            self.replicationServersSecurityGroupsIDs = nil
            self.stagingAreaSubnetId = nil
            self.stagingAreaTags = nil
            self.tags = nil
            self.useDedicatedReplicationServer = nil
        }
    }
}

public struct UpdateReplicationConfigurationTemplateOutput: Swift.Equatable {
    /// The Replication Configuration Template ARN.
    public var arn: Swift.String?
    /// Whether to associate the default Elastic Disaster Recovery Security group with the Replication Configuration Template.
    public var associateDefaultSecurityGroup: Swift.Bool?
    /// Whether to allow the AWS replication agent to automatically replicate newly added disks.
    public var autoReplicateNewDisks: Swift.Bool?
    /// Configure bandwidth throttling for the outbound data transfer rate of the Source Server in Mbps.
    public var bandwidthThrottling: Swift.Int
    /// Whether to create a Public IP for the Recovery Instance by default.
    public var createPublicIP: Swift.Bool?
    /// The data plane routing mechanism that will be used for replication.
    public var dataPlaneRouting: DrsClientTypes.ReplicationConfigurationDataPlaneRouting?
    /// The Staging Disk EBS volume type to be used during replication.
    public var defaultLargeStagingDiskType: DrsClientTypes.ReplicationConfigurationDefaultLargeStagingDiskType?
    /// The type of EBS encryption to be used during replication.
    public var ebsEncryption: DrsClientTypes.ReplicationConfigurationEbsEncryption?
    /// The ARN of the EBS encryption key to be used during replication.
    public var ebsEncryptionKeyArn: Swift.String?
    /// The Point in time (PIT) policy to manage snapshots taken during replication.
    public var pitPolicy: [DrsClientTypes.PITPolicyRule]?
    /// The Replication Configuration Template ID.
    /// This member is required.
    public var replicationConfigurationTemplateID: Swift.String?
    /// The instance type to be used for the replication server.
    public var replicationServerInstanceType: Swift.String?
    /// The security group IDs that will be used by the replication server.
    public var replicationServersSecurityGroupsIDs: [Swift.String]?
    /// The subnet to be used by the replication staging area.
    public var stagingAreaSubnetId: Swift.String?
    /// A set of tags to be associated with all resources created in the replication staging area: EC2 replication server, EBS volumes, EBS snapshots, etc.
    public var stagingAreaTags: [Swift.String:Swift.String]?
    /// A set of tags to be associated with the Replication Configuration Template resource.
    public var tags: [Swift.String:Swift.String]?
    /// Whether to use a dedicated Replication Server in the replication staging area.
    public var useDedicatedReplicationServer: Swift.Bool?

    public init(
        arn: Swift.String? = nil,
        associateDefaultSecurityGroup: Swift.Bool? = nil,
        autoReplicateNewDisks: Swift.Bool? = nil,
        bandwidthThrottling: Swift.Int = 0,
        createPublicIP: Swift.Bool? = nil,
        dataPlaneRouting: DrsClientTypes.ReplicationConfigurationDataPlaneRouting? = nil,
        defaultLargeStagingDiskType: DrsClientTypes.ReplicationConfigurationDefaultLargeStagingDiskType? = nil,
        ebsEncryption: DrsClientTypes.ReplicationConfigurationEbsEncryption? = nil,
        ebsEncryptionKeyArn: Swift.String? = nil,
        pitPolicy: [DrsClientTypes.PITPolicyRule]? = nil,
        replicationConfigurationTemplateID: Swift.String? = nil,
        replicationServerInstanceType: Swift.String? = nil,
        replicationServersSecurityGroupsIDs: [Swift.String]? = nil,
        stagingAreaSubnetId: Swift.String? = nil,
        stagingAreaTags: [Swift.String:Swift.String]? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        useDedicatedReplicationServer: Swift.Bool? = nil
    )
    {
        self.arn = arn
        self.associateDefaultSecurityGroup = associateDefaultSecurityGroup
        self.autoReplicateNewDisks = autoReplicateNewDisks
        self.bandwidthThrottling = bandwidthThrottling
        self.createPublicIP = createPublicIP
        self.dataPlaneRouting = dataPlaneRouting
        self.defaultLargeStagingDiskType = defaultLargeStagingDiskType
        self.ebsEncryption = ebsEncryption
        self.ebsEncryptionKeyArn = ebsEncryptionKeyArn
        self.pitPolicy = pitPolicy
        self.replicationConfigurationTemplateID = replicationConfigurationTemplateID
        self.replicationServerInstanceType = replicationServerInstanceType
        self.replicationServersSecurityGroupsIDs = replicationServersSecurityGroupsIDs
        self.stagingAreaSubnetId = stagingAreaSubnetId
        self.stagingAreaTags = stagingAreaTags
        self.tags = tags
        self.useDedicatedReplicationServer = useDedicatedReplicationServer
    }
}

struct UpdateReplicationConfigurationTemplateOutputBody: Swift.Equatable {
    let replicationConfigurationTemplateID: Swift.String?
    let arn: Swift.String?
    let stagingAreaSubnetId: Swift.String?
    let associateDefaultSecurityGroup: Swift.Bool?
    let replicationServersSecurityGroupsIDs: [Swift.String]?
    let replicationServerInstanceType: Swift.String?
    let useDedicatedReplicationServer: Swift.Bool?
    let defaultLargeStagingDiskType: DrsClientTypes.ReplicationConfigurationDefaultLargeStagingDiskType?
    let ebsEncryption: DrsClientTypes.ReplicationConfigurationEbsEncryption?
    let ebsEncryptionKeyArn: Swift.String?
    let bandwidthThrottling: Swift.Int
    let dataPlaneRouting: DrsClientTypes.ReplicationConfigurationDataPlaneRouting?
    let createPublicIP: Swift.Bool?
    let stagingAreaTags: [Swift.String:Swift.String]?
    let tags: [Swift.String:Swift.String]?
    let pitPolicy: [DrsClientTypes.PITPolicyRule]?
    let autoReplicateNewDisks: Swift.Bool?
}

extension UpdateReplicationConfigurationTemplateOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case associateDefaultSecurityGroup
        case autoReplicateNewDisks
        case bandwidthThrottling
        case createPublicIP
        case dataPlaneRouting
        case defaultLargeStagingDiskType
        case ebsEncryption
        case ebsEncryptionKeyArn
        case pitPolicy
        case replicationConfigurationTemplateID
        case replicationServerInstanceType
        case replicationServersSecurityGroupsIDs
        case stagingAreaSubnetId
        case stagingAreaTags
        case tags
        case useDedicatedReplicationServer
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationConfigurationTemplateIDDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationConfigurationTemplateID)
        replicationConfigurationTemplateID = replicationConfigurationTemplateIDDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let stagingAreaSubnetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .stagingAreaSubnetId)
        stagingAreaSubnetId = stagingAreaSubnetIdDecoded
        let associateDefaultSecurityGroupDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .associateDefaultSecurityGroup)
        associateDefaultSecurityGroup = associateDefaultSecurityGroupDecoded
        let replicationServersSecurityGroupsIDsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .replicationServersSecurityGroupsIDs)
        var replicationServersSecurityGroupsIDsDecoded0:[Swift.String]? = nil
        if let replicationServersSecurityGroupsIDsContainer = replicationServersSecurityGroupsIDsContainer {
            replicationServersSecurityGroupsIDsDecoded0 = [Swift.String]()
            for string0 in replicationServersSecurityGroupsIDsContainer {
                if let string0 = string0 {
                    replicationServersSecurityGroupsIDsDecoded0?.append(string0)
                }
            }
        }
        replicationServersSecurityGroupsIDs = replicationServersSecurityGroupsIDsDecoded0
        let replicationServerInstanceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .replicationServerInstanceType)
        replicationServerInstanceType = replicationServerInstanceTypeDecoded
        let useDedicatedReplicationServerDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .useDedicatedReplicationServer)
        useDedicatedReplicationServer = useDedicatedReplicationServerDecoded
        let defaultLargeStagingDiskTypeDecoded = try containerValues.decodeIfPresent(DrsClientTypes.ReplicationConfigurationDefaultLargeStagingDiskType.self, forKey: .defaultLargeStagingDiskType)
        defaultLargeStagingDiskType = defaultLargeStagingDiskTypeDecoded
        let ebsEncryptionDecoded = try containerValues.decodeIfPresent(DrsClientTypes.ReplicationConfigurationEbsEncryption.self, forKey: .ebsEncryption)
        ebsEncryption = ebsEncryptionDecoded
        let ebsEncryptionKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ebsEncryptionKeyArn)
        ebsEncryptionKeyArn = ebsEncryptionKeyArnDecoded
        let bandwidthThrottlingDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .bandwidthThrottling) ?? 0
        bandwidthThrottling = bandwidthThrottlingDecoded
        let dataPlaneRoutingDecoded = try containerValues.decodeIfPresent(DrsClientTypes.ReplicationConfigurationDataPlaneRouting.self, forKey: .dataPlaneRouting)
        dataPlaneRouting = dataPlaneRoutingDecoded
        let createPublicIPDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .createPublicIP)
        createPublicIP = createPublicIPDecoded
        let stagingAreaTagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .stagingAreaTags)
        var stagingAreaTagsDecoded0: [Swift.String:Swift.String]? = nil
        if let stagingAreaTagsContainer = stagingAreaTagsContainer {
            stagingAreaTagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in stagingAreaTagsContainer {
                if let tagvalue0 = tagvalue0 {
                    stagingAreaTagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        stagingAreaTags = stagingAreaTagsDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let pitPolicyContainer = try containerValues.decodeIfPresent([DrsClientTypes.PITPolicyRule?].self, forKey: .pitPolicy)
        var pitPolicyDecoded0:[DrsClientTypes.PITPolicyRule]? = nil
        if let pitPolicyContainer = pitPolicyContainer {
            pitPolicyDecoded0 = [DrsClientTypes.PITPolicyRule]()
            for structure0 in pitPolicyContainer {
                if let structure0 = structure0 {
                    pitPolicyDecoded0?.append(structure0)
                }
            }
        }
        pitPolicy = pitPolicyDecoded0
        let autoReplicateNewDisksDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .autoReplicateNewDisks)
        autoReplicateNewDisks = autoReplicateNewDisksDecoded
    }
}

enum UpdateReplicationConfigurationTemplateOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UninitializedAccountException": return try await UninitializedAccountException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ValidationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.code = output.code
            self.properties.fieldList = output.fieldList
            self.properties.message = output.message
            self.properties.reason = output.reason
        } else {
            self.properties.code = nil
            self.properties.fieldList = nil
            self.properties.message = nil
            self.properties.reason = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The input fails to satisfy the constraints specified by the AWS service.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var code: Swift.String? = nil
        /// A list of fields that failed validation.
        public internal(set) var fieldList: [DrsClientTypes.ValidationExceptionField]? = nil
        public internal(set) var message: Swift.String? = nil
        /// Validation exception reason.
        public internal(set) var reason: DrsClientTypes.ValidationExceptionReason? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        code: Swift.String? = nil,
        fieldList: [DrsClientTypes.ValidationExceptionField]? = nil,
        message: Swift.String? = nil,
        reason: DrsClientTypes.ValidationExceptionReason? = nil
    )
    {
        self.properties.code = code
        self.properties.fieldList = fieldList
        self.properties.message = message
        self.properties.reason = reason
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let code: Swift.String?
    let reason: DrsClientTypes.ValidationExceptionReason?
    let fieldList: [DrsClientTypes.ValidationExceptionField]?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code
        case fieldList
        case message
        case reason
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(DrsClientTypes.ValidationExceptionReason.self, forKey: .reason)
        reason = reasonDecoded
        let fieldListContainer = try containerValues.decodeIfPresent([DrsClientTypes.ValidationExceptionField?].self, forKey: .fieldList)
        var fieldListDecoded0:[DrsClientTypes.ValidationExceptionField]? = nil
        if let fieldListContainer = fieldListContainer {
            fieldListDecoded0 = [DrsClientTypes.ValidationExceptionField]()
            for structure0 in fieldListContainer {
                if let structure0 = structure0 {
                    fieldListDecoded0?.append(structure0)
                }
            }
        }
        fieldList = fieldListDecoded0
    }
}

extension DrsClientTypes.ValidationExceptionField: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension DrsClientTypes {
    /// Validate exception field.
    public struct ValidationExceptionField: Swift.Equatable {
        /// Validate exception field message.
        public var message: Swift.String?
        /// Validate exception field name.
        public var name: Swift.String?

        public init(
            message: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.message = message
            self.name = name
        }
    }

}

extension DrsClientTypes {
    public enum ValidationExceptionReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cannotParse
        case fieldValidationFailed
        case other
        case unknownOperation
        case sdkUnknown(Swift.String)

        public static var allCases: [ValidationExceptionReason] {
            return [
                .cannotParse,
                .fieldValidationFailed,
                .other,
                .unknownOperation,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cannotParse: return "cannotParse"
            case .fieldValidationFailed: return "fieldValidationFailed"
            case .other: return "other"
            case .unknownOperation: return "unknownOperation"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ValidationExceptionReason(rawValue: rawValue) ?? ValidationExceptionReason.sdkUnknown(rawValue)
        }
    }
}
