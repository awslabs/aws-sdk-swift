//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum Smithy.ClientError
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
@_spi(SmithyReadWrite) import func SmithyReadWrite.optionalFormOf
@_spi(SmithyReadWrite) import func SmithyReadWrite.sparseFormOf
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.RestJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
import struct Smithy.URIQueryItem
@_spi(SmithyTimestamps) import struct SmithyTimestamps.TimestampFormatter

public struct DeleteLedgerOutput {

    public init() { }
}

/// One or more parameters in the request aren't valid.
public struct InvalidParameterException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        /// The name of the invalid parameter.
        public internal(set) var parameterName: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidParameterException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        parameterName: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.parameterName = parameterName
    }
}

/// The specified resource doesn't exist.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        /// The name of the resource.
        public internal(set) var resourceName: Swift.String? = nil
        /// The type of resource.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceName: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceName = resourceName
        self.properties.resourceType = resourceType
    }
}

/// The operation failed because a condition wasn't satisfied in advance.
public struct ResourcePreconditionNotMetException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        /// The name of the resource.
        public internal(set) var resourceName: Swift.String? = nil
        /// The type of resource.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourcePreconditionNotMetException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceName: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceName = resourceName
        self.properties.resourceType = resourceType
    }
}

public struct CancelJournalKinesisStreamInput {
    /// The name of the ledger.
    /// This member is required.
    public var ledgerName: Swift.String?
    /// The UUID (represented in Base62-encoded text) of the QLDB journal stream to be canceled.
    /// This member is required.
    public var streamId: Swift.String?

    public init(
        ledgerName: Swift.String? = nil,
        streamId: Swift.String? = nil
    )
    {
        self.ledgerName = ledgerName
        self.streamId = streamId
    }
}

public struct CancelJournalKinesisStreamOutput {
    /// The UUID (Base62-encoded text) of the canceled QLDB journal stream.
    public var streamId: Swift.String?

    public init(
        streamId: Swift.String? = nil
    )
    {
        self.streamId = streamId
    }
}

/// You have reached the limit on the maximum number of resources allowed.
public struct LimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        /// The type of resource.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "LimitExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceType = resourceType
    }
}

/// The specified resource already exists.
public struct ResourceAlreadyExistsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        /// The name of the resource.
        public internal(set) var resourceName: Swift.String? = nil
        /// The type of resource.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceAlreadyExistsException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceName: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceName = resourceName
        self.properties.resourceType = resourceType
    }
}

/// The specified resource can't be modified at this time.
public struct ResourceInUseException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        /// The name of the resource.
        public internal(set) var resourceName: Swift.String? = nil
        /// The type of resource.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceInUseException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceName: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceName = resourceName
        self.properties.resourceType = resourceType
    }
}

extension QLDBClientTypes {

    public enum PermissionsMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case allowAll
        case standard
        case sdkUnknown(Swift.String)

        public static var allCases: [PermissionsMode] {
            return [
                .allowAll,
                .standard
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .allowAll: return "ALLOW_ALL"
            case .standard: return "STANDARD"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateLedgerInput {
    /// Specifies whether the ledger is protected from being deleted by any user. If not defined during ledger creation, this feature is enabled (true) by default. If deletion protection is enabled, you must first disable it before you can delete the ledger. You can disable it by calling the UpdateLedger operation to set this parameter to false.
    public var deletionProtection: Swift.Bool?
    /// The key in Key Management Service (KMS) to use for encryption of data at rest in the ledger. For more information, see [Encryption at rest](https://docs.aws.amazon.com/qldb/latest/developerguide/encryption-at-rest.html) in the Amazon QLDB Developer Guide. Use one of the following options to specify this parameter:
    ///
    /// * AWS_OWNED_KMS_KEY: Use an KMS key that is owned and managed by Amazon Web Services on your behalf.
    ///
    /// * Undefined: By default, use an Amazon Web Services owned KMS key.
    ///
    /// * A valid symmetric customer managed KMS key: Use the specified symmetric encryption KMS key in your account that you create, own, and manage. Amazon QLDB does not support asymmetric keys. For more information, see [Using symmetric and asymmetric keys](https://docs.aws.amazon.com/kms/latest/developerguide/symmetric-asymmetric.html) in the Key Management Service Developer Guide.
    ///
    ///
    /// To specify a customer managed KMS key, you can use its key ID, Amazon Resource Name (ARN), alias name, or alias ARN. When using an alias name, prefix it with "alias/". To specify a key in a different Amazon Web Services account, you must use the key ARN or alias ARN. For example:
    ///
    /// * Key ID: 1234abcd-12ab-34cd-56ef-1234567890ab
    ///
    /// * Key ARN: arn:aws:kms:us-east-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab
    ///
    /// * Alias name: alias/ExampleAlias
    ///
    /// * Alias ARN: arn:aws:kms:us-east-2:111122223333:alias/ExampleAlias
    ///
    ///
    /// For more information, see [Key identifiers (KeyId)](https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#key-id) in the Key Management Service Developer Guide.
    public var kmsKey: Swift.String?
    /// The name of the ledger that you want to create. The name must be unique among all of the ledgers in your Amazon Web Services account in the current Region. Naming constraints for ledger names are defined in [Quotas in Amazon QLDB](https://docs.aws.amazon.com/qldb/latest/developerguide/limits.html#limits.naming) in the Amazon QLDB Developer Guide.
    /// This member is required.
    public var name: Swift.String?
    /// The permissions mode to assign to the ledger that you want to create. This parameter can have one of the following values:
    ///
    /// * ALLOW_ALL: A legacy permissions mode that enables access control with API-level granularity for ledgers. This mode allows users who have the SendCommand API permission for this ledger to run all PartiQL commands (hence, ALLOW_ALL) on any tables in the specified ledger. This mode disregards any table-level or command-level IAM permissions policies that you create for the ledger.
    ///
    /// * STANDARD: (Recommended) A permissions mode that enables access control with finer granularity for ledgers, tables, and PartiQL commands. By default, this mode denies all user requests to run any PartiQL commands on any tables in this ledger. To allow PartiQL commands to run, you must create IAM permissions policies for specific table resources and PartiQL actions, in addition to the SendCommand API permission for the ledger. For information, see [Getting started with the standard permissions mode](https://docs.aws.amazon.com/qldb/latest/developerguide/getting-started-standard-mode.html) in the Amazon QLDB Developer Guide.
    ///
    ///
    /// We strongly recommend using the STANDARD permissions mode to maximize the security of your ledger data.
    /// This member is required.
    public var permissionsMode: QLDBClientTypes.PermissionsMode?
    /// The key-value pairs to add as tags to the ledger that you want to create. Tag keys are case sensitive. Tag values are case sensitive and can be null.
    public var tags: [Swift.String: Swift.String?]?

    public init(
        deletionProtection: Swift.Bool? = nil,
        kmsKey: Swift.String? = nil,
        name: Swift.String? = nil,
        permissionsMode: QLDBClientTypes.PermissionsMode? = nil,
        tags: [Swift.String: Swift.String?]? = nil
    )
    {
        self.deletionProtection = deletionProtection
        self.kmsKey = kmsKey
        self.name = name
        self.permissionsMode = permissionsMode
        self.tags = tags
    }
}

extension QLDBClientTypes {

    public enum LedgerState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case creating
        case deleted
        case deleting
        case sdkUnknown(Swift.String)

        public static var allCases: [LedgerState] {
            return [
                .active,
                .creating,
                .deleted,
                .deleting
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .creating: return "CREATING"
            case .deleted: return "DELETED"
            case .deleting: return "DELETING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateLedgerOutput {
    /// The Amazon Resource Name (ARN) for the ledger.
    public var arn: Swift.String?
    /// The date and time, in epoch time format, when the ledger was created. (Epoch time format is the number of seconds elapsed since 12:00:00 AM January 1, 1970 UTC.)
    public var creationDateTime: Foundation.Date?
    /// Specifies whether the ledger is protected from being deleted by any user. If not defined during ledger creation, this feature is enabled (true) by default. If deletion protection is enabled, you must first disable it before you can delete the ledger. You can disable it by calling the UpdateLedger operation to set this parameter to false.
    public var deletionProtection: Swift.Bool?
    /// The ARN of the customer managed KMS key that the ledger uses for encryption at rest. If this parameter is undefined, the ledger uses an Amazon Web Services owned KMS key for encryption.
    public var kmsKeyArn: Swift.String?
    /// The name of the ledger.
    public var name: Swift.String?
    /// The permissions mode of the ledger that you created.
    public var permissionsMode: QLDBClientTypes.PermissionsMode?
    /// The current status of the ledger.
    public var state: QLDBClientTypes.LedgerState?

    public init(
        arn: Swift.String? = nil,
        creationDateTime: Foundation.Date? = nil,
        deletionProtection: Swift.Bool? = nil,
        kmsKeyArn: Swift.String? = nil,
        name: Swift.String? = nil,
        permissionsMode: QLDBClientTypes.PermissionsMode? = nil,
        state: QLDBClientTypes.LedgerState? = nil
    )
    {
        self.arn = arn
        self.creationDateTime = creationDateTime
        self.deletionProtection = deletionProtection
        self.kmsKeyArn = kmsKeyArn
        self.name = name
        self.permissionsMode = permissionsMode
        self.state = state
    }
}

public struct DeleteLedgerInput {
    /// The name of the ledger that you want to delete.
    /// This member is required.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

public struct DescribeJournalKinesisStreamInput {
    /// The name of the ledger.
    /// This member is required.
    public var ledgerName: Swift.String?
    /// The UUID (represented in Base62-encoded text) of the QLDB journal stream to describe.
    /// This member is required.
    public var streamId: Swift.String?

    public init(
        ledgerName: Swift.String? = nil,
        streamId: Swift.String? = nil
    )
    {
        self.ledgerName = ledgerName
        self.streamId = streamId
    }
}

extension QLDBClientTypes {

    public enum ErrorCause: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case iamPermissionRevoked
        case kinesisStreamNotFound
        case sdkUnknown(Swift.String)

        public static var allCases: [ErrorCause] {
            return [
                .iamPermissionRevoked,
                .kinesisStreamNotFound
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .iamPermissionRevoked: return "IAM_PERMISSION_REVOKED"
            case .kinesisStreamNotFound: return "KINESIS_STREAM_NOT_FOUND"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QLDBClientTypes {
    /// The configuration settings of the Amazon Kinesis Data Streams destination for an Amazon QLDB journal stream.
    public struct KinesisConfiguration {
        /// Enables QLDB to publish multiple data records in a single Kinesis Data Streams record, increasing the number of records sent per API call. Default: True Record aggregation has important implications for processing records and requires de-aggregation in your stream consumer. To learn more, see [KPL Key Concepts](https://docs.aws.amazon.com/streams/latest/dev/kinesis-kpl-concepts.html) and [Consumer De-aggregation](https://docs.aws.amazon.com/streams/latest/dev/kinesis-kpl-consumer-deaggregation.html) in the Amazon Kinesis Data Streams Developer Guide.
        public var aggregationEnabled: Swift.Bool?
        /// The Amazon Resource Name (ARN) of the Kinesis Data Streams resource.
        /// This member is required.
        public var streamArn: Swift.String?

        public init(
            aggregationEnabled: Swift.Bool? = nil,
            streamArn: Swift.String? = nil
        )
        {
            self.aggregationEnabled = aggregationEnabled
            self.streamArn = streamArn
        }
    }

}

extension QLDBClientTypes {

    public enum StreamStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case canceled
        case completed
        case failed
        case impaired
        case sdkUnknown(Swift.String)

        public static var allCases: [StreamStatus] {
            return [
                .active,
                .canceled,
                .completed,
                .failed,
                .impaired
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .canceled: return "CANCELED"
            case .completed: return "COMPLETED"
            case .failed: return "FAILED"
            case .impaired: return "IMPAIRED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QLDBClientTypes {
    /// Information about an Amazon QLDB journal stream, including the Amazon Resource Name (ARN), stream name, creation time, current status, and the parameters of the original stream creation request.
    public struct JournalKinesisStreamDescription {
        /// The Amazon Resource Name (ARN) of the QLDB journal stream.
        public var arn: Swift.String?
        /// The date and time, in epoch time format, when the QLDB journal stream was created. (Epoch time format is the number of seconds elapsed since 12:00:00 AM January 1, 1970 UTC.)
        public var creationTime: Foundation.Date?
        /// The error message that describes the reason that a stream has a status of IMPAIRED or FAILED. This is not applicable to streams that have other status values.
        public var errorCause: QLDBClientTypes.ErrorCause?
        /// The exclusive date and time that specifies when the stream ends. If this parameter is undefined, the stream runs indefinitely until you cancel it.
        public var exclusiveEndTime: Foundation.Date?
        /// The inclusive start date and time from which to start streaming journal data.
        public var inclusiveStartTime: Foundation.Date?
        /// The configuration settings of the Amazon Kinesis Data Streams destination for a QLDB journal stream.
        /// This member is required.
        public var kinesisConfiguration: QLDBClientTypes.KinesisConfiguration?
        /// The name of the ledger.
        /// This member is required.
        public var ledgerName: Swift.String?
        /// The Amazon Resource Name (ARN) of the IAM role that grants QLDB permissions for a journal stream to write data records to a Kinesis Data Streams resource.
        /// This member is required.
        public var roleArn: Swift.String?
        /// The current state of the QLDB journal stream.
        /// This member is required.
        public var status: QLDBClientTypes.StreamStatus?
        /// The UUID (represented in Base62-encoded text) of the QLDB journal stream.
        /// This member is required.
        public var streamId: Swift.String?
        /// The user-defined name of the QLDB journal stream.
        /// This member is required.
        public var streamName: Swift.String?

        public init(
            arn: Swift.String? = nil,
            creationTime: Foundation.Date? = nil,
            errorCause: QLDBClientTypes.ErrorCause? = nil,
            exclusiveEndTime: Foundation.Date? = nil,
            inclusiveStartTime: Foundation.Date? = nil,
            kinesisConfiguration: QLDBClientTypes.KinesisConfiguration? = nil,
            ledgerName: Swift.String? = nil,
            roleArn: Swift.String? = nil,
            status: QLDBClientTypes.StreamStatus? = nil,
            streamId: Swift.String? = nil,
            streamName: Swift.String? = nil
        )
        {
            self.arn = arn
            self.creationTime = creationTime
            self.errorCause = errorCause
            self.exclusiveEndTime = exclusiveEndTime
            self.inclusiveStartTime = inclusiveStartTime
            self.kinesisConfiguration = kinesisConfiguration
            self.ledgerName = ledgerName
            self.roleArn = roleArn
            self.status = status
            self.streamId = streamId
            self.streamName = streamName
        }
    }

}

public struct DescribeJournalKinesisStreamOutput {
    /// Information about the QLDB journal stream returned by a DescribeJournalS3Export request.
    public var stream: QLDBClientTypes.JournalKinesisStreamDescription?

    public init(
        stream: QLDBClientTypes.JournalKinesisStreamDescription? = nil
    )
    {
        self.stream = stream
    }
}

public struct DescribeJournalS3ExportInput {
    /// The UUID (represented in Base62-encoded text) of the journal export job to describe.
    /// This member is required.
    public var exportId: Swift.String?
    /// The name of the ledger.
    /// This member is required.
    public var name: Swift.String?

    public init(
        exportId: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.exportId = exportId
        self.name = name
    }
}

extension QLDBClientTypes {

    public enum OutputFormat: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case ionBinary
        case ionText
        case json
        case sdkUnknown(Swift.String)

        public static var allCases: [OutputFormat] {
            return [
                .ionBinary,
                .ionText,
                .json
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .ionBinary: return "ION_BINARY"
            case .ionText: return "ION_TEXT"
            case .json: return "JSON"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QLDBClientTypes {

    public enum S3ObjectEncryptionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case noEncryption
        case sseKms
        case sseS3
        case sdkUnknown(Swift.String)

        public static var allCases: [S3ObjectEncryptionType] {
            return [
                .noEncryption,
                .sseKms,
                .sseS3
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .noEncryption: return "NO_ENCRYPTION"
            case .sseKms: return "SSE_KMS"
            case .sseS3: return "SSE_S3"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QLDBClientTypes {
    /// The encryption settings that are used by a journal export job to write data in an Amazon Simple Storage Service (Amazon S3) bucket.
    public struct S3EncryptionConfiguration {
        /// The Amazon Resource Name (ARN) of a symmetric encryption key in Key Management Service (KMS). Amazon S3 does not support asymmetric KMS keys. You must provide a KmsKeyArn if you specify SSE_KMS as the ObjectEncryptionType. KmsKeyArn is not required if you specify SSE_S3 as the ObjectEncryptionType.
        public var kmsKeyArn: Swift.String?
        /// The Amazon S3 object encryption type. To learn more about server-side encryption options in Amazon S3, see [Protecting Data Using Server-Side Encryption](https://docs.aws.amazon.com/AmazonS3/latest/dev/serv-side-encryption.html) in the Amazon S3 Developer Guide.
        /// This member is required.
        public var objectEncryptionType: QLDBClientTypes.S3ObjectEncryptionType?

        public init(
            kmsKeyArn: Swift.String? = nil,
            objectEncryptionType: QLDBClientTypes.S3ObjectEncryptionType? = nil
        )
        {
            self.kmsKeyArn = kmsKeyArn
            self.objectEncryptionType = objectEncryptionType
        }
    }

}

extension QLDBClientTypes {
    /// The Amazon Simple Storage Service (Amazon S3) bucket location in which a journal export job writes the journal contents.
    public struct S3ExportConfiguration {
        /// The Amazon S3 bucket name in which a journal export job writes the journal contents. The bucket name must comply with the Amazon S3 bucket naming conventions. For more information, see [Bucket Restrictions and Limitations](https://docs.aws.amazon.com/AmazonS3/latest/dev/BucketRestrictions.html) in the Amazon S3 Developer Guide.
        /// This member is required.
        public var bucket: Swift.String?
        /// The encryption settings that are used by a journal export job to write data in an Amazon S3 bucket.
        /// This member is required.
        public var encryptionConfiguration: QLDBClientTypes.S3EncryptionConfiguration?
        /// The prefix for the Amazon S3 bucket in which a journal export job writes the journal contents. The prefix must comply with Amazon S3 key naming rules and restrictions. For more information, see [Object Key and Metadata](https://docs.aws.amazon.com/AmazonS3/latest/dev/UsingMetadata.html) in the Amazon S3 Developer Guide. The following are examples of valid Prefix values:
        ///
        /// * JournalExports-ForMyLedger/Testing/
        ///
        /// * JournalExports
        ///
        /// * My:Tests/
        /// This member is required.
        public var `prefix`: Swift.String?

        public init(
            bucket: Swift.String? = nil,
            encryptionConfiguration: QLDBClientTypes.S3EncryptionConfiguration? = nil,
            `prefix`: Swift.String? = nil
        )
        {
            self.bucket = bucket
            self.encryptionConfiguration = encryptionConfiguration
            self.`prefix` = `prefix`
        }
    }

}

extension QLDBClientTypes {

    public enum ExportStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case cancelled
        case completed
        case inProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [ExportStatus] {
            return [
                .cancelled,
                .completed,
                .inProgress
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .cancelled: return "CANCELLED"
            case .completed: return "COMPLETED"
            case .inProgress: return "IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QLDBClientTypes {
    /// Information about a journal export job, including the ledger name, export ID, creation time, current status, and the parameters of the original export creation request.
    public struct JournalS3ExportDescription {
        /// The exclusive end date and time for the range of journal contents that was specified in the original export request.
        /// This member is required.
        public var exclusiveEndTime: Foundation.Date?
        /// The date and time, in epoch time format, when the export job was created. (Epoch time format is the number of seconds elapsed since 12:00:00 AM January 1, 1970 UTC.)
        /// This member is required.
        public var exportCreationTime: Foundation.Date?
        /// The UUID (represented in Base62-encoded text) of the journal export job.
        /// This member is required.
        public var exportId: Swift.String?
        /// The inclusive start date and time for the range of journal contents that was specified in the original export request.
        /// This member is required.
        public var inclusiveStartTime: Foundation.Date?
        /// The name of the ledger.
        /// This member is required.
        public var ledgerName: Swift.String?
        /// The output format of the exported journal data.
        public var outputFormat: QLDBClientTypes.OutputFormat?
        /// The Amazon Resource Name (ARN) of the IAM role that grants QLDB permissions for a journal export job to do the following:
        ///
        /// * Write objects into your Amazon Simple Storage Service (Amazon S3) bucket.
        ///
        /// * (Optional) Use your customer managed key in Key Management Service (KMS) for server-side encryption of your exported data.
        /// This member is required.
        public var roleArn: Swift.String?
        /// The Amazon Simple Storage Service (Amazon S3) bucket location in which a journal export job writes the journal contents.
        /// This member is required.
        public var s3ExportConfiguration: QLDBClientTypes.S3ExportConfiguration?
        /// The current state of the journal export job.
        /// This member is required.
        public var status: QLDBClientTypes.ExportStatus?

        public init(
            exclusiveEndTime: Foundation.Date? = nil,
            exportCreationTime: Foundation.Date? = nil,
            exportId: Swift.String? = nil,
            inclusiveStartTime: Foundation.Date? = nil,
            ledgerName: Swift.String? = nil,
            outputFormat: QLDBClientTypes.OutputFormat? = nil,
            roleArn: Swift.String? = nil,
            s3ExportConfiguration: QLDBClientTypes.S3ExportConfiguration? = nil,
            status: QLDBClientTypes.ExportStatus? = nil
        )
        {
            self.exclusiveEndTime = exclusiveEndTime
            self.exportCreationTime = exportCreationTime
            self.exportId = exportId
            self.inclusiveStartTime = inclusiveStartTime
            self.ledgerName = ledgerName
            self.outputFormat = outputFormat
            self.roleArn = roleArn
            self.s3ExportConfiguration = s3ExportConfiguration
            self.status = status
        }
    }

}

public struct DescribeJournalS3ExportOutput {
    /// Information about the journal export job returned by a DescribeJournalS3Export request.
    /// This member is required.
    public var exportDescription: QLDBClientTypes.JournalS3ExportDescription?

    public init(
        exportDescription: QLDBClientTypes.JournalS3ExportDescription? = nil
    )
    {
        self.exportDescription = exportDescription
    }
}

public struct DescribeLedgerInput {
    /// The name of the ledger that you want to describe.
    /// This member is required.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

extension QLDBClientTypes {

    public enum EncryptionStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case enabled
        case kmsKeyInaccessible
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [EncryptionStatus] {
            return [
                .enabled,
                .kmsKeyInaccessible,
                .updating
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .enabled: return "ENABLED"
            case .kmsKeyInaccessible: return "KMS_KEY_INACCESSIBLE"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension QLDBClientTypes {
    /// Information about the encryption of data at rest in an Amazon QLDB ledger. This includes the current status, the key in Key Management Service (KMS), and when the key became inaccessible (in the case of an error). For more information, see [Encryption at rest](https://docs.aws.amazon.com/qldb/latest/developerguide/encryption-at-rest.html) in the Amazon QLDB Developer Guide.
    public struct LedgerEncryptionDescription {
        /// The current state of encryption at rest for the ledger. This can be one of the following values:
        ///
        /// * ENABLED: Encryption is fully enabled using the specified key.
        ///
        /// * UPDATING: The ledger is actively processing the specified key change. Key changes in QLDB are asynchronous. The ledger is fully accessible without any performance impact while the key change is being processed. The amount of time it takes to update a key varies depending on the ledger size.
        ///
        /// * KMS_KEY_INACCESSIBLE: The specified customer managed KMS key is not accessible, and the ledger is impaired. Either the key was disabled or deleted, or the grants on the key were revoked. When a ledger is impaired, it is not accessible and does not accept any read or write requests. An impaired ledger automatically returns to an active state after you restore the grants on the key, or re-enable the key that was disabled. However, deleting a customer managed KMS key is irreversible. After a key is deleted, you can no longer access the ledgers that are protected with that key, and the data becomes unrecoverable permanently.
        /// This member is required.
        public var encryptionStatus: QLDBClientTypes.EncryptionStatus?
        /// The date and time, in epoch time format, when the KMS key first became inaccessible, in the case of an error. (Epoch time format is the number of seconds that have elapsed since 12:00:00 AM January 1, 1970 UTC.) This parameter is undefined if the KMS key is accessible.
        public var inaccessibleKmsKeyDateTime: Foundation.Date?
        /// The Amazon Resource Name (ARN) of the customer managed KMS key that the ledger uses for encryption at rest. If this parameter is undefined, the ledger uses an Amazon Web Services owned KMS key for encryption. It will display AWS_OWNED_KMS_KEY when updating the ledger's encryption configuration to the Amazon Web Services owned KMS key.
        /// This member is required.
        public var kmsKeyArn: Swift.String?

        public init(
            encryptionStatus: QLDBClientTypes.EncryptionStatus? = nil,
            inaccessibleKmsKeyDateTime: Foundation.Date? = nil,
            kmsKeyArn: Swift.String? = nil
        )
        {
            self.encryptionStatus = encryptionStatus
            self.inaccessibleKmsKeyDateTime = inaccessibleKmsKeyDateTime
            self.kmsKeyArn = kmsKeyArn
        }
    }

}

public struct DescribeLedgerOutput {
    /// The Amazon Resource Name (ARN) for the ledger.
    public var arn: Swift.String?
    /// The date and time, in epoch time format, when the ledger was created. (Epoch time format is the number of seconds elapsed since 12:00:00 AM January 1, 1970 UTC.)
    public var creationDateTime: Foundation.Date?
    /// Specifies whether the ledger is protected from being deleted by any user. If not defined during ledger creation, this feature is enabled (true) by default. If deletion protection is enabled, you must first disable it before you can delete the ledger. You can disable it by calling the UpdateLedger operation to set this parameter to false.
    public var deletionProtection: Swift.Bool?
    /// Information about the encryption of data at rest in the ledger. This includes the current status, the KMS key, and when the key became inaccessible (in the case of an error). If this parameter is undefined, the ledger uses an Amazon Web Services owned KMS key for encryption.
    public var encryptionDescription: QLDBClientTypes.LedgerEncryptionDescription?
    /// The name of the ledger.
    public var name: Swift.String?
    /// The permissions mode of the ledger.
    public var permissionsMode: QLDBClientTypes.PermissionsMode?
    /// The current status of the ledger.
    public var state: QLDBClientTypes.LedgerState?

    public init(
        arn: Swift.String? = nil,
        creationDateTime: Foundation.Date? = nil,
        deletionProtection: Swift.Bool? = nil,
        encryptionDescription: QLDBClientTypes.LedgerEncryptionDescription? = nil,
        name: Swift.String? = nil,
        permissionsMode: QLDBClientTypes.PermissionsMode? = nil,
        state: QLDBClientTypes.LedgerState? = nil
    )
    {
        self.arn = arn
        self.creationDateTime = creationDateTime
        self.deletionProtection = deletionProtection
        self.encryptionDescription = encryptionDescription
        self.name = name
        self.permissionsMode = permissionsMode
        self.state = state
    }
}

public struct ExportJournalToS3Input {
    /// The exclusive end date and time for the range of journal contents to export. The ExclusiveEndTime must be in ISO 8601 date and time format and in Universal Coordinated Time (UTC). For example: 2019-06-13T21:36:34Z. The ExclusiveEndTime must be less than or equal to the current UTC date and time.
    /// This member is required.
    public var exclusiveEndTime: Foundation.Date?
    /// The inclusive start date and time for the range of journal contents to export. The InclusiveStartTime must be in ISO 8601 date and time format and in Universal Coordinated Time (UTC). For example: 2019-06-13T21:36:34Z. The InclusiveStartTime must be before ExclusiveEndTime. If you provide an InclusiveStartTime that is before the ledger's CreationDateTime, Amazon QLDB defaults it to the ledger's CreationDateTime.
    /// This member is required.
    public var inclusiveStartTime: Foundation.Date?
    /// The name of the ledger.
    /// This member is required.
    public var name: Swift.String?
    /// The output format of your exported journal data. A journal export job can write the data objects in either the text or binary representation of [Amazon Ion](https://docs.aws.amazon.com/qldb/latest/developerguide/ion.html) format, or in [JSON Lines](https://jsonlines.org/) text format. Default: ION_TEXT In JSON Lines format, each journal block in an exported data object is a valid JSON object that is delimited by a newline. You can use this format to directly integrate JSON exports with analytics tools such as Amazon Athena and Glue because these services can parse newline-delimited JSON automatically.
    public var outputFormat: QLDBClientTypes.OutputFormat?
    /// The Amazon Resource Name (ARN) of the IAM role that grants QLDB permissions for a journal export job to do the following:
    ///
    /// * Write objects into your Amazon S3 bucket.
    ///
    /// * (Optional) Use your customer managed key in Key Management Service (KMS) for server-side encryption of your exported data.
    ///
    ///
    /// To pass a role to QLDB when requesting a journal export, you must have permissions to perform the iam:PassRole action on the IAM role resource. This is required for all journal export requests.
    /// This member is required.
    public var roleArn: Swift.String?
    /// The configuration settings of the Amazon S3 bucket destination for your export request.
    /// This member is required.
    public var s3ExportConfiguration: QLDBClientTypes.S3ExportConfiguration?

    public init(
        exclusiveEndTime: Foundation.Date? = nil,
        inclusiveStartTime: Foundation.Date? = nil,
        name: Swift.String? = nil,
        outputFormat: QLDBClientTypes.OutputFormat? = nil,
        roleArn: Swift.String? = nil,
        s3ExportConfiguration: QLDBClientTypes.S3ExportConfiguration? = nil
    )
    {
        self.exclusiveEndTime = exclusiveEndTime
        self.inclusiveStartTime = inclusiveStartTime
        self.name = name
        self.outputFormat = outputFormat
        self.roleArn = roleArn
        self.s3ExportConfiguration = s3ExportConfiguration
    }
}

public struct ExportJournalToS3Output {
    /// The UUID (represented in Base62-encoded text) that QLDB assigns to each journal export job. To describe your export request and check the status of the job, you can use ExportId to call DescribeJournalS3Export.
    /// This member is required.
    public var exportId: Swift.String?

    public init(
        exportId: Swift.String? = nil
    )
    {
        self.exportId = exportId
    }
}

extension QLDBClientTypes {
    /// A structure that can contain a value in multiple encoding formats.
    public struct ValueHolder {
        /// An Amazon Ion plaintext value contained in a ValueHolder structure.
        public var ionText: Swift.String?

        public init(
            ionText: Swift.String? = nil
        )
        {
            self.ionText = ionText
        }
    }

}

extension QLDBClientTypes.ValueHolder: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

public struct GetBlockInput {
    /// The location of the block that you want to request. An address is an Amazon Ion structure that has two fields: strandId and sequenceNo. For example: {strandId:"BlFTjlSXze9BIh1KOszcE3",sequenceNo:14}.
    /// This member is required.
    public var blockAddress: QLDBClientTypes.ValueHolder?
    /// The latest block location covered by the digest for which to request a proof. An address is an Amazon Ion structure that has two fields: strandId and sequenceNo. For example: {strandId:"BlFTjlSXze9BIh1KOszcE3",sequenceNo:49}.
    public var digestTipAddress: QLDBClientTypes.ValueHolder?
    /// The name of the ledger.
    /// This member is required.
    public var name: Swift.String?

    public init(
        blockAddress: QLDBClientTypes.ValueHolder? = nil,
        digestTipAddress: QLDBClientTypes.ValueHolder? = nil,
        name: Swift.String? = nil
    )
    {
        self.blockAddress = blockAddress
        self.digestTipAddress = digestTipAddress
        self.name = name
    }
}

extension GetBlockInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetBlockInput(name: \(Swift.String(describing: name)), blockAddress: \"CONTENT_REDACTED\", digestTipAddress: \"CONTENT_REDACTED\")"}
}

public struct GetBlockOutput {
    /// The block data object in Amazon Ion format.
    /// This member is required.
    public var block: QLDBClientTypes.ValueHolder?
    /// The proof object in Amazon Ion format returned by a GetBlock request. A proof contains the list of hash values required to recalculate the specified digest using a Merkle tree, starting with the specified block.
    public var proof: QLDBClientTypes.ValueHolder?

    public init(
        block: QLDBClientTypes.ValueHolder? = nil,
        proof: QLDBClientTypes.ValueHolder? = nil
    )
    {
        self.block = block
        self.proof = proof
    }
}

extension GetBlockOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetBlockOutput(block: \"CONTENT_REDACTED\", proof: \"CONTENT_REDACTED\")"}
}

public struct GetDigestInput {
    /// The name of the ledger.
    /// This member is required.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

public struct GetDigestOutput {
    /// The 256-bit hash value representing the digest returned by a GetDigest request.
    /// This member is required.
    public var digest: Foundation.Data?
    /// The latest block location covered by the digest that you requested. An address is an Amazon Ion structure that has two fields: strandId and sequenceNo.
    /// This member is required.
    public var digestTipAddress: QLDBClientTypes.ValueHolder?

    public init(
        digest: Foundation.Data? = nil,
        digestTipAddress: QLDBClientTypes.ValueHolder? = nil
    )
    {
        self.digest = digest
        self.digestTipAddress = digestTipAddress
    }
}

extension GetDigestOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetDigestOutput(digest: \(Swift.String(describing: digest)), digestTipAddress: \"CONTENT_REDACTED\")"}
}

public struct GetRevisionInput {
    /// The block location of the document revision to be verified. An address is an Amazon Ion structure that has two fields: strandId and sequenceNo. For example: {strandId:"BlFTjlSXze9BIh1KOszcE3",sequenceNo:14}.
    /// This member is required.
    public var blockAddress: QLDBClientTypes.ValueHolder?
    /// The latest block location covered by the digest for which to request a proof. An address is an Amazon Ion structure that has two fields: strandId and sequenceNo. For example: {strandId:"BlFTjlSXze9BIh1KOszcE3",sequenceNo:49}.
    public var digestTipAddress: QLDBClientTypes.ValueHolder?
    /// The UUID (represented in Base62-encoded text) of the document to be verified.
    /// This member is required.
    public var documentId: Swift.String?
    /// The name of the ledger.
    /// This member is required.
    public var name: Swift.String?

    public init(
        blockAddress: QLDBClientTypes.ValueHolder? = nil,
        digestTipAddress: QLDBClientTypes.ValueHolder? = nil,
        documentId: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.blockAddress = blockAddress
        self.digestTipAddress = digestTipAddress
        self.documentId = documentId
        self.name = name
    }
}

extension GetRevisionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetRevisionInput(documentId: \(Swift.String(describing: documentId)), name: \(Swift.String(describing: name)), blockAddress: \"CONTENT_REDACTED\", digestTipAddress: \"CONTENT_REDACTED\")"}
}

public struct GetRevisionOutput {
    /// The proof object in Amazon Ion format returned by a GetRevision request. A proof contains the list of hash values that are required to recalculate the specified digest using a Merkle tree, starting with the specified document revision.
    public var proof: QLDBClientTypes.ValueHolder?
    /// The document revision data object in Amazon Ion format.
    /// This member is required.
    public var revision: QLDBClientTypes.ValueHolder?

    public init(
        proof: QLDBClientTypes.ValueHolder? = nil,
        revision: QLDBClientTypes.ValueHolder? = nil
    )
    {
        self.proof = proof
        self.revision = revision
    }
}

extension GetRevisionOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetRevisionOutput(proof: \"CONTENT_REDACTED\", revision: \"CONTENT_REDACTED\")"}
}

public struct ListJournalKinesisStreamsForLedgerInput {
    /// The name of the ledger.
    /// This member is required.
    public var ledgerName: Swift.String?
    /// The maximum number of results to return in a single ListJournalKinesisStreamsForLedger request. (The actual number of results returned might be fewer.)
    public var maxResults: Swift.Int?
    /// A pagination token, indicating that you want to retrieve the next page of results. If you received a value for NextToken in the response from a previous ListJournalKinesisStreamsForLedger call, you should use that value as input here.
    public var nextToken: Swift.String?

    public init(
        ledgerName: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.ledgerName = ledgerName
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListJournalKinesisStreamsForLedgerOutput {
    /// * If NextToken is empty, the last page of results has been processed and there are no more results to be retrieved.
    ///
    /// * If NextToken is not empty, more results are available. To retrieve the next page of results, use the value of NextToken in a subsequent ListJournalKinesisStreamsForLedger call.
    public var nextToken: Swift.String?
    /// The QLDB journal streams that are currently associated with the given ledger.
    public var streams: [QLDBClientTypes.JournalKinesisStreamDescription]?

    public init(
        nextToken: Swift.String? = nil,
        streams: [QLDBClientTypes.JournalKinesisStreamDescription]? = nil
    )
    {
        self.nextToken = nextToken
        self.streams = streams
    }
}

public struct ListJournalS3ExportsInput {
    /// The maximum number of results to return in a single ListJournalS3Exports request. (The actual number of results returned might be fewer.)
    public var maxResults: Swift.Int?
    /// A pagination token, indicating that you want to retrieve the next page of results. If you received a value for NextToken in the response from a previous ListJournalS3Exports call, then you should use that value as input here.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListJournalS3ExportsOutput {
    /// The journal export jobs for all ledgers that are associated with the current Amazon Web Services account and Region.
    public var journalS3Exports: [QLDBClientTypes.JournalS3ExportDescription]?
    /// * If NextToken is empty, then the last page of results has been processed and there are no more results to be retrieved.
    ///
    /// * If NextToken is not empty, then there are more results available. To retrieve the next page of results, use the value of NextToken in a subsequent ListJournalS3Exports call.
    public var nextToken: Swift.String?

    public init(
        journalS3Exports: [QLDBClientTypes.JournalS3ExportDescription]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.journalS3Exports = journalS3Exports
        self.nextToken = nextToken
    }
}

public struct ListJournalS3ExportsForLedgerInput {
    /// The maximum number of results to return in a single ListJournalS3ExportsForLedger request. (The actual number of results returned might be fewer.)
    public var maxResults: Swift.Int?
    /// The name of the ledger.
    /// This member is required.
    public var name: Swift.String?
    /// A pagination token, indicating that you want to retrieve the next page of results. If you received a value for NextToken in the response from a previous ListJournalS3ExportsForLedger call, then you should use that value as input here.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        name: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.name = name
        self.nextToken = nextToken
    }
}

public struct ListJournalS3ExportsForLedgerOutput {
    /// The journal export jobs that are currently associated with the specified ledger.
    public var journalS3Exports: [QLDBClientTypes.JournalS3ExportDescription]?
    /// * If NextToken is empty, then the last page of results has been processed and there are no more results to be retrieved.
    ///
    /// * If NextToken is not empty, then there are more results available. To retrieve the next page of results, use the value of NextToken in a subsequent ListJournalS3ExportsForLedger call.
    public var nextToken: Swift.String?

    public init(
        journalS3Exports: [QLDBClientTypes.JournalS3ExportDescription]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.journalS3Exports = journalS3Exports
        self.nextToken = nextToken
    }
}

public struct ListLedgersInput {
    /// The maximum number of results to return in a single ListLedgers request. (The actual number of results returned might be fewer.)
    public var maxResults: Swift.Int?
    /// A pagination token, indicating that you want to retrieve the next page of results. If you received a value for NextToken in the response from a previous ListLedgers call, then you should use that value as input here.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension QLDBClientTypes {
    /// Information about a ledger, including its name, state, and when it was created.
    public struct LedgerSummary {
        /// The date and time, in epoch time format, when the ledger was created. (Epoch time format is the number of seconds elapsed since 12:00:00 AM January 1, 1970 UTC.)
        public var creationDateTime: Foundation.Date?
        /// The name of the ledger.
        public var name: Swift.String?
        /// The current status of the ledger.
        public var state: QLDBClientTypes.LedgerState?

        public init(
            creationDateTime: Foundation.Date? = nil,
            name: Swift.String? = nil,
            state: QLDBClientTypes.LedgerState? = nil
        )
        {
            self.creationDateTime = creationDateTime
            self.name = name
            self.state = state
        }
    }

}

public struct ListLedgersOutput {
    /// The ledgers that are associated with the current Amazon Web Services account and Region.
    public var ledgers: [QLDBClientTypes.LedgerSummary]?
    /// A pagination token, indicating whether there are more results available:
    ///
    /// * If NextToken is empty, then the last page of results has been processed and there are no more results to be retrieved.
    ///
    /// * If NextToken is not empty, then there are more results available. To retrieve the next page of results, use the value of NextToken in a subsequent ListLedgers call.
    public var nextToken: Swift.String?

    public init(
        ledgers: [QLDBClientTypes.LedgerSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.ledgers = ledgers
        self.nextToken = nextToken
    }
}

public struct ListTagsForResourceInput {
    /// The Amazon Resource Name (ARN) for which to list the tags. For example: arn:aws:qldb:us-east-1:123456789012:ledger/exampleLedger
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

public struct ListTagsForResourceOutput {
    /// The tags that are currently associated with the specified Amazon QLDB resource.
    public var tags: [Swift.String: Swift.String?]?

    public init(
        tags: [Swift.String: Swift.String?]? = nil
    )
    {
        self.tags = tags
    }
}

public struct StreamJournalToKinesisInput {
    /// The exclusive date and time that specifies when the stream ends. If you don't define this parameter, the stream runs indefinitely until you cancel it. The ExclusiveEndTime must be in ISO 8601 date and time format and in Universal Coordinated Time (UTC). For example: 2019-06-13T21:36:34Z.
    public var exclusiveEndTime: Foundation.Date?
    /// The inclusive start date and time from which to start streaming journal data. This parameter must be in ISO 8601 date and time format and in Universal Coordinated Time (UTC). For example: 2019-06-13T21:36:34Z. The InclusiveStartTime cannot be in the future and must be before ExclusiveEndTime. If you provide an InclusiveStartTime that is before the ledger's CreationDateTime, QLDB effectively defaults it to the ledger's CreationDateTime.
    /// This member is required.
    public var inclusiveStartTime: Foundation.Date?
    /// The configuration settings of the Kinesis Data Streams destination for your stream request.
    /// This member is required.
    public var kinesisConfiguration: QLDBClientTypes.KinesisConfiguration?
    /// The name of the ledger.
    /// This member is required.
    public var ledgerName: Swift.String?
    /// The Amazon Resource Name (ARN) of the IAM role that grants QLDB permissions for a journal stream to write data records to a Kinesis Data Streams resource. To pass a role to QLDB when requesting a journal stream, you must have permissions to perform the iam:PassRole action on the IAM role resource. This is required for all journal stream requests.
    /// This member is required.
    public var roleArn: Swift.String?
    /// The name that you want to assign to the QLDB journal stream. User-defined names can help identify and indicate the purpose of a stream. Your stream name must be unique among other active streams for a given ledger. Stream names have the same naming constraints as ledger names, as defined in [Quotas in Amazon QLDB](https://docs.aws.amazon.com/qldb/latest/developerguide/limits.html#limits.naming) in the Amazon QLDB Developer Guide.
    /// This member is required.
    public var streamName: Swift.String?
    /// The key-value pairs to add as tags to the stream that you want to create. Tag keys are case sensitive. Tag values are case sensitive and can be null.
    public var tags: [Swift.String: Swift.String?]?

    public init(
        exclusiveEndTime: Foundation.Date? = nil,
        inclusiveStartTime: Foundation.Date? = nil,
        kinesisConfiguration: QLDBClientTypes.KinesisConfiguration? = nil,
        ledgerName: Swift.String? = nil,
        roleArn: Swift.String? = nil,
        streamName: Swift.String? = nil,
        tags: [Swift.String: Swift.String?]? = nil
    )
    {
        self.exclusiveEndTime = exclusiveEndTime
        self.inclusiveStartTime = inclusiveStartTime
        self.kinesisConfiguration = kinesisConfiguration
        self.ledgerName = ledgerName
        self.roleArn = roleArn
        self.streamName = streamName
        self.tags = tags
    }
}

public struct StreamJournalToKinesisOutput {
    /// The UUID (represented in Base62-encoded text) that QLDB assigns to each QLDB journal stream.
    public var streamId: Swift.String?

    public init(
        streamId: Swift.String? = nil
    )
    {
        self.streamId = streamId
    }
}

public struct TagResourceInput {
    /// The Amazon Resource Name (ARN) to which you want to add the tags. For example: arn:aws:qldb:us-east-1:123456789012:ledger/exampleLedger
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The key-value pairs to add as tags to the specified QLDB resource. Tag keys are case sensitive. If you specify a key that already exists for the resource, your request fails and returns an error. Tag values are case sensitive and can be null.
    /// This member is required.
    public var tags: [Swift.String: Swift.String?]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String: Swift.String?]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

public struct TagResourceOutput {

    public init() { }
}

public struct UntagResourceInput {
    /// The Amazon Resource Name (ARN) from which to remove the tags. For example: arn:aws:qldb:us-east-1:123456789012:ledger/exampleLedger
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The list of tag keys to remove.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

public struct UntagResourceOutput {

    public init() { }
}

public struct UpdateLedgerInput {
    /// Specifies whether the ledger is protected from being deleted by any user. If not defined during ledger creation, this feature is enabled (true) by default. If deletion protection is enabled, you must first disable it before you can delete the ledger. You can disable it by calling the UpdateLedger operation to set this parameter to false.
    public var deletionProtection: Swift.Bool?
    /// The key in Key Management Service (KMS) to use for encryption of data at rest in the ledger. For more information, see [Encryption at rest](https://docs.aws.amazon.com/qldb/latest/developerguide/encryption-at-rest.html) in the Amazon QLDB Developer Guide. Use one of the following options to specify this parameter:
    ///
    /// * AWS_OWNED_KMS_KEY: Use an KMS key that is owned and managed by Amazon Web Services on your behalf.
    ///
    /// * Undefined: Make no changes to the KMS key of the ledger.
    ///
    /// * A valid symmetric customer managed KMS key: Use the specified symmetric encryption KMS key in your account that you create, own, and manage. Amazon QLDB does not support asymmetric keys. For more information, see [Using symmetric and asymmetric keys](https://docs.aws.amazon.com/kms/latest/developerguide/symmetric-asymmetric.html) in the Key Management Service Developer Guide.
    ///
    ///
    /// To specify a customer managed KMS key, you can use its key ID, Amazon Resource Name (ARN), alias name, or alias ARN. When using an alias name, prefix it with "alias/". To specify a key in a different Amazon Web Services account, you must use the key ARN or alias ARN. For example:
    ///
    /// * Key ID: 1234abcd-12ab-34cd-56ef-1234567890ab
    ///
    /// * Key ARN: arn:aws:kms:us-east-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab
    ///
    /// * Alias name: alias/ExampleAlias
    ///
    /// * Alias ARN: arn:aws:kms:us-east-2:111122223333:alias/ExampleAlias
    ///
    ///
    /// For more information, see [Key identifiers (KeyId)](https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#key-id) in the Key Management Service Developer Guide.
    public var kmsKey: Swift.String?
    /// The name of the ledger.
    /// This member is required.
    public var name: Swift.String?

    public init(
        deletionProtection: Swift.Bool? = nil,
        kmsKey: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.deletionProtection = deletionProtection
        self.kmsKey = kmsKey
        self.name = name
    }
}

public struct UpdateLedgerOutput {
    /// The Amazon Resource Name (ARN) for the ledger.
    public var arn: Swift.String?
    /// The date and time, in epoch time format, when the ledger was created. (Epoch time format is the number of seconds elapsed since 12:00:00 AM January 1, 1970 UTC.)
    public var creationDateTime: Foundation.Date?
    /// Specifies whether the ledger is protected from being deleted by any user. If not defined during ledger creation, this feature is enabled (true) by default. If deletion protection is enabled, you must first disable it before you can delete the ledger. You can disable it by calling the UpdateLedger operation to set this parameter to false.
    public var deletionProtection: Swift.Bool?
    /// Information about the encryption of data at rest in the ledger. This includes the current status, the KMS key, and when the key became inaccessible (in the case of an error).
    public var encryptionDescription: QLDBClientTypes.LedgerEncryptionDescription?
    /// The name of the ledger.
    public var name: Swift.String?
    /// The current status of the ledger.
    public var state: QLDBClientTypes.LedgerState?

    public init(
        arn: Swift.String? = nil,
        creationDateTime: Foundation.Date? = nil,
        deletionProtection: Swift.Bool? = nil,
        encryptionDescription: QLDBClientTypes.LedgerEncryptionDescription? = nil,
        name: Swift.String? = nil,
        state: QLDBClientTypes.LedgerState? = nil
    )
    {
        self.arn = arn
        self.creationDateTime = creationDateTime
        self.deletionProtection = deletionProtection
        self.encryptionDescription = encryptionDescription
        self.name = name
        self.state = state
    }
}

public struct UpdateLedgerPermissionsModeInput {
    /// The name of the ledger.
    /// This member is required.
    public var name: Swift.String?
    /// The permissions mode to assign to the ledger. This parameter can have one of the following values:
    ///
    /// * ALLOW_ALL: A legacy permissions mode that enables access control with API-level granularity for ledgers. This mode allows users who have the SendCommand API permission for this ledger to run all PartiQL commands (hence, ALLOW_ALL) on any tables in the specified ledger. This mode disregards any table-level or command-level IAM permissions policies that you create for the ledger.
    ///
    /// * STANDARD: (Recommended) A permissions mode that enables access control with finer granularity for ledgers, tables, and PartiQL commands. By default, this mode denies all user requests to run any PartiQL commands on any tables in this ledger. To allow PartiQL commands to run, you must create IAM permissions policies for specific table resources and PartiQL actions, in addition to the SendCommand API permission for the ledger. For information, see [Getting started with the standard permissions mode](https://docs.aws.amazon.com/qldb/latest/developerguide/getting-started-standard-mode.html) in the Amazon QLDB Developer Guide.
    ///
    ///
    /// We strongly recommend using the STANDARD permissions mode to maximize the security of your ledger data.
    /// This member is required.
    public var permissionsMode: QLDBClientTypes.PermissionsMode?

    public init(
        name: Swift.String? = nil,
        permissionsMode: QLDBClientTypes.PermissionsMode? = nil
    )
    {
        self.name = name
        self.permissionsMode = permissionsMode
    }
}

public struct UpdateLedgerPermissionsModeOutput {
    /// The Amazon Resource Name (ARN) for the ledger.
    public var arn: Swift.String?
    /// The name of the ledger.
    public var name: Swift.String?
    /// The current permissions mode of the ledger.
    public var permissionsMode: QLDBClientTypes.PermissionsMode?

    public init(
        arn: Swift.String? = nil,
        name: Swift.String? = nil,
        permissionsMode: QLDBClientTypes.PermissionsMode? = nil
    )
    {
        self.arn = arn
        self.name = name
        self.permissionsMode = permissionsMode
    }
}

extension CancelJournalKinesisStreamInput {

    static func urlPathProvider(_ value: CancelJournalKinesisStreamInput) -> Swift.String? {
        guard let ledgerName = value.ledgerName else {
            return nil
        }
        guard let streamId = value.streamId else {
            return nil
        }
        return "/ledgers/\(ledgerName.urlPercentEncoding())/journal-kinesis-streams/\(streamId.urlPercentEncoding())"
    }
}

extension CreateLedgerInput {

    static func urlPathProvider(_ value: CreateLedgerInput) -> Swift.String? {
        return "/ledgers"
    }
}

extension DeleteLedgerInput {

    static func urlPathProvider(_ value: DeleteLedgerInput) -> Swift.String? {
        guard let name = value.name else {
            return nil
        }
        return "/ledgers/\(name.urlPercentEncoding())"
    }
}

extension DescribeJournalKinesisStreamInput {

    static func urlPathProvider(_ value: DescribeJournalKinesisStreamInput) -> Swift.String? {
        guard let ledgerName = value.ledgerName else {
            return nil
        }
        guard let streamId = value.streamId else {
            return nil
        }
        return "/ledgers/\(ledgerName.urlPercentEncoding())/journal-kinesis-streams/\(streamId.urlPercentEncoding())"
    }
}

extension DescribeJournalS3ExportInput {

    static func urlPathProvider(_ value: DescribeJournalS3ExportInput) -> Swift.String? {
        guard let name = value.name else {
            return nil
        }
        guard let exportId = value.exportId else {
            return nil
        }
        return "/ledgers/\(name.urlPercentEncoding())/journal-s3-exports/\(exportId.urlPercentEncoding())"
    }
}

extension DescribeLedgerInput {

    static func urlPathProvider(_ value: DescribeLedgerInput) -> Swift.String? {
        guard let name = value.name else {
            return nil
        }
        return "/ledgers/\(name.urlPercentEncoding())"
    }
}

extension ExportJournalToS3Input {

    static func urlPathProvider(_ value: ExportJournalToS3Input) -> Swift.String? {
        guard let name = value.name else {
            return nil
        }
        return "/ledgers/\(name.urlPercentEncoding())/journal-s3-exports"
    }
}

extension GetBlockInput {

    static func urlPathProvider(_ value: GetBlockInput) -> Swift.String? {
        guard let name = value.name else {
            return nil
        }
        return "/ledgers/\(name.urlPercentEncoding())/block"
    }
}

extension GetDigestInput {

    static func urlPathProvider(_ value: GetDigestInput) -> Swift.String? {
        guard let name = value.name else {
            return nil
        }
        return "/ledgers/\(name.urlPercentEncoding())/digest"
    }
}

extension GetRevisionInput {

    static func urlPathProvider(_ value: GetRevisionInput) -> Swift.String? {
        guard let name = value.name else {
            return nil
        }
        return "/ledgers/\(name.urlPercentEncoding())/revision"
    }
}

extension ListJournalKinesisStreamsForLedgerInput {

    static func urlPathProvider(_ value: ListJournalKinesisStreamsForLedgerInput) -> Swift.String? {
        guard let ledgerName = value.ledgerName else {
            return nil
        }
        return "/ledgers/\(ledgerName.urlPercentEncoding())/journal-kinesis-streams"
    }
}

extension ListJournalKinesisStreamsForLedgerInput {

    static func queryItemProvider(_ value: ListJournalKinesisStreamsForLedgerInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "next_token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "max_results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListJournalS3ExportsInput {

    static func urlPathProvider(_ value: ListJournalS3ExportsInput) -> Swift.String? {
        return "/journal-s3-exports"
    }
}

extension ListJournalS3ExportsInput {

    static func queryItemProvider(_ value: ListJournalS3ExportsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "next_token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "max_results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListJournalS3ExportsForLedgerInput {

    static func urlPathProvider(_ value: ListJournalS3ExportsForLedgerInput) -> Swift.String? {
        guard let name = value.name else {
            return nil
        }
        return "/ledgers/\(name.urlPercentEncoding())/journal-s3-exports"
    }
}

extension ListJournalS3ExportsForLedgerInput {

    static func queryItemProvider(_ value: ListJournalS3ExportsForLedgerInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "next_token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "max_results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListLedgersInput {

    static func urlPathProvider(_ value: ListLedgersInput) -> Swift.String? {
        return "/ledgers"
    }
}

extension ListLedgersInput {

    static func queryItemProvider(_ value: ListLedgersInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "next_token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "max_results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension StreamJournalToKinesisInput {

    static func urlPathProvider(_ value: StreamJournalToKinesisInput) -> Swift.String? {
        guard let ledgerName = value.ledgerName else {
            return nil
        }
        return "/ledgers/\(ledgerName.urlPercentEncoding())/journal-kinesis-streams"
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension UntagResourceInput {

    static func queryItemProvider(_ value: UntagResourceInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let tagKeys = value.tagKeys else {
            let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        tagKeys.forEach { queryItemValue in
            let queryItem = Smithy.URIQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
            items.append(queryItem)
        }
        return items
    }
}

extension UpdateLedgerInput {

    static func urlPathProvider(_ value: UpdateLedgerInput) -> Swift.String? {
        guard let name = value.name else {
            return nil
        }
        return "/ledgers/\(name.urlPercentEncoding())"
    }
}

extension UpdateLedgerPermissionsModeInput {

    static func urlPathProvider(_ value: UpdateLedgerPermissionsModeInput) -> Swift.String? {
        guard let name = value.name else {
            return nil
        }
        return "/ledgers/\(name.urlPercentEncoding())/permissions-mode"
    }
}

extension CreateLedgerInput {

    static func write(value: CreateLedgerInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DeletionProtection"].write(value.deletionProtection)
        try writer["KmsKey"].write(value.kmsKey)
        try writer["Name"].write(value.name)
        try writer["PermissionsMode"].write(value.permissionsMode)
        try writer["Tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.sparseFormOf(writingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:)), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension ExportJournalToS3Input {

    static func write(value: ExportJournalToS3Input?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ExclusiveEndTime"].writeTimestamp(value.exclusiveEndTime, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["InclusiveStartTime"].writeTimestamp(value.inclusiveStartTime, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["OutputFormat"].write(value.outputFormat)
        try writer["RoleArn"].write(value.roleArn)
        try writer["S3ExportConfiguration"].write(value.s3ExportConfiguration, with: QLDBClientTypes.S3ExportConfiguration.write(value:to:))
    }
}

extension GetBlockInput {

    static func write(value: GetBlockInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BlockAddress"].write(value.blockAddress, with: QLDBClientTypes.ValueHolder.write(value:to:))
        try writer["DigestTipAddress"].write(value.digestTipAddress, with: QLDBClientTypes.ValueHolder.write(value:to:))
    }
}

extension GetRevisionInput {

    static func write(value: GetRevisionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BlockAddress"].write(value.blockAddress, with: QLDBClientTypes.ValueHolder.write(value:to:))
        try writer["DigestTipAddress"].write(value.digestTipAddress, with: QLDBClientTypes.ValueHolder.write(value:to:))
        try writer["DocumentId"].write(value.documentId)
    }
}

extension StreamJournalToKinesisInput {

    static func write(value: StreamJournalToKinesisInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ExclusiveEndTime"].writeTimestamp(value.exclusiveEndTime, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["InclusiveStartTime"].writeTimestamp(value.inclusiveStartTime, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["KinesisConfiguration"].write(value.kinesisConfiguration, with: QLDBClientTypes.KinesisConfiguration.write(value:to:))
        try writer["RoleArn"].write(value.roleArn)
        try writer["StreamName"].write(value.streamName)
        try writer["Tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.sparseFormOf(writingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:)), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.sparseFormOf(writingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:)), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension UpdateLedgerInput {

    static func write(value: UpdateLedgerInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DeletionProtection"].write(value.deletionProtection)
        try writer["KmsKey"].write(value.kmsKey)
    }
}

extension UpdateLedgerPermissionsModeInput {

    static func write(value: UpdateLedgerPermissionsModeInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["PermissionsMode"].write(value.permissionsMode)
    }
}

extension CancelJournalKinesisStreamOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CancelJournalKinesisStreamOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CancelJournalKinesisStreamOutput()
        value.streamId = try reader["StreamId"].readIfPresent()
        return value
    }
}

extension CreateLedgerOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateLedgerOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateLedgerOutput()
        value.arn = try reader["Arn"].readIfPresent()
        value.creationDateTime = try reader["CreationDateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.deletionProtection = try reader["DeletionProtection"].readIfPresent()
        value.kmsKeyArn = try reader["KmsKeyArn"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.permissionsMode = try reader["PermissionsMode"].readIfPresent()
        value.state = try reader["State"].readIfPresent()
        return value
    }
}

extension DeleteLedgerOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteLedgerOutput {
        return DeleteLedgerOutput()
    }
}

extension DescribeJournalKinesisStreamOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeJournalKinesisStreamOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeJournalKinesisStreamOutput()
        value.stream = try reader["Stream"].readIfPresent(with: QLDBClientTypes.JournalKinesisStreamDescription.read(from:))
        return value
    }
}

extension DescribeJournalS3ExportOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeJournalS3ExportOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeJournalS3ExportOutput()
        value.exportDescription = try reader["ExportDescription"].readIfPresent(with: QLDBClientTypes.JournalS3ExportDescription.read(from:))
        return value
    }
}

extension DescribeLedgerOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeLedgerOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeLedgerOutput()
        value.arn = try reader["Arn"].readIfPresent()
        value.creationDateTime = try reader["CreationDateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.deletionProtection = try reader["DeletionProtection"].readIfPresent()
        value.encryptionDescription = try reader["EncryptionDescription"].readIfPresent(with: QLDBClientTypes.LedgerEncryptionDescription.read(from:))
        value.name = try reader["Name"].readIfPresent()
        value.permissionsMode = try reader["PermissionsMode"].readIfPresent()
        value.state = try reader["State"].readIfPresent()
        return value
    }
}

extension ExportJournalToS3Output {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ExportJournalToS3Output {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ExportJournalToS3Output()
        value.exportId = try reader["ExportId"].readIfPresent() ?? ""
        return value
    }
}

extension GetBlockOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetBlockOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetBlockOutput()
        value.block = try reader["Block"].readIfPresent(with: QLDBClientTypes.ValueHolder.read(from:))
        value.proof = try reader["Proof"].readIfPresent(with: QLDBClientTypes.ValueHolder.read(from:))
        return value
    }
}

extension GetDigestOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetDigestOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetDigestOutput()
        value.digest = try reader["Digest"].readIfPresent() ?? Foundation.Data("".utf8)
        value.digestTipAddress = try reader["DigestTipAddress"].readIfPresent(with: QLDBClientTypes.ValueHolder.read(from:))
        return value
    }
}

extension GetRevisionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetRevisionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetRevisionOutput()
        value.proof = try reader["Proof"].readIfPresent(with: QLDBClientTypes.ValueHolder.read(from:))
        value.revision = try reader["Revision"].readIfPresent(with: QLDBClientTypes.ValueHolder.read(from:))
        return value
    }
}

extension ListJournalKinesisStreamsForLedgerOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListJournalKinesisStreamsForLedgerOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListJournalKinesisStreamsForLedgerOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.streams = try reader["Streams"].readListIfPresent(memberReadingClosure: QLDBClientTypes.JournalKinesisStreamDescription.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListJournalS3ExportsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListJournalS3ExportsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListJournalS3ExportsOutput()
        value.journalS3Exports = try reader["JournalS3Exports"].readListIfPresent(memberReadingClosure: QLDBClientTypes.JournalS3ExportDescription.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListJournalS3ExportsForLedgerOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListJournalS3ExportsForLedgerOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListJournalS3ExportsForLedgerOutput()
        value.journalS3Exports = try reader["JournalS3Exports"].readListIfPresent(memberReadingClosure: QLDBClientTypes.JournalS3ExportDescription.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListLedgersOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListLedgersOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListLedgersOutput()
        value.ledgers = try reader["Ledgers"].readListIfPresent(memberReadingClosure: QLDBClientTypes.LedgerSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.tags = try reader["Tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.optionalFormOf(readingClosure: SmithyReadWrite.ReadingClosures.readString(from:)), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension StreamJournalToKinesisOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StreamJournalToKinesisOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StreamJournalToKinesisOutput()
        value.streamId = try reader["StreamId"].readIfPresent()
        return value
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

extension UpdateLedgerOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateLedgerOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateLedgerOutput()
        value.arn = try reader["Arn"].readIfPresent()
        value.creationDateTime = try reader["CreationDateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.deletionProtection = try reader["DeletionProtection"].readIfPresent()
        value.encryptionDescription = try reader["EncryptionDescription"].readIfPresent(with: QLDBClientTypes.LedgerEncryptionDescription.read(from:))
        value.name = try reader["Name"].readIfPresent()
        value.state = try reader["State"].readIfPresent()
        return value
    }
}

extension UpdateLedgerPermissionsModeOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateLedgerPermissionsModeOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateLedgerPermissionsModeOutput()
        value.arn = try reader["Arn"].readIfPresent()
        value.name = try reader["Name"].readIfPresent()
        value.permissionsMode = try reader["PermissionsMode"].readIfPresent()
        return value
    }
}

enum CancelJournalKinesisStreamOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ResourcePreconditionNotMetException": return try ResourcePreconditionNotMetException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateLedgerOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "LimitExceededException": return try LimitExceededException.makeError(baseError: baseError)
            case "ResourceAlreadyExistsException": return try ResourceAlreadyExistsException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteLedgerOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "ResourceInUseException": return try ResourceInUseException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ResourcePreconditionNotMetException": return try ResourcePreconditionNotMetException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeJournalKinesisStreamOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ResourcePreconditionNotMetException": return try ResourcePreconditionNotMetException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeJournalS3ExportOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeLedgerOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ExportJournalToS3OutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ResourcePreconditionNotMetException": return try ResourcePreconditionNotMetException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetBlockOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ResourcePreconditionNotMetException": return try ResourcePreconditionNotMetException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetDigestOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ResourcePreconditionNotMetException": return try ResourcePreconditionNotMetException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetRevisionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ResourcePreconditionNotMetException": return try ResourcePreconditionNotMetException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListJournalKinesisStreamsForLedgerOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ResourcePreconditionNotMetException": return try ResourcePreconditionNotMetException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListJournalS3ExportsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListJournalS3ExportsForLedgerOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListLedgersOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StreamJournalToKinesisOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ResourcePreconditionNotMetException": return try ResourcePreconditionNotMetException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateLedgerOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateLedgerPermissionsModeOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.properties.resourceName = try reader["ResourceName"].readIfPresent()
        value.properties.resourceType = try reader["ResourceType"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidParameterException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InvalidParameterException {
        let reader = baseError.errorBodyReader
        var value = InvalidParameterException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.properties.parameterName = try reader["ParameterName"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourcePreconditionNotMetException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ResourcePreconditionNotMetException {
        let reader = baseError.errorBodyReader
        var value = ResourcePreconditionNotMetException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.properties.resourceName = try reader["ResourceName"].readIfPresent()
        value.properties.resourceType = try reader["ResourceType"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension LimitExceededException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> LimitExceededException {
        let reader = baseError.errorBodyReader
        var value = LimitExceededException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.properties.resourceType = try reader["ResourceType"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceInUseException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ResourceInUseException {
        let reader = baseError.errorBodyReader
        var value = ResourceInUseException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.properties.resourceName = try reader["ResourceName"].readIfPresent()
        value.properties.resourceType = try reader["ResourceType"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceAlreadyExistsException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ResourceAlreadyExistsException {
        let reader = baseError.errorBodyReader
        var value = ResourceAlreadyExistsException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.properties.resourceName = try reader["ResourceName"].readIfPresent()
        value.properties.resourceType = try reader["ResourceType"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension QLDBClientTypes.JournalKinesisStreamDescription {

    static func read(from reader: SmithyJSON.Reader) throws -> QLDBClientTypes.JournalKinesisStreamDescription {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QLDBClientTypes.JournalKinesisStreamDescription()
        value.ledgerName = try reader["LedgerName"].readIfPresent() ?? ""
        value.creationTime = try reader["CreationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.inclusiveStartTime = try reader["InclusiveStartTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.exclusiveEndTime = try reader["ExclusiveEndTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.roleArn = try reader["RoleArn"].readIfPresent() ?? ""
        value.streamId = try reader["StreamId"].readIfPresent() ?? ""
        value.arn = try reader["Arn"].readIfPresent()
        value.status = try reader["Status"].readIfPresent() ?? .sdkUnknown("")
        value.kinesisConfiguration = try reader["KinesisConfiguration"].readIfPresent(with: QLDBClientTypes.KinesisConfiguration.read(from:))
        value.errorCause = try reader["ErrorCause"].readIfPresent()
        value.streamName = try reader["StreamName"].readIfPresent() ?? ""
        return value
    }
}

extension QLDBClientTypes.KinesisConfiguration {

    static func write(value: QLDBClientTypes.KinesisConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AggregationEnabled"].write(value.aggregationEnabled)
        try writer["StreamArn"].write(value.streamArn)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QLDBClientTypes.KinesisConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QLDBClientTypes.KinesisConfiguration()
        value.streamArn = try reader["StreamArn"].readIfPresent() ?? ""
        value.aggregationEnabled = try reader["AggregationEnabled"].readIfPresent()
        return value
    }
}

extension QLDBClientTypes.JournalS3ExportDescription {

    static func read(from reader: SmithyJSON.Reader) throws -> QLDBClientTypes.JournalS3ExportDescription {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QLDBClientTypes.JournalS3ExportDescription()
        value.ledgerName = try reader["LedgerName"].readIfPresent() ?? ""
        value.exportId = try reader["ExportId"].readIfPresent() ?? ""
        value.exportCreationTime = try reader["ExportCreationTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.status = try reader["Status"].readIfPresent() ?? .sdkUnknown("")
        value.inclusiveStartTime = try reader["InclusiveStartTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.exclusiveEndTime = try reader["ExclusiveEndTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.s3ExportConfiguration = try reader["S3ExportConfiguration"].readIfPresent(with: QLDBClientTypes.S3ExportConfiguration.read(from:))
        value.roleArn = try reader["RoleArn"].readIfPresent() ?? ""
        value.outputFormat = try reader["OutputFormat"].readIfPresent()
        return value
    }
}

extension QLDBClientTypes.S3ExportConfiguration {

    static func write(value: QLDBClientTypes.S3ExportConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Bucket"].write(value.bucket)
        try writer["EncryptionConfiguration"].write(value.encryptionConfiguration, with: QLDBClientTypes.S3EncryptionConfiguration.write(value:to:))
        try writer["Prefix"].write(value.`prefix`)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QLDBClientTypes.S3ExportConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QLDBClientTypes.S3ExportConfiguration()
        value.bucket = try reader["Bucket"].readIfPresent() ?? ""
        value.`prefix` = try reader["Prefix"].readIfPresent() ?? ""
        value.encryptionConfiguration = try reader["EncryptionConfiguration"].readIfPresent(with: QLDBClientTypes.S3EncryptionConfiguration.read(from:))
        return value
    }
}

extension QLDBClientTypes.S3EncryptionConfiguration {

    static func write(value: QLDBClientTypes.S3EncryptionConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["KmsKeyArn"].write(value.kmsKeyArn)
        try writer["ObjectEncryptionType"].write(value.objectEncryptionType)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QLDBClientTypes.S3EncryptionConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QLDBClientTypes.S3EncryptionConfiguration()
        value.objectEncryptionType = try reader["ObjectEncryptionType"].readIfPresent() ?? .sdkUnknown("")
        value.kmsKeyArn = try reader["KmsKeyArn"].readIfPresent()
        return value
    }
}

extension QLDBClientTypes.LedgerEncryptionDescription {

    static func read(from reader: SmithyJSON.Reader) throws -> QLDBClientTypes.LedgerEncryptionDescription {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QLDBClientTypes.LedgerEncryptionDescription()
        value.kmsKeyArn = try reader["KmsKeyArn"].readIfPresent() ?? ""
        value.encryptionStatus = try reader["EncryptionStatus"].readIfPresent() ?? .sdkUnknown("")
        value.inaccessibleKmsKeyDateTime = try reader["InaccessibleKmsKeyDateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension QLDBClientTypes.ValueHolder {

    static func write(value: QLDBClientTypes.ValueHolder?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["IonText"].write(value.ionText)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> QLDBClientTypes.ValueHolder {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QLDBClientTypes.ValueHolder()
        value.ionText = try reader["IonText"].readIfPresent()
        return value
    }
}

extension QLDBClientTypes.LedgerSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> QLDBClientTypes.LedgerSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = QLDBClientTypes.LedgerSummary()
        value.name = try reader["Name"].readIfPresent()
        value.state = try reader["State"].readIfPresent()
        value.creationDateTime = try reader["CreationDateTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

public enum QLDBClientTypes {}
