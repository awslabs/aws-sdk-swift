// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension CancelJournalKinesisStreamInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let ledgerName = ledgerName else {
            return nil
        }
        guard let streamId = streamId else {
            return nil
        }
        return "/ledgers/\(ledgerName.urlPercentEncoding())/journal-kinesis-streams/\(streamId.urlPercentEncoding())"
    }
}

public struct CancelJournalKinesisStreamInput: Swift.Equatable {
    /// The name of the ledger.
    /// This member is required.
    public var ledgerName: Swift.String?
    /// The UUID (represented in Base62-encoded text) of the QLDB journal stream to be canceled.
    /// This member is required.
    public var streamId: Swift.String?

    public init(
        ledgerName: Swift.String? = nil,
        streamId: Swift.String? = nil
    )
    {
        self.ledgerName = ledgerName
        self.streamId = streamId
    }
}

struct CancelJournalKinesisStreamInputBody: Swift.Equatable {
}

extension CancelJournalKinesisStreamInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension CancelJournalKinesisStreamOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CancelJournalKinesisStreamOutputBody = try responseDecoder.decode(responseBody: data)
            self.streamId = output.streamId
        } else {
            self.streamId = nil
        }
    }
}

public struct CancelJournalKinesisStreamOutput: Swift.Equatable {
    /// The UUID (Base62-encoded text) of the canceled QLDB journal stream.
    public var streamId: Swift.String?

    public init(
        streamId: Swift.String? = nil
    )
    {
        self.streamId = streamId
    }
}

struct CancelJournalKinesisStreamOutputBody: Swift.Equatable {
    let streamId: Swift.String?
}

extension CancelJournalKinesisStreamOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case streamId = "StreamId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamId)
        streamId = streamIdDecoded
    }
}

enum CancelJournalKinesisStreamOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourcePreconditionNotMetException": return try await ResourcePreconditionNotMetException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateLedgerInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deletionProtection = "DeletionProtection"
        case kmsKey = "KmsKey"
        case name = "Name"
        case permissionsMode = "PermissionsMode"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deletionProtection = self.deletionProtection {
            try encodeContainer.encode(deletionProtection, forKey: .deletionProtection)
        }
        if let kmsKey = self.kmsKey {
            try encodeContainer.encode(kmsKey, forKey: .kmsKey)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let permissionsMode = self.permissionsMode {
            try encodeContainer.encode(permissionsMode.rawValue, forKey: .permissionsMode)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                guard let tags0 = tags0 else {
                    try tagsContainer.encodeNil(forKey: ClientRuntime.Key(stringValue: dictKey0))
                    continue
                }
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateLedgerInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/ledgers"
    }
}

public struct CreateLedgerInput: Swift.Equatable {
    /// Specifies whether the ledger is protected from being deleted by any user. If not defined during ledger creation, this feature is enabled (true) by default. If deletion protection is enabled, you must first disable it before you can delete the ledger. You can disable it by calling the UpdateLedger operation to set this parameter to false.
    public var deletionProtection: Swift.Bool?
    /// The key in Key Management Service (KMS) to use for encryption of data at rest in the ledger. For more information, see [Encryption at rest](https://docs.aws.amazon.com/qldb/latest/developerguide/encryption-at-rest.html) in the Amazon QLDB Developer Guide. Use one of the following options to specify this parameter:
    ///
    /// * AWS_OWNED_KMS_KEY: Use an KMS key that is owned and managed by Amazon Web Services on your behalf.
    ///
    /// * Undefined: By default, use an Amazon Web Services owned KMS key.
    ///
    /// * A valid symmetric customer managed KMS key: Use the specified symmetric encryption KMS key in your account that you create, own, and manage. Amazon QLDB does not support asymmetric keys. For more information, see [Using symmetric and asymmetric keys](https://docs.aws.amazon.com/kms/latest/developerguide/symmetric-asymmetric.html) in the Key Management Service Developer Guide.
    ///
    ///
    /// To specify a customer managed KMS key, you can use its key ID, Amazon Resource Name (ARN), alias name, or alias ARN. When using an alias name, prefix it with "alias/". To specify a key in a different Amazon Web Services account, you must use the key ARN or alias ARN. For example:
    ///
    /// * Key ID: 1234abcd-12ab-34cd-56ef-1234567890ab
    ///
    /// * Key ARN: arn:aws:kms:us-east-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab
    ///
    /// * Alias name: alias/ExampleAlias
    ///
    /// * Alias ARN: arn:aws:kms:us-east-2:111122223333:alias/ExampleAlias
    ///
    ///
    /// For more information, see [Key identifiers (KeyId)](https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#key-id) in the Key Management Service Developer Guide.
    public var kmsKey: Swift.String?
    /// The name of the ledger that you want to create. The name must be unique among all of the ledgers in your Amazon Web Services account in the current Region. Naming constraints for ledger names are defined in [Quotas in Amazon QLDB](https://docs.aws.amazon.com/qldb/latest/developerguide/limits.html#limits.naming) in the Amazon QLDB Developer Guide.
    /// This member is required.
    public var name: Swift.String?
    /// The permissions mode to assign to the ledger that you want to create. This parameter can have one of the following values:
    ///
    /// * ALLOW_ALL: A legacy permissions mode that enables access control with API-level granularity for ledgers. This mode allows users who have the SendCommand API permission for this ledger to run all PartiQL commands (hence, ALLOW_ALL) on any tables in the specified ledger. This mode disregards any table-level or command-level IAM permissions policies that you create for the ledger.
    ///
    /// * STANDARD: (Recommended) A permissions mode that enables access control with finer granularity for ledgers, tables, and PartiQL commands. By default, this mode denies all user requests to run any PartiQL commands on any tables in this ledger. To allow PartiQL commands to run, you must create IAM permissions policies for specific table resources and PartiQL actions, in addition to the SendCommand API permission for the ledger. For information, see [Getting started with the standard permissions mode](https://docs.aws.amazon.com/qldb/latest/developerguide/getting-started-standard-mode.html) in the Amazon QLDB Developer Guide.
    ///
    ///
    /// We strongly recommend using the STANDARD permissions mode to maximize the security of your ledger data.
    /// This member is required.
    public var permissionsMode: QLDBClientTypes.PermissionsMode?
    /// The key-value pairs to add as tags to the ledger that you want to create. Tag keys are case sensitive. Tag values are case sensitive and can be null.
    public var tags: [Swift.String:Swift.String?]?

    public init(
        deletionProtection: Swift.Bool? = nil,
        kmsKey: Swift.String? = nil,
        name: Swift.String? = nil,
        permissionsMode: QLDBClientTypes.PermissionsMode? = nil,
        tags: [Swift.String:Swift.String?]? = nil
    )
    {
        self.deletionProtection = deletionProtection
        self.kmsKey = kmsKey
        self.name = name
        self.permissionsMode = permissionsMode
        self.tags = tags
    }
}

struct CreateLedgerInputBody: Swift.Equatable {
    let name: Swift.String?
    let tags: [Swift.String:Swift.String?]?
    let permissionsMode: QLDBClientTypes.PermissionsMode?
    let deletionProtection: Swift.Bool?
    let kmsKey: Swift.String?
}

extension CreateLedgerInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deletionProtection = "DeletionProtection"
        case kmsKey = "KmsKey"
        case name = "Name"
        case permissionsMode = "PermissionsMode"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String?]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String?]()
            for (key0, tagvalue0) in tagsContainer {
                tagsDecoded0?[key0] = tagvalue0
            }
        }
        tags = tagsDecoded0
        let permissionsModeDecoded = try containerValues.decodeIfPresent(QLDBClientTypes.PermissionsMode.self, forKey: .permissionsMode)
        permissionsMode = permissionsModeDecoded
        let deletionProtectionDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .deletionProtection)
        deletionProtection = deletionProtectionDecoded
        let kmsKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKey)
        kmsKey = kmsKeyDecoded
    }
}

extension CreateLedgerOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateLedgerOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.creationDateTime = output.creationDateTime
            self.deletionProtection = output.deletionProtection
            self.kmsKeyArn = output.kmsKeyArn
            self.name = output.name
            self.permissionsMode = output.permissionsMode
            self.state = output.state
        } else {
            self.arn = nil
            self.creationDateTime = nil
            self.deletionProtection = nil
            self.kmsKeyArn = nil
            self.name = nil
            self.permissionsMode = nil
            self.state = nil
        }
    }
}

public struct CreateLedgerOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) for the ledger.
    public var arn: Swift.String?
    /// The date and time, in epoch time format, when the ledger was created. (Epoch time format is the number of seconds elapsed since 12:00:00 AM January 1, 1970 UTC.)
    public var creationDateTime: ClientRuntime.Date?
    /// Specifies whether the ledger is protected from being deleted by any user. If not defined during ledger creation, this feature is enabled (true) by default. If deletion protection is enabled, you must first disable it before you can delete the ledger. You can disable it by calling the UpdateLedger operation to set this parameter to false.
    public var deletionProtection: Swift.Bool?
    /// The ARN of the customer managed KMS key that the ledger uses for encryption at rest. If this parameter is undefined, the ledger uses an Amazon Web Services owned KMS key for encryption.
    public var kmsKeyArn: Swift.String?
    /// The name of the ledger.
    public var name: Swift.String?
    /// The permissions mode of the ledger that you created.
    public var permissionsMode: QLDBClientTypes.PermissionsMode?
    /// The current status of the ledger.
    public var state: QLDBClientTypes.LedgerState?

    public init(
        arn: Swift.String? = nil,
        creationDateTime: ClientRuntime.Date? = nil,
        deletionProtection: Swift.Bool? = nil,
        kmsKeyArn: Swift.String? = nil,
        name: Swift.String? = nil,
        permissionsMode: QLDBClientTypes.PermissionsMode? = nil,
        state: QLDBClientTypes.LedgerState? = nil
    )
    {
        self.arn = arn
        self.creationDateTime = creationDateTime
        self.deletionProtection = deletionProtection
        self.kmsKeyArn = kmsKeyArn
        self.name = name
        self.permissionsMode = permissionsMode
        self.state = state
    }
}

struct CreateLedgerOutputBody: Swift.Equatable {
    let name: Swift.String?
    let arn: Swift.String?
    let state: QLDBClientTypes.LedgerState?
    let creationDateTime: ClientRuntime.Date?
    let permissionsMode: QLDBClientTypes.PermissionsMode?
    let deletionProtection: Swift.Bool?
    let kmsKeyArn: Swift.String?
}

extension CreateLedgerOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case creationDateTime = "CreationDateTime"
        case deletionProtection = "DeletionProtection"
        case kmsKeyArn = "KmsKeyArn"
        case name = "Name"
        case permissionsMode = "PermissionsMode"
        case state = "State"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let stateDecoded = try containerValues.decodeIfPresent(QLDBClientTypes.LedgerState.self, forKey: .state)
        state = stateDecoded
        let creationDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let permissionsModeDecoded = try containerValues.decodeIfPresent(QLDBClientTypes.PermissionsMode.self, forKey: .permissionsMode)
        permissionsMode = permissionsModeDecoded
        let deletionProtectionDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .deletionProtection)
        deletionProtection = deletionProtectionDecoded
        let kmsKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyArn)
        kmsKeyArn = kmsKeyArnDecoded
    }
}

enum CreateLedgerOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceAlreadyExistsException": return try await ResourceAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceInUseException": return try await ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteLedgerInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let name = name else {
            return nil
        }
        return "/ledgers/\(name.urlPercentEncoding())"
    }
}

public struct DeleteLedgerInput: Swift.Equatable {
    /// The name of the ledger that you want to delete.
    /// This member is required.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct DeleteLedgerInputBody: Swift.Equatable {
}

extension DeleteLedgerInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteLedgerOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteLedgerOutput: Swift.Equatable {

    public init() { }
}

enum DeleteLedgerOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceInUseException": return try await ResourceInUseException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourcePreconditionNotMetException": return try await ResourcePreconditionNotMetException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeJournalKinesisStreamInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let ledgerName = ledgerName else {
            return nil
        }
        guard let streamId = streamId else {
            return nil
        }
        return "/ledgers/\(ledgerName.urlPercentEncoding())/journal-kinesis-streams/\(streamId.urlPercentEncoding())"
    }
}

public struct DescribeJournalKinesisStreamInput: Swift.Equatable {
    /// The name of the ledger.
    /// This member is required.
    public var ledgerName: Swift.String?
    /// The UUID (represented in Base62-encoded text) of the QLDB journal stream to describe.
    /// This member is required.
    public var streamId: Swift.String?

    public init(
        ledgerName: Swift.String? = nil,
        streamId: Swift.String? = nil
    )
    {
        self.ledgerName = ledgerName
        self.streamId = streamId
    }
}

struct DescribeJournalKinesisStreamInputBody: Swift.Equatable {
}

extension DescribeJournalKinesisStreamInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeJournalKinesisStreamOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeJournalKinesisStreamOutputBody = try responseDecoder.decode(responseBody: data)
            self.stream = output.stream
        } else {
            self.stream = nil
        }
    }
}

public struct DescribeJournalKinesisStreamOutput: Swift.Equatable {
    /// Information about the QLDB journal stream returned by a DescribeJournalS3Export request.
    public var stream: QLDBClientTypes.JournalKinesisStreamDescription?

    public init(
        stream: QLDBClientTypes.JournalKinesisStreamDescription? = nil
    )
    {
        self.stream = stream
    }
}

struct DescribeJournalKinesisStreamOutputBody: Swift.Equatable {
    let stream: QLDBClientTypes.JournalKinesisStreamDescription?
}

extension DescribeJournalKinesisStreamOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case stream = "Stream"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamDecoded = try containerValues.decodeIfPresent(QLDBClientTypes.JournalKinesisStreamDescription.self, forKey: .stream)
        stream = streamDecoded
    }
}

enum DescribeJournalKinesisStreamOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourcePreconditionNotMetException": return try await ResourcePreconditionNotMetException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeJournalS3ExportInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let name = name else {
            return nil
        }
        guard let exportId = exportId else {
            return nil
        }
        return "/ledgers/\(name.urlPercentEncoding())/journal-s3-exports/\(exportId.urlPercentEncoding())"
    }
}

public struct DescribeJournalS3ExportInput: Swift.Equatable {
    /// The UUID (represented in Base62-encoded text) of the journal export job to describe.
    /// This member is required.
    public var exportId: Swift.String?
    /// The name of the ledger.
    /// This member is required.
    public var name: Swift.String?

    public init(
        exportId: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.exportId = exportId
        self.name = name
    }
}

struct DescribeJournalS3ExportInputBody: Swift.Equatable {
}

extension DescribeJournalS3ExportInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeJournalS3ExportOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeJournalS3ExportOutputBody = try responseDecoder.decode(responseBody: data)
            self.exportDescription = output.exportDescription
        } else {
            self.exportDescription = nil
        }
    }
}

public struct DescribeJournalS3ExportOutput: Swift.Equatable {
    /// Information about the journal export job returned by a DescribeJournalS3Export request.
    /// This member is required.
    public var exportDescription: QLDBClientTypes.JournalS3ExportDescription?

    public init(
        exportDescription: QLDBClientTypes.JournalS3ExportDescription? = nil
    )
    {
        self.exportDescription = exportDescription
    }
}

struct DescribeJournalS3ExportOutputBody: Swift.Equatable {
    let exportDescription: QLDBClientTypes.JournalS3ExportDescription?
}

extension DescribeJournalS3ExportOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case exportDescription = "ExportDescription"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let exportDescriptionDecoded = try containerValues.decodeIfPresent(QLDBClientTypes.JournalS3ExportDescription.self, forKey: .exportDescription)
        exportDescription = exportDescriptionDecoded
    }
}

enum DescribeJournalS3ExportOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeLedgerInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let name = name else {
            return nil
        }
        return "/ledgers/\(name.urlPercentEncoding())"
    }
}

public struct DescribeLedgerInput: Swift.Equatable {
    /// The name of the ledger that you want to describe.
    /// This member is required.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct DescribeLedgerInputBody: Swift.Equatable {
}

extension DescribeLedgerInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeLedgerOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeLedgerOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.creationDateTime = output.creationDateTime
            self.deletionProtection = output.deletionProtection
            self.encryptionDescription = output.encryptionDescription
            self.name = output.name
            self.permissionsMode = output.permissionsMode
            self.state = output.state
        } else {
            self.arn = nil
            self.creationDateTime = nil
            self.deletionProtection = nil
            self.encryptionDescription = nil
            self.name = nil
            self.permissionsMode = nil
            self.state = nil
        }
    }
}

public struct DescribeLedgerOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) for the ledger.
    public var arn: Swift.String?
    /// The date and time, in epoch time format, when the ledger was created. (Epoch time format is the number of seconds elapsed since 12:00:00 AM January 1, 1970 UTC.)
    public var creationDateTime: ClientRuntime.Date?
    /// Specifies whether the ledger is protected from being deleted by any user. If not defined during ledger creation, this feature is enabled (true) by default. If deletion protection is enabled, you must first disable it before you can delete the ledger. You can disable it by calling the UpdateLedger operation to set this parameter to false.
    public var deletionProtection: Swift.Bool?
    /// Information about the encryption of data at rest in the ledger. This includes the current status, the KMS key, and when the key became inaccessible (in the case of an error).
    public var encryptionDescription: QLDBClientTypes.LedgerEncryptionDescription?
    /// The name of the ledger.
    public var name: Swift.String?
    /// The permissions mode of the ledger.
    public var permissionsMode: QLDBClientTypes.PermissionsMode?
    /// The current status of the ledger.
    public var state: QLDBClientTypes.LedgerState?

    public init(
        arn: Swift.String? = nil,
        creationDateTime: ClientRuntime.Date? = nil,
        deletionProtection: Swift.Bool? = nil,
        encryptionDescription: QLDBClientTypes.LedgerEncryptionDescription? = nil,
        name: Swift.String? = nil,
        permissionsMode: QLDBClientTypes.PermissionsMode? = nil,
        state: QLDBClientTypes.LedgerState? = nil
    )
    {
        self.arn = arn
        self.creationDateTime = creationDateTime
        self.deletionProtection = deletionProtection
        self.encryptionDescription = encryptionDescription
        self.name = name
        self.permissionsMode = permissionsMode
        self.state = state
    }
}

struct DescribeLedgerOutputBody: Swift.Equatable {
    let name: Swift.String?
    let arn: Swift.String?
    let state: QLDBClientTypes.LedgerState?
    let creationDateTime: ClientRuntime.Date?
    let permissionsMode: QLDBClientTypes.PermissionsMode?
    let deletionProtection: Swift.Bool?
    let encryptionDescription: QLDBClientTypes.LedgerEncryptionDescription?
}

extension DescribeLedgerOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case creationDateTime = "CreationDateTime"
        case deletionProtection = "DeletionProtection"
        case encryptionDescription = "EncryptionDescription"
        case name = "Name"
        case permissionsMode = "PermissionsMode"
        case state = "State"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let stateDecoded = try containerValues.decodeIfPresent(QLDBClientTypes.LedgerState.self, forKey: .state)
        state = stateDecoded
        let creationDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let permissionsModeDecoded = try containerValues.decodeIfPresent(QLDBClientTypes.PermissionsMode.self, forKey: .permissionsMode)
        permissionsMode = permissionsModeDecoded
        let deletionProtectionDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .deletionProtection)
        deletionProtection = deletionProtectionDecoded
        let encryptionDescriptionDecoded = try containerValues.decodeIfPresent(QLDBClientTypes.LedgerEncryptionDescription.self, forKey: .encryptionDescription)
        encryptionDescription = encryptionDescriptionDecoded
    }
}

enum DescribeLedgerOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension QLDBClientTypes {
    public enum EncryptionStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case enabled
        case kmsKeyInaccessible
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [EncryptionStatus] {
            return [
                .enabled,
                .kmsKeyInaccessible,
                .updating,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .enabled: return "ENABLED"
            case .kmsKeyInaccessible: return "KMS_KEY_INACCESSIBLE"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EncryptionStatus(rawValue: rawValue) ?? EncryptionStatus.sdkUnknown(rawValue)
        }
    }
}

extension QLDBClientTypes {
    public enum ErrorCause: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case iamPermissionRevoked
        case kinesisStreamNotFound
        case sdkUnknown(Swift.String)

        public static var allCases: [ErrorCause] {
            return [
                .iamPermissionRevoked,
                .kinesisStreamNotFound,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .iamPermissionRevoked: return "IAM_PERMISSION_REVOKED"
            case .kinesisStreamNotFound: return "KINESIS_STREAM_NOT_FOUND"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ErrorCause(rawValue: rawValue) ?? ErrorCause.sdkUnknown(rawValue)
        }
    }
}

extension ExportJournalToS3Input: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case exclusiveEndTime = "ExclusiveEndTime"
        case inclusiveStartTime = "InclusiveStartTime"
        case outputFormat = "OutputFormat"
        case roleArn = "RoleArn"
        case s3ExportConfiguration = "S3ExportConfiguration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let exclusiveEndTime = self.exclusiveEndTime {
            try encodeContainer.encodeTimestamp(exclusiveEndTime, format: .epochSeconds, forKey: .exclusiveEndTime)
        }
        if let inclusiveStartTime = self.inclusiveStartTime {
            try encodeContainer.encodeTimestamp(inclusiveStartTime, format: .epochSeconds, forKey: .inclusiveStartTime)
        }
        if let outputFormat = self.outputFormat {
            try encodeContainer.encode(outputFormat.rawValue, forKey: .outputFormat)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let s3ExportConfiguration = self.s3ExportConfiguration {
            try encodeContainer.encode(s3ExportConfiguration, forKey: .s3ExportConfiguration)
        }
    }
}

extension ExportJournalToS3Input: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let name = name else {
            return nil
        }
        return "/ledgers/\(name.urlPercentEncoding())/journal-s3-exports"
    }
}

public struct ExportJournalToS3Input: Swift.Equatable {
    /// The exclusive end date and time for the range of journal contents to export. The ExclusiveEndTime must be in ISO 8601 date and time format and in Universal Coordinated Time (UTC). For example: 2019-06-13T21:36:34Z. The ExclusiveEndTime must be less than or equal to the current UTC date and time.
    /// This member is required.
    public var exclusiveEndTime: ClientRuntime.Date?
    /// The inclusive start date and time for the range of journal contents to export. The InclusiveStartTime must be in ISO 8601 date and time format and in Universal Coordinated Time (UTC). For example: 2019-06-13T21:36:34Z. The InclusiveStartTime must be before ExclusiveEndTime. If you provide an InclusiveStartTime that is before the ledger's CreationDateTime, Amazon QLDB defaults it to the ledger's CreationDateTime.
    /// This member is required.
    public var inclusiveStartTime: ClientRuntime.Date?
    /// The name of the ledger.
    /// This member is required.
    public var name: Swift.String?
    /// The output format of your exported journal data. A journal export job can write the data objects in either the text or binary representation of [Amazon Ion](https://docs.aws.amazon.com/qldb/latest/developerguide/ion.html) format, or in [JSON Lines](https://jsonlines.org/) text format. Default: ION_TEXT In JSON Lines format, each journal block in an exported data object is a valid JSON object that is delimited by a newline. You can use this format to directly integrate JSON exports with analytics tools such as Amazon Athena and Glue because these services can parse newline-delimited JSON automatically.
    public var outputFormat: QLDBClientTypes.OutputFormat?
    /// The Amazon Resource Name (ARN) of the IAM role that grants QLDB permissions for a journal export job to do the following:
    ///
    /// * Write objects into your Amazon S3 bucket.
    ///
    /// * (Optional) Use your customer managed key in Key Management Service (KMS) for server-side encryption of your exported data.
    ///
    ///
    /// To pass a role to QLDB when requesting a journal export, you must have permissions to perform the iam:PassRole action on the IAM role resource. This is required for all journal export requests.
    /// This member is required.
    public var roleArn: Swift.String?
    /// The configuration settings of the Amazon S3 bucket destination for your export request.
    /// This member is required.
    public var s3ExportConfiguration: QLDBClientTypes.S3ExportConfiguration?

    public init(
        exclusiveEndTime: ClientRuntime.Date? = nil,
        inclusiveStartTime: ClientRuntime.Date? = nil,
        name: Swift.String? = nil,
        outputFormat: QLDBClientTypes.OutputFormat? = nil,
        roleArn: Swift.String? = nil,
        s3ExportConfiguration: QLDBClientTypes.S3ExportConfiguration? = nil
    )
    {
        self.exclusiveEndTime = exclusiveEndTime
        self.inclusiveStartTime = inclusiveStartTime
        self.name = name
        self.outputFormat = outputFormat
        self.roleArn = roleArn
        self.s3ExportConfiguration = s3ExportConfiguration
    }
}

struct ExportJournalToS3InputBody: Swift.Equatable {
    let inclusiveStartTime: ClientRuntime.Date?
    let exclusiveEndTime: ClientRuntime.Date?
    let s3ExportConfiguration: QLDBClientTypes.S3ExportConfiguration?
    let roleArn: Swift.String?
    let outputFormat: QLDBClientTypes.OutputFormat?
}

extension ExportJournalToS3InputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case exclusiveEndTime = "ExclusiveEndTime"
        case inclusiveStartTime = "InclusiveStartTime"
        case outputFormat = "OutputFormat"
        case roleArn = "RoleArn"
        case s3ExportConfiguration = "S3ExportConfiguration"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inclusiveStartTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .inclusiveStartTime)
        inclusiveStartTime = inclusiveStartTimeDecoded
        let exclusiveEndTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .exclusiveEndTime)
        exclusiveEndTime = exclusiveEndTimeDecoded
        let s3ExportConfigurationDecoded = try containerValues.decodeIfPresent(QLDBClientTypes.S3ExportConfiguration.self, forKey: .s3ExportConfiguration)
        s3ExportConfiguration = s3ExportConfigurationDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let outputFormatDecoded = try containerValues.decodeIfPresent(QLDBClientTypes.OutputFormat.self, forKey: .outputFormat)
        outputFormat = outputFormatDecoded
    }
}

extension ExportJournalToS3Output: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ExportJournalToS3OutputBody = try responseDecoder.decode(responseBody: data)
            self.exportId = output.exportId
        } else {
            self.exportId = nil
        }
    }
}

public struct ExportJournalToS3Output: Swift.Equatable {
    /// The UUID (represented in Base62-encoded text) that QLDB assigns to each journal export job. To describe your export request and check the status of the job, you can use ExportId to call DescribeJournalS3Export.
    /// This member is required.
    public var exportId: Swift.String?

    public init(
        exportId: Swift.String? = nil
    )
    {
        self.exportId = exportId
    }
}

struct ExportJournalToS3OutputBody: Swift.Equatable {
    let exportId: Swift.String?
}

extension ExportJournalToS3OutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case exportId = "ExportId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let exportIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .exportId)
        exportId = exportIdDecoded
    }
}

enum ExportJournalToS3OutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourcePreconditionNotMetException": return try await ResourcePreconditionNotMetException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension QLDBClientTypes {
    public enum ExportStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cancelled
        case completed
        case inProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [ExportStatus] {
            return [
                .cancelled,
                .completed,
                .inProgress,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cancelled: return "CANCELLED"
            case .completed: return "COMPLETED"
            case .inProgress: return "IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ExportStatus(rawValue: rawValue) ?? ExportStatus.sdkUnknown(rawValue)
        }
    }
}

extension GetBlockInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetBlockInput(name: \(Swift.String(describing: name)), blockAddress: \"CONTENT_REDACTED\", digestTipAddress: \"CONTENT_REDACTED\")"}
}

extension GetBlockInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case blockAddress = "BlockAddress"
        case digestTipAddress = "DigestTipAddress"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let blockAddress = self.blockAddress {
            try encodeContainer.encode(blockAddress, forKey: .blockAddress)
        }
        if let digestTipAddress = self.digestTipAddress {
            try encodeContainer.encode(digestTipAddress, forKey: .digestTipAddress)
        }
    }
}

extension GetBlockInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let name = name else {
            return nil
        }
        return "/ledgers/\(name.urlPercentEncoding())/block"
    }
}

public struct GetBlockInput: Swift.Equatable {
    /// The location of the block that you want to request. An address is an Amazon Ion structure that has two fields: strandId and sequenceNo. For example: {strandId:"BlFTjlSXze9BIh1KOszcE3",sequenceNo:14}.
    /// This member is required.
    public var blockAddress: QLDBClientTypes.ValueHolder?
    /// The latest block location covered by the digest for which to request a proof. An address is an Amazon Ion structure that has two fields: strandId and sequenceNo. For example: {strandId:"BlFTjlSXze9BIh1KOszcE3",sequenceNo:49}.
    public var digestTipAddress: QLDBClientTypes.ValueHolder?
    /// The name of the ledger.
    /// This member is required.
    public var name: Swift.String?

    public init(
        blockAddress: QLDBClientTypes.ValueHolder? = nil,
        digestTipAddress: QLDBClientTypes.ValueHolder? = nil,
        name: Swift.String? = nil
    )
    {
        self.blockAddress = blockAddress
        self.digestTipAddress = digestTipAddress
        self.name = name
    }
}

struct GetBlockInputBody: Swift.Equatable {
    let blockAddress: QLDBClientTypes.ValueHolder?
    let digestTipAddress: QLDBClientTypes.ValueHolder?
}

extension GetBlockInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case blockAddress = "BlockAddress"
        case digestTipAddress = "DigestTipAddress"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let blockAddressDecoded = try containerValues.decodeIfPresent(QLDBClientTypes.ValueHolder.self, forKey: .blockAddress)
        blockAddress = blockAddressDecoded
        let digestTipAddressDecoded = try containerValues.decodeIfPresent(QLDBClientTypes.ValueHolder.self, forKey: .digestTipAddress)
        digestTipAddress = digestTipAddressDecoded
    }
}

extension GetBlockOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetBlockOutput(block: \"CONTENT_REDACTED\", proof: \"CONTENT_REDACTED\")"}
}

extension GetBlockOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetBlockOutputBody = try responseDecoder.decode(responseBody: data)
            self.block = output.block
            self.proof = output.proof
        } else {
            self.block = nil
            self.proof = nil
        }
    }
}

public struct GetBlockOutput: Swift.Equatable {
    /// The block data object in Amazon Ion format.
    /// This member is required.
    public var block: QLDBClientTypes.ValueHolder?
    /// The proof object in Amazon Ion format returned by a GetBlock request. A proof contains the list of hash values required to recalculate the specified digest using a Merkle tree, starting with the specified block.
    public var proof: QLDBClientTypes.ValueHolder?

    public init(
        block: QLDBClientTypes.ValueHolder? = nil,
        proof: QLDBClientTypes.ValueHolder? = nil
    )
    {
        self.block = block
        self.proof = proof
    }
}

struct GetBlockOutputBody: Swift.Equatable {
    let block: QLDBClientTypes.ValueHolder?
    let proof: QLDBClientTypes.ValueHolder?
}

extension GetBlockOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case block = "Block"
        case proof = "Proof"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let blockDecoded = try containerValues.decodeIfPresent(QLDBClientTypes.ValueHolder.self, forKey: .block)
        block = blockDecoded
        let proofDecoded = try containerValues.decodeIfPresent(QLDBClientTypes.ValueHolder.self, forKey: .proof)
        proof = proofDecoded
    }
}

enum GetBlockOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourcePreconditionNotMetException": return try await ResourcePreconditionNotMetException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetDigestInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let name = name else {
            return nil
        }
        return "/ledgers/\(name.urlPercentEncoding())/digest"
    }
}

public struct GetDigestInput: Swift.Equatable {
    /// The name of the ledger.
    /// This member is required.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct GetDigestInputBody: Swift.Equatable {
}

extension GetDigestInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetDigestOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetDigestOutput(digest: \(Swift.String(describing: digest)), digestTipAddress: \"CONTENT_REDACTED\")"}
}

extension GetDigestOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetDigestOutputBody = try responseDecoder.decode(responseBody: data)
            self.digest = output.digest
            self.digestTipAddress = output.digestTipAddress
        } else {
            self.digest = nil
            self.digestTipAddress = nil
        }
    }
}

public struct GetDigestOutput: Swift.Equatable {
    /// The 256-bit hash value representing the digest returned by a GetDigest request.
    /// This member is required.
    public var digest: ClientRuntime.Data?
    /// The latest block location covered by the digest that you requested. An address is an Amazon Ion structure that has two fields: strandId and sequenceNo.
    /// This member is required.
    public var digestTipAddress: QLDBClientTypes.ValueHolder?

    public init(
        digest: ClientRuntime.Data? = nil,
        digestTipAddress: QLDBClientTypes.ValueHolder? = nil
    )
    {
        self.digest = digest
        self.digestTipAddress = digestTipAddress
    }
}

struct GetDigestOutputBody: Swift.Equatable {
    let digest: ClientRuntime.Data?
    let digestTipAddress: QLDBClientTypes.ValueHolder?
}

extension GetDigestOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case digest = "Digest"
        case digestTipAddress = "DigestTipAddress"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let digestDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .digest)
        digest = digestDecoded
        let digestTipAddressDecoded = try containerValues.decodeIfPresent(QLDBClientTypes.ValueHolder.self, forKey: .digestTipAddress)
        digestTipAddress = digestTipAddressDecoded
    }
}

enum GetDigestOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourcePreconditionNotMetException": return try await ResourcePreconditionNotMetException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetRevisionInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetRevisionInput(documentId: \(Swift.String(describing: documentId)), name: \(Swift.String(describing: name)), blockAddress: \"CONTENT_REDACTED\", digestTipAddress: \"CONTENT_REDACTED\")"}
}

extension GetRevisionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case blockAddress = "BlockAddress"
        case digestTipAddress = "DigestTipAddress"
        case documentId = "DocumentId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let blockAddress = self.blockAddress {
            try encodeContainer.encode(blockAddress, forKey: .blockAddress)
        }
        if let digestTipAddress = self.digestTipAddress {
            try encodeContainer.encode(digestTipAddress, forKey: .digestTipAddress)
        }
        if let documentId = self.documentId {
            try encodeContainer.encode(documentId, forKey: .documentId)
        }
    }
}

extension GetRevisionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let name = name else {
            return nil
        }
        return "/ledgers/\(name.urlPercentEncoding())/revision"
    }
}

public struct GetRevisionInput: Swift.Equatable {
    /// The block location of the document revision to be verified. An address is an Amazon Ion structure that has two fields: strandId and sequenceNo. For example: {strandId:"BlFTjlSXze9BIh1KOszcE3",sequenceNo:14}.
    /// This member is required.
    public var blockAddress: QLDBClientTypes.ValueHolder?
    /// The latest block location covered by the digest for which to request a proof. An address is an Amazon Ion structure that has two fields: strandId and sequenceNo. For example: {strandId:"BlFTjlSXze9BIh1KOszcE3",sequenceNo:49}.
    public var digestTipAddress: QLDBClientTypes.ValueHolder?
    /// The UUID (represented in Base62-encoded text) of the document to be verified.
    /// This member is required.
    public var documentId: Swift.String?
    /// The name of the ledger.
    /// This member is required.
    public var name: Swift.String?

    public init(
        blockAddress: QLDBClientTypes.ValueHolder? = nil,
        digestTipAddress: QLDBClientTypes.ValueHolder? = nil,
        documentId: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.blockAddress = blockAddress
        self.digestTipAddress = digestTipAddress
        self.documentId = documentId
        self.name = name
    }
}

struct GetRevisionInputBody: Swift.Equatable {
    let blockAddress: QLDBClientTypes.ValueHolder?
    let documentId: Swift.String?
    let digestTipAddress: QLDBClientTypes.ValueHolder?
}

extension GetRevisionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case blockAddress = "BlockAddress"
        case digestTipAddress = "DigestTipAddress"
        case documentId = "DocumentId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let blockAddressDecoded = try containerValues.decodeIfPresent(QLDBClientTypes.ValueHolder.self, forKey: .blockAddress)
        blockAddress = blockAddressDecoded
        let documentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .documentId)
        documentId = documentIdDecoded
        let digestTipAddressDecoded = try containerValues.decodeIfPresent(QLDBClientTypes.ValueHolder.self, forKey: .digestTipAddress)
        digestTipAddress = digestTipAddressDecoded
    }
}

extension GetRevisionOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetRevisionOutput(proof: \"CONTENT_REDACTED\", revision: \"CONTENT_REDACTED\")"}
}

extension GetRevisionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetRevisionOutputBody = try responseDecoder.decode(responseBody: data)
            self.proof = output.proof
            self.revision = output.revision
        } else {
            self.proof = nil
            self.revision = nil
        }
    }
}

public struct GetRevisionOutput: Swift.Equatable {
    /// The proof object in Amazon Ion format returned by a GetRevision request. A proof contains the list of hash values that are required to recalculate the specified digest using a Merkle tree, starting with the specified document revision.
    public var proof: QLDBClientTypes.ValueHolder?
    /// The document revision data object in Amazon Ion format.
    /// This member is required.
    public var revision: QLDBClientTypes.ValueHolder?

    public init(
        proof: QLDBClientTypes.ValueHolder? = nil,
        revision: QLDBClientTypes.ValueHolder? = nil
    )
    {
        self.proof = proof
        self.revision = revision
    }
}

struct GetRevisionOutputBody: Swift.Equatable {
    let proof: QLDBClientTypes.ValueHolder?
    let revision: QLDBClientTypes.ValueHolder?
}

extension GetRevisionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case proof = "Proof"
        case revision = "Revision"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let proofDecoded = try containerValues.decodeIfPresent(QLDBClientTypes.ValueHolder.self, forKey: .proof)
        proof = proofDecoded
        let revisionDecoded = try containerValues.decodeIfPresent(QLDBClientTypes.ValueHolder.self, forKey: .revision)
        revision = revisionDecoded
    }
}

enum GetRevisionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourcePreconditionNotMetException": return try await ResourcePreconditionNotMetException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension InvalidParameterException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidParameterExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.parameterName = output.parameterName
        } else {
            self.properties.message = nil
            self.properties.parameterName = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// One or more parameters in the request aren't valid.
public struct InvalidParameterException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        /// The name of the invalid parameter.
        public internal(set) var parameterName: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidParameterException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        parameterName: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.parameterName = parameterName
    }
}

struct InvalidParameterExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let parameterName: Swift.String?
}

extension InvalidParameterExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case parameterName = "ParameterName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let parameterNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parameterName)
        parameterName = parameterNameDecoded
    }
}

extension QLDBClientTypes.JournalKinesisStreamDescription: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case creationTime = "CreationTime"
        case errorCause = "ErrorCause"
        case exclusiveEndTime = "ExclusiveEndTime"
        case inclusiveStartTime = "InclusiveStartTime"
        case kinesisConfiguration = "KinesisConfiguration"
        case ledgerName = "LedgerName"
        case roleArn = "RoleArn"
        case status = "Status"
        case streamId = "StreamId"
        case streamName = "StreamName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let creationTime = self.creationTime {
            try encodeContainer.encodeTimestamp(creationTime, format: .epochSeconds, forKey: .creationTime)
        }
        if let errorCause = self.errorCause {
            try encodeContainer.encode(errorCause.rawValue, forKey: .errorCause)
        }
        if let exclusiveEndTime = self.exclusiveEndTime {
            try encodeContainer.encodeTimestamp(exclusiveEndTime, format: .epochSeconds, forKey: .exclusiveEndTime)
        }
        if let inclusiveStartTime = self.inclusiveStartTime {
            try encodeContainer.encodeTimestamp(inclusiveStartTime, format: .epochSeconds, forKey: .inclusiveStartTime)
        }
        if let kinesisConfiguration = self.kinesisConfiguration {
            try encodeContainer.encode(kinesisConfiguration, forKey: .kinesisConfiguration)
        }
        if let ledgerName = self.ledgerName {
            try encodeContainer.encode(ledgerName, forKey: .ledgerName)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let streamId = self.streamId {
            try encodeContainer.encode(streamId, forKey: .streamId)
        }
        if let streamName = self.streamName {
            try encodeContainer.encode(streamName, forKey: .streamName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ledgerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ledgerName)
        ledgerName = ledgerNameDecoded
        let creationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationTime)
        creationTime = creationTimeDecoded
        let inclusiveStartTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .inclusiveStartTime)
        inclusiveStartTime = inclusiveStartTimeDecoded
        let exclusiveEndTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .exclusiveEndTime)
        exclusiveEndTime = exclusiveEndTimeDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let streamIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamId)
        streamId = streamIdDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(QLDBClientTypes.StreamStatus.self, forKey: .status)
        status = statusDecoded
        let kinesisConfigurationDecoded = try containerValues.decodeIfPresent(QLDBClientTypes.KinesisConfiguration.self, forKey: .kinesisConfiguration)
        kinesisConfiguration = kinesisConfigurationDecoded
        let errorCauseDecoded = try containerValues.decodeIfPresent(QLDBClientTypes.ErrorCause.self, forKey: .errorCause)
        errorCause = errorCauseDecoded
        let streamNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamName)
        streamName = streamNameDecoded
    }
}

extension QLDBClientTypes {
    /// Information about an Amazon QLDB journal stream, including the Amazon Resource Name (ARN), stream name, creation time, current status, and the parameters of the original stream creation request.
    public struct JournalKinesisStreamDescription: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the QLDB journal stream.
        public var arn: Swift.String?
        /// The date and time, in epoch time format, when the QLDB journal stream was created. (Epoch time format is the number of seconds elapsed since 12:00:00 AM January 1, 1970 UTC.)
        public var creationTime: ClientRuntime.Date?
        /// The error message that describes the reason that a stream has a status of IMPAIRED or FAILED. This is not applicable to streams that have other status values.
        public var errorCause: QLDBClientTypes.ErrorCause?
        /// The exclusive date and time that specifies when the stream ends. If this parameter is undefined, the stream runs indefinitely until you cancel it.
        public var exclusiveEndTime: ClientRuntime.Date?
        /// The inclusive start date and time from which to start streaming journal data.
        public var inclusiveStartTime: ClientRuntime.Date?
        /// The configuration settings of the Amazon Kinesis Data Streams destination for a QLDB journal stream.
        /// This member is required.
        public var kinesisConfiguration: QLDBClientTypes.KinesisConfiguration?
        /// The name of the ledger.
        /// This member is required.
        public var ledgerName: Swift.String?
        /// The Amazon Resource Name (ARN) of the IAM role that grants QLDB permissions for a journal stream to write data records to a Kinesis Data Streams resource.
        /// This member is required.
        public var roleArn: Swift.String?
        /// The current state of the QLDB journal stream.
        /// This member is required.
        public var status: QLDBClientTypes.StreamStatus?
        /// The UUID (represented in Base62-encoded text) of the QLDB journal stream.
        /// This member is required.
        public var streamId: Swift.String?
        /// The user-defined name of the QLDB journal stream.
        /// This member is required.
        public var streamName: Swift.String?

        public init(
            arn: Swift.String? = nil,
            creationTime: ClientRuntime.Date? = nil,
            errorCause: QLDBClientTypes.ErrorCause? = nil,
            exclusiveEndTime: ClientRuntime.Date? = nil,
            inclusiveStartTime: ClientRuntime.Date? = nil,
            kinesisConfiguration: QLDBClientTypes.KinesisConfiguration? = nil,
            ledgerName: Swift.String? = nil,
            roleArn: Swift.String? = nil,
            status: QLDBClientTypes.StreamStatus? = nil,
            streamId: Swift.String? = nil,
            streamName: Swift.String? = nil
        )
        {
            self.arn = arn
            self.creationTime = creationTime
            self.errorCause = errorCause
            self.exclusiveEndTime = exclusiveEndTime
            self.inclusiveStartTime = inclusiveStartTime
            self.kinesisConfiguration = kinesisConfiguration
            self.ledgerName = ledgerName
            self.roleArn = roleArn
            self.status = status
            self.streamId = streamId
            self.streamName = streamName
        }
    }

}

extension QLDBClientTypes.JournalS3ExportDescription: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case exclusiveEndTime = "ExclusiveEndTime"
        case exportCreationTime = "ExportCreationTime"
        case exportId = "ExportId"
        case inclusiveStartTime = "InclusiveStartTime"
        case ledgerName = "LedgerName"
        case outputFormat = "OutputFormat"
        case roleArn = "RoleArn"
        case s3ExportConfiguration = "S3ExportConfiguration"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let exclusiveEndTime = self.exclusiveEndTime {
            try encodeContainer.encodeTimestamp(exclusiveEndTime, format: .epochSeconds, forKey: .exclusiveEndTime)
        }
        if let exportCreationTime = self.exportCreationTime {
            try encodeContainer.encodeTimestamp(exportCreationTime, format: .epochSeconds, forKey: .exportCreationTime)
        }
        if let exportId = self.exportId {
            try encodeContainer.encode(exportId, forKey: .exportId)
        }
        if let inclusiveStartTime = self.inclusiveStartTime {
            try encodeContainer.encodeTimestamp(inclusiveStartTime, format: .epochSeconds, forKey: .inclusiveStartTime)
        }
        if let ledgerName = self.ledgerName {
            try encodeContainer.encode(ledgerName, forKey: .ledgerName)
        }
        if let outputFormat = self.outputFormat {
            try encodeContainer.encode(outputFormat.rawValue, forKey: .outputFormat)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let s3ExportConfiguration = self.s3ExportConfiguration {
            try encodeContainer.encode(s3ExportConfiguration, forKey: .s3ExportConfiguration)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ledgerNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ledgerName)
        ledgerName = ledgerNameDecoded
        let exportIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .exportId)
        exportId = exportIdDecoded
        let exportCreationTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .exportCreationTime)
        exportCreationTime = exportCreationTimeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(QLDBClientTypes.ExportStatus.self, forKey: .status)
        status = statusDecoded
        let inclusiveStartTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .inclusiveStartTime)
        inclusiveStartTime = inclusiveStartTimeDecoded
        let exclusiveEndTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .exclusiveEndTime)
        exclusiveEndTime = exclusiveEndTimeDecoded
        let s3ExportConfigurationDecoded = try containerValues.decodeIfPresent(QLDBClientTypes.S3ExportConfiguration.self, forKey: .s3ExportConfiguration)
        s3ExportConfiguration = s3ExportConfigurationDecoded
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let outputFormatDecoded = try containerValues.decodeIfPresent(QLDBClientTypes.OutputFormat.self, forKey: .outputFormat)
        outputFormat = outputFormatDecoded
    }
}

extension QLDBClientTypes {
    /// Information about a journal export job, including the ledger name, export ID, creation time, current status, and the parameters of the original export creation request.
    public struct JournalS3ExportDescription: Swift.Equatable {
        /// The exclusive end date and time for the range of journal contents that was specified in the original export request.
        /// This member is required.
        public var exclusiveEndTime: ClientRuntime.Date?
        /// The date and time, in epoch time format, when the export job was created. (Epoch time format is the number of seconds elapsed since 12:00:00 AM January 1, 1970 UTC.)
        /// This member is required.
        public var exportCreationTime: ClientRuntime.Date?
        /// The UUID (represented in Base62-encoded text) of the journal export job.
        /// This member is required.
        public var exportId: Swift.String?
        /// The inclusive start date and time for the range of journal contents that was specified in the original export request.
        /// This member is required.
        public var inclusiveStartTime: ClientRuntime.Date?
        /// The name of the ledger.
        /// This member is required.
        public var ledgerName: Swift.String?
        /// The output format of the exported journal data.
        public var outputFormat: QLDBClientTypes.OutputFormat?
        /// The Amazon Resource Name (ARN) of the IAM role that grants QLDB permissions for a journal export job to do the following:
        ///
        /// * Write objects into your Amazon Simple Storage Service (Amazon S3) bucket.
        ///
        /// * (Optional) Use your customer managed key in Key Management Service (KMS) for server-side encryption of your exported data.
        /// This member is required.
        public var roleArn: Swift.String?
        /// The Amazon Simple Storage Service (Amazon S3) bucket location in which a journal export job writes the journal contents.
        /// This member is required.
        public var s3ExportConfiguration: QLDBClientTypes.S3ExportConfiguration?
        /// The current state of the journal export job.
        /// This member is required.
        public var status: QLDBClientTypes.ExportStatus?

        public init(
            exclusiveEndTime: ClientRuntime.Date? = nil,
            exportCreationTime: ClientRuntime.Date? = nil,
            exportId: Swift.String? = nil,
            inclusiveStartTime: ClientRuntime.Date? = nil,
            ledgerName: Swift.String? = nil,
            outputFormat: QLDBClientTypes.OutputFormat? = nil,
            roleArn: Swift.String? = nil,
            s3ExportConfiguration: QLDBClientTypes.S3ExportConfiguration? = nil,
            status: QLDBClientTypes.ExportStatus? = nil
        )
        {
            self.exclusiveEndTime = exclusiveEndTime
            self.exportCreationTime = exportCreationTime
            self.exportId = exportId
            self.inclusiveStartTime = inclusiveStartTime
            self.ledgerName = ledgerName
            self.outputFormat = outputFormat
            self.roleArn = roleArn
            self.s3ExportConfiguration = s3ExportConfiguration
            self.status = status
        }
    }

}

extension QLDBClientTypes.KinesisConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aggregationEnabled = "AggregationEnabled"
        case streamArn = "StreamArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aggregationEnabled = self.aggregationEnabled {
            try encodeContainer.encode(aggregationEnabled, forKey: .aggregationEnabled)
        }
        if let streamArn = self.streamArn {
            try encodeContainer.encode(streamArn, forKey: .streamArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamArn)
        streamArn = streamArnDecoded
        let aggregationEnabledDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .aggregationEnabled)
        aggregationEnabled = aggregationEnabledDecoded
    }
}

extension QLDBClientTypes {
    /// The configuration settings of the Amazon Kinesis Data Streams destination for an Amazon QLDB journal stream.
    public struct KinesisConfiguration: Swift.Equatable {
        /// Enables QLDB to publish multiple data records in a single Kinesis Data Streams record, increasing the number of records sent per API call. Default: True Record aggregation has important implications for processing records and requires de-aggregation in your stream consumer. To learn more, see [KPL Key Concepts](https://docs.aws.amazon.com/streams/latest/dev/kinesis-kpl-concepts.html) and [Consumer De-aggregation](https://docs.aws.amazon.com/streams/latest/dev/kinesis-kpl-consumer-deaggregation.html) in the Amazon Kinesis Data Streams Developer Guide.
        public var aggregationEnabled: Swift.Bool?
        /// The Amazon Resource Name (ARN) of the Kinesis Data Streams resource.
        /// This member is required.
        public var streamArn: Swift.String?

        public init(
            aggregationEnabled: Swift.Bool? = nil,
            streamArn: Swift.String? = nil
        )
        {
            self.aggregationEnabled = aggregationEnabled
            self.streamArn = streamArn
        }
    }

}

extension QLDBClientTypes.LedgerEncryptionDescription: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case encryptionStatus = "EncryptionStatus"
        case inaccessibleKmsKeyDateTime = "InaccessibleKmsKeyDateTime"
        case kmsKeyArn = "KmsKeyArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let encryptionStatus = self.encryptionStatus {
            try encodeContainer.encode(encryptionStatus.rawValue, forKey: .encryptionStatus)
        }
        if let inaccessibleKmsKeyDateTime = self.inaccessibleKmsKeyDateTime {
            try encodeContainer.encodeTimestamp(inaccessibleKmsKeyDateTime, format: .epochSeconds, forKey: .inaccessibleKmsKeyDateTime)
        }
        if let kmsKeyArn = self.kmsKeyArn {
            try encodeContainer.encode(kmsKeyArn, forKey: .kmsKeyArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let kmsKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyArn)
        kmsKeyArn = kmsKeyArnDecoded
        let encryptionStatusDecoded = try containerValues.decodeIfPresent(QLDBClientTypes.EncryptionStatus.self, forKey: .encryptionStatus)
        encryptionStatus = encryptionStatusDecoded
        let inaccessibleKmsKeyDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .inaccessibleKmsKeyDateTime)
        inaccessibleKmsKeyDateTime = inaccessibleKmsKeyDateTimeDecoded
    }
}

extension QLDBClientTypes {
    /// Information about the encryption of data at rest in an Amazon QLDB ledger. This includes the current status, the key in Key Management Service (KMS), and when the key became inaccessible (in the case of an error). For more information, see [Encryption at rest](https://docs.aws.amazon.com/qldb/latest/developerguide/encryption-at-rest.html) in the Amazon QLDB Developer Guide.
    public struct LedgerEncryptionDescription: Swift.Equatable {
        /// The current state of encryption at rest for the ledger. This can be one of the following values:
        ///
        /// * ENABLED: Encryption is fully enabled using the specified key.
        ///
        /// * UPDATING: The ledger is actively processing the specified key change. Key changes in QLDB are asynchronous. The ledger is fully accessible without any performance impact while the key change is being processed. The amount of time it takes to update a key varies depending on the ledger size.
        ///
        /// * KMS_KEY_INACCESSIBLE: The specified customer managed KMS key is not accessible, and the ledger is impaired. Either the key was disabled or deleted, or the grants on the key were revoked. When a ledger is impaired, it is not accessible and does not accept any read or write requests. An impaired ledger automatically returns to an active state after you restore the grants on the key, or re-enable the key that was disabled. However, deleting a customer managed KMS key is irreversible. After a key is deleted, you can no longer access the ledgers that are protected with that key, and the data becomes unrecoverable permanently.
        /// This member is required.
        public var encryptionStatus: QLDBClientTypes.EncryptionStatus?
        /// The date and time, in epoch time format, when the KMS key first became inaccessible, in the case of an error. (Epoch time format is the number of seconds that have elapsed since 12:00:00 AM January 1, 1970 UTC.) This parameter is undefined if the KMS key is accessible.
        public var inaccessibleKmsKeyDateTime: ClientRuntime.Date?
        /// The Amazon Resource Name (ARN) of the customer managed KMS key that the ledger uses for encryption at rest. If this parameter is undefined, the ledger uses an Amazon Web Services owned KMS key for encryption.
        /// This member is required.
        public var kmsKeyArn: Swift.String?

        public init(
            encryptionStatus: QLDBClientTypes.EncryptionStatus? = nil,
            inaccessibleKmsKeyDateTime: ClientRuntime.Date? = nil,
            kmsKeyArn: Swift.String? = nil
        )
        {
            self.encryptionStatus = encryptionStatus
            self.inaccessibleKmsKeyDateTime = inaccessibleKmsKeyDateTime
            self.kmsKeyArn = kmsKeyArn
        }
    }

}

extension QLDBClientTypes {
    public enum LedgerState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case creating
        case deleted
        case deleting
        case sdkUnknown(Swift.String)

        public static var allCases: [LedgerState] {
            return [
                .active,
                .creating,
                .deleted,
                .deleting,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .creating: return "CREATING"
            case .deleted: return "DELETED"
            case .deleting: return "DELETING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LedgerState(rawValue: rawValue) ?? LedgerState.sdkUnknown(rawValue)
        }
    }
}

extension QLDBClientTypes.LedgerSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case creationDateTime = "CreationDateTime"
        case name = "Name"
        case state = "State"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let creationDateTime = self.creationDateTime {
            try encodeContainer.encodeTimestamp(creationDateTime, format: .epochSeconds, forKey: .creationDateTime)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let state = self.state {
            try encodeContainer.encode(state.rawValue, forKey: .state)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let stateDecoded = try containerValues.decodeIfPresent(QLDBClientTypes.LedgerState.self, forKey: .state)
        state = stateDecoded
        let creationDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
    }
}

extension QLDBClientTypes {
    /// Information about a ledger, including its name, state, and when it was created.
    public struct LedgerSummary: Swift.Equatable {
        /// The date and time, in epoch time format, when the ledger was created. (Epoch time format is the number of seconds elapsed since 12:00:00 AM January 1, 1970 UTC.)
        public var creationDateTime: ClientRuntime.Date?
        /// The name of the ledger.
        public var name: Swift.String?
        /// The current status of the ledger.
        public var state: QLDBClientTypes.LedgerState?

        public init(
            creationDateTime: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            state: QLDBClientTypes.LedgerState? = nil
        )
        {
            self.creationDateTime = creationDateTime
            self.name = name
            self.state = state
        }
    }

}

extension LimitExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: LimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.resourceType = output.resourceType
        } else {
            self.properties.message = nil
            self.properties.resourceType = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// You have reached the limit on the maximum number of resources allowed.
public struct LimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        /// The type of resource.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "LimitExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceType = resourceType
    }
}

struct LimitExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceType: Swift.String?
}

extension LimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case resourceType = "ResourceType"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension ListJournalKinesisStreamsForLedgerInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next_token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max_results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListJournalKinesisStreamsForLedgerInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let ledgerName = ledgerName else {
            return nil
        }
        return "/ledgers/\(ledgerName.urlPercentEncoding())/journal-kinesis-streams"
    }
}

public struct ListJournalKinesisStreamsForLedgerInput: Swift.Equatable {
    /// The name of the ledger.
    /// This member is required.
    public var ledgerName: Swift.String?
    /// The maximum number of results to return in a single ListJournalKinesisStreamsForLedger request. (The actual number of results returned might be fewer.)
    public var maxResults: Swift.Int?
    /// A pagination token, indicating that you want to retrieve the next page of results. If you received a value for NextToken in the response from a previous ListJournalKinesisStreamsForLedger call, you should use that value as input here.
    public var nextToken: Swift.String?

    public init(
        ledgerName: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.ledgerName = ledgerName
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListJournalKinesisStreamsForLedgerInputBody: Swift.Equatable {
}

extension ListJournalKinesisStreamsForLedgerInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListJournalKinesisStreamsForLedgerOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListJournalKinesisStreamsForLedgerOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.streams = output.streams
        } else {
            self.nextToken = nil
            self.streams = nil
        }
    }
}

public struct ListJournalKinesisStreamsForLedgerOutput: Swift.Equatable {
    /// * If NextToken is empty, the last page of results has been processed and there are no more results to be retrieved.
    ///
    /// * If NextToken is not empty, more results are available. To retrieve the next page of results, use the value of NextToken in a subsequent ListJournalKinesisStreamsForLedger call.
    public var nextToken: Swift.String?
    /// The QLDB journal streams that are currently associated with the given ledger.
    public var streams: [QLDBClientTypes.JournalKinesisStreamDescription]?

    public init(
        nextToken: Swift.String? = nil,
        streams: [QLDBClientTypes.JournalKinesisStreamDescription]? = nil
    )
    {
        self.nextToken = nextToken
        self.streams = streams
    }
}

struct ListJournalKinesisStreamsForLedgerOutputBody: Swift.Equatable {
    let streams: [QLDBClientTypes.JournalKinesisStreamDescription]?
    let nextToken: Swift.String?
}

extension ListJournalKinesisStreamsForLedgerOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case streams = "Streams"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamsContainer = try containerValues.decodeIfPresent([QLDBClientTypes.JournalKinesisStreamDescription?].self, forKey: .streams)
        var streamsDecoded0:[QLDBClientTypes.JournalKinesisStreamDescription]? = nil
        if let streamsContainer = streamsContainer {
            streamsDecoded0 = [QLDBClientTypes.JournalKinesisStreamDescription]()
            for structure0 in streamsContainer {
                if let structure0 = structure0 {
                    streamsDecoded0?.append(structure0)
                }
            }
        }
        streams = streamsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListJournalKinesisStreamsForLedgerOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourcePreconditionNotMetException": return try await ResourcePreconditionNotMetException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListJournalS3ExportsForLedgerInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next_token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max_results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListJournalS3ExportsForLedgerInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let name = name else {
            return nil
        }
        return "/ledgers/\(name.urlPercentEncoding())/journal-s3-exports"
    }
}

public struct ListJournalS3ExportsForLedgerInput: Swift.Equatable {
    /// The maximum number of results to return in a single ListJournalS3ExportsForLedger request. (The actual number of results returned might be fewer.)
    public var maxResults: Swift.Int?
    /// The name of the ledger.
    /// This member is required.
    public var name: Swift.String?
    /// A pagination token, indicating that you want to retrieve the next page of results. If you received a value for NextToken in the response from a previous ListJournalS3ExportsForLedger call, then you should use that value as input here.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        name: Swift.String? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.name = name
        self.nextToken = nextToken
    }
}

struct ListJournalS3ExportsForLedgerInputBody: Swift.Equatable {
}

extension ListJournalS3ExportsForLedgerInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListJournalS3ExportsForLedgerOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListJournalS3ExportsForLedgerOutputBody = try responseDecoder.decode(responseBody: data)
            self.journalS3Exports = output.journalS3Exports
            self.nextToken = output.nextToken
        } else {
            self.journalS3Exports = nil
            self.nextToken = nil
        }
    }
}

public struct ListJournalS3ExportsForLedgerOutput: Swift.Equatable {
    /// The journal export jobs that are currently associated with the specified ledger.
    public var journalS3Exports: [QLDBClientTypes.JournalS3ExportDescription]?
    /// * If NextToken is empty, then the last page of results has been processed and there are no more results to be retrieved.
    ///
    /// * If NextToken is not empty, then there are more results available. To retrieve the next page of results, use the value of NextToken in a subsequent ListJournalS3ExportsForLedger call.
    public var nextToken: Swift.String?

    public init(
        journalS3Exports: [QLDBClientTypes.JournalS3ExportDescription]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.journalS3Exports = journalS3Exports
        self.nextToken = nextToken
    }
}

struct ListJournalS3ExportsForLedgerOutputBody: Swift.Equatable {
    let journalS3Exports: [QLDBClientTypes.JournalS3ExportDescription]?
    let nextToken: Swift.String?
}

extension ListJournalS3ExportsForLedgerOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case journalS3Exports = "JournalS3Exports"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let journalS3ExportsContainer = try containerValues.decodeIfPresent([QLDBClientTypes.JournalS3ExportDescription?].self, forKey: .journalS3Exports)
        var journalS3ExportsDecoded0:[QLDBClientTypes.JournalS3ExportDescription]? = nil
        if let journalS3ExportsContainer = journalS3ExportsContainer {
            journalS3ExportsDecoded0 = [QLDBClientTypes.JournalS3ExportDescription]()
            for structure0 in journalS3ExportsContainer {
                if let structure0 = structure0 {
                    journalS3ExportsDecoded0?.append(structure0)
                }
            }
        }
        journalS3Exports = journalS3ExportsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListJournalS3ExportsForLedgerOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListJournalS3ExportsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next_token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max_results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListJournalS3ExportsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/journal-s3-exports"
    }
}

public struct ListJournalS3ExportsInput: Swift.Equatable {
    /// The maximum number of results to return in a single ListJournalS3Exports request. (The actual number of results returned might be fewer.)
    public var maxResults: Swift.Int?
    /// A pagination token, indicating that you want to retrieve the next page of results. If you received a value for NextToken in the response from a previous ListJournalS3Exports call, then you should use that value as input here.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListJournalS3ExportsInputBody: Swift.Equatable {
}

extension ListJournalS3ExportsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListJournalS3ExportsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListJournalS3ExportsOutputBody = try responseDecoder.decode(responseBody: data)
            self.journalS3Exports = output.journalS3Exports
            self.nextToken = output.nextToken
        } else {
            self.journalS3Exports = nil
            self.nextToken = nil
        }
    }
}

public struct ListJournalS3ExportsOutput: Swift.Equatable {
    /// The journal export jobs for all ledgers that are associated with the current Amazon Web Services account and Region.
    public var journalS3Exports: [QLDBClientTypes.JournalS3ExportDescription]?
    /// * If NextToken is empty, then the last page of results has been processed and there are no more results to be retrieved.
    ///
    /// * If NextToken is not empty, then there are more results available. To retrieve the next page of results, use the value of NextToken in a subsequent ListJournalS3Exports call.
    public var nextToken: Swift.String?

    public init(
        journalS3Exports: [QLDBClientTypes.JournalS3ExportDescription]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.journalS3Exports = journalS3Exports
        self.nextToken = nextToken
    }
}

struct ListJournalS3ExportsOutputBody: Swift.Equatable {
    let journalS3Exports: [QLDBClientTypes.JournalS3ExportDescription]?
    let nextToken: Swift.String?
}

extension ListJournalS3ExportsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case journalS3Exports = "JournalS3Exports"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let journalS3ExportsContainer = try containerValues.decodeIfPresent([QLDBClientTypes.JournalS3ExportDescription?].self, forKey: .journalS3Exports)
        var journalS3ExportsDecoded0:[QLDBClientTypes.JournalS3ExportDescription]? = nil
        if let journalS3ExportsContainer = journalS3ExportsContainer {
            journalS3ExportsDecoded0 = [QLDBClientTypes.JournalS3ExportDescription]()
            for structure0 in journalS3ExportsContainer {
                if let structure0 = structure0 {
                    journalS3ExportsDecoded0?.append(structure0)
                }
            }
        }
        journalS3Exports = journalS3ExportsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListJournalS3ExportsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListLedgersInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "next_token".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "max_results".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListLedgersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/ledgers"
    }
}

public struct ListLedgersInput: Swift.Equatable {
    /// The maximum number of results to return in a single ListLedgers request. (The actual number of results returned might be fewer.)
    public var maxResults: Swift.Int?
    /// A pagination token, indicating that you want to retrieve the next page of results. If you received a value for NextToken in the response from a previous ListLedgers call, then you should use that value as input here.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListLedgersInputBody: Swift.Equatable {
}

extension ListLedgersInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListLedgersOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListLedgersOutputBody = try responseDecoder.decode(responseBody: data)
            self.ledgers = output.ledgers
            self.nextToken = output.nextToken
        } else {
            self.ledgers = nil
            self.nextToken = nil
        }
    }
}

public struct ListLedgersOutput: Swift.Equatable {
    /// The ledgers that are associated with the current Amazon Web Services account and Region.
    public var ledgers: [QLDBClientTypes.LedgerSummary]?
    /// A pagination token, indicating whether there are more results available:
    ///
    /// * If NextToken is empty, then the last page of results has been processed and there are no more results to be retrieved.
    ///
    /// * If NextToken is not empty, then there are more results available. To retrieve the next page of results, use the value of NextToken in a subsequent ListLedgers call.
    public var nextToken: Swift.String?

    public init(
        ledgers: [QLDBClientTypes.LedgerSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.ledgers = ledgers
        self.nextToken = nextToken
    }
}

struct ListLedgersOutputBody: Swift.Equatable {
    let ledgers: [QLDBClientTypes.LedgerSummary]?
    let nextToken: Swift.String?
}

extension ListLedgersOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ledgers = "Ledgers"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ledgersContainer = try containerValues.decodeIfPresent([QLDBClientTypes.LedgerSummary?].self, forKey: .ledgers)
        var ledgersDecoded0:[QLDBClientTypes.LedgerSummary]? = nil
        if let ledgersContainer = ledgersContainer {
            ledgersDecoded0 = [QLDBClientTypes.LedgerSummary]()
            for structure0 in ledgersContainer {
                if let structure0 = structure0 {
                    ledgersDecoded0?.append(structure0)
                }
            }
        }
        ledgers = ledgersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListLedgersOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) for which to list the tags. For example: arn:aws:qldb:us-east-1:123456789012:ledger/exampleLedger
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutput: Swift.Equatable {
    /// The tags that are currently associated with the specified Amazon QLDB resource.
    public var tags: [Swift.String:Swift.String?]?

    public init(
        tags: [Swift.String:Swift.String?]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String?]?
}

extension ListTagsForResourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String?]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String?]()
            for (key0, tagvalue0) in tagsContainer {
                tagsDecoded0?[key0] = tagvalue0
            }
        }
        tags = tagsDecoded0
    }
}

enum ListTagsForResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension QLDBClientTypes {
    public enum OutputFormat: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ionBinary
        case ionText
        case json
        case sdkUnknown(Swift.String)

        public static var allCases: [OutputFormat] {
            return [
                .ionBinary,
                .ionText,
                .json,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ionBinary: return "ION_BINARY"
            case .ionText: return "ION_TEXT"
            case .json: return "JSON"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OutputFormat(rawValue: rawValue) ?? OutputFormat.sdkUnknown(rawValue)
        }
    }
}

extension QLDBClientTypes {
    public enum PermissionsMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case allowAll
        case standard
        case sdkUnknown(Swift.String)

        public static var allCases: [PermissionsMode] {
            return [
                .allowAll,
                .standard,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .allowAll: return "ALLOW_ALL"
            case .standard: return "STANDARD"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PermissionsMode(rawValue: rawValue) ?? PermissionsMode.sdkUnknown(rawValue)
        }
    }
}

extension ResourceAlreadyExistsException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceAlreadyExistsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.resourceName = output.resourceName
            self.properties.resourceType = output.resourceType
        } else {
            self.properties.message = nil
            self.properties.resourceName = nil
            self.properties.resourceType = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The specified resource already exists.
public struct ResourceAlreadyExistsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        /// The name of the resource.
        public internal(set) var resourceName: Swift.String? = nil
        /// The type of resource.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceAlreadyExistsException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceName: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceName = resourceName
        self.properties.resourceType = resourceType
    }
}

struct ResourceAlreadyExistsExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceType: Swift.String?
    let resourceName: Swift.String?
}

extension ResourceAlreadyExistsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case resourceName = "ResourceName"
        case resourceType = "ResourceType"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let resourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
    }
}

extension ResourceInUseException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceInUseExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.resourceName = output.resourceName
            self.properties.resourceType = output.resourceType
        } else {
            self.properties.message = nil
            self.properties.resourceName = nil
            self.properties.resourceType = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The specified resource can't be modified at this time.
public struct ResourceInUseException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        /// The name of the resource.
        public internal(set) var resourceName: Swift.String? = nil
        /// The type of resource.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceInUseException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceName: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceName = resourceName
        self.properties.resourceType = resourceType
    }
}

struct ResourceInUseExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceType: Swift.String?
    let resourceName: Swift.String?
}

extension ResourceInUseExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case resourceName = "ResourceName"
        case resourceType = "ResourceType"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let resourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
    }
}

extension ResourceNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.resourceName = output.resourceName
            self.properties.resourceType = output.resourceType
        } else {
            self.properties.message = nil
            self.properties.resourceName = nil
            self.properties.resourceType = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The specified resource doesn't exist.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        /// The name of the resource.
        public internal(set) var resourceName: Swift.String? = nil
        /// The type of resource.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceName: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceName = resourceName
        self.properties.resourceType = resourceType
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceType: Swift.String?
    let resourceName: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case resourceName = "ResourceName"
        case resourceType = "ResourceType"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let resourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
    }
}

extension ResourcePreconditionNotMetException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourcePreconditionNotMetExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.resourceName = output.resourceName
            self.properties.resourceType = output.resourceType
        } else {
            self.properties.message = nil
            self.properties.resourceName = nil
            self.properties.resourceType = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The operation failed because a condition wasn't satisfied in advance.
public struct ResourcePreconditionNotMetException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        /// The name of the resource.
        public internal(set) var resourceName: Swift.String? = nil
        /// The type of resource.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourcePreconditionNotMetException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceName: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceName = resourceName
        self.properties.resourceType = resourceType
    }
}

struct ResourcePreconditionNotMetExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceType: Swift.String?
    let resourceName: Swift.String?
}

extension ResourcePreconditionNotMetExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case resourceName = "ResourceName"
        case resourceType = "ResourceType"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let resourceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceName)
        resourceName = resourceNameDecoded
    }
}

extension QLDBClientTypes.S3EncryptionConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case kmsKeyArn = "KmsKeyArn"
        case objectEncryptionType = "ObjectEncryptionType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let kmsKeyArn = self.kmsKeyArn {
            try encodeContainer.encode(kmsKeyArn, forKey: .kmsKeyArn)
        }
        if let objectEncryptionType = self.objectEncryptionType {
            try encodeContainer.encode(objectEncryptionType.rawValue, forKey: .objectEncryptionType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let objectEncryptionTypeDecoded = try containerValues.decodeIfPresent(QLDBClientTypes.S3ObjectEncryptionType.self, forKey: .objectEncryptionType)
        objectEncryptionType = objectEncryptionTypeDecoded
        let kmsKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyArn)
        kmsKeyArn = kmsKeyArnDecoded
    }
}

extension QLDBClientTypes {
    /// The encryption settings that are used by a journal export job to write data in an Amazon Simple Storage Service (Amazon S3) bucket.
    public struct S3EncryptionConfiguration: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of a symmetric encryption key in Key Management Service (KMS). Amazon S3 does not support asymmetric KMS keys. You must provide a KmsKeyArn if you specify SSE_KMS as the ObjectEncryptionType. KmsKeyArn is not required if you specify SSE_S3 as the ObjectEncryptionType.
        public var kmsKeyArn: Swift.String?
        /// The Amazon S3 object encryption type. To learn more about server-side encryption options in Amazon S3, see [Protecting Data Using Server-Side Encryption](https://docs.aws.amazon.com/AmazonS3/latest/dev/serv-side-encryption.html) in the Amazon S3 Developer Guide.
        /// This member is required.
        public var objectEncryptionType: QLDBClientTypes.S3ObjectEncryptionType?

        public init(
            kmsKeyArn: Swift.String? = nil,
            objectEncryptionType: QLDBClientTypes.S3ObjectEncryptionType? = nil
        )
        {
            self.kmsKeyArn = kmsKeyArn
            self.objectEncryptionType = objectEncryptionType
        }
    }

}

extension QLDBClientTypes.S3ExportConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucket = "Bucket"
        case encryptionConfiguration = "EncryptionConfiguration"
        case `prefix` = "Prefix"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucket = self.bucket {
            try encodeContainer.encode(bucket, forKey: .bucket)
        }
        if let encryptionConfiguration = self.encryptionConfiguration {
            try encodeContainer.encode(encryptionConfiguration, forKey: .encryptionConfiguration)
        }
        if let `prefix` = self.`prefix` {
            try encodeContainer.encode(`prefix`, forKey: .`prefix`)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucket)
        bucket = bucketDecoded
        let prefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .prefix)
        `prefix` = prefixDecoded
        let encryptionConfigurationDecoded = try containerValues.decodeIfPresent(QLDBClientTypes.S3EncryptionConfiguration.self, forKey: .encryptionConfiguration)
        encryptionConfiguration = encryptionConfigurationDecoded
    }
}

extension QLDBClientTypes {
    /// The Amazon Simple Storage Service (Amazon S3) bucket location in which a journal export job writes the journal contents.
    public struct S3ExportConfiguration: Swift.Equatable {
        /// The Amazon S3 bucket name in which a journal export job writes the journal contents. The bucket name must comply with the Amazon S3 bucket naming conventions. For more information, see [Bucket Restrictions and Limitations](https://docs.aws.amazon.com/AmazonS3/latest/dev/BucketRestrictions.html) in the Amazon S3 Developer Guide.
        /// This member is required.
        public var bucket: Swift.String?
        /// The encryption settings that are used by a journal export job to write data in an Amazon S3 bucket.
        /// This member is required.
        public var encryptionConfiguration: QLDBClientTypes.S3EncryptionConfiguration?
        /// The prefix for the Amazon S3 bucket in which a journal export job writes the journal contents. The prefix must comply with Amazon S3 key naming rules and restrictions. For more information, see [Object Key and Metadata](https://docs.aws.amazon.com/AmazonS3/latest/dev/UsingMetadata.html) in the Amazon S3 Developer Guide. The following are examples of valid Prefix values:
        ///
        /// * JournalExports-ForMyLedger/Testing/
        ///
        /// * JournalExports
        ///
        /// * My:Tests/
        /// This member is required.
        public var `prefix`: Swift.String?

        public init(
            bucket: Swift.String? = nil,
            encryptionConfiguration: QLDBClientTypes.S3EncryptionConfiguration? = nil,
            `prefix`: Swift.String? = nil
        )
        {
            self.bucket = bucket
            self.encryptionConfiguration = encryptionConfiguration
            self.`prefix` = `prefix`
        }
    }

}

extension QLDBClientTypes {
    public enum S3ObjectEncryptionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case noEncryption
        case sseKms
        case sseS3
        case sdkUnknown(Swift.String)

        public static var allCases: [S3ObjectEncryptionType] {
            return [
                .noEncryption,
                .sseKms,
                .sseS3,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .noEncryption: return "NO_ENCRYPTION"
            case .sseKms: return "SSE_KMS"
            case .sseS3: return "SSE_S3"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = S3ObjectEncryptionType(rawValue: rawValue) ?? S3ObjectEncryptionType.sdkUnknown(rawValue)
        }
    }
}

extension StreamJournalToKinesisInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case exclusiveEndTime = "ExclusiveEndTime"
        case inclusiveStartTime = "InclusiveStartTime"
        case kinesisConfiguration = "KinesisConfiguration"
        case roleArn = "RoleArn"
        case streamName = "StreamName"
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let exclusiveEndTime = self.exclusiveEndTime {
            try encodeContainer.encodeTimestamp(exclusiveEndTime, format: .epochSeconds, forKey: .exclusiveEndTime)
        }
        if let inclusiveStartTime = self.inclusiveStartTime {
            try encodeContainer.encodeTimestamp(inclusiveStartTime, format: .epochSeconds, forKey: .inclusiveStartTime)
        }
        if let kinesisConfiguration = self.kinesisConfiguration {
            try encodeContainer.encode(kinesisConfiguration, forKey: .kinesisConfiguration)
        }
        if let roleArn = self.roleArn {
            try encodeContainer.encode(roleArn, forKey: .roleArn)
        }
        if let streamName = self.streamName {
            try encodeContainer.encode(streamName, forKey: .streamName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                guard let tags0 = tags0 else {
                    try tagsContainer.encodeNil(forKey: ClientRuntime.Key(stringValue: dictKey0))
                    continue
                }
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension StreamJournalToKinesisInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let ledgerName = ledgerName else {
            return nil
        }
        return "/ledgers/\(ledgerName.urlPercentEncoding())/journal-kinesis-streams"
    }
}

public struct StreamJournalToKinesisInput: Swift.Equatable {
    /// The exclusive date and time that specifies when the stream ends. If you don't define this parameter, the stream runs indefinitely until you cancel it. The ExclusiveEndTime must be in ISO 8601 date and time format and in Universal Coordinated Time (UTC). For example: 2019-06-13T21:36:34Z.
    public var exclusiveEndTime: ClientRuntime.Date?
    /// The inclusive start date and time from which to start streaming journal data. This parameter must be in ISO 8601 date and time format and in Universal Coordinated Time (UTC). For example: 2019-06-13T21:36:34Z. The InclusiveStartTime cannot be in the future and must be before ExclusiveEndTime. If you provide an InclusiveStartTime that is before the ledger's CreationDateTime, QLDB effectively defaults it to the ledger's CreationDateTime.
    /// This member is required.
    public var inclusiveStartTime: ClientRuntime.Date?
    /// The configuration settings of the Kinesis Data Streams destination for your stream request.
    /// This member is required.
    public var kinesisConfiguration: QLDBClientTypes.KinesisConfiguration?
    /// The name of the ledger.
    /// This member is required.
    public var ledgerName: Swift.String?
    /// The Amazon Resource Name (ARN) of the IAM role that grants QLDB permissions for a journal stream to write data records to a Kinesis Data Streams resource. To pass a role to QLDB when requesting a journal stream, you must have permissions to perform the iam:PassRole action on the IAM role resource. This is required for all journal stream requests.
    /// This member is required.
    public var roleArn: Swift.String?
    /// The name that you want to assign to the QLDB journal stream. User-defined names can help identify and indicate the purpose of a stream. Your stream name must be unique among other active streams for a given ledger. Stream names have the same naming constraints as ledger names, as defined in [Quotas in Amazon QLDB](https://docs.aws.amazon.com/qldb/latest/developerguide/limits.html#limits.naming) in the Amazon QLDB Developer Guide.
    /// This member is required.
    public var streamName: Swift.String?
    /// The key-value pairs to add as tags to the stream that you want to create. Tag keys are case sensitive. Tag values are case sensitive and can be null.
    public var tags: [Swift.String:Swift.String?]?

    public init(
        exclusiveEndTime: ClientRuntime.Date? = nil,
        inclusiveStartTime: ClientRuntime.Date? = nil,
        kinesisConfiguration: QLDBClientTypes.KinesisConfiguration? = nil,
        ledgerName: Swift.String? = nil,
        roleArn: Swift.String? = nil,
        streamName: Swift.String? = nil,
        tags: [Swift.String:Swift.String?]? = nil
    )
    {
        self.exclusiveEndTime = exclusiveEndTime
        self.inclusiveStartTime = inclusiveStartTime
        self.kinesisConfiguration = kinesisConfiguration
        self.ledgerName = ledgerName
        self.roleArn = roleArn
        self.streamName = streamName
        self.tags = tags
    }
}

struct StreamJournalToKinesisInputBody: Swift.Equatable {
    let roleArn: Swift.String?
    let tags: [Swift.String:Swift.String?]?
    let inclusiveStartTime: ClientRuntime.Date?
    let exclusiveEndTime: ClientRuntime.Date?
    let kinesisConfiguration: QLDBClientTypes.KinesisConfiguration?
    let streamName: Swift.String?
}

extension StreamJournalToKinesisInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case exclusiveEndTime = "ExclusiveEndTime"
        case inclusiveStartTime = "InclusiveStartTime"
        case kinesisConfiguration = "KinesisConfiguration"
        case roleArn = "RoleArn"
        case streamName = "StreamName"
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let roleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .roleArn)
        roleArn = roleArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String?]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String?]()
            for (key0, tagvalue0) in tagsContainer {
                tagsDecoded0?[key0] = tagvalue0
            }
        }
        tags = tagsDecoded0
        let inclusiveStartTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .inclusiveStartTime)
        inclusiveStartTime = inclusiveStartTimeDecoded
        let exclusiveEndTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .exclusiveEndTime)
        exclusiveEndTime = exclusiveEndTimeDecoded
        let kinesisConfigurationDecoded = try containerValues.decodeIfPresent(QLDBClientTypes.KinesisConfiguration.self, forKey: .kinesisConfiguration)
        kinesisConfiguration = kinesisConfigurationDecoded
        let streamNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamName)
        streamName = streamNameDecoded
    }
}

extension StreamJournalToKinesisOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StreamJournalToKinesisOutputBody = try responseDecoder.decode(responseBody: data)
            self.streamId = output.streamId
        } else {
            self.streamId = nil
        }
    }
}

public struct StreamJournalToKinesisOutput: Swift.Equatable {
    /// The UUID (represented in Base62-encoded text) that QLDB assigns to each QLDB journal stream.
    public var streamId: Swift.String?

    public init(
        streamId: Swift.String? = nil
    )
    {
        self.streamId = streamId
    }
}

struct StreamJournalToKinesisOutputBody: Swift.Equatable {
    let streamId: Swift.String?
}

extension StreamJournalToKinesisOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case streamId = "StreamId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let streamIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .streamId)
        streamId = streamIdDecoded
    }
}

enum StreamJournalToKinesisOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourcePreconditionNotMetException": return try await ResourcePreconditionNotMetException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension QLDBClientTypes {
    public enum StreamStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case canceled
        case completed
        case failed
        case impaired
        case sdkUnknown(Swift.String)

        public static var allCases: [StreamStatus] {
            return [
                .active,
                .canceled,
                .completed,
                .failed,
                .impaired,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .canceled: return "CANCELED"
            case .completed: return "COMPLETED"
            case .failed: return "FAILED"
            case .impaired: return "IMPAIRED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = StreamStatus(rawValue: rawValue) ?? StreamStatus.sdkUnknown(rawValue)
        }
    }
}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                guard let tags0 = tags0 else {
                    try tagsContainer.encodeNil(forKey: ClientRuntime.Key(stringValue: dictKey0))
                    continue
                }
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) to which you want to add the tags. For example: arn:aws:qldb:us-east-1:123456789012:ledger/exampleLedger
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The key-value pairs to add as tags to the specified QLDB resource. Tag keys are case sensitive. If you specify a key that already exists for the resource, your request fails and returns an error. Tag values are case sensitive and can be null.
    /// This member is required.
    public var tags: [Swift.String:Swift.String?]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String?]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String?]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "Tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String?]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String?]()
            for (key0, tagvalue0) in tagsContainer {
                tagsDecoded0?[key0] = tagvalue0
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct TagResourceOutput: Swift.Equatable {

    public init() { }
}

enum TagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UntagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let tagKeys = tagKeys else {
                let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
            return items
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) from which to remove the tags. For example: arn:aws:qldb:us-east-1:123456789012:ledger/exampleLedger
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The list of tag keys to remove.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UntagResourceOutput: Swift.Equatable {

    public init() { }
}

enum UntagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateLedgerInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deletionProtection = "DeletionProtection"
        case kmsKey = "KmsKey"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deletionProtection = self.deletionProtection {
            try encodeContainer.encode(deletionProtection, forKey: .deletionProtection)
        }
        if let kmsKey = self.kmsKey {
            try encodeContainer.encode(kmsKey, forKey: .kmsKey)
        }
    }
}

extension UpdateLedgerInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let name = name else {
            return nil
        }
        return "/ledgers/\(name.urlPercentEncoding())"
    }
}

public struct UpdateLedgerInput: Swift.Equatable {
    /// Specifies whether the ledger is protected from being deleted by any user. If not defined during ledger creation, this feature is enabled (true) by default. If deletion protection is enabled, you must first disable it before you can delete the ledger. You can disable it by calling the UpdateLedger operation to set this parameter to false.
    public var deletionProtection: Swift.Bool?
    /// The key in Key Management Service (KMS) to use for encryption of data at rest in the ledger. For more information, see [Encryption at rest](https://docs.aws.amazon.com/qldb/latest/developerguide/encryption-at-rest.html) in the Amazon QLDB Developer Guide. Use one of the following options to specify this parameter:
    ///
    /// * AWS_OWNED_KMS_KEY: Use an KMS key that is owned and managed by Amazon Web Services on your behalf.
    ///
    /// * Undefined: Make no changes to the KMS key of the ledger.
    ///
    /// * A valid symmetric customer managed KMS key: Use the specified symmetric encryption KMS key in your account that you create, own, and manage. Amazon QLDB does not support asymmetric keys. For more information, see [Using symmetric and asymmetric keys](https://docs.aws.amazon.com/kms/latest/developerguide/symmetric-asymmetric.html) in the Key Management Service Developer Guide.
    ///
    ///
    /// To specify a customer managed KMS key, you can use its key ID, Amazon Resource Name (ARN), alias name, or alias ARN. When using an alias name, prefix it with "alias/". To specify a key in a different Amazon Web Services account, you must use the key ARN or alias ARN. For example:
    ///
    /// * Key ID: 1234abcd-12ab-34cd-56ef-1234567890ab
    ///
    /// * Key ARN: arn:aws:kms:us-east-2:111122223333:key/1234abcd-12ab-34cd-56ef-1234567890ab
    ///
    /// * Alias name: alias/ExampleAlias
    ///
    /// * Alias ARN: arn:aws:kms:us-east-2:111122223333:alias/ExampleAlias
    ///
    ///
    /// For more information, see [Key identifiers (KeyId)](https://docs.aws.amazon.com/kms/latest/developerguide/concepts.html#key-id) in the Key Management Service Developer Guide.
    public var kmsKey: Swift.String?
    /// The name of the ledger.
    /// This member is required.
    public var name: Swift.String?

    public init(
        deletionProtection: Swift.Bool? = nil,
        kmsKey: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.deletionProtection = deletionProtection
        self.kmsKey = kmsKey
        self.name = name
    }
}

struct UpdateLedgerInputBody: Swift.Equatable {
    let deletionProtection: Swift.Bool?
    let kmsKey: Swift.String?
}

extension UpdateLedgerInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deletionProtection = "DeletionProtection"
        case kmsKey = "KmsKey"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deletionProtectionDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .deletionProtection)
        deletionProtection = deletionProtectionDecoded
        let kmsKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKey)
        kmsKey = kmsKeyDecoded
    }
}

extension UpdateLedgerOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateLedgerOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.creationDateTime = output.creationDateTime
            self.deletionProtection = output.deletionProtection
            self.encryptionDescription = output.encryptionDescription
            self.name = output.name
            self.state = output.state
        } else {
            self.arn = nil
            self.creationDateTime = nil
            self.deletionProtection = nil
            self.encryptionDescription = nil
            self.name = nil
            self.state = nil
        }
    }
}

public struct UpdateLedgerOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) for the ledger.
    public var arn: Swift.String?
    /// The date and time, in epoch time format, when the ledger was created. (Epoch time format is the number of seconds elapsed since 12:00:00 AM January 1, 1970 UTC.)
    public var creationDateTime: ClientRuntime.Date?
    /// Specifies whether the ledger is protected from being deleted by any user. If not defined during ledger creation, this feature is enabled (true) by default. If deletion protection is enabled, you must first disable it before you can delete the ledger. You can disable it by calling the UpdateLedger operation to set this parameter to false.
    public var deletionProtection: Swift.Bool?
    /// Information about the encryption of data at rest in the ledger. This includes the current status, the KMS key, and when the key became inaccessible (in the case of an error).
    public var encryptionDescription: QLDBClientTypes.LedgerEncryptionDescription?
    /// The name of the ledger.
    public var name: Swift.String?
    /// The current status of the ledger.
    public var state: QLDBClientTypes.LedgerState?

    public init(
        arn: Swift.String? = nil,
        creationDateTime: ClientRuntime.Date? = nil,
        deletionProtection: Swift.Bool? = nil,
        encryptionDescription: QLDBClientTypes.LedgerEncryptionDescription? = nil,
        name: Swift.String? = nil,
        state: QLDBClientTypes.LedgerState? = nil
    )
    {
        self.arn = arn
        self.creationDateTime = creationDateTime
        self.deletionProtection = deletionProtection
        self.encryptionDescription = encryptionDescription
        self.name = name
        self.state = state
    }
}

struct UpdateLedgerOutputBody: Swift.Equatable {
    let name: Swift.String?
    let arn: Swift.String?
    let state: QLDBClientTypes.LedgerState?
    let creationDateTime: ClientRuntime.Date?
    let deletionProtection: Swift.Bool?
    let encryptionDescription: QLDBClientTypes.LedgerEncryptionDescription?
}

extension UpdateLedgerOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case creationDateTime = "CreationDateTime"
        case deletionProtection = "DeletionProtection"
        case encryptionDescription = "EncryptionDescription"
        case name = "Name"
        case state = "State"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let stateDecoded = try containerValues.decodeIfPresent(QLDBClientTypes.LedgerState.self, forKey: .state)
        state = stateDecoded
        let creationDateTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .creationDateTime)
        creationDateTime = creationDateTimeDecoded
        let deletionProtectionDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .deletionProtection)
        deletionProtection = deletionProtectionDecoded
        let encryptionDescriptionDecoded = try containerValues.decodeIfPresent(QLDBClientTypes.LedgerEncryptionDescription.self, forKey: .encryptionDescription)
        encryptionDescription = encryptionDescriptionDecoded
    }
}

enum UpdateLedgerOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateLedgerPermissionsModeInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case permissionsMode = "PermissionsMode"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let permissionsMode = self.permissionsMode {
            try encodeContainer.encode(permissionsMode.rawValue, forKey: .permissionsMode)
        }
    }
}

extension UpdateLedgerPermissionsModeInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let name = name else {
            return nil
        }
        return "/ledgers/\(name.urlPercentEncoding())/permissions-mode"
    }
}

public struct UpdateLedgerPermissionsModeInput: Swift.Equatable {
    /// The name of the ledger.
    /// This member is required.
    public var name: Swift.String?
    /// The permissions mode to assign to the ledger. This parameter can have one of the following values:
    ///
    /// * ALLOW_ALL: A legacy permissions mode that enables access control with API-level granularity for ledgers. This mode allows users who have the SendCommand API permission for this ledger to run all PartiQL commands (hence, ALLOW_ALL) on any tables in the specified ledger. This mode disregards any table-level or command-level IAM permissions policies that you create for the ledger.
    ///
    /// * STANDARD: (Recommended) A permissions mode that enables access control with finer granularity for ledgers, tables, and PartiQL commands. By default, this mode denies all user requests to run any PartiQL commands on any tables in this ledger. To allow PartiQL commands to run, you must create IAM permissions policies for specific table resources and PartiQL actions, in addition to the SendCommand API permission for the ledger. For information, see [Getting started with the standard permissions mode](https://docs.aws.amazon.com/qldb/latest/developerguide/getting-started-standard-mode.html) in the Amazon QLDB Developer Guide.
    ///
    ///
    /// We strongly recommend using the STANDARD permissions mode to maximize the security of your ledger data.
    /// This member is required.
    public var permissionsMode: QLDBClientTypes.PermissionsMode?

    public init(
        name: Swift.String? = nil,
        permissionsMode: QLDBClientTypes.PermissionsMode? = nil
    )
    {
        self.name = name
        self.permissionsMode = permissionsMode
    }
}

struct UpdateLedgerPermissionsModeInputBody: Swift.Equatable {
    let permissionsMode: QLDBClientTypes.PermissionsMode?
}

extension UpdateLedgerPermissionsModeInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case permissionsMode = "PermissionsMode"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let permissionsModeDecoded = try containerValues.decodeIfPresent(QLDBClientTypes.PermissionsMode.self, forKey: .permissionsMode)
        permissionsMode = permissionsModeDecoded
    }
}

extension UpdateLedgerPermissionsModeOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateLedgerPermissionsModeOutputBody = try responseDecoder.decode(responseBody: data)
            self.arn = output.arn
            self.name = output.name
            self.permissionsMode = output.permissionsMode
        } else {
            self.arn = nil
            self.name = nil
            self.permissionsMode = nil
        }
    }
}

public struct UpdateLedgerPermissionsModeOutput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) for the ledger.
    public var arn: Swift.String?
    /// The name of the ledger.
    public var name: Swift.String?
    /// The current permissions mode of the ledger.
    public var permissionsMode: QLDBClientTypes.PermissionsMode?

    public init(
        arn: Swift.String? = nil,
        name: Swift.String? = nil,
        permissionsMode: QLDBClientTypes.PermissionsMode? = nil
    )
    {
        self.arn = arn
        self.name = name
        self.permissionsMode = permissionsMode
    }
}

struct UpdateLedgerPermissionsModeOutputBody: Swift.Equatable {
    let name: Swift.String?
    let arn: Swift.String?
    let permissionsMode: QLDBClientTypes.PermissionsMode?
}

extension UpdateLedgerPermissionsModeOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case name = "Name"
        case permissionsMode = "PermissionsMode"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let permissionsModeDecoded = try containerValues.decodeIfPresent(QLDBClientTypes.PermissionsMode.self, forKey: .permissionsMode)
        permissionsMode = permissionsModeDecoded
    }
}

enum UpdateLedgerPermissionsModeOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension QLDBClientTypes.ValueHolder: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ionText = "IonText"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ionText = self.ionText {
            try encodeContainer.encode(ionText, forKey: .ionText)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ionTextDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ionText)
        ionText = ionTextDecoded
    }
}

extension QLDBClientTypes.ValueHolder: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension QLDBClientTypes {
    /// A structure that can contain a value in multiple encoding formats.
    public struct ValueHolder: Swift.Equatable {
        /// An Amazon Ion plaintext value contained in a ValueHolder structure.
        public var ionText: Swift.String?

        public init(
            ionText: Swift.String? = nil
        )
        {
            self.ionText = ionText
        }
    }

}
