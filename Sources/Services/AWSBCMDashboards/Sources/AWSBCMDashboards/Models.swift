//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class ClientRuntime.Indirect
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.AWSJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
@_spi(SmithyReadWrite) import struct SmithyReadWrite.ReadingClosureBox
@_spi(SmithyReadWrite) import struct SmithyReadWrite.WritingClosureBox
@_spi(SmithyTimestamps) import struct SmithyTimestamps.TimestampFormatter

/// You do not have sufficient permissions to perform this action. Verify your IAM permissions and any resource policies.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

/// An internal error occurred while processing the request. Retry your request. If the problem persists, contact Amazon Web Services Support.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

/// The request would exceed service quotas. For example, attempting to create more than 20 widgets in a dashboard or exceeding the maximum number of dashboards per account.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

/// The request was denied due to request throttling. Reduce the frequency of requests and use exponential backoff.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

/// The input parameters do not satisfy the requirements. Check the error message for specific validation details.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

extension BCMDashboardsClientTypes {

    /// A key-value pair that can be attached to a dashboard for organization and management purposes.
    public struct ResourceTag: Swift.Sendable {
        /// The key of the tag to be attached to the dashboard resource.
        /// This member is required.
        public var key: Swift.String?
        /// The value of the tag to be attached to the dashboard resource.
        /// This member is required.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        ) {
            self.key = key
            self.value = value
        }
    }
}

extension BCMDashboardsClientTypes {

    public enum VisualType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case bar
        case line
        case stack
        case sdkUnknown(Swift.String)

        public static var allCases: [VisualType] {
            return [
                .bar,
                .line,
                .stack
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .bar: return "BAR"
            case .line: return "LINE"
            case .stack: return "STACK"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BCMDashboardsClientTypes {

    /// Defines the visual representation settings for widget data, including the visualization type, styling options, and display preferences for different metric types.
    public struct GraphDisplayConfig: Swift.Sendable {
        /// The type of visualization to use for the data.
        /// This member is required.
        public var visualType: BCMDashboardsClientTypes.VisualType?

        public init(
            visualType: BCMDashboardsClientTypes.VisualType? = nil
        ) {
            self.visualType = visualType
        }
    }
}

extension BCMDashboardsClientTypes {

    /// Configuration structure for customizing the tabular display of widget data.
    public struct TableDisplayConfigStruct: Swift.Sendable {

        public init() { }
    }
}

extension BCMDashboardsClientTypes {

    /// Defines how the widget's data should be visualized, including chart type, color schemes, axis configurations, and other display preferences.
    public enum DisplayConfig: Swift.Sendable {
        /// The configuration for graphical display of the widget data, including chart type and visual options.
        case graph([Swift.String: BCMDashboardsClientTypes.GraphDisplayConfig])
        /// The configuration for tabular display of the widget data.
        case table(BCMDashboardsClientTypes.TableDisplayConfigStruct)
        case sdkUnknown(Swift.String)
    }
}

extension BCMDashboardsClientTypes {

    public enum MatchOption: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case absent
        case caseInsensitive
        case caseSensitive
        case contains
        case endsWith
        case equals
        case greaterThanOrEqual
        case startsWith
        case sdkUnknown(Swift.String)

        public static var allCases: [MatchOption] {
            return [
                .absent,
                .caseInsensitive,
                .caseSensitive,
                .contains,
                .endsWith,
                .equals,
                .greaterThanOrEqual,
                .startsWith
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .absent: return "ABSENT"
            case .caseInsensitive: return "CASE_INSENSITIVE"
            case .caseSensitive: return "CASE_SENSITIVE"
            case .contains: return "CONTAINS"
            case .endsWith: return "ENDS_WITH"
            case .equals: return "EQUALS"
            case .greaterThanOrEqual: return "GREATER_THAN_OR_EQUAL"
            case .startsWith: return "STARTS_WITH"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BCMDashboardsClientTypes {

    /// Specifies the values and match options for cost category-based filtering in cost and usage queries.
    public struct CostCategoryValues: Swift.Sendable {
        /// The key of the cost category to filter on.
        public var key: Swift.String?
        /// The match options for cost category values, such as EQUALS, CONTAINS, STARTS_WITH, or ENDS_WITH.
        public var matchOptions: [BCMDashboardsClientTypes.MatchOption]?
        /// The values to match for the specified cost category key.
        public var values: [Swift.String]?

        public init(
            key: Swift.String? = nil,
            matchOptions: [BCMDashboardsClientTypes.MatchOption]? = nil,
            values: [Swift.String]? = nil
        ) {
            self.key = key
            self.matchOptions = matchOptions
            self.values = values
        }
    }
}

extension BCMDashboardsClientTypes {

    public enum Dimension: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case az
        case billingEntity
        case cacheEngine
        case costCategoryName
        case databaseEngine
        case deploymentOption
        case instanceType
        case instanceTypeFamily
        case legalEntityName
        case linkedAccount
        case operatingSystem
        case operation
        case platform
        case purchaseType
        case recordType
        case region
        case reservationId
        case resourceId
        case savingsPlansType
        case scope
        case service
        case subscriptionId
        case tagKey
        case tenancy
        case usageType
        case usageTypeGroup
        case sdkUnknown(Swift.String)

        public static var allCases: [Dimension] {
            return [
                .az,
                .billingEntity,
                .cacheEngine,
                .costCategoryName,
                .databaseEngine,
                .deploymentOption,
                .instanceType,
                .instanceTypeFamily,
                .legalEntityName,
                .linkedAccount,
                .operatingSystem,
                .operation,
                .platform,
                .purchaseType,
                .recordType,
                .region,
                .reservationId,
                .resourceId,
                .savingsPlansType,
                .scope,
                .service,
                .subscriptionId,
                .tagKey,
                .tenancy,
                .usageType,
                .usageTypeGroup
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .az: return "AZ"
            case .billingEntity: return "BILLING_ENTITY"
            case .cacheEngine: return "CACHE_ENGINE"
            case .costCategoryName: return "COST_CATEGORY_NAME"
            case .databaseEngine: return "DATABASE_ENGINE"
            case .deploymentOption: return "DEPLOYMENT_OPTION"
            case .instanceType: return "INSTANCE_TYPE"
            case .instanceTypeFamily: return "INSTANCE_TYPE_FAMILY"
            case .legalEntityName: return "LEGAL_ENTITY_NAME"
            case .linkedAccount: return "LINKED_ACCOUNT"
            case .operatingSystem: return "OPERATING_SYSTEM"
            case .operation: return "OPERATION"
            case .platform: return "PLATFORM"
            case .purchaseType: return "PURCHASE_TYPE"
            case .recordType: return "RECORD_TYPE"
            case .region: return "REGION"
            case .reservationId: return "RESERVATION_ID"
            case .resourceId: return "RESOURCE_ID"
            case .savingsPlansType: return "SAVINGS_PLANS_TYPE"
            case .scope: return "SCOPE"
            case .service: return "SERVICE"
            case .subscriptionId: return "SUBSCRIPTION_ID"
            case .tagKey: return "TAG_KEY"
            case .tenancy: return "TENANCY"
            case .usageType: return "USAGE_TYPE"
            case .usageTypeGroup: return "USAGE_TYPE_GROUP"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BCMDashboardsClientTypes {

    /// Specifies the values and match options for dimension-based filtering in cost and usage queries.
    public struct DimensionValues: Swift.Sendable {
        /// The key of the dimension to filter on (for example, SERVICE, USAGE_TYPE, or OPERATION).
        /// This member is required.
        public var key: BCMDashboardsClientTypes.Dimension?
        /// The match options for dimension values, such as EQUALS, CONTAINS, STARTS_WITH, or ENDS_WITH.
        public var matchOptions: [BCMDashboardsClientTypes.MatchOption]?
        /// The values to match for the specified dimension key.
        /// This member is required.
        public var values: [Swift.String]?

        public init(
            key: BCMDashboardsClientTypes.Dimension? = nil,
            matchOptions: [BCMDashboardsClientTypes.MatchOption]? = nil,
            values: [Swift.String]? = nil
        ) {
            self.key = key
            self.matchOptions = matchOptions
            self.values = values
        }
    }
}

extension BCMDashboardsClientTypes {

    /// Specifies tag-based filtering options for cost and usage queries.
    public struct TagValues: Swift.Sendable {
        /// The key of the tag to filter on.
        public var key: Swift.String?
        /// The match options for tag values, such as EQUALS, CONTAINS, STARTS_WITH, or ENDS_WITH.
        public var matchOptions: [BCMDashboardsClientTypes.MatchOption]?
        /// The values to match for the specified tag key.
        public var values: [Swift.String]?

        public init(
            key: Swift.String? = nil,
            matchOptions: [BCMDashboardsClientTypes.MatchOption]? = nil,
            values: [Swift.String]? = nil
        ) {
            self.key = key
            self.matchOptions = matchOptions
            self.values = values
        }
    }
}

extension BCMDashboardsClientTypes {

    public enum Granularity: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case daily
        case hourly
        case monthly
        case sdkUnknown(Swift.String)

        public static var allCases: [Granularity] {
            return [
                .daily,
                .hourly,
                .monthly
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .daily: return "DAILY"
            case .hourly: return "HOURLY"
            case .monthly: return "MONTHLY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BCMDashboardsClientTypes {

    public enum GroupDefinitionType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case costCategory
        case dimension
        case tag
        case sdkUnknown(Swift.String)

        public static var allCases: [GroupDefinitionType] {
            return [
                .costCategory,
                .dimension,
                .tag
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .costCategory: return "COST_CATEGORY"
            case .dimension: return "DIMENSION"
            case .tag: return "TAG"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BCMDashboardsClientTypes {

    /// Specifies how to group cost and usage data.
    public struct GroupDefinition: Swift.Sendable {
        /// The key to use for grouping cost and usage data.
        /// This member is required.
        public var key: Swift.String?
        /// The type of grouping to apply.
        public var type: BCMDashboardsClientTypes.GroupDefinitionType?

        public init(
            key: Swift.String? = nil,
            type: BCMDashboardsClientTypes.GroupDefinitionType? = .dimension
        ) {
            self.key = key
            self.type = type
        }
    }
}

extension BCMDashboardsClientTypes {

    public enum MetricName: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case amortizedcost
        case blendedcost
        case cost
        case hour
        case netamortizedcost
        case netunblendedcost
        case normalizedusageamount
        case spendcoveredbysavingsplans
        case unblendedcost
        case unit
        case usagequantity
        case sdkUnknown(Swift.String)

        public static var allCases: [MetricName] {
            return [
                .amortizedcost,
                .blendedcost,
                .cost,
                .hour,
                .netamortizedcost,
                .netunblendedcost,
                .normalizedusageamount,
                .spendcoveredbysavingsplans,
                .unblendedcost,
                .unit,
                .usagequantity
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .amortizedcost: return "AmortizedCost"
            case .blendedcost: return "BlendedCost"
            case .cost: return "Cost"
            case .hour: return "Hour"
            case .netamortizedcost: return "NetAmortizedCost"
            case .netunblendedcost: return "NetUnblendedCost"
            case .normalizedusageamount: return "NormalizedUsageAmount"
            case .spendcoveredbysavingsplans: return "SpendCoveredBySavingsPlans"
            case .unblendedcost: return "UnblendedCost"
            case .unit: return "Unit"
            case .usagequantity: return "UsageQuantity"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BCMDashboardsClientTypes {

    public enum DateTimeType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case absolute
        case relative
        case sdkUnknown(Swift.String)

        public static var allCases: [DateTimeType] {
            return [
                .absolute,
                .relative
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .absolute: return "ABSOLUTE"
            case .relative: return "RELATIVE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BCMDashboardsClientTypes {

    /// Represents a point in time that can be specified as either an absolute date (for example, "2025-07-01") or a relative time period using ISO 8601 duration format (for example, "-P3M" for three months ago).
    public struct DateTimeValue: Swift.Sendable {
        /// The type of date/time value: ABSOLUTE for specific dates or RELATIVE for dynamic time periods.
        /// This member is required.
        public var type: BCMDashboardsClientTypes.DateTimeType?
        /// The actual date/time value.
        /// This member is required.
        public var value: Swift.String?

        public init(
            type: BCMDashboardsClientTypes.DateTimeType? = nil,
            value: Swift.String? = nil
        ) {
            self.type = type
            self.value = value
        }
    }
}

extension BCMDashboardsClientTypes {

    /// Defines a time period with explicit start and end times for data queries.
    public struct DateTimeRange: Swift.Sendable {
        /// The end time of the date range for querying data.
        /// This member is required.
        public var endTime: BCMDashboardsClientTypes.DateTimeValue?
        /// The start time of the date range for querying data.
        /// This member is required.
        public var startTime: BCMDashboardsClientTypes.DateTimeValue?

        public init(
            endTime: BCMDashboardsClientTypes.DateTimeValue? = nil,
            startTime: BCMDashboardsClientTypes.DateTimeValue? = nil
        ) {
            self.endTime = endTime
            self.startTime = startTime
        }
    }
}

public struct CreateDashboardOutput: Swift.Sendable {
    /// The ARN of the newly created dashboard.
    /// This member is required.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    ) {
        self.arn = arn
    }
}

public struct DeleteDashboardInput: Swift.Sendable {
    /// The ARN of the dashboard to be deleted.
    /// This member is required.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    ) {
        self.arn = arn
    }
}

public struct DeleteDashboardOutput: Swift.Sendable {
    /// The ARN of the dashboard that was deleted.
    /// This member is required.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    ) {
        self.arn = arn
    }
}

/// The specified resource (dashboard, policy, or widget) was not found. Verify the ARN and try again.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

public struct GetDashboardInput: Swift.Sendable {
    /// The ARN of the dashboard to retrieve. This is required to uniquely identify the dashboard.
    /// This member is required.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    ) {
        self.arn = arn
    }
}

extension BCMDashboardsClientTypes {

    public enum DashboardType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case custom
        case sdkUnknown(Swift.String)

        public static var allCases: [DashboardType] {
            return [
                .custom
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .custom: return "CUSTOM"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetResourcePolicyInput: Swift.Sendable {
    /// The ARN of the dashboard whose resource-based policy you want to retrieve.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    ) {
        self.resourceArn = resourceArn
    }
}

public struct GetResourcePolicyOutput: Swift.Sendable {
    /// The JSON policy document that represents the dashboard's resource-based policy.
    /// This member is required.
    public var policyDocument: Swift.String?
    /// The ARN of the dashboard for which the resource-based policy was retrieved.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        policyDocument: Swift.String? = nil,
        resourceArn: Swift.String? = nil
    ) {
        self.policyDocument = policyDocument
        self.resourceArn = resourceArn
    }
}

public struct ListDashboardsInput: Swift.Sendable {
    /// The maximum number of results to return in a single call. The default value is 20.
    public var maxResults: Swift.Int?
    /// The token for the next page of results. Use the value returned in the previous response.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension BCMDashboardsClientTypes {

    /// Contains basic information about a dashboard, including its ARN, name, type, and timestamps.
    public struct DashboardReference: Swift.Sendable {
        /// The ARN of the referenced dashboard.
        /// This member is required.
        public var arn: Swift.String?
        /// The timestamp when the dashboard was created.
        /// This member is required.
        public var createdAt: Foundation.Date?
        /// The description of the referenced dashboard.
        public var description: Swift.String?
        /// The name of the referenced dashboard.
        /// This member is required.
        public var name: Swift.String?
        /// The dashboard type.
        /// This member is required.
        public var type: BCMDashboardsClientTypes.DashboardType?
        /// The timestamp when the dashboard was last modified.
        /// This member is required.
        public var updatedAt: Foundation.Date?

        public init(
            arn: Swift.String? = nil,
            createdAt: Foundation.Date? = nil,
            description: Swift.String? = nil,
            name: Swift.String? = nil,
            type: BCMDashboardsClientTypes.DashboardType? = nil,
            updatedAt: Foundation.Date? = nil
        ) {
            self.arn = arn
            self.createdAt = createdAt
            self.description = description
            self.name = name
            self.type = type
            self.updatedAt = updatedAt
        }
    }
}

public struct ListDashboardsOutput: Swift.Sendable {
    /// An array of dashboard references, containing basic information about each dashboard.
    /// This member is required.
    public var dashboards: [BCMDashboardsClientTypes.DashboardReference]?
    /// The token to use to retrieve the next page of results. Not returned if there are no more results to retrieve.
    public var nextToken: Swift.String?

    public init(
        dashboards: [BCMDashboardsClientTypes.DashboardReference]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.dashboards = dashboards
        self.nextToken = nextToken
    }
}

public struct ListTagsForResourceInput: Swift.Sendable {
    /// The unique identifier for the resource.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    ) {
        self.resourceArn = resourceArn
    }
}

public struct ListTagsForResourceOutput: Swift.Sendable {
    /// The list of tags associated with the specified dashboard resource.
    public var resourceTags: [BCMDashboardsClientTypes.ResourceTag]?

    public init(
        resourceTags: [BCMDashboardsClientTypes.ResourceTag]? = nil
    ) {
        self.resourceTags = resourceTags
    }
}

public struct TagResourceInput: Swift.Sendable {
    /// The unique identifier for the resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tags to add to the dashboard resource.
    /// This member is required.
    public var resourceTags: [BCMDashboardsClientTypes.ResourceTag]?

    public init(
        resourceArn: Swift.String? = nil,
        resourceTags: [BCMDashboardsClientTypes.ResourceTag]? = nil
    ) {
        self.resourceArn = resourceArn
        self.resourceTags = resourceTags
    }
}

public struct TagResourceOutput: Swift.Sendable {

    public init() { }
}

public struct UntagResourceInput: Swift.Sendable {
    /// The unique identifier for the resource.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The keys of the tags to remove from the dashboard resource.
    /// This member is required.
    public var resourceTagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        resourceTagKeys: [Swift.String]? = nil
    ) {
        self.resourceArn = resourceArn
        self.resourceTagKeys = resourceTagKeys
    }
}

public struct UntagResourceOutput: Swift.Sendable {

    public init() { }
}

public struct UpdateDashboardOutput: Swift.Sendable {
    /// The ARN of the updated dashboard.
    /// This member is required.
    public var arn: Swift.String?

    public init(
        arn: Swift.String? = nil
    ) {
        self.arn = arn
    }
}

extension BCMDashboardsClientTypes {

    /// Defines complex filtering conditions using logical operators (AND, OR, NOT) and various filter types.
    public struct Expression: Swift.Sendable {
        /// A list of expressions to combine with AND logic.
        public var and: [BCMDashboardsClientTypes.Expression]?
        /// The cost category values to include in the filter expression.
        public var costCategories: BCMDashboardsClientTypes.CostCategoryValues?
        /// The dimension values to include in the filter expression.
        public var dimensions: BCMDashboardsClientTypes.DimensionValues?
        /// An expression to negate with NOT logic.
        @Indirect public var not: BCMDashboardsClientTypes.Expression?
        /// A list of expressions to combine with OR logic.
        public var or: [BCMDashboardsClientTypes.Expression]?
        /// The tag values to include in the filter expression.
        public var tags: BCMDashboardsClientTypes.TagValues?

        public init(
            and: [BCMDashboardsClientTypes.Expression]? = nil,
            costCategories: BCMDashboardsClientTypes.CostCategoryValues? = nil,
            dimensions: BCMDashboardsClientTypes.DimensionValues? = nil,
            not: BCMDashboardsClientTypes.Expression? = nil,
            or: [BCMDashboardsClientTypes.Expression]? = nil,
            tags: BCMDashboardsClientTypes.TagValues? = nil
        ) {
            self.and = and
            self.costCategories = costCategories
            self.dimensions = dimensions
            self.not = not
            self.or = or
            self.tags = tags
        }
    }
}

extension BCMDashboardsClientTypes {

    /// Defines the parameters for retrieving Amazon Web Services cost and usage data. Includes specifications for metrics, time periods, granularity, grouping dimensions, and filtering conditions.
    public struct CostAndUsageQuery: Swift.Sendable {
        /// The filter expression to be applied to the cost and usage data.
        public var filter: BCMDashboardsClientTypes.Expression?
        /// The granularity of the retrieved data: HOURLY, DAILY, or MONTHLY.
        /// This member is required.
        public var granularity: BCMDashboardsClientTypes.Granularity?
        /// Specifies how to group the retrieved data, such as by SERVICE, ACCOUNT, or TAG.
        public var groupBy: [BCMDashboardsClientTypes.GroupDefinition]?
        /// The specific cost and usage metrics to retrieve. Valid values for CostAndUsageQuery metrics are AmortizedCost, BlendedCost, NetAmortizedCost, NetUnblendedCost, NormalizedUsageAmount, UnblendedCost, and UsageQuantity.
        /// This member is required.
        public var metrics: [BCMDashboardsClientTypes.MetricName]?
        /// The time period for which to retrieve data. Can be specified as absolute dates or relative time periods.
        /// This member is required.
        public var timeRange: BCMDashboardsClientTypes.DateTimeRange?

        public init(
            filter: BCMDashboardsClientTypes.Expression? = nil,
            granularity: BCMDashboardsClientTypes.Granularity? = nil,
            groupBy: [BCMDashboardsClientTypes.GroupDefinition]? = nil,
            metrics: [BCMDashboardsClientTypes.MetricName]? = nil,
            timeRange: BCMDashboardsClientTypes.DateTimeRange? = nil
        ) {
            self.filter = filter
            self.granularity = granularity
            self.groupBy = groupBy
            self.metrics = metrics
            self.timeRange = timeRange
        }
    }
}

extension BCMDashboardsClientTypes {

    /// Defines the parameters for querying Reserved Instance coverage data, including grouping options, metrics, and sorting preferences.
    public struct ReservationCoverageQuery: Swift.Sendable {
        /// Defines complex filtering conditions using logical operators (AND, OR, NOT) and various filter types.
        public var filter: BCMDashboardsClientTypes.Expression?
        /// The time granularity of the retrieved data: HOURLY, DAILY, or MONTHLY.
        public var granularity: BCMDashboardsClientTypes.Granularity?
        /// Specifies how to group the Reserved Instance coverage data, such as by service, Region, or instance type.
        public var groupBy: [BCMDashboardsClientTypes.GroupDefinition]?
        /// The coverage metrics to include in the results. Valid values for ReservationCoverageQuery metrics are Hour, Unit, and Cost.
        public var metrics: [BCMDashboardsClientTypes.MetricName]?
        /// Defines a time period with explicit start and end times for data queries.
        /// This member is required.
        public var timeRange: BCMDashboardsClientTypes.DateTimeRange?

        public init(
            filter: BCMDashboardsClientTypes.Expression? = nil,
            granularity: BCMDashboardsClientTypes.Granularity? = nil,
            groupBy: [BCMDashboardsClientTypes.GroupDefinition]? = nil,
            metrics: [BCMDashboardsClientTypes.MetricName]? = nil,
            timeRange: BCMDashboardsClientTypes.DateTimeRange? = nil
        ) {
            self.filter = filter
            self.granularity = granularity
            self.groupBy = groupBy
            self.metrics = metrics
            self.timeRange = timeRange
        }
    }
}

extension BCMDashboardsClientTypes {

    /// Defines the parameters for querying Reserved Instance utilization data, including grouping options and time granularity.
    public struct ReservationUtilizationQuery: Swift.Sendable {
        /// Defines complex filtering conditions using logical operators (AND, OR, NOT) and various filter types.
        public var filter: BCMDashboardsClientTypes.Expression?
        /// The time granularity of the retrieved data: HOURLY, DAILY, or MONTHLY.
        public var granularity: BCMDashboardsClientTypes.Granularity?
        /// Specifies how to group the Reserved Instance utilization data, such as by service, Region, or instance type.
        public var groupBy: [BCMDashboardsClientTypes.GroupDefinition]?
        /// Defines a time period with explicit start and end times for data queries.
        /// This member is required.
        public var timeRange: BCMDashboardsClientTypes.DateTimeRange?

        public init(
            filter: BCMDashboardsClientTypes.Expression? = nil,
            granularity: BCMDashboardsClientTypes.Granularity? = nil,
            groupBy: [BCMDashboardsClientTypes.GroupDefinition]? = nil,
            timeRange: BCMDashboardsClientTypes.DateTimeRange? = nil
        ) {
            self.filter = filter
            self.granularity = granularity
            self.groupBy = groupBy
            self.timeRange = timeRange
        }
    }
}

extension BCMDashboardsClientTypes {

    /// Defines the parameters for querying Savings Plans coverage data, including metrics, grouping options, and time granularity.
    public struct SavingsPlansCoverageQuery: Swift.Sendable {
        /// Defines complex filtering conditions using logical operators (AND, OR, NOT) and various filter types.
        public var filter: BCMDashboardsClientTypes.Expression?
        /// The time granularity of the retrieved data: HOURLY, DAILY, or MONTHLY.
        public var granularity: BCMDashboardsClientTypes.Granularity?
        /// Specifies how to group the Savings Plans coverage data, such as by service or instance family.
        public var groupBy: [BCMDashboardsClientTypes.GroupDefinition]?
        /// The coverage metrics to include in the results. Valid value for SavingsPlansCoverageQuery metrics is SpendCoveredBySavingsPlans.
        public var metrics: [BCMDashboardsClientTypes.MetricName]?
        /// Defines a time period with explicit start and end times for data queries.
        /// This member is required.
        public var timeRange: BCMDashboardsClientTypes.DateTimeRange?

        public init(
            filter: BCMDashboardsClientTypes.Expression? = nil,
            granularity: BCMDashboardsClientTypes.Granularity? = nil,
            groupBy: [BCMDashboardsClientTypes.GroupDefinition]? = nil,
            metrics: [BCMDashboardsClientTypes.MetricName]? = nil,
            timeRange: BCMDashboardsClientTypes.DateTimeRange? = nil
        ) {
            self.filter = filter
            self.granularity = granularity
            self.groupBy = groupBy
            self.metrics = metrics
            self.timeRange = timeRange
        }
    }
}

extension BCMDashboardsClientTypes {

    /// Defines the parameters for querying Savings Plans utilization data, including time granularity and sorting preferences.
    public struct SavingsPlansUtilizationQuery: Swift.Sendable {
        /// Defines complex filtering conditions using logical operators (AND, OR, NOT) and various filter types.
        public var filter: BCMDashboardsClientTypes.Expression?
        /// The time granularity of the retrieved data: HOURLY, DAILY, or MONTHLY.
        public var granularity: BCMDashboardsClientTypes.Granularity?
        /// Defines a time period with explicit start and end times for data queries.
        /// This member is required.
        public var timeRange: BCMDashboardsClientTypes.DateTimeRange?

        public init(
            filter: BCMDashboardsClientTypes.Expression? = nil,
            granularity: BCMDashboardsClientTypes.Granularity? = nil,
            timeRange: BCMDashboardsClientTypes.DateTimeRange? = nil
        ) {
            self.filter = filter
            self.granularity = granularity
            self.timeRange = timeRange
        }
    }
}

extension BCMDashboardsClientTypes {

    /// Defines the data retrieval parameters for a widget.
    public indirect enum QueryParameters: Swift.Sendable {
        /// The parameters for querying cost and usage data, including metrics, time range, granularity, grouping dimensions, and filters.
        case costandusage(BCMDashboardsClientTypes.CostAndUsageQuery)
        /// The parameters for querying Savings Plans coverage data, showing how much of your eligible compute usage is covered by Savings Plans.
        case savingsplanscoverage(BCMDashboardsClientTypes.SavingsPlansCoverageQuery)
        /// The parameters for querying Savings Plans utilization data, showing how effectively your Savings Plans are being used.
        case savingsplansutilization(BCMDashboardsClientTypes.SavingsPlansUtilizationQuery)
        /// The parameters for querying Reserved Instance coverage data, showing how much of your eligible instance usage is covered by Reserved Instances.
        case reservationcoverage(BCMDashboardsClientTypes.ReservationCoverageQuery)
        /// The parameters for querying Reserved Instance utilization data, showing how effectively your Reserved Instances are being used.
        case reservationutilization(BCMDashboardsClientTypes.ReservationUtilizationQuery)
        case sdkUnknown(Swift.String)
    }
}

extension BCMDashboardsClientTypes {

    /// Defines the complete configuration for a widget, including data retrieval settings and visualization preferences.
    public struct WidgetConfig: Swift.Sendable {
        /// The configuration that determines how the retrieved data should be visualized in the widget.
        /// This member is required.
        public var displayConfig: BCMDashboardsClientTypes.DisplayConfig?
        /// The parameters that define what data the widget should retrieve and how it should be filtered or grouped.
        /// This member is required.
        public var queryParameters: BCMDashboardsClientTypes.QueryParameters?

        public init(
            displayConfig: BCMDashboardsClientTypes.DisplayConfig? = nil,
            queryParameters: BCMDashboardsClientTypes.QueryParameters? = nil
        ) {
            self.displayConfig = displayConfig
            self.queryParameters = queryParameters
        }
    }
}

extension BCMDashboardsClientTypes {

    /// A configurable visualization component within a dashboard that displays specific cost and usage metrics. Each widget can show data as charts or tables and includes settings for data querying, filtering, and visual presentation.
    public struct Widget: Swift.Sendable {
        /// An array of configurations that define the data queries and display settings for the widget.
        /// This member is required.
        public var configs: [BCMDashboardsClientTypes.WidgetConfig]?
        /// A description of the widget's purpose or the data it displays.
        public var description: Swift.String?
        /// The height of the widget in row spans. The dashboard layout consists of a grid system.
        public var height: Swift.Int?
        /// Specifies the starting column position of the widget in the dashboard's grid layout. Used to control widget placement.
        public var horizontalOffset: Swift.Int
        /// The title of the widget.
        /// This member is required.
        public var title: Swift.String?
        /// The width of the widget in column spans. The dashboard layout consists of a grid system.
        public var width: Swift.Int?

        public init(
            configs: [BCMDashboardsClientTypes.WidgetConfig]? = nil,
            description: Swift.String? = nil,
            height: Swift.Int? = 7,
            horizontalOffset: Swift.Int = 0,
            title: Swift.String? = nil,
            width: Swift.Int? = 4
        ) {
            self.configs = configs
            self.description = description
            self.height = height
            self.horizontalOffset = horizontalOffset
            self.title = title
            self.width = width
        }
    }
}

public struct CreateDashboardInput: Swift.Sendable {
    /// A description of the dashboard's purpose or contents.
    public var description: Swift.String?
    /// The name of the dashboard. The name must be unique within your account.
    /// This member is required.
    public var name: Swift.String?
    /// The tags to apply to the dashboard resource for organization and management.
    public var resourceTags: [BCMDashboardsClientTypes.ResourceTag]?
    /// An array of widget configurations that define the visualizations to be displayed in the dashboard. Each dashboard can contain up to 20 widgets.
    /// This member is required.
    public var widgets: [BCMDashboardsClientTypes.Widget]?

    public init(
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        resourceTags: [BCMDashboardsClientTypes.ResourceTag]? = nil,
        widgets: [BCMDashboardsClientTypes.Widget]? = nil
    ) {
        self.description = description
        self.name = name
        self.resourceTags = resourceTags
        self.widgets = widgets
    }
}

public struct GetDashboardOutput: Swift.Sendable {
    /// The ARN of the retrieved dashboard.
    /// This member is required.
    public var arn: Swift.String?
    /// The timestamp when the dashboard was created.
    /// This member is required.
    public var createdAt: Foundation.Date?
    /// The description of the retrieved dashboard.
    public var description: Swift.String?
    /// The name of the retrieved dashboard.
    /// This member is required.
    public var name: Swift.String?
    /// Indicates the dashboard type.
    /// This member is required.
    public var type: BCMDashboardsClientTypes.DashboardType?
    /// The timestamp when the dashboard was last modified.
    /// This member is required.
    public var updatedAt: Foundation.Date?
    /// An array of widget configurations that make up the dashboard.
    /// This member is required.
    public var widgets: [BCMDashboardsClientTypes.Widget]?

    public init(
        arn: Swift.String? = nil,
        createdAt: Foundation.Date? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        type: BCMDashboardsClientTypes.DashboardType? = nil,
        updatedAt: Foundation.Date? = nil,
        widgets: [BCMDashboardsClientTypes.Widget]? = nil
    ) {
        self.arn = arn
        self.createdAt = createdAt
        self.description = description
        self.name = name
        self.type = type
        self.updatedAt = updatedAt
        self.widgets = widgets
    }
}

public struct UpdateDashboardInput: Swift.Sendable {
    /// The ARN of the dashboard to update.
    /// This member is required.
    public var arn: Swift.String?
    /// The new description for the dashboard. If not specified, the existing description is retained.
    public var description: Swift.String?
    /// The new name for the dashboard. If not specified, the existing name is retained.
    public var name: Swift.String?
    /// The updated array of widget configurations for the dashboard. Replaces all existing widgets.
    public var widgets: [BCMDashboardsClientTypes.Widget]?

    public init(
        arn: Swift.String? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        widgets: [BCMDashboardsClientTypes.Widget]? = nil
    ) {
        self.arn = arn
        self.description = description
        self.name = name
        self.widgets = widgets
    }
}

extension CreateDashboardInput {

    static func urlPathProvider(_ value: CreateDashboardInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteDashboardInput {

    static func urlPathProvider(_ value: DeleteDashboardInput) -> Swift.String? {
        return "/"
    }
}

extension GetDashboardInput {

    static func urlPathProvider(_ value: GetDashboardInput) -> Swift.String? {
        return "/"
    }
}

extension GetResourcePolicyInput {

    static func urlPathProvider(_ value: GetResourcePolicyInput) -> Swift.String? {
        return "/"
    }
}

extension ListDashboardsInput {

    static func urlPathProvider(_ value: ListDashboardsInput) -> Swift.String? {
        return "/"
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        return "/"
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        return "/"
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateDashboardInput {

    static func urlPathProvider(_ value: UpdateDashboardInput) -> Swift.String? {
        return "/"
    }
}

extension CreateDashboardInput {

    static func write(value: CreateDashboardInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["description"].write(value.description)
        try writer["name"].write(value.name)
        try writer["resourceTags"].writeList(value.resourceTags, memberWritingClosure: BCMDashboardsClientTypes.ResourceTag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["widgets"].writeList(value.widgets, memberWritingClosure: BCMDashboardsClientTypes.Widget.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension DeleteDashboardInput {

    static func write(value: DeleteDashboardInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["arn"].write(value.arn)
    }
}

extension GetDashboardInput {

    static func write(value: GetDashboardInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["arn"].write(value.arn)
    }
}

extension GetResourcePolicyInput {

    static func write(value: GetResourcePolicyInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["resourceArn"].write(value.resourceArn)
    }
}

extension ListDashboardsInput {

    static func write(value: ListDashboardsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension ListTagsForResourceInput {

    static func write(value: ListTagsForResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["resourceArn"].write(value.resourceArn)
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["resourceArn"].write(value.resourceArn)
        try writer["resourceTags"].writeList(value.resourceTags, memberWritingClosure: BCMDashboardsClientTypes.ResourceTag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UntagResourceInput {

    static func write(value: UntagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["resourceArn"].write(value.resourceArn)
        try writer["resourceTagKeys"].writeList(value.resourceTagKeys, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdateDashboardInput {

    static func write(value: UpdateDashboardInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["arn"].write(value.arn)
        try writer["description"].write(value.description)
        try writer["name"].write(value.name)
        try writer["widgets"].writeList(value.widgets, memberWritingClosure: BCMDashboardsClientTypes.Widget.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateDashboardOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateDashboardOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateDashboardOutput()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        return value
    }
}

extension DeleteDashboardOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteDashboardOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteDashboardOutput()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        return value
    }
}

extension GetDashboardOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetDashboardOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetDashboardOutput()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.description = try reader["description"].readIfPresent()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.type = try reader["type"].readIfPresent() ?? .sdkUnknown("")
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.widgets = try reader["widgets"].readListIfPresent(memberReadingClosure: BCMDashboardsClientTypes.Widget.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension GetResourcePolicyOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetResourcePolicyOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetResourcePolicyOutput()
        value.policyDocument = try reader["policyDocument"].readIfPresent() ?? ""
        value.resourceArn = try reader["resourceArn"].readIfPresent() ?? ""
        return value
    }
}

extension ListDashboardsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListDashboardsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListDashboardsOutput()
        value.dashboards = try reader["dashboards"].readListIfPresent(memberReadingClosure: BCMDashboardsClientTypes.DashboardReference.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.resourceTags = try reader["resourceTags"].readListIfPresent(memberReadingClosure: BCMDashboardsClientTypes.ResourceTag.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

extension UpdateDashboardOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateDashboardOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateDashboardOutput()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        return value
    }
}

enum CreateDashboardOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteDashboardOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetDashboardOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetResourcePolicyOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListDashboardsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateDashboardOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension AccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> AccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = AccessDeniedException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InternalServerException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InternalServerException {
        let reader = baseError.errorBodyReader
        var value = InternalServerException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ServiceQuotaExceededException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ServiceQuotaExceededException {
        let reader = baseError.errorBodyReader
        var value = ServiceQuotaExceededException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ThrottlingException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ThrottlingException {
        let reader = baseError.errorBodyReader
        var value = ThrottlingException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ValidationException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ValidationException {
        let reader = baseError.errorBodyReader
        var value = ValidationException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension BCMDashboardsClientTypes.CostAndUsageQuery {

    static func write(value: BCMDashboardsClientTypes.CostAndUsageQuery?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["filter"].write(value.filter, with: BCMDashboardsClientTypes.Expression.write(value:to:))
        try writer["granularity"].write(value.granularity)
        try writer["groupBy"].writeList(value.groupBy, memberWritingClosure: BCMDashboardsClientTypes.GroupDefinition.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["metrics"].writeList(value.metrics, memberWritingClosure: SmithyReadWrite.WritingClosureBox<BCMDashboardsClientTypes.MetricName>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["timeRange"].write(value.timeRange, with: BCMDashboardsClientTypes.DateTimeRange.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BCMDashboardsClientTypes.CostAndUsageQuery {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BCMDashboardsClientTypes.CostAndUsageQuery()
        value.metrics = try reader["metrics"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<BCMDashboardsClientTypes.MetricName>().read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.timeRange = try reader["timeRange"].readIfPresent(with: BCMDashboardsClientTypes.DateTimeRange.read(from:))
        value.granularity = try reader["granularity"].readIfPresent() ?? .sdkUnknown("")
        value.groupBy = try reader["groupBy"].readListIfPresent(memberReadingClosure: BCMDashboardsClientTypes.GroupDefinition.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.filter = try reader["filter"].readIfPresent(with: BCMDashboardsClientTypes.Expression.read(from:))
        return value
    }
}

extension BCMDashboardsClientTypes.CostCategoryValues {

    static func write(value: BCMDashboardsClientTypes.CostCategoryValues?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["key"].write(value.key)
        try writer["matchOptions"].writeList(value.matchOptions, memberWritingClosure: SmithyReadWrite.WritingClosureBox<BCMDashboardsClientTypes.MatchOption>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["values"].writeList(value.values, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BCMDashboardsClientTypes.CostCategoryValues {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BCMDashboardsClientTypes.CostCategoryValues()
        value.key = try reader["key"].readIfPresent()
        value.values = try reader["values"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.matchOptions = try reader["matchOptions"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<BCMDashboardsClientTypes.MatchOption>().read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BCMDashboardsClientTypes.DashboardReference {

    static func read(from reader: SmithyJSON.Reader) throws -> BCMDashboardsClientTypes.DashboardReference {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BCMDashboardsClientTypes.DashboardReference()
        value.arn = try reader["arn"].readIfPresent() ?? ""
        value.name = try reader["name"].readIfPresent() ?? ""
        value.description = try reader["description"].readIfPresent()
        value.type = try reader["type"].readIfPresent() ?? .sdkUnknown("")
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension BCMDashboardsClientTypes.DateTimeRange {

    static func write(value: BCMDashboardsClientTypes.DateTimeRange?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["endTime"].write(value.endTime, with: BCMDashboardsClientTypes.DateTimeValue.write(value:to:))
        try writer["startTime"].write(value.startTime, with: BCMDashboardsClientTypes.DateTimeValue.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BCMDashboardsClientTypes.DateTimeRange {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BCMDashboardsClientTypes.DateTimeRange()
        value.startTime = try reader["startTime"].readIfPresent(with: BCMDashboardsClientTypes.DateTimeValue.read(from:))
        value.endTime = try reader["endTime"].readIfPresent(with: BCMDashboardsClientTypes.DateTimeValue.read(from:))
        return value
    }
}

extension BCMDashboardsClientTypes.DateTimeValue {

    static func write(value: BCMDashboardsClientTypes.DateTimeValue?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["type"].write(value.type)
        try writer["value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BCMDashboardsClientTypes.DateTimeValue {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BCMDashboardsClientTypes.DateTimeValue()
        value.type = try reader["type"].readIfPresent() ?? .sdkUnknown("")
        value.value = try reader["value"].readIfPresent() ?? ""
        return value
    }
}

extension BCMDashboardsClientTypes.DimensionValues {

    static func write(value: BCMDashboardsClientTypes.DimensionValues?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["key"].write(value.key)
        try writer["matchOptions"].writeList(value.matchOptions, memberWritingClosure: SmithyReadWrite.WritingClosureBox<BCMDashboardsClientTypes.MatchOption>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["values"].writeList(value.values, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BCMDashboardsClientTypes.DimensionValues {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BCMDashboardsClientTypes.DimensionValues()
        value.key = try reader["key"].readIfPresent() ?? .sdkUnknown("")
        value.values = try reader["values"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.matchOptions = try reader["matchOptions"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<BCMDashboardsClientTypes.MatchOption>().read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BCMDashboardsClientTypes.DisplayConfig {

    static func write(value: BCMDashboardsClientTypes.DisplayConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .graph(graph):
                try writer["graph"].writeMap(graph, valueWritingClosure: BCMDashboardsClientTypes.GraphDisplayConfig.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
            case let .table(table):
                try writer["table"].write(table, with: BCMDashboardsClientTypes.TableDisplayConfigStruct.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BCMDashboardsClientTypes.DisplayConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "graph":
                return .graph(try reader["graph"].readMap(valueReadingClosure: BCMDashboardsClientTypes.GraphDisplayConfig.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false))
            case "table":
                return .table(try reader["table"].read(with: BCMDashboardsClientTypes.TableDisplayConfigStruct.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension BCMDashboardsClientTypes.Expression {

    static func write(value: BCMDashboardsClientTypes.Expression?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["and"].writeList(value.and, memberWritingClosure: BCMDashboardsClientTypes.Expression.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["costCategories"].write(value.costCategories, with: BCMDashboardsClientTypes.CostCategoryValues.write(value:to:))
        try writer["dimensions"].write(value.dimensions, with: BCMDashboardsClientTypes.DimensionValues.write(value:to:))
        try writer["not"].write(value.not, with: BCMDashboardsClientTypes.Expression.write(value:to:))
        try writer["or"].writeList(value.or, memberWritingClosure: BCMDashboardsClientTypes.Expression.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["tags"].write(value.tags, with: BCMDashboardsClientTypes.TagValues.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BCMDashboardsClientTypes.Expression {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BCMDashboardsClientTypes.Expression()
        value.or = try reader["or"].readListIfPresent(memberReadingClosure: BCMDashboardsClientTypes.Expression.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.and = try reader["and"].readListIfPresent(memberReadingClosure: BCMDashboardsClientTypes.Expression.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.not = try reader["not"].readIfPresent(with: BCMDashboardsClientTypes.Expression.read(from:))
        value.dimensions = try reader["dimensions"].readIfPresent(with: BCMDashboardsClientTypes.DimensionValues.read(from:))
        value.tags = try reader["tags"].readIfPresent(with: BCMDashboardsClientTypes.TagValues.read(from:))
        value.costCategories = try reader["costCategories"].readIfPresent(with: BCMDashboardsClientTypes.CostCategoryValues.read(from:))
        return value
    }
}

extension BCMDashboardsClientTypes.GraphDisplayConfig {

    static func write(value: BCMDashboardsClientTypes.GraphDisplayConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["visualType"].write(value.visualType)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BCMDashboardsClientTypes.GraphDisplayConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BCMDashboardsClientTypes.GraphDisplayConfig()
        value.visualType = try reader["visualType"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension BCMDashboardsClientTypes.GroupDefinition {

    static func write(value: BCMDashboardsClientTypes.GroupDefinition?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["key"].write(value.key)
        try writer["type"].write(value.type)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BCMDashboardsClientTypes.GroupDefinition {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BCMDashboardsClientTypes.GroupDefinition()
        value.key = try reader["key"].readIfPresent() ?? ""
        value.type = try reader["type"].readIfPresent() ?? BCMDashboardsClientTypes.GroupDefinitionType.dimension
        return value
    }
}

extension BCMDashboardsClientTypes.QueryParameters {

    static func write(value: BCMDashboardsClientTypes.QueryParameters?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .costandusage(costandusage):
                try writer["costAndUsage"].write(costandusage, with: BCMDashboardsClientTypes.CostAndUsageQuery.write(value:to:))
            case let .reservationcoverage(reservationcoverage):
                try writer["reservationCoverage"].write(reservationcoverage, with: BCMDashboardsClientTypes.ReservationCoverageQuery.write(value:to:))
            case let .reservationutilization(reservationutilization):
                try writer["reservationUtilization"].write(reservationutilization, with: BCMDashboardsClientTypes.ReservationUtilizationQuery.write(value:to:))
            case let .savingsplanscoverage(savingsplanscoverage):
                try writer["savingsPlansCoverage"].write(savingsplanscoverage, with: BCMDashboardsClientTypes.SavingsPlansCoverageQuery.write(value:to:))
            case let .savingsplansutilization(savingsplansutilization):
                try writer["savingsPlansUtilization"].write(savingsplansutilization, with: BCMDashboardsClientTypes.SavingsPlansUtilizationQuery.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BCMDashboardsClientTypes.QueryParameters {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "costAndUsage":
                return .costandusage(try reader["costAndUsage"].read(with: BCMDashboardsClientTypes.CostAndUsageQuery.read(from:)))
            case "savingsPlansCoverage":
                return .savingsplanscoverage(try reader["savingsPlansCoverage"].read(with: BCMDashboardsClientTypes.SavingsPlansCoverageQuery.read(from:)))
            case "savingsPlansUtilization":
                return .savingsplansutilization(try reader["savingsPlansUtilization"].read(with: BCMDashboardsClientTypes.SavingsPlansUtilizationQuery.read(from:)))
            case "reservationCoverage":
                return .reservationcoverage(try reader["reservationCoverage"].read(with: BCMDashboardsClientTypes.ReservationCoverageQuery.read(from:)))
            case "reservationUtilization":
                return .reservationutilization(try reader["reservationUtilization"].read(with: BCMDashboardsClientTypes.ReservationUtilizationQuery.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension BCMDashboardsClientTypes.ReservationCoverageQuery {

    static func write(value: BCMDashboardsClientTypes.ReservationCoverageQuery?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["filter"].write(value.filter, with: BCMDashboardsClientTypes.Expression.write(value:to:))
        try writer["granularity"].write(value.granularity)
        try writer["groupBy"].writeList(value.groupBy, memberWritingClosure: BCMDashboardsClientTypes.GroupDefinition.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["metrics"].writeList(value.metrics, memberWritingClosure: SmithyReadWrite.WritingClosureBox<BCMDashboardsClientTypes.MetricName>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["timeRange"].write(value.timeRange, with: BCMDashboardsClientTypes.DateTimeRange.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BCMDashboardsClientTypes.ReservationCoverageQuery {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BCMDashboardsClientTypes.ReservationCoverageQuery()
        value.timeRange = try reader["timeRange"].readIfPresent(with: BCMDashboardsClientTypes.DateTimeRange.read(from:))
        value.groupBy = try reader["groupBy"].readListIfPresent(memberReadingClosure: BCMDashboardsClientTypes.GroupDefinition.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.granularity = try reader["granularity"].readIfPresent()
        value.filter = try reader["filter"].readIfPresent(with: BCMDashboardsClientTypes.Expression.read(from:))
        value.metrics = try reader["metrics"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<BCMDashboardsClientTypes.MetricName>().read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BCMDashboardsClientTypes.ReservationUtilizationQuery {

    static func write(value: BCMDashboardsClientTypes.ReservationUtilizationQuery?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["filter"].write(value.filter, with: BCMDashboardsClientTypes.Expression.write(value:to:))
        try writer["granularity"].write(value.granularity)
        try writer["groupBy"].writeList(value.groupBy, memberWritingClosure: BCMDashboardsClientTypes.GroupDefinition.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["timeRange"].write(value.timeRange, with: BCMDashboardsClientTypes.DateTimeRange.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BCMDashboardsClientTypes.ReservationUtilizationQuery {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BCMDashboardsClientTypes.ReservationUtilizationQuery()
        value.timeRange = try reader["timeRange"].readIfPresent(with: BCMDashboardsClientTypes.DateTimeRange.read(from:))
        value.groupBy = try reader["groupBy"].readListIfPresent(memberReadingClosure: BCMDashboardsClientTypes.GroupDefinition.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.granularity = try reader["granularity"].readIfPresent()
        value.filter = try reader["filter"].readIfPresent(with: BCMDashboardsClientTypes.Expression.read(from:))
        return value
    }
}

extension BCMDashboardsClientTypes.ResourceTag {

    static func write(value: BCMDashboardsClientTypes.ResourceTag?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["key"].write(value.key)
        try writer["value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BCMDashboardsClientTypes.ResourceTag {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BCMDashboardsClientTypes.ResourceTag()
        value.key = try reader["key"].readIfPresent() ?? ""
        value.value = try reader["value"].readIfPresent() ?? ""
        return value
    }
}

extension BCMDashboardsClientTypes.SavingsPlansCoverageQuery {

    static func write(value: BCMDashboardsClientTypes.SavingsPlansCoverageQuery?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["filter"].write(value.filter, with: BCMDashboardsClientTypes.Expression.write(value:to:))
        try writer["granularity"].write(value.granularity)
        try writer["groupBy"].writeList(value.groupBy, memberWritingClosure: BCMDashboardsClientTypes.GroupDefinition.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["metrics"].writeList(value.metrics, memberWritingClosure: SmithyReadWrite.WritingClosureBox<BCMDashboardsClientTypes.MetricName>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["timeRange"].write(value.timeRange, with: BCMDashboardsClientTypes.DateTimeRange.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BCMDashboardsClientTypes.SavingsPlansCoverageQuery {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BCMDashboardsClientTypes.SavingsPlansCoverageQuery()
        value.timeRange = try reader["timeRange"].readIfPresent(with: BCMDashboardsClientTypes.DateTimeRange.read(from:))
        value.metrics = try reader["metrics"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<BCMDashboardsClientTypes.MetricName>().read(from:), memberNodeInfo: "member", isFlattened: false)
        value.granularity = try reader["granularity"].readIfPresent()
        value.groupBy = try reader["groupBy"].readListIfPresent(memberReadingClosure: BCMDashboardsClientTypes.GroupDefinition.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.filter = try reader["filter"].readIfPresent(with: BCMDashboardsClientTypes.Expression.read(from:))
        return value
    }
}

extension BCMDashboardsClientTypes.SavingsPlansUtilizationQuery {

    static func write(value: BCMDashboardsClientTypes.SavingsPlansUtilizationQuery?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["filter"].write(value.filter, with: BCMDashboardsClientTypes.Expression.write(value:to:))
        try writer["granularity"].write(value.granularity)
        try writer["timeRange"].write(value.timeRange, with: BCMDashboardsClientTypes.DateTimeRange.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BCMDashboardsClientTypes.SavingsPlansUtilizationQuery {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BCMDashboardsClientTypes.SavingsPlansUtilizationQuery()
        value.timeRange = try reader["timeRange"].readIfPresent(with: BCMDashboardsClientTypes.DateTimeRange.read(from:))
        value.granularity = try reader["granularity"].readIfPresent()
        value.filter = try reader["filter"].readIfPresent(with: BCMDashboardsClientTypes.Expression.read(from:))
        return value
    }
}

extension BCMDashboardsClientTypes.TableDisplayConfigStruct {

    static func write(value: BCMDashboardsClientTypes.TableDisplayConfigStruct?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BCMDashboardsClientTypes.TableDisplayConfigStruct {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        return BCMDashboardsClientTypes.TableDisplayConfigStruct()
    }
}

extension BCMDashboardsClientTypes.TagValues {

    static func write(value: BCMDashboardsClientTypes.TagValues?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["key"].write(value.key)
        try writer["matchOptions"].writeList(value.matchOptions, memberWritingClosure: SmithyReadWrite.WritingClosureBox<BCMDashboardsClientTypes.MatchOption>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["values"].writeList(value.values, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BCMDashboardsClientTypes.TagValues {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BCMDashboardsClientTypes.TagValues()
        value.key = try reader["key"].readIfPresent()
        value.values = try reader["values"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.matchOptions = try reader["matchOptions"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<BCMDashboardsClientTypes.MatchOption>().read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BCMDashboardsClientTypes.Widget {

    static func write(value: BCMDashboardsClientTypes.Widget?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["configs"].writeList(value.configs, memberWritingClosure: BCMDashboardsClientTypes.WidgetConfig.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["description"].write(value.description)
        try writer["height"].write(value.height)
        try writer["horizontalOffset"].write(value.horizontalOffset)
        try writer["title"].write(value.title)
        try writer["width"].write(value.width)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BCMDashboardsClientTypes.Widget {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BCMDashboardsClientTypes.Widget()
        value.title = try reader["title"].readIfPresent() ?? ""
        value.description = try reader["description"].readIfPresent()
        value.width = try reader["width"].readIfPresent() ?? 4
        value.height = try reader["height"].readIfPresent() ?? 7
        value.horizontalOffset = try reader["horizontalOffset"].readIfPresent() ?? 0
        value.configs = try reader["configs"].readListIfPresent(memberReadingClosure: BCMDashboardsClientTypes.WidgetConfig.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension BCMDashboardsClientTypes.WidgetConfig {

    static func write(value: BCMDashboardsClientTypes.WidgetConfig?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["displayConfig"].write(value.displayConfig, with: BCMDashboardsClientTypes.DisplayConfig.write(value:to:))
        try writer["queryParameters"].write(value.queryParameters, with: BCMDashboardsClientTypes.QueryParameters.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BCMDashboardsClientTypes.WidgetConfig {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BCMDashboardsClientTypes.WidgetConfig()
        value.queryParameters = try reader["queryParameters"].readIfPresent(with: BCMDashboardsClientTypes.QueryParameters.read(from:))
        value.displayConfig = try reader["displayConfig"].readIfPresent(with: BCMDashboardsClientTypes.DisplayConfig.read(from:))
        return value
    }
}

public enum BCMDashboardsClientTypes {}
