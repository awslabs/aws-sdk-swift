// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You do not have sufficient access to perform this action.
public struct AccessDeniedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension FinspacedataClientTypes {
    public enum ApiAccess: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [ApiAccess] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ApiAccess(rawValue: rawValue) ?? ApiAccess.sdkUnknown(rawValue)
        }
    }
}

extension FinspacedataClientTypes {
    public enum ApplicationPermission: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case accessnotebooks
        case createdataset
        case gettemporarycredentials
        case manageattributesets
        case manageclusters
        case manageusersandgroups
        case viewauditdata
        case sdkUnknown(Swift.String)

        public static var allCases: [ApplicationPermission] {
            return [
                .accessnotebooks,
                .createdataset,
                .gettemporarycredentials,
                .manageattributesets,
                .manageclusters,
                .manageusersandgroups,
                .viewauditdata,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .accessnotebooks: return "AccessNotebooks"
            case .createdataset: return "CreateDataset"
            case .gettemporarycredentials: return "GetTemporaryCredentials"
            case .manageattributesets: return "ManageAttributeSets"
            case .manageclusters: return "ManageClusters"
            case .manageusersandgroups: return "ManageUsersAndGroups"
            case .viewauditdata: return "ViewAuditData"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ApplicationPermission(rawValue: rawValue) ?? ApplicationPermission.sdkUnknown(rawValue)
        }
    }
}

extension AssociateUserToPermissionGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
    }
}

extension AssociateUserToPermissionGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let permissionGroupId = permissionGroupId else {
            return nil
        }
        guard let userId = userId else {
            return nil
        }
        return "/permission-group/\(permissionGroupId.urlPercentEncoding())/users/\(userId.urlPercentEncoding())"
    }
}

public struct AssociateUserToPermissionGroupInput: Swift.Equatable {
    /// A token that ensures idempotency. This token expires in 10 minutes.
    public var clientToken: Swift.String?
    /// The unique identifier for the permission group.
    /// This member is required.
    public var permissionGroupId: Swift.String?
    /// The unique identifier for the user.
    /// This member is required.
    public var userId: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        permissionGroupId: Swift.String? = nil,
        userId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.permissionGroupId = permissionGroupId
        self.userId = userId
    }
}

struct AssociateUserToPermissionGroupInputBody: Swift.Equatable {
    let clientToken: Swift.String?
}

extension AssociateUserToPermissionGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension AssociateUserToPermissionGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AssociateUserToPermissionGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum AssociateUserToPermissionGroupOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AssociateUserToPermissionGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        self.statusCode = httpResponse.statusCode.rawValue
    }
}

public struct AssociateUserToPermissionGroupOutputResponse: Swift.Equatable {
    /// The returned status code of the response.
    public var statusCode: Swift.Int

    public init (
        statusCode: Swift.Int = 0
    )
    {
        self.statusCode = statusCode
    }
}

struct AssociateUserToPermissionGroupOutputResponseBody: Swift.Equatable {
    let statusCode: Swift.Int
}

extension AssociateUserToPermissionGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case statusCode
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusCodeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .statusCode) ?? 0
        statusCode = statusCodeDecoded
    }
}

extension FinspacedataClientTypes.AwsCredentials: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessKeyId
        case expiration
        case secretAccessKey
        case sessionToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessKeyId = self.accessKeyId {
            try encodeContainer.encode(accessKeyId, forKey: .accessKeyId)
        }
        if expiration != 0 {
            try encodeContainer.encode(expiration, forKey: .expiration)
        }
        if let secretAccessKey = self.secretAccessKey {
            try encodeContainer.encode(secretAccessKey, forKey: .secretAccessKey)
        }
        if let sessionToken = self.sessionToken {
            try encodeContainer.encode(sessionToken, forKey: .sessionToken)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accessKeyId)
        accessKeyId = accessKeyIdDecoded
        let secretAccessKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretAccessKey)
        secretAccessKey = secretAccessKeyDecoded
        let sessionTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sessionToken)
        sessionToken = sessionTokenDecoded
        let expirationDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .expiration) ?? 0
        expiration = expirationDecoded
    }
}

extension FinspacedataClientTypes.AwsCredentials: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AwsCredentials(accessKeyId: \(Swift.String(describing: accessKeyId)), expiration: \(Swift.String(describing: expiration)), secretAccessKey: \"CONTENT_REDACTED\", sessionToken: \"CONTENT_REDACTED\")"}
}

extension FinspacedataClientTypes {
    /// The credentials required to access the external Dataview from the S3 location.
    public struct AwsCredentials: Swift.Equatable {
        /// The unique identifier for the security credentials.
        public var accessKeyId: Swift.String?
        /// The Epoch time when the current credentials expire.
        public var expiration: Swift.Int
        /// The secret access key that can be used to sign requests.
        public var secretAccessKey: Swift.String?
        /// The token that users must pass to use the credentials.
        public var sessionToken: Swift.String?

        public init (
            accessKeyId: Swift.String? = nil,
            expiration: Swift.Int = 0,
            secretAccessKey: Swift.String? = nil,
            sessionToken: Swift.String? = nil
        )
        {
            self.accessKeyId = accessKeyId
            self.expiration = expiration
            self.secretAccessKey = secretAccessKey
            self.sessionToken = sessionToken
        }
    }

}

extension FinspacedataClientTypes {
    /// Indicates how the given change will be applied to the dataset.
    public enum ChangeType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case append
        case modify
        case replace
        case sdkUnknown(Swift.String)

        public static var allCases: [ChangeType] {
            return [
                .append,
                .modify,
                .replace,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .append: return "APPEND"
            case .modify: return "MODIFY"
            case .replace: return "REPLACE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ChangeType(rawValue: rawValue) ?? ChangeType.sdkUnknown(rawValue)
        }
    }
}

extension FinspacedataClientTypes.ChangesetErrorInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCategory
        case errorMessage
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCategory = self.errorCategory {
            try encodeContainer.encode(errorCategory.rawValue, forKey: .errorCategory)
        }
        if let errorMessage = self.errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
        let errorCategoryDecoded = try containerValues.decodeIfPresent(FinspacedataClientTypes.ErrorCategory.self, forKey: .errorCategory)
        errorCategory = errorCategoryDecoded
    }
}

extension FinspacedataClientTypes {
    /// The structure with error messages.
    public struct ChangesetErrorInfo: Swift.Equatable {
        /// The category of the error.
        ///
        /// * VALIDATION – The inputs to this request are invalid.
        ///
        /// * SERVICE_QUOTA_EXCEEDED – Service quotas have been exceeded. Please contact AWS support to increase quotas.
        ///
        /// * ACCESS_DENIED – Missing required permission to perform this request.
        ///
        /// * RESOURCE_NOT_FOUND – One or more inputs to this request were not found.
        ///
        /// * THROTTLING – The system temporarily lacks sufficient resources to process the request.
        ///
        /// * INTERNAL_SERVICE_EXCEPTION – An internal service error has occurred.
        ///
        /// * CANCELLED – Cancelled.
        ///
        /// * USER_RECOVERABLE – A user recoverable error has occurred.
        public var errorCategory: FinspacedataClientTypes.ErrorCategory?
        /// The text of the error message.
        public var errorMessage: Swift.String?

        public init (
            errorCategory: FinspacedataClientTypes.ErrorCategory? = nil,
            errorMessage: Swift.String? = nil
        )
        {
            self.errorCategory = errorCategory
            self.errorMessage = errorMessage
        }
    }

}

extension FinspacedataClientTypes.ChangesetSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case activeFromTimestamp
        case activeUntilTimestamp
        case changeType
        case changesetArn
        case changesetId
        case createTime
        case datasetId
        case errorInfo
        case formatParams
        case sourceParams
        case status
        case updatedByChangesetId
        case updatesChangesetId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let activeFromTimestamp = self.activeFromTimestamp {
            try encodeContainer.encode(activeFromTimestamp, forKey: .activeFromTimestamp)
        }
        if let activeUntilTimestamp = self.activeUntilTimestamp {
            try encodeContainer.encode(activeUntilTimestamp, forKey: .activeUntilTimestamp)
        }
        if let changeType = self.changeType {
            try encodeContainer.encode(changeType.rawValue, forKey: .changeType)
        }
        if let changesetArn = self.changesetArn {
            try encodeContainer.encode(changesetArn, forKey: .changesetArn)
        }
        if let changesetId = self.changesetId {
            try encodeContainer.encode(changesetId, forKey: .changesetId)
        }
        if createTime != 0 {
            try encodeContainer.encode(createTime, forKey: .createTime)
        }
        if let datasetId = self.datasetId {
            try encodeContainer.encode(datasetId, forKey: .datasetId)
        }
        if let errorInfo = self.errorInfo {
            try encodeContainer.encode(errorInfo, forKey: .errorInfo)
        }
        if let formatParams = formatParams {
            var formatParamsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .formatParams)
            for (dictKey0, formatParams0) in formatParams {
                try formatParamsContainer.encode(formatParams0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let sourceParams = sourceParams {
            var sourceParamsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .sourceParams)
            for (dictKey0, sourceParams0) in sourceParams {
                try sourceParamsContainer.encode(sourceParams0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let updatedByChangesetId = self.updatedByChangesetId {
            try encodeContainer.encode(updatedByChangesetId, forKey: .updatedByChangesetId)
        }
        if let updatesChangesetId = self.updatesChangesetId {
            try encodeContainer.encode(updatesChangesetId, forKey: .updatesChangesetId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let changesetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .changesetId)
        changesetId = changesetIdDecoded
        let changesetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .changesetArn)
        changesetArn = changesetArnDecoded
        let datasetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetId)
        datasetId = datasetIdDecoded
        let changeTypeDecoded = try containerValues.decodeIfPresent(FinspacedataClientTypes.ChangeType.self, forKey: .changeType)
        changeType = changeTypeDecoded
        let sourceParamsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .sourceParams)
        var sourceParamsDecoded0: [Swift.String:Swift.String]? = nil
        if let sourceParamsContainer = sourceParamsContainer {
            sourceParamsDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringmapvalue0) in sourceParamsContainer {
                if let stringmapvalue0 = stringmapvalue0 {
                    sourceParamsDecoded0?[key0] = stringmapvalue0
                }
            }
        }
        sourceParams = sourceParamsDecoded0
        let formatParamsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .formatParams)
        var formatParamsDecoded0: [Swift.String:Swift.String]? = nil
        if let formatParamsContainer = formatParamsContainer {
            formatParamsDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringmapvalue0) in formatParamsContainer {
                if let stringmapvalue0 = stringmapvalue0 {
                    formatParamsDecoded0?[key0] = stringmapvalue0
                }
            }
        }
        formatParams = formatParamsDecoded0
        let createTimeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .createTime) ?? 0
        createTime = createTimeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(FinspacedataClientTypes.IngestionStatus.self, forKey: .status)
        status = statusDecoded
        let errorInfoDecoded = try containerValues.decodeIfPresent(FinspacedataClientTypes.ChangesetErrorInfo.self, forKey: .errorInfo)
        errorInfo = errorInfoDecoded
        let activeUntilTimestampDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .activeUntilTimestamp)
        activeUntilTimestamp = activeUntilTimestampDecoded
        let activeFromTimestampDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .activeFromTimestamp)
        activeFromTimestamp = activeFromTimestampDecoded
        let updatesChangesetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .updatesChangesetId)
        updatesChangesetId = updatesChangesetIdDecoded
        let updatedByChangesetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .updatedByChangesetId)
        updatedByChangesetId = updatedByChangesetIdDecoded
    }
}

extension FinspacedataClientTypes {
    /// A Changeset is unit of data in a Dataset.
    public struct ChangesetSummary: Swift.Equatable {
        /// Beginning time from which the Changeset is active. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
        public var activeFromTimestamp: Swift.Int?
        /// Time until which the Changeset is active. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
        public var activeUntilTimestamp: Swift.Int?
        /// Type that indicates how a Changeset is applied to a Dataset.
        ///
        /// * REPLACE – Changeset is considered as a replacement to all prior loaded Changesets.
        ///
        /// * APPEND – Changeset is considered as an addition to the end of all prior loaded Changesets.
        ///
        /// * MODIFY – Changeset is considered as a replacement to a specific prior ingested Changeset.
        public var changeType: FinspacedataClientTypes.ChangeType?
        /// The ARN identifier of the Changeset.
        public var changesetArn: Swift.String?
        /// The unique identifier for a Changeset.
        public var changesetId: Swift.String?
        /// The timestamp at which the Changeset was created in FinSpace. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
        public var createTime: Swift.Int
        /// The unique identifier for the FinSpace Dataset in which the Changeset is created.
        public var datasetId: Swift.String?
        /// The structure with error messages.
        public var errorInfo: FinspacedataClientTypes.ChangesetErrorInfo?
        /// Options that define the structure of the source file(s).
        public var formatParams: [Swift.String:Swift.String]?
        /// Options that define the location of the data being ingested.
        public var sourceParams: [Swift.String:Swift.String]?
        /// Status of the Changeset ingestion.
        ///
        /// * PENDING – Changeset is pending creation.
        ///
        /// * FAILED – Changeset creation has failed.
        ///
        /// * SUCCESS – Changeset creation has succeeded.
        ///
        /// * RUNNING – Changeset creation is running.
        ///
        /// * STOP_REQUESTED – User requested Changeset creation to stop.
        public var status: FinspacedataClientTypes.IngestionStatus?
        /// The unique identifier of the updated Changeset.
        public var updatedByChangesetId: Swift.String?
        /// The unique identifier of the Changeset that is updated.
        public var updatesChangesetId: Swift.String?

        public init (
            activeFromTimestamp: Swift.Int? = nil,
            activeUntilTimestamp: Swift.Int? = nil,
            changeType: FinspacedataClientTypes.ChangeType? = nil,
            changesetArn: Swift.String? = nil,
            changesetId: Swift.String? = nil,
            createTime: Swift.Int = 0,
            datasetId: Swift.String? = nil,
            errorInfo: FinspacedataClientTypes.ChangesetErrorInfo? = nil,
            formatParams: [Swift.String:Swift.String]? = nil,
            sourceParams: [Swift.String:Swift.String]? = nil,
            status: FinspacedataClientTypes.IngestionStatus? = nil,
            updatedByChangesetId: Swift.String? = nil,
            updatesChangesetId: Swift.String? = nil
        )
        {
            self.activeFromTimestamp = activeFromTimestamp
            self.activeUntilTimestamp = activeUntilTimestamp
            self.changeType = changeType
            self.changesetArn = changesetArn
            self.changesetId = changesetId
            self.createTime = createTime
            self.datasetId = datasetId
            self.errorInfo = errorInfo
            self.formatParams = formatParams
            self.sourceParams = sourceParams
            self.status = status
            self.updatedByChangesetId = updatedByChangesetId
            self.updatesChangesetId = updatesChangesetId
        }
    }

}

extension FinspacedataClientTypes {
    /// Data type of a column.
    public enum ColumnDataType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case bigint
        case binary
        case boolean
        case char
        case date
        case datetime
        case double
        case float
        case integer
        case smallint
        case string
        case tinyint
        case sdkUnknown(Swift.String)

        public static var allCases: [ColumnDataType] {
            return [
                .bigint,
                .binary,
                .boolean,
                .char,
                .date,
                .datetime,
                .double,
                .float,
                .integer,
                .smallint,
                .string,
                .tinyint,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .bigint: return "BIGINT"
            case .binary: return "BINARY"
            case .boolean: return "BOOLEAN"
            case .char: return "CHAR"
            case .date: return "DATE"
            case .datetime: return "DATETIME"
            case .double: return "DOUBLE"
            case .float: return "FLOAT"
            case .integer: return "INTEGER"
            case .smallint: return "SMALLINT"
            case .string: return "STRING"
            case .tinyint: return "TINYINT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ColumnDataType(rawValue: rawValue) ?? ColumnDataType.sdkUnknown(rawValue)
        }
    }
}

extension FinspacedataClientTypes.ColumnDefinition: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case columnDescription
        case columnName
        case dataType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let columnDescription = self.columnDescription {
            try encodeContainer.encode(columnDescription, forKey: .columnDescription)
        }
        if let columnName = self.columnName {
            try encodeContainer.encode(columnName, forKey: .columnName)
        }
        if let dataType = self.dataType {
            try encodeContainer.encode(dataType.rawValue, forKey: .dataType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataTypeDecoded = try containerValues.decodeIfPresent(FinspacedataClientTypes.ColumnDataType.self, forKey: .dataType)
        dataType = dataTypeDecoded
        let columnNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .columnName)
        columnName = columnNameDecoded
        let columnDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .columnDescription)
        columnDescription = columnDescriptionDecoded
    }
}

extension FinspacedataClientTypes {
    /// The definition of a column in a tabular Dataset.
    public struct ColumnDefinition: Swift.Equatable {
        /// Description for a column.
        public var columnDescription: Swift.String?
        /// The name of a column.
        public var columnName: Swift.String?
        /// Data type of a column.
        ///
        /// * STRING – A String data type. CHAR – A char data type. INTEGER – An integer data type. TINYINT – A tinyint data type. SMALLINT – A smallint data type. BIGINT – A bigint data type. FLOAT – A float data type. DOUBLE – A double data type. DATE – A date data type. DATETIME – A datetime data type. BOOLEAN – A boolean data type. BINARY – A binary data type.
        public var dataType: FinspacedataClientTypes.ColumnDataType?

        public init (
            columnDescription: Swift.String? = nil,
            columnName: Swift.String? = nil,
            dataType: FinspacedataClientTypes.ColumnDataType? = nil
        )
        {
            self.columnDescription = columnDescription
            self.columnName = columnName
            self.dataType = dataType
        }
    }

}

extension ConflictException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.reason = output.reason
        } else {
            self.message = nil
            self.reason = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request conflicts with an existing resource.
public struct ConflictException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?
    public var reason: Swift.String?

    public init (
        message: Swift.String? = nil,
        reason: Swift.String? = nil
    )
    {
        self.message = message
        self.reason = reason
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let reason: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case reason
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reason)
        reason = reasonDecoded
    }
}

extension CreateChangesetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case changeType
        case clientToken
        case formatParams
        case sourceParams
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let changeType = self.changeType {
            try encodeContainer.encode(changeType.rawValue, forKey: .changeType)
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let formatParams = formatParams {
            var formatParamsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .formatParams)
            for (dictKey0, formatParams0) in formatParams {
                try formatParamsContainer.encode(formatParams0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let sourceParams = sourceParams {
            var sourceParamsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .sourceParams)
            for (dictKey0, sourceParams0) in sourceParams {
                try sourceParamsContainer.encode(sourceParams0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateChangesetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let datasetId = datasetId else {
            return nil
        }
        return "/datasets/\(datasetId.urlPercentEncoding())/changesetsv2"
    }
}

/// The request for a CreateChangeset operation.
public struct CreateChangesetInput: Swift.Equatable {
    /// The option to indicate how a Changeset will be applied to a Dataset.
    ///
    /// * REPLACE – Changeset will be considered as a replacement to all prior loaded Changesets.
    ///
    /// * APPEND – Changeset will be considered as an addition to the end of all prior loaded Changesets.
    ///
    /// * MODIFY – Changeset is considered as a replacement to a specific prior ingested Changeset.
    /// This member is required.
    public var changeType: FinspacedataClientTypes.ChangeType?
    /// A token that ensures idempotency. This token expires in 10 minutes.
    public var clientToken: Swift.String?
    /// The unique identifier for the FinSpace Dataset where the Changeset will be created.
    /// This member is required.
    public var datasetId: Swift.String?
    /// Options that define the structure of the source file(s) including the format type (formatType), header row (withHeader), data separation character (separator) and the type of compression (compression). formatType is a required attribute and can have the following values:
    ///
    /// * PARQUET – Parquet source file format.
    ///
    /// * CSV – CSV source file format.
    ///
    /// * JSON – JSON source file format.
    ///
    /// * XML – XML source file format.
    ///
    ///
    /// Here is an example of how you could specify the formatParams:  "formatParams": { "formatType": "CSV", "withHeader": "true", "separator": ",", "compression":"None" }  Note that if you only provide formatType as CSV, the rest of the attributes will automatically default to CSV values as following:  { "withHeader": "true", "separator": "," }  For more information about supported file formats, see [Supported Data Types and File Formats](https://docs.aws.amazon.com/finspace/latest/userguide/supported-data-types.html) in the FinSpace User Guide.
    /// This member is required.
    public var formatParams: [Swift.String:Swift.String]?
    /// Options that define the location of the data being ingested (s3SourcePath) and the source of the changeset (sourceType). Both s3SourcePath and sourceType are required attributes. Here is an example of how you could specify the sourceParams:  "sourceParams": { "s3SourcePath": "s3://finspace-landing-us-east-2-bk7gcfvitndqa6ebnvys4d/scratch/wr5hh8pwkpqqkxa4sxrmcw/ingestion/equity.csv", "sourceType": "S3" }  The S3 path that you specify must allow the FinSpace role access. To do that, you first need to configure the IAM policy on S3 bucket. For more information, see [Loading data from an Amazon S3 Bucket using the FinSpace API](https://docs.aws.amazon.com/finspace/latest/data-api/fs-using-the-finspace-api.html#access-s3-buckets) section.
    /// This member is required.
    public var sourceParams: [Swift.String:Swift.String]?

    public init (
        changeType: FinspacedataClientTypes.ChangeType? = nil,
        clientToken: Swift.String? = nil,
        datasetId: Swift.String? = nil,
        formatParams: [Swift.String:Swift.String]? = nil,
        sourceParams: [Swift.String:Swift.String]? = nil
    )
    {
        self.changeType = changeType
        self.clientToken = clientToken
        self.datasetId = datasetId
        self.formatParams = formatParams
        self.sourceParams = sourceParams
    }
}

struct CreateChangesetInputBody: Swift.Equatable {
    let clientToken: Swift.String?
    let changeType: FinspacedataClientTypes.ChangeType?
    let sourceParams: [Swift.String:Swift.String]?
    let formatParams: [Swift.String:Swift.String]?
}

extension CreateChangesetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case changeType
        case clientToken
        case formatParams
        case sourceParams
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let changeTypeDecoded = try containerValues.decodeIfPresent(FinspacedataClientTypes.ChangeType.self, forKey: .changeType)
        changeType = changeTypeDecoded
        let sourceParamsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .sourceParams)
        var sourceParamsDecoded0: [Swift.String:Swift.String]? = nil
        if let sourceParamsContainer = sourceParamsContainer {
            sourceParamsDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringmapvalue0) in sourceParamsContainer {
                if let stringmapvalue0 = stringmapvalue0 {
                    sourceParamsDecoded0?[key0] = stringmapvalue0
                }
            }
        }
        sourceParams = sourceParamsDecoded0
        let formatParamsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .formatParams)
        var formatParamsDecoded0: [Swift.String:Swift.String]? = nil
        if let formatParamsContainer = formatParamsContainer {
            formatParamsDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringmapvalue0) in formatParamsContainer {
                if let stringmapvalue0 = stringmapvalue0 {
                    formatParamsDecoded0?[key0] = stringmapvalue0
                }
            }
        }
        formatParams = formatParamsDecoded0
    }
}

extension CreateChangesetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateChangesetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateChangesetOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateChangesetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateChangesetOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.changesetId = output.changesetId
            self.datasetId = output.datasetId
        } else {
            self.changesetId = nil
            self.datasetId = nil
        }
    }
}

/// The response from a CreateChangeset operation.
public struct CreateChangesetOutputResponse: Swift.Equatable {
    /// The unique identifier of the Changeset that is created.
    public var changesetId: Swift.String?
    /// The unique identifier for the FinSpace Dataset where the Changeset is created.
    public var datasetId: Swift.String?

    public init (
        changesetId: Swift.String? = nil,
        datasetId: Swift.String? = nil
    )
    {
        self.changesetId = changesetId
        self.datasetId = datasetId
    }
}

struct CreateChangesetOutputResponseBody: Swift.Equatable {
    let datasetId: Swift.String?
    let changesetId: Swift.String?
}

extension CreateChangesetOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case changesetId
        case datasetId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetId)
        datasetId = datasetIdDecoded
        let changesetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .changesetId)
        changesetId = changesetIdDecoded
    }
}

extension CreateDataViewInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case asOfTimestamp
        case autoUpdate
        case clientToken
        case destinationTypeParams
        case partitionColumns
        case sortColumns
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let asOfTimestamp = self.asOfTimestamp {
            try encodeContainer.encode(asOfTimestamp, forKey: .asOfTimestamp)
        }
        if autoUpdate != false {
            try encodeContainer.encode(autoUpdate, forKey: .autoUpdate)
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let destinationTypeParams = self.destinationTypeParams {
            try encodeContainer.encode(destinationTypeParams, forKey: .destinationTypeParams)
        }
        if let partitionColumns = partitionColumns {
            var partitionColumnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .partitionColumns)
            for stringvaluelength1to2550 in partitionColumns {
                try partitionColumnsContainer.encode(stringvaluelength1to2550)
            }
        }
        if let sortColumns = sortColumns {
            var sortColumnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sortColumns)
            for stringvaluelength1to2550 in sortColumns {
                try sortColumnsContainer.encode(stringvaluelength1to2550)
            }
        }
    }
}

extension CreateDataViewInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let datasetId = datasetId else {
            return nil
        }
        return "/datasets/\(datasetId.urlPercentEncoding())/dataviewsv2"
    }
}

/// Request for creating a data view.
public struct CreateDataViewInput: Swift.Equatable {
    /// Beginning time to use for the Dataview. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
    public var asOfTimestamp: Swift.Int?
    /// Flag to indicate Dataview should be updated automatically.
    public var autoUpdate: Swift.Bool
    /// A token that ensures idempotency. This token expires in 10 minutes.
    public var clientToken: Swift.String?
    /// The unique Dataset identifier that is used to create a Dataview.
    /// This member is required.
    public var datasetId: Swift.String?
    /// Options that define the destination type for the Dataview.
    /// This member is required.
    public var destinationTypeParams: FinspacedataClientTypes.DataViewDestinationTypeParams?
    /// Ordered set of column names used to partition data.
    public var partitionColumns: [Swift.String]?
    /// Columns to be used for sorting the data.
    public var sortColumns: [Swift.String]?

    public init (
        asOfTimestamp: Swift.Int? = nil,
        autoUpdate: Swift.Bool = false,
        clientToken: Swift.String? = nil,
        datasetId: Swift.String? = nil,
        destinationTypeParams: FinspacedataClientTypes.DataViewDestinationTypeParams? = nil,
        partitionColumns: [Swift.String]? = nil,
        sortColumns: [Swift.String]? = nil
    )
    {
        self.asOfTimestamp = asOfTimestamp
        self.autoUpdate = autoUpdate
        self.clientToken = clientToken
        self.datasetId = datasetId
        self.destinationTypeParams = destinationTypeParams
        self.partitionColumns = partitionColumns
        self.sortColumns = sortColumns
    }
}

struct CreateDataViewInputBody: Swift.Equatable {
    let clientToken: Swift.String?
    let autoUpdate: Swift.Bool
    let sortColumns: [Swift.String]?
    let partitionColumns: [Swift.String]?
    let asOfTimestamp: Swift.Int?
    let destinationTypeParams: FinspacedataClientTypes.DataViewDestinationTypeParams?
}

extension CreateDataViewInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case asOfTimestamp
        case autoUpdate
        case clientToken
        case destinationTypeParams
        case partitionColumns
        case sortColumns
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let autoUpdateDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .autoUpdate) ?? false
        autoUpdate = autoUpdateDecoded
        let sortColumnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .sortColumns)
        var sortColumnsDecoded0:[Swift.String]? = nil
        if let sortColumnsContainer = sortColumnsContainer {
            sortColumnsDecoded0 = [Swift.String]()
            for string0 in sortColumnsContainer {
                if let string0 = string0 {
                    sortColumnsDecoded0?.append(string0)
                }
            }
        }
        sortColumns = sortColumnsDecoded0
        let partitionColumnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .partitionColumns)
        var partitionColumnsDecoded0:[Swift.String]? = nil
        if let partitionColumnsContainer = partitionColumnsContainer {
            partitionColumnsDecoded0 = [Swift.String]()
            for string0 in partitionColumnsContainer {
                if let string0 = string0 {
                    partitionColumnsDecoded0?.append(string0)
                }
            }
        }
        partitionColumns = partitionColumnsDecoded0
        let asOfTimestampDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .asOfTimestamp)
        asOfTimestamp = asOfTimestampDecoded
        let destinationTypeParamsDecoded = try containerValues.decodeIfPresent(FinspacedataClientTypes.DataViewDestinationTypeParams.self, forKey: .destinationTypeParams)
        destinationTypeParams = destinationTypeParamsDecoded
    }
}

extension CreateDataViewOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateDataViewOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateDataViewOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDataViewOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateDataViewOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dataViewId = output.dataViewId
            self.datasetId = output.datasetId
        } else {
            self.dataViewId = nil
            self.datasetId = nil
        }
    }
}

/// Response for creating a data view.
public struct CreateDataViewOutputResponse: Swift.Equatable {
    /// The unique identifier for the created Dataview.
    public var dataViewId: Swift.String?
    /// The unique identifier of the Dataset used for the Dataview.
    public var datasetId: Swift.String?

    public init (
        dataViewId: Swift.String? = nil,
        datasetId: Swift.String? = nil
    )
    {
        self.dataViewId = dataViewId
        self.datasetId = datasetId
    }
}

struct CreateDataViewOutputResponseBody: Swift.Equatable {
    let datasetId: Swift.String?
    let dataViewId: Swift.String?
}

extension CreateDataViewOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataViewId
        case datasetId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetId)
        datasetId = datasetIdDecoded
        let dataViewIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataViewId)
        dataViewId = dataViewIdDecoded
    }
}

extension CreateDatasetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alias
        case clientToken
        case datasetDescription
        case datasetTitle
        case kind
        case ownerInfo
        case permissionGroupParams
        case schemaDefinition
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let alias = self.alias {
            try encodeContainer.encode(alias, forKey: .alias)
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let datasetDescription = self.datasetDescription {
            try encodeContainer.encode(datasetDescription, forKey: .datasetDescription)
        }
        if let datasetTitle = self.datasetTitle {
            try encodeContainer.encode(datasetTitle, forKey: .datasetTitle)
        }
        if let kind = self.kind {
            try encodeContainer.encode(kind.rawValue, forKey: .kind)
        }
        if let ownerInfo = self.ownerInfo {
            try encodeContainer.encode(ownerInfo, forKey: .ownerInfo)
        }
        if let permissionGroupParams = self.permissionGroupParams {
            try encodeContainer.encode(permissionGroupParams, forKey: .permissionGroupParams)
        }
        if let schemaDefinition = self.schemaDefinition {
            try encodeContainer.encode(schemaDefinition, forKey: .schemaDefinition)
        }
    }
}

extension CreateDatasetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/datasetsv2"
    }
}

/// The request for a CreateDataset operation
public struct CreateDatasetInput: Swift.Equatable {
    /// The unique resource identifier for a Dataset.
    public var alias: Swift.String?
    /// A token that ensures idempotency. This token expires in 10 minutes.
    public var clientToken: Swift.String?
    /// Description of a Dataset.
    public var datasetDescription: Swift.String?
    /// Display title for a FinSpace Dataset.
    /// This member is required.
    public var datasetTitle: Swift.String?
    /// The format in which Dataset data is structured.
    ///
    /// * TABULAR – Data is structured in a tabular format.
    ///
    /// * NON_TABULAR – Data is structured in a non-tabular format.
    /// This member is required.
    public var kind: FinspacedataClientTypes.DatasetKind?
    /// Contact information for a Dataset owner.
    public var ownerInfo: FinspacedataClientTypes.DatasetOwnerInfo?
    /// Permission group parameters for Dataset permissions.
    /// This member is required.
    public var permissionGroupParams: FinspacedataClientTypes.PermissionGroupParams?
    /// Definition for a schema on a tabular Dataset.
    public var schemaDefinition: FinspacedataClientTypes.SchemaUnion?

    public init (
        alias: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        datasetDescription: Swift.String? = nil,
        datasetTitle: Swift.String? = nil,
        kind: FinspacedataClientTypes.DatasetKind? = nil,
        ownerInfo: FinspacedataClientTypes.DatasetOwnerInfo? = nil,
        permissionGroupParams: FinspacedataClientTypes.PermissionGroupParams? = nil,
        schemaDefinition: FinspacedataClientTypes.SchemaUnion? = nil
    )
    {
        self.alias = alias
        self.clientToken = clientToken
        self.datasetDescription = datasetDescription
        self.datasetTitle = datasetTitle
        self.kind = kind
        self.ownerInfo = ownerInfo
        self.permissionGroupParams = permissionGroupParams
        self.schemaDefinition = schemaDefinition
    }
}

struct CreateDatasetInputBody: Swift.Equatable {
    let clientToken: Swift.String?
    let datasetTitle: Swift.String?
    let kind: FinspacedataClientTypes.DatasetKind?
    let datasetDescription: Swift.String?
    let ownerInfo: FinspacedataClientTypes.DatasetOwnerInfo?
    let permissionGroupParams: FinspacedataClientTypes.PermissionGroupParams?
    let alias: Swift.String?
    let schemaDefinition: FinspacedataClientTypes.SchemaUnion?
}

extension CreateDatasetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alias
        case clientToken
        case datasetDescription
        case datasetTitle
        case kind
        case ownerInfo
        case permissionGroupParams
        case schemaDefinition
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let datasetTitleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetTitle)
        datasetTitle = datasetTitleDecoded
        let kindDecoded = try containerValues.decodeIfPresent(FinspacedataClientTypes.DatasetKind.self, forKey: .kind)
        kind = kindDecoded
        let datasetDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetDescription)
        datasetDescription = datasetDescriptionDecoded
        let ownerInfoDecoded = try containerValues.decodeIfPresent(FinspacedataClientTypes.DatasetOwnerInfo.self, forKey: .ownerInfo)
        ownerInfo = ownerInfoDecoded
        let permissionGroupParamsDecoded = try containerValues.decodeIfPresent(FinspacedataClientTypes.PermissionGroupParams.self, forKey: .permissionGroupParams)
        permissionGroupParams = permissionGroupParamsDecoded
        let aliasDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .alias)
        alias = aliasDecoded
        let schemaDefinitionDecoded = try containerValues.decodeIfPresent(FinspacedataClientTypes.SchemaUnion.self, forKey: .schemaDefinition)
        schemaDefinition = schemaDefinitionDecoded
    }
}

extension CreateDatasetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateDatasetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateDatasetOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDatasetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateDatasetOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.datasetId = output.datasetId
        } else {
            self.datasetId = nil
        }
    }
}

/// The response from a CreateDataset operation
public struct CreateDatasetOutputResponse: Swift.Equatable {
    /// The unique identifier for the created Dataset.
    public var datasetId: Swift.String?

    public init (
        datasetId: Swift.String? = nil
    )
    {
        self.datasetId = datasetId
    }
}

struct CreateDatasetOutputResponseBody: Swift.Equatable {
    let datasetId: Swift.String?
}

extension CreateDatasetOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetId)
        datasetId = datasetIdDecoded
    }
}

extension CreatePermissionGroupInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreatePermissionGroupInput(applicationPermissions: \(Swift.String(describing: applicationPermissions)), clientToken: \(Swift.String(describing: clientToken)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension CreatePermissionGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationPermissions
        case clientToken
        case description
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationPermissions = applicationPermissions {
            var applicationPermissionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .applicationPermissions)
            for applicationpermission0 in applicationPermissions {
                try applicationPermissionsContainer.encode(applicationpermission0.rawValue)
            }
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension CreatePermissionGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/permission-group"
    }
}

public struct CreatePermissionGroupInput: Swift.Equatable {
    /// The option to indicate FinSpace application permissions that are granted to a specific group. When assigning application permissions, be aware that the permission ManageUsersAndGroups allows users to grant themselves or others access to any functionality in their FinSpace environment's application. It should only be granted to trusted users.
    ///
    /// * CreateDataset – Group members can create new datasets.
    ///
    /// * ManageClusters – Group members can manage Apache Spark clusters from FinSpace notebooks.
    ///
    /// * ManageUsersAndGroups – Group members can manage users and permission groups. This is a privileged permission that allows users to grant themselves or others access to any functionality in the application. It should only be granted to trusted users.
    ///
    /// * ManageAttributeSets – Group members can manage attribute sets.
    ///
    /// * ViewAuditData – Group members can view audit data.
    ///
    /// * AccessNotebooks – Group members will have access to FinSpace notebooks.
    ///
    /// * GetTemporaryCredentials – Group members can get temporary API credentials.
    /// This member is required.
    public var applicationPermissions: [FinspacedataClientTypes.ApplicationPermission]?
    /// A token that ensures idempotency. This token expires in 10 minutes.
    public var clientToken: Swift.String?
    /// A brief description for the permission group.
    public var description: Swift.String?
    /// The name of the permission group.
    /// This member is required.
    public var name: Swift.String?

    public init (
        applicationPermissions: [FinspacedataClientTypes.ApplicationPermission]? = nil,
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.applicationPermissions = applicationPermissions
        self.clientToken = clientToken
        self.description = description
        self.name = name
    }
}

struct CreatePermissionGroupInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let applicationPermissions: [FinspacedataClientTypes.ApplicationPermission]?
    let clientToken: Swift.String?
}

extension CreatePermissionGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationPermissions
        case clientToken
        case description
        case name
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let applicationPermissionsContainer = try containerValues.decodeIfPresent([FinspacedataClientTypes.ApplicationPermission?].self, forKey: .applicationPermissions)
        var applicationPermissionsDecoded0:[FinspacedataClientTypes.ApplicationPermission]? = nil
        if let applicationPermissionsContainer = applicationPermissionsContainer {
            applicationPermissionsDecoded0 = [FinspacedataClientTypes.ApplicationPermission]()
            for string0 in applicationPermissionsContainer {
                if let string0 = string0 {
                    applicationPermissionsDecoded0?.append(string0)
                }
            }
        }
        applicationPermissions = applicationPermissionsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CreatePermissionGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreatePermissionGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreatePermissionGroupOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case limitExceededException(LimitExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreatePermissionGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreatePermissionGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.permissionGroupId = output.permissionGroupId
        } else {
            self.permissionGroupId = nil
        }
    }
}

public struct CreatePermissionGroupOutputResponse: Swift.Equatable {
    /// The unique identifier for the permission group.
    public var permissionGroupId: Swift.String?

    public init (
        permissionGroupId: Swift.String? = nil
    )
    {
        self.permissionGroupId = permissionGroupId
    }
}

struct CreatePermissionGroupOutputResponseBody: Swift.Equatable {
    let permissionGroupId: Swift.String?
}

extension CreatePermissionGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case permissionGroupId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let permissionGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .permissionGroupId)
        permissionGroupId = permissionGroupIdDecoded
    }
}

extension CreateUserInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateUserInput(apiAccess: \(Swift.String(describing: apiAccess)), apiAccessPrincipalArn: \(Swift.String(describing: apiAccessPrincipalArn)), clientToken: \(Swift.String(describing: clientToken)), type: \(Swift.String(describing: type)), emailAddress: \"CONTENT_REDACTED\", firstName: \"CONTENT_REDACTED\", lastName: \"CONTENT_REDACTED\")"}
}

extension CreateUserInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiAccess = "ApiAccess"
        case apiAccessPrincipalArn
        case clientToken
        case emailAddress
        case firstName
        case lastName
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let apiAccess = self.apiAccess {
            try encodeContainer.encode(apiAccess.rawValue, forKey: .apiAccess)
        }
        if let apiAccessPrincipalArn = self.apiAccessPrincipalArn {
            try encodeContainer.encode(apiAccessPrincipalArn, forKey: .apiAccessPrincipalArn)
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let emailAddress = self.emailAddress {
            try encodeContainer.encode(emailAddress, forKey: .emailAddress)
        }
        if let firstName = self.firstName {
            try encodeContainer.encode(firstName, forKey: .firstName)
        }
        if let lastName = self.lastName {
            try encodeContainer.encode(lastName, forKey: .lastName)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

extension CreateUserInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/user"
    }
}

public struct CreateUserInput: Swift.Equatable {
    /// The option to indicate whether the user can use the GetProgrammaticAccessCredentials API to obtain credentials that can then be used to access other FinSpace Data API operations.
    ///
    /// * ENABLED – The user has permissions to use the APIs.
    ///
    /// * DISABLED – The user does not have permissions to use any APIs.
    public var apiAccess: FinspacedataClientTypes.ApiAccess?
    /// The ARN identifier of an AWS user or role that is allowed to call the GetProgrammaticAccessCredentials API to obtain a credentials token for a specific FinSpace user. This must be an IAM role within your FinSpace account.
    public var apiAccessPrincipalArn: Swift.String?
    /// A token that ensures idempotency. This token expires in 10 minutes.
    public var clientToken: Swift.String?
    /// The email address of the user that you want to register. The email address serves as a uniquer identifier for each user and cannot be changed after it's created.
    /// This member is required.
    public var emailAddress: Swift.String?
    /// The first name of the user that you want to register.
    public var firstName: Swift.String?
    /// The last name of the user that you want to register.
    public var lastName: Swift.String?
    /// The option to indicate the type of user. Use one of the following options to specify this parameter:
    ///
    /// * SUPER_USER – A user with permission to all the functionality and data in FinSpace.
    ///
    /// * APP_USER – A user with specific permissions in FinSpace. The users are assigned permissions by adding them to a permission group.
    /// This member is required.
    public var type: FinspacedataClientTypes.UserType?

    public init (
        apiAccess: FinspacedataClientTypes.ApiAccess? = nil,
        apiAccessPrincipalArn: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        emailAddress: Swift.String? = nil,
        firstName: Swift.String? = nil,
        lastName: Swift.String? = nil,
        type: FinspacedataClientTypes.UserType? = nil
    )
    {
        self.apiAccess = apiAccess
        self.apiAccessPrincipalArn = apiAccessPrincipalArn
        self.clientToken = clientToken
        self.emailAddress = emailAddress
        self.firstName = firstName
        self.lastName = lastName
        self.type = type
    }
}

struct CreateUserInputBody: Swift.Equatable {
    let emailAddress: Swift.String?
    let type: FinspacedataClientTypes.UserType?
    let firstName: Swift.String?
    let lastName: Swift.String?
    let apiAccess: FinspacedataClientTypes.ApiAccess?
    let apiAccessPrincipalArn: Swift.String?
    let clientToken: Swift.String?
}

extension CreateUserInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiAccess = "ApiAccess"
        case apiAccessPrincipalArn
        case clientToken
        case emailAddress
        case firstName
        case lastName
        case type
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let emailAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .emailAddress)
        emailAddress = emailAddressDecoded
        let typeDecoded = try containerValues.decodeIfPresent(FinspacedataClientTypes.UserType.self, forKey: .type)
        type = typeDecoded
        let firstNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .firstName)
        firstName = firstNameDecoded
        let lastNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastName)
        lastName = lastNameDecoded
        let apiAccessDecoded = try containerValues.decodeIfPresent(FinspacedataClientTypes.ApiAccess.self, forKey: .apiAccess)
        apiAccess = apiAccessDecoded
        let apiAccessPrincipalArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiAccessPrincipalArn)
        apiAccessPrincipalArn = apiAccessPrincipalArnDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CreateUserOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateUserOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateUserOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case limitExceededException(LimitExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateUserOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateUserOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.userId = output.userId
        } else {
            self.userId = nil
        }
    }
}

public struct CreateUserOutputResponse: Swift.Equatable {
    /// The unique identifier for the user.
    public var userId: Swift.String?

    public init (
        userId: Swift.String? = nil
    )
    {
        self.userId = userId
    }
}

struct CreateUserOutputResponseBody: Swift.Equatable {
    let userId: Swift.String?
}

extension CreateUserOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case userId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userId)
        userId = userIdDecoded
    }
}

extension FinspacedataClientTypes.Credentials: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessKeyId
        case secretAccessKey
        case sessionToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessKeyId = self.accessKeyId {
            try encodeContainer.encode(accessKeyId, forKey: .accessKeyId)
        }
        if let secretAccessKey = self.secretAccessKey {
            try encodeContainer.encode(secretAccessKey, forKey: .secretAccessKey)
        }
        if let sessionToken = self.sessionToken {
            try encodeContainer.encode(sessionToken, forKey: .sessionToken)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accessKeyId)
        accessKeyId = accessKeyIdDecoded
        let secretAccessKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretAccessKey)
        secretAccessKey = secretAccessKeyDecoded
        let sessionTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sessionToken)
        sessionToken = sessionTokenDecoded
    }
}

extension FinspacedataClientTypes {
    /// Short term API credentials.
    public struct Credentials: Swift.Equatable {
        /// The access key identifier.
        public var accessKeyId: Swift.String?
        /// The access key.
        public var secretAccessKey: Swift.String?
        /// The session token.
        public var sessionToken: Swift.String?

        public init (
            accessKeyId: Swift.String? = nil,
            secretAccessKey: Swift.String? = nil,
            sessionToken: Swift.String? = nil
        )
        {
            self.accessKeyId = accessKeyId
            self.secretAccessKey = secretAccessKey
            self.sessionToken = sessionToken
        }
    }

}

extension FinspacedataClientTypes.DataViewDestinationTypeParams: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationType
        case s3DestinationExportFileFormat
        case s3DestinationExportFileFormatOptions
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destinationType = self.destinationType {
            try encodeContainer.encode(destinationType, forKey: .destinationType)
        }
        if let s3DestinationExportFileFormat = self.s3DestinationExportFileFormat {
            try encodeContainer.encode(s3DestinationExportFileFormat.rawValue, forKey: .s3DestinationExportFileFormat)
        }
        if let s3DestinationExportFileFormatOptions = s3DestinationExportFileFormatOptions {
            var s3DestinationExportFileFormatOptionsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .s3DestinationExportFileFormatOptions)
            for (dictKey0, s3DestinationFormatOptions0) in s3DestinationExportFileFormatOptions {
                try s3DestinationExportFileFormatOptionsContainer.encode(s3DestinationFormatOptions0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let destinationTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationType)
        destinationType = destinationTypeDecoded
        let s3DestinationExportFileFormatDecoded = try containerValues.decodeIfPresent(FinspacedataClientTypes.ExportFileFormat.self, forKey: .s3DestinationExportFileFormat)
        s3DestinationExportFileFormat = s3DestinationExportFileFormatDecoded
        let s3DestinationExportFileFormatOptionsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .s3DestinationExportFileFormatOptions)
        var s3DestinationExportFileFormatOptionsDecoded0: [Swift.String:Swift.String]? = nil
        if let s3DestinationExportFileFormatOptionsContainer = s3DestinationExportFileFormatOptionsContainer {
            s3DestinationExportFileFormatOptionsDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringmapvalue0) in s3DestinationExportFileFormatOptionsContainer {
                if let stringmapvalue0 = stringmapvalue0 {
                    s3DestinationExportFileFormatOptionsDecoded0?[key0] = stringmapvalue0
                }
            }
        }
        s3DestinationExportFileFormatOptions = s3DestinationExportFileFormatOptionsDecoded0
    }
}

extension FinspacedataClientTypes {
    /// Structure for the Dataview destination type parameters.
    public struct DataViewDestinationTypeParams: Swift.Equatable {
        /// Destination type for a Dataview.
        ///
        /// * GLUE_TABLE – Glue table destination type.
        ///
        /// * S3 – S3 destination type.
        /// This member is required.
        public var destinationType: Swift.String?
        /// Dataview export file format.
        ///
        /// * PARQUET – Parquet export file format.
        ///
        /// * DELIMITED_TEXT – Delimited text export file format.
        public var s3DestinationExportFileFormat: FinspacedataClientTypes.ExportFileFormat?
        /// Format Options for S3 Destination type. Here is an example of how you could specify the s3DestinationExportFileFormatOptions
        ///     { "header": "true", "delimiter": ",", "compression": "gzip" }
        public var s3DestinationExportFileFormatOptions: [Swift.String:Swift.String]?

        public init (
            destinationType: Swift.String? = nil,
            s3DestinationExportFileFormat: FinspacedataClientTypes.ExportFileFormat? = nil,
            s3DestinationExportFileFormatOptions: [Swift.String:Swift.String]? = nil
        )
        {
            self.destinationType = destinationType
            self.s3DestinationExportFileFormat = s3DestinationExportFileFormat
            self.s3DestinationExportFileFormatOptions = s3DestinationExportFileFormatOptions
        }
    }

}

extension FinspacedataClientTypes.DataViewErrorInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCategory
        case errorMessage
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCategory = self.errorCategory {
            try encodeContainer.encode(errorCategory.rawValue, forKey: .errorCategory)
        }
        if let errorMessage = self.errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
        let errorCategoryDecoded = try containerValues.decodeIfPresent(FinspacedataClientTypes.ErrorCategory.self, forKey: .errorCategory)
        errorCategory = errorCategoryDecoded
    }
}

extension FinspacedataClientTypes {
    /// The structure with error messages.
    public struct DataViewErrorInfo: Swift.Equatable {
        /// The category of the error.
        ///
        /// * VALIDATION – The inputs to this request are invalid.
        ///
        /// * SERVICE_QUOTA_EXCEEDED – Service quotas have been exceeded. Please contact AWS support to increase quotas.
        ///
        /// * ACCESS_DENIED – Missing required permission to perform this request.
        ///
        /// * RESOURCE_NOT_FOUND – One or more inputs to this request were not found.
        ///
        /// * THROTTLING – The system temporarily lacks sufficient resources to process the request.
        ///
        /// * INTERNAL_SERVICE_EXCEPTION – An internal service error has occurred.
        ///
        /// * CANCELLED – Cancelled.
        ///
        /// * USER_RECOVERABLE – A user recoverable error has occurred.
        public var errorCategory: FinspacedataClientTypes.ErrorCategory?
        /// The text of the error message.
        public var errorMessage: Swift.String?

        public init (
            errorCategory: FinspacedataClientTypes.ErrorCategory? = nil,
            errorMessage: Swift.String? = nil
        )
        {
            self.errorCategory = errorCategory
            self.errorMessage = errorMessage
        }
    }

}

extension FinspacedataClientTypes {
    /// Status of a DataView
    public enum DataViewStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cancelled
        case failed
        case failedCleanupFailed
        case pending
        case running
        case starting
        case success
        case timeout
        case sdkUnknown(Swift.String)

        public static var allCases: [DataViewStatus] {
            return [
                .cancelled,
                .failed,
                .failedCleanupFailed,
                .pending,
                .running,
                .starting,
                .success,
                .timeout,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cancelled: return "CANCELLED"
            case .failed: return "FAILED"
            case .failedCleanupFailed: return "FAILED_CLEANUP_FAILED"
            case .pending: return "PENDING"
            case .running: return "RUNNING"
            case .starting: return "STARTING"
            case .success: return "SUCCESS"
            case .timeout: return "TIMEOUT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DataViewStatus(rawValue: rawValue) ?? DataViewStatus.sdkUnknown(rawValue)
        }
    }
}

extension FinspacedataClientTypes.DataViewSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case asOfTimestamp
        case autoUpdate
        case createTime
        case dataViewArn
        case dataViewId
        case datasetId
        case destinationTypeProperties
        case errorInfo
        case lastModifiedTime
        case partitionColumns
        case sortColumns
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let asOfTimestamp = self.asOfTimestamp {
            try encodeContainer.encode(asOfTimestamp, forKey: .asOfTimestamp)
        }
        if autoUpdate != false {
            try encodeContainer.encode(autoUpdate, forKey: .autoUpdate)
        }
        if createTime != 0 {
            try encodeContainer.encode(createTime, forKey: .createTime)
        }
        if let dataViewArn = self.dataViewArn {
            try encodeContainer.encode(dataViewArn, forKey: .dataViewArn)
        }
        if let dataViewId = self.dataViewId {
            try encodeContainer.encode(dataViewId, forKey: .dataViewId)
        }
        if let datasetId = self.datasetId {
            try encodeContainer.encode(datasetId, forKey: .datasetId)
        }
        if let destinationTypeProperties = self.destinationTypeProperties {
            try encodeContainer.encode(destinationTypeProperties, forKey: .destinationTypeProperties)
        }
        if let errorInfo = self.errorInfo {
            try encodeContainer.encode(errorInfo, forKey: .errorInfo)
        }
        if lastModifiedTime != 0 {
            try encodeContainer.encode(lastModifiedTime, forKey: .lastModifiedTime)
        }
        if let partitionColumns = partitionColumns {
            var partitionColumnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .partitionColumns)
            for stringvaluelength1to2550 in partitionColumns {
                try partitionColumnsContainer.encode(stringvaluelength1to2550)
            }
        }
        if let sortColumns = sortColumns {
            var sortColumnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sortColumns)
            for stringvaluelength1to2550 in sortColumns {
                try sortColumnsContainer.encode(stringvaluelength1to2550)
            }
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataViewIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataViewId)
        dataViewId = dataViewIdDecoded
        let dataViewArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataViewArn)
        dataViewArn = dataViewArnDecoded
        let datasetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetId)
        datasetId = datasetIdDecoded
        let asOfTimestampDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .asOfTimestamp)
        asOfTimestamp = asOfTimestampDecoded
        let partitionColumnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .partitionColumns)
        var partitionColumnsDecoded0:[Swift.String]? = nil
        if let partitionColumnsContainer = partitionColumnsContainer {
            partitionColumnsDecoded0 = [Swift.String]()
            for string0 in partitionColumnsContainer {
                if let string0 = string0 {
                    partitionColumnsDecoded0?.append(string0)
                }
            }
        }
        partitionColumns = partitionColumnsDecoded0
        let sortColumnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .sortColumns)
        var sortColumnsDecoded0:[Swift.String]? = nil
        if let sortColumnsContainer = sortColumnsContainer {
            sortColumnsDecoded0 = [Swift.String]()
            for string0 in sortColumnsContainer {
                if let string0 = string0 {
                    sortColumnsDecoded0?.append(string0)
                }
            }
        }
        sortColumns = sortColumnsDecoded0
        let statusDecoded = try containerValues.decodeIfPresent(FinspacedataClientTypes.DataViewStatus.self, forKey: .status)
        status = statusDecoded
        let errorInfoDecoded = try containerValues.decodeIfPresent(FinspacedataClientTypes.DataViewErrorInfo.self, forKey: .errorInfo)
        errorInfo = errorInfoDecoded
        let destinationTypePropertiesDecoded = try containerValues.decodeIfPresent(FinspacedataClientTypes.DataViewDestinationTypeParams.self, forKey: .destinationTypeProperties)
        destinationTypeProperties = destinationTypePropertiesDecoded
        let autoUpdateDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .autoUpdate) ?? false
        autoUpdate = autoUpdateDecoded
        let createTimeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .createTime) ?? 0
        createTime = createTimeDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .lastModifiedTime) ?? 0
        lastModifiedTime = lastModifiedTimeDecoded
    }
}

extension FinspacedataClientTypes {
    /// Structure for the summary of a Dataview.
    public struct DataViewSummary: Swift.Equatable {
        /// Time range to use for the Dataview. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
        public var asOfTimestamp: Swift.Int?
        /// The flag to indicate Dataview should be updated automatically.
        public var autoUpdate: Swift.Bool
        /// The timestamp at which the Dataview was created in FinSpace. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
        public var createTime: Swift.Int
        /// The ARN identifier of the Dataview.
        public var dataViewArn: Swift.String?
        /// The unique identifier for the Dataview.
        public var dataViewId: Swift.String?
        /// Th unique identifier for the Dataview Dataset.
        public var datasetId: Swift.String?
        /// Information about the Dataview destination.
        public var destinationTypeProperties: FinspacedataClientTypes.DataViewDestinationTypeParams?
        /// The structure with error messages.
        public var errorInfo: FinspacedataClientTypes.DataViewErrorInfo?
        /// The last time that a Dataview was modified. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
        public var lastModifiedTime: Swift.Int
        /// Ordered set of column names used to partition data.
        public var partitionColumns: [Swift.String]?
        /// Columns to be used for sorting the data.
        public var sortColumns: [Swift.String]?
        /// The status of a Dataview creation.
        ///
        /// * RUNNING – Dataview creation is running.
        ///
        /// * STARTING – Dataview creation is starting.
        ///
        /// * FAILED – Dataview creation has failed.
        ///
        /// * CANCELLED – Dataview creation has been cancelled.
        ///
        /// * TIMEOUT – Dataview creation has timed out.
        ///
        /// * SUCCESS – Dataview creation has succeeded.
        ///
        /// * PENDING – Dataview creation is pending.
        ///
        /// * FAILED_CLEANUP_FAILED – Dataview creation failed and resource cleanup failed.
        public var status: FinspacedataClientTypes.DataViewStatus?

        public init (
            asOfTimestamp: Swift.Int? = nil,
            autoUpdate: Swift.Bool = false,
            createTime: Swift.Int = 0,
            dataViewArn: Swift.String? = nil,
            dataViewId: Swift.String? = nil,
            datasetId: Swift.String? = nil,
            destinationTypeProperties: FinspacedataClientTypes.DataViewDestinationTypeParams? = nil,
            errorInfo: FinspacedataClientTypes.DataViewErrorInfo? = nil,
            lastModifiedTime: Swift.Int = 0,
            partitionColumns: [Swift.String]? = nil,
            sortColumns: [Swift.String]? = nil,
            status: FinspacedataClientTypes.DataViewStatus? = nil
        )
        {
            self.asOfTimestamp = asOfTimestamp
            self.autoUpdate = autoUpdate
            self.createTime = createTime
            self.dataViewArn = dataViewArn
            self.dataViewId = dataViewId
            self.datasetId = datasetId
            self.destinationTypeProperties = destinationTypeProperties
            self.errorInfo = errorInfo
            self.lastModifiedTime = lastModifiedTime
            self.partitionColumns = partitionColumns
            self.sortColumns = sortColumns
            self.status = status
        }
    }

}

extension FinspacedataClientTypes.Dataset: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alias
        case createTime
        case datasetArn
        case datasetDescription
        case datasetId
        case datasetTitle
        case kind
        case lastModifiedTime
        case ownerInfo
        case schemaDefinition
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let alias = self.alias {
            try encodeContainer.encode(alias, forKey: .alias)
        }
        if createTime != 0 {
            try encodeContainer.encode(createTime, forKey: .createTime)
        }
        if let datasetArn = self.datasetArn {
            try encodeContainer.encode(datasetArn, forKey: .datasetArn)
        }
        if let datasetDescription = self.datasetDescription {
            try encodeContainer.encode(datasetDescription, forKey: .datasetDescription)
        }
        if let datasetId = self.datasetId {
            try encodeContainer.encode(datasetId, forKey: .datasetId)
        }
        if let datasetTitle = self.datasetTitle {
            try encodeContainer.encode(datasetTitle, forKey: .datasetTitle)
        }
        if let kind = self.kind {
            try encodeContainer.encode(kind.rawValue, forKey: .kind)
        }
        if lastModifiedTime != 0 {
            try encodeContainer.encode(lastModifiedTime, forKey: .lastModifiedTime)
        }
        if let ownerInfo = self.ownerInfo {
            try encodeContainer.encode(ownerInfo, forKey: .ownerInfo)
        }
        if let schemaDefinition = self.schemaDefinition {
            try encodeContainer.encode(schemaDefinition, forKey: .schemaDefinition)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetId)
        datasetId = datasetIdDecoded
        let datasetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetArn)
        datasetArn = datasetArnDecoded
        let datasetTitleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetTitle)
        datasetTitle = datasetTitleDecoded
        let kindDecoded = try containerValues.decodeIfPresent(FinspacedataClientTypes.DatasetKind.self, forKey: .kind)
        kind = kindDecoded
        let datasetDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetDescription)
        datasetDescription = datasetDescriptionDecoded
        let ownerInfoDecoded = try containerValues.decodeIfPresent(FinspacedataClientTypes.DatasetOwnerInfo.self, forKey: .ownerInfo)
        ownerInfo = ownerInfoDecoded
        let createTimeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .createTime) ?? 0
        createTime = createTimeDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .lastModifiedTime) ?? 0
        lastModifiedTime = lastModifiedTimeDecoded
        let schemaDefinitionDecoded = try containerValues.decodeIfPresent(FinspacedataClientTypes.SchemaUnion.self, forKey: .schemaDefinition)
        schemaDefinition = schemaDefinitionDecoded
        let aliasDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .alias)
        alias = aliasDecoded
    }
}

extension FinspacedataClientTypes {
    /// The structure for a Dataset.
    public struct Dataset: Swift.Equatable {
        /// The unique resource identifier for a Dataset.
        public var alias: Swift.String?
        /// The timestamp at which the Dataset was created in FinSpace. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
        public var createTime: Swift.Int
        /// The ARN identifier of the Dataset.
        public var datasetArn: Swift.String?
        /// Description for a Dataset.
        public var datasetDescription: Swift.String?
        /// An identifier for a Dataset.
        public var datasetId: Swift.String?
        /// Display title for a Dataset.
        public var datasetTitle: Swift.String?
        /// The format in which Dataset data is structured.
        ///
        /// * TABULAR – Data is structured in a tabular format.
        ///
        /// * NON_TABULAR – Data is structured in a non-tabular format.
        public var kind: FinspacedataClientTypes.DatasetKind?
        /// The last time that the Dataset was modified. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
        public var lastModifiedTime: Swift.Int
        /// Contact information for a Dataset owner.
        public var ownerInfo: FinspacedataClientTypes.DatasetOwnerInfo?
        /// Definition for a schema on a tabular Dataset.
        public var schemaDefinition: FinspacedataClientTypes.SchemaUnion?

        public init (
            alias: Swift.String? = nil,
            createTime: Swift.Int = 0,
            datasetArn: Swift.String? = nil,
            datasetDescription: Swift.String? = nil,
            datasetId: Swift.String? = nil,
            datasetTitle: Swift.String? = nil,
            kind: FinspacedataClientTypes.DatasetKind? = nil,
            lastModifiedTime: Swift.Int = 0,
            ownerInfo: FinspacedataClientTypes.DatasetOwnerInfo? = nil,
            schemaDefinition: FinspacedataClientTypes.SchemaUnion? = nil
        )
        {
            self.alias = alias
            self.createTime = createTime
            self.datasetArn = datasetArn
            self.datasetDescription = datasetDescription
            self.datasetId = datasetId
            self.datasetTitle = datasetTitle
            self.kind = kind
            self.lastModifiedTime = lastModifiedTime
            self.ownerInfo = ownerInfo
            self.schemaDefinition = schemaDefinition
        }
    }

}

extension FinspacedataClientTypes {
    /// Dataset Kind
    public enum DatasetKind: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case nonTabular
        case tabular
        case sdkUnknown(Swift.String)

        public static var allCases: [DatasetKind] {
            return [
                .nonTabular,
                .tabular,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .nonTabular: return "NON_TABULAR"
            case .tabular: return "TABULAR"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DatasetKind(rawValue: rawValue) ?? DatasetKind.sdkUnknown(rawValue)
        }
    }
}

extension FinspacedataClientTypes.DatasetOwnerInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case email
        case name
        case phoneNumber
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let email = self.email {
            try encodeContainer.encode(email, forKey: .email)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let phoneNumber = self.phoneNumber {
            try encodeContainer.encode(phoneNumber, forKey: .phoneNumber)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let phoneNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .phoneNumber)
        phoneNumber = phoneNumberDecoded
        let emailDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .email)
        email = emailDecoded
    }
}

extension FinspacedataClientTypes.DatasetOwnerInfo: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DatasetOwnerInfo(name: \(Swift.String(describing: name)), phoneNumber: \(Swift.String(describing: phoneNumber)), email: \"CONTENT_REDACTED\")"}
}

extension FinspacedataClientTypes {
    /// A structure for Dataset owner info.
    public struct DatasetOwnerInfo: Swift.Equatable {
        /// Email address for the Dataset owner.
        public var email: Swift.String?
        /// The name of the Dataset owner.
        public var name: Swift.String?
        /// Phone number for the Dataset owner.
        public var phoneNumber: Swift.String?

        public init (
            email: Swift.String? = nil,
            name: Swift.String? = nil,
            phoneNumber: Swift.String? = nil
        )
        {
            self.email = email
            self.name = name
            self.phoneNumber = phoneNumber
        }
    }

}

extension FinspacedataClientTypes {
    /// Status of the dataset process returned from scheduler service.
    public enum DatasetStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failed
        case pending
        case running
        case success
        case sdkUnknown(Swift.String)

        public static var allCases: [DatasetStatus] {
            return [
                .failed,
                .pending,
                .running,
                .success,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .pending: return "PENDING"
            case .running: return "RUNNING"
            case .success: return "SUCCESS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DatasetStatus(rawValue: rawValue) ?? DatasetStatus.sdkUnknown(rawValue)
        }
    }
}

extension DeleteDatasetInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let clientToken = clientToken {
                let clientTokenQueryItem = ClientRuntime.URLQueryItem(name: "clientToken".urlPercentEncoding(), value: Swift.String(clientToken).urlPercentEncoding())
                items.append(clientTokenQueryItem)
            }
            return items
        }
    }
}

extension DeleteDatasetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let datasetId = datasetId else {
            return nil
        }
        return "/datasetsv2/\(datasetId.urlPercentEncoding())"
    }
}

/// The request for a DeleteDataset operation.
public struct DeleteDatasetInput: Swift.Equatable {
    /// A token that ensures idempotency. This token expires in 10 minutes.
    public var clientToken: Swift.String?
    /// The unique identifier of the Dataset to be deleted.
    /// This member is required.
    public var datasetId: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        datasetId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.datasetId = datasetId
    }
}

struct DeleteDatasetInputBody: Swift.Equatable {
}

extension DeleteDatasetInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteDatasetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteDatasetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteDatasetOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDatasetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DeleteDatasetOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.datasetId = output.datasetId
        } else {
            self.datasetId = nil
        }
    }
}

/// The response from an DeleteDataset operation
public struct DeleteDatasetOutputResponse: Swift.Equatable {
    /// The unique identifier for the deleted Dataset.
    public var datasetId: Swift.String?

    public init (
        datasetId: Swift.String? = nil
    )
    {
        self.datasetId = datasetId
    }
}

struct DeleteDatasetOutputResponseBody: Swift.Equatable {
    let datasetId: Swift.String?
}

extension DeleteDatasetOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetId)
        datasetId = datasetIdDecoded
    }
}

extension DeletePermissionGroupInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let clientToken = clientToken {
                let clientTokenQueryItem = ClientRuntime.URLQueryItem(name: "clientToken".urlPercentEncoding(), value: Swift.String(clientToken).urlPercentEncoding())
                items.append(clientTokenQueryItem)
            }
            return items
        }
    }
}

extension DeletePermissionGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let permissionGroupId = permissionGroupId else {
            return nil
        }
        return "/permission-group/\(permissionGroupId.urlPercentEncoding())"
    }
}

public struct DeletePermissionGroupInput: Swift.Equatable {
    /// A token that ensures idempotency. This token expires in 10 minutes.
    public var clientToken: Swift.String?
    /// The unique identifier for the permission group that you want to delete.
    /// This member is required.
    public var permissionGroupId: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        permissionGroupId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.permissionGroupId = permissionGroupId
    }
}

struct DeletePermissionGroupInputBody: Swift.Equatable {
}

extension DeletePermissionGroupInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeletePermissionGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeletePermissionGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeletePermissionGroupOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeletePermissionGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DeletePermissionGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.permissionGroupId = output.permissionGroupId
        } else {
            self.permissionGroupId = nil
        }
    }
}

public struct DeletePermissionGroupOutputResponse: Swift.Equatable {
    /// The unique identifier for the deleted permission group.
    public var permissionGroupId: Swift.String?

    public init (
        permissionGroupId: Swift.String? = nil
    )
    {
        self.permissionGroupId = permissionGroupId
    }
}

struct DeletePermissionGroupOutputResponseBody: Swift.Equatable {
    let permissionGroupId: Swift.String?
}

extension DeletePermissionGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case permissionGroupId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let permissionGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .permissionGroupId)
        permissionGroupId = permissionGroupIdDecoded
    }
}

extension DisableUserInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
    }
}

extension DisableUserInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let userId = userId else {
            return nil
        }
        return "/user/\(userId.urlPercentEncoding())/disable"
    }
}

public struct DisableUserInput: Swift.Equatable {
    /// A token that ensures idempotency. This token expires in 10 minutes.
    public var clientToken: Swift.String?
    /// The unique identifier for the user account that you want to disable.
    /// This member is required.
    public var userId: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        userId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.userId = userId
    }
}

struct DisableUserInputBody: Swift.Equatable {
    let clientToken: Swift.String?
}

extension DisableUserInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension DisableUserOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisableUserOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DisableUserOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisableUserOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DisableUserOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.userId = output.userId
        } else {
            self.userId = nil
        }
    }
}

public struct DisableUserOutputResponse: Swift.Equatable {
    /// The unique identifier for the disabled user account.
    public var userId: Swift.String?

    public init (
        userId: Swift.String? = nil
    )
    {
        self.userId = userId
    }
}

struct DisableUserOutputResponseBody: Swift.Equatable {
    let userId: Swift.String?
}

extension DisableUserOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case userId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userId)
        userId = userIdDecoded
    }
}

extension DisassociateUserFromPermissionGroupInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let clientToken = clientToken {
                let clientTokenQueryItem = ClientRuntime.URLQueryItem(name: "clientToken".urlPercentEncoding(), value: Swift.String(clientToken).urlPercentEncoding())
                items.append(clientTokenQueryItem)
            }
            return items
        }
    }
}

extension DisassociateUserFromPermissionGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let permissionGroupId = permissionGroupId else {
            return nil
        }
        guard let userId = userId else {
            return nil
        }
        return "/permission-group/\(permissionGroupId.urlPercentEncoding())/users/\(userId.urlPercentEncoding())"
    }
}

public struct DisassociateUserFromPermissionGroupInput: Swift.Equatable {
    /// A token that ensures idempotency. This token expires in 10 minutes.
    public var clientToken: Swift.String?
    /// The unique identifier for the permission group.
    /// This member is required.
    public var permissionGroupId: Swift.String?
    /// The unique identifier for the user.
    /// This member is required.
    public var userId: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        permissionGroupId: Swift.String? = nil,
        userId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.permissionGroupId = permissionGroupId
        self.userId = userId
    }
}

struct DisassociateUserFromPermissionGroupInputBody: Swift.Equatable {
}

extension DisassociateUserFromPermissionGroupInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DisassociateUserFromPermissionGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateUserFromPermissionGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DisassociateUserFromPermissionGroupOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateUserFromPermissionGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        self.statusCode = httpResponse.statusCode.rawValue
    }
}

public struct DisassociateUserFromPermissionGroupOutputResponse: Swift.Equatable {
    /// The returned status code of the response.
    public var statusCode: Swift.Int

    public init (
        statusCode: Swift.Int = 0
    )
    {
        self.statusCode = statusCode
    }
}

struct DisassociateUserFromPermissionGroupOutputResponseBody: Swift.Equatable {
    let statusCode: Swift.Int
}

extension DisassociateUserFromPermissionGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case statusCode
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusCodeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .statusCode) ?? 0
        statusCode = statusCodeDecoded
    }
}

extension EnableUserInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
    }
}

extension EnableUserInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let userId = userId else {
            return nil
        }
        return "/user/\(userId.urlPercentEncoding())/enable"
    }
}

public struct EnableUserInput: Swift.Equatable {
    /// A token that ensures idempotency. This token expires in 10 minutes.
    public var clientToken: Swift.String?
    /// The unique identifier for the user account that you want to enable.
    /// This member is required.
    public var userId: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        userId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.userId = userId
    }
}

struct EnableUserInputBody: Swift.Equatable {
    let clientToken: Swift.String?
}

extension EnableUserInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension EnableUserOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension EnableUserOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "LimitExceededException" : self = .limitExceededException(try LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum EnableUserOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case limitExceededException(LimitExceededException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension EnableUserOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: EnableUserOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.userId = output.userId
        } else {
            self.userId = nil
        }
    }
}

public struct EnableUserOutputResponse: Swift.Equatable {
    /// The unique identifier for the enabled user account.
    public var userId: Swift.String?

    public init (
        userId: Swift.String? = nil
    )
    {
        self.userId = userId
    }
}

struct EnableUserOutputResponseBody: Swift.Equatable {
    let userId: Swift.String?
}

extension EnableUserOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case userId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userId)
        userId = userIdDecoded
    }
}

extension FinspacedataClientTypes {
    /// Changeset Error Category
    public enum ErrorCategory: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case accessDenied
        case cancelled
        case internalServiceException
        case resourceNotFound
        case serviceQuotaExceeded
        case throttling
        case userRecoverable
        case validation
        case sdkUnknown(Swift.String)

        public static var allCases: [ErrorCategory] {
            return [
                .accessDenied,
                .cancelled,
                .internalServiceException,
                .resourceNotFound,
                .serviceQuotaExceeded,
                .throttling,
                .userRecoverable,
                .validation,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .accessDenied: return "ACCESS_DENIED"
            case .cancelled: return "CANCELLED"
            case .internalServiceException: return "INTERNAL_SERVICE_EXCEPTION"
            case .resourceNotFound: return "RESOURCE_NOT_FOUND"
            case .serviceQuotaExceeded: return "SERVICE_QUOTA_EXCEEDED"
            case .throttling: return "THROTTLING"
            case .userRecoverable: return "USER_RECOVERABLE"
            case .validation: return "VALIDATION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ErrorCategory(rawValue: rawValue) ?? ErrorCategory.sdkUnknown(rawValue)
        }
    }
}

extension FinspacedataClientTypes {
    /// Data View Export File Format
    public enum ExportFileFormat: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case delimitedText
        case parquet
        case sdkUnknown(Swift.String)

        public static var allCases: [ExportFileFormat] {
            return [
                .delimitedText,
                .parquet,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .delimitedText: return "DELIMITED_TEXT"
            case .parquet: return "PARQUET"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ExportFileFormat(rawValue: rawValue) ?? ExportFileFormat.sdkUnknown(rawValue)
        }
    }
}

extension GetChangesetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let datasetId = datasetId else {
            return nil
        }
        guard let changesetId = changesetId else {
            return nil
        }
        return "/datasets/\(datasetId.urlPercentEncoding())/changesetsv2/\(changesetId.urlPercentEncoding())"
    }
}

/// Request to describe a changeset.
public struct GetChangesetInput: Swift.Equatable {
    /// The unique identifier of the Changeset for which to get data.
    /// This member is required.
    public var changesetId: Swift.String?
    /// The unique identifier for the FinSpace Dataset where the Changeset is created.
    /// This member is required.
    public var datasetId: Swift.String?

    public init (
        changesetId: Swift.String? = nil,
        datasetId: Swift.String? = nil
    )
    {
        self.changesetId = changesetId
        self.datasetId = datasetId
    }
}

struct GetChangesetInputBody: Swift.Equatable {
}

extension GetChangesetInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetChangesetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetChangesetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetChangesetOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetChangesetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetChangesetOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.activeFromTimestamp = output.activeFromTimestamp
            self.activeUntilTimestamp = output.activeUntilTimestamp
            self.changeType = output.changeType
            self.changesetArn = output.changesetArn
            self.changesetId = output.changesetId
            self.createTime = output.createTime
            self.datasetId = output.datasetId
            self.errorInfo = output.errorInfo
            self.formatParams = output.formatParams
            self.sourceParams = output.sourceParams
            self.status = output.status
            self.updatedByChangesetId = output.updatedByChangesetId
            self.updatesChangesetId = output.updatesChangesetId
        } else {
            self.activeFromTimestamp = nil
            self.activeUntilTimestamp = nil
            self.changeType = nil
            self.changesetArn = nil
            self.changesetId = nil
            self.createTime = 0
            self.datasetId = nil
            self.errorInfo = nil
            self.formatParams = nil
            self.sourceParams = nil
            self.status = nil
            self.updatedByChangesetId = nil
            self.updatesChangesetId = nil
        }
    }
}

/// The response from a describe changeset operation
public struct GetChangesetOutputResponse: Swift.Equatable {
    /// Beginning time from which the Changeset is active. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
    public var activeFromTimestamp: Swift.Int?
    /// Time until which the Changeset is active. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
    public var activeUntilTimestamp: Swift.Int?
    /// Type that indicates how a Changeset is applied to a Dataset.
    ///
    /// * REPLACE – Changeset is considered as a replacement to all prior loaded Changesets.
    ///
    /// * APPEND – Changeset is considered as an addition to the end of all prior loaded Changesets.
    ///
    /// * MODIFY – Changeset is considered as a replacement to a specific prior ingested Changeset.
    public var changeType: FinspacedataClientTypes.ChangeType?
    /// The ARN identifier of the Changeset.
    public var changesetArn: Swift.String?
    /// The unique identifier for a Changeset.
    public var changesetId: Swift.String?
    /// The timestamp at which the Changeset was created in FinSpace. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
    public var createTime: Swift.Int
    /// The unique identifier for the FinSpace Dataset where the Changeset is created.
    public var datasetId: Swift.String?
    /// The structure with error messages.
    public var errorInfo: FinspacedataClientTypes.ChangesetErrorInfo?
    /// Structure of the source file(s).
    public var formatParams: [Swift.String:Swift.String]?
    /// Options that define the location of the data being ingested.
    public var sourceParams: [Swift.String:Swift.String]?
    /// The status of Changeset creation operation.
    public var status: FinspacedataClientTypes.IngestionStatus?
    /// The unique identifier of the updated Changeset.
    public var updatedByChangesetId: Swift.String?
    /// The unique identifier of the Changeset that is being updated.
    public var updatesChangesetId: Swift.String?

    public init (
        activeFromTimestamp: Swift.Int? = nil,
        activeUntilTimestamp: Swift.Int? = nil,
        changeType: FinspacedataClientTypes.ChangeType? = nil,
        changesetArn: Swift.String? = nil,
        changesetId: Swift.String? = nil,
        createTime: Swift.Int = 0,
        datasetId: Swift.String? = nil,
        errorInfo: FinspacedataClientTypes.ChangesetErrorInfo? = nil,
        formatParams: [Swift.String:Swift.String]? = nil,
        sourceParams: [Swift.String:Swift.String]? = nil,
        status: FinspacedataClientTypes.IngestionStatus? = nil,
        updatedByChangesetId: Swift.String? = nil,
        updatesChangesetId: Swift.String? = nil
    )
    {
        self.activeFromTimestamp = activeFromTimestamp
        self.activeUntilTimestamp = activeUntilTimestamp
        self.changeType = changeType
        self.changesetArn = changesetArn
        self.changesetId = changesetId
        self.createTime = createTime
        self.datasetId = datasetId
        self.errorInfo = errorInfo
        self.formatParams = formatParams
        self.sourceParams = sourceParams
        self.status = status
        self.updatedByChangesetId = updatedByChangesetId
        self.updatesChangesetId = updatesChangesetId
    }
}

struct GetChangesetOutputResponseBody: Swift.Equatable {
    let changesetId: Swift.String?
    let changesetArn: Swift.String?
    let datasetId: Swift.String?
    let changeType: FinspacedataClientTypes.ChangeType?
    let sourceParams: [Swift.String:Swift.String]?
    let formatParams: [Swift.String:Swift.String]?
    let createTime: Swift.Int
    let status: FinspacedataClientTypes.IngestionStatus?
    let errorInfo: FinspacedataClientTypes.ChangesetErrorInfo?
    let activeUntilTimestamp: Swift.Int?
    let activeFromTimestamp: Swift.Int?
    let updatesChangesetId: Swift.String?
    let updatedByChangesetId: Swift.String?
}

extension GetChangesetOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case activeFromTimestamp
        case activeUntilTimestamp
        case changeType
        case changesetArn
        case changesetId
        case createTime
        case datasetId
        case errorInfo
        case formatParams
        case sourceParams
        case status
        case updatedByChangesetId
        case updatesChangesetId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let changesetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .changesetId)
        changesetId = changesetIdDecoded
        let changesetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .changesetArn)
        changesetArn = changesetArnDecoded
        let datasetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetId)
        datasetId = datasetIdDecoded
        let changeTypeDecoded = try containerValues.decodeIfPresent(FinspacedataClientTypes.ChangeType.self, forKey: .changeType)
        changeType = changeTypeDecoded
        let sourceParamsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .sourceParams)
        var sourceParamsDecoded0: [Swift.String:Swift.String]? = nil
        if let sourceParamsContainer = sourceParamsContainer {
            sourceParamsDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringmapvalue0) in sourceParamsContainer {
                if let stringmapvalue0 = stringmapvalue0 {
                    sourceParamsDecoded0?[key0] = stringmapvalue0
                }
            }
        }
        sourceParams = sourceParamsDecoded0
        let formatParamsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .formatParams)
        var formatParamsDecoded0: [Swift.String:Swift.String]? = nil
        if let formatParamsContainer = formatParamsContainer {
            formatParamsDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringmapvalue0) in formatParamsContainer {
                if let stringmapvalue0 = stringmapvalue0 {
                    formatParamsDecoded0?[key0] = stringmapvalue0
                }
            }
        }
        formatParams = formatParamsDecoded0
        let createTimeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .createTime) ?? 0
        createTime = createTimeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(FinspacedataClientTypes.IngestionStatus.self, forKey: .status)
        status = statusDecoded
        let errorInfoDecoded = try containerValues.decodeIfPresent(FinspacedataClientTypes.ChangesetErrorInfo.self, forKey: .errorInfo)
        errorInfo = errorInfoDecoded
        let activeUntilTimestampDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .activeUntilTimestamp)
        activeUntilTimestamp = activeUntilTimestampDecoded
        let activeFromTimestampDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .activeFromTimestamp)
        activeFromTimestamp = activeFromTimestampDecoded
        let updatesChangesetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .updatesChangesetId)
        updatesChangesetId = updatesChangesetIdDecoded
        let updatedByChangesetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .updatedByChangesetId)
        updatedByChangesetId = updatedByChangesetIdDecoded
    }
}

extension GetDataViewInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let datasetId = datasetId else {
            return nil
        }
        guard let dataViewId = dataViewId else {
            return nil
        }
        return "/datasets/\(datasetId.urlPercentEncoding())/dataviewsv2/\(dataViewId.urlPercentEncoding())"
    }
}

/// Request for retrieving a data view detail. Grouped / accessible within a dataset by its dataset id.
public struct GetDataViewInput: Swift.Equatable {
    /// The unique identifier for the Dataview.
    /// This member is required.
    public var dataViewId: Swift.String?
    /// The unique identifier for the Dataset used in the Dataview.
    /// This member is required.
    public var datasetId: Swift.String?

    public init (
        dataViewId: Swift.String? = nil,
        datasetId: Swift.String? = nil
    )
    {
        self.dataViewId = dataViewId
        self.datasetId = datasetId
    }
}

struct GetDataViewInputBody: Swift.Equatable {
}

extension GetDataViewInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetDataViewOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDataViewOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetDataViewOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDataViewOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetDataViewOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.asOfTimestamp = output.asOfTimestamp
            self.autoUpdate = output.autoUpdate
            self.createTime = output.createTime
            self.dataViewArn = output.dataViewArn
            self.dataViewId = output.dataViewId
            self.datasetId = output.datasetId
            self.destinationTypeParams = output.destinationTypeParams
            self.errorInfo = output.errorInfo
            self.lastModifiedTime = output.lastModifiedTime
            self.partitionColumns = output.partitionColumns
            self.sortColumns = output.sortColumns
            self.status = output.status
        } else {
            self.asOfTimestamp = nil
            self.autoUpdate = false
            self.createTime = 0
            self.dataViewArn = nil
            self.dataViewId = nil
            self.datasetId = nil
            self.destinationTypeParams = nil
            self.errorInfo = nil
            self.lastModifiedTime = 0
            self.partitionColumns = nil
            self.sortColumns = nil
            self.status = nil
        }
    }
}

/// Response from retrieving a dataview, which includes details on the target database and table name
public struct GetDataViewOutputResponse: Swift.Equatable {
    /// Time range to use for the Dataview. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
    public var asOfTimestamp: Swift.Int?
    /// Flag to indicate Dataview should be updated automatically.
    public var autoUpdate: Swift.Bool
    /// The timestamp at which the Dataview was created in FinSpace. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
    public var createTime: Swift.Int
    /// The ARN identifier of the Dataview.
    public var dataViewArn: Swift.String?
    /// The unique identifier for the Dataview.
    public var dataViewId: Swift.String?
    /// The unique identifier for the Dataset used in the Dataview.
    public var datasetId: Swift.String?
    /// Options that define the destination type for the Dataview.
    public var destinationTypeParams: FinspacedataClientTypes.DataViewDestinationTypeParams?
    /// Information about an error that occurred for the Dataview.
    public var errorInfo: FinspacedataClientTypes.DataViewErrorInfo?
    /// The last time that a Dataview was modified. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
    public var lastModifiedTime: Swift.Int
    /// Ordered set of column names used to partition data.
    public var partitionColumns: [Swift.String]?
    /// Columns to be used for sorting the data.
    public var sortColumns: [Swift.String]?
    /// The status of a Dataview creation.
    ///
    /// * RUNNING – Dataview creation is running.
    ///
    /// * STARTING – Dataview creation is starting.
    ///
    /// * FAILED – Dataview creation has failed.
    ///
    /// * CANCELLED – Dataview creation has been cancelled.
    ///
    /// * TIMEOUT – Dataview creation has timed out.
    ///
    /// * SUCCESS – Dataview creation has succeeded.
    ///
    /// * PENDING – Dataview creation is pending.
    ///
    /// * FAILED_CLEANUP_FAILED – Dataview creation failed and resource cleanup failed.
    public var status: FinspacedataClientTypes.DataViewStatus?

    public init (
        asOfTimestamp: Swift.Int? = nil,
        autoUpdate: Swift.Bool = false,
        createTime: Swift.Int = 0,
        dataViewArn: Swift.String? = nil,
        dataViewId: Swift.String? = nil,
        datasetId: Swift.String? = nil,
        destinationTypeParams: FinspacedataClientTypes.DataViewDestinationTypeParams? = nil,
        errorInfo: FinspacedataClientTypes.DataViewErrorInfo? = nil,
        lastModifiedTime: Swift.Int = 0,
        partitionColumns: [Swift.String]? = nil,
        sortColumns: [Swift.String]? = nil,
        status: FinspacedataClientTypes.DataViewStatus? = nil
    )
    {
        self.asOfTimestamp = asOfTimestamp
        self.autoUpdate = autoUpdate
        self.createTime = createTime
        self.dataViewArn = dataViewArn
        self.dataViewId = dataViewId
        self.datasetId = datasetId
        self.destinationTypeParams = destinationTypeParams
        self.errorInfo = errorInfo
        self.lastModifiedTime = lastModifiedTime
        self.partitionColumns = partitionColumns
        self.sortColumns = sortColumns
        self.status = status
    }
}

struct GetDataViewOutputResponseBody: Swift.Equatable {
    let autoUpdate: Swift.Bool
    let partitionColumns: [Swift.String]?
    let datasetId: Swift.String?
    let asOfTimestamp: Swift.Int?
    let errorInfo: FinspacedataClientTypes.DataViewErrorInfo?
    let lastModifiedTime: Swift.Int
    let createTime: Swift.Int
    let sortColumns: [Swift.String]?
    let dataViewId: Swift.String?
    let dataViewArn: Swift.String?
    let destinationTypeParams: FinspacedataClientTypes.DataViewDestinationTypeParams?
    let status: FinspacedataClientTypes.DataViewStatus?
}

extension GetDataViewOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case asOfTimestamp
        case autoUpdate
        case createTime
        case dataViewArn
        case dataViewId
        case datasetId
        case destinationTypeParams
        case errorInfo
        case lastModifiedTime
        case partitionColumns
        case sortColumns
        case status
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let autoUpdateDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .autoUpdate) ?? false
        autoUpdate = autoUpdateDecoded
        let partitionColumnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .partitionColumns)
        var partitionColumnsDecoded0:[Swift.String]? = nil
        if let partitionColumnsContainer = partitionColumnsContainer {
            partitionColumnsDecoded0 = [Swift.String]()
            for string0 in partitionColumnsContainer {
                if let string0 = string0 {
                    partitionColumnsDecoded0?.append(string0)
                }
            }
        }
        partitionColumns = partitionColumnsDecoded0
        let datasetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetId)
        datasetId = datasetIdDecoded
        let asOfTimestampDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .asOfTimestamp)
        asOfTimestamp = asOfTimestampDecoded
        let errorInfoDecoded = try containerValues.decodeIfPresent(FinspacedataClientTypes.DataViewErrorInfo.self, forKey: .errorInfo)
        errorInfo = errorInfoDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .lastModifiedTime) ?? 0
        lastModifiedTime = lastModifiedTimeDecoded
        let createTimeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .createTime) ?? 0
        createTime = createTimeDecoded
        let sortColumnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .sortColumns)
        var sortColumnsDecoded0:[Swift.String]? = nil
        if let sortColumnsContainer = sortColumnsContainer {
            sortColumnsDecoded0 = [Swift.String]()
            for string0 in sortColumnsContainer {
                if let string0 = string0 {
                    sortColumnsDecoded0?.append(string0)
                }
            }
        }
        sortColumns = sortColumnsDecoded0
        let dataViewIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataViewId)
        dataViewId = dataViewIdDecoded
        let dataViewArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataViewArn)
        dataViewArn = dataViewArnDecoded
        let destinationTypeParamsDecoded = try containerValues.decodeIfPresent(FinspacedataClientTypes.DataViewDestinationTypeParams.self, forKey: .destinationTypeParams)
        destinationTypeParams = destinationTypeParamsDecoded
        let statusDecoded = try containerValues.decodeIfPresent(FinspacedataClientTypes.DataViewStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension GetDatasetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let datasetId = datasetId else {
            return nil
        }
        return "/datasetsv2/\(datasetId.urlPercentEncoding())"
    }
}

/// Request for the GetDataset operation.
public struct GetDatasetInput: Swift.Equatable {
    /// The unique identifier for a Dataset.
    /// This member is required.
    public var datasetId: Swift.String?

    public init (
        datasetId: Swift.String? = nil
    )
    {
        self.datasetId = datasetId
    }
}

struct GetDatasetInputBody: Swift.Equatable {
}

extension GetDatasetInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetDatasetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDatasetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetDatasetOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDatasetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetDatasetOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.alias = output.alias
            self.createTime = output.createTime
            self.datasetArn = output.datasetArn
            self.datasetDescription = output.datasetDescription
            self.datasetId = output.datasetId
            self.datasetTitle = output.datasetTitle
            self.kind = output.kind
            self.lastModifiedTime = output.lastModifiedTime
            self.schemaDefinition = output.schemaDefinition
            self.status = output.status
        } else {
            self.alias = nil
            self.createTime = 0
            self.datasetArn = nil
            self.datasetDescription = nil
            self.datasetId = nil
            self.datasetTitle = nil
            self.kind = nil
            self.lastModifiedTime = 0
            self.schemaDefinition = nil
            self.status = nil
        }
    }
}

/// Response for the GetDataset operation
public struct GetDatasetOutputResponse: Swift.Equatable {
    /// The unique resource identifier for a Dataset.
    public var alias: Swift.String?
    /// The timestamp at which the Dataset was created in FinSpace. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
    public var createTime: Swift.Int
    /// The ARN identifier of the Dataset.
    public var datasetArn: Swift.String?
    /// A description of the Dataset.
    public var datasetDescription: Swift.String?
    /// The unique identifier for a Dataset.
    public var datasetId: Swift.String?
    /// Display title for a Dataset.
    public var datasetTitle: Swift.String?
    /// The format in which Dataset data is structured.
    ///
    /// * TABULAR – Data is structured in a tabular format.
    ///
    /// * NON_TABULAR – Data is structured in a non-tabular format.
    public var kind: FinspacedataClientTypes.DatasetKind?
    /// The last time that the Dataset was modified. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
    public var lastModifiedTime: Swift.Int
    /// Definition for a schema on a tabular Dataset.
    public var schemaDefinition: FinspacedataClientTypes.SchemaUnion?
    /// Status of the Dataset creation.
    ///
    /// * PENDING – Dataset is pending creation.
    ///
    /// * FAILED – Dataset creation has failed.
    ///
    /// * SUCCESS – Dataset creation has succeeded.
    ///
    /// * RUNNING – Dataset creation is running.
    public var status: FinspacedataClientTypes.DatasetStatus?

    public init (
        alias: Swift.String? = nil,
        createTime: Swift.Int = 0,
        datasetArn: Swift.String? = nil,
        datasetDescription: Swift.String? = nil,
        datasetId: Swift.String? = nil,
        datasetTitle: Swift.String? = nil,
        kind: FinspacedataClientTypes.DatasetKind? = nil,
        lastModifiedTime: Swift.Int = 0,
        schemaDefinition: FinspacedataClientTypes.SchemaUnion? = nil,
        status: FinspacedataClientTypes.DatasetStatus? = nil
    )
    {
        self.alias = alias
        self.createTime = createTime
        self.datasetArn = datasetArn
        self.datasetDescription = datasetDescription
        self.datasetId = datasetId
        self.datasetTitle = datasetTitle
        self.kind = kind
        self.lastModifiedTime = lastModifiedTime
        self.schemaDefinition = schemaDefinition
        self.status = status
    }
}

struct GetDatasetOutputResponseBody: Swift.Equatable {
    let datasetId: Swift.String?
    let datasetArn: Swift.String?
    let datasetTitle: Swift.String?
    let kind: FinspacedataClientTypes.DatasetKind?
    let datasetDescription: Swift.String?
    let createTime: Swift.Int
    let lastModifiedTime: Swift.Int
    let schemaDefinition: FinspacedataClientTypes.SchemaUnion?
    let alias: Swift.String?
    let status: FinspacedataClientTypes.DatasetStatus?
}

extension GetDatasetOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alias
        case createTime
        case datasetArn
        case datasetDescription
        case datasetId
        case datasetTitle
        case kind
        case lastModifiedTime
        case schemaDefinition
        case status
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetId)
        datasetId = datasetIdDecoded
        let datasetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetArn)
        datasetArn = datasetArnDecoded
        let datasetTitleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetTitle)
        datasetTitle = datasetTitleDecoded
        let kindDecoded = try containerValues.decodeIfPresent(FinspacedataClientTypes.DatasetKind.self, forKey: .kind)
        kind = kindDecoded
        let datasetDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetDescription)
        datasetDescription = datasetDescriptionDecoded
        let createTimeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .createTime) ?? 0
        createTime = createTimeDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .lastModifiedTime) ?? 0
        lastModifiedTime = lastModifiedTimeDecoded
        let schemaDefinitionDecoded = try containerValues.decodeIfPresent(FinspacedataClientTypes.SchemaUnion.self, forKey: .schemaDefinition)
        schemaDefinition = schemaDefinitionDecoded
        let aliasDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .alias)
        alias = aliasDecoded
        let statusDecoded = try containerValues.decodeIfPresent(FinspacedataClientTypes.DatasetStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension GetExternalDataViewAccessDetailsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let datasetId = datasetId else {
            return nil
        }
        guard let dataViewId = dataViewId else {
            return nil
        }
        return "/datasets/\(datasetId.urlPercentEncoding())/dataviewsv2/\(dataViewId.urlPercentEncoding())/external-access-details"
    }
}

public struct GetExternalDataViewAccessDetailsInput: Swift.Equatable {
    /// The unique identifier for the Dataview that you want to access.
    /// This member is required.
    public var dataViewId: Swift.String?
    /// The unique identifier for the Dataset.
    /// This member is required.
    public var datasetId: Swift.String?

    public init (
        dataViewId: Swift.String? = nil,
        datasetId: Swift.String? = nil
    )
    {
        self.dataViewId = dataViewId
        self.datasetId = datasetId
    }
}

struct GetExternalDataViewAccessDetailsInputBody: Swift.Equatable {
}

extension GetExternalDataViewAccessDetailsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetExternalDataViewAccessDetailsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetExternalDataViewAccessDetailsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetExternalDataViewAccessDetailsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetExternalDataViewAccessDetailsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetExternalDataViewAccessDetailsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.credentials = output.credentials
            self.s3Location = output.s3Location
        } else {
            self.credentials = nil
            self.s3Location = nil
        }
    }
}

public struct GetExternalDataViewAccessDetailsOutputResponse: Swift.Equatable {
    /// The credentials required to access the external Dataview from the S3 location.
    public var credentials: FinspacedataClientTypes.AwsCredentials?
    /// The location where the external Dataview is stored.
    public var s3Location: FinspacedataClientTypes.S3Location?

    public init (
        credentials: FinspacedataClientTypes.AwsCredentials? = nil,
        s3Location: FinspacedataClientTypes.S3Location? = nil
    )
    {
        self.credentials = credentials
        self.s3Location = s3Location
    }
}

struct GetExternalDataViewAccessDetailsOutputResponseBody: Swift.Equatable {
    let credentials: FinspacedataClientTypes.AwsCredentials?
    let s3Location: FinspacedataClientTypes.S3Location?
}

extension GetExternalDataViewAccessDetailsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case credentials
        case s3Location
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let credentialsDecoded = try containerValues.decodeIfPresent(FinspacedataClientTypes.AwsCredentials.self, forKey: .credentials)
        credentials = credentialsDecoded
        let s3LocationDecoded = try containerValues.decodeIfPresent(FinspacedataClientTypes.S3Location.self, forKey: .s3Location)
        s3Location = s3LocationDecoded
    }
}

extension GetPermissionGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let permissionGroupId = permissionGroupId else {
            return nil
        }
        return "/permission-group/\(permissionGroupId.urlPercentEncoding())"
    }
}

public struct GetPermissionGroupInput: Swift.Equatable {
    /// The unique identifier for the permission group.
    /// This member is required.
    public var permissionGroupId: Swift.String?

    public init (
        permissionGroupId: Swift.String? = nil
    )
    {
        self.permissionGroupId = permissionGroupId
    }
}

struct GetPermissionGroupInputBody: Swift.Equatable {
}

extension GetPermissionGroupInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetPermissionGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetPermissionGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetPermissionGroupOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetPermissionGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetPermissionGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.permissionGroup = output.permissionGroup
        } else {
            self.permissionGroup = nil
        }
    }
}

public struct GetPermissionGroupOutputResponse: Swift.Equatable {
    /// The structure for a permission group.
    public var permissionGroup: FinspacedataClientTypes.PermissionGroup?

    public init (
        permissionGroup: FinspacedataClientTypes.PermissionGroup? = nil
    )
    {
        self.permissionGroup = permissionGroup
    }
}

struct GetPermissionGroupOutputResponseBody: Swift.Equatable {
    let permissionGroup: FinspacedataClientTypes.PermissionGroup?
}

extension GetPermissionGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case permissionGroup
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let permissionGroupDecoded = try containerValues.decodeIfPresent(FinspacedataClientTypes.PermissionGroup.self, forKey: .permissionGroup)
        permissionGroup = permissionGroupDecoded
    }
}

extension GetProgrammaticAccessCredentialsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let environmentId = environmentId else {
                let message = "Creating a URL Query Item failed. environmentId is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            let environmentIdQueryItem = ClientRuntime.URLQueryItem(name: "environmentId".urlPercentEncoding(), value: Swift.String(environmentId).urlPercentEncoding())
            items.append(environmentIdQueryItem)
            if durationInMinutes != 0 {
                let durationInMinutesQueryItem = ClientRuntime.URLQueryItem(name: "durationInMinutes".urlPercentEncoding(), value: Swift.String(durationInMinutes).urlPercentEncoding())
                items.append(durationInMinutesQueryItem)
            }
            return items
        }
    }
}

extension GetProgrammaticAccessCredentialsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/credentials/programmatic"
    }
}

/// Request for GetProgrammaticAccessCredentials operation
public struct GetProgrammaticAccessCredentialsInput: Swift.Equatable {
    /// The time duration in which the credentials remain valid.
    public var durationInMinutes: Swift.Int
    /// The FinSpace environment identifier.
    /// This member is required.
    public var environmentId: Swift.String?

    public init (
        durationInMinutes: Swift.Int = 0,
        environmentId: Swift.String? = nil
    )
    {
        self.durationInMinutes = durationInMinutes
        self.environmentId = environmentId
    }
}

struct GetProgrammaticAccessCredentialsInputBody: Swift.Equatable {
}

extension GetProgrammaticAccessCredentialsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetProgrammaticAccessCredentialsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetProgrammaticAccessCredentialsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetProgrammaticAccessCredentialsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetProgrammaticAccessCredentialsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetProgrammaticAccessCredentialsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.credentials = output.credentials
            self.durationInMinutes = output.durationInMinutes
        } else {
            self.credentials = nil
            self.durationInMinutes = 0
        }
    }
}

/// Response for GetProgrammaticAccessCredentials operation
public struct GetProgrammaticAccessCredentialsOutputResponse: Swift.Equatable {
    /// Returns the programmatic credentials.
    public var credentials: FinspacedataClientTypes.Credentials?
    /// Returns the duration in which the credentials will remain valid.
    public var durationInMinutes: Swift.Int

    public init (
        credentials: FinspacedataClientTypes.Credentials? = nil,
        durationInMinutes: Swift.Int = 0
    )
    {
        self.credentials = credentials
        self.durationInMinutes = durationInMinutes
    }
}

struct GetProgrammaticAccessCredentialsOutputResponseBody: Swift.Equatable {
    let credentials: FinspacedataClientTypes.Credentials?
    let durationInMinutes: Swift.Int
}

extension GetProgrammaticAccessCredentialsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case credentials
        case durationInMinutes
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let credentialsDecoded = try containerValues.decodeIfPresent(FinspacedataClientTypes.Credentials.self, forKey: .credentials)
        credentials = credentialsDecoded
        let durationInMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .durationInMinutes) ?? 0
        durationInMinutes = durationInMinutesDecoded
    }
}

extension GetUserInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let userId = userId else {
            return nil
        }
        return "/user/\(userId.urlPercentEncoding())"
    }
}

public struct GetUserInput: Swift.Equatable {
    /// The unique identifier of the user to get data for.
    /// This member is required.
    public var userId: Swift.String?

    public init (
        userId: Swift.String? = nil
    )
    {
        self.userId = userId
    }
}

struct GetUserInputBody: Swift.Equatable {
}

extension GetUserInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetUserOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetUserOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetUserOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetUserOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetUserOutputResponse(apiAccess: \(Swift.String(describing: apiAccess)), apiAccessPrincipalArn: \(Swift.String(describing: apiAccessPrincipalArn)), createTime: \(Swift.String(describing: createTime)), lastDisabledTime: \(Swift.String(describing: lastDisabledTime)), lastEnabledTime: \(Swift.String(describing: lastEnabledTime)), lastLoginTime: \(Swift.String(describing: lastLoginTime)), lastModifiedTime: \(Swift.String(describing: lastModifiedTime)), status: \(Swift.String(describing: status)), type: \(Swift.String(describing: type)), userId: \(Swift.String(describing: userId)), emailAddress: \"CONTENT_REDACTED\", firstName: \"CONTENT_REDACTED\", lastName: \"CONTENT_REDACTED\")"}
}

extension GetUserOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetUserOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.apiAccess = output.apiAccess
            self.apiAccessPrincipalArn = output.apiAccessPrincipalArn
            self.createTime = output.createTime
            self.emailAddress = output.emailAddress
            self.firstName = output.firstName
            self.lastDisabledTime = output.lastDisabledTime
            self.lastEnabledTime = output.lastEnabledTime
            self.lastLoginTime = output.lastLoginTime
            self.lastModifiedTime = output.lastModifiedTime
            self.lastName = output.lastName
            self.status = output.status
            self.type = output.type
            self.userId = output.userId
        } else {
            self.apiAccess = nil
            self.apiAccessPrincipalArn = nil
            self.createTime = 0
            self.emailAddress = nil
            self.firstName = nil
            self.lastDisabledTime = 0
            self.lastEnabledTime = 0
            self.lastLoginTime = 0
            self.lastModifiedTime = 0
            self.lastName = nil
            self.status = nil
            self.type = nil
            self.userId = nil
        }
    }
}

public struct GetUserOutputResponse: Swift.Equatable {
    /// Indicates whether the user can use the GetProgrammaticAccessCredentials API to obtain credentials that can then be used to access other FinSpace Data API operations.
    ///
    /// * ENABLED – The user has permissions to use the APIs.
    ///
    /// * DISABLED – The user does not have permissions to use any APIs.
    public var apiAccess: FinspacedataClientTypes.ApiAccess?
    /// The ARN identifier of an AWS user or role that is allowed to call the GetProgrammaticAccessCredentials API to obtain a credentials token for a specific FinSpace user. This must be an IAM role within your FinSpace account.
    public var apiAccessPrincipalArn: Swift.String?
    /// The timestamp at which the user account was created in FinSpace. The value is determined as epoch time in milliseconds.
    public var createTime: Swift.Int
    /// The email address that is associated with the user.
    public var emailAddress: Swift.String?
    /// The first name of the user.
    public var firstName: Swift.String?
    /// Describes the last time the user account was disabled. The value is determined as epoch time in milliseconds.
    public var lastDisabledTime: Swift.Int
    /// Describes the last time the user account was enabled. The value is determined as epoch time in milliseconds.
    public var lastEnabledTime: Swift.Int
    /// Describes the last time that the user logged into their account. The value is determined as epoch time in milliseconds.
    public var lastLoginTime: Swift.Int
    /// Describes the last time the user account was updated. The value is determined as epoch time in milliseconds.
    public var lastModifiedTime: Swift.Int
    /// The last name of the user.
    public var lastName: Swift.String?
    /// The current status of the user account.
    ///
    /// * CREATING – The user account creation is in progress.
    ///
    /// * ENABLED – The user account is created and is currently active.
    ///
    /// * DISABLED – The user account is currently inactive.
    public var status: FinspacedataClientTypes.UserStatus?
    /// Indicates the type of user.
    ///
    /// * SUPER_USER – A user with permission to all the functionality and data in FinSpace.
    ///
    ///
    ///
    ///
    /// * APP_USER – A user with specific permissions in FinSpace. The users are assigned permissions by adding them to a permission group.
    public var type: FinspacedataClientTypes.UserType?
    /// The unique identifier for the user account that is retrieved.
    public var userId: Swift.String?

    public init (
        apiAccess: FinspacedataClientTypes.ApiAccess? = nil,
        apiAccessPrincipalArn: Swift.String? = nil,
        createTime: Swift.Int = 0,
        emailAddress: Swift.String? = nil,
        firstName: Swift.String? = nil,
        lastDisabledTime: Swift.Int = 0,
        lastEnabledTime: Swift.Int = 0,
        lastLoginTime: Swift.Int = 0,
        lastModifiedTime: Swift.Int = 0,
        lastName: Swift.String? = nil,
        status: FinspacedataClientTypes.UserStatus? = nil,
        type: FinspacedataClientTypes.UserType? = nil,
        userId: Swift.String? = nil
    )
    {
        self.apiAccess = apiAccess
        self.apiAccessPrincipalArn = apiAccessPrincipalArn
        self.createTime = createTime
        self.emailAddress = emailAddress
        self.firstName = firstName
        self.lastDisabledTime = lastDisabledTime
        self.lastEnabledTime = lastEnabledTime
        self.lastLoginTime = lastLoginTime
        self.lastModifiedTime = lastModifiedTime
        self.lastName = lastName
        self.status = status
        self.type = type
        self.userId = userId
    }
}

struct GetUserOutputResponseBody: Swift.Equatable {
    let userId: Swift.String?
    let status: FinspacedataClientTypes.UserStatus?
    let firstName: Swift.String?
    let lastName: Swift.String?
    let emailAddress: Swift.String?
    let type: FinspacedataClientTypes.UserType?
    let apiAccess: FinspacedataClientTypes.ApiAccess?
    let apiAccessPrincipalArn: Swift.String?
    let createTime: Swift.Int
    let lastEnabledTime: Swift.Int
    let lastDisabledTime: Swift.Int
    let lastModifiedTime: Swift.Int
    let lastLoginTime: Swift.Int
}

extension GetUserOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiAccess
        case apiAccessPrincipalArn
        case createTime
        case emailAddress
        case firstName
        case lastDisabledTime
        case lastEnabledTime
        case lastLoginTime
        case lastModifiedTime
        case lastName
        case status
        case type
        case userId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userId)
        userId = userIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(FinspacedataClientTypes.UserStatus.self, forKey: .status)
        status = statusDecoded
        let firstNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .firstName)
        firstName = firstNameDecoded
        let lastNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastName)
        lastName = lastNameDecoded
        let emailAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .emailAddress)
        emailAddress = emailAddressDecoded
        let typeDecoded = try containerValues.decodeIfPresent(FinspacedataClientTypes.UserType.self, forKey: .type)
        type = typeDecoded
        let apiAccessDecoded = try containerValues.decodeIfPresent(FinspacedataClientTypes.ApiAccess.self, forKey: .apiAccess)
        apiAccess = apiAccessDecoded
        let apiAccessPrincipalArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiAccessPrincipalArn)
        apiAccessPrincipalArn = apiAccessPrincipalArnDecoded
        let createTimeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .createTime) ?? 0
        createTime = createTimeDecoded
        let lastEnabledTimeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .lastEnabledTime) ?? 0
        lastEnabledTime = lastEnabledTimeDecoded
        let lastDisabledTimeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .lastDisabledTime) ?? 0
        lastDisabledTime = lastDisabledTimeDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .lastModifiedTime) ?? 0
        lastModifiedTime = lastModifiedTimeDecoded
        let lastLoginTimeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .lastLoginTime) ?? 0
        lastLoginTime = lastLoginTimeDecoded
    }
}

extension GetWorkingLocationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case locationType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let locationType = self.locationType {
            try encodeContainer.encode(locationType.rawValue, forKey: .locationType)
        }
    }
}

extension GetWorkingLocationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/workingLocationV1"
    }
}

public struct GetWorkingLocationInput: Swift.Equatable {
    /// Specify the type of the working location.
    ///
    /// * SAGEMAKER – Use the Amazon S3 location as a temporary location to store data content when working with FinSpace Notebooks that run on SageMaker studio.
    ///
    /// * INGESTION – Use the Amazon S3 location as a staging location to copy your data content and then use the location with the Changeset creation operation.
    public var locationType: FinspacedataClientTypes.LocationType?

    public init (
        locationType: FinspacedataClientTypes.LocationType? = nil
    )
    {
        self.locationType = locationType
    }
}

struct GetWorkingLocationInputBody: Swift.Equatable {
    let locationType: FinspacedataClientTypes.LocationType?
}

extension GetWorkingLocationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case locationType
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let locationTypeDecoded = try containerValues.decodeIfPresent(FinspacedataClientTypes.LocationType.self, forKey: .locationType)
        locationType = locationTypeDecoded
    }
}

extension GetWorkingLocationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetWorkingLocationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetWorkingLocationOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetWorkingLocationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetWorkingLocationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.s3Bucket = output.s3Bucket
            self.s3Path = output.s3Path
            self.s3Uri = output.s3Uri
        } else {
            self.s3Bucket = nil
            self.s3Path = nil
            self.s3Uri = nil
        }
    }
}

public struct GetWorkingLocationOutputResponse: Swift.Equatable {
    /// Returns the Amazon S3 bucket name for the working location.
    public var s3Bucket: Swift.String?
    /// Returns the Amazon S3 Path for the working location.
    public var s3Path: Swift.String?
    /// Returns the Amazon S3 URI for the working location.
    public var s3Uri: Swift.String?

    public init (
        s3Bucket: Swift.String? = nil,
        s3Path: Swift.String? = nil,
        s3Uri: Swift.String? = nil
    )
    {
        self.s3Bucket = s3Bucket
        self.s3Path = s3Path
        self.s3Uri = s3Uri
    }
}

struct GetWorkingLocationOutputResponseBody: Swift.Equatable {
    let s3Uri: Swift.String?
    let s3Path: Swift.String?
    let s3Bucket: Swift.String?
}

extension GetWorkingLocationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3Bucket
        case s3Path
        case s3Uri
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3UriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3Uri)
        s3Uri = s3UriDecoded
        let s3PathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3Path)
        s3Path = s3PathDecoded
        let s3BucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3Bucket)
        s3Bucket = s3BucketDecoded
    }
}

extension FinspacedataClientTypes {
    /// Status of the ingestion process returned from scheduler service.
    public enum IngestionStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failed
        case pending
        case running
        case stopRequested
        case success
        case sdkUnknown(Swift.String)

        public static var allCases: [IngestionStatus] {
            return [
                .failed,
                .pending,
                .running,
                .stopRequested,
                .success,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .pending: return "PENDING"
            case .running: return "RUNNING"
            case .stopRequested: return "STOP_REQUESTED"
            case .success: return "SUCCESS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = IngestionStatus(rawValue: rawValue) ?? IngestionStatus.sdkUnknown(rawValue)
        }
    }
}

extension InternalServerException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request processing has failed because of an unknown error, exception or failure.
public struct InternalServerException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LimitExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: LimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// A limit has exceeded.
public struct LimitExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct LimitExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension LimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListChangesetsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            return items
        }
    }
}

extension ListChangesetsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let datasetId = datasetId else {
            return nil
        }
        return "/datasets/\(datasetId.urlPercentEncoding())/changesetsv2"
    }
}

/// Request to ListChangesetsRequest. It exposes minimal query filters.
public struct ListChangesetsInput: Swift.Equatable {
    /// The unique identifier for the FinSpace Dataset to which the Changeset belongs.
    /// This member is required.
    public var datasetId: Swift.String?
    /// The maximum number of results per page.
    public var maxResults: Swift.Int?
    /// A token that indicates where a results page should begin.
    public var nextToken: Swift.String?

    public init (
        datasetId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.datasetId = datasetId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListChangesetsInputBody: Swift.Equatable {
}

extension ListChangesetsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListChangesetsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListChangesetsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListChangesetsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListChangesetsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListChangesetsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.changesets = output.changesets
            self.nextToken = output.nextToken
        } else {
            self.changesets = nil
            self.nextToken = nil
        }
    }
}

/// Response to ListChangesetsResponse. This returns a list of dataset changesets that match the query criteria.
public struct ListChangesetsOutputResponse: Swift.Equatable {
    /// List of Changesets found.
    public var changesets: [FinspacedataClientTypes.ChangesetSummary]?
    /// A token that indicates where a results page should begin.
    public var nextToken: Swift.String?

    public init (
        changesets: [FinspacedataClientTypes.ChangesetSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.changesets = changesets
        self.nextToken = nextToken
    }
}

struct ListChangesetsOutputResponseBody: Swift.Equatable {
    let changesets: [FinspacedataClientTypes.ChangesetSummary]?
    let nextToken: Swift.String?
}

extension ListChangesetsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case changesets
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let changesetsContainer = try containerValues.decodeIfPresent([FinspacedataClientTypes.ChangesetSummary?].self, forKey: .changesets)
        var changesetsDecoded0:[FinspacedataClientTypes.ChangesetSummary]? = nil
        if let changesetsContainer = changesetsContainer {
            changesetsDecoded0 = [FinspacedataClientTypes.ChangesetSummary]()
            for structure0 in changesetsContainer {
                if let structure0 = structure0 {
                    changesetsDecoded0?.append(structure0)
                }
            }
        }
        changesets = changesetsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListDataViewsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListDataViewsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let datasetId = datasetId else {
            return nil
        }
        return "/datasets/\(datasetId.urlPercentEncoding())/dataviewsv2"
    }
}

/// Request for a list data views.
public struct ListDataViewsInput: Swift.Equatable {
    /// The unique identifier of the Dataset for which to retrieve Dataviews.
    /// This member is required.
    public var datasetId: Swift.String?
    /// The maximum number of results per page.
    public var maxResults: Swift.Int?
    /// A token that indicates where a results page should begin.
    public var nextToken: Swift.String?

    public init (
        datasetId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.datasetId = datasetId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListDataViewsInputBody: Swift.Equatable {
}

extension ListDataViewsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListDataViewsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDataViewsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListDataViewsOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDataViewsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListDataViewsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.dataViews = output.dataViews
            self.nextToken = output.nextToken
        } else {
            self.dataViews = nil
            self.nextToken = nil
        }
    }
}

public struct ListDataViewsOutputResponse: Swift.Equatable {
    /// A list of Dataviews.
    public var dataViews: [FinspacedataClientTypes.DataViewSummary]?
    /// A token that indicates where a results page should begin.
    public var nextToken: Swift.String?

    public init (
        dataViews: [FinspacedataClientTypes.DataViewSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.dataViews = dataViews
        self.nextToken = nextToken
    }
}

struct ListDataViewsOutputResponseBody: Swift.Equatable {
    let nextToken: Swift.String?
    let dataViews: [FinspacedataClientTypes.DataViewSummary]?
}

extension ListDataViewsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataViews
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let dataViewsContainer = try containerValues.decodeIfPresent([FinspacedataClientTypes.DataViewSummary?].self, forKey: .dataViews)
        var dataViewsDecoded0:[FinspacedataClientTypes.DataViewSummary]? = nil
        if let dataViewsContainer = dataViewsContainer {
            dataViewsDecoded0 = [FinspacedataClientTypes.DataViewSummary]()
            for structure0 in dataViewsContainer {
                if let structure0 = structure0 {
                    dataViewsDecoded0?.append(structure0)
                }
            }
        }
        dataViews = dataViewsDecoded0
    }
}

extension ListDatasetsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListDatasetsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/datasetsv2"
    }
}

/// Request for the ListDatasets operation.
public struct ListDatasetsInput: Swift.Equatable {
    /// The maximum number of results per page.
    public var maxResults: Swift.Int?
    /// A token that indicates where a results page should begin.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListDatasetsInputBody: Swift.Equatable {
}

extension ListDatasetsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListDatasetsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDatasetsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListDatasetsOutputError: Swift.Error, Swift.Equatable {
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDatasetsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListDatasetsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.datasets = output.datasets
            self.nextToken = output.nextToken
        } else {
            self.datasets = nil
            self.nextToken = nil
        }
    }
}

/// Response for the ListDatasets operation
public struct ListDatasetsOutputResponse: Swift.Equatable {
    /// List of Datasets.
    public var datasets: [FinspacedataClientTypes.Dataset]?
    /// A token that indicates where a results page should begin.
    public var nextToken: Swift.String?

    public init (
        datasets: [FinspacedataClientTypes.Dataset]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.datasets = datasets
        self.nextToken = nextToken
    }
}

struct ListDatasetsOutputResponseBody: Swift.Equatable {
    let datasets: [FinspacedataClientTypes.Dataset]?
    let nextToken: Swift.String?
}

extension ListDatasetsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasets
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetsContainer = try containerValues.decodeIfPresent([FinspacedataClientTypes.Dataset?].self, forKey: .datasets)
        var datasetsDecoded0:[FinspacedataClientTypes.Dataset]? = nil
        if let datasetsContainer = datasetsContainer {
            datasetsDecoded0 = [FinspacedataClientTypes.Dataset]()
            for structure0 in datasetsContainer {
                if let structure0 = structure0 {
                    datasetsDecoded0?.append(structure0)
                }
            }
        }
        datasets = datasetsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListPermissionGroupsByUserInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
            return items
        }
    }
}

extension ListPermissionGroupsByUserInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let userId = userId else {
            return nil
        }
        return "/user/\(userId.urlPercentEncoding())/permission-groups"
    }
}

public struct ListPermissionGroupsByUserInput: Swift.Equatable {
    /// The maximum number of results per page.
    /// This member is required.
    public var maxResults: Swift.Int
    /// A token that indicates where a results page should begin.
    public var nextToken: Swift.String?
    /// The unique identifier for the user.
    /// This member is required.
    public var userId: Swift.String?

    public init (
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil,
        userId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.userId = userId
    }
}

struct ListPermissionGroupsByUserInputBody: Swift.Equatable {
}

extension ListPermissionGroupsByUserInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListPermissionGroupsByUserOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListPermissionGroupsByUserOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListPermissionGroupsByUserOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListPermissionGroupsByUserOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListPermissionGroupsByUserOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.permissionGroups = output.permissionGroups
        } else {
            self.nextToken = nil
            self.permissionGroups = nil
        }
    }
}

public struct ListPermissionGroupsByUserOutputResponse: Swift.Equatable {
    /// A token that indicates where a results page should begin.
    public var nextToken: Swift.String?
    /// A list of returned permission groups.
    public var permissionGroups: [FinspacedataClientTypes.PermissionGroupByUser]?

    public init (
        nextToken: Swift.String? = nil,
        permissionGroups: [FinspacedataClientTypes.PermissionGroupByUser]? = nil
    )
    {
        self.nextToken = nextToken
        self.permissionGroups = permissionGroups
    }
}

struct ListPermissionGroupsByUserOutputResponseBody: Swift.Equatable {
    let permissionGroups: [FinspacedataClientTypes.PermissionGroupByUser]?
    let nextToken: Swift.String?
}

extension ListPermissionGroupsByUserOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case permissionGroups
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let permissionGroupsContainer = try containerValues.decodeIfPresent([FinspacedataClientTypes.PermissionGroupByUser?].self, forKey: .permissionGroups)
        var permissionGroupsDecoded0:[FinspacedataClientTypes.PermissionGroupByUser]? = nil
        if let permissionGroupsContainer = permissionGroupsContainer {
            permissionGroupsDecoded0 = [FinspacedataClientTypes.PermissionGroupByUser]()
            for structure0 in permissionGroupsContainer {
                if let structure0 = structure0 {
                    permissionGroupsDecoded0?.append(structure0)
                }
            }
        }
        permissionGroups = permissionGroupsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListPermissionGroupsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
            return items
        }
    }
}

extension ListPermissionGroupsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/permission-group"
    }
}

public struct ListPermissionGroupsInput: Swift.Equatable {
    /// The maximum number of results per page.
    /// This member is required.
    public var maxResults: Swift.Int
    /// A token that indicates where a results page should begin.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListPermissionGroupsInputBody: Swift.Equatable {
}

extension ListPermissionGroupsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListPermissionGroupsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListPermissionGroupsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListPermissionGroupsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListPermissionGroupsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListPermissionGroupsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.permissionGroups = output.permissionGroups
        } else {
            self.nextToken = nil
            self.permissionGroups = nil
        }
    }
}

public struct ListPermissionGroupsOutputResponse: Swift.Equatable {
    /// A token that indicates where a results page should begin.
    public var nextToken: Swift.String?
    /// A list of all the permission groups.
    public var permissionGroups: [FinspacedataClientTypes.PermissionGroup]?

    public init (
        nextToken: Swift.String? = nil,
        permissionGroups: [FinspacedataClientTypes.PermissionGroup]? = nil
    )
    {
        self.nextToken = nextToken
        self.permissionGroups = permissionGroups
    }
}

struct ListPermissionGroupsOutputResponseBody: Swift.Equatable {
    let permissionGroups: [FinspacedataClientTypes.PermissionGroup]?
    let nextToken: Swift.String?
}

extension ListPermissionGroupsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case permissionGroups
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let permissionGroupsContainer = try containerValues.decodeIfPresent([FinspacedataClientTypes.PermissionGroup?].self, forKey: .permissionGroups)
        var permissionGroupsDecoded0:[FinspacedataClientTypes.PermissionGroup]? = nil
        if let permissionGroupsContainer = permissionGroupsContainer {
            permissionGroupsDecoded0 = [FinspacedataClientTypes.PermissionGroup]()
            for structure0 in permissionGroupsContainer {
                if let structure0 = structure0 {
                    permissionGroupsDecoded0?.append(structure0)
                }
            }
        }
        permissionGroups = permissionGroupsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListUsersByPermissionGroupInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
            return items
        }
    }
}

extension ListUsersByPermissionGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let permissionGroupId = permissionGroupId else {
            return nil
        }
        return "/permission-group/\(permissionGroupId.urlPercentEncoding())/users"
    }
}

public struct ListUsersByPermissionGroupInput: Swift.Equatable {
    /// The maximum number of results per page.
    /// This member is required.
    public var maxResults: Swift.Int
    /// A token that indicates where a results page should begin.
    public var nextToken: Swift.String?
    /// The unique identifier for the permission group.
    /// This member is required.
    public var permissionGroupId: Swift.String?

    public init (
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil,
        permissionGroupId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.permissionGroupId = permissionGroupId
    }
}

struct ListUsersByPermissionGroupInputBody: Swift.Equatable {
}

extension ListUsersByPermissionGroupInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListUsersByPermissionGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListUsersByPermissionGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListUsersByPermissionGroupOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListUsersByPermissionGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListUsersByPermissionGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.users = output.users
        } else {
            self.nextToken = nil
            self.users = nil
        }
    }
}

public struct ListUsersByPermissionGroupOutputResponse: Swift.Equatable {
    /// A token that indicates where a results page should begin.
    public var nextToken: Swift.String?
    /// Lists details of all users in a specific permission group.
    public var users: [FinspacedataClientTypes.UserByPermissionGroup]?

    public init (
        nextToken: Swift.String? = nil,
        users: [FinspacedataClientTypes.UserByPermissionGroup]? = nil
    )
    {
        self.nextToken = nextToken
        self.users = users
    }
}

struct ListUsersByPermissionGroupOutputResponseBody: Swift.Equatable {
    let users: [FinspacedataClientTypes.UserByPermissionGroup]?
    let nextToken: Swift.String?
}

extension ListUsersByPermissionGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case users
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let usersContainer = try containerValues.decodeIfPresent([FinspacedataClientTypes.UserByPermissionGroup?].self, forKey: .users)
        var usersDecoded0:[FinspacedataClientTypes.UserByPermissionGroup]? = nil
        if let usersContainer = usersContainer {
            usersDecoded0 = [FinspacedataClientTypes.UserByPermissionGroup]()
            for structure0 in usersContainer {
                if let structure0 = structure0 {
                    usersDecoded0?.append(structure0)
                }
            }
        }
        users = usersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListUsersInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
            return items
        }
    }
}

extension ListUsersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/user"
    }
}

public struct ListUsersInput: Swift.Equatable {
    /// The maximum number of results per page.
    /// This member is required.
    public var maxResults: Swift.Int
    /// A token that indicates where a results page should begin.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int = 0,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListUsersInputBody: Swift.Equatable {
}

extension ListUsersInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListUsersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListUsersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListUsersOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListUsersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListUsersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.users = output.users
        } else {
            self.nextToken = nil
            self.users = nil
        }
    }
}

public struct ListUsersOutputResponse: Swift.Equatable {
    /// A token that indicates where a results page should begin.
    public var nextToken: Swift.String?
    /// A list of all the user accounts.
    public var users: [FinspacedataClientTypes.User]?

    public init (
        nextToken: Swift.String? = nil,
        users: [FinspacedataClientTypes.User]? = nil
    )
    {
        self.nextToken = nextToken
        self.users = users
    }
}

struct ListUsersOutputResponseBody: Swift.Equatable {
    let users: [FinspacedataClientTypes.User]?
    let nextToken: Swift.String?
}

extension ListUsersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case users
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let usersContainer = try containerValues.decodeIfPresent([FinspacedataClientTypes.User?].self, forKey: .users)
        var usersDecoded0:[FinspacedataClientTypes.User]? = nil
        if let usersContainer = usersContainer {
            usersDecoded0 = [FinspacedataClientTypes.User]()
            for structure0 in usersContainer {
                if let structure0 = structure0 {
                    usersDecoded0?.append(structure0)
                }
            }
        }
        users = usersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension FinspacedataClientTypes {
    public enum LocationType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ingestion
        case sagemaker
        case sdkUnknown(Swift.String)

        public static var allCases: [LocationType] {
            return [
                .ingestion,
                .sagemaker,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ingestion: return "INGESTION"
            case .sagemaker: return "SAGEMAKER"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LocationType(rawValue: rawValue) ?? LocationType.sdkUnknown(rawValue)
        }
    }
}

extension FinspacedataClientTypes.PermissionGroup: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationPermissions
        case createTime
        case description
        case lastModifiedTime
        case membershipStatus
        case name
        case permissionGroupId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationPermissions = applicationPermissions {
            var applicationPermissionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .applicationPermissions)
            for applicationpermission0 in applicationPermissions {
                try applicationPermissionsContainer.encode(applicationpermission0.rawValue)
            }
        }
        if createTime != 0 {
            try encodeContainer.encode(createTime, forKey: .createTime)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if lastModifiedTime != 0 {
            try encodeContainer.encode(lastModifiedTime, forKey: .lastModifiedTime)
        }
        if let membershipStatus = self.membershipStatus {
            try encodeContainer.encode(membershipStatus.rawValue, forKey: .membershipStatus)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let permissionGroupId = self.permissionGroupId {
            try encodeContainer.encode(permissionGroupId, forKey: .permissionGroupId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let permissionGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .permissionGroupId)
        permissionGroupId = permissionGroupIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let applicationPermissionsContainer = try containerValues.decodeIfPresent([FinspacedataClientTypes.ApplicationPermission?].self, forKey: .applicationPermissions)
        var applicationPermissionsDecoded0:[FinspacedataClientTypes.ApplicationPermission]? = nil
        if let applicationPermissionsContainer = applicationPermissionsContainer {
            applicationPermissionsDecoded0 = [FinspacedataClientTypes.ApplicationPermission]()
            for string0 in applicationPermissionsContainer {
                if let string0 = string0 {
                    applicationPermissionsDecoded0?.append(string0)
                }
            }
        }
        applicationPermissions = applicationPermissionsDecoded0
        let createTimeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .createTime) ?? 0
        createTime = createTimeDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .lastModifiedTime) ?? 0
        lastModifiedTime = lastModifiedTimeDecoded
        let membershipStatusDecoded = try containerValues.decodeIfPresent(FinspacedataClientTypes.PermissionGroupMembershipStatus.self, forKey: .membershipStatus)
        membershipStatus = membershipStatusDecoded
    }
}

extension FinspacedataClientTypes.PermissionGroup: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PermissionGroup(applicationPermissions: \(Swift.String(describing: applicationPermissions)), createTime: \(Swift.String(describing: createTime)), lastModifiedTime: \(Swift.String(describing: lastModifiedTime)), membershipStatus: \(Swift.String(describing: membershipStatus)), permissionGroupId: \(Swift.String(describing: permissionGroupId)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension FinspacedataClientTypes {
    /// The structure for a permission group.
    public struct PermissionGroup: Swift.Equatable {
        /// Indicates the permissions that are granted to a specific group for accessing the FinSpace application. When assigning application permissions, be aware that the permission ManageUsersAndGroups allows users to grant themselves or others access to any functionality in their FinSpace environment's application. It should only be granted to trusted users.
        ///
        /// * CreateDataset – Group members can create new datasets.
        ///
        /// * ManageClusters – Group members can manage Apache Spark clusters from FinSpace notebooks.
        ///
        /// * ManageUsersAndGroups – Group members can manage users and permission groups. This is a privileged permission that allows users to grant themselves or others access to any functionality in the application. It should only be granted to trusted users.
        ///
        /// * ManageAttributeSets – Group members can manage attribute sets.
        ///
        /// * ViewAuditData – Group members can view audit data.
        ///
        /// * AccessNotebooks – Group members will have access to FinSpace notebooks.
        ///
        /// * GetTemporaryCredentials – Group members can get temporary API credentials.
        public var applicationPermissions: [FinspacedataClientTypes.ApplicationPermission]?
        /// The timestamp at which the group was created in FinSpace. The value is determined as epoch time in milliseconds.
        public var createTime: Swift.Int
        /// A brief description for the permission group.
        public var description: Swift.String?
        /// Describes the last time the permission group was updated. The value is determined as epoch time in milliseconds.
        public var lastModifiedTime: Swift.Int
        /// Indicates the status of the user account within a permission group.
        ///
        /// * ADDITION_IN_PROGRESS – The user account is currently being added to the permission group.
        ///
        /// * ADDITION_SUCCESS – The user account is successfully added to the permission group.
        ///
        /// * REMOVAL_IN_PROGRESS – The user is currently being removed from the permission group.
        public var membershipStatus: FinspacedataClientTypes.PermissionGroupMembershipStatus?
        /// The name of the permission group.
        public var name: Swift.String?
        /// The unique identifier for the permission group.
        public var permissionGroupId: Swift.String?

        public init (
            applicationPermissions: [FinspacedataClientTypes.ApplicationPermission]? = nil,
            createTime: Swift.Int = 0,
            description: Swift.String? = nil,
            lastModifiedTime: Swift.Int = 0,
            membershipStatus: FinspacedataClientTypes.PermissionGroupMembershipStatus? = nil,
            name: Swift.String? = nil,
            permissionGroupId: Swift.String? = nil
        )
        {
            self.applicationPermissions = applicationPermissions
            self.createTime = createTime
            self.description = description
            self.lastModifiedTime = lastModifiedTime
            self.membershipStatus = membershipStatus
            self.name = name
            self.permissionGroupId = permissionGroupId
        }
    }

}

extension FinspacedataClientTypes.PermissionGroupByUser: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case membershipStatus
        case name
        case permissionGroupId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let membershipStatus = self.membershipStatus {
            try encodeContainer.encode(membershipStatus.rawValue, forKey: .membershipStatus)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let permissionGroupId = self.permissionGroupId {
            try encodeContainer.encode(permissionGroupId, forKey: .permissionGroupId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let permissionGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .permissionGroupId)
        permissionGroupId = permissionGroupIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let membershipStatusDecoded = try containerValues.decodeIfPresent(FinspacedataClientTypes.PermissionGroupMembershipStatus.self, forKey: .membershipStatus)
        membershipStatus = membershipStatusDecoded
    }
}

extension FinspacedataClientTypes.PermissionGroupByUser: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PermissionGroupByUser(membershipStatus: \(Swift.String(describing: membershipStatus)), permissionGroupId: \(Swift.String(describing: permissionGroupId)), name: \"CONTENT_REDACTED\")"}
}

extension FinspacedataClientTypes {
    /// The structure of a permission group associated with a user account.
    public struct PermissionGroupByUser: Swift.Equatable {
        /// Indicates the status of the user account within a permission group.
        ///
        /// * ADDITION_IN_PROGRESS – The user account is currently being added to the permission group.
        ///
        /// * ADDITION_SUCCESS – The user account is successfully added to the permission group.
        ///
        /// * REMOVAL_IN_PROGRESS – The user is currently being removed from the permission group.
        public var membershipStatus: FinspacedataClientTypes.PermissionGroupMembershipStatus?
        /// The name of the permission group.
        public var name: Swift.String?
        /// The unique identifier for the permission group.
        public var permissionGroupId: Swift.String?

        public init (
            membershipStatus: FinspacedataClientTypes.PermissionGroupMembershipStatus? = nil,
            name: Swift.String? = nil,
            permissionGroupId: Swift.String? = nil
        )
        {
            self.membershipStatus = membershipStatus
            self.name = name
            self.permissionGroupId = permissionGroupId
        }
    }

}

extension FinspacedataClientTypes {
    public enum PermissionGroupMembershipStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case additionInProgress
        case additionSuccess
        case removalInProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [PermissionGroupMembershipStatus] {
            return [
                .additionInProgress,
                .additionSuccess,
                .removalInProgress,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .additionInProgress: return "ADDITION_IN_PROGRESS"
            case .additionSuccess: return "ADDITION_SUCCESS"
            case .removalInProgress: return "REMOVAL_IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PermissionGroupMembershipStatus(rawValue: rawValue) ?? PermissionGroupMembershipStatus.sdkUnknown(rawValue)
        }
    }
}

extension FinspacedataClientTypes.PermissionGroupParams: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetPermissions
        case permissionGroupId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let datasetPermissions = datasetPermissions {
            var datasetPermissionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .datasetPermissions)
            for resourcepermission0 in datasetPermissions {
                try datasetPermissionsContainer.encode(resourcepermission0)
            }
        }
        if let permissionGroupId = self.permissionGroupId {
            try encodeContainer.encode(permissionGroupId, forKey: .permissionGroupId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let permissionGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .permissionGroupId)
        permissionGroupId = permissionGroupIdDecoded
        let datasetPermissionsContainer = try containerValues.decodeIfPresent([FinspacedataClientTypes.ResourcePermission?].self, forKey: .datasetPermissions)
        var datasetPermissionsDecoded0:[FinspacedataClientTypes.ResourcePermission]? = nil
        if let datasetPermissionsContainer = datasetPermissionsContainer {
            datasetPermissionsDecoded0 = [FinspacedataClientTypes.ResourcePermission]()
            for structure0 in datasetPermissionsContainer {
                if let structure0 = structure0 {
                    datasetPermissionsDecoded0?.append(structure0)
                }
            }
        }
        datasetPermissions = datasetPermissionsDecoded0
    }
}

extension FinspacedataClientTypes {
    /// Permission group parameters for Dataset permissions. Here is an example of how you could specify the PermissionGroupParams:  { "permissionGroupId": "0r6fCRtSTUk4XPfXQe3M0g", "datasetPermissions": [ {"permission": "ViewDatasetDetails"}, {"permission": "AddDatasetData"}, {"permission": "EditDatasetMetadata"}, {"permission": "DeleteDataset"} ] }
    public struct PermissionGroupParams: Swift.Equatable {
        /// List of resource permissions.
        public var datasetPermissions: [FinspacedataClientTypes.ResourcePermission]?
        /// The unique identifier for the PermissionGroup.
        public var permissionGroupId: Swift.String?

        public init (
            datasetPermissions: [FinspacedataClientTypes.ResourcePermission]? = nil,
            permissionGroupId: Swift.String? = nil
        )
        {
            self.datasetPermissions = datasetPermissions
            self.permissionGroupId = permissionGroupId
        }
    }

}

extension ResetUserPasswordInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
    }
}

extension ResetUserPasswordInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let userId = userId else {
            return nil
        }
        return "/user/\(userId.urlPercentEncoding())/password"
    }
}

public struct ResetUserPasswordInput: Swift.Equatable {
    /// A token that ensures idempotency. This token expires in 10 minutes.
    public var clientToken: Swift.String?
    /// The unique identifier of the user that a temporary password is requested for.
    /// This member is required.
    public var userId: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        userId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.userId = userId
    }
}

struct ResetUserPasswordInputBody: Swift.Equatable {
    let clientToken: Swift.String?
}

extension ResetUserPasswordInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension ResetUserPasswordOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ResetUserPasswordOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ResetUserPasswordOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ResetUserPasswordOutputResponse: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResetUserPasswordOutputResponse(userId: \(Swift.String(describing: userId)), temporaryPassword: \"CONTENT_REDACTED\")"}
}

extension ResetUserPasswordOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ResetUserPasswordOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.temporaryPassword = output.temporaryPassword
            self.userId = output.userId
        } else {
            self.temporaryPassword = nil
            self.userId = nil
        }
    }
}

public struct ResetUserPasswordOutputResponse: Swift.Equatable {
    /// A randomly generated temporary password for the requested user account. This password expires in 7 days.
    public var temporaryPassword: Swift.String?
    /// The unique identifier of the user that a new password is generated for.
    public var userId: Swift.String?

    public init (
        temporaryPassword: Swift.String? = nil,
        userId: Swift.String? = nil
    )
    {
        self.temporaryPassword = temporaryPassword
        self.userId = userId
    }
}

struct ResetUserPasswordOutputResponseBody: Swift.Equatable {
    let userId: Swift.String?
    let temporaryPassword: Swift.String?
}

extension ResetUserPasswordOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case temporaryPassword
        case userId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userId)
        userId = userIdDecoded
        let temporaryPasswordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .temporaryPassword)
        temporaryPassword = temporaryPasswordDecoded
    }
}

extension ResourceNotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.reason = output.reason
        } else {
            self.message = nil
            self.reason = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// One or more resources can't be found.
public struct ResourceNotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?
    public var reason: Swift.String?

    public init (
        message: Swift.String? = nil,
        reason: Swift.String? = nil
    )
    {
        self.message = message
        self.reason = reason
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let reason: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case reason
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reason)
        reason = reasonDecoded
    }
}

extension FinspacedataClientTypes.ResourcePermission: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case permission
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let permission = self.permission {
            try encodeContainer.encode(permission, forKey: .permission)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let permissionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .permission)
        permission = permissionDecoded
    }
}

extension FinspacedataClientTypes {
    /// Resource permission for a dataset. When you create a dataset, all the other members of the same user group inherit access to the dataset. You can only create a dataset if your user group has application permission for Create Datasets. The following is a list of valid dataset permissions that you can apply:
    ///
    /// * ViewDatasetDetails
    ///
    /// * ReadDatasetDetails
    ///
    /// * AddDatasetData
    ///
    /// * CreateDataView
    ///
    /// * EditDatasetMetadata
    ///
    /// * DeleteDataset
    ///
    ///
    /// For more information on the dataset permissions, see [Supported Dataset Permissions](https://docs.aws.amazon.com/finspace/latest/userguide/managing-user-permissions.html#supported-dataset-permissions) in the FinSpace User Guide.
    public struct ResourcePermission: Swift.Equatable {
        /// Permission for a resource.
        public var permission: Swift.String?

        public init (
            permission: Swift.String? = nil
        )
        {
            self.permission = permission
        }
    }

}

extension FinspacedataClientTypes.S3Location: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucket
        case key
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucket = self.bucket {
            try encodeContainer.encode(bucket, forKey: .bucket)
        }
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucket)
        bucket = bucketDecoded
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
    }
}

extension FinspacedataClientTypes {
    /// The location of an external Dataview in an S3 bucket.
    public struct S3Location: Swift.Equatable {
        /// The name of the S3 bucket.
        /// This member is required.
        public var bucket: Swift.String?
        /// The path of the folder, within the S3 bucket that contains the Dataset.
        /// This member is required.
        public var key: Swift.String?

        public init (
            bucket: Swift.String? = nil,
            key: Swift.String? = nil
        )
        {
            self.bucket = bucket
            self.key = key
        }
    }

}

extension FinspacedataClientTypes.SchemaDefinition: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case columns
        case primaryKeyColumns
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let columns = columns {
            var columnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .columns)
            for columndefinition0 in columns {
                try columnsContainer.encode(columndefinition0)
            }
        }
        if let primaryKeyColumns = primaryKeyColumns {
            var primaryKeyColumnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .primaryKeyColumns)
            for columnname0 in primaryKeyColumns {
                try primaryKeyColumnsContainer.encode(columnname0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let columnsContainer = try containerValues.decodeIfPresent([FinspacedataClientTypes.ColumnDefinition?].self, forKey: .columns)
        var columnsDecoded0:[FinspacedataClientTypes.ColumnDefinition]? = nil
        if let columnsContainer = columnsContainer {
            columnsDecoded0 = [FinspacedataClientTypes.ColumnDefinition]()
            for structure0 in columnsContainer {
                if let structure0 = structure0 {
                    columnsDecoded0?.append(structure0)
                }
            }
        }
        columns = columnsDecoded0
        let primaryKeyColumnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .primaryKeyColumns)
        var primaryKeyColumnsDecoded0:[Swift.String]? = nil
        if let primaryKeyColumnsContainer = primaryKeyColumnsContainer {
            primaryKeyColumnsDecoded0 = [Swift.String]()
            for string0 in primaryKeyColumnsContainer {
                if let string0 = string0 {
                    primaryKeyColumnsDecoded0?.append(string0)
                }
            }
        }
        primaryKeyColumns = primaryKeyColumnsDecoded0
    }
}

extension FinspacedataClientTypes {
    /// Definition for a schema on a tabular Dataset.
    public struct SchemaDefinition: Swift.Equatable {
        /// List of column definitions.
        public var columns: [FinspacedataClientTypes.ColumnDefinition]?
        /// List of column names used for primary key.
        public var primaryKeyColumns: [Swift.String]?

        public init (
            columns: [FinspacedataClientTypes.ColumnDefinition]? = nil,
            primaryKeyColumns: [Swift.String]? = nil
        )
        {
            self.columns = columns
            self.primaryKeyColumns = primaryKeyColumns
        }
    }

}

extension FinspacedataClientTypes.SchemaUnion: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tabularSchemaConfig
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tabularSchemaConfig = self.tabularSchemaConfig {
            try encodeContainer.encode(tabularSchemaConfig, forKey: .tabularSchemaConfig)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tabularSchemaConfigDecoded = try containerValues.decodeIfPresent(FinspacedataClientTypes.SchemaDefinition.self, forKey: .tabularSchemaConfig)
        tabularSchemaConfig = tabularSchemaConfigDecoded
    }
}

extension FinspacedataClientTypes {
    /// A union of schema types.
    public struct SchemaUnion: Swift.Equatable {
        /// The configuration for a schema on a tabular Dataset.
        public var tabularSchemaConfig: FinspacedataClientTypes.SchemaDefinition?

        public init (
            tabularSchemaConfig: FinspacedataClientTypes.SchemaDefinition? = nil
        )
        {
            self.tabularSchemaConfig = tabularSchemaConfig
        }
    }

}

extension ThrottlingException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request was denied due to request throttling.
public struct ThrottlingException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client

    public init () { }
}

extension UpdateChangesetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case formatParams
        case sourceParams
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let formatParams = formatParams {
            var formatParamsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .formatParams)
            for (dictKey0, formatParams0) in formatParams {
                try formatParamsContainer.encode(formatParams0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let sourceParams = sourceParams {
            var sourceParamsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .sourceParams)
            for (dictKey0, sourceParams0) in sourceParams {
                try sourceParamsContainer.encode(sourceParams0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension UpdateChangesetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let datasetId = datasetId else {
            return nil
        }
        guard let changesetId = changesetId else {
            return nil
        }
        return "/datasets/\(datasetId.urlPercentEncoding())/changesetsv2/\(changesetId.urlPercentEncoding())"
    }
}

/// Request to update an existing changeset.
public struct UpdateChangesetInput: Swift.Equatable {
    /// The unique identifier for the Changeset to update.
    /// This member is required.
    public var changesetId: Swift.String?
    /// A token that ensures idempotency. This token expires in 10 minutes.
    public var clientToken: Swift.String?
    /// The unique identifier for the FinSpace Dataset in which the Changeset is created.
    /// This member is required.
    public var datasetId: Swift.String?
    /// Options that define the structure of the source file(s) including the format type (formatType), header row (withHeader), data separation character (separator) and the type of compression (compression). formatType is a required attribute and can have the following values:
    ///
    /// * PARQUET – Parquet source file format.
    ///
    /// * CSV – CSV source file format.
    ///
    /// * JSON – JSON source file format.
    ///
    /// * XML – XML source file format.
    ///
    ///
    /// Here is an example of how you could specify the formatParams:  "formatParams": { "formatType": "CSV", "withHeader": "true", "separator": ",", "compression":"None" }  Note that if you only provide formatType as CSV, the rest of the attributes will automatically default to CSV values as following:  { "withHeader": "true", "separator": "," }  For more information about supported file formats, see [Supported Data Types and File Formats](https://docs.aws.amazon.com/finspace/latest/userguide/supported-data-types.html) in the FinSpace User Guide.
    /// This member is required.
    public var formatParams: [Swift.String:Swift.String]?
    /// Options that define the location of the data being ingested (s3SourcePath) and the source of the changeset (sourceType). Both s3SourcePath and sourceType are required attributes. Here is an example of how you could specify the sourceParams:  "sourceParams": { "s3SourcePath": "s3://finspace-landing-us-east-2-bk7gcfvitndqa6ebnvys4d/scratch/wr5hh8pwkpqqkxa4sxrmcw/ingestion/equity.csv", "sourceType": "S3" }  The S3 path that you specify must allow the FinSpace role access. To do that, you first need to configure the IAM policy on S3 bucket. For more information, see [Loading data from an Amazon S3 Bucket using the FinSpace API](https://docs.aws.amazon.com/finspace/latest/data-api/fs-using-the-finspace-api.html#access-s3-buckets)section.
    /// This member is required.
    public var sourceParams: [Swift.String:Swift.String]?

    public init (
        changesetId: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        datasetId: Swift.String? = nil,
        formatParams: [Swift.String:Swift.String]? = nil,
        sourceParams: [Swift.String:Swift.String]? = nil
    )
    {
        self.changesetId = changesetId
        self.clientToken = clientToken
        self.datasetId = datasetId
        self.formatParams = formatParams
        self.sourceParams = sourceParams
    }
}

struct UpdateChangesetInputBody: Swift.Equatable {
    let clientToken: Swift.String?
    let sourceParams: [Swift.String:Swift.String]?
    let formatParams: [Swift.String:Swift.String]?
}

extension UpdateChangesetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case formatParams
        case sourceParams
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let sourceParamsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .sourceParams)
        var sourceParamsDecoded0: [Swift.String:Swift.String]? = nil
        if let sourceParamsContainer = sourceParamsContainer {
            sourceParamsDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringmapvalue0) in sourceParamsContainer {
                if let stringmapvalue0 = stringmapvalue0 {
                    sourceParamsDecoded0?[key0] = stringmapvalue0
                }
            }
        }
        sourceParams = sourceParamsDecoded0
        let formatParamsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .formatParams)
        var formatParamsDecoded0: [Swift.String:Swift.String]? = nil
        if let formatParamsContainer = formatParamsContainer {
            formatParamsDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringmapvalue0) in formatParamsContainer {
                if let stringmapvalue0 = stringmapvalue0 {
                    formatParamsDecoded0?[key0] = stringmapvalue0
                }
            }
        }
        formatParams = formatParamsDecoded0
    }
}

extension UpdateChangesetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateChangesetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateChangesetOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateChangesetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateChangesetOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.changesetId = output.changesetId
            self.datasetId = output.datasetId
        } else {
            self.changesetId = nil
            self.datasetId = nil
        }
    }
}

/// The response from a update changeset operation.
public struct UpdateChangesetOutputResponse: Swift.Equatable {
    /// The unique identifier for the Changeset to update.
    public var changesetId: Swift.String?
    /// The unique identifier for the FinSpace Dataset in which the Changeset is created.
    public var datasetId: Swift.String?

    public init (
        changesetId: Swift.String? = nil,
        datasetId: Swift.String? = nil
    )
    {
        self.changesetId = changesetId
        self.datasetId = datasetId
    }
}

struct UpdateChangesetOutputResponseBody: Swift.Equatable {
    let changesetId: Swift.String?
    let datasetId: Swift.String?
}

extension UpdateChangesetOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case changesetId
        case datasetId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let changesetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .changesetId)
        changesetId = changesetIdDecoded
        let datasetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetId)
        datasetId = datasetIdDecoded
    }
}

extension UpdateDatasetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alias
        case clientToken
        case datasetDescription
        case datasetTitle
        case kind
        case schemaDefinition
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let alias = self.alias {
            try encodeContainer.encode(alias, forKey: .alias)
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let datasetDescription = self.datasetDescription {
            try encodeContainer.encode(datasetDescription, forKey: .datasetDescription)
        }
        if let datasetTitle = self.datasetTitle {
            try encodeContainer.encode(datasetTitle, forKey: .datasetTitle)
        }
        if let kind = self.kind {
            try encodeContainer.encode(kind.rawValue, forKey: .kind)
        }
        if let schemaDefinition = self.schemaDefinition {
            try encodeContainer.encode(schemaDefinition, forKey: .schemaDefinition)
        }
    }
}

extension UpdateDatasetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let datasetId = datasetId else {
            return nil
        }
        return "/datasetsv2/\(datasetId.urlPercentEncoding())"
    }
}

/// The request for an UpdateDataset operation
public struct UpdateDatasetInput: Swift.Equatable {
    /// The unique resource identifier for a Dataset.
    public var alias: Swift.String?
    /// A token that ensures idempotency. This token expires in 10 minutes.
    public var clientToken: Swift.String?
    /// A description for the Dataset.
    public var datasetDescription: Swift.String?
    /// The unique identifier for the Dataset to update.
    /// This member is required.
    public var datasetId: Swift.String?
    /// A display title for the Dataset.
    /// This member is required.
    public var datasetTitle: Swift.String?
    /// The format in which the Dataset data is structured.
    ///
    /// * TABULAR – Data is structured in a tabular format.
    ///
    /// * NON_TABULAR – Data is structured in a non-tabular format.
    /// This member is required.
    public var kind: FinspacedataClientTypes.DatasetKind?
    /// Definition for a schema on a tabular Dataset.
    public var schemaDefinition: FinspacedataClientTypes.SchemaUnion?

    public init (
        alias: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        datasetDescription: Swift.String? = nil,
        datasetId: Swift.String? = nil,
        datasetTitle: Swift.String? = nil,
        kind: FinspacedataClientTypes.DatasetKind? = nil,
        schemaDefinition: FinspacedataClientTypes.SchemaUnion? = nil
    )
    {
        self.alias = alias
        self.clientToken = clientToken
        self.datasetDescription = datasetDescription
        self.datasetId = datasetId
        self.datasetTitle = datasetTitle
        self.kind = kind
        self.schemaDefinition = schemaDefinition
    }
}

struct UpdateDatasetInputBody: Swift.Equatable {
    let clientToken: Swift.String?
    let datasetTitle: Swift.String?
    let kind: FinspacedataClientTypes.DatasetKind?
    let datasetDescription: Swift.String?
    let alias: Swift.String?
    let schemaDefinition: FinspacedataClientTypes.SchemaUnion?
}

extension UpdateDatasetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alias
        case clientToken
        case datasetDescription
        case datasetTitle
        case kind
        case schemaDefinition
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let datasetTitleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetTitle)
        datasetTitle = datasetTitleDecoded
        let kindDecoded = try containerValues.decodeIfPresent(FinspacedataClientTypes.DatasetKind.self, forKey: .kind)
        kind = kindDecoded
        let datasetDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetDescription)
        datasetDescription = datasetDescriptionDecoded
        let aliasDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .alias)
        alias = aliasDecoded
        let schemaDefinitionDecoded = try containerValues.decodeIfPresent(FinspacedataClientTypes.SchemaUnion.self, forKey: .schemaDefinition)
        schemaDefinition = schemaDefinitionDecoded
    }
}

extension UpdateDatasetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateDatasetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateDatasetOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateDatasetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateDatasetOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.datasetId = output.datasetId
        } else {
            self.datasetId = nil
        }
    }
}

/// The response from an UpdateDataset operation
public struct UpdateDatasetOutputResponse: Swift.Equatable {
    /// The unique identifier for updated Dataset.
    public var datasetId: Swift.String?

    public init (
        datasetId: Swift.String? = nil
    )
    {
        self.datasetId = datasetId
    }
}

struct UpdateDatasetOutputResponseBody: Swift.Equatable {
    let datasetId: Swift.String?
}

extension UpdateDatasetOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetId)
        datasetId = datasetIdDecoded
    }
}

extension UpdatePermissionGroupInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdatePermissionGroupInput(applicationPermissions: \(Swift.String(describing: applicationPermissions)), clientToken: \(Swift.String(describing: clientToken)), permissionGroupId: \(Swift.String(describing: permissionGroupId)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension UpdatePermissionGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationPermissions
        case clientToken
        case description
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationPermissions = applicationPermissions {
            var applicationPermissionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .applicationPermissions)
            for applicationpermission0 in applicationPermissions {
                try applicationPermissionsContainer.encode(applicationpermission0.rawValue)
            }
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension UpdatePermissionGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let permissionGroupId = permissionGroupId else {
            return nil
        }
        return "/permission-group/\(permissionGroupId.urlPercentEncoding())"
    }
}

public struct UpdatePermissionGroupInput: Swift.Equatable {
    /// The permissions that are granted to a specific group for accessing the FinSpace application. When assigning application permissions, be aware that the permission ManageUsersAndGroups allows users to grant themselves or others access to any functionality in their FinSpace environment's application. It should only be granted to trusted users.
    ///
    /// * CreateDataset – Group members can create new datasets.
    ///
    /// * ManageClusters – Group members can manage Apache Spark clusters from FinSpace notebooks.
    ///
    /// * ManageUsersAndGroups – Group members can manage users and permission groups. This is a privileged permission that allows users to grant themselves or others access to any functionality in the application. It should only be granted to trusted users.
    ///
    /// * ManageAttributeSets – Group members can manage attribute sets.
    ///
    /// * ViewAuditData – Group members can view audit data.
    ///
    /// * AccessNotebooks – Group members will have access to FinSpace notebooks.
    ///
    /// * GetTemporaryCredentials – Group members can get temporary API credentials.
    public var applicationPermissions: [FinspacedataClientTypes.ApplicationPermission]?
    /// A token that ensures idempotency. This token expires in 10 minutes.
    public var clientToken: Swift.String?
    /// A brief description for the permission group.
    public var description: Swift.String?
    /// The name of the permission group.
    public var name: Swift.String?
    /// The unique identifier for the permission group to update.
    /// This member is required.
    public var permissionGroupId: Swift.String?

    public init (
        applicationPermissions: [FinspacedataClientTypes.ApplicationPermission]? = nil,
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        permissionGroupId: Swift.String? = nil
    )
    {
        self.applicationPermissions = applicationPermissions
        self.clientToken = clientToken
        self.description = description
        self.name = name
        self.permissionGroupId = permissionGroupId
    }
}

struct UpdatePermissionGroupInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let applicationPermissions: [FinspacedataClientTypes.ApplicationPermission]?
    let clientToken: Swift.String?
}

extension UpdatePermissionGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationPermissions
        case clientToken
        case description
        case name
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let applicationPermissionsContainer = try containerValues.decodeIfPresent([FinspacedataClientTypes.ApplicationPermission?].self, forKey: .applicationPermissions)
        var applicationPermissionsDecoded0:[FinspacedataClientTypes.ApplicationPermission]? = nil
        if let applicationPermissionsContainer = applicationPermissionsContainer {
            applicationPermissionsDecoded0 = [FinspacedataClientTypes.ApplicationPermission]()
            for string0 in applicationPermissionsContainer {
                if let string0 = string0 {
                    applicationPermissionsDecoded0?.append(string0)
                }
            }
        }
        applicationPermissions = applicationPermissionsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension UpdatePermissionGroupOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdatePermissionGroupOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdatePermissionGroupOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdatePermissionGroupOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdatePermissionGroupOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.permissionGroupId = output.permissionGroupId
        } else {
            self.permissionGroupId = nil
        }
    }
}

public struct UpdatePermissionGroupOutputResponse: Swift.Equatable {
    /// The unique identifier for the updated permission group.
    public var permissionGroupId: Swift.String?

    public init (
        permissionGroupId: Swift.String? = nil
    )
    {
        self.permissionGroupId = permissionGroupId
    }
}

struct UpdatePermissionGroupOutputResponseBody: Swift.Equatable {
    let permissionGroupId: Swift.String?
}

extension UpdatePermissionGroupOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case permissionGroupId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let permissionGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .permissionGroupId)
        permissionGroupId = permissionGroupIdDecoded
    }
}

extension UpdateUserInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateUserInput(apiAccess: \(Swift.String(describing: apiAccess)), apiAccessPrincipalArn: \(Swift.String(describing: apiAccessPrincipalArn)), clientToken: \(Swift.String(describing: clientToken)), type: \(Swift.String(describing: type)), userId: \(Swift.String(describing: userId)), firstName: \"CONTENT_REDACTED\", lastName: \"CONTENT_REDACTED\")"}
}

extension UpdateUserInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiAccess
        case apiAccessPrincipalArn
        case clientToken
        case firstName
        case lastName
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let apiAccess = self.apiAccess {
            try encodeContainer.encode(apiAccess.rawValue, forKey: .apiAccess)
        }
        if let apiAccessPrincipalArn = self.apiAccessPrincipalArn {
            try encodeContainer.encode(apiAccessPrincipalArn, forKey: .apiAccessPrincipalArn)
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let firstName = self.firstName {
            try encodeContainer.encode(firstName, forKey: .firstName)
        }
        if let lastName = self.lastName {
            try encodeContainer.encode(lastName, forKey: .lastName)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

extension UpdateUserInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let userId = userId else {
            return nil
        }
        return "/user/\(userId.urlPercentEncoding())"
    }
}

public struct UpdateUserInput: Swift.Equatable {
    /// The option to indicate whether the user can use the GetProgrammaticAccessCredentials API to obtain credentials that can then be used to access other FinSpace Data API operations.
    ///
    /// * ENABLED – The user has permissions to use the APIs.
    ///
    /// * DISABLED – The user does not have permissions to use any APIs.
    public var apiAccess: FinspacedataClientTypes.ApiAccess?
    /// The ARN identifier of an AWS user or role that is allowed to call the GetProgrammaticAccessCredentials API to obtain a credentials token for a specific FinSpace user. This must be an IAM role within your FinSpace account.
    public var apiAccessPrincipalArn: Swift.String?
    /// A token that ensures idempotency. This token expires in 10 minutes.
    public var clientToken: Swift.String?
    /// The first name of the user.
    public var firstName: Swift.String?
    /// The last name of the user.
    public var lastName: Swift.String?
    /// The option to indicate the type of user.
    ///
    /// * SUPER_USER– A user with permission to all the functionality and data in FinSpace.
    ///
    /// * APP_USER – A user with specific permissions in FinSpace. The users are assigned permissions by adding them to a permission group.
    public var type: FinspacedataClientTypes.UserType?
    /// The unique identifier for the user account to update.
    /// This member is required.
    public var userId: Swift.String?

    public init (
        apiAccess: FinspacedataClientTypes.ApiAccess? = nil,
        apiAccessPrincipalArn: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        firstName: Swift.String? = nil,
        lastName: Swift.String? = nil,
        type: FinspacedataClientTypes.UserType? = nil,
        userId: Swift.String? = nil
    )
    {
        self.apiAccess = apiAccess
        self.apiAccessPrincipalArn = apiAccessPrincipalArn
        self.clientToken = clientToken
        self.firstName = firstName
        self.lastName = lastName
        self.type = type
        self.userId = userId
    }
}

struct UpdateUserInputBody: Swift.Equatable {
    let type: FinspacedataClientTypes.UserType?
    let firstName: Swift.String?
    let lastName: Swift.String?
    let apiAccess: FinspacedataClientTypes.ApiAccess?
    let apiAccessPrincipalArn: Swift.String?
    let clientToken: Swift.String?
}

extension UpdateUserInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiAccess
        case apiAccessPrincipalArn
        case clientToken
        case firstName
        case lastName
        case type
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(FinspacedataClientTypes.UserType.self, forKey: .type)
        type = typeDecoded
        let firstNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .firstName)
        firstName = firstNameDecoded
        let lastNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastName)
        lastName = lastNameDecoded
        let apiAccessDecoded = try containerValues.decodeIfPresent(FinspacedataClientTypes.ApiAccess.self, forKey: .apiAccess)
        apiAccess = apiAccessDecoded
        let apiAccessPrincipalArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiAccessPrincipalArn)
        apiAccessPrincipalArn = apiAccessPrincipalArnDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension UpdateUserOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateUserOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceNotFoundException" : self = .resourceNotFoundException(try ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateUserOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case resourceNotFoundException(ResourceNotFoundException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateUserOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateUserOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.userId = output.userId
        } else {
            self.userId = nil
        }
    }
}

public struct UpdateUserOutputResponse: Swift.Equatable {
    /// The unique identifier of the updated user account.
    public var userId: Swift.String?

    public init (
        userId: Swift.String? = nil
    )
    {
        self.userId = userId
    }
}

struct UpdateUserOutputResponseBody: Swift.Equatable {
    let userId: Swift.String?
}

extension UpdateUserOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case userId
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userId)
        userId = userIdDecoded
    }
}

extension FinspacedataClientTypes.User: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiAccess
        case apiAccessPrincipalArn
        case createTime
        case emailAddress
        case firstName
        case lastDisabledTime
        case lastEnabledTime
        case lastLoginTime
        case lastModifiedTime
        case lastName
        case status
        case type
        case userId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let apiAccess = self.apiAccess {
            try encodeContainer.encode(apiAccess.rawValue, forKey: .apiAccess)
        }
        if let apiAccessPrincipalArn = self.apiAccessPrincipalArn {
            try encodeContainer.encode(apiAccessPrincipalArn, forKey: .apiAccessPrincipalArn)
        }
        if createTime != 0 {
            try encodeContainer.encode(createTime, forKey: .createTime)
        }
        if let emailAddress = self.emailAddress {
            try encodeContainer.encode(emailAddress, forKey: .emailAddress)
        }
        if let firstName = self.firstName {
            try encodeContainer.encode(firstName, forKey: .firstName)
        }
        if lastDisabledTime != 0 {
            try encodeContainer.encode(lastDisabledTime, forKey: .lastDisabledTime)
        }
        if lastEnabledTime != 0 {
            try encodeContainer.encode(lastEnabledTime, forKey: .lastEnabledTime)
        }
        if lastLoginTime != 0 {
            try encodeContainer.encode(lastLoginTime, forKey: .lastLoginTime)
        }
        if lastModifiedTime != 0 {
            try encodeContainer.encode(lastModifiedTime, forKey: .lastModifiedTime)
        }
        if let lastName = self.lastName {
            try encodeContainer.encode(lastName, forKey: .lastName)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let userId = self.userId {
            try encodeContainer.encode(userId, forKey: .userId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userId)
        userId = userIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(FinspacedataClientTypes.UserStatus.self, forKey: .status)
        status = statusDecoded
        let firstNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .firstName)
        firstName = firstNameDecoded
        let lastNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastName)
        lastName = lastNameDecoded
        let emailAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .emailAddress)
        emailAddress = emailAddressDecoded
        let typeDecoded = try containerValues.decodeIfPresent(FinspacedataClientTypes.UserType.self, forKey: .type)
        type = typeDecoded
        let apiAccessDecoded = try containerValues.decodeIfPresent(FinspacedataClientTypes.ApiAccess.self, forKey: .apiAccess)
        apiAccess = apiAccessDecoded
        let apiAccessPrincipalArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiAccessPrincipalArn)
        apiAccessPrincipalArn = apiAccessPrincipalArnDecoded
        let createTimeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .createTime) ?? 0
        createTime = createTimeDecoded
        let lastEnabledTimeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .lastEnabledTime) ?? 0
        lastEnabledTime = lastEnabledTimeDecoded
        let lastDisabledTimeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .lastDisabledTime) ?? 0
        lastDisabledTime = lastDisabledTimeDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .lastModifiedTime) ?? 0
        lastModifiedTime = lastModifiedTimeDecoded
        let lastLoginTimeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .lastLoginTime) ?? 0
        lastLoginTime = lastLoginTimeDecoded
    }
}

extension FinspacedataClientTypes.User: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "User(apiAccess: \(Swift.String(describing: apiAccess)), apiAccessPrincipalArn: \(Swift.String(describing: apiAccessPrincipalArn)), createTime: \(Swift.String(describing: createTime)), lastDisabledTime: \(Swift.String(describing: lastDisabledTime)), lastEnabledTime: \(Swift.String(describing: lastEnabledTime)), lastLoginTime: \(Swift.String(describing: lastLoginTime)), lastModifiedTime: \(Swift.String(describing: lastModifiedTime)), status: \(Swift.String(describing: status)), type: \(Swift.String(describing: type)), userId: \(Swift.String(describing: userId)), emailAddress: \"CONTENT_REDACTED\", firstName: \"CONTENT_REDACTED\", lastName: \"CONTENT_REDACTED\")"}
}

extension FinspacedataClientTypes {
    /// The details of the user account.
    public struct User: Swift.Equatable {
        /// Indicates whether the user can use the GetProgrammaticAccessCredentials API to obtain credentials that can then be used to access other FinSpace Data API operations.
        ///
        /// * ENABLED – The user has permissions to use the APIs.
        ///
        /// * DISABLED – The user does not have permissions to use any APIs.
        public var apiAccess: FinspacedataClientTypes.ApiAccess?
        /// The ARN identifier of an AWS user or role that is allowed to call the GetProgrammaticAccessCredentials API to obtain a credentials token for a specific FinSpace user. This must be an IAM role within your FinSpace account.
        public var apiAccessPrincipalArn: Swift.String?
        /// The timestamp at which the user account was created in FinSpace. The value is determined as epoch time in milliseconds.
        public var createTime: Swift.Int
        /// The email address of the user. The email address serves as a uniquer identifier for each user and cannot be changed after it's created.
        public var emailAddress: Swift.String?
        /// The first name of the user.
        public var firstName: Swift.String?
        /// Describes the last time the user account was disabled. The value is determined as epoch time in milliseconds.
        public var lastDisabledTime: Swift.Int
        /// Describes the last time the user account was enabled. The value is determined as epoch time in milliseconds.
        public var lastEnabledTime: Swift.Int
        /// Describes the last time that the user logged into their account. The value is determined as epoch time in milliseconds.
        public var lastLoginTime: Swift.Int
        /// Describes the last time the user account was updated. The value is determined as epoch time in milliseconds.
        public var lastModifiedTime: Swift.Int
        /// The last name of the user.
        public var lastName: Swift.String?
        /// The current status of the user account.
        ///
        /// * CREATING – The user account creation is in progress.
        ///
        /// * ENABLED – The user account is created and is currently active.
        ///
        /// * DISABLED – The user account is currently inactive.
        public var status: FinspacedataClientTypes.UserStatus?
        /// Indicates the type of user.
        ///
        /// * SUPER_USER – A user with permission to all the functionality and data in FinSpace.
        ///
        /// * APP_USER – A user with specific permissions in FinSpace. The users are assigned permissions by adding them to a permission group.
        public var type: FinspacedataClientTypes.UserType?
        /// The unique identifier for the user.
        public var userId: Swift.String?

        public init (
            apiAccess: FinspacedataClientTypes.ApiAccess? = nil,
            apiAccessPrincipalArn: Swift.String? = nil,
            createTime: Swift.Int = 0,
            emailAddress: Swift.String? = nil,
            firstName: Swift.String? = nil,
            lastDisabledTime: Swift.Int = 0,
            lastEnabledTime: Swift.Int = 0,
            lastLoginTime: Swift.Int = 0,
            lastModifiedTime: Swift.Int = 0,
            lastName: Swift.String? = nil,
            status: FinspacedataClientTypes.UserStatus? = nil,
            type: FinspacedataClientTypes.UserType? = nil,
            userId: Swift.String? = nil
        )
        {
            self.apiAccess = apiAccess
            self.apiAccessPrincipalArn = apiAccessPrincipalArn
            self.createTime = createTime
            self.emailAddress = emailAddress
            self.firstName = firstName
            self.lastDisabledTime = lastDisabledTime
            self.lastEnabledTime = lastEnabledTime
            self.lastLoginTime = lastLoginTime
            self.lastModifiedTime = lastModifiedTime
            self.lastName = lastName
            self.status = status
            self.type = type
            self.userId = userId
        }
    }

}

extension FinspacedataClientTypes.UserByPermissionGroup: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiAccess
        case apiAccessPrincipalArn
        case emailAddress
        case firstName
        case lastName
        case membershipStatus
        case status
        case type
        case userId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let apiAccess = self.apiAccess {
            try encodeContainer.encode(apiAccess.rawValue, forKey: .apiAccess)
        }
        if let apiAccessPrincipalArn = self.apiAccessPrincipalArn {
            try encodeContainer.encode(apiAccessPrincipalArn, forKey: .apiAccessPrincipalArn)
        }
        if let emailAddress = self.emailAddress {
            try encodeContainer.encode(emailAddress, forKey: .emailAddress)
        }
        if let firstName = self.firstName {
            try encodeContainer.encode(firstName, forKey: .firstName)
        }
        if let lastName = self.lastName {
            try encodeContainer.encode(lastName, forKey: .lastName)
        }
        if let membershipStatus = self.membershipStatus {
            try encodeContainer.encode(membershipStatus.rawValue, forKey: .membershipStatus)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let userId = self.userId {
            try encodeContainer.encode(userId, forKey: .userId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userId)
        userId = userIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(FinspacedataClientTypes.UserStatus.self, forKey: .status)
        status = statusDecoded
        let firstNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .firstName)
        firstName = firstNameDecoded
        let lastNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastName)
        lastName = lastNameDecoded
        let emailAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .emailAddress)
        emailAddress = emailAddressDecoded
        let typeDecoded = try containerValues.decodeIfPresent(FinspacedataClientTypes.UserType.self, forKey: .type)
        type = typeDecoded
        let apiAccessDecoded = try containerValues.decodeIfPresent(FinspacedataClientTypes.ApiAccess.self, forKey: .apiAccess)
        apiAccess = apiAccessDecoded
        let apiAccessPrincipalArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiAccessPrincipalArn)
        apiAccessPrincipalArn = apiAccessPrincipalArnDecoded
        let membershipStatusDecoded = try containerValues.decodeIfPresent(FinspacedataClientTypes.PermissionGroupMembershipStatus.self, forKey: .membershipStatus)
        membershipStatus = membershipStatusDecoded
    }
}

extension FinspacedataClientTypes.UserByPermissionGroup: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UserByPermissionGroup(apiAccess: \(Swift.String(describing: apiAccess)), apiAccessPrincipalArn: \(Swift.String(describing: apiAccessPrincipalArn)), membershipStatus: \(Swift.String(describing: membershipStatus)), status: \(Swift.String(describing: status)), type: \(Swift.String(describing: type)), userId: \(Swift.String(describing: userId)), emailAddress: \"CONTENT_REDACTED\", firstName: \"CONTENT_REDACTED\", lastName: \"CONTENT_REDACTED\")"}
}

extension FinspacedataClientTypes {
    /// The structure of a user account associated with a permission group.
    public struct UserByPermissionGroup: Swift.Equatable {
        /// Indicates whether the user can access FinSpace API operations.
        ///
        /// * ENABLED – The user has permissions to use the API operations.
        ///
        /// * DISABLED – The user does not have permissions to use any API operations.
        public var apiAccess: FinspacedataClientTypes.ApiAccess?
        /// The IAM ARN identifier that is attached to FinSpace API calls.
        public var apiAccessPrincipalArn: Swift.String?
        /// The email address of the user. The email address serves as a unique identifier for each user and cannot be changed after it's created.
        public var emailAddress: Swift.String?
        /// The first name of the user.
        public var firstName: Swift.String?
        /// The last name of the user.
        public var lastName: Swift.String?
        /// Indicates the status of the user account within a permission group.
        ///
        /// * ADDITION_IN_PROGRESS – The user account is currently being added to the permission group.
        ///
        /// * ADDITION_SUCCESS – The user account is successfully added to the permission group.
        ///
        /// * REMOVAL_IN_PROGRESS – The user is currently being removed from the permission group.
        public var membershipStatus: FinspacedataClientTypes.PermissionGroupMembershipStatus?
        /// The current status of the user account.
        ///
        /// * CREATING – The user account creation is in progress.
        ///
        /// * ENABLED – The user account is created and is currently active.
        ///
        /// * DISABLED – The user account is currently inactive.
        public var status: FinspacedataClientTypes.UserStatus?
        /// Indicates the type of user.
        ///
        /// * SUPER_USER – A user with permission to all the functionality and data in FinSpace.
        ///
        /// * APP_USER – A user with specific permissions in FinSpace. The users are assigned permissions by adding them to a permission group.
        public var type: FinspacedataClientTypes.UserType?
        /// The unique identifier for the user.
        public var userId: Swift.String?

        public init (
            apiAccess: FinspacedataClientTypes.ApiAccess? = nil,
            apiAccessPrincipalArn: Swift.String? = nil,
            emailAddress: Swift.String? = nil,
            firstName: Swift.String? = nil,
            lastName: Swift.String? = nil,
            membershipStatus: FinspacedataClientTypes.PermissionGroupMembershipStatus? = nil,
            status: FinspacedataClientTypes.UserStatus? = nil,
            type: FinspacedataClientTypes.UserType? = nil,
            userId: Swift.String? = nil
        )
        {
            self.apiAccess = apiAccess
            self.apiAccessPrincipalArn = apiAccessPrincipalArn
            self.emailAddress = emailAddress
            self.firstName = firstName
            self.lastName = lastName
            self.membershipStatus = membershipStatus
            self.status = status
            self.type = type
            self.userId = userId
        }
    }

}

extension FinspacedataClientTypes {
    public enum UserStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case creating
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [UserStatus] {
            return [
                .creating,
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .creating: return "CREATING"
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = UserStatus(rawValue: rawValue) ?? UserStatus.sdkUnknown(rawValue)
        }
    }
}

extension FinspacedataClientTypes {
    public enum UserType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case appUser
        case superUser
        case sdkUnknown(Swift.String)

        public static var allCases: [UserType] {
            return [
                .appUser,
                .superUser,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .appUser: return "APP_USER"
            case .superUser: return "SUPER_USER"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = UserType(rawValue: rawValue) ?? UserType.sdkUnknown(rawValue)
        }
    }
}

extension ValidationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.reason = output.reason
        } else {
            self.message = nil
            self.reason = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The input fails to satisfy the constraints specified by an AWS service.
public struct ValidationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?
    public var reason: Swift.String?

    public init (
        message: Swift.String? = nil,
        reason: Swift.String? = nil
    )
    {
        self.message = message
        self.reason = reason
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let reason: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case reason
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reason)
        reason = reasonDecoded
    }
}
