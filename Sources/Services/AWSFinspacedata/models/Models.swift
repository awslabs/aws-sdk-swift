// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// You do not have sufficient access to perform this action.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension FinspacedataClientTypes {
    public enum ApiAccess: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [ApiAccess] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ApiAccess(rawValue: rawValue) ?? ApiAccess.sdkUnknown(rawValue)
        }
    }
}

extension FinspacedataClientTypes {
    public enum ApplicationPermission: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case accessnotebooks
        case createdataset
        case gettemporarycredentials
        case manageattributesets
        case manageclusters
        case manageusersandgroups
        case viewauditdata
        case sdkUnknown(Swift.String)

        public static var allCases: [ApplicationPermission] {
            return [
                .accessnotebooks,
                .createdataset,
                .gettemporarycredentials,
                .manageattributesets,
                .manageclusters,
                .manageusersandgroups,
                .viewauditdata,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .accessnotebooks: return "AccessNotebooks"
            case .createdataset: return "CreateDataset"
            case .gettemporarycredentials: return "GetTemporaryCredentials"
            case .manageattributesets: return "ManageAttributeSets"
            case .manageclusters: return "ManageClusters"
            case .manageusersandgroups: return "ManageUsersAndGroups"
            case .viewauditdata: return "ViewAuditData"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ApplicationPermission(rawValue: rawValue) ?? ApplicationPermission.sdkUnknown(rawValue)
        }
    }
}

extension AssociateUserToPermissionGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
    }
}

extension AssociateUserToPermissionGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let permissionGroupId = permissionGroupId else {
            return nil
        }
        guard let userId = userId else {
            return nil
        }
        return "/permission-group/\(permissionGroupId.urlPercentEncoding())/users/\(userId.urlPercentEncoding())"
    }
}

public struct AssociateUserToPermissionGroupInput: Swift.Equatable {
    /// A token that ensures idempotency. This token expires in 10 minutes.
    public var clientToken: Swift.String?
    /// The unique identifier for the permission group.
    /// This member is required.
    public var permissionGroupId: Swift.String?
    /// The unique identifier for the user.
    /// This member is required.
    public var userId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        permissionGroupId: Swift.String? = nil,
        userId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.permissionGroupId = permissionGroupId
        self.userId = userId
    }
}

struct AssociateUserToPermissionGroupInputBody: Swift.Equatable {
    let clientToken: Swift.String?
}

extension AssociateUserToPermissionGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension AssociateUserToPermissionGroupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        self.statusCode = httpResponse.statusCode.rawValue
    }
}

public struct AssociateUserToPermissionGroupOutput: Swift.Equatable {
    /// The returned status code of the response.
    public var statusCode: Swift.Int

    public init(
        statusCode: Swift.Int = 0
    )
    {
        self.statusCode = statusCode
    }
}

struct AssociateUserToPermissionGroupOutputBody: Swift.Equatable {
    let statusCode: Swift.Int
}

extension AssociateUserToPermissionGroupOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case statusCode
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusCodeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .statusCode) ?? 0
        statusCode = statusCodeDecoded
    }
}

enum AssociateUserToPermissionGroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension FinspacedataClientTypes.AwsCredentials: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessKeyId
        case expiration
        case secretAccessKey
        case sessionToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessKeyId = self.accessKeyId {
            try encodeContainer.encode(accessKeyId, forKey: .accessKeyId)
        }
        if expiration != 0 {
            try encodeContainer.encode(expiration, forKey: .expiration)
        }
        if let secretAccessKey = self.secretAccessKey {
            try encodeContainer.encode(secretAccessKey, forKey: .secretAccessKey)
        }
        if let sessionToken = self.sessionToken {
            try encodeContainer.encode(sessionToken, forKey: .sessionToken)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accessKeyId)
        accessKeyId = accessKeyIdDecoded
        let secretAccessKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretAccessKey)
        secretAccessKey = secretAccessKeyDecoded
        let sessionTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sessionToken)
        sessionToken = sessionTokenDecoded
        let expirationDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .expiration) ?? 0
        expiration = expirationDecoded
    }
}

extension FinspacedataClientTypes.AwsCredentials: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension FinspacedataClientTypes {
    /// The credentials required to access the external Dataview from the S3 location.
    public struct AwsCredentials: Swift.Equatable {
        /// The unique identifier for the security credentials.
        public var accessKeyId: Swift.String?
        /// The Epoch time when the current credentials expire.
        public var expiration: Swift.Int
        /// The secret access key that can be used to sign requests.
        public var secretAccessKey: Swift.String?
        /// The token that users must pass to use the credentials.
        public var sessionToken: Swift.String?

        public init(
            accessKeyId: Swift.String? = nil,
            expiration: Swift.Int = 0,
            secretAccessKey: Swift.String? = nil,
            sessionToken: Swift.String? = nil
        )
        {
            self.accessKeyId = accessKeyId
            self.expiration = expiration
            self.secretAccessKey = secretAccessKey
            self.sessionToken = sessionToken
        }
    }

}

extension FinspacedataClientTypes {
    /// Indicates how the given change will be applied to the dataset.
    public enum ChangeType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case append
        case modify
        case replace
        case sdkUnknown(Swift.String)

        public static var allCases: [ChangeType] {
            return [
                .append,
                .modify,
                .replace,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .append: return "APPEND"
            case .modify: return "MODIFY"
            case .replace: return "REPLACE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ChangeType(rawValue: rawValue) ?? ChangeType.sdkUnknown(rawValue)
        }
    }
}

extension FinspacedataClientTypes.ChangesetErrorInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCategory
        case errorMessage
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCategory = self.errorCategory {
            try encodeContainer.encode(errorCategory.rawValue, forKey: .errorCategory)
        }
        if let errorMessage = self.errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
        let errorCategoryDecoded = try containerValues.decodeIfPresent(FinspacedataClientTypes.ErrorCategory.self, forKey: .errorCategory)
        errorCategory = errorCategoryDecoded
    }
}

extension FinspacedataClientTypes {
    /// The structure with error messages.
    public struct ChangesetErrorInfo: Swift.Equatable {
        /// The category of the error.
        ///
        /// * VALIDATION – The inputs to this request are invalid.
        ///
        /// * SERVICE_QUOTA_EXCEEDED – Service quotas have been exceeded. Please contact AWS support to increase quotas.
        ///
        /// * ACCESS_DENIED – Missing required permission to perform this request.
        ///
        /// * RESOURCE_NOT_FOUND – One or more inputs to this request were not found.
        ///
        /// * THROTTLING – The system temporarily lacks sufficient resources to process the request.
        ///
        /// * INTERNAL_SERVICE_EXCEPTION – An internal service error has occurred.
        ///
        /// * CANCELLED – Cancelled.
        ///
        /// * USER_RECOVERABLE – A user recoverable error has occurred.
        public var errorCategory: FinspacedataClientTypes.ErrorCategory?
        /// The text of the error message.
        public var errorMessage: Swift.String?

        public init(
            errorCategory: FinspacedataClientTypes.ErrorCategory? = nil,
            errorMessage: Swift.String? = nil
        )
        {
            self.errorCategory = errorCategory
            self.errorMessage = errorMessage
        }
    }

}

extension FinspacedataClientTypes.ChangesetSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case activeFromTimestamp
        case activeUntilTimestamp
        case changeType
        case changesetArn
        case changesetId
        case createTime
        case datasetId
        case errorInfo
        case formatParams
        case sourceParams
        case status
        case updatedByChangesetId
        case updatesChangesetId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let activeFromTimestamp = self.activeFromTimestamp {
            try encodeContainer.encode(activeFromTimestamp, forKey: .activeFromTimestamp)
        }
        if let activeUntilTimestamp = self.activeUntilTimestamp {
            try encodeContainer.encode(activeUntilTimestamp, forKey: .activeUntilTimestamp)
        }
        if let changeType = self.changeType {
            try encodeContainer.encode(changeType.rawValue, forKey: .changeType)
        }
        if let changesetArn = self.changesetArn {
            try encodeContainer.encode(changesetArn, forKey: .changesetArn)
        }
        if let changesetId = self.changesetId {
            try encodeContainer.encode(changesetId, forKey: .changesetId)
        }
        if createTime != 0 {
            try encodeContainer.encode(createTime, forKey: .createTime)
        }
        if let datasetId = self.datasetId {
            try encodeContainer.encode(datasetId, forKey: .datasetId)
        }
        if let errorInfo = self.errorInfo {
            try encodeContainer.encode(errorInfo, forKey: .errorInfo)
        }
        if let formatParams = formatParams {
            var formatParamsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .formatParams)
            for (dictKey0, formatParams0) in formatParams {
                try formatParamsContainer.encode(formatParams0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let sourceParams = sourceParams {
            var sourceParamsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .sourceParams)
            for (dictKey0, sourceParams0) in sourceParams {
                try sourceParamsContainer.encode(sourceParams0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let updatedByChangesetId = self.updatedByChangesetId {
            try encodeContainer.encode(updatedByChangesetId, forKey: .updatedByChangesetId)
        }
        if let updatesChangesetId = self.updatesChangesetId {
            try encodeContainer.encode(updatesChangesetId, forKey: .updatesChangesetId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let changesetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .changesetId)
        changesetId = changesetIdDecoded
        let changesetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .changesetArn)
        changesetArn = changesetArnDecoded
        let datasetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetId)
        datasetId = datasetIdDecoded
        let changeTypeDecoded = try containerValues.decodeIfPresent(FinspacedataClientTypes.ChangeType.self, forKey: .changeType)
        changeType = changeTypeDecoded
        let sourceParamsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .sourceParams)
        var sourceParamsDecoded0: [Swift.String:Swift.String]? = nil
        if let sourceParamsContainer = sourceParamsContainer {
            sourceParamsDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringmapvalue0) in sourceParamsContainer {
                if let stringmapvalue0 = stringmapvalue0 {
                    sourceParamsDecoded0?[key0] = stringmapvalue0
                }
            }
        }
        sourceParams = sourceParamsDecoded0
        let formatParamsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .formatParams)
        var formatParamsDecoded0: [Swift.String:Swift.String]? = nil
        if let formatParamsContainer = formatParamsContainer {
            formatParamsDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringmapvalue0) in formatParamsContainer {
                if let stringmapvalue0 = stringmapvalue0 {
                    formatParamsDecoded0?[key0] = stringmapvalue0
                }
            }
        }
        formatParams = formatParamsDecoded0
        let createTimeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .createTime) ?? 0
        createTime = createTimeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(FinspacedataClientTypes.IngestionStatus.self, forKey: .status)
        status = statusDecoded
        let errorInfoDecoded = try containerValues.decodeIfPresent(FinspacedataClientTypes.ChangesetErrorInfo.self, forKey: .errorInfo)
        errorInfo = errorInfoDecoded
        let activeUntilTimestampDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .activeUntilTimestamp)
        activeUntilTimestamp = activeUntilTimestampDecoded
        let activeFromTimestampDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .activeFromTimestamp)
        activeFromTimestamp = activeFromTimestampDecoded
        let updatesChangesetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .updatesChangesetId)
        updatesChangesetId = updatesChangesetIdDecoded
        let updatedByChangesetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .updatedByChangesetId)
        updatedByChangesetId = updatedByChangesetIdDecoded
    }
}

extension FinspacedataClientTypes {
    /// A Changeset is unit of data in a Dataset.
    public struct ChangesetSummary: Swift.Equatable {
        /// Beginning time from which the Changeset is active. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
        public var activeFromTimestamp: Swift.Int?
        /// Time until which the Changeset is active. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
        public var activeUntilTimestamp: Swift.Int?
        /// Type that indicates how a Changeset is applied to a Dataset.
        ///
        /// * REPLACE – Changeset is considered as a replacement to all prior loaded Changesets.
        ///
        /// * APPEND – Changeset is considered as an addition to the end of all prior loaded Changesets.
        ///
        /// * MODIFY – Changeset is considered as a replacement to a specific prior ingested Changeset.
        public var changeType: FinspacedataClientTypes.ChangeType?
        /// The ARN identifier of the Changeset.
        public var changesetArn: Swift.String?
        /// The unique identifier for a Changeset.
        public var changesetId: Swift.String?
        /// The timestamp at which the Changeset was created in FinSpace. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
        public var createTime: Swift.Int
        /// The unique identifier for the FinSpace Dataset in which the Changeset is created.
        public var datasetId: Swift.String?
        /// The structure with error messages.
        public var errorInfo: FinspacedataClientTypes.ChangesetErrorInfo?
        /// Options that define the structure of the source file(s).
        public var formatParams: [Swift.String:Swift.String]?
        /// Options that define the location of the data being ingested.
        public var sourceParams: [Swift.String:Swift.String]?
        /// Status of the Changeset ingestion.
        ///
        /// * PENDING – Changeset is pending creation.
        ///
        /// * FAILED – Changeset creation has failed.
        ///
        /// * SUCCESS – Changeset creation has succeeded.
        ///
        /// * RUNNING – Changeset creation is running.
        ///
        /// * STOP_REQUESTED – User requested Changeset creation to stop.
        public var status: FinspacedataClientTypes.IngestionStatus?
        /// The unique identifier of the updated Changeset.
        public var updatedByChangesetId: Swift.String?
        /// The unique identifier of the Changeset that is updated.
        public var updatesChangesetId: Swift.String?

        public init(
            activeFromTimestamp: Swift.Int? = nil,
            activeUntilTimestamp: Swift.Int? = nil,
            changeType: FinspacedataClientTypes.ChangeType? = nil,
            changesetArn: Swift.String? = nil,
            changesetId: Swift.String? = nil,
            createTime: Swift.Int = 0,
            datasetId: Swift.String? = nil,
            errorInfo: FinspacedataClientTypes.ChangesetErrorInfo? = nil,
            formatParams: [Swift.String:Swift.String]? = nil,
            sourceParams: [Swift.String:Swift.String]? = nil,
            status: FinspacedataClientTypes.IngestionStatus? = nil,
            updatedByChangesetId: Swift.String? = nil,
            updatesChangesetId: Swift.String? = nil
        )
        {
            self.activeFromTimestamp = activeFromTimestamp
            self.activeUntilTimestamp = activeUntilTimestamp
            self.changeType = changeType
            self.changesetArn = changesetArn
            self.changesetId = changesetId
            self.createTime = createTime
            self.datasetId = datasetId
            self.errorInfo = errorInfo
            self.formatParams = formatParams
            self.sourceParams = sourceParams
            self.status = status
            self.updatedByChangesetId = updatedByChangesetId
            self.updatesChangesetId = updatesChangesetId
        }
    }

}

extension FinspacedataClientTypes {
    /// Data type of a column.
    public enum ColumnDataType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case bigint
        case binary
        case boolean
        case char
        case date
        case datetime
        case double
        case float
        case integer
        case smallint
        case string
        case tinyint
        case sdkUnknown(Swift.String)

        public static var allCases: [ColumnDataType] {
            return [
                .bigint,
                .binary,
                .boolean,
                .char,
                .date,
                .datetime,
                .double,
                .float,
                .integer,
                .smallint,
                .string,
                .tinyint,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .bigint: return "BIGINT"
            case .binary: return "BINARY"
            case .boolean: return "BOOLEAN"
            case .char: return "CHAR"
            case .date: return "DATE"
            case .datetime: return "DATETIME"
            case .double: return "DOUBLE"
            case .float: return "FLOAT"
            case .integer: return "INTEGER"
            case .smallint: return "SMALLINT"
            case .string: return "STRING"
            case .tinyint: return "TINYINT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ColumnDataType(rawValue: rawValue) ?? ColumnDataType.sdkUnknown(rawValue)
        }
    }
}

extension FinspacedataClientTypes.ColumnDefinition: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case columnDescription
        case columnName
        case dataType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let columnDescription = self.columnDescription {
            try encodeContainer.encode(columnDescription, forKey: .columnDescription)
        }
        if let columnName = self.columnName {
            try encodeContainer.encode(columnName, forKey: .columnName)
        }
        if let dataType = self.dataType {
            try encodeContainer.encode(dataType.rawValue, forKey: .dataType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataTypeDecoded = try containerValues.decodeIfPresent(FinspacedataClientTypes.ColumnDataType.self, forKey: .dataType)
        dataType = dataTypeDecoded
        let columnNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .columnName)
        columnName = columnNameDecoded
        let columnDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .columnDescription)
        columnDescription = columnDescriptionDecoded
    }
}

extension FinspacedataClientTypes {
    /// The definition of a column in a tabular Dataset.
    public struct ColumnDefinition: Swift.Equatable {
        /// Description for a column.
        public var columnDescription: Swift.String?
        /// The name of a column.
        public var columnName: Swift.String?
        /// Data type of a column.
        ///
        /// * STRING – A String data type. CHAR – A char data type. INTEGER – An integer data type. TINYINT – A tinyint data type. SMALLINT – A smallint data type. BIGINT – A bigint data type. FLOAT – A float data type. DOUBLE – A double data type. DATE – A date data type. DATETIME – A datetime data type. BOOLEAN – A boolean data type. BINARY – A binary data type.
        public var dataType: FinspacedataClientTypes.ColumnDataType?

        public init(
            columnDescription: Swift.String? = nil,
            columnName: Swift.String? = nil,
            dataType: FinspacedataClientTypes.ColumnDataType? = nil
        )
        {
            self.columnDescription = columnDescription
            self.columnName = columnName
            self.dataType = dataType
        }
    }

}

extension ConflictException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.reason = output.reason
        } else {
            self.properties.message = nil
            self.properties.reason = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request conflicts with an existing resource.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        public internal(set) var reason: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        reason: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.reason = reason
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let reason: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case reason
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reason)
        reason = reasonDecoded
    }
}

extension CreateChangesetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case changeType
        case clientToken
        case formatParams
        case sourceParams
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let changeType = self.changeType {
            try encodeContainer.encode(changeType.rawValue, forKey: .changeType)
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let formatParams = formatParams {
            var formatParamsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .formatParams)
            for (dictKey0, formatParams0) in formatParams {
                try formatParamsContainer.encode(formatParams0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let sourceParams = sourceParams {
            var sourceParamsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .sourceParams)
            for (dictKey0, sourceParams0) in sourceParams {
                try sourceParamsContainer.encode(sourceParams0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateChangesetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let datasetId = datasetId else {
            return nil
        }
        return "/datasets/\(datasetId.urlPercentEncoding())/changesetsv2"
    }
}

/// The request for a CreateChangeset operation.
public struct CreateChangesetInput: Swift.Equatable {
    /// The option to indicate how a Changeset will be applied to a Dataset.
    ///
    /// * REPLACE – Changeset will be considered as a replacement to all prior loaded Changesets.
    ///
    /// * APPEND – Changeset will be considered as an addition to the end of all prior loaded Changesets.
    ///
    /// * MODIFY – Changeset is considered as a replacement to a specific prior ingested Changeset.
    /// This member is required.
    public var changeType: FinspacedataClientTypes.ChangeType?
    /// A token that ensures idempotency. This token expires in 10 minutes.
    public var clientToken: Swift.String?
    /// The unique identifier for the FinSpace Dataset where the Changeset will be created.
    /// This member is required.
    public var datasetId: Swift.String?
    /// Options that define the structure of the source file(s) including the format type (formatType), header row (withHeader), data separation character (separator) and the type of compression (compression). formatType is a required attribute and can have the following values:
    ///
    /// * PARQUET – Parquet source file format.
    ///
    /// * CSV – CSV source file format.
    ///
    /// * JSON – JSON source file format.
    ///
    /// * XML – XML source file format.
    ///
    ///
    /// Here is an example of how you could specify the formatParams:  "formatParams": { "formatType": "CSV", "withHeader": "true", "separator": ",", "compression":"None" }  Note that if you only provide formatType as CSV, the rest of the attributes will automatically default to CSV values as following:  { "withHeader": "true", "separator": "," }  For more information about supported file formats, see [Supported Data Types and File Formats](https://docs.aws.amazon.com/finspace/latest/userguide/supported-data-types.html) in the FinSpace User Guide.
    /// This member is required.
    public var formatParams: [Swift.String:Swift.String]?
    /// Options that define the location of the data being ingested (s3SourcePath) and the source of the changeset (sourceType). Both s3SourcePath and sourceType are required attributes. Here is an example of how you could specify the sourceParams:  "sourceParams": { "s3SourcePath": "s3://finspace-landing-us-east-2-bk7gcfvitndqa6ebnvys4d/scratch/wr5hh8pwkpqqkxa4sxrmcw/ingestion/equity.csv", "sourceType": "S3" }  The S3 path that you specify must allow the FinSpace role access. To do that, you first need to configure the IAM policy on S3 bucket. For more information, see [Loading data from an Amazon S3 Bucket using the FinSpace API](https://docs.aws.amazon.com/finspace/latest/data-api/fs-using-the-finspace-api.html#access-s3-buckets) section.
    /// This member is required.
    public var sourceParams: [Swift.String:Swift.String]?

    public init(
        changeType: FinspacedataClientTypes.ChangeType? = nil,
        clientToken: Swift.String? = nil,
        datasetId: Swift.String? = nil,
        formatParams: [Swift.String:Swift.String]? = nil,
        sourceParams: [Swift.String:Swift.String]? = nil
    )
    {
        self.changeType = changeType
        self.clientToken = clientToken
        self.datasetId = datasetId
        self.formatParams = formatParams
        self.sourceParams = sourceParams
    }
}

struct CreateChangesetInputBody: Swift.Equatable {
    let clientToken: Swift.String?
    let changeType: FinspacedataClientTypes.ChangeType?
    let sourceParams: [Swift.String:Swift.String]?
    let formatParams: [Swift.String:Swift.String]?
}

extension CreateChangesetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case changeType
        case clientToken
        case formatParams
        case sourceParams
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let changeTypeDecoded = try containerValues.decodeIfPresent(FinspacedataClientTypes.ChangeType.self, forKey: .changeType)
        changeType = changeTypeDecoded
        let sourceParamsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .sourceParams)
        var sourceParamsDecoded0: [Swift.String:Swift.String]? = nil
        if let sourceParamsContainer = sourceParamsContainer {
            sourceParamsDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringmapvalue0) in sourceParamsContainer {
                if let stringmapvalue0 = stringmapvalue0 {
                    sourceParamsDecoded0?[key0] = stringmapvalue0
                }
            }
        }
        sourceParams = sourceParamsDecoded0
        let formatParamsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .formatParams)
        var formatParamsDecoded0: [Swift.String:Swift.String]? = nil
        if let formatParamsContainer = formatParamsContainer {
            formatParamsDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringmapvalue0) in formatParamsContainer {
                if let stringmapvalue0 = stringmapvalue0 {
                    formatParamsDecoded0?[key0] = stringmapvalue0
                }
            }
        }
        formatParams = formatParamsDecoded0
    }
}

extension CreateChangesetOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateChangesetOutputBody = try responseDecoder.decode(responseBody: data)
            self.changesetId = output.changesetId
            self.datasetId = output.datasetId
        } else {
            self.changesetId = nil
            self.datasetId = nil
        }
    }
}

/// The response from a CreateChangeset operation.
public struct CreateChangesetOutput: Swift.Equatable {
    /// The unique identifier of the Changeset that is created.
    public var changesetId: Swift.String?
    /// The unique identifier for the FinSpace Dataset where the Changeset is created.
    public var datasetId: Swift.String?

    public init(
        changesetId: Swift.String? = nil,
        datasetId: Swift.String? = nil
    )
    {
        self.changesetId = changesetId
        self.datasetId = datasetId
    }
}

struct CreateChangesetOutputBody: Swift.Equatable {
    let datasetId: Swift.String?
    let changesetId: Swift.String?
}

extension CreateChangesetOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case changesetId
        case datasetId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetId)
        datasetId = datasetIdDecoded
        let changesetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .changesetId)
        changesetId = changesetIdDecoded
    }
}

enum CreateChangesetOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateDataViewInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case asOfTimestamp
        case autoUpdate
        case clientToken
        case destinationTypeParams
        case partitionColumns
        case sortColumns
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let asOfTimestamp = self.asOfTimestamp {
            try encodeContainer.encode(asOfTimestamp, forKey: .asOfTimestamp)
        }
        if let autoUpdate = self.autoUpdate {
            try encodeContainer.encode(autoUpdate, forKey: .autoUpdate)
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let destinationTypeParams = self.destinationTypeParams {
            try encodeContainer.encode(destinationTypeParams, forKey: .destinationTypeParams)
        }
        if let partitionColumns = partitionColumns {
            var partitionColumnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .partitionColumns)
            for stringvaluelength1to2550 in partitionColumns {
                try partitionColumnsContainer.encode(stringvaluelength1to2550)
            }
        }
        if let sortColumns = sortColumns {
            var sortColumnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sortColumns)
            for stringvaluelength1to2550 in sortColumns {
                try sortColumnsContainer.encode(stringvaluelength1to2550)
            }
        }
    }
}

extension CreateDataViewInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let datasetId = datasetId else {
            return nil
        }
        return "/datasets/\(datasetId.urlPercentEncoding())/dataviewsv2"
    }
}

/// Request for creating a data view.
public struct CreateDataViewInput: Swift.Equatable {
    /// Beginning time to use for the Dataview. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
    public var asOfTimestamp: Swift.Int?
    /// Flag to indicate Dataview should be updated automatically.
    public var autoUpdate: Swift.Bool?
    /// A token that ensures idempotency. This token expires in 10 minutes.
    public var clientToken: Swift.String?
    /// The unique Dataset identifier that is used to create a Dataview.
    /// This member is required.
    public var datasetId: Swift.String?
    /// Options that define the destination type for the Dataview.
    /// This member is required.
    public var destinationTypeParams: FinspacedataClientTypes.DataViewDestinationTypeParams?
    /// Ordered set of column names used to partition data.
    public var partitionColumns: [Swift.String]?
    /// Columns to be used for sorting the data.
    public var sortColumns: [Swift.String]?

    public init(
        asOfTimestamp: Swift.Int? = nil,
        autoUpdate: Swift.Bool? = nil,
        clientToken: Swift.String? = nil,
        datasetId: Swift.String? = nil,
        destinationTypeParams: FinspacedataClientTypes.DataViewDestinationTypeParams? = nil,
        partitionColumns: [Swift.String]? = nil,
        sortColumns: [Swift.String]? = nil
    )
    {
        self.asOfTimestamp = asOfTimestamp
        self.autoUpdate = autoUpdate
        self.clientToken = clientToken
        self.datasetId = datasetId
        self.destinationTypeParams = destinationTypeParams
        self.partitionColumns = partitionColumns
        self.sortColumns = sortColumns
    }
}

struct CreateDataViewInputBody: Swift.Equatable {
    let clientToken: Swift.String?
    let autoUpdate: Swift.Bool?
    let sortColumns: [Swift.String]?
    let partitionColumns: [Swift.String]?
    let asOfTimestamp: Swift.Int?
    let destinationTypeParams: FinspacedataClientTypes.DataViewDestinationTypeParams?
}

extension CreateDataViewInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case asOfTimestamp
        case autoUpdate
        case clientToken
        case destinationTypeParams
        case partitionColumns
        case sortColumns
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let autoUpdateDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .autoUpdate)
        autoUpdate = autoUpdateDecoded
        let sortColumnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .sortColumns)
        var sortColumnsDecoded0:[Swift.String]? = nil
        if let sortColumnsContainer = sortColumnsContainer {
            sortColumnsDecoded0 = [Swift.String]()
            for string0 in sortColumnsContainer {
                if let string0 = string0 {
                    sortColumnsDecoded0?.append(string0)
                }
            }
        }
        sortColumns = sortColumnsDecoded0
        let partitionColumnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .partitionColumns)
        var partitionColumnsDecoded0:[Swift.String]? = nil
        if let partitionColumnsContainer = partitionColumnsContainer {
            partitionColumnsDecoded0 = [Swift.String]()
            for string0 in partitionColumnsContainer {
                if let string0 = string0 {
                    partitionColumnsDecoded0?.append(string0)
                }
            }
        }
        partitionColumns = partitionColumnsDecoded0
        let asOfTimestampDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .asOfTimestamp)
        asOfTimestamp = asOfTimestampDecoded
        let destinationTypeParamsDecoded = try containerValues.decodeIfPresent(FinspacedataClientTypes.DataViewDestinationTypeParams.self, forKey: .destinationTypeParams)
        destinationTypeParams = destinationTypeParamsDecoded
    }
}

extension CreateDataViewOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateDataViewOutputBody = try responseDecoder.decode(responseBody: data)
            self.dataViewId = output.dataViewId
            self.datasetId = output.datasetId
        } else {
            self.dataViewId = nil
            self.datasetId = nil
        }
    }
}

/// Response for creating a data view.
public struct CreateDataViewOutput: Swift.Equatable {
    /// The unique identifier for the created Dataview.
    public var dataViewId: Swift.String?
    /// The unique identifier of the Dataset used for the Dataview.
    public var datasetId: Swift.String?

    public init(
        dataViewId: Swift.String? = nil,
        datasetId: Swift.String? = nil
    )
    {
        self.dataViewId = dataViewId
        self.datasetId = datasetId
    }
}

struct CreateDataViewOutputBody: Swift.Equatable {
    let datasetId: Swift.String?
    let dataViewId: Swift.String?
}

extension CreateDataViewOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataViewId
        case datasetId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetId)
        datasetId = datasetIdDecoded
        let dataViewIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataViewId)
        dataViewId = dataViewIdDecoded
    }
}

enum CreateDataViewOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateDatasetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alias
        case clientToken
        case datasetDescription
        case datasetTitle
        case kind
        case ownerInfo
        case permissionGroupParams
        case schemaDefinition
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let alias = self.alias {
            try encodeContainer.encode(alias, forKey: .alias)
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let datasetDescription = self.datasetDescription {
            try encodeContainer.encode(datasetDescription, forKey: .datasetDescription)
        }
        if let datasetTitle = self.datasetTitle {
            try encodeContainer.encode(datasetTitle, forKey: .datasetTitle)
        }
        if let kind = self.kind {
            try encodeContainer.encode(kind.rawValue, forKey: .kind)
        }
        if let ownerInfo = self.ownerInfo {
            try encodeContainer.encode(ownerInfo, forKey: .ownerInfo)
        }
        if let permissionGroupParams = self.permissionGroupParams {
            try encodeContainer.encode(permissionGroupParams, forKey: .permissionGroupParams)
        }
        if let schemaDefinition = self.schemaDefinition {
            try encodeContainer.encode(schemaDefinition, forKey: .schemaDefinition)
        }
    }
}

extension CreateDatasetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/datasetsv2"
    }
}

/// The request for a CreateDataset operation
public struct CreateDatasetInput: Swift.Equatable {
    /// The unique resource identifier for a Dataset.
    public var alias: Swift.String?
    /// A token that ensures idempotency. This token expires in 10 minutes.
    public var clientToken: Swift.String?
    /// Description of a Dataset.
    public var datasetDescription: Swift.String?
    /// Display title for a FinSpace Dataset.
    /// This member is required.
    public var datasetTitle: Swift.String?
    /// The format in which Dataset data is structured.
    ///
    /// * TABULAR – Data is structured in a tabular format.
    ///
    /// * NON_TABULAR – Data is structured in a non-tabular format.
    /// This member is required.
    public var kind: FinspacedataClientTypes.DatasetKind?
    /// Contact information for a Dataset owner.
    public var ownerInfo: FinspacedataClientTypes.DatasetOwnerInfo?
    /// Permission group parameters for Dataset permissions.
    /// This member is required.
    public var permissionGroupParams: FinspacedataClientTypes.PermissionGroupParams?
    /// Definition for a schema on a tabular Dataset.
    public var schemaDefinition: FinspacedataClientTypes.SchemaUnion?

    public init(
        alias: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        datasetDescription: Swift.String? = nil,
        datasetTitle: Swift.String? = nil,
        kind: FinspacedataClientTypes.DatasetKind? = nil,
        ownerInfo: FinspacedataClientTypes.DatasetOwnerInfo? = nil,
        permissionGroupParams: FinspacedataClientTypes.PermissionGroupParams? = nil,
        schemaDefinition: FinspacedataClientTypes.SchemaUnion? = nil
    )
    {
        self.alias = alias
        self.clientToken = clientToken
        self.datasetDescription = datasetDescription
        self.datasetTitle = datasetTitle
        self.kind = kind
        self.ownerInfo = ownerInfo
        self.permissionGroupParams = permissionGroupParams
        self.schemaDefinition = schemaDefinition
    }
}

struct CreateDatasetInputBody: Swift.Equatable {
    let clientToken: Swift.String?
    let datasetTitle: Swift.String?
    let kind: FinspacedataClientTypes.DatasetKind?
    let datasetDescription: Swift.String?
    let ownerInfo: FinspacedataClientTypes.DatasetOwnerInfo?
    let permissionGroupParams: FinspacedataClientTypes.PermissionGroupParams?
    let alias: Swift.String?
    let schemaDefinition: FinspacedataClientTypes.SchemaUnion?
}

extension CreateDatasetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alias
        case clientToken
        case datasetDescription
        case datasetTitle
        case kind
        case ownerInfo
        case permissionGroupParams
        case schemaDefinition
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let datasetTitleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetTitle)
        datasetTitle = datasetTitleDecoded
        let kindDecoded = try containerValues.decodeIfPresent(FinspacedataClientTypes.DatasetKind.self, forKey: .kind)
        kind = kindDecoded
        let datasetDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetDescription)
        datasetDescription = datasetDescriptionDecoded
        let ownerInfoDecoded = try containerValues.decodeIfPresent(FinspacedataClientTypes.DatasetOwnerInfo.self, forKey: .ownerInfo)
        ownerInfo = ownerInfoDecoded
        let permissionGroupParamsDecoded = try containerValues.decodeIfPresent(FinspacedataClientTypes.PermissionGroupParams.self, forKey: .permissionGroupParams)
        permissionGroupParams = permissionGroupParamsDecoded
        let aliasDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .alias)
        alias = aliasDecoded
        let schemaDefinitionDecoded = try containerValues.decodeIfPresent(FinspacedataClientTypes.SchemaUnion.self, forKey: .schemaDefinition)
        schemaDefinition = schemaDefinitionDecoded
    }
}

extension CreateDatasetOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateDatasetOutputBody = try responseDecoder.decode(responseBody: data)
            self.datasetId = output.datasetId
        } else {
            self.datasetId = nil
        }
    }
}

/// The response from a CreateDataset operation
public struct CreateDatasetOutput: Swift.Equatable {
    /// The unique identifier for the created Dataset.
    public var datasetId: Swift.String?

    public init(
        datasetId: Swift.String? = nil
    )
    {
        self.datasetId = datasetId
    }
}

struct CreateDatasetOutputBody: Swift.Equatable {
    let datasetId: Swift.String?
}

extension CreateDatasetOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetId)
        datasetId = datasetIdDecoded
    }
}

enum CreateDatasetOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreatePermissionGroupInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreatePermissionGroupInput(applicationPermissions: \(Swift.String(describing: applicationPermissions)), clientToken: \(Swift.String(describing: clientToken)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension CreatePermissionGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationPermissions
        case clientToken
        case description
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationPermissions = applicationPermissions {
            var applicationPermissionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .applicationPermissions)
            for applicationpermission0 in applicationPermissions {
                try applicationPermissionsContainer.encode(applicationpermission0.rawValue)
            }
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension CreatePermissionGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/permission-group"
    }
}

public struct CreatePermissionGroupInput: Swift.Equatable {
    /// The option to indicate FinSpace application permissions that are granted to a specific group. When assigning application permissions, be aware that the permission ManageUsersAndGroups allows users to grant themselves or others access to any functionality in their FinSpace environment's application. It should only be granted to trusted users.
    ///
    /// * CreateDataset – Group members can create new datasets.
    ///
    /// * ManageClusters – Group members can manage Apache Spark clusters from FinSpace notebooks.
    ///
    /// * ManageUsersAndGroups – Group members can manage users and permission groups. This is a privileged permission that allows users to grant themselves or others access to any functionality in the application. It should only be granted to trusted users.
    ///
    /// * ManageAttributeSets – Group members can manage attribute sets.
    ///
    /// * ViewAuditData – Group members can view audit data.
    ///
    /// * AccessNotebooks – Group members will have access to FinSpace notebooks.
    ///
    /// * GetTemporaryCredentials – Group members can get temporary API credentials.
    /// This member is required.
    public var applicationPermissions: [FinspacedataClientTypes.ApplicationPermission]?
    /// A token that ensures idempotency. This token expires in 10 minutes.
    public var clientToken: Swift.String?
    /// A brief description for the permission group.
    public var description: Swift.String?
    /// The name of the permission group.
    /// This member is required.
    public var name: Swift.String?

    public init(
        applicationPermissions: [FinspacedataClientTypes.ApplicationPermission]? = nil,
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.applicationPermissions = applicationPermissions
        self.clientToken = clientToken
        self.description = description
        self.name = name
    }
}

struct CreatePermissionGroupInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let applicationPermissions: [FinspacedataClientTypes.ApplicationPermission]?
    let clientToken: Swift.String?
}

extension CreatePermissionGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationPermissions
        case clientToken
        case description
        case name
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let applicationPermissionsContainer = try containerValues.decodeIfPresent([FinspacedataClientTypes.ApplicationPermission?].self, forKey: .applicationPermissions)
        var applicationPermissionsDecoded0:[FinspacedataClientTypes.ApplicationPermission]? = nil
        if let applicationPermissionsContainer = applicationPermissionsContainer {
            applicationPermissionsDecoded0 = [FinspacedataClientTypes.ApplicationPermission]()
            for enum0 in applicationPermissionsContainer {
                if let enum0 = enum0 {
                    applicationPermissionsDecoded0?.append(enum0)
                }
            }
        }
        applicationPermissions = applicationPermissionsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CreatePermissionGroupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreatePermissionGroupOutputBody = try responseDecoder.decode(responseBody: data)
            self.permissionGroupId = output.permissionGroupId
        } else {
            self.permissionGroupId = nil
        }
    }
}

public struct CreatePermissionGroupOutput: Swift.Equatable {
    /// The unique identifier for the permission group.
    public var permissionGroupId: Swift.String?

    public init(
        permissionGroupId: Swift.String? = nil
    )
    {
        self.permissionGroupId = permissionGroupId
    }
}

struct CreatePermissionGroupOutputBody: Swift.Equatable {
    let permissionGroupId: Swift.String?
}

extension CreatePermissionGroupOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case permissionGroupId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let permissionGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .permissionGroupId)
        permissionGroupId = permissionGroupIdDecoded
    }
}

enum CreatePermissionGroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateUserInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateUserInput(apiAccess: \(Swift.String(describing: apiAccess)), apiAccessPrincipalArn: \(Swift.String(describing: apiAccessPrincipalArn)), clientToken: \(Swift.String(describing: clientToken)), type: \(Swift.String(describing: type)), emailAddress: \"CONTENT_REDACTED\", firstName: \"CONTENT_REDACTED\", lastName: \"CONTENT_REDACTED\")"}
}

extension CreateUserInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiAccess
        case apiAccessPrincipalArn
        case clientToken
        case emailAddress
        case firstName
        case lastName
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let apiAccess = self.apiAccess {
            try encodeContainer.encode(apiAccess.rawValue, forKey: .apiAccess)
        }
        if let apiAccessPrincipalArn = self.apiAccessPrincipalArn {
            try encodeContainer.encode(apiAccessPrincipalArn, forKey: .apiAccessPrincipalArn)
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let emailAddress = self.emailAddress {
            try encodeContainer.encode(emailAddress, forKey: .emailAddress)
        }
        if let firstName = self.firstName {
            try encodeContainer.encode(firstName, forKey: .firstName)
        }
        if let lastName = self.lastName {
            try encodeContainer.encode(lastName, forKey: .lastName)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

extension CreateUserInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/user"
    }
}

public struct CreateUserInput: Swift.Equatable {
    /// The option to indicate whether the user can use the GetProgrammaticAccessCredentials API to obtain credentials that can then be used to access other FinSpace Data API operations.
    ///
    /// * ENABLED – The user has permissions to use the APIs.
    ///
    /// * DISABLED – The user does not have permissions to use any APIs.
    public var apiAccess: FinspacedataClientTypes.ApiAccess?
    /// The ARN identifier of an AWS user or role that is allowed to call the GetProgrammaticAccessCredentials API to obtain a credentials token for a specific FinSpace user. This must be an IAM role within your FinSpace account.
    public var apiAccessPrincipalArn: Swift.String?
    /// A token that ensures idempotency. This token expires in 10 minutes.
    public var clientToken: Swift.String?
    /// The email address of the user that you want to register. The email address serves as a uniquer identifier for each user and cannot be changed after it's created.
    /// This member is required.
    public var emailAddress: Swift.String?
    /// The first name of the user that you want to register.
    public var firstName: Swift.String?
    /// The last name of the user that you want to register.
    public var lastName: Swift.String?
    /// The option to indicate the type of user. Use one of the following options to specify this parameter:
    ///
    /// * SUPER_USER – A user with permission to all the functionality and data in FinSpace.
    ///
    /// * APP_USER – A user with specific permissions in FinSpace. The users are assigned permissions by adding them to a permission group.
    /// This member is required.
    public var type: FinspacedataClientTypes.UserType?

    public init(
        apiAccess: FinspacedataClientTypes.ApiAccess? = nil,
        apiAccessPrincipalArn: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        emailAddress: Swift.String? = nil,
        firstName: Swift.String? = nil,
        lastName: Swift.String? = nil,
        type: FinspacedataClientTypes.UserType? = nil
    )
    {
        self.apiAccess = apiAccess
        self.apiAccessPrincipalArn = apiAccessPrincipalArn
        self.clientToken = clientToken
        self.emailAddress = emailAddress
        self.firstName = firstName
        self.lastName = lastName
        self.type = type
    }
}

struct CreateUserInputBody: Swift.Equatable {
    let emailAddress: Swift.String?
    let type: FinspacedataClientTypes.UserType?
    let firstName: Swift.String?
    let lastName: Swift.String?
    let apiAccess: FinspacedataClientTypes.ApiAccess?
    let apiAccessPrincipalArn: Swift.String?
    let clientToken: Swift.String?
}

extension CreateUserInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiAccess
        case apiAccessPrincipalArn
        case clientToken
        case emailAddress
        case firstName
        case lastName
        case type
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let emailAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .emailAddress)
        emailAddress = emailAddressDecoded
        let typeDecoded = try containerValues.decodeIfPresent(FinspacedataClientTypes.UserType.self, forKey: .type)
        type = typeDecoded
        let firstNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .firstName)
        firstName = firstNameDecoded
        let lastNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastName)
        lastName = lastNameDecoded
        let apiAccessDecoded = try containerValues.decodeIfPresent(FinspacedataClientTypes.ApiAccess.self, forKey: .apiAccess)
        apiAccess = apiAccessDecoded
        let apiAccessPrincipalArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiAccessPrincipalArn)
        apiAccessPrincipalArn = apiAccessPrincipalArnDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CreateUserOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateUserOutputBody = try responseDecoder.decode(responseBody: data)
            self.userId = output.userId
        } else {
            self.userId = nil
        }
    }
}

public struct CreateUserOutput: Swift.Equatable {
    /// The unique identifier for the user.
    public var userId: Swift.String?

    public init(
        userId: Swift.String? = nil
    )
    {
        self.userId = userId
    }
}

struct CreateUserOutputBody: Swift.Equatable {
    let userId: Swift.String?
}

extension CreateUserOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case userId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userId)
        userId = userIdDecoded
    }
}

enum CreateUserOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension FinspacedataClientTypes.Credentials: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessKeyId
        case secretAccessKey
        case sessionToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessKeyId = self.accessKeyId {
            try encodeContainer.encode(accessKeyId, forKey: .accessKeyId)
        }
        if let secretAccessKey = self.secretAccessKey {
            try encodeContainer.encode(secretAccessKey, forKey: .secretAccessKey)
        }
        if let sessionToken = self.sessionToken {
            try encodeContainer.encode(sessionToken, forKey: .sessionToken)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accessKeyId)
        accessKeyId = accessKeyIdDecoded
        let secretAccessKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .secretAccessKey)
        secretAccessKey = secretAccessKeyDecoded
        let sessionTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sessionToken)
        sessionToken = sessionTokenDecoded
    }
}

extension FinspacedataClientTypes.Credentials: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension FinspacedataClientTypes {
    /// Short term API credentials.
    public struct Credentials: Swift.Equatable {
        /// The access key identifier.
        public var accessKeyId: Swift.String?
        /// The access key.
        public var secretAccessKey: Swift.String?
        /// The session token.
        public var sessionToken: Swift.String?

        public init(
            accessKeyId: Swift.String? = nil,
            secretAccessKey: Swift.String? = nil,
            sessionToken: Swift.String? = nil
        )
        {
            self.accessKeyId = accessKeyId
            self.secretAccessKey = secretAccessKey
            self.sessionToken = sessionToken
        }
    }

}

extension FinspacedataClientTypes.DataViewDestinationTypeParams: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationType
        case s3DestinationExportFileFormat
        case s3DestinationExportFileFormatOptions
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destinationType = self.destinationType {
            try encodeContainer.encode(destinationType, forKey: .destinationType)
        }
        if let s3DestinationExportFileFormat = self.s3DestinationExportFileFormat {
            try encodeContainer.encode(s3DestinationExportFileFormat.rawValue, forKey: .s3DestinationExportFileFormat)
        }
        if let s3DestinationExportFileFormatOptions = s3DestinationExportFileFormatOptions {
            var s3DestinationExportFileFormatOptionsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .s3DestinationExportFileFormatOptions)
            for (dictKey0, s3DestinationFormatOptions0) in s3DestinationExportFileFormatOptions {
                try s3DestinationExportFileFormatOptionsContainer.encode(s3DestinationFormatOptions0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let destinationTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationType)
        destinationType = destinationTypeDecoded
        let s3DestinationExportFileFormatDecoded = try containerValues.decodeIfPresent(FinspacedataClientTypes.ExportFileFormat.self, forKey: .s3DestinationExportFileFormat)
        s3DestinationExportFileFormat = s3DestinationExportFileFormatDecoded
        let s3DestinationExportFileFormatOptionsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .s3DestinationExportFileFormatOptions)
        var s3DestinationExportFileFormatOptionsDecoded0: [Swift.String:Swift.String]? = nil
        if let s3DestinationExportFileFormatOptionsContainer = s3DestinationExportFileFormatOptionsContainer {
            s3DestinationExportFileFormatOptionsDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringmapvalue0) in s3DestinationExportFileFormatOptionsContainer {
                if let stringmapvalue0 = stringmapvalue0 {
                    s3DestinationExportFileFormatOptionsDecoded0?[key0] = stringmapvalue0
                }
            }
        }
        s3DestinationExportFileFormatOptions = s3DestinationExportFileFormatOptionsDecoded0
    }
}

extension FinspacedataClientTypes {
    /// Structure for the Dataview destination type parameters.
    public struct DataViewDestinationTypeParams: Swift.Equatable {
        /// Destination type for a Dataview.
        ///
        /// * GLUE_TABLE – Glue table destination type.
        ///
        /// * S3 – S3 destination type.
        /// This member is required.
        public var destinationType: Swift.String?
        /// Dataview export file format.
        ///
        /// * PARQUET – Parquet export file format.
        ///
        /// * DELIMITED_TEXT – Delimited text export file format.
        public var s3DestinationExportFileFormat: FinspacedataClientTypes.ExportFileFormat?
        /// Format Options for S3 Destination type. Here is an example of how you could specify the s3DestinationExportFileFormatOptions
        ///     { "header": "true", "delimiter": ",", "compression": "gzip" }
        public var s3DestinationExportFileFormatOptions: [Swift.String:Swift.String]?

        public init(
            destinationType: Swift.String? = nil,
            s3DestinationExportFileFormat: FinspacedataClientTypes.ExportFileFormat? = nil,
            s3DestinationExportFileFormatOptions: [Swift.String:Swift.String]? = nil
        )
        {
            self.destinationType = destinationType
            self.s3DestinationExportFileFormat = s3DestinationExportFileFormat
            self.s3DestinationExportFileFormatOptions = s3DestinationExportFileFormatOptions
        }
    }

}

extension FinspacedataClientTypes.DataViewErrorInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCategory
        case errorMessage
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCategory = self.errorCategory {
            try encodeContainer.encode(errorCategory.rawValue, forKey: .errorCategory)
        }
        if let errorMessage = self.errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
        let errorCategoryDecoded = try containerValues.decodeIfPresent(FinspacedataClientTypes.ErrorCategory.self, forKey: .errorCategory)
        errorCategory = errorCategoryDecoded
    }
}

extension FinspacedataClientTypes {
    /// The structure with error messages.
    public struct DataViewErrorInfo: Swift.Equatable {
        /// The category of the error.
        ///
        /// * VALIDATION – The inputs to this request are invalid.
        ///
        /// * SERVICE_QUOTA_EXCEEDED – Service quotas have been exceeded. Please contact AWS support to increase quotas.
        ///
        /// * ACCESS_DENIED – Missing required permission to perform this request.
        ///
        /// * RESOURCE_NOT_FOUND – One or more inputs to this request were not found.
        ///
        /// * THROTTLING – The system temporarily lacks sufficient resources to process the request.
        ///
        /// * INTERNAL_SERVICE_EXCEPTION – An internal service error has occurred.
        ///
        /// * CANCELLED – Cancelled.
        ///
        /// * USER_RECOVERABLE – A user recoverable error has occurred.
        public var errorCategory: FinspacedataClientTypes.ErrorCategory?
        /// The text of the error message.
        public var errorMessage: Swift.String?

        public init(
            errorCategory: FinspacedataClientTypes.ErrorCategory? = nil,
            errorMessage: Swift.String? = nil
        )
        {
            self.errorCategory = errorCategory
            self.errorMessage = errorMessage
        }
    }

}

extension FinspacedataClientTypes {
    /// Status of a DataView
    public enum DataViewStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cancelled
        case failed
        case failedCleanupFailed
        case pending
        case running
        case starting
        case success
        case timeout
        case sdkUnknown(Swift.String)

        public static var allCases: [DataViewStatus] {
            return [
                .cancelled,
                .failed,
                .failedCleanupFailed,
                .pending,
                .running,
                .starting,
                .success,
                .timeout,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cancelled: return "CANCELLED"
            case .failed: return "FAILED"
            case .failedCleanupFailed: return "FAILED_CLEANUP_FAILED"
            case .pending: return "PENDING"
            case .running: return "RUNNING"
            case .starting: return "STARTING"
            case .success: return "SUCCESS"
            case .timeout: return "TIMEOUT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DataViewStatus(rawValue: rawValue) ?? DataViewStatus.sdkUnknown(rawValue)
        }
    }
}

extension FinspacedataClientTypes.DataViewSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case asOfTimestamp
        case autoUpdate
        case createTime
        case dataViewArn
        case dataViewId
        case datasetId
        case destinationTypeProperties
        case errorInfo
        case lastModifiedTime
        case partitionColumns
        case sortColumns
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let asOfTimestamp = self.asOfTimestamp {
            try encodeContainer.encode(asOfTimestamp, forKey: .asOfTimestamp)
        }
        if autoUpdate != false {
            try encodeContainer.encode(autoUpdate, forKey: .autoUpdate)
        }
        if createTime != 0 {
            try encodeContainer.encode(createTime, forKey: .createTime)
        }
        if let dataViewArn = self.dataViewArn {
            try encodeContainer.encode(dataViewArn, forKey: .dataViewArn)
        }
        if let dataViewId = self.dataViewId {
            try encodeContainer.encode(dataViewId, forKey: .dataViewId)
        }
        if let datasetId = self.datasetId {
            try encodeContainer.encode(datasetId, forKey: .datasetId)
        }
        if let destinationTypeProperties = self.destinationTypeProperties {
            try encodeContainer.encode(destinationTypeProperties, forKey: .destinationTypeProperties)
        }
        if let errorInfo = self.errorInfo {
            try encodeContainer.encode(errorInfo, forKey: .errorInfo)
        }
        if lastModifiedTime != 0 {
            try encodeContainer.encode(lastModifiedTime, forKey: .lastModifiedTime)
        }
        if let partitionColumns = partitionColumns {
            var partitionColumnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .partitionColumns)
            for stringvaluelength1to2550 in partitionColumns {
                try partitionColumnsContainer.encode(stringvaluelength1to2550)
            }
        }
        if let sortColumns = sortColumns {
            var sortColumnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sortColumns)
            for stringvaluelength1to2550 in sortColumns {
                try sortColumnsContainer.encode(stringvaluelength1to2550)
            }
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataViewIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataViewId)
        dataViewId = dataViewIdDecoded
        let dataViewArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataViewArn)
        dataViewArn = dataViewArnDecoded
        let datasetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetId)
        datasetId = datasetIdDecoded
        let asOfTimestampDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .asOfTimestamp)
        asOfTimestamp = asOfTimestampDecoded
        let partitionColumnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .partitionColumns)
        var partitionColumnsDecoded0:[Swift.String]? = nil
        if let partitionColumnsContainer = partitionColumnsContainer {
            partitionColumnsDecoded0 = [Swift.String]()
            for string0 in partitionColumnsContainer {
                if let string0 = string0 {
                    partitionColumnsDecoded0?.append(string0)
                }
            }
        }
        partitionColumns = partitionColumnsDecoded0
        let sortColumnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .sortColumns)
        var sortColumnsDecoded0:[Swift.String]? = nil
        if let sortColumnsContainer = sortColumnsContainer {
            sortColumnsDecoded0 = [Swift.String]()
            for string0 in sortColumnsContainer {
                if let string0 = string0 {
                    sortColumnsDecoded0?.append(string0)
                }
            }
        }
        sortColumns = sortColumnsDecoded0
        let statusDecoded = try containerValues.decodeIfPresent(FinspacedataClientTypes.DataViewStatus.self, forKey: .status)
        status = statusDecoded
        let errorInfoDecoded = try containerValues.decodeIfPresent(FinspacedataClientTypes.DataViewErrorInfo.self, forKey: .errorInfo)
        errorInfo = errorInfoDecoded
        let destinationTypePropertiesDecoded = try containerValues.decodeIfPresent(FinspacedataClientTypes.DataViewDestinationTypeParams.self, forKey: .destinationTypeProperties)
        destinationTypeProperties = destinationTypePropertiesDecoded
        let autoUpdateDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .autoUpdate) ?? false
        autoUpdate = autoUpdateDecoded
        let createTimeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .createTime) ?? 0
        createTime = createTimeDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .lastModifiedTime) ?? 0
        lastModifiedTime = lastModifiedTimeDecoded
    }
}

extension FinspacedataClientTypes {
    /// Structure for the summary of a Dataview.
    public struct DataViewSummary: Swift.Equatable {
        /// Time range to use for the Dataview. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
        public var asOfTimestamp: Swift.Int?
        /// The flag to indicate Dataview should be updated automatically.
        public var autoUpdate: Swift.Bool
        /// The timestamp at which the Dataview was created in FinSpace. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
        public var createTime: Swift.Int
        /// The ARN identifier of the Dataview.
        public var dataViewArn: Swift.String?
        /// The unique identifier for the Dataview.
        public var dataViewId: Swift.String?
        /// Th unique identifier for the Dataview Dataset.
        public var datasetId: Swift.String?
        /// Information about the Dataview destination.
        public var destinationTypeProperties: FinspacedataClientTypes.DataViewDestinationTypeParams?
        /// The structure with error messages.
        public var errorInfo: FinspacedataClientTypes.DataViewErrorInfo?
        /// The last time that a Dataview was modified. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
        public var lastModifiedTime: Swift.Int
        /// Ordered set of column names used to partition data.
        public var partitionColumns: [Swift.String]?
        /// Columns to be used for sorting the data.
        public var sortColumns: [Swift.String]?
        /// The status of a Dataview creation.
        ///
        /// * RUNNING – Dataview creation is running.
        ///
        /// * STARTING – Dataview creation is starting.
        ///
        /// * FAILED – Dataview creation has failed.
        ///
        /// * CANCELLED – Dataview creation has been cancelled.
        ///
        /// * TIMEOUT – Dataview creation has timed out.
        ///
        /// * SUCCESS – Dataview creation has succeeded.
        ///
        /// * PENDING – Dataview creation is pending.
        ///
        /// * FAILED_CLEANUP_FAILED – Dataview creation failed and resource cleanup failed.
        public var status: FinspacedataClientTypes.DataViewStatus?

        public init(
            asOfTimestamp: Swift.Int? = nil,
            autoUpdate: Swift.Bool = false,
            createTime: Swift.Int = 0,
            dataViewArn: Swift.String? = nil,
            dataViewId: Swift.String? = nil,
            datasetId: Swift.String? = nil,
            destinationTypeProperties: FinspacedataClientTypes.DataViewDestinationTypeParams? = nil,
            errorInfo: FinspacedataClientTypes.DataViewErrorInfo? = nil,
            lastModifiedTime: Swift.Int = 0,
            partitionColumns: [Swift.String]? = nil,
            sortColumns: [Swift.String]? = nil,
            status: FinspacedataClientTypes.DataViewStatus? = nil
        )
        {
            self.asOfTimestamp = asOfTimestamp
            self.autoUpdate = autoUpdate
            self.createTime = createTime
            self.dataViewArn = dataViewArn
            self.dataViewId = dataViewId
            self.datasetId = datasetId
            self.destinationTypeProperties = destinationTypeProperties
            self.errorInfo = errorInfo
            self.lastModifiedTime = lastModifiedTime
            self.partitionColumns = partitionColumns
            self.sortColumns = sortColumns
            self.status = status
        }
    }

}

extension FinspacedataClientTypes.Dataset: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alias
        case createTime
        case datasetArn
        case datasetDescription
        case datasetId
        case datasetTitle
        case kind
        case lastModifiedTime
        case ownerInfo
        case schemaDefinition
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let alias = self.alias {
            try encodeContainer.encode(alias, forKey: .alias)
        }
        if createTime != 0 {
            try encodeContainer.encode(createTime, forKey: .createTime)
        }
        if let datasetArn = self.datasetArn {
            try encodeContainer.encode(datasetArn, forKey: .datasetArn)
        }
        if let datasetDescription = self.datasetDescription {
            try encodeContainer.encode(datasetDescription, forKey: .datasetDescription)
        }
        if let datasetId = self.datasetId {
            try encodeContainer.encode(datasetId, forKey: .datasetId)
        }
        if let datasetTitle = self.datasetTitle {
            try encodeContainer.encode(datasetTitle, forKey: .datasetTitle)
        }
        if let kind = self.kind {
            try encodeContainer.encode(kind.rawValue, forKey: .kind)
        }
        if lastModifiedTime != 0 {
            try encodeContainer.encode(lastModifiedTime, forKey: .lastModifiedTime)
        }
        if let ownerInfo = self.ownerInfo {
            try encodeContainer.encode(ownerInfo, forKey: .ownerInfo)
        }
        if let schemaDefinition = self.schemaDefinition {
            try encodeContainer.encode(schemaDefinition, forKey: .schemaDefinition)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetId)
        datasetId = datasetIdDecoded
        let datasetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetArn)
        datasetArn = datasetArnDecoded
        let datasetTitleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetTitle)
        datasetTitle = datasetTitleDecoded
        let kindDecoded = try containerValues.decodeIfPresent(FinspacedataClientTypes.DatasetKind.self, forKey: .kind)
        kind = kindDecoded
        let datasetDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetDescription)
        datasetDescription = datasetDescriptionDecoded
        let ownerInfoDecoded = try containerValues.decodeIfPresent(FinspacedataClientTypes.DatasetOwnerInfo.self, forKey: .ownerInfo)
        ownerInfo = ownerInfoDecoded
        let createTimeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .createTime) ?? 0
        createTime = createTimeDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .lastModifiedTime) ?? 0
        lastModifiedTime = lastModifiedTimeDecoded
        let schemaDefinitionDecoded = try containerValues.decodeIfPresent(FinspacedataClientTypes.SchemaUnion.self, forKey: .schemaDefinition)
        schemaDefinition = schemaDefinitionDecoded
        let aliasDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .alias)
        alias = aliasDecoded
    }
}

extension FinspacedataClientTypes {
    /// The structure for a Dataset.
    public struct Dataset: Swift.Equatable {
        /// The unique resource identifier for a Dataset.
        public var alias: Swift.String?
        /// The timestamp at which the Dataset was created in FinSpace. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
        public var createTime: Swift.Int
        /// The ARN identifier of the Dataset.
        public var datasetArn: Swift.String?
        /// Description for a Dataset.
        public var datasetDescription: Swift.String?
        /// An identifier for a Dataset.
        public var datasetId: Swift.String?
        /// Display title for a Dataset.
        public var datasetTitle: Swift.String?
        /// The format in which Dataset data is structured.
        ///
        /// * TABULAR – Data is structured in a tabular format.
        ///
        /// * NON_TABULAR – Data is structured in a non-tabular format.
        public var kind: FinspacedataClientTypes.DatasetKind?
        /// The last time that the Dataset was modified. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
        public var lastModifiedTime: Swift.Int
        /// Contact information for a Dataset owner.
        public var ownerInfo: FinspacedataClientTypes.DatasetOwnerInfo?
        /// Definition for a schema on a tabular Dataset.
        public var schemaDefinition: FinspacedataClientTypes.SchemaUnion?

        public init(
            alias: Swift.String? = nil,
            createTime: Swift.Int = 0,
            datasetArn: Swift.String? = nil,
            datasetDescription: Swift.String? = nil,
            datasetId: Swift.String? = nil,
            datasetTitle: Swift.String? = nil,
            kind: FinspacedataClientTypes.DatasetKind? = nil,
            lastModifiedTime: Swift.Int = 0,
            ownerInfo: FinspacedataClientTypes.DatasetOwnerInfo? = nil,
            schemaDefinition: FinspacedataClientTypes.SchemaUnion? = nil
        )
        {
            self.alias = alias
            self.createTime = createTime
            self.datasetArn = datasetArn
            self.datasetDescription = datasetDescription
            self.datasetId = datasetId
            self.datasetTitle = datasetTitle
            self.kind = kind
            self.lastModifiedTime = lastModifiedTime
            self.ownerInfo = ownerInfo
            self.schemaDefinition = schemaDefinition
        }
    }

}

extension FinspacedataClientTypes {
    /// Dataset Kind
    public enum DatasetKind: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case nonTabular
        case tabular
        case sdkUnknown(Swift.String)

        public static var allCases: [DatasetKind] {
            return [
                .nonTabular,
                .tabular,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .nonTabular: return "NON_TABULAR"
            case .tabular: return "TABULAR"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DatasetKind(rawValue: rawValue) ?? DatasetKind.sdkUnknown(rawValue)
        }
    }
}

extension FinspacedataClientTypes.DatasetOwnerInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case email
        case name
        case phoneNumber
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let email = self.email {
            try encodeContainer.encode(email, forKey: .email)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let phoneNumber = self.phoneNumber {
            try encodeContainer.encode(phoneNumber, forKey: .phoneNumber)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let phoneNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .phoneNumber)
        phoneNumber = phoneNumberDecoded
        let emailDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .email)
        email = emailDecoded
    }
}

extension FinspacedataClientTypes.DatasetOwnerInfo: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DatasetOwnerInfo(name: \(Swift.String(describing: name)), phoneNumber: \(Swift.String(describing: phoneNumber)), email: \"CONTENT_REDACTED\")"}
}

extension FinspacedataClientTypes {
    /// A structure for Dataset owner info.
    public struct DatasetOwnerInfo: Swift.Equatable {
        /// Email address for the Dataset owner.
        public var email: Swift.String?
        /// The name of the Dataset owner.
        public var name: Swift.String?
        /// Phone number for the Dataset owner.
        public var phoneNumber: Swift.String?

        public init(
            email: Swift.String? = nil,
            name: Swift.String? = nil,
            phoneNumber: Swift.String? = nil
        )
        {
            self.email = email
            self.name = name
            self.phoneNumber = phoneNumber
        }
    }

}

extension FinspacedataClientTypes {
    /// Status of the dataset process returned from scheduler service.
    public enum DatasetStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failed
        case pending
        case running
        case success
        case sdkUnknown(Swift.String)

        public static var allCases: [DatasetStatus] {
            return [
                .failed,
                .pending,
                .running,
                .success,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .pending: return "PENDING"
            case .running: return "RUNNING"
            case .success: return "SUCCESS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DatasetStatus(rawValue: rawValue) ?? DatasetStatus.sdkUnknown(rawValue)
        }
    }
}

extension DeleteDatasetInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let clientToken = clientToken {
                let clientTokenQueryItem = ClientRuntime.URLQueryItem(name: "clientToken".urlPercentEncoding(), value: Swift.String(clientToken).urlPercentEncoding())
                items.append(clientTokenQueryItem)
            }
            return items
        }
    }
}

extension DeleteDatasetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let datasetId = datasetId else {
            return nil
        }
        return "/datasetsv2/\(datasetId.urlPercentEncoding())"
    }
}

/// The request for a DeleteDataset operation.
public struct DeleteDatasetInput: Swift.Equatable {
    /// A token that ensures idempotency. This token expires in 10 minutes.
    public var clientToken: Swift.String?
    /// The unique identifier of the Dataset to be deleted.
    /// This member is required.
    public var datasetId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        datasetId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.datasetId = datasetId
    }
}

struct DeleteDatasetInputBody: Swift.Equatable {
}

extension DeleteDatasetInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteDatasetOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteDatasetOutputBody = try responseDecoder.decode(responseBody: data)
            self.datasetId = output.datasetId
        } else {
            self.datasetId = nil
        }
    }
}

/// The response from an DeleteDataset operation
public struct DeleteDatasetOutput: Swift.Equatable {
    /// The unique identifier for the deleted Dataset.
    public var datasetId: Swift.String?

    public init(
        datasetId: Swift.String? = nil
    )
    {
        self.datasetId = datasetId
    }
}

struct DeleteDatasetOutputBody: Swift.Equatable {
    let datasetId: Swift.String?
}

extension DeleteDatasetOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetId)
        datasetId = datasetIdDecoded
    }
}

enum DeleteDatasetOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeletePermissionGroupInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let clientToken = clientToken {
                let clientTokenQueryItem = ClientRuntime.URLQueryItem(name: "clientToken".urlPercentEncoding(), value: Swift.String(clientToken).urlPercentEncoding())
                items.append(clientTokenQueryItem)
            }
            return items
        }
    }
}

extension DeletePermissionGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let permissionGroupId = permissionGroupId else {
            return nil
        }
        return "/permission-group/\(permissionGroupId.urlPercentEncoding())"
    }
}

public struct DeletePermissionGroupInput: Swift.Equatable {
    /// A token that ensures idempotency. This token expires in 10 minutes.
    public var clientToken: Swift.String?
    /// The unique identifier for the permission group that you want to delete.
    /// This member is required.
    public var permissionGroupId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        permissionGroupId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.permissionGroupId = permissionGroupId
    }
}

struct DeletePermissionGroupInputBody: Swift.Equatable {
}

extension DeletePermissionGroupInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeletePermissionGroupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeletePermissionGroupOutputBody = try responseDecoder.decode(responseBody: data)
            self.permissionGroupId = output.permissionGroupId
        } else {
            self.permissionGroupId = nil
        }
    }
}

public struct DeletePermissionGroupOutput: Swift.Equatable {
    /// The unique identifier for the deleted permission group.
    public var permissionGroupId: Swift.String?

    public init(
        permissionGroupId: Swift.String? = nil
    )
    {
        self.permissionGroupId = permissionGroupId
    }
}

struct DeletePermissionGroupOutputBody: Swift.Equatable {
    let permissionGroupId: Swift.String?
}

extension DeletePermissionGroupOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case permissionGroupId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let permissionGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .permissionGroupId)
        permissionGroupId = permissionGroupIdDecoded
    }
}

enum DeletePermissionGroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DisableUserInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
    }
}

extension DisableUserInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let userId = userId else {
            return nil
        }
        return "/user/\(userId.urlPercentEncoding())/disable"
    }
}

public struct DisableUserInput: Swift.Equatable {
    /// A token that ensures idempotency. This token expires in 10 minutes.
    public var clientToken: Swift.String?
    /// The unique identifier for the user that you want to deactivate.
    /// This member is required.
    public var userId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        userId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.userId = userId
    }
}

struct DisableUserInputBody: Swift.Equatable {
    let clientToken: Swift.String?
}

extension DisableUserInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension DisableUserOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DisableUserOutputBody = try responseDecoder.decode(responseBody: data)
            self.userId = output.userId
        } else {
            self.userId = nil
        }
    }
}

public struct DisableUserOutput: Swift.Equatable {
    /// The unique identifier for the deactivated user.
    public var userId: Swift.String?

    public init(
        userId: Swift.String? = nil
    )
    {
        self.userId = userId
    }
}

struct DisableUserOutputBody: Swift.Equatable {
    let userId: Swift.String?
}

extension DisableUserOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case userId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userId)
        userId = userIdDecoded
    }
}

enum DisableUserOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DisassociateUserFromPermissionGroupInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let clientToken = clientToken {
                let clientTokenQueryItem = ClientRuntime.URLQueryItem(name: "clientToken".urlPercentEncoding(), value: Swift.String(clientToken).urlPercentEncoding())
                items.append(clientTokenQueryItem)
            }
            return items
        }
    }
}

extension DisassociateUserFromPermissionGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let permissionGroupId = permissionGroupId else {
            return nil
        }
        guard let userId = userId else {
            return nil
        }
        return "/permission-group/\(permissionGroupId.urlPercentEncoding())/users/\(userId.urlPercentEncoding())"
    }
}

public struct DisassociateUserFromPermissionGroupInput: Swift.Equatable {
    /// A token that ensures idempotency. This token expires in 10 minutes.
    public var clientToken: Swift.String?
    /// The unique identifier for the permission group.
    /// This member is required.
    public var permissionGroupId: Swift.String?
    /// The unique identifier for the user.
    /// This member is required.
    public var userId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        permissionGroupId: Swift.String? = nil,
        userId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.permissionGroupId = permissionGroupId
        self.userId = userId
    }
}

struct DisassociateUserFromPermissionGroupInputBody: Swift.Equatable {
}

extension DisassociateUserFromPermissionGroupInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DisassociateUserFromPermissionGroupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        self.statusCode = httpResponse.statusCode.rawValue
    }
}

public struct DisassociateUserFromPermissionGroupOutput: Swift.Equatable {
    /// The returned status code of the response.
    public var statusCode: Swift.Int

    public init(
        statusCode: Swift.Int = 0
    )
    {
        self.statusCode = statusCode
    }
}

struct DisassociateUserFromPermissionGroupOutputBody: Swift.Equatable {
    let statusCode: Swift.Int
}

extension DisassociateUserFromPermissionGroupOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case statusCode
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusCodeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .statusCode) ?? 0
        statusCode = statusCodeDecoded
    }
}

enum DisassociateUserFromPermissionGroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension EnableUserInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
    }
}

extension EnableUserInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let userId = userId else {
            return nil
        }
        return "/user/\(userId.urlPercentEncoding())/enable"
    }
}

public struct EnableUserInput: Swift.Equatable {
    /// A token that ensures idempotency. This token expires in 10 minutes.
    public var clientToken: Swift.String?
    /// The unique identifier for the user that you want to activate.
    /// This member is required.
    public var userId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        userId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.userId = userId
    }
}

struct EnableUserInputBody: Swift.Equatable {
    let clientToken: Swift.String?
}

extension EnableUserInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension EnableUserOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: EnableUserOutputBody = try responseDecoder.decode(responseBody: data)
            self.userId = output.userId
        } else {
            self.userId = nil
        }
    }
}

public struct EnableUserOutput: Swift.Equatable {
    /// The unique identifier for the active user.
    public var userId: Swift.String?

    public init(
        userId: Swift.String? = nil
    )
    {
        self.userId = userId
    }
}

struct EnableUserOutputBody: Swift.Equatable {
    let userId: Swift.String?
}

extension EnableUserOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case userId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userId)
        userId = userIdDecoded
    }
}

enum EnableUserOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension FinspacedataClientTypes {
    /// Changeset Error Category
    public enum ErrorCategory: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case accessDenied
        case cancelled
        case internalServiceException
        case resourceNotFound
        case serviceQuotaExceeded
        case throttling
        case userRecoverable
        case validation
        case sdkUnknown(Swift.String)

        public static var allCases: [ErrorCategory] {
            return [
                .accessDenied,
                .cancelled,
                .internalServiceException,
                .resourceNotFound,
                .serviceQuotaExceeded,
                .throttling,
                .userRecoverable,
                .validation,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .accessDenied: return "ACCESS_DENIED"
            case .cancelled: return "CANCELLED"
            case .internalServiceException: return "INTERNAL_SERVICE_EXCEPTION"
            case .resourceNotFound: return "RESOURCE_NOT_FOUND"
            case .serviceQuotaExceeded: return "SERVICE_QUOTA_EXCEEDED"
            case .throttling: return "THROTTLING"
            case .userRecoverable: return "USER_RECOVERABLE"
            case .validation: return "VALIDATION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ErrorCategory(rawValue: rawValue) ?? ErrorCategory.sdkUnknown(rawValue)
        }
    }
}

extension FinspacedataClientTypes {
    /// Data View Export File Format
    public enum ExportFileFormat: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case delimitedText
        case parquet
        case sdkUnknown(Swift.String)

        public static var allCases: [ExportFileFormat] {
            return [
                .delimitedText,
                .parquet,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .delimitedText: return "DELIMITED_TEXT"
            case .parquet: return "PARQUET"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ExportFileFormat(rawValue: rawValue) ?? ExportFileFormat.sdkUnknown(rawValue)
        }
    }
}

extension GetChangesetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let datasetId = datasetId else {
            return nil
        }
        guard let changesetId = changesetId else {
            return nil
        }
        return "/datasets/\(datasetId.urlPercentEncoding())/changesetsv2/\(changesetId.urlPercentEncoding())"
    }
}

/// Request to describe a changeset.
public struct GetChangesetInput: Swift.Equatable {
    /// The unique identifier of the Changeset for which to get data.
    /// This member is required.
    public var changesetId: Swift.String?
    /// The unique identifier for the FinSpace Dataset where the Changeset is created.
    /// This member is required.
    public var datasetId: Swift.String?

    public init(
        changesetId: Swift.String? = nil,
        datasetId: Swift.String? = nil
    )
    {
        self.changesetId = changesetId
        self.datasetId = datasetId
    }
}

struct GetChangesetInputBody: Swift.Equatable {
}

extension GetChangesetInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetChangesetOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetChangesetOutputBody = try responseDecoder.decode(responseBody: data)
            self.activeFromTimestamp = output.activeFromTimestamp
            self.activeUntilTimestamp = output.activeUntilTimestamp
            self.changeType = output.changeType
            self.changesetArn = output.changesetArn
            self.changesetId = output.changesetId
            self.createTime = output.createTime
            self.datasetId = output.datasetId
            self.errorInfo = output.errorInfo
            self.formatParams = output.formatParams
            self.sourceParams = output.sourceParams
            self.status = output.status
            self.updatedByChangesetId = output.updatedByChangesetId
            self.updatesChangesetId = output.updatesChangesetId
        } else {
            self.activeFromTimestamp = nil
            self.activeUntilTimestamp = nil
            self.changeType = nil
            self.changesetArn = nil
            self.changesetId = nil
            self.createTime = 0
            self.datasetId = nil
            self.errorInfo = nil
            self.formatParams = nil
            self.sourceParams = nil
            self.status = nil
            self.updatedByChangesetId = nil
            self.updatesChangesetId = nil
        }
    }
}

/// The response from a describe changeset operation
public struct GetChangesetOutput: Swift.Equatable {
    /// Beginning time from which the Changeset is active. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
    public var activeFromTimestamp: Swift.Int?
    /// Time until which the Changeset is active. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
    public var activeUntilTimestamp: Swift.Int?
    /// Type that indicates how a Changeset is applied to a Dataset.
    ///
    /// * REPLACE – Changeset is considered as a replacement to all prior loaded Changesets.
    ///
    /// * APPEND – Changeset is considered as an addition to the end of all prior loaded Changesets.
    ///
    /// * MODIFY – Changeset is considered as a replacement to a specific prior ingested Changeset.
    public var changeType: FinspacedataClientTypes.ChangeType?
    /// The ARN identifier of the Changeset.
    public var changesetArn: Swift.String?
    /// The unique identifier for a Changeset.
    public var changesetId: Swift.String?
    /// The timestamp at which the Changeset was created in FinSpace. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
    public var createTime: Swift.Int
    /// The unique identifier for the FinSpace Dataset where the Changeset is created.
    public var datasetId: Swift.String?
    /// The structure with error messages.
    public var errorInfo: FinspacedataClientTypes.ChangesetErrorInfo?
    /// Structure of the source file(s).
    public var formatParams: [Swift.String:Swift.String]?
    /// Options that define the location of the data being ingested.
    public var sourceParams: [Swift.String:Swift.String]?
    /// The status of Changeset creation operation.
    public var status: FinspacedataClientTypes.IngestionStatus?
    /// The unique identifier of the updated Changeset.
    public var updatedByChangesetId: Swift.String?
    /// The unique identifier of the Changeset that is being updated.
    public var updatesChangesetId: Swift.String?

    public init(
        activeFromTimestamp: Swift.Int? = nil,
        activeUntilTimestamp: Swift.Int? = nil,
        changeType: FinspacedataClientTypes.ChangeType? = nil,
        changesetArn: Swift.String? = nil,
        changesetId: Swift.String? = nil,
        createTime: Swift.Int = 0,
        datasetId: Swift.String? = nil,
        errorInfo: FinspacedataClientTypes.ChangesetErrorInfo? = nil,
        formatParams: [Swift.String:Swift.String]? = nil,
        sourceParams: [Swift.String:Swift.String]? = nil,
        status: FinspacedataClientTypes.IngestionStatus? = nil,
        updatedByChangesetId: Swift.String? = nil,
        updatesChangesetId: Swift.String? = nil
    )
    {
        self.activeFromTimestamp = activeFromTimestamp
        self.activeUntilTimestamp = activeUntilTimestamp
        self.changeType = changeType
        self.changesetArn = changesetArn
        self.changesetId = changesetId
        self.createTime = createTime
        self.datasetId = datasetId
        self.errorInfo = errorInfo
        self.formatParams = formatParams
        self.sourceParams = sourceParams
        self.status = status
        self.updatedByChangesetId = updatedByChangesetId
        self.updatesChangesetId = updatesChangesetId
    }
}

struct GetChangesetOutputBody: Swift.Equatable {
    let changesetId: Swift.String?
    let changesetArn: Swift.String?
    let datasetId: Swift.String?
    let changeType: FinspacedataClientTypes.ChangeType?
    let sourceParams: [Swift.String:Swift.String]?
    let formatParams: [Swift.String:Swift.String]?
    let createTime: Swift.Int
    let status: FinspacedataClientTypes.IngestionStatus?
    let errorInfo: FinspacedataClientTypes.ChangesetErrorInfo?
    let activeUntilTimestamp: Swift.Int?
    let activeFromTimestamp: Swift.Int?
    let updatesChangesetId: Swift.String?
    let updatedByChangesetId: Swift.String?
}

extension GetChangesetOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case activeFromTimestamp
        case activeUntilTimestamp
        case changeType
        case changesetArn
        case changesetId
        case createTime
        case datasetId
        case errorInfo
        case formatParams
        case sourceParams
        case status
        case updatedByChangesetId
        case updatesChangesetId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let changesetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .changesetId)
        changesetId = changesetIdDecoded
        let changesetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .changesetArn)
        changesetArn = changesetArnDecoded
        let datasetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetId)
        datasetId = datasetIdDecoded
        let changeTypeDecoded = try containerValues.decodeIfPresent(FinspacedataClientTypes.ChangeType.self, forKey: .changeType)
        changeType = changeTypeDecoded
        let sourceParamsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .sourceParams)
        var sourceParamsDecoded0: [Swift.String:Swift.String]? = nil
        if let sourceParamsContainer = sourceParamsContainer {
            sourceParamsDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringmapvalue0) in sourceParamsContainer {
                if let stringmapvalue0 = stringmapvalue0 {
                    sourceParamsDecoded0?[key0] = stringmapvalue0
                }
            }
        }
        sourceParams = sourceParamsDecoded0
        let formatParamsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .formatParams)
        var formatParamsDecoded0: [Swift.String:Swift.String]? = nil
        if let formatParamsContainer = formatParamsContainer {
            formatParamsDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringmapvalue0) in formatParamsContainer {
                if let stringmapvalue0 = stringmapvalue0 {
                    formatParamsDecoded0?[key0] = stringmapvalue0
                }
            }
        }
        formatParams = formatParamsDecoded0
        let createTimeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .createTime) ?? 0
        createTime = createTimeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(FinspacedataClientTypes.IngestionStatus.self, forKey: .status)
        status = statusDecoded
        let errorInfoDecoded = try containerValues.decodeIfPresent(FinspacedataClientTypes.ChangesetErrorInfo.self, forKey: .errorInfo)
        errorInfo = errorInfoDecoded
        let activeUntilTimestampDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .activeUntilTimestamp)
        activeUntilTimestamp = activeUntilTimestampDecoded
        let activeFromTimestampDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .activeFromTimestamp)
        activeFromTimestamp = activeFromTimestampDecoded
        let updatesChangesetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .updatesChangesetId)
        updatesChangesetId = updatesChangesetIdDecoded
        let updatedByChangesetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .updatedByChangesetId)
        updatedByChangesetId = updatedByChangesetIdDecoded
    }
}

enum GetChangesetOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetDataViewInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let datasetId = datasetId else {
            return nil
        }
        guard let dataViewId = dataViewId else {
            return nil
        }
        return "/datasets/\(datasetId.urlPercentEncoding())/dataviewsv2/\(dataViewId.urlPercentEncoding())"
    }
}

/// Request for retrieving a data view detail. Grouped / accessible within a dataset by its dataset id.
public struct GetDataViewInput: Swift.Equatable {
    /// The unique identifier for the Dataview.
    /// This member is required.
    public var dataViewId: Swift.String?
    /// The unique identifier for the Dataset used in the Dataview.
    /// This member is required.
    public var datasetId: Swift.String?

    public init(
        dataViewId: Swift.String? = nil,
        datasetId: Swift.String? = nil
    )
    {
        self.dataViewId = dataViewId
        self.datasetId = datasetId
    }
}

struct GetDataViewInputBody: Swift.Equatable {
}

extension GetDataViewInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetDataViewOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetDataViewOutputBody = try responseDecoder.decode(responseBody: data)
            self.asOfTimestamp = output.asOfTimestamp
            self.autoUpdate = output.autoUpdate
            self.createTime = output.createTime
            self.dataViewArn = output.dataViewArn
            self.dataViewId = output.dataViewId
            self.datasetId = output.datasetId
            self.destinationTypeParams = output.destinationTypeParams
            self.errorInfo = output.errorInfo
            self.lastModifiedTime = output.lastModifiedTime
            self.partitionColumns = output.partitionColumns
            self.sortColumns = output.sortColumns
            self.status = output.status
        } else {
            self.asOfTimestamp = nil
            self.autoUpdate = false
            self.createTime = 0
            self.dataViewArn = nil
            self.dataViewId = nil
            self.datasetId = nil
            self.destinationTypeParams = nil
            self.errorInfo = nil
            self.lastModifiedTime = 0
            self.partitionColumns = nil
            self.sortColumns = nil
            self.status = nil
        }
    }
}

/// Response from retrieving a dataview, which includes details on the target database and table name
public struct GetDataViewOutput: Swift.Equatable {
    /// Time range to use for the Dataview. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
    public var asOfTimestamp: Swift.Int?
    /// Flag to indicate Dataview should be updated automatically.
    public var autoUpdate: Swift.Bool
    /// The timestamp at which the Dataview was created in FinSpace. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
    public var createTime: Swift.Int
    /// The ARN identifier of the Dataview.
    public var dataViewArn: Swift.String?
    /// The unique identifier for the Dataview.
    public var dataViewId: Swift.String?
    /// The unique identifier for the Dataset used in the Dataview.
    public var datasetId: Swift.String?
    /// Options that define the destination type for the Dataview.
    public var destinationTypeParams: FinspacedataClientTypes.DataViewDestinationTypeParams?
    /// Information about an error that occurred for the Dataview.
    public var errorInfo: FinspacedataClientTypes.DataViewErrorInfo?
    /// The last time that a Dataview was modified. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
    public var lastModifiedTime: Swift.Int
    /// Ordered set of column names used to partition data.
    public var partitionColumns: [Swift.String]?
    /// Columns to be used for sorting the data.
    public var sortColumns: [Swift.String]?
    /// The status of a Dataview creation.
    ///
    /// * RUNNING – Dataview creation is running.
    ///
    /// * STARTING – Dataview creation is starting.
    ///
    /// * FAILED – Dataview creation has failed.
    ///
    /// * CANCELLED – Dataview creation has been cancelled.
    ///
    /// * TIMEOUT – Dataview creation has timed out.
    ///
    /// * SUCCESS – Dataview creation has succeeded.
    ///
    /// * PENDING – Dataview creation is pending.
    ///
    /// * FAILED_CLEANUP_FAILED – Dataview creation failed and resource cleanup failed.
    public var status: FinspacedataClientTypes.DataViewStatus?

    public init(
        asOfTimestamp: Swift.Int? = nil,
        autoUpdate: Swift.Bool = false,
        createTime: Swift.Int = 0,
        dataViewArn: Swift.String? = nil,
        dataViewId: Swift.String? = nil,
        datasetId: Swift.String? = nil,
        destinationTypeParams: FinspacedataClientTypes.DataViewDestinationTypeParams? = nil,
        errorInfo: FinspacedataClientTypes.DataViewErrorInfo? = nil,
        lastModifiedTime: Swift.Int = 0,
        partitionColumns: [Swift.String]? = nil,
        sortColumns: [Swift.String]? = nil,
        status: FinspacedataClientTypes.DataViewStatus? = nil
    )
    {
        self.asOfTimestamp = asOfTimestamp
        self.autoUpdate = autoUpdate
        self.createTime = createTime
        self.dataViewArn = dataViewArn
        self.dataViewId = dataViewId
        self.datasetId = datasetId
        self.destinationTypeParams = destinationTypeParams
        self.errorInfo = errorInfo
        self.lastModifiedTime = lastModifiedTime
        self.partitionColumns = partitionColumns
        self.sortColumns = sortColumns
        self.status = status
    }
}

struct GetDataViewOutputBody: Swift.Equatable {
    let autoUpdate: Swift.Bool
    let partitionColumns: [Swift.String]?
    let datasetId: Swift.String?
    let asOfTimestamp: Swift.Int?
    let errorInfo: FinspacedataClientTypes.DataViewErrorInfo?
    let lastModifiedTime: Swift.Int
    let createTime: Swift.Int
    let sortColumns: [Swift.String]?
    let dataViewId: Swift.String?
    let dataViewArn: Swift.String?
    let destinationTypeParams: FinspacedataClientTypes.DataViewDestinationTypeParams?
    let status: FinspacedataClientTypes.DataViewStatus?
}

extension GetDataViewOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case asOfTimestamp
        case autoUpdate
        case createTime
        case dataViewArn
        case dataViewId
        case datasetId
        case destinationTypeParams
        case errorInfo
        case lastModifiedTime
        case partitionColumns
        case sortColumns
        case status
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let autoUpdateDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .autoUpdate) ?? false
        autoUpdate = autoUpdateDecoded
        let partitionColumnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .partitionColumns)
        var partitionColumnsDecoded0:[Swift.String]? = nil
        if let partitionColumnsContainer = partitionColumnsContainer {
            partitionColumnsDecoded0 = [Swift.String]()
            for string0 in partitionColumnsContainer {
                if let string0 = string0 {
                    partitionColumnsDecoded0?.append(string0)
                }
            }
        }
        partitionColumns = partitionColumnsDecoded0
        let datasetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetId)
        datasetId = datasetIdDecoded
        let asOfTimestampDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .asOfTimestamp)
        asOfTimestamp = asOfTimestampDecoded
        let errorInfoDecoded = try containerValues.decodeIfPresent(FinspacedataClientTypes.DataViewErrorInfo.self, forKey: .errorInfo)
        errorInfo = errorInfoDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .lastModifiedTime) ?? 0
        lastModifiedTime = lastModifiedTimeDecoded
        let createTimeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .createTime) ?? 0
        createTime = createTimeDecoded
        let sortColumnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .sortColumns)
        var sortColumnsDecoded0:[Swift.String]? = nil
        if let sortColumnsContainer = sortColumnsContainer {
            sortColumnsDecoded0 = [Swift.String]()
            for string0 in sortColumnsContainer {
                if let string0 = string0 {
                    sortColumnsDecoded0?.append(string0)
                }
            }
        }
        sortColumns = sortColumnsDecoded0
        let dataViewIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataViewId)
        dataViewId = dataViewIdDecoded
        let dataViewArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dataViewArn)
        dataViewArn = dataViewArnDecoded
        let destinationTypeParamsDecoded = try containerValues.decodeIfPresent(FinspacedataClientTypes.DataViewDestinationTypeParams.self, forKey: .destinationTypeParams)
        destinationTypeParams = destinationTypeParamsDecoded
        let statusDecoded = try containerValues.decodeIfPresent(FinspacedataClientTypes.DataViewStatus.self, forKey: .status)
        status = statusDecoded
    }
}

enum GetDataViewOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetDatasetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let datasetId = datasetId else {
            return nil
        }
        return "/datasetsv2/\(datasetId.urlPercentEncoding())"
    }
}

/// Request for the GetDataset operation.
public struct GetDatasetInput: Swift.Equatable {
    /// The unique identifier for a Dataset.
    /// This member is required.
    public var datasetId: Swift.String?

    public init(
        datasetId: Swift.String? = nil
    )
    {
        self.datasetId = datasetId
    }
}

struct GetDatasetInputBody: Swift.Equatable {
}

extension GetDatasetInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetDatasetOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetDatasetOutputBody = try responseDecoder.decode(responseBody: data)
            self.alias = output.alias
            self.createTime = output.createTime
            self.datasetArn = output.datasetArn
            self.datasetDescription = output.datasetDescription
            self.datasetId = output.datasetId
            self.datasetTitle = output.datasetTitle
            self.kind = output.kind
            self.lastModifiedTime = output.lastModifiedTime
            self.schemaDefinition = output.schemaDefinition
            self.status = output.status
        } else {
            self.alias = nil
            self.createTime = 0
            self.datasetArn = nil
            self.datasetDescription = nil
            self.datasetId = nil
            self.datasetTitle = nil
            self.kind = nil
            self.lastModifiedTime = 0
            self.schemaDefinition = nil
            self.status = nil
        }
    }
}

/// Response for the GetDataset operation
public struct GetDatasetOutput: Swift.Equatable {
    /// The unique resource identifier for a Dataset.
    public var alias: Swift.String?
    /// The timestamp at which the Dataset was created in FinSpace. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
    public var createTime: Swift.Int
    /// The ARN identifier of the Dataset.
    public var datasetArn: Swift.String?
    /// A description of the Dataset.
    public var datasetDescription: Swift.String?
    /// The unique identifier for a Dataset.
    public var datasetId: Swift.String?
    /// Display title for a Dataset.
    public var datasetTitle: Swift.String?
    /// The format in which Dataset data is structured.
    ///
    /// * TABULAR – Data is structured in a tabular format.
    ///
    /// * NON_TABULAR – Data is structured in a non-tabular format.
    public var kind: FinspacedataClientTypes.DatasetKind?
    /// The last time that the Dataset was modified. The value is determined as epoch time in milliseconds. For example, the value for Monday, November 1, 2021 12:00:00 PM UTC is specified as 1635768000000.
    public var lastModifiedTime: Swift.Int
    /// Definition for a schema on a tabular Dataset.
    public var schemaDefinition: FinspacedataClientTypes.SchemaUnion?
    /// Status of the Dataset creation.
    ///
    /// * PENDING – Dataset is pending creation.
    ///
    /// * FAILED – Dataset creation has failed.
    ///
    /// * SUCCESS – Dataset creation has succeeded.
    ///
    /// * RUNNING – Dataset creation is running.
    public var status: FinspacedataClientTypes.DatasetStatus?

    public init(
        alias: Swift.String? = nil,
        createTime: Swift.Int = 0,
        datasetArn: Swift.String? = nil,
        datasetDescription: Swift.String? = nil,
        datasetId: Swift.String? = nil,
        datasetTitle: Swift.String? = nil,
        kind: FinspacedataClientTypes.DatasetKind? = nil,
        lastModifiedTime: Swift.Int = 0,
        schemaDefinition: FinspacedataClientTypes.SchemaUnion? = nil,
        status: FinspacedataClientTypes.DatasetStatus? = nil
    )
    {
        self.alias = alias
        self.createTime = createTime
        self.datasetArn = datasetArn
        self.datasetDescription = datasetDescription
        self.datasetId = datasetId
        self.datasetTitle = datasetTitle
        self.kind = kind
        self.lastModifiedTime = lastModifiedTime
        self.schemaDefinition = schemaDefinition
        self.status = status
    }
}

struct GetDatasetOutputBody: Swift.Equatable {
    let datasetId: Swift.String?
    let datasetArn: Swift.String?
    let datasetTitle: Swift.String?
    let kind: FinspacedataClientTypes.DatasetKind?
    let datasetDescription: Swift.String?
    let createTime: Swift.Int
    let lastModifiedTime: Swift.Int
    let schemaDefinition: FinspacedataClientTypes.SchemaUnion?
    let alias: Swift.String?
    let status: FinspacedataClientTypes.DatasetStatus?
}

extension GetDatasetOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alias
        case createTime
        case datasetArn
        case datasetDescription
        case datasetId
        case datasetTitle
        case kind
        case lastModifiedTime
        case schemaDefinition
        case status
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetId)
        datasetId = datasetIdDecoded
        let datasetArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetArn)
        datasetArn = datasetArnDecoded
        let datasetTitleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetTitle)
        datasetTitle = datasetTitleDecoded
        let kindDecoded = try containerValues.decodeIfPresent(FinspacedataClientTypes.DatasetKind.self, forKey: .kind)
        kind = kindDecoded
        let datasetDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetDescription)
        datasetDescription = datasetDescriptionDecoded
        let createTimeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .createTime) ?? 0
        createTime = createTimeDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .lastModifiedTime) ?? 0
        lastModifiedTime = lastModifiedTimeDecoded
        let schemaDefinitionDecoded = try containerValues.decodeIfPresent(FinspacedataClientTypes.SchemaUnion.self, forKey: .schemaDefinition)
        schemaDefinition = schemaDefinitionDecoded
        let aliasDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .alias)
        alias = aliasDecoded
        let statusDecoded = try containerValues.decodeIfPresent(FinspacedataClientTypes.DatasetStatus.self, forKey: .status)
        status = statusDecoded
    }
}

enum GetDatasetOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetExternalDataViewAccessDetailsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let datasetId = datasetId else {
            return nil
        }
        guard let dataViewId = dataViewId else {
            return nil
        }
        return "/datasets/\(datasetId.urlPercentEncoding())/dataviewsv2/\(dataViewId.urlPercentEncoding())/external-access-details"
    }
}

public struct GetExternalDataViewAccessDetailsInput: Swift.Equatable {
    /// The unique identifier for the Dataview that you want to access.
    /// This member is required.
    public var dataViewId: Swift.String?
    /// The unique identifier for the Dataset.
    /// This member is required.
    public var datasetId: Swift.String?

    public init(
        dataViewId: Swift.String? = nil,
        datasetId: Swift.String? = nil
    )
    {
        self.dataViewId = dataViewId
        self.datasetId = datasetId
    }
}

struct GetExternalDataViewAccessDetailsInputBody: Swift.Equatable {
}

extension GetExternalDataViewAccessDetailsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetExternalDataViewAccessDetailsOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetExternalDataViewAccessDetailsOutput(s3Location: \(Swift.String(describing: s3Location)), credentials: \"CONTENT_REDACTED\")"}
}

extension GetExternalDataViewAccessDetailsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetExternalDataViewAccessDetailsOutputBody = try responseDecoder.decode(responseBody: data)
            self.credentials = output.credentials
            self.s3Location = output.s3Location
        } else {
            self.credentials = nil
            self.s3Location = nil
        }
    }
}

public struct GetExternalDataViewAccessDetailsOutput: Swift.Equatable {
    /// The credentials required to access the external Dataview from the S3 location.
    public var credentials: FinspacedataClientTypes.AwsCredentials?
    /// The location where the external Dataview is stored.
    public var s3Location: FinspacedataClientTypes.S3Location?

    public init(
        credentials: FinspacedataClientTypes.AwsCredentials? = nil,
        s3Location: FinspacedataClientTypes.S3Location? = nil
    )
    {
        self.credentials = credentials
        self.s3Location = s3Location
    }
}

struct GetExternalDataViewAccessDetailsOutputBody: Swift.Equatable {
    let credentials: FinspacedataClientTypes.AwsCredentials?
    let s3Location: FinspacedataClientTypes.S3Location?
}

extension GetExternalDataViewAccessDetailsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case credentials
        case s3Location
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let credentialsDecoded = try containerValues.decodeIfPresent(FinspacedataClientTypes.AwsCredentials.self, forKey: .credentials)
        credentials = credentialsDecoded
        let s3LocationDecoded = try containerValues.decodeIfPresent(FinspacedataClientTypes.S3Location.self, forKey: .s3Location)
        s3Location = s3LocationDecoded
    }
}

enum GetExternalDataViewAccessDetailsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetPermissionGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let permissionGroupId = permissionGroupId else {
            return nil
        }
        return "/permission-group/\(permissionGroupId.urlPercentEncoding())"
    }
}

public struct GetPermissionGroupInput: Swift.Equatable {
    /// The unique identifier for the permission group.
    /// This member is required.
    public var permissionGroupId: Swift.String?

    public init(
        permissionGroupId: Swift.String? = nil
    )
    {
        self.permissionGroupId = permissionGroupId
    }
}

struct GetPermissionGroupInputBody: Swift.Equatable {
}

extension GetPermissionGroupInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetPermissionGroupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetPermissionGroupOutputBody = try responseDecoder.decode(responseBody: data)
            self.permissionGroup = output.permissionGroup
        } else {
            self.permissionGroup = nil
        }
    }
}

public struct GetPermissionGroupOutput: Swift.Equatable {
    /// The structure for a permission group.
    public var permissionGroup: FinspacedataClientTypes.PermissionGroup?

    public init(
        permissionGroup: FinspacedataClientTypes.PermissionGroup? = nil
    )
    {
        self.permissionGroup = permissionGroup
    }
}

struct GetPermissionGroupOutputBody: Swift.Equatable {
    let permissionGroup: FinspacedataClientTypes.PermissionGroup?
}

extension GetPermissionGroupOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case permissionGroup
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let permissionGroupDecoded = try containerValues.decodeIfPresent(FinspacedataClientTypes.PermissionGroup.self, forKey: .permissionGroup)
        permissionGroup = permissionGroupDecoded
    }
}

enum GetPermissionGroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetProgrammaticAccessCredentialsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let environmentId = environmentId else {
                let message = "Creating a URL Query Item failed. environmentId is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let environmentIdQueryItem = ClientRuntime.URLQueryItem(name: "environmentId".urlPercentEncoding(), value: Swift.String(environmentId).urlPercentEncoding())
            items.append(environmentIdQueryItem)
            if let durationInMinutes = durationInMinutes {
                let durationInMinutesQueryItem = ClientRuntime.URLQueryItem(name: "durationInMinutes".urlPercentEncoding(), value: Swift.String(durationInMinutes).urlPercentEncoding())
                items.append(durationInMinutesQueryItem)
            }
            return items
        }
    }
}

extension GetProgrammaticAccessCredentialsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/credentials/programmatic"
    }
}

/// Request for GetProgrammaticAccessCredentials operation
public struct GetProgrammaticAccessCredentialsInput: Swift.Equatable {
    /// The time duration in which the credentials remain valid.
    public var durationInMinutes: Swift.Int?
    /// The FinSpace environment identifier.
    /// This member is required.
    public var environmentId: Swift.String?

    public init(
        durationInMinutes: Swift.Int? = nil,
        environmentId: Swift.String? = nil
    )
    {
        self.durationInMinutes = durationInMinutes
        self.environmentId = environmentId
    }
}

struct GetProgrammaticAccessCredentialsInputBody: Swift.Equatable {
}

extension GetProgrammaticAccessCredentialsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetProgrammaticAccessCredentialsOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetProgrammaticAccessCredentialsOutput(durationInMinutes: \(Swift.String(describing: durationInMinutes)), credentials: \"CONTENT_REDACTED\")"}
}

extension GetProgrammaticAccessCredentialsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetProgrammaticAccessCredentialsOutputBody = try responseDecoder.decode(responseBody: data)
            self.credentials = output.credentials
            self.durationInMinutes = output.durationInMinutes
        } else {
            self.credentials = nil
            self.durationInMinutes = 0
        }
    }
}

/// Response for GetProgrammaticAccessCredentials operation
public struct GetProgrammaticAccessCredentialsOutput: Swift.Equatable {
    /// Returns the programmatic credentials.
    public var credentials: FinspacedataClientTypes.Credentials?
    /// Returns the duration in which the credentials will remain valid.
    public var durationInMinutes: Swift.Int

    public init(
        credentials: FinspacedataClientTypes.Credentials? = nil,
        durationInMinutes: Swift.Int = 0
    )
    {
        self.credentials = credentials
        self.durationInMinutes = durationInMinutes
    }
}

struct GetProgrammaticAccessCredentialsOutputBody: Swift.Equatable {
    let credentials: FinspacedataClientTypes.Credentials?
    let durationInMinutes: Swift.Int
}

extension GetProgrammaticAccessCredentialsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case credentials
        case durationInMinutes
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let credentialsDecoded = try containerValues.decodeIfPresent(FinspacedataClientTypes.Credentials.self, forKey: .credentials)
        credentials = credentialsDecoded
        let durationInMinutesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .durationInMinutes) ?? 0
        durationInMinutes = durationInMinutesDecoded
    }
}

enum GetProgrammaticAccessCredentialsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetUserInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let userId = userId else {
            return nil
        }
        return "/user/\(userId.urlPercentEncoding())"
    }
}

public struct GetUserInput: Swift.Equatable {
    /// The unique identifier of the user to get data for.
    /// This member is required.
    public var userId: Swift.String?

    public init(
        userId: Swift.String? = nil
    )
    {
        self.userId = userId
    }
}

struct GetUserInputBody: Swift.Equatable {
}

extension GetUserInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetUserOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetUserOutput(apiAccess: \(Swift.String(describing: apiAccess)), apiAccessPrincipalArn: \(Swift.String(describing: apiAccessPrincipalArn)), createTime: \(Swift.String(describing: createTime)), lastDisabledTime: \(Swift.String(describing: lastDisabledTime)), lastEnabledTime: \(Swift.String(describing: lastEnabledTime)), lastLoginTime: \(Swift.String(describing: lastLoginTime)), lastModifiedTime: \(Swift.String(describing: lastModifiedTime)), status: \(Swift.String(describing: status)), type: \(Swift.String(describing: type)), userId: \(Swift.String(describing: userId)), emailAddress: \"CONTENT_REDACTED\", firstName: \"CONTENT_REDACTED\", lastName: \"CONTENT_REDACTED\")"}
}

extension GetUserOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetUserOutputBody = try responseDecoder.decode(responseBody: data)
            self.apiAccess = output.apiAccess
            self.apiAccessPrincipalArn = output.apiAccessPrincipalArn
            self.createTime = output.createTime
            self.emailAddress = output.emailAddress
            self.firstName = output.firstName
            self.lastDisabledTime = output.lastDisabledTime
            self.lastEnabledTime = output.lastEnabledTime
            self.lastLoginTime = output.lastLoginTime
            self.lastModifiedTime = output.lastModifiedTime
            self.lastName = output.lastName
            self.status = output.status
            self.type = output.type
            self.userId = output.userId
        } else {
            self.apiAccess = nil
            self.apiAccessPrincipalArn = nil
            self.createTime = 0
            self.emailAddress = nil
            self.firstName = nil
            self.lastDisabledTime = 0
            self.lastEnabledTime = 0
            self.lastLoginTime = 0
            self.lastModifiedTime = 0
            self.lastName = nil
            self.status = nil
            self.type = nil
            self.userId = nil
        }
    }
}

public struct GetUserOutput: Swift.Equatable {
    /// Indicates whether the user can use the GetProgrammaticAccessCredentials API to obtain credentials that can then be used to access other FinSpace Data API operations.
    ///
    /// * ENABLED – The user has permissions to use the APIs.
    ///
    /// * DISABLED – The user does not have permissions to use any APIs.
    public var apiAccess: FinspacedataClientTypes.ApiAccess?
    /// The ARN identifier of an AWS user or role that is allowed to call the GetProgrammaticAccessCredentials API to obtain a credentials token for a specific FinSpace user. This must be an IAM role within your FinSpace account.
    public var apiAccessPrincipalArn: Swift.String?
    /// The timestamp at which the user was created in FinSpace. The value is determined as epoch time in milliseconds.
    public var createTime: Swift.Int
    /// The email address that is associated with the user.
    public var emailAddress: Swift.String?
    /// The first name of the user.
    public var firstName: Swift.String?
    /// Describes the last time the user was deactivated. The value is determined as epoch time in milliseconds.
    public var lastDisabledTime: Swift.Int
    /// Describes the last time the user was activated. The value is determined as epoch time in milliseconds.
    public var lastEnabledTime: Swift.Int
    /// Describes the last time that the user logged into their account. The value is determined as epoch time in milliseconds.
    public var lastLoginTime: Swift.Int
    /// Describes the last time the user details were updated. The value is determined as epoch time in milliseconds.
    public var lastModifiedTime: Swift.Int
    /// The last name of the user.
    public var lastName: Swift.String?
    /// The current status of the user.
    ///
    /// * CREATING – The creation is in progress.
    ///
    /// * ENABLED – The user is created and is currently active.
    ///
    /// * DISABLED – The user is currently inactive.
    public var status: FinspacedataClientTypes.UserStatus?
    /// Indicates the type of user.
    ///
    /// * SUPER_USER – A user with permission to all the functionality and data in FinSpace.
    ///
    ///
    ///
    ///
    /// * APP_USER – A user with specific permissions in FinSpace. The users are assigned permissions by adding them to a permission group.
    public var type: FinspacedataClientTypes.UserType?
    /// The unique identifier for the user that is retrieved.
    public var userId: Swift.String?

    public init(
        apiAccess: FinspacedataClientTypes.ApiAccess? = nil,
        apiAccessPrincipalArn: Swift.String? = nil,
        createTime: Swift.Int = 0,
        emailAddress: Swift.String? = nil,
        firstName: Swift.String? = nil,
        lastDisabledTime: Swift.Int = 0,
        lastEnabledTime: Swift.Int = 0,
        lastLoginTime: Swift.Int = 0,
        lastModifiedTime: Swift.Int = 0,
        lastName: Swift.String? = nil,
        status: FinspacedataClientTypes.UserStatus? = nil,
        type: FinspacedataClientTypes.UserType? = nil,
        userId: Swift.String? = nil
    )
    {
        self.apiAccess = apiAccess
        self.apiAccessPrincipalArn = apiAccessPrincipalArn
        self.createTime = createTime
        self.emailAddress = emailAddress
        self.firstName = firstName
        self.lastDisabledTime = lastDisabledTime
        self.lastEnabledTime = lastEnabledTime
        self.lastLoginTime = lastLoginTime
        self.lastModifiedTime = lastModifiedTime
        self.lastName = lastName
        self.status = status
        self.type = type
        self.userId = userId
    }
}

struct GetUserOutputBody: Swift.Equatable {
    let userId: Swift.String?
    let status: FinspacedataClientTypes.UserStatus?
    let firstName: Swift.String?
    let lastName: Swift.String?
    let emailAddress: Swift.String?
    let type: FinspacedataClientTypes.UserType?
    let apiAccess: FinspacedataClientTypes.ApiAccess?
    let apiAccessPrincipalArn: Swift.String?
    let createTime: Swift.Int
    let lastEnabledTime: Swift.Int
    let lastDisabledTime: Swift.Int
    let lastModifiedTime: Swift.Int
    let lastLoginTime: Swift.Int
}

extension GetUserOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiAccess
        case apiAccessPrincipalArn
        case createTime
        case emailAddress
        case firstName
        case lastDisabledTime
        case lastEnabledTime
        case lastLoginTime
        case lastModifiedTime
        case lastName
        case status
        case type
        case userId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userId)
        userId = userIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(FinspacedataClientTypes.UserStatus.self, forKey: .status)
        status = statusDecoded
        let firstNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .firstName)
        firstName = firstNameDecoded
        let lastNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastName)
        lastName = lastNameDecoded
        let emailAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .emailAddress)
        emailAddress = emailAddressDecoded
        let typeDecoded = try containerValues.decodeIfPresent(FinspacedataClientTypes.UserType.self, forKey: .type)
        type = typeDecoded
        let apiAccessDecoded = try containerValues.decodeIfPresent(FinspacedataClientTypes.ApiAccess.self, forKey: .apiAccess)
        apiAccess = apiAccessDecoded
        let apiAccessPrincipalArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiAccessPrincipalArn)
        apiAccessPrincipalArn = apiAccessPrincipalArnDecoded
        let createTimeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .createTime) ?? 0
        createTime = createTimeDecoded
        let lastEnabledTimeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .lastEnabledTime) ?? 0
        lastEnabledTime = lastEnabledTimeDecoded
        let lastDisabledTimeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .lastDisabledTime) ?? 0
        lastDisabledTime = lastDisabledTimeDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .lastModifiedTime) ?? 0
        lastModifiedTime = lastModifiedTimeDecoded
        let lastLoginTimeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .lastLoginTime) ?? 0
        lastLoginTime = lastLoginTimeDecoded
    }
}

enum GetUserOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetWorkingLocationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case locationType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let locationType = self.locationType {
            try encodeContainer.encode(locationType.rawValue, forKey: .locationType)
        }
    }
}

extension GetWorkingLocationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/workingLocationV1"
    }
}

public struct GetWorkingLocationInput: Swift.Equatable {
    /// Specify the type of the working location.
    ///
    /// * SAGEMAKER – Use the Amazon S3 location as a temporary location to store data content when working with FinSpace Notebooks that run on SageMaker studio.
    ///
    /// * INGESTION – Use the Amazon S3 location as a staging location to copy your data content and then use the location with the Changeset creation operation.
    public var locationType: FinspacedataClientTypes.LocationType?

    public init(
        locationType: FinspacedataClientTypes.LocationType? = nil
    )
    {
        self.locationType = locationType
    }
}

struct GetWorkingLocationInputBody: Swift.Equatable {
    let locationType: FinspacedataClientTypes.LocationType?
}

extension GetWorkingLocationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case locationType
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let locationTypeDecoded = try containerValues.decodeIfPresent(FinspacedataClientTypes.LocationType.self, forKey: .locationType)
        locationType = locationTypeDecoded
    }
}

extension GetWorkingLocationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetWorkingLocationOutputBody = try responseDecoder.decode(responseBody: data)
            self.s3Bucket = output.s3Bucket
            self.s3Path = output.s3Path
            self.s3Uri = output.s3Uri
        } else {
            self.s3Bucket = nil
            self.s3Path = nil
            self.s3Uri = nil
        }
    }
}

public struct GetWorkingLocationOutput: Swift.Equatable {
    /// Returns the Amazon S3 bucket name for the working location.
    public var s3Bucket: Swift.String?
    /// Returns the Amazon S3 Path for the working location.
    public var s3Path: Swift.String?
    /// Returns the Amazon S3 URI for the working location.
    public var s3Uri: Swift.String?

    public init(
        s3Bucket: Swift.String? = nil,
        s3Path: Swift.String? = nil,
        s3Uri: Swift.String? = nil
    )
    {
        self.s3Bucket = s3Bucket
        self.s3Path = s3Path
        self.s3Uri = s3Uri
    }
}

struct GetWorkingLocationOutputBody: Swift.Equatable {
    let s3Uri: Swift.String?
    let s3Path: Swift.String?
    let s3Bucket: Swift.String?
}

extension GetWorkingLocationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case s3Bucket
        case s3Path
        case s3Uri
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3UriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3Uri)
        s3Uri = s3UriDecoded
        let s3PathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3Path)
        s3Path = s3PathDecoded
        let s3BucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .s3Bucket)
        s3Bucket = s3BucketDecoded
    }
}

enum GetWorkingLocationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension FinspacedataClientTypes {
    /// Status of the ingestion process returned from scheduler service.
    public enum IngestionStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case failed
        case pending
        case running
        case stopRequested
        case success
        case sdkUnknown(Swift.String)

        public static var allCases: [IngestionStatus] {
            return [
                .failed,
                .pending,
                .running,
                .stopRequested,
                .success,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .pending: return "PENDING"
            case .running: return "RUNNING"
            case .stopRequested: return "STOP_REQUESTED"
            case .success: return "SUCCESS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = IngestionStatus(rawValue: rawValue) ?? IngestionStatus.sdkUnknown(rawValue)
        }
    }
}

extension InternalServerException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request processing has failed because of an unknown error, exception or failure.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LimitExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: LimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// A limit has exceeded.
public struct LimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "LimitExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct LimitExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension LimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListChangesetsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            return items
        }
    }
}

extension ListChangesetsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let datasetId = datasetId else {
            return nil
        }
        return "/datasets/\(datasetId.urlPercentEncoding())/changesetsv2"
    }
}

/// Request to ListChangesetsRequest. It exposes minimal query filters.
public struct ListChangesetsInput: Swift.Equatable {
    /// The unique identifier for the FinSpace Dataset to which the Changeset belongs.
    /// This member is required.
    public var datasetId: Swift.String?
    /// The maximum number of results per page.
    public var maxResults: Swift.Int?
    /// A token that indicates where a results page should begin.
    public var nextToken: Swift.String?

    public init(
        datasetId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.datasetId = datasetId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListChangesetsInputBody: Swift.Equatable {
}

extension ListChangesetsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListChangesetsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListChangesetsOutputBody = try responseDecoder.decode(responseBody: data)
            self.changesets = output.changesets
            self.nextToken = output.nextToken
        } else {
            self.changesets = nil
            self.nextToken = nil
        }
    }
}

/// Response to ListChangesetsResponse. This returns a list of dataset changesets that match the query criteria.
public struct ListChangesetsOutput: Swift.Equatable {
    /// List of Changesets found.
    public var changesets: [FinspacedataClientTypes.ChangesetSummary]?
    /// A token that indicates where a results page should begin.
    public var nextToken: Swift.String?

    public init(
        changesets: [FinspacedataClientTypes.ChangesetSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.changesets = changesets
        self.nextToken = nextToken
    }
}

struct ListChangesetsOutputBody: Swift.Equatable {
    let changesets: [FinspacedataClientTypes.ChangesetSummary]?
    let nextToken: Swift.String?
}

extension ListChangesetsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case changesets
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let changesetsContainer = try containerValues.decodeIfPresent([FinspacedataClientTypes.ChangesetSummary?].self, forKey: .changesets)
        var changesetsDecoded0:[FinspacedataClientTypes.ChangesetSummary]? = nil
        if let changesetsContainer = changesetsContainer {
            changesetsDecoded0 = [FinspacedataClientTypes.ChangesetSummary]()
            for structure0 in changesetsContainer {
                if let structure0 = structure0 {
                    changesetsDecoded0?.append(structure0)
                }
            }
        }
        changesets = changesetsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListChangesetsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListDataViewsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListDataViewsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let datasetId = datasetId else {
            return nil
        }
        return "/datasets/\(datasetId.urlPercentEncoding())/dataviewsv2"
    }
}

/// Request for a list data views.
public struct ListDataViewsInput: Swift.Equatable {
    /// The unique identifier of the Dataset for which to retrieve Dataviews.
    /// This member is required.
    public var datasetId: Swift.String?
    /// The maximum number of results per page.
    public var maxResults: Swift.Int?
    /// A token that indicates where a results page should begin.
    public var nextToken: Swift.String?

    public init(
        datasetId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.datasetId = datasetId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListDataViewsInputBody: Swift.Equatable {
}

extension ListDataViewsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListDataViewsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListDataViewsOutputBody = try responseDecoder.decode(responseBody: data)
            self.dataViews = output.dataViews
            self.nextToken = output.nextToken
        } else {
            self.dataViews = nil
            self.nextToken = nil
        }
    }
}

public struct ListDataViewsOutput: Swift.Equatable {
    /// A list of Dataviews.
    public var dataViews: [FinspacedataClientTypes.DataViewSummary]?
    /// A token that indicates where a results page should begin.
    public var nextToken: Swift.String?

    public init(
        dataViews: [FinspacedataClientTypes.DataViewSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.dataViews = dataViews
        self.nextToken = nextToken
    }
}

struct ListDataViewsOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let dataViews: [FinspacedataClientTypes.DataViewSummary]?
}

extension ListDataViewsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataViews
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let dataViewsContainer = try containerValues.decodeIfPresent([FinspacedataClientTypes.DataViewSummary?].self, forKey: .dataViews)
        var dataViewsDecoded0:[FinspacedataClientTypes.DataViewSummary]? = nil
        if let dataViewsContainer = dataViewsContainer {
            dataViewsDecoded0 = [FinspacedataClientTypes.DataViewSummary]()
            for structure0 in dataViewsContainer {
                if let structure0 = structure0 {
                    dataViewsDecoded0?.append(structure0)
                }
            }
        }
        dataViews = dataViewsDecoded0
    }
}

enum ListDataViewsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListDatasetsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListDatasetsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/datasetsv2"
    }
}

/// Request for the ListDatasets operation.
public struct ListDatasetsInput: Swift.Equatable {
    /// The maximum number of results per page.
    public var maxResults: Swift.Int?
    /// A token that indicates where a results page should begin.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListDatasetsInputBody: Swift.Equatable {
}

extension ListDatasetsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListDatasetsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListDatasetsOutputBody = try responseDecoder.decode(responseBody: data)
            self.datasets = output.datasets
            self.nextToken = output.nextToken
        } else {
            self.datasets = nil
            self.nextToken = nil
        }
    }
}

/// Response for the ListDatasets operation
public struct ListDatasetsOutput: Swift.Equatable {
    /// List of Datasets.
    public var datasets: [FinspacedataClientTypes.Dataset]?
    /// A token that indicates where a results page should begin.
    public var nextToken: Swift.String?

    public init(
        datasets: [FinspacedataClientTypes.Dataset]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.datasets = datasets
        self.nextToken = nextToken
    }
}

struct ListDatasetsOutputBody: Swift.Equatable {
    let datasets: [FinspacedataClientTypes.Dataset]?
    let nextToken: Swift.String?
}

extension ListDatasetsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasets
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetsContainer = try containerValues.decodeIfPresent([FinspacedataClientTypes.Dataset?].self, forKey: .datasets)
        var datasetsDecoded0:[FinspacedataClientTypes.Dataset]? = nil
        if let datasetsContainer = datasetsContainer {
            datasetsDecoded0 = [FinspacedataClientTypes.Dataset]()
            for structure0 in datasetsContainer {
                if let structure0 = structure0 {
                    datasetsDecoded0?.append(structure0)
                }
            }
        }
        datasets = datasetsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListDatasetsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListPermissionGroupsByUserInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            guard let maxResults = maxResults else {
                let message = "Creating a URL Query Item failed. maxResults is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
            return items
        }
    }
}

extension ListPermissionGroupsByUserInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let userId = userId else {
            return nil
        }
        return "/user/\(userId.urlPercentEncoding())/permission-groups"
    }
}

public struct ListPermissionGroupsByUserInput: Swift.Equatable {
    /// The maximum number of results per page.
    /// This member is required.
    public var maxResults: Swift.Int?
    /// A token that indicates where a results page should begin.
    public var nextToken: Swift.String?
    /// The unique identifier for the user.
    /// This member is required.
    public var userId: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        userId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.userId = userId
    }
}

struct ListPermissionGroupsByUserInputBody: Swift.Equatable {
}

extension ListPermissionGroupsByUserInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListPermissionGroupsByUserOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListPermissionGroupsByUserOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.permissionGroups = output.permissionGroups
        } else {
            self.nextToken = nil
            self.permissionGroups = nil
        }
    }
}

public struct ListPermissionGroupsByUserOutput: Swift.Equatable {
    /// A token that indicates where a results page should begin.
    public var nextToken: Swift.String?
    /// A list of returned permission groups.
    public var permissionGroups: [FinspacedataClientTypes.PermissionGroupByUser]?

    public init(
        nextToken: Swift.String? = nil,
        permissionGroups: [FinspacedataClientTypes.PermissionGroupByUser]? = nil
    )
    {
        self.nextToken = nextToken
        self.permissionGroups = permissionGroups
    }
}

struct ListPermissionGroupsByUserOutputBody: Swift.Equatable {
    let permissionGroups: [FinspacedataClientTypes.PermissionGroupByUser]?
    let nextToken: Swift.String?
}

extension ListPermissionGroupsByUserOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case permissionGroups
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let permissionGroupsContainer = try containerValues.decodeIfPresent([FinspacedataClientTypes.PermissionGroupByUser?].self, forKey: .permissionGroups)
        var permissionGroupsDecoded0:[FinspacedataClientTypes.PermissionGroupByUser]? = nil
        if let permissionGroupsContainer = permissionGroupsContainer {
            permissionGroupsDecoded0 = [FinspacedataClientTypes.PermissionGroupByUser]()
            for structure0 in permissionGroupsContainer {
                if let structure0 = structure0 {
                    permissionGroupsDecoded0?.append(structure0)
                }
            }
        }
        permissionGroups = permissionGroupsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListPermissionGroupsByUserOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListPermissionGroupsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            guard let maxResults = maxResults else {
                let message = "Creating a URL Query Item failed. maxResults is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
            return items
        }
    }
}

extension ListPermissionGroupsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/permission-group"
    }
}

public struct ListPermissionGroupsInput: Swift.Equatable {
    /// The maximum number of results per page.
    /// This member is required.
    public var maxResults: Swift.Int?
    /// A token that indicates where a results page should begin.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListPermissionGroupsInputBody: Swift.Equatable {
}

extension ListPermissionGroupsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListPermissionGroupsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListPermissionGroupsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.permissionGroups = output.permissionGroups
        } else {
            self.nextToken = nil
            self.permissionGroups = nil
        }
    }
}

public struct ListPermissionGroupsOutput: Swift.Equatable {
    /// A token that indicates where a results page should begin.
    public var nextToken: Swift.String?
    /// A list of all the permission groups.
    public var permissionGroups: [FinspacedataClientTypes.PermissionGroup]?

    public init(
        nextToken: Swift.String? = nil,
        permissionGroups: [FinspacedataClientTypes.PermissionGroup]? = nil
    )
    {
        self.nextToken = nextToken
        self.permissionGroups = permissionGroups
    }
}

struct ListPermissionGroupsOutputBody: Swift.Equatable {
    let permissionGroups: [FinspacedataClientTypes.PermissionGroup]?
    let nextToken: Swift.String?
}

extension ListPermissionGroupsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case permissionGroups
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let permissionGroupsContainer = try containerValues.decodeIfPresent([FinspacedataClientTypes.PermissionGroup?].self, forKey: .permissionGroups)
        var permissionGroupsDecoded0:[FinspacedataClientTypes.PermissionGroup]? = nil
        if let permissionGroupsContainer = permissionGroupsContainer {
            permissionGroupsDecoded0 = [FinspacedataClientTypes.PermissionGroup]()
            for structure0 in permissionGroupsContainer {
                if let structure0 = structure0 {
                    permissionGroupsDecoded0?.append(structure0)
                }
            }
        }
        permissionGroups = permissionGroupsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListPermissionGroupsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListUsersByPermissionGroupInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            guard let maxResults = maxResults else {
                let message = "Creating a URL Query Item failed. maxResults is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
            return items
        }
    }
}

extension ListUsersByPermissionGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let permissionGroupId = permissionGroupId else {
            return nil
        }
        return "/permission-group/\(permissionGroupId.urlPercentEncoding())/users"
    }
}

public struct ListUsersByPermissionGroupInput: Swift.Equatable {
    /// The maximum number of results per page.
    /// This member is required.
    public var maxResults: Swift.Int?
    /// A token that indicates where a results page should begin.
    public var nextToken: Swift.String?
    /// The unique identifier for the permission group.
    /// This member is required.
    public var permissionGroupId: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        permissionGroupId: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.permissionGroupId = permissionGroupId
    }
}

struct ListUsersByPermissionGroupInputBody: Swift.Equatable {
}

extension ListUsersByPermissionGroupInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListUsersByPermissionGroupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListUsersByPermissionGroupOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.users = output.users
        } else {
            self.nextToken = nil
            self.users = nil
        }
    }
}

public struct ListUsersByPermissionGroupOutput: Swift.Equatable {
    /// A token that indicates where a results page should begin.
    public var nextToken: Swift.String?
    /// Lists details of all users in a specific permission group.
    public var users: [FinspacedataClientTypes.UserByPermissionGroup]?

    public init(
        nextToken: Swift.String? = nil,
        users: [FinspacedataClientTypes.UserByPermissionGroup]? = nil
    )
    {
        self.nextToken = nextToken
        self.users = users
    }
}

struct ListUsersByPermissionGroupOutputBody: Swift.Equatable {
    let users: [FinspacedataClientTypes.UserByPermissionGroup]?
    let nextToken: Swift.String?
}

extension ListUsersByPermissionGroupOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case users
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let usersContainer = try containerValues.decodeIfPresent([FinspacedataClientTypes.UserByPermissionGroup?].self, forKey: .users)
        var usersDecoded0:[FinspacedataClientTypes.UserByPermissionGroup]? = nil
        if let usersContainer = usersContainer {
            usersDecoded0 = [FinspacedataClientTypes.UserByPermissionGroup]()
            for structure0 in usersContainer {
                if let structure0 = structure0 {
                    usersDecoded0?.append(structure0)
                }
            }
        }
        users = usersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListUsersByPermissionGroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListUsersInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            guard let maxResults = maxResults else {
                let message = "Creating a URL Query Item failed. maxResults is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
            return items
        }
    }
}

extension ListUsersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/user"
    }
}

public struct ListUsersInput: Swift.Equatable {
    /// The maximum number of results per page.
    /// This member is required.
    public var maxResults: Swift.Int?
    /// A token that indicates where a results page should begin.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListUsersInputBody: Swift.Equatable {
}

extension ListUsersInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListUsersOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListUsersOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.users = output.users
        } else {
            self.nextToken = nil
            self.users = nil
        }
    }
}

public struct ListUsersOutput: Swift.Equatable {
    /// A token that indicates where a results page should begin.
    public var nextToken: Swift.String?
    /// A list of all the users.
    public var users: [FinspacedataClientTypes.User]?

    public init(
        nextToken: Swift.String? = nil,
        users: [FinspacedataClientTypes.User]? = nil
    )
    {
        self.nextToken = nextToken
        self.users = users
    }
}

struct ListUsersOutputBody: Swift.Equatable {
    let users: [FinspacedataClientTypes.User]?
    let nextToken: Swift.String?
}

extension ListUsersOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case users
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let usersContainer = try containerValues.decodeIfPresent([FinspacedataClientTypes.User?].self, forKey: .users)
        var usersDecoded0:[FinspacedataClientTypes.User]? = nil
        if let usersContainer = usersContainer {
            usersDecoded0 = [FinspacedataClientTypes.User]()
            for structure0 in usersContainer {
                if let structure0 = structure0 {
                    usersDecoded0?.append(structure0)
                }
            }
        }
        users = usersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListUsersOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension FinspacedataClientTypes {
    public enum LocationType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ingestion
        case sagemaker
        case sdkUnknown(Swift.String)

        public static var allCases: [LocationType] {
            return [
                .ingestion,
                .sagemaker,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ingestion: return "INGESTION"
            case .sagemaker: return "SAGEMAKER"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LocationType(rawValue: rawValue) ?? LocationType.sdkUnknown(rawValue)
        }
    }
}

extension FinspacedataClientTypes.PermissionGroup: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationPermissions
        case createTime
        case description
        case lastModifiedTime
        case membershipStatus
        case name
        case permissionGroupId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationPermissions = applicationPermissions {
            var applicationPermissionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .applicationPermissions)
            for applicationpermission0 in applicationPermissions {
                try applicationPermissionsContainer.encode(applicationpermission0.rawValue)
            }
        }
        if createTime != 0 {
            try encodeContainer.encode(createTime, forKey: .createTime)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if lastModifiedTime != 0 {
            try encodeContainer.encode(lastModifiedTime, forKey: .lastModifiedTime)
        }
        if let membershipStatus = self.membershipStatus {
            try encodeContainer.encode(membershipStatus.rawValue, forKey: .membershipStatus)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let permissionGroupId = self.permissionGroupId {
            try encodeContainer.encode(permissionGroupId, forKey: .permissionGroupId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let permissionGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .permissionGroupId)
        permissionGroupId = permissionGroupIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let applicationPermissionsContainer = try containerValues.decodeIfPresent([FinspacedataClientTypes.ApplicationPermission?].self, forKey: .applicationPermissions)
        var applicationPermissionsDecoded0:[FinspacedataClientTypes.ApplicationPermission]? = nil
        if let applicationPermissionsContainer = applicationPermissionsContainer {
            applicationPermissionsDecoded0 = [FinspacedataClientTypes.ApplicationPermission]()
            for enum0 in applicationPermissionsContainer {
                if let enum0 = enum0 {
                    applicationPermissionsDecoded0?.append(enum0)
                }
            }
        }
        applicationPermissions = applicationPermissionsDecoded0
        let createTimeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .createTime) ?? 0
        createTime = createTimeDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .lastModifiedTime) ?? 0
        lastModifiedTime = lastModifiedTimeDecoded
        let membershipStatusDecoded = try containerValues.decodeIfPresent(FinspacedataClientTypes.PermissionGroupMembershipStatus.self, forKey: .membershipStatus)
        membershipStatus = membershipStatusDecoded
    }
}

extension FinspacedataClientTypes.PermissionGroup: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PermissionGroup(applicationPermissions: \(Swift.String(describing: applicationPermissions)), createTime: \(Swift.String(describing: createTime)), lastModifiedTime: \(Swift.String(describing: lastModifiedTime)), membershipStatus: \(Swift.String(describing: membershipStatus)), permissionGroupId: \(Swift.String(describing: permissionGroupId)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension FinspacedataClientTypes {
    /// The structure for a permission group.
    public struct PermissionGroup: Swift.Equatable {
        /// Indicates the permissions that are granted to a specific group for accessing the FinSpace application. When assigning application permissions, be aware that the permission ManageUsersAndGroups allows users to grant themselves or others access to any functionality in their FinSpace environment's application. It should only be granted to trusted users.
        ///
        /// * CreateDataset – Group members can create new datasets.
        ///
        /// * ManageClusters – Group members can manage Apache Spark clusters from FinSpace notebooks.
        ///
        /// * ManageUsersAndGroups – Group members can manage users and permission groups. This is a privileged permission that allows users to grant themselves or others access to any functionality in the application. It should only be granted to trusted users.
        ///
        /// * ManageAttributeSets – Group members can manage attribute sets.
        ///
        /// * ViewAuditData – Group members can view audit data.
        ///
        /// * AccessNotebooks – Group members will have access to FinSpace notebooks.
        ///
        /// * GetTemporaryCredentials – Group members can get temporary API credentials.
        public var applicationPermissions: [FinspacedataClientTypes.ApplicationPermission]?
        /// The timestamp at which the group was created in FinSpace. The value is determined as epoch time in milliseconds.
        public var createTime: Swift.Int
        /// A brief description for the permission group.
        public var description: Swift.String?
        /// Describes the last time the permission group was updated. The value is determined as epoch time in milliseconds.
        public var lastModifiedTime: Swift.Int
        /// Indicates the status of the user within a permission group.
        ///
        /// * ADDITION_IN_PROGRESS – The user is currently being added to the permission group.
        ///
        /// * ADDITION_SUCCESS – The user is successfully added to the permission group.
        ///
        /// * REMOVAL_IN_PROGRESS – The user is currently being removed from the permission group.
        public var membershipStatus: FinspacedataClientTypes.PermissionGroupMembershipStatus?
        /// The name of the permission group.
        public var name: Swift.String?
        /// The unique identifier for the permission group.
        public var permissionGroupId: Swift.String?

        public init(
            applicationPermissions: [FinspacedataClientTypes.ApplicationPermission]? = nil,
            createTime: Swift.Int = 0,
            description: Swift.String? = nil,
            lastModifiedTime: Swift.Int = 0,
            membershipStatus: FinspacedataClientTypes.PermissionGroupMembershipStatus? = nil,
            name: Swift.String? = nil,
            permissionGroupId: Swift.String? = nil
        )
        {
            self.applicationPermissions = applicationPermissions
            self.createTime = createTime
            self.description = description
            self.lastModifiedTime = lastModifiedTime
            self.membershipStatus = membershipStatus
            self.name = name
            self.permissionGroupId = permissionGroupId
        }
    }

}

extension FinspacedataClientTypes.PermissionGroupByUser: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case membershipStatus
        case name
        case permissionGroupId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let membershipStatus = self.membershipStatus {
            try encodeContainer.encode(membershipStatus.rawValue, forKey: .membershipStatus)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let permissionGroupId = self.permissionGroupId {
            try encodeContainer.encode(permissionGroupId, forKey: .permissionGroupId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let permissionGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .permissionGroupId)
        permissionGroupId = permissionGroupIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let membershipStatusDecoded = try containerValues.decodeIfPresent(FinspacedataClientTypes.PermissionGroupMembershipStatus.self, forKey: .membershipStatus)
        membershipStatus = membershipStatusDecoded
    }
}

extension FinspacedataClientTypes.PermissionGroupByUser: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PermissionGroupByUser(membershipStatus: \(Swift.String(describing: membershipStatus)), permissionGroupId: \(Swift.String(describing: permissionGroupId)), name: \"CONTENT_REDACTED\")"}
}

extension FinspacedataClientTypes {
    /// The structure of a permission group associated with a user.
    public struct PermissionGroupByUser: Swift.Equatable {
        /// Indicates the status of the user within a permission group.
        ///
        /// * ADDITION_IN_PROGRESS – The user is currently being added to the permission group.
        ///
        /// * ADDITION_SUCCESS – The user is successfully added to the permission group.
        ///
        /// * REMOVAL_IN_PROGRESS – The user is currently being removed from the permission group.
        public var membershipStatus: FinspacedataClientTypes.PermissionGroupMembershipStatus?
        /// The name of the permission group.
        public var name: Swift.String?
        /// The unique identifier for the permission group.
        public var permissionGroupId: Swift.String?

        public init(
            membershipStatus: FinspacedataClientTypes.PermissionGroupMembershipStatus? = nil,
            name: Swift.String? = nil,
            permissionGroupId: Swift.String? = nil
        )
        {
            self.membershipStatus = membershipStatus
            self.name = name
            self.permissionGroupId = permissionGroupId
        }
    }

}

extension FinspacedataClientTypes {
    public enum PermissionGroupMembershipStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case additionInProgress
        case additionSuccess
        case removalInProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [PermissionGroupMembershipStatus] {
            return [
                .additionInProgress,
                .additionSuccess,
                .removalInProgress,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .additionInProgress: return "ADDITION_IN_PROGRESS"
            case .additionSuccess: return "ADDITION_SUCCESS"
            case .removalInProgress: return "REMOVAL_IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PermissionGroupMembershipStatus(rawValue: rawValue) ?? PermissionGroupMembershipStatus.sdkUnknown(rawValue)
        }
    }
}

extension FinspacedataClientTypes.PermissionGroupParams: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetPermissions
        case permissionGroupId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let datasetPermissions = datasetPermissions {
            var datasetPermissionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .datasetPermissions)
            for resourcepermission0 in datasetPermissions {
                try datasetPermissionsContainer.encode(resourcepermission0)
            }
        }
        if let permissionGroupId = self.permissionGroupId {
            try encodeContainer.encode(permissionGroupId, forKey: .permissionGroupId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let permissionGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .permissionGroupId)
        permissionGroupId = permissionGroupIdDecoded
        let datasetPermissionsContainer = try containerValues.decodeIfPresent([FinspacedataClientTypes.ResourcePermission?].self, forKey: .datasetPermissions)
        var datasetPermissionsDecoded0:[FinspacedataClientTypes.ResourcePermission]? = nil
        if let datasetPermissionsContainer = datasetPermissionsContainer {
            datasetPermissionsDecoded0 = [FinspacedataClientTypes.ResourcePermission]()
            for structure0 in datasetPermissionsContainer {
                if let structure0 = structure0 {
                    datasetPermissionsDecoded0?.append(structure0)
                }
            }
        }
        datasetPermissions = datasetPermissionsDecoded0
    }
}

extension FinspacedataClientTypes {
    /// Permission group parameters for Dataset permissions. Here is an example of how you could specify the PermissionGroupParams:  { "permissionGroupId": "0r6fCRtSTUk4XPfXQe3M0g", "datasetPermissions": [ {"permission": "ViewDatasetDetails"}, {"permission": "AddDatasetData"}, {"permission": "EditDatasetMetadata"}, {"permission": "DeleteDataset"} ] }
    public struct PermissionGroupParams: Swift.Equatable {
        /// List of resource permissions.
        public var datasetPermissions: [FinspacedataClientTypes.ResourcePermission]?
        /// The unique identifier for the PermissionGroup.
        public var permissionGroupId: Swift.String?

        public init(
            datasetPermissions: [FinspacedataClientTypes.ResourcePermission]? = nil,
            permissionGroupId: Swift.String? = nil
        )
        {
            self.datasetPermissions = datasetPermissions
            self.permissionGroupId = permissionGroupId
        }
    }

}

extension ResetUserPasswordInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
    }
}

extension ResetUserPasswordInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let userId = userId else {
            return nil
        }
        return "/user/\(userId.urlPercentEncoding())/password"
    }
}

public struct ResetUserPasswordInput: Swift.Equatable {
    /// A token that ensures idempotency. This token expires in 10 minutes.
    public var clientToken: Swift.String?
    /// The unique identifier of the user that a temporary password is requested for.
    /// This member is required.
    public var userId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        userId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.userId = userId
    }
}

struct ResetUserPasswordInputBody: Swift.Equatable {
    let clientToken: Swift.String?
}

extension ResetUserPasswordInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension ResetUserPasswordOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ResetUserPasswordOutput(userId: \(Swift.String(describing: userId)), temporaryPassword: \"CONTENT_REDACTED\")"}
}

extension ResetUserPasswordOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResetUserPasswordOutputBody = try responseDecoder.decode(responseBody: data)
            self.temporaryPassword = output.temporaryPassword
            self.userId = output.userId
        } else {
            self.temporaryPassword = nil
            self.userId = nil
        }
    }
}

public struct ResetUserPasswordOutput: Swift.Equatable {
    /// A randomly generated temporary password for the requested user. This password expires in 7 days.
    public var temporaryPassword: Swift.String?
    /// The unique identifier of the user that a new password is generated for.
    public var userId: Swift.String?

    public init(
        temporaryPassword: Swift.String? = nil,
        userId: Swift.String? = nil
    )
    {
        self.temporaryPassword = temporaryPassword
        self.userId = userId
    }
}

struct ResetUserPasswordOutputBody: Swift.Equatable {
    let userId: Swift.String?
    let temporaryPassword: Swift.String?
}

extension ResetUserPasswordOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case temporaryPassword
        case userId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userId)
        userId = userIdDecoded
        let temporaryPasswordDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .temporaryPassword)
        temporaryPassword = temporaryPasswordDecoded
    }
}

enum ResetUserPasswordOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ResourceNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.reason = output.reason
        } else {
            self.properties.message = nil
            self.properties.reason = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// One or more resources can't be found.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        public internal(set) var reason: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        reason: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.reason = reason
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let reason: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case reason
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reason)
        reason = reasonDecoded
    }
}

extension FinspacedataClientTypes.ResourcePermission: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case permission
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let permission = self.permission {
            try encodeContainer.encode(permission, forKey: .permission)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let permissionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .permission)
        permission = permissionDecoded
    }
}

extension FinspacedataClientTypes {
    /// Resource permission for a dataset. When you create a dataset, all the other members of the same user group inherit access to the dataset. You can only create a dataset if your user group has application permission for Create Datasets. The following is a list of valid dataset permissions that you can apply:
    ///
    /// * ViewDatasetDetails
    ///
    /// * ReadDatasetDetails
    ///
    /// * AddDatasetData
    ///
    /// * CreateDataView
    ///
    /// * EditDatasetMetadata
    ///
    /// * DeleteDataset
    ///
    ///
    /// For more information on the dataset permissions, see [Supported Dataset Permissions](https://docs.aws.amazon.com/finspace/latest/userguide/managing-user-permissions.html#supported-dataset-permissions) in the FinSpace User Guide.
    public struct ResourcePermission: Swift.Equatable {
        /// Permission for a resource.
        public var permission: Swift.String?

        public init(
            permission: Swift.String? = nil
        )
        {
            self.permission = permission
        }
    }

}

extension FinspacedataClientTypes.S3Location: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case bucket
        case key
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let bucket = self.bucket {
            try encodeContainer.encode(bucket, forKey: .bucket)
        }
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .bucket)
        bucket = bucketDecoded
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
    }
}

extension FinspacedataClientTypes {
    /// The location of an external Dataview in an S3 bucket.
    public struct S3Location: Swift.Equatable {
        /// The name of the S3 bucket.
        /// This member is required.
        public var bucket: Swift.String?
        /// The path of the folder, within the S3 bucket that contains the Dataset.
        /// This member is required.
        public var key: Swift.String?

        public init(
            bucket: Swift.String? = nil,
            key: Swift.String? = nil
        )
        {
            self.bucket = bucket
            self.key = key
        }
    }

}

extension FinspacedataClientTypes.SchemaDefinition: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case columns
        case primaryKeyColumns
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let columns = columns {
            var columnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .columns)
            for columndefinition0 in columns {
                try columnsContainer.encode(columndefinition0)
            }
        }
        if let primaryKeyColumns = primaryKeyColumns {
            var primaryKeyColumnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .primaryKeyColumns)
            for columnname0 in primaryKeyColumns {
                try primaryKeyColumnsContainer.encode(columnname0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let columnsContainer = try containerValues.decodeIfPresent([FinspacedataClientTypes.ColumnDefinition?].self, forKey: .columns)
        var columnsDecoded0:[FinspacedataClientTypes.ColumnDefinition]? = nil
        if let columnsContainer = columnsContainer {
            columnsDecoded0 = [FinspacedataClientTypes.ColumnDefinition]()
            for structure0 in columnsContainer {
                if let structure0 = structure0 {
                    columnsDecoded0?.append(structure0)
                }
            }
        }
        columns = columnsDecoded0
        let primaryKeyColumnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .primaryKeyColumns)
        var primaryKeyColumnsDecoded0:[Swift.String]? = nil
        if let primaryKeyColumnsContainer = primaryKeyColumnsContainer {
            primaryKeyColumnsDecoded0 = [Swift.String]()
            for string0 in primaryKeyColumnsContainer {
                if let string0 = string0 {
                    primaryKeyColumnsDecoded0?.append(string0)
                }
            }
        }
        primaryKeyColumns = primaryKeyColumnsDecoded0
    }
}

extension FinspacedataClientTypes {
    /// Definition for a schema on a tabular Dataset.
    public struct SchemaDefinition: Swift.Equatable {
        /// List of column definitions.
        public var columns: [FinspacedataClientTypes.ColumnDefinition]?
        /// List of column names used for primary key.
        public var primaryKeyColumns: [Swift.String]?

        public init(
            columns: [FinspacedataClientTypes.ColumnDefinition]? = nil,
            primaryKeyColumns: [Swift.String]? = nil
        )
        {
            self.columns = columns
            self.primaryKeyColumns = primaryKeyColumns
        }
    }

}

extension FinspacedataClientTypes.SchemaUnion: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tabularSchemaConfig
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tabularSchemaConfig = self.tabularSchemaConfig {
            try encodeContainer.encode(tabularSchemaConfig, forKey: .tabularSchemaConfig)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tabularSchemaConfigDecoded = try containerValues.decodeIfPresent(FinspacedataClientTypes.SchemaDefinition.self, forKey: .tabularSchemaConfig)
        tabularSchemaConfig = tabularSchemaConfigDecoded
    }
}

extension FinspacedataClientTypes {
    /// A union of schema types.
    public struct SchemaUnion: Swift.Equatable {
        /// The configuration for a schema on a tabular Dataset.
        public var tabularSchemaConfig: FinspacedataClientTypes.SchemaDefinition?

        public init(
            tabularSchemaConfig: FinspacedataClientTypes.SchemaDefinition? = nil
        )
        {
            self.tabularSchemaConfig = tabularSchemaConfig
        }
    }

}

extension ThrottlingException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request was denied due to request throttling.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init() { }
}

extension UpdateChangesetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case formatParams
        case sourceParams
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let formatParams = formatParams {
            var formatParamsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .formatParams)
            for (dictKey0, formatParams0) in formatParams {
                try formatParamsContainer.encode(formatParams0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let sourceParams = sourceParams {
            var sourceParamsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .sourceParams)
            for (dictKey0, sourceParams0) in sourceParams {
                try sourceParamsContainer.encode(sourceParams0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension UpdateChangesetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let datasetId = datasetId else {
            return nil
        }
        guard let changesetId = changesetId else {
            return nil
        }
        return "/datasets/\(datasetId.urlPercentEncoding())/changesetsv2/\(changesetId.urlPercentEncoding())"
    }
}

/// Request to update an existing changeset.
public struct UpdateChangesetInput: Swift.Equatable {
    /// The unique identifier for the Changeset to update.
    /// This member is required.
    public var changesetId: Swift.String?
    /// A token that ensures idempotency. This token expires in 10 minutes.
    public var clientToken: Swift.String?
    /// The unique identifier for the FinSpace Dataset in which the Changeset is created.
    /// This member is required.
    public var datasetId: Swift.String?
    /// Options that define the structure of the source file(s) including the format type (formatType), header row (withHeader), data separation character (separator) and the type of compression (compression). formatType is a required attribute and can have the following values:
    ///
    /// * PARQUET – Parquet source file format.
    ///
    /// * CSV – CSV source file format.
    ///
    /// * JSON – JSON source file format.
    ///
    /// * XML – XML source file format.
    ///
    ///
    /// Here is an example of how you could specify the formatParams:  "formatParams": { "formatType": "CSV", "withHeader": "true", "separator": ",", "compression":"None" }  Note that if you only provide formatType as CSV, the rest of the attributes will automatically default to CSV values as following:  { "withHeader": "true", "separator": "," }  For more information about supported file formats, see [Supported Data Types and File Formats](https://docs.aws.amazon.com/finspace/latest/userguide/supported-data-types.html) in the FinSpace User Guide.
    /// This member is required.
    public var formatParams: [Swift.String:Swift.String]?
    /// Options that define the location of the data being ingested (s3SourcePath) and the source of the changeset (sourceType). Both s3SourcePath and sourceType are required attributes. Here is an example of how you could specify the sourceParams:  "sourceParams": { "s3SourcePath": "s3://finspace-landing-us-east-2-bk7gcfvitndqa6ebnvys4d/scratch/wr5hh8pwkpqqkxa4sxrmcw/ingestion/equity.csv", "sourceType": "S3" }  The S3 path that you specify must allow the FinSpace role access. To do that, you first need to configure the IAM policy on S3 bucket. For more information, see [Loading data from an Amazon S3 Bucket using the FinSpace API](https://docs.aws.amazon.com/finspace/latest/data-api/fs-using-the-finspace-api.html#access-s3-buckets)section.
    /// This member is required.
    public var sourceParams: [Swift.String:Swift.String]?

    public init(
        changesetId: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        datasetId: Swift.String? = nil,
        formatParams: [Swift.String:Swift.String]? = nil,
        sourceParams: [Swift.String:Swift.String]? = nil
    )
    {
        self.changesetId = changesetId
        self.clientToken = clientToken
        self.datasetId = datasetId
        self.formatParams = formatParams
        self.sourceParams = sourceParams
    }
}

struct UpdateChangesetInputBody: Swift.Equatable {
    let clientToken: Swift.String?
    let sourceParams: [Swift.String:Swift.String]?
    let formatParams: [Swift.String:Swift.String]?
}

extension UpdateChangesetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case formatParams
        case sourceParams
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let sourceParamsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .sourceParams)
        var sourceParamsDecoded0: [Swift.String:Swift.String]? = nil
        if let sourceParamsContainer = sourceParamsContainer {
            sourceParamsDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringmapvalue0) in sourceParamsContainer {
                if let stringmapvalue0 = stringmapvalue0 {
                    sourceParamsDecoded0?[key0] = stringmapvalue0
                }
            }
        }
        sourceParams = sourceParamsDecoded0
        let formatParamsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .formatParams)
        var formatParamsDecoded0: [Swift.String:Swift.String]? = nil
        if let formatParamsContainer = formatParamsContainer {
            formatParamsDecoded0 = [Swift.String:Swift.String]()
            for (key0, stringmapvalue0) in formatParamsContainer {
                if let stringmapvalue0 = stringmapvalue0 {
                    formatParamsDecoded0?[key0] = stringmapvalue0
                }
            }
        }
        formatParams = formatParamsDecoded0
    }
}

extension UpdateChangesetOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateChangesetOutputBody = try responseDecoder.decode(responseBody: data)
            self.changesetId = output.changesetId
            self.datasetId = output.datasetId
        } else {
            self.changesetId = nil
            self.datasetId = nil
        }
    }
}

/// The response from a update changeset operation.
public struct UpdateChangesetOutput: Swift.Equatable {
    /// The unique identifier for the Changeset to update.
    public var changesetId: Swift.String?
    /// The unique identifier for the FinSpace Dataset in which the Changeset is created.
    public var datasetId: Swift.String?

    public init(
        changesetId: Swift.String? = nil,
        datasetId: Swift.String? = nil
    )
    {
        self.changesetId = changesetId
        self.datasetId = datasetId
    }
}

struct UpdateChangesetOutputBody: Swift.Equatable {
    let changesetId: Swift.String?
    let datasetId: Swift.String?
}

extension UpdateChangesetOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case changesetId
        case datasetId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let changesetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .changesetId)
        changesetId = changesetIdDecoded
        let datasetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetId)
        datasetId = datasetIdDecoded
    }
}

enum UpdateChangesetOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateDatasetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alias
        case clientToken
        case datasetDescription
        case datasetTitle
        case kind
        case schemaDefinition
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let alias = self.alias {
            try encodeContainer.encode(alias, forKey: .alias)
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let datasetDescription = self.datasetDescription {
            try encodeContainer.encode(datasetDescription, forKey: .datasetDescription)
        }
        if let datasetTitle = self.datasetTitle {
            try encodeContainer.encode(datasetTitle, forKey: .datasetTitle)
        }
        if let kind = self.kind {
            try encodeContainer.encode(kind.rawValue, forKey: .kind)
        }
        if let schemaDefinition = self.schemaDefinition {
            try encodeContainer.encode(schemaDefinition, forKey: .schemaDefinition)
        }
    }
}

extension UpdateDatasetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let datasetId = datasetId else {
            return nil
        }
        return "/datasetsv2/\(datasetId.urlPercentEncoding())"
    }
}

/// The request for an UpdateDataset operation
public struct UpdateDatasetInput: Swift.Equatable {
    /// The unique resource identifier for a Dataset.
    public var alias: Swift.String?
    /// A token that ensures idempotency. This token expires in 10 minutes.
    public var clientToken: Swift.String?
    /// A description for the Dataset.
    public var datasetDescription: Swift.String?
    /// The unique identifier for the Dataset to update.
    /// This member is required.
    public var datasetId: Swift.String?
    /// A display title for the Dataset.
    /// This member is required.
    public var datasetTitle: Swift.String?
    /// The format in which the Dataset data is structured.
    ///
    /// * TABULAR – Data is structured in a tabular format.
    ///
    /// * NON_TABULAR – Data is structured in a non-tabular format.
    /// This member is required.
    public var kind: FinspacedataClientTypes.DatasetKind?
    /// Definition for a schema on a tabular Dataset.
    public var schemaDefinition: FinspacedataClientTypes.SchemaUnion?

    public init(
        alias: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        datasetDescription: Swift.String? = nil,
        datasetId: Swift.String? = nil,
        datasetTitle: Swift.String? = nil,
        kind: FinspacedataClientTypes.DatasetKind? = nil,
        schemaDefinition: FinspacedataClientTypes.SchemaUnion? = nil
    )
    {
        self.alias = alias
        self.clientToken = clientToken
        self.datasetDescription = datasetDescription
        self.datasetId = datasetId
        self.datasetTitle = datasetTitle
        self.kind = kind
        self.schemaDefinition = schemaDefinition
    }
}

struct UpdateDatasetInputBody: Swift.Equatable {
    let clientToken: Swift.String?
    let datasetTitle: Swift.String?
    let kind: FinspacedataClientTypes.DatasetKind?
    let datasetDescription: Swift.String?
    let alias: Swift.String?
    let schemaDefinition: FinspacedataClientTypes.SchemaUnion?
}

extension UpdateDatasetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case alias
        case clientToken
        case datasetDescription
        case datasetTitle
        case kind
        case schemaDefinition
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let datasetTitleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetTitle)
        datasetTitle = datasetTitleDecoded
        let kindDecoded = try containerValues.decodeIfPresent(FinspacedataClientTypes.DatasetKind.self, forKey: .kind)
        kind = kindDecoded
        let datasetDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetDescription)
        datasetDescription = datasetDescriptionDecoded
        let aliasDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .alias)
        alias = aliasDecoded
        let schemaDefinitionDecoded = try containerValues.decodeIfPresent(FinspacedataClientTypes.SchemaUnion.self, forKey: .schemaDefinition)
        schemaDefinition = schemaDefinitionDecoded
    }
}

extension UpdateDatasetOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateDatasetOutputBody = try responseDecoder.decode(responseBody: data)
            self.datasetId = output.datasetId
        } else {
            self.datasetId = nil
        }
    }
}

/// The response from an UpdateDataset operation
public struct UpdateDatasetOutput: Swift.Equatable {
    /// The unique identifier for updated Dataset.
    public var datasetId: Swift.String?

    public init(
        datasetId: Swift.String? = nil
    )
    {
        self.datasetId = datasetId
    }
}

struct UpdateDatasetOutputBody: Swift.Equatable {
    let datasetId: Swift.String?
}

extension UpdateDatasetOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case datasetId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let datasetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .datasetId)
        datasetId = datasetIdDecoded
    }
}

enum UpdateDatasetOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdatePermissionGroupInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdatePermissionGroupInput(applicationPermissions: \(Swift.String(describing: applicationPermissions)), clientToken: \(Swift.String(describing: clientToken)), permissionGroupId: \(Swift.String(describing: permissionGroupId)), description: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension UpdatePermissionGroupInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationPermissions
        case clientToken
        case description
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applicationPermissions = applicationPermissions {
            var applicationPermissionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .applicationPermissions)
            for applicationpermission0 in applicationPermissions {
                try applicationPermissionsContainer.encode(applicationpermission0.rawValue)
            }
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension UpdatePermissionGroupInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let permissionGroupId = permissionGroupId else {
            return nil
        }
        return "/permission-group/\(permissionGroupId.urlPercentEncoding())"
    }
}

public struct UpdatePermissionGroupInput: Swift.Equatable {
    /// The permissions that are granted to a specific group for accessing the FinSpace application. When assigning application permissions, be aware that the permission ManageUsersAndGroups allows users to grant themselves or others access to any functionality in their FinSpace environment's application. It should only be granted to trusted users.
    ///
    /// * CreateDataset – Group members can create new datasets.
    ///
    /// * ManageClusters – Group members can manage Apache Spark clusters from FinSpace notebooks.
    ///
    /// * ManageUsersAndGroups – Group members can manage users and permission groups. This is a privileged permission that allows users to grant themselves or others access to any functionality in the application. It should only be granted to trusted users.
    ///
    /// * ManageAttributeSets – Group members can manage attribute sets.
    ///
    /// * ViewAuditData – Group members can view audit data.
    ///
    /// * AccessNotebooks – Group members will have access to FinSpace notebooks.
    ///
    /// * GetTemporaryCredentials – Group members can get temporary API credentials.
    public var applicationPermissions: [FinspacedataClientTypes.ApplicationPermission]?
    /// A token that ensures idempotency. This token expires in 10 minutes.
    public var clientToken: Swift.String?
    /// A brief description for the permission group.
    public var description: Swift.String?
    /// The name of the permission group.
    public var name: Swift.String?
    /// The unique identifier for the permission group to update.
    /// This member is required.
    public var permissionGroupId: Swift.String?

    public init(
        applicationPermissions: [FinspacedataClientTypes.ApplicationPermission]? = nil,
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        name: Swift.String? = nil,
        permissionGroupId: Swift.String? = nil
    )
    {
        self.applicationPermissions = applicationPermissions
        self.clientToken = clientToken
        self.description = description
        self.name = name
        self.permissionGroupId = permissionGroupId
    }
}

struct UpdatePermissionGroupInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let applicationPermissions: [FinspacedataClientTypes.ApplicationPermission]?
    let clientToken: Swift.String?
}

extension UpdatePermissionGroupInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applicationPermissions
        case clientToken
        case description
        case name
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let applicationPermissionsContainer = try containerValues.decodeIfPresent([FinspacedataClientTypes.ApplicationPermission?].self, forKey: .applicationPermissions)
        var applicationPermissionsDecoded0:[FinspacedataClientTypes.ApplicationPermission]? = nil
        if let applicationPermissionsContainer = applicationPermissionsContainer {
            applicationPermissionsDecoded0 = [FinspacedataClientTypes.ApplicationPermission]()
            for enum0 in applicationPermissionsContainer {
                if let enum0 = enum0 {
                    applicationPermissionsDecoded0?.append(enum0)
                }
            }
        }
        applicationPermissions = applicationPermissionsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension UpdatePermissionGroupOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdatePermissionGroupOutputBody = try responseDecoder.decode(responseBody: data)
            self.permissionGroupId = output.permissionGroupId
        } else {
            self.permissionGroupId = nil
        }
    }
}

public struct UpdatePermissionGroupOutput: Swift.Equatable {
    /// The unique identifier for the updated permission group.
    public var permissionGroupId: Swift.String?

    public init(
        permissionGroupId: Swift.String? = nil
    )
    {
        self.permissionGroupId = permissionGroupId
    }
}

struct UpdatePermissionGroupOutputBody: Swift.Equatable {
    let permissionGroupId: Swift.String?
}

extension UpdatePermissionGroupOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case permissionGroupId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let permissionGroupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .permissionGroupId)
        permissionGroupId = permissionGroupIdDecoded
    }
}

enum UpdatePermissionGroupOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateUserInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateUserInput(apiAccess: \(Swift.String(describing: apiAccess)), apiAccessPrincipalArn: \(Swift.String(describing: apiAccessPrincipalArn)), clientToken: \(Swift.String(describing: clientToken)), type: \(Swift.String(describing: type)), userId: \(Swift.String(describing: userId)), firstName: \"CONTENT_REDACTED\", lastName: \"CONTENT_REDACTED\")"}
}

extension UpdateUserInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiAccess
        case apiAccessPrincipalArn
        case clientToken
        case firstName
        case lastName
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let apiAccess = self.apiAccess {
            try encodeContainer.encode(apiAccess.rawValue, forKey: .apiAccess)
        }
        if let apiAccessPrincipalArn = self.apiAccessPrincipalArn {
            try encodeContainer.encode(apiAccessPrincipalArn, forKey: .apiAccessPrincipalArn)
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let firstName = self.firstName {
            try encodeContainer.encode(firstName, forKey: .firstName)
        }
        if let lastName = self.lastName {
            try encodeContainer.encode(lastName, forKey: .lastName)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }
}

extension UpdateUserInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let userId = userId else {
            return nil
        }
        return "/user/\(userId.urlPercentEncoding())"
    }
}

public struct UpdateUserInput: Swift.Equatable {
    /// The option to indicate whether the user can use the GetProgrammaticAccessCredentials API to obtain credentials that can then be used to access other FinSpace Data API operations.
    ///
    /// * ENABLED – The user has permissions to use the APIs.
    ///
    /// * DISABLED – The user does not have permissions to use any APIs.
    public var apiAccess: FinspacedataClientTypes.ApiAccess?
    /// The ARN identifier of an AWS user or role that is allowed to call the GetProgrammaticAccessCredentials API to obtain a credentials token for a specific FinSpace user. This must be an IAM role within your FinSpace account.
    public var apiAccessPrincipalArn: Swift.String?
    /// A token that ensures idempotency. This token expires in 10 minutes.
    public var clientToken: Swift.String?
    /// The first name of the user.
    public var firstName: Swift.String?
    /// The last name of the user.
    public var lastName: Swift.String?
    /// The option to indicate the type of user.
    ///
    /// * SUPER_USER– A user with permission to all the functionality and data in FinSpace.
    ///
    /// * APP_USER – A user with specific permissions in FinSpace. The users are assigned permissions by adding them to a permission group.
    public var type: FinspacedataClientTypes.UserType?
    /// The unique identifier for the user that you want to update.
    /// This member is required.
    public var userId: Swift.String?

    public init(
        apiAccess: FinspacedataClientTypes.ApiAccess? = nil,
        apiAccessPrincipalArn: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        firstName: Swift.String? = nil,
        lastName: Swift.String? = nil,
        type: FinspacedataClientTypes.UserType? = nil,
        userId: Swift.String? = nil
    )
    {
        self.apiAccess = apiAccess
        self.apiAccessPrincipalArn = apiAccessPrincipalArn
        self.clientToken = clientToken
        self.firstName = firstName
        self.lastName = lastName
        self.type = type
        self.userId = userId
    }
}

struct UpdateUserInputBody: Swift.Equatable {
    let type: FinspacedataClientTypes.UserType?
    let firstName: Swift.String?
    let lastName: Swift.String?
    let apiAccess: FinspacedataClientTypes.ApiAccess?
    let apiAccessPrincipalArn: Swift.String?
    let clientToken: Swift.String?
}

extension UpdateUserInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiAccess
        case apiAccessPrincipalArn
        case clientToken
        case firstName
        case lastName
        case type
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(FinspacedataClientTypes.UserType.self, forKey: .type)
        type = typeDecoded
        let firstNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .firstName)
        firstName = firstNameDecoded
        let lastNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastName)
        lastName = lastNameDecoded
        let apiAccessDecoded = try containerValues.decodeIfPresent(FinspacedataClientTypes.ApiAccess.self, forKey: .apiAccess)
        apiAccess = apiAccessDecoded
        let apiAccessPrincipalArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiAccessPrincipalArn)
        apiAccessPrincipalArn = apiAccessPrincipalArnDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension UpdateUserOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateUserOutputBody = try responseDecoder.decode(responseBody: data)
            self.userId = output.userId
        } else {
            self.userId = nil
        }
    }
}

public struct UpdateUserOutput: Swift.Equatable {
    /// The unique identifier of the updated user.
    public var userId: Swift.String?

    public init(
        userId: Swift.String? = nil
    )
    {
        self.userId = userId
    }
}

struct UpdateUserOutputBody: Swift.Equatable {
    let userId: Swift.String?
}

extension UpdateUserOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case userId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userId)
        userId = userIdDecoded
    }
}

enum UpdateUserOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension FinspacedataClientTypes.User: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiAccess
        case apiAccessPrincipalArn
        case createTime
        case emailAddress
        case firstName
        case lastDisabledTime
        case lastEnabledTime
        case lastLoginTime
        case lastModifiedTime
        case lastName
        case status
        case type
        case userId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let apiAccess = self.apiAccess {
            try encodeContainer.encode(apiAccess.rawValue, forKey: .apiAccess)
        }
        if let apiAccessPrincipalArn = self.apiAccessPrincipalArn {
            try encodeContainer.encode(apiAccessPrincipalArn, forKey: .apiAccessPrincipalArn)
        }
        if createTime != 0 {
            try encodeContainer.encode(createTime, forKey: .createTime)
        }
        if let emailAddress = self.emailAddress {
            try encodeContainer.encode(emailAddress, forKey: .emailAddress)
        }
        if let firstName = self.firstName {
            try encodeContainer.encode(firstName, forKey: .firstName)
        }
        if lastDisabledTime != 0 {
            try encodeContainer.encode(lastDisabledTime, forKey: .lastDisabledTime)
        }
        if lastEnabledTime != 0 {
            try encodeContainer.encode(lastEnabledTime, forKey: .lastEnabledTime)
        }
        if lastLoginTime != 0 {
            try encodeContainer.encode(lastLoginTime, forKey: .lastLoginTime)
        }
        if lastModifiedTime != 0 {
            try encodeContainer.encode(lastModifiedTime, forKey: .lastModifiedTime)
        }
        if let lastName = self.lastName {
            try encodeContainer.encode(lastName, forKey: .lastName)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let userId = self.userId {
            try encodeContainer.encode(userId, forKey: .userId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userId)
        userId = userIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(FinspacedataClientTypes.UserStatus.self, forKey: .status)
        status = statusDecoded
        let firstNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .firstName)
        firstName = firstNameDecoded
        let lastNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastName)
        lastName = lastNameDecoded
        let emailAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .emailAddress)
        emailAddress = emailAddressDecoded
        let typeDecoded = try containerValues.decodeIfPresent(FinspacedataClientTypes.UserType.self, forKey: .type)
        type = typeDecoded
        let apiAccessDecoded = try containerValues.decodeIfPresent(FinspacedataClientTypes.ApiAccess.self, forKey: .apiAccess)
        apiAccess = apiAccessDecoded
        let apiAccessPrincipalArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiAccessPrincipalArn)
        apiAccessPrincipalArn = apiAccessPrincipalArnDecoded
        let createTimeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .createTime) ?? 0
        createTime = createTimeDecoded
        let lastEnabledTimeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .lastEnabledTime) ?? 0
        lastEnabledTime = lastEnabledTimeDecoded
        let lastDisabledTimeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .lastDisabledTime) ?? 0
        lastDisabledTime = lastDisabledTimeDecoded
        let lastModifiedTimeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .lastModifiedTime) ?? 0
        lastModifiedTime = lastModifiedTimeDecoded
        let lastLoginTimeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .lastLoginTime) ?? 0
        lastLoginTime = lastLoginTimeDecoded
    }
}

extension FinspacedataClientTypes.User: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "User(apiAccess: \(Swift.String(describing: apiAccess)), apiAccessPrincipalArn: \(Swift.String(describing: apiAccessPrincipalArn)), createTime: \(Swift.String(describing: createTime)), lastDisabledTime: \(Swift.String(describing: lastDisabledTime)), lastEnabledTime: \(Swift.String(describing: lastEnabledTime)), lastLoginTime: \(Swift.String(describing: lastLoginTime)), lastModifiedTime: \(Swift.String(describing: lastModifiedTime)), status: \(Swift.String(describing: status)), type: \(Swift.String(describing: type)), userId: \(Swift.String(describing: userId)), emailAddress: \"CONTENT_REDACTED\", firstName: \"CONTENT_REDACTED\", lastName: \"CONTENT_REDACTED\")"}
}

extension FinspacedataClientTypes {
    /// The details of the user.
    public struct User: Swift.Equatable {
        /// Indicates whether the user can use the GetProgrammaticAccessCredentials API to obtain credentials that can then be used to access other FinSpace Data API operations.
        ///
        /// * ENABLED – The user has permissions to use the APIs.
        ///
        /// * DISABLED – The user does not have permissions to use any APIs.
        public var apiAccess: FinspacedataClientTypes.ApiAccess?
        /// The ARN identifier of an AWS user or role that is allowed to call the GetProgrammaticAccessCredentials API to obtain a credentials token for a specific FinSpace user. This must be an IAM role within your FinSpace account.
        public var apiAccessPrincipalArn: Swift.String?
        /// The timestamp at which the user was created in FinSpace. The value is determined as epoch time in milliseconds.
        public var createTime: Swift.Int
        /// The email address of the user. The email address serves as a uniquer identifier for each user and cannot be changed after it's created.
        public var emailAddress: Swift.String?
        /// The first name of the user.
        public var firstName: Swift.String?
        /// Describes the last time the user was deactivated. The value is determined as epoch time in milliseconds.
        public var lastDisabledTime: Swift.Int
        /// Describes the last time the user was activated. The value is determined as epoch time in milliseconds.
        public var lastEnabledTime: Swift.Int
        /// Describes the last time that the user logged into their account. The value is determined as epoch time in milliseconds.
        public var lastLoginTime: Swift.Int
        /// Describes the last time the user was updated. The value is determined as epoch time in milliseconds.
        public var lastModifiedTime: Swift.Int
        /// The last name of the user.
        public var lastName: Swift.String?
        /// The current status of the user.
        ///
        /// * CREATING – The user creation is in progress.
        ///
        /// * ENABLED – The user is created and is currently active.
        ///
        /// * DISABLED – The user is currently inactive.
        public var status: FinspacedataClientTypes.UserStatus?
        /// Indicates the type of user.
        ///
        /// * SUPER_USER – A user with permission to all the functionality and data in FinSpace.
        ///
        /// * APP_USER – A user with specific permissions in FinSpace. The users are assigned permissions by adding them to a permission group.
        public var type: FinspacedataClientTypes.UserType?
        /// The unique identifier for the user.
        public var userId: Swift.String?

        public init(
            apiAccess: FinspacedataClientTypes.ApiAccess? = nil,
            apiAccessPrincipalArn: Swift.String? = nil,
            createTime: Swift.Int = 0,
            emailAddress: Swift.String? = nil,
            firstName: Swift.String? = nil,
            lastDisabledTime: Swift.Int = 0,
            lastEnabledTime: Swift.Int = 0,
            lastLoginTime: Swift.Int = 0,
            lastModifiedTime: Swift.Int = 0,
            lastName: Swift.String? = nil,
            status: FinspacedataClientTypes.UserStatus? = nil,
            type: FinspacedataClientTypes.UserType? = nil,
            userId: Swift.String? = nil
        )
        {
            self.apiAccess = apiAccess
            self.apiAccessPrincipalArn = apiAccessPrincipalArn
            self.createTime = createTime
            self.emailAddress = emailAddress
            self.firstName = firstName
            self.lastDisabledTime = lastDisabledTime
            self.lastEnabledTime = lastEnabledTime
            self.lastLoginTime = lastLoginTime
            self.lastModifiedTime = lastModifiedTime
            self.lastName = lastName
            self.status = status
            self.type = type
            self.userId = userId
        }
    }

}

extension FinspacedataClientTypes.UserByPermissionGroup: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case apiAccess
        case apiAccessPrincipalArn
        case emailAddress
        case firstName
        case lastName
        case membershipStatus
        case status
        case type
        case userId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let apiAccess = self.apiAccess {
            try encodeContainer.encode(apiAccess.rawValue, forKey: .apiAccess)
        }
        if let apiAccessPrincipalArn = self.apiAccessPrincipalArn {
            try encodeContainer.encode(apiAccessPrincipalArn, forKey: .apiAccessPrincipalArn)
        }
        if let emailAddress = self.emailAddress {
            try encodeContainer.encode(emailAddress, forKey: .emailAddress)
        }
        if let firstName = self.firstName {
            try encodeContainer.encode(firstName, forKey: .firstName)
        }
        if let lastName = self.lastName {
            try encodeContainer.encode(lastName, forKey: .lastName)
        }
        if let membershipStatus = self.membershipStatus {
            try encodeContainer.encode(membershipStatus.rawValue, forKey: .membershipStatus)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let userId = self.userId {
            try encodeContainer.encode(userId, forKey: .userId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userId)
        userId = userIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(FinspacedataClientTypes.UserStatus.self, forKey: .status)
        status = statusDecoded
        let firstNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .firstName)
        firstName = firstNameDecoded
        let lastNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lastName)
        lastName = lastNameDecoded
        let emailAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .emailAddress)
        emailAddress = emailAddressDecoded
        let typeDecoded = try containerValues.decodeIfPresent(FinspacedataClientTypes.UserType.self, forKey: .type)
        type = typeDecoded
        let apiAccessDecoded = try containerValues.decodeIfPresent(FinspacedataClientTypes.ApiAccess.self, forKey: .apiAccess)
        apiAccess = apiAccessDecoded
        let apiAccessPrincipalArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .apiAccessPrincipalArn)
        apiAccessPrincipalArn = apiAccessPrincipalArnDecoded
        let membershipStatusDecoded = try containerValues.decodeIfPresent(FinspacedataClientTypes.PermissionGroupMembershipStatus.self, forKey: .membershipStatus)
        membershipStatus = membershipStatusDecoded
    }
}

extension FinspacedataClientTypes.UserByPermissionGroup: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UserByPermissionGroup(apiAccess: \(Swift.String(describing: apiAccess)), apiAccessPrincipalArn: \(Swift.String(describing: apiAccessPrincipalArn)), membershipStatus: \(Swift.String(describing: membershipStatus)), status: \(Swift.String(describing: status)), type: \(Swift.String(describing: type)), userId: \(Swift.String(describing: userId)), emailAddress: \"CONTENT_REDACTED\", firstName: \"CONTENT_REDACTED\", lastName: \"CONTENT_REDACTED\")"}
}

extension FinspacedataClientTypes {
    /// The structure of a user associated with a permission group.
    public struct UserByPermissionGroup: Swift.Equatable {
        /// Indicates whether the user can access FinSpace API operations.
        ///
        /// * ENABLED – The user has permissions to use the API operations.
        ///
        /// * DISABLED – The user does not have permissions to use any API operations.
        public var apiAccess: FinspacedataClientTypes.ApiAccess?
        /// The IAM ARN identifier that is attached to FinSpace API calls.
        public var apiAccessPrincipalArn: Swift.String?
        /// The email address of the user. The email address serves as a unique identifier for each user and cannot be changed after it's created.
        public var emailAddress: Swift.String?
        /// The first name of the user.
        public var firstName: Swift.String?
        /// The last name of the user.
        public var lastName: Swift.String?
        /// Indicates the status of the user within a permission group.
        ///
        /// * ADDITION_IN_PROGRESS – The user is currently being added to the permission group.
        ///
        /// * ADDITION_SUCCESS – The user is successfully added to the permission group.
        ///
        /// * REMOVAL_IN_PROGRESS – The user is currently being removed from the permission group.
        public var membershipStatus: FinspacedataClientTypes.PermissionGroupMembershipStatus?
        /// The current status of the user.
        ///
        /// * CREATING – The user creation is in progress.
        ///
        /// * ENABLED – The user is created and is currently active.
        ///
        /// * DISABLED – The user is currently inactive.
        public var status: FinspacedataClientTypes.UserStatus?
        /// Indicates the type of user.
        ///
        /// * SUPER_USER – A user with permission to all the functionality and data in FinSpace.
        ///
        /// * APP_USER – A user with specific permissions in FinSpace. The users are assigned permissions by adding them to a permission group.
        public var type: FinspacedataClientTypes.UserType?
        /// The unique identifier for the user.
        public var userId: Swift.String?

        public init(
            apiAccess: FinspacedataClientTypes.ApiAccess? = nil,
            apiAccessPrincipalArn: Swift.String? = nil,
            emailAddress: Swift.String? = nil,
            firstName: Swift.String? = nil,
            lastName: Swift.String? = nil,
            membershipStatus: FinspacedataClientTypes.PermissionGroupMembershipStatus? = nil,
            status: FinspacedataClientTypes.UserStatus? = nil,
            type: FinspacedataClientTypes.UserType? = nil,
            userId: Swift.String? = nil
        )
        {
            self.apiAccess = apiAccess
            self.apiAccessPrincipalArn = apiAccessPrincipalArn
            self.emailAddress = emailAddress
            self.firstName = firstName
            self.lastName = lastName
            self.membershipStatus = membershipStatus
            self.status = status
            self.type = type
            self.userId = userId
        }
    }

}

extension FinspacedataClientTypes {
    public enum UserStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case creating
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [UserStatus] {
            return [
                .creating,
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .creating: return "CREATING"
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = UserStatus(rawValue: rawValue) ?? UserStatus.sdkUnknown(rawValue)
        }
    }
}

extension FinspacedataClientTypes {
    public enum UserType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case appUser
        case superUser
        case sdkUnknown(Swift.String)

        public static var allCases: [UserType] {
            return [
                .appUser,
                .superUser,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .appUser: return "APP_USER"
            case .superUser: return "SUPER_USER"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = UserType(rawValue: rawValue) ?? UserType.sdkUnknown(rawValue)
        }
    }
}

extension ValidationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.reason = output.reason
        } else {
            self.properties.message = nil
            self.properties.reason = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The input fails to satisfy the constraints specified by an AWS service.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        public internal(set) var reason: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        reason: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.reason = reason
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let reason: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case reason
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reason)
        reason = reasonDecoded
    }
}
