//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
@_spi(SmithyReadWrite) import func SmithyReadWrite.listReadingClosure
@_spi(SmithyReadWrite) import func SmithyReadWrite.listWritingClosure
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.AWSJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
@_spi(SmithyTimestamps) import struct SmithyTimestamps.TimestampFormatter

/// You are not authorized to use this operation with the given parameters.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The error message the exception carries.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension BudgetsClientTypes {

    /// The type of threshold for a notification.
    public enum ThresholdType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case absoluteValue
        case percentage
        case sdkUnknown(Swift.String)

        public static var allCases: [ThresholdType] {
            return [
                .absoluteValue,
                .percentage
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .absoluteValue: return "ABSOLUTE_VALUE"
            case .percentage: return "PERCENTAGE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BudgetsClientTypes {
    /// The trigger threshold of the action.
    public struct ActionThreshold {
        /// The type of threshold for a notification.
        /// This member is required.
        public var actionThresholdType: BudgetsClientTypes.ThresholdType?
        /// The threshold of a notification.
        /// This member is required.
        public var actionThresholdValue: Swift.Double

        public init(
            actionThresholdType: BudgetsClientTypes.ThresholdType? = nil,
            actionThresholdValue: Swift.Double = 0.0
        )
        {
            self.actionThresholdType = actionThresholdType
            self.actionThresholdValue = actionThresholdValue
        }
    }

}

extension BudgetsClientTypes {

    public enum ActionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case iam
        case scp
        case ssm
        case sdkUnknown(Swift.String)

        public static var allCases: [ActionType] {
            return [
                .iam,
                .scp,
                .ssm
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .iam: return "APPLY_IAM_POLICY"
            case .scp: return "APPLY_SCP_POLICY"
            case .ssm: return "RUN_SSM_DOCUMENTS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BudgetsClientTypes {

    public enum ApprovalModel: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case auto
        case manual
        case sdkUnknown(Swift.String)

        public static var allCases: [ApprovalModel] {
            return [
                .auto,
                .manual
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .auto: return "AUTOMATIC"
            case .manual: return "MANUAL"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BudgetsClientTypes {
    /// The Identity and Access Management (IAM) action definition details.
    public struct IamActionDefinition {
        /// A list of groups to be attached. There must be at least one group.
        public var groups: [Swift.String]?
        /// The Amazon Resource Name (ARN) of the policy to be attached.
        /// This member is required.
        public var policyArn: Swift.String?
        /// A list of roles to be attached. There must be at least one role.
        public var roles: [Swift.String]?
        /// A list of users to be attached. There must be at least one user.
        public var users: [Swift.String]?

        public init(
            groups: [Swift.String]? = nil,
            policyArn: Swift.String? = nil,
            roles: [Swift.String]? = nil,
            users: [Swift.String]? = nil
        )
        {
            self.groups = groups
            self.policyArn = policyArn
            self.roles = roles
            self.users = users
        }
    }

}

extension BudgetsClientTypes {
    /// The service control policies (SCP) action definition details.
    public struct ScpActionDefinition {
        /// The policy ID attached.
        /// This member is required.
        public var policyId: Swift.String?
        /// A list of target IDs.
        /// This member is required.
        public var targetIds: [Swift.String]?

        public init(
            policyId: Swift.String? = nil,
            targetIds: [Swift.String]? = nil
        )
        {
            self.policyId = policyId
            self.targetIds = targetIds
        }
    }

}

extension BudgetsClientTypes {

    public enum ActionSubType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case stopEc2
        case stopRds
        case sdkUnknown(Swift.String)

        public static var allCases: [ActionSubType] {
            return [
                .stopEc2,
                .stopRds
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .stopEc2: return "STOP_EC2_INSTANCES"
            case .stopRds: return "STOP_RDS_INSTANCES"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BudgetsClientTypes {
    /// The Amazon Web Services Systems Manager (SSM) action definition details.
    public struct SsmActionDefinition {
        /// The action subType.
        /// This member is required.
        public var actionSubType: BudgetsClientTypes.ActionSubType?
        /// The EC2 and RDS instance IDs.
        /// This member is required.
        public var instanceIds: [Swift.String]?
        /// The Region to run the SSM document.
        /// This member is required.
        public var region: Swift.String?

        public init(
            actionSubType: BudgetsClientTypes.ActionSubType? = nil,
            instanceIds: [Swift.String]? = nil,
            region: Swift.String? = nil
        )
        {
            self.actionSubType = actionSubType
            self.instanceIds = instanceIds
            self.region = region
        }
    }

}

extension BudgetsClientTypes {
    /// Specifies all of the type-specific parameters.
    public struct Definition {
        /// The Identity and Access Management (IAM) action definition details.
        public var iamActionDefinition: BudgetsClientTypes.IamActionDefinition?
        /// The service control policies (SCPs) action definition details.
        public var scpActionDefinition: BudgetsClientTypes.ScpActionDefinition?
        /// The Amazon Web Services Systems Manager (SSM) action definition details.
        public var ssmActionDefinition: BudgetsClientTypes.SsmActionDefinition?

        public init(
            iamActionDefinition: BudgetsClientTypes.IamActionDefinition? = nil,
            scpActionDefinition: BudgetsClientTypes.ScpActionDefinition? = nil,
            ssmActionDefinition: BudgetsClientTypes.SsmActionDefinition? = nil
        )
        {
            self.iamActionDefinition = iamActionDefinition
            self.scpActionDefinition = scpActionDefinition
            self.ssmActionDefinition = ssmActionDefinition
        }
    }

}

extension BudgetsClientTypes {

    /// The type of a notification. It must be ACTUAL or FORECASTED.
    public enum NotificationType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case actual
        case forecasted
        case sdkUnknown(Swift.String)

        public static var allCases: [NotificationType] {
            return [
                .actual,
                .forecasted
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .actual: return "ACTUAL"
            case .forecasted: return "FORECASTED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BudgetsClientTypes {

    public enum ActionStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case executionFailure
        case executionInProgress
        case executionSuccess
        case pending
        case resetFailure
        case resetInProgress
        case reverseFailure
        case reverseInProgress
        case reverseSuccess
        case standby
        case sdkUnknown(Swift.String)

        public static var allCases: [ActionStatus] {
            return [
                .executionFailure,
                .executionInProgress,
                .executionSuccess,
                .pending,
                .resetFailure,
                .resetInProgress,
                .reverseFailure,
                .reverseInProgress,
                .reverseSuccess,
                .standby
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .executionFailure: return "EXECUTION_FAILURE"
            case .executionInProgress: return "EXECUTION_IN_PROGRESS"
            case .executionSuccess: return "EXECUTION_SUCCESS"
            case .pending: return "PENDING"
            case .resetFailure: return "RESET_FAILURE"
            case .resetInProgress: return "RESET_IN_PROGRESS"
            case .reverseFailure: return "REVERSE_FAILURE"
            case .reverseInProgress: return "REVERSE_IN_PROGRESS"
            case .reverseSuccess: return "REVERSE_SUCCESS"
            case .standby: return "STANDBY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BudgetsClientTypes {

    /// The subscription type of the subscriber. It can be SMS or EMAIL.
    public enum SubscriptionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case email
        case sns
        case sdkUnknown(Swift.String)

        public static var allCases: [SubscriptionType] {
            return [
                .email,
                .sns
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .email: return "EMAIL"
            case .sns: return "SNS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BudgetsClientTypes {
    /// The subscriber to a budget notification. The subscriber consists of a subscription type and either an Amazon SNS topic or an email address. For example, an email subscriber has the following parameters:
    ///
    /// * A subscriptionType of EMAIL
    ///
    /// * An address of example@example.com
    public struct Subscriber {
        /// The address that Amazon Web Services sends budget notifications to, either an SNS topic or an email. When you create a subscriber, the value of Address can't contain line breaks.
        /// This member is required.
        public var address: Swift.String?
        /// The type of notification that Amazon Web Services sends to a subscriber.
        /// This member is required.
        public var subscriptionType: BudgetsClientTypes.SubscriptionType?

        public init(
            address: Swift.String? = nil,
            subscriptionType: BudgetsClientTypes.SubscriptionType? = nil
        )
        {
            self.address = address
            self.subscriptionType = subscriptionType
        }
    }

}

extension BudgetsClientTypes.Subscriber: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Subscriber(subscriptionType: \(Swift.String(describing: subscriptionType)), address: \"CONTENT_REDACTED\")"}
}

extension BudgetsClientTypes {
    /// A budget action resource.
    public struct Action {
        /// A system-generated universally unique identifier (UUID) for the action.
        /// This member is required.
        public var actionId: Swift.String?
        /// The trigger threshold of the action.
        /// This member is required.
        public var actionThreshold: BudgetsClientTypes.ActionThreshold?
        /// The type of action. This defines the type of tasks that can be carried out by this action. This field also determines the format for definition.
        /// This member is required.
        public var actionType: BudgetsClientTypes.ActionType?
        /// This specifies if the action needs manual or automatic approval.
        /// This member is required.
        public var approvalModel: BudgetsClientTypes.ApprovalModel?
        /// A string that represents the budget name. The ":" and "\" characters, and the "/action/" substring, aren't allowed.
        /// This member is required.
        public var budgetName: Swift.String?
        /// Where you specify all of the type-specific parameters.
        /// This member is required.
        public var definition: BudgetsClientTypes.Definition?
        /// The role passed for action execution and reversion. Roles and actions must be in the same account.
        /// This member is required.
        public var executionRoleArn: Swift.String?
        /// The type of a notification. It must be ACTUAL or FORECASTED.
        /// This member is required.
        public var notificationType: BudgetsClientTypes.NotificationType?
        /// The status of the action.
        /// This member is required.
        public var status: BudgetsClientTypes.ActionStatus?
        /// A list of subscribers.
        /// This member is required.
        public var subscribers: [BudgetsClientTypes.Subscriber]?

        public init(
            actionId: Swift.String? = nil,
            actionThreshold: BudgetsClientTypes.ActionThreshold? = nil,
            actionType: BudgetsClientTypes.ActionType? = nil,
            approvalModel: BudgetsClientTypes.ApprovalModel? = nil,
            budgetName: Swift.String? = nil,
            definition: BudgetsClientTypes.Definition? = nil,
            executionRoleArn: Swift.String? = nil,
            notificationType: BudgetsClientTypes.NotificationType? = nil,
            status: BudgetsClientTypes.ActionStatus? = nil,
            subscribers: [BudgetsClientTypes.Subscriber]? = nil
        )
        {
            self.actionId = actionId
            self.actionThreshold = actionThreshold
            self.actionType = actionType
            self.approvalModel = approvalModel
            self.budgetName = budgetName
            self.definition = definition
            self.executionRoleArn = executionRoleArn
            self.notificationType = notificationType
            self.status = status
            self.subscribers = subscribers
        }
    }

}

extension BudgetsClientTypes {
    /// The description of the details for the event.
    public struct ActionHistoryDetails {
        /// The budget action resource.
        /// This member is required.
        public var action: BudgetsClientTypes.Action?
        /// A generic string.
        /// This member is required.
        public var message: Swift.String?

        public init(
            action: BudgetsClientTypes.Action? = nil,
            message: Swift.String? = nil
        )
        {
            self.action = action
            self.message = message
        }
    }

}

extension BudgetsClientTypes {

    public enum EventType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case createaction
        case deleteaction
        case executeaction
        case system
        case updateaction
        case sdkUnknown(Swift.String)

        public static var allCases: [EventType] {
            return [
                .createaction,
                .deleteaction,
                .executeaction,
                .system,
                .updateaction
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .createaction: return "CREATE_ACTION"
            case .deleteaction: return "DELETE_ACTION"
            case .executeaction: return "EXECUTE_ACTION"
            case .system: return "SYSTEM"
            case .updateaction: return "UPDATE_ACTION"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BudgetsClientTypes {
    /// The historical records for a budget action.
    public struct ActionHistory {
        /// The description of the details for the event.
        /// This member is required.
        public var actionHistoryDetails: BudgetsClientTypes.ActionHistoryDetails?
        /// This distinguishes between whether the events are triggered by the user or are generated by the system.
        /// This member is required.
        public var eventType: BudgetsClientTypes.EventType?
        /// The status of action at the time of the event.
        /// This member is required.
        public var status: BudgetsClientTypes.ActionStatus?
        /// A generic time stamp. In Java, it's transformed to a Date object.
        /// This member is required.
        public var timestamp: Foundation.Date?

        public init(
            actionHistoryDetails: BudgetsClientTypes.ActionHistoryDetails? = nil,
            eventType: BudgetsClientTypes.EventType? = nil,
            status: BudgetsClientTypes.ActionStatus? = nil,
            timestamp: Foundation.Date? = nil
        )
        {
            self.actionHistoryDetails = actionHistoryDetails
            self.eventType = eventType
            self.status = status
            self.timestamp = timestamp
        }
    }

}

extension BudgetsClientTypes {

    public enum AutoAdjustType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case forecast
        case historical
        case sdkUnknown(Swift.String)

        public static var allCases: [AutoAdjustType] {
            return [
                .forecast,
                .historical
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .forecast: return "FORECAST"
            case .historical: return "HISTORICAL"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BudgetsClientTypes {
    /// The parameters that define or describe the historical data that your auto-adjusting budget is based on.
    public struct HistoricalOptions {
        /// The number of budget periods included in the moving-average calculation that determines your auto-adjusted budget amount. The maximum value depends on the TimeUnit granularity of the budget:
        ///
        /// * For the DAILY granularity, the maximum value is 60.
        ///
        /// * For the MONTHLY granularity, the maximum value is 12.
        ///
        /// * For the QUARTERLY granularity, the maximum value is 4.
        ///
        /// * For the ANNUALLY granularity, the maximum value is 1.
        /// This member is required.
        public var budgetAdjustmentPeriod: Swift.Int?
        /// The integer that describes how many budget periods in your BudgetAdjustmentPeriod are included in the calculation of your current BudgetLimit. If the first budget period in your BudgetAdjustmentPeriod has no cost data, then that budget period isn’t included in the average that determines your budget limit. For example, if you set BudgetAdjustmentPeriod as 4 quarters, but your account had no cost data in the first quarter, then only the last three quarters are included in the calculation. In this scenario, LookBackAvailablePeriods returns 3. You can’t set your own LookBackAvailablePeriods. The value is automatically calculated from the BudgetAdjustmentPeriod and your historical cost data.
        public var lookBackAvailablePeriods: Swift.Int?

        public init(
            budgetAdjustmentPeriod: Swift.Int? = nil,
            lookBackAvailablePeriods: Swift.Int? = nil
        )
        {
            self.budgetAdjustmentPeriod = budgetAdjustmentPeriod
            self.lookBackAvailablePeriods = lookBackAvailablePeriods
        }
    }

}

extension BudgetsClientTypes {
    /// The parameters that determine the budget amount for an auto-adjusting budget.
    public struct AutoAdjustData {
        /// The string that defines whether your budget auto-adjusts based on historical or forecasted data.
        /// This member is required.
        public var autoAdjustType: BudgetsClientTypes.AutoAdjustType?
        /// The parameters that define or describe the historical data that your auto-adjusting budget is based on.
        public var historicalOptions: BudgetsClientTypes.HistoricalOptions?
        /// The last time that your budget was auto-adjusted.
        public var lastAutoAdjustTime: Foundation.Date?

        public init(
            autoAdjustType: BudgetsClientTypes.AutoAdjustType? = nil,
            historicalOptions: BudgetsClientTypes.HistoricalOptions? = nil,
            lastAutoAdjustTime: Foundation.Date? = nil
        )
        {
            self.autoAdjustType = autoAdjustType
            self.historicalOptions = historicalOptions
            self.lastAutoAdjustTime = lastAutoAdjustTime
        }
    }

}

/// You've exceeded the notification or subscriber limit.
public struct CreationLimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The error message the exception carries.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "CreationLimitExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The budget name already exists. Budget names must be unique within an account.
public struct DuplicateRecordException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The error message the exception carries.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "DuplicateRecordException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// An error on the server occurred during the processing of your request. Try again later.
public struct InternalErrorException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The error message the exception carries.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalErrorException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// An error on the client occurred. Typically, the cause is an invalid input value.
public struct InvalidParameterException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The error message the exception carries.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidParameterException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// You've reached the limit on the number of tags you can associate with a resource.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The error message the exception carries.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

/// The number of API requests has exceeded the maximum allowed API request throttling limit for the account.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The error message the exception carries.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension BudgetsClientTypes {
    /// The amount of cost or usage that's measured for a budget. Cost example: A Spend for 3 USD of costs has the following parameters:
    ///
    /// * An Amount of 3
    ///
    /// * A Unit of USD
    ///
    ///
    /// Usage example: A Spend for 3 GB of S3 usage has the following parameters:
    ///
    /// * An Amount of 3
    ///
    /// * A Unit of GB
    public struct Spend {
        /// The cost or usage amount that's associated with a budget forecast, actual spend, or budget threshold.
        /// This member is required.
        public var amount: Swift.String?
        /// The unit of measurement that's used for the budget forecast, actual spend, or budget threshold.
        /// This member is required.
        public var unit: Swift.String?

        public init(
            amount: Swift.String? = nil,
            unit: Swift.String? = nil
        )
        {
            self.amount = amount
            self.unit = unit
        }
    }

}

extension BudgetsClientTypes {

    /// The type of a budget. It must be one of the following types: COST, USAGE, RI_UTILIZATION, RI_COVERAGE, SAVINGS_PLANS_UTILIZATION, or SAVINGS_PLANS_COVERAGE.
    public enum BudgetType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case cost
        case ricoverage
        case riutilization
        case spcoverage
        case sputilization
        case usage
        case sdkUnknown(Swift.String)

        public static var allCases: [BudgetType] {
            return [
                .cost,
                .ricoverage,
                .riutilization,
                .spcoverage,
                .sputilization,
                .usage
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .cost: return "COST"
            case .ricoverage: return "RI_COVERAGE"
            case .riutilization: return "RI_UTILIZATION"
            case .spcoverage: return "SAVINGS_PLANS_COVERAGE"
            case .sputilization: return "SAVINGS_PLANS_UTILIZATION"
            case .usage: return "USAGE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BudgetsClientTypes {
    /// The spend objects that are associated with this budget. The actualSpend tracks how much you've used, cost, usage, RI units, or Savings Plans units and the forecastedSpend tracks how much that you're predicted to spend based on your historical usage profile. For example, if it's the 20th of the month and you have spent 50 dollars on Amazon EC2, your actualSpend is 50 USD, and your forecastedSpend is 75 USD.
    public struct CalculatedSpend {
        /// The amount of cost, usage, RI units, or Savings Plans units that you used.
        /// This member is required.
        public var actualSpend: BudgetsClientTypes.Spend?
        /// The amount of cost, usage, RI units, or Savings Plans units that you're forecasted to use.
        public var forecastedSpend: BudgetsClientTypes.Spend?

        public init(
            actualSpend: BudgetsClientTypes.Spend? = nil,
            forecastedSpend: BudgetsClientTypes.Spend? = nil
        )
        {
            self.actualSpend = actualSpend
            self.forecastedSpend = forecastedSpend
        }
    }

}

extension BudgetsClientTypes {
    /// The types of cost that are included in a COST budget, such as tax and subscriptions. USAGE, RI_UTILIZATION, RI_COVERAGE, SAVINGS_PLANS_UTILIZATION, and SAVINGS_PLANS_COVERAGE budgets don't have CostTypes.
    public struct CostTypes {
        /// Specifies whether a budget includes credits. The default value is true.
        public var includeCredit: Swift.Bool?
        /// Specifies whether a budget includes discounts. The default value is true.
        public var includeDiscount: Swift.Bool?
        /// Specifies whether a budget includes non-RI subscription costs. The default value is true.
        public var includeOtherSubscription: Swift.Bool?
        /// Specifies whether a budget includes recurring fees such as monthly RI fees. The default value is true.
        public var includeRecurring: Swift.Bool?
        /// Specifies whether a budget includes refunds. The default value is true.
        public var includeRefund: Swift.Bool?
        /// Specifies whether a budget includes subscriptions. The default value is true.
        public var includeSubscription: Swift.Bool?
        /// Specifies whether a budget includes support subscription fees. The default value is true.
        public var includeSupport: Swift.Bool?
        /// Specifies whether a budget includes taxes. The default value is true.
        public var includeTax: Swift.Bool?
        /// Specifies whether a budget includes upfront RI costs. The default value is true.
        public var includeUpfront: Swift.Bool?
        /// Specifies whether a budget uses the amortized rate. The default value is false.
        public var useAmortized: Swift.Bool?
        /// Specifies whether a budget uses a blended rate. The default value is false.
        public var useBlended: Swift.Bool?

        public init(
            includeCredit: Swift.Bool? = nil,
            includeDiscount: Swift.Bool? = nil,
            includeOtherSubscription: Swift.Bool? = nil,
            includeRecurring: Swift.Bool? = nil,
            includeRefund: Swift.Bool? = nil,
            includeSubscription: Swift.Bool? = nil,
            includeSupport: Swift.Bool? = nil,
            includeTax: Swift.Bool? = nil,
            includeUpfront: Swift.Bool? = nil,
            useAmortized: Swift.Bool? = nil,
            useBlended: Swift.Bool? = nil
        )
        {
            self.includeCredit = includeCredit
            self.includeDiscount = includeDiscount
            self.includeOtherSubscription = includeOtherSubscription
            self.includeRecurring = includeRecurring
            self.includeRefund = includeRefund
            self.includeSubscription = includeSubscription
            self.includeSupport = includeSupport
            self.includeTax = includeTax
            self.includeUpfront = includeUpfront
            self.useAmortized = useAmortized
            self.useBlended = useBlended
        }
    }

}

extension BudgetsClientTypes {
    /// The period of time that's covered by a budget. The period has a start date and an end date. The start date must come before the end date. There are no restrictions on the end date.
    public struct TimePeriod {
        /// The end date for a budget. If you didn't specify an end date, Amazon Web Services set your end date to 06/15/87 00:00 UTC. The defaults are the same for the Billing and Cost Management console and the API. After the end date, Amazon Web Services deletes the budget and all the associated notifications and subscribers. You can change your end date with the UpdateBudget operation.
        public var end: Foundation.Date?
        /// The start date for a budget. If you created your budget and didn't specify a start date, Amazon Web Services defaults to the start of your chosen time period (DAILY, MONTHLY, QUARTERLY, or ANNUALLY). For example, if you created your budget on January 24, 2018, chose DAILY, and didn't set a start date, Amazon Web Services set your start date to 01/24/18 00:00 UTC. If you chose MONTHLY, Amazon Web Services set your start date to 01/01/18 00:00 UTC. The defaults are the same for the Billing and Cost Management console and the API. You can change your start date with the UpdateBudget operation.
        public var start: Foundation.Date?

        public init(
            end: Foundation.Date? = nil,
            start: Foundation.Date? = nil
        )
        {
            self.end = end
            self.start = start
        }
    }

}

extension BudgetsClientTypes {

    /// The time unit of the budget, such as MONTHLY or QUARTERLY.
    public enum TimeUnit: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case annually
        case daily
        case monthly
        case quarterly
        case sdkUnknown(Swift.String)

        public static var allCases: [TimeUnit] {
            return [
                .annually,
                .daily,
                .monthly,
                .quarterly
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .annually: return "ANNUALLY"
            case .daily: return "DAILY"
            case .monthly: return "MONTHLY"
            case .quarterly: return "QUARTERLY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BudgetsClientTypes {
    /// Represents the output of the CreateBudget operation. The content consists of the detailed metadata and data file information, and the current status of the budget object. This is the Amazon Resource Name (ARN) pattern for a budget: arn:aws:budgets::AccountId:budget/budgetName
    public struct Budget {
        /// The parameters that determine the budget amount for an auto-adjusting budget.
        public var autoAdjustData: BudgetsClientTypes.AutoAdjustData?
        /// The total amount of cost, usage, RI utilization, RI coverage, Savings Plans utilization, or Savings Plans coverage that you want to track with your budget. BudgetLimit is required for cost or usage budgets, but optional for RI or Savings Plans utilization or coverage budgets. RI and Savings Plans utilization or coverage budgets default to 100. This is the only valid value for RI or Savings Plans utilization or coverage budgets. You can't use BudgetLimit with PlannedBudgetLimits for CreateBudget and UpdateBudget actions.
        public var budgetLimit: BudgetsClientTypes.Spend?
        /// The name of a budget. The name must be unique within an account. The : and \ characters, and the "/action/" substring, aren't allowed in BudgetName.
        /// This member is required.
        public var budgetName: Swift.String?
        /// Specifies whether this budget tracks costs, usage, RI utilization, RI coverage, Savings Plans utilization, or Savings Plans coverage.
        /// This member is required.
        public var budgetType: BudgetsClientTypes.BudgetType?
        /// The actual and forecasted cost or usage that the budget tracks.
        public var calculatedSpend: BudgetsClientTypes.CalculatedSpend?
        /// The cost filters, such as Region, Service, LinkedAccount, Tag, or CostCategory, that are applied to a budget. Amazon Web Services Budgets supports the following services as a Service filter for RI budgets:
        ///
        /// * Amazon EC2
        ///
        /// * Amazon Redshift
        ///
        /// * Amazon Relational Database Service
        ///
        /// * Amazon ElastiCache
        ///
        /// * Amazon OpenSearch Service
        public var costFilters: [Swift.String: [Swift.String]]?
        /// The types of costs that are included in this COST budget. USAGE, RI_UTILIZATION, RI_COVERAGE, SAVINGS_PLANS_UTILIZATION, and SAVINGS_PLANS_COVERAGE budgets do not have CostTypes.
        public var costTypes: BudgetsClientTypes.CostTypes?
        /// The last time that you updated this budget.
        public var lastUpdatedTime: Foundation.Date?
        /// A map containing multiple BudgetLimit, including current or future limits. PlannedBudgetLimits is available for cost or usage budget and supports both monthly and quarterly TimeUnit. For monthly budgets, provide 12 months of PlannedBudgetLimits values. This must start from the current month and include the next 11 months. The key is the start of the month, UTC in epoch seconds. For quarterly budgets, provide four quarters of PlannedBudgetLimits value entries in standard calendar quarter increments. This must start from the current quarter and include the next three quarters. The key is the start of the quarter, UTC in epoch seconds. If the planned budget expires before 12 months for monthly or four quarters for quarterly, provide the PlannedBudgetLimits values only for the remaining periods. If the budget begins at a date in the future, provide PlannedBudgetLimits values from the start date of the budget. After all of the BudgetLimit values in PlannedBudgetLimits are used, the budget continues to use the last limit as the BudgetLimit. At that point, the planned budget provides the same experience as a fixed budget. DescribeBudget and DescribeBudgets response along with PlannedBudgetLimits also contain BudgetLimit representing the current month or quarter limit present in PlannedBudgetLimits. This only applies to budgets that are created with PlannedBudgetLimits. Budgets that are created without PlannedBudgetLimits only contain BudgetLimit. They don't contain PlannedBudgetLimits.
        public var plannedBudgetLimits: [Swift.String: BudgetsClientTypes.Spend]?
        /// The period of time that's covered by a budget. You setthe start date and end date. The start date must come before the end date. The end date must come before 06/15/87 00:00 UTC. If you create your budget and don't specify a start date, Amazon Web Services defaults to the start of your chosen time period (DAILY, MONTHLY, QUARTERLY, or ANNUALLY). For example, if you created your budget on January 24, 2018, chose DAILY, and didn't set a start date, Amazon Web Services set your start date to 01/24/18 00:00 UTC. If you chose MONTHLY, Amazon Web Services set your start date to 01/01/18 00:00 UTC. If you didn't specify an end date, Amazon Web Services set your end date to 06/15/87 00:00 UTC. The defaults are the same for the Billing and Cost Management console and the API. You can change either date with the UpdateBudget operation. After the end date, Amazon Web Services deletes the budget and all the associated notifications and subscribers.
        public var timePeriod: BudgetsClientTypes.TimePeriod?
        /// The length of time until a budget resets the actual and forecasted spend.
        /// This member is required.
        public var timeUnit: BudgetsClientTypes.TimeUnit?

        public init(
            autoAdjustData: BudgetsClientTypes.AutoAdjustData? = nil,
            budgetLimit: BudgetsClientTypes.Spend? = nil,
            budgetName: Swift.String? = nil,
            budgetType: BudgetsClientTypes.BudgetType? = nil,
            calculatedSpend: BudgetsClientTypes.CalculatedSpend? = nil,
            costFilters: [Swift.String: [Swift.String]]? = nil,
            costTypes: BudgetsClientTypes.CostTypes? = nil,
            lastUpdatedTime: Foundation.Date? = nil,
            plannedBudgetLimits: [Swift.String: BudgetsClientTypes.Spend]? = nil,
            timePeriod: BudgetsClientTypes.TimePeriod? = nil,
            timeUnit: BudgetsClientTypes.TimeUnit? = nil
        )
        {
            self.autoAdjustData = autoAdjustData
            self.budgetLimit = budgetLimit
            self.budgetName = budgetName
            self.budgetType = budgetType
            self.calculatedSpend = calculatedSpend
            self.costFilters = costFilters
            self.costTypes = costTypes
            self.lastUpdatedTime = lastUpdatedTime
            self.plannedBudgetLimits = plannedBudgetLimits
            self.timePeriod = timePeriod
            self.timeUnit = timeUnit
        }
    }

}

extension BudgetsClientTypes {

    /// The comparison operator of a notification. Currently, the service supports the following operators: GREATER_THAN, LESS_THAN, EQUAL_TO
    public enum ComparisonOperator: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case equalTo
        case greaterThan
        case lessThan
        case sdkUnknown(Swift.String)

        public static var allCases: [ComparisonOperator] {
            return [
                .equalTo,
                .greaterThan,
                .lessThan
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .equalTo: return "EQUAL_TO"
            case .greaterThan: return "GREATER_THAN"
            case .lessThan: return "LESS_THAN"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BudgetsClientTypes {

    public enum NotificationState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case alarm
        case ok
        case sdkUnknown(Swift.String)

        public static var allCases: [NotificationState] {
            return [
                .alarm,
                .ok
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .alarm: return "ALARM"
            case .ok: return "OK"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension BudgetsClientTypes {
    /// A notification that's associated with a budget. A budget can have up to ten notifications. Each notification must have at least one subscriber. A notification can have one SNS subscriber and up to 10 email subscribers, for a total of 11 subscribers. For example, if you have a budget for 200 dollars and you want to be notified when you go over 160 dollars, create a notification with the following parameters:
    ///
    /// * A notificationType of ACTUAL
    ///
    /// * A thresholdType of PERCENTAGE
    ///
    /// * A comparisonOperator of GREATER_THAN
    ///
    /// * A notification threshold of 80
    public struct Notification {
        /// The comparison that's used for this notification.
        /// This member is required.
        public var comparisonOperator: BudgetsClientTypes.ComparisonOperator?
        /// Specifies whether this notification is in alarm. If a budget notification is in the ALARM state, you passed the set threshold for the budget.
        public var notificationState: BudgetsClientTypes.NotificationState?
        /// Specifies whether the notification is for how much you have spent (ACTUAL) or for how much that you're forecasted to spend (FORECASTED).
        /// This member is required.
        public var notificationType: BudgetsClientTypes.NotificationType?
        /// The threshold that's associated with a notification. Thresholds are always a percentage, and many customers find value being alerted between 50% - 200% of the budgeted amount. The maximum limit for your threshold is 1,000,000% above the budgeted amount.
        /// This member is required.
        public var threshold: Swift.Double
        /// The type of threshold for a notification. For ABSOLUTE_VALUE thresholds, Amazon Web Services notifies you when you go over or are forecasted to go over your total cost threshold. For PERCENTAGE thresholds, Amazon Web Services notifies you when you go over or are forecasted to go over a certain percentage of your forecasted spend. For example, if you have a budget for 200 dollars and you have a PERCENTAGE threshold of 80%, Amazon Web Services notifies you when you go over 160 dollars.
        public var thresholdType: BudgetsClientTypes.ThresholdType?

        public init(
            comparisonOperator: BudgetsClientTypes.ComparisonOperator? = nil,
            notificationState: BudgetsClientTypes.NotificationState? = nil,
            notificationType: BudgetsClientTypes.NotificationType? = nil,
            threshold: Swift.Double = 0.0,
            thresholdType: BudgetsClientTypes.ThresholdType? = nil
        )
        {
            self.comparisonOperator = comparisonOperator
            self.notificationState = notificationState
            self.notificationType = notificationType
            self.threshold = threshold
            self.thresholdType = thresholdType
        }
    }

}

extension BudgetsClientTypes {
    /// A notification with subscribers. A notification can have one SNS subscriber and up to 10 email subscribers, for a total of 11 subscribers.
    public struct NotificationWithSubscribers {
        /// The notification that's associated with a budget.
        /// This member is required.
        public var notification: BudgetsClientTypes.Notification?
        /// A list of subscribers who are subscribed to this notification.
        /// This member is required.
        public var subscribers: [BudgetsClientTypes.Subscriber]?

        public init(
            notification: BudgetsClientTypes.Notification? = nil,
            subscribers: [BudgetsClientTypes.Subscriber]? = nil
        )
        {
            self.notification = notification
            self.subscribers = subscribers
        }
    }

}

extension BudgetsClientTypes {
    /// The tag structure that contains a tag key and value.
    public struct ResourceTag {
        /// The key that's associated with the tag.
        /// This member is required.
        public var key: Swift.String?
        /// The value that's associated with the tag.
        /// This member is required.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

/// Request of CreateBudget
public struct CreateBudgetInput {
    /// The accountId that is associated with the budget.
    /// This member is required.
    public var accountId: Swift.String?
    /// The budget object that you want to create.
    /// This member is required.
    public var budget: BudgetsClientTypes.Budget?
    /// A notification that you want to associate with a budget. A budget can have up to five notifications, and each notification can have one SNS subscriber and up to 10 email subscribers. If you include notifications and subscribers in your CreateBudget call, Amazon Web Services creates the notifications and subscribers for you.
    public var notificationsWithSubscribers: [BudgetsClientTypes.NotificationWithSubscribers]?
    /// An optional list of tags to associate with the specified budget. Each tag consists of a key and a value, and each key must be unique for the resource.
    public var resourceTags: [BudgetsClientTypes.ResourceTag]?

    public init(
        accountId: Swift.String? = nil,
        budget: BudgetsClientTypes.Budget? = nil,
        notificationsWithSubscribers: [BudgetsClientTypes.NotificationWithSubscribers]? = nil,
        resourceTags: [BudgetsClientTypes.ResourceTag]? = nil
    )
    {
        self.accountId = accountId
        self.budget = budget
        self.notificationsWithSubscribers = notificationsWithSubscribers
        self.resourceTags = resourceTags
    }
}

/// Response of CreateBudget
public struct CreateBudgetOutput {

    public init() { }
}

/// We can’t locate the resource that you specified.
public struct NotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The error message the exception carries.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct CreateBudgetActionInput {
    /// The account ID of the user. It's a 12-digit number.
    /// This member is required.
    public var accountId: Swift.String?
    /// The trigger threshold of the action.
    /// This member is required.
    public var actionThreshold: BudgetsClientTypes.ActionThreshold?
    /// The type of action. This defines the type of tasks that can be carried out by this action. This field also determines the format for definition.
    /// This member is required.
    public var actionType: BudgetsClientTypes.ActionType?
    /// This specifies if the action needs manual or automatic approval.
    /// This member is required.
    public var approvalModel: BudgetsClientTypes.ApprovalModel?
    /// A string that represents the budget name. The ":" and "\" characters, and the "/action/" substring, aren't allowed.
    /// This member is required.
    public var budgetName: Swift.String?
    /// Specifies all of the type-specific parameters.
    /// This member is required.
    public var definition: BudgetsClientTypes.Definition?
    /// The role passed for action execution and reversion. Roles and actions must be in the same account.
    /// This member is required.
    public var executionRoleArn: Swift.String?
    /// The type of a notification. It must be ACTUAL or FORECASTED.
    /// This member is required.
    public var notificationType: BudgetsClientTypes.NotificationType?
    /// An optional list of tags to associate with the specified budget action. Each tag consists of a key and a value, and each key must be unique for the resource.
    public var resourceTags: [BudgetsClientTypes.ResourceTag]?
    /// A list of subscribers.
    /// This member is required.
    public var subscribers: [BudgetsClientTypes.Subscriber]?

    public init(
        accountId: Swift.String? = nil,
        actionThreshold: BudgetsClientTypes.ActionThreshold? = nil,
        actionType: BudgetsClientTypes.ActionType? = nil,
        approvalModel: BudgetsClientTypes.ApprovalModel? = nil,
        budgetName: Swift.String? = nil,
        definition: BudgetsClientTypes.Definition? = nil,
        executionRoleArn: Swift.String? = nil,
        notificationType: BudgetsClientTypes.NotificationType? = nil,
        resourceTags: [BudgetsClientTypes.ResourceTag]? = nil,
        subscribers: [BudgetsClientTypes.Subscriber]? = nil
    )
    {
        self.accountId = accountId
        self.actionThreshold = actionThreshold
        self.actionType = actionType
        self.approvalModel = approvalModel
        self.budgetName = budgetName
        self.definition = definition
        self.executionRoleArn = executionRoleArn
        self.notificationType = notificationType
        self.resourceTags = resourceTags
        self.subscribers = subscribers
    }
}

public struct CreateBudgetActionOutput {
    /// The account ID of the user. It's a 12-digit number.
    /// This member is required.
    public var accountId: Swift.String?
    /// A system-generated universally unique identifier (UUID) for the action.
    /// This member is required.
    public var actionId: Swift.String?
    /// A string that represents the budget name. The ":" and "\" characters, and the "/action/" substring, aren't allowed.
    /// This member is required.
    public var budgetName: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        actionId: Swift.String? = nil,
        budgetName: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.actionId = actionId
        self.budgetName = budgetName
    }
}

/// Request of CreateNotification
public struct CreateNotificationInput {
    /// The accountId that is associated with the budget that you want to create a notification for.
    /// This member is required.
    public var accountId: Swift.String?
    /// The name of the budget that you want Amazon Web Services to notify you about. Budget names must be unique within an account.
    /// This member is required.
    public var budgetName: Swift.String?
    /// The notification that you want to create.
    /// This member is required.
    public var notification: BudgetsClientTypes.Notification?
    /// A list of subscribers that you want to associate with the notification. Each notification can have one SNS subscriber and up to 10 email subscribers.
    /// This member is required.
    public var subscribers: [BudgetsClientTypes.Subscriber]?

    public init(
        accountId: Swift.String? = nil,
        budgetName: Swift.String? = nil,
        notification: BudgetsClientTypes.Notification? = nil,
        subscribers: [BudgetsClientTypes.Subscriber]? = nil
    )
    {
        self.accountId = accountId
        self.budgetName = budgetName
        self.notification = notification
        self.subscribers = subscribers
    }
}

/// Response of CreateNotification
public struct CreateNotificationOutput {

    public init() { }
}

/// Request of CreateSubscriber
public struct CreateSubscriberInput {
    /// The accountId that is associated with the budget that you want to create a subscriber for.
    /// This member is required.
    public var accountId: Swift.String?
    /// The name of the budget that you want to subscribe to. Budget names must be unique within an account.
    /// This member is required.
    public var budgetName: Swift.String?
    /// The notification that you want to create a subscriber for.
    /// This member is required.
    public var notification: BudgetsClientTypes.Notification?
    /// The subscriber that you want to associate with a budget notification.
    /// This member is required.
    public var subscriber: BudgetsClientTypes.Subscriber?

    public init(
        accountId: Swift.String? = nil,
        budgetName: Swift.String? = nil,
        notification: BudgetsClientTypes.Notification? = nil,
        subscriber: BudgetsClientTypes.Subscriber? = nil
    )
    {
        self.accountId = accountId
        self.budgetName = budgetName
        self.notification = notification
        self.subscriber = subscriber
    }
}

/// Response of CreateSubscriber
public struct CreateSubscriberOutput {

    public init() { }
}

/// Request of DeleteBudget
public struct DeleteBudgetInput {
    /// The accountId that is associated with the budget that you want to delete.
    /// This member is required.
    public var accountId: Swift.String?
    /// The name of the budget that you want to delete.
    /// This member is required.
    public var budgetName: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        budgetName: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.budgetName = budgetName
    }
}

/// Response of DeleteBudget
public struct DeleteBudgetOutput {

    public init() { }
}

/// The request was received and recognized by the server, but the server rejected that particular method for the requested resource.
public struct ResourceLockedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The error message the exception carries.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceLockedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct DeleteBudgetActionInput {
    /// The account ID of the user. It's a 12-digit number.
    /// This member is required.
    public var accountId: Swift.String?
    /// A system-generated universally unique identifier (UUID) for the action.
    /// This member is required.
    public var actionId: Swift.String?
    /// A string that represents the budget name. The ":" and "\" characters, and the "/action/" substring, aren't allowed.
    /// This member is required.
    public var budgetName: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        actionId: Swift.String? = nil,
        budgetName: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.actionId = actionId
        self.budgetName = budgetName
    }
}

public struct DeleteBudgetActionOutput {
    /// The account ID of the user. It's a 12-digit number.
    /// This member is required.
    public var accountId: Swift.String?
    /// A budget action resource.
    /// This member is required.
    public var action: BudgetsClientTypes.Action?
    /// A string that represents the budget name. The ":" and "\" characters, and the "/action/" substring, aren't allowed.
    /// This member is required.
    public var budgetName: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        action: BudgetsClientTypes.Action? = nil,
        budgetName: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.action = action
        self.budgetName = budgetName
    }
}

/// Request of DeleteNotification
public struct DeleteNotificationInput {
    /// The accountId that is associated with the budget whose notification you want to delete.
    /// This member is required.
    public var accountId: Swift.String?
    /// The name of the budget whose notification you want to delete.
    /// This member is required.
    public var budgetName: Swift.String?
    /// The notification that you want to delete.
    /// This member is required.
    public var notification: BudgetsClientTypes.Notification?

    public init(
        accountId: Swift.String? = nil,
        budgetName: Swift.String? = nil,
        notification: BudgetsClientTypes.Notification? = nil
    )
    {
        self.accountId = accountId
        self.budgetName = budgetName
        self.notification = notification
    }
}

/// Response of DeleteNotification
public struct DeleteNotificationOutput {

    public init() { }
}

/// Request of DeleteSubscriber
public struct DeleteSubscriberInput {
    /// The accountId that is associated with the budget whose subscriber you want to delete.
    /// This member is required.
    public var accountId: Swift.String?
    /// The name of the budget whose subscriber you want to delete.
    /// This member is required.
    public var budgetName: Swift.String?
    /// The notification whose subscriber you want to delete.
    /// This member is required.
    public var notification: BudgetsClientTypes.Notification?
    /// The subscriber that you want to delete.
    /// This member is required.
    public var subscriber: BudgetsClientTypes.Subscriber?

    public init(
        accountId: Swift.String? = nil,
        budgetName: Swift.String? = nil,
        notification: BudgetsClientTypes.Notification? = nil,
        subscriber: BudgetsClientTypes.Subscriber? = nil
    )
    {
        self.accountId = accountId
        self.budgetName = budgetName
        self.notification = notification
        self.subscriber = subscriber
    }
}

/// Response of DeleteSubscriber
public struct DeleteSubscriberOutput {

    public init() { }
}

/// Request of DescribeBudget
public struct DescribeBudgetInput {
    /// The accountId that is associated with the budget that you want a description of.
    /// This member is required.
    public var accountId: Swift.String?
    /// The name of the budget that you want a description of.
    /// This member is required.
    public var budgetName: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        budgetName: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.budgetName = budgetName
    }
}

/// Response of DescribeBudget
public struct DescribeBudgetOutput {
    /// The description of the budget.
    public var budget: BudgetsClientTypes.Budget?

    public init(
        budget: BudgetsClientTypes.Budget? = nil
    )
    {
        self.budget = budget
    }
}

public struct DescribeBudgetActionInput {
    /// The account ID of the user. It's a 12-digit number.
    /// This member is required.
    public var accountId: Swift.String?
    /// A system-generated universally unique identifier (UUID) for the action.
    /// This member is required.
    public var actionId: Swift.String?
    /// A string that represents the budget name. The ":" and "\" characters, and the "/action/" substring, aren't allowed.
    /// This member is required.
    public var budgetName: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        actionId: Swift.String? = nil,
        budgetName: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.actionId = actionId
        self.budgetName = budgetName
    }
}

public struct DescribeBudgetActionOutput {
    /// The account ID of the user. It's a 12-digit number.
    /// This member is required.
    public var accountId: Swift.String?
    /// A budget action resource.
    /// This member is required.
    public var action: BudgetsClientTypes.Action?
    /// A string that represents the budget name. The ":" and "\" characters, and the "/action/" substring, aren't allowed.
    /// This member is required.
    public var budgetName: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        action: BudgetsClientTypes.Action? = nil,
        budgetName: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.action = action
        self.budgetName = budgetName
    }
}

/// The pagination token is invalid.
public struct InvalidNextTokenException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The error message the exception carries.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidNextTokenException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct DescribeBudgetActionHistoriesInput {
    /// The account ID of the user. It's a 12-digit number.
    /// This member is required.
    public var accountId: Swift.String?
    /// A system-generated universally unique identifier (UUID) for the action.
    /// This member is required.
    public var actionId: Swift.String?
    /// A string that represents the budget name. The ":" and "\" characters, and the "/action/" substring, aren't allowed.
    /// This member is required.
    public var budgetName: Swift.String?
    /// An integer that represents how many entries a paginated response contains. The maximum is 100.
    public var maxResults: Swift.Int?
    /// A generic string.
    public var nextToken: Swift.String?
    /// The period of time that's covered by a budget. The period has a start date and an end date. The start date must come before the end date. There are no restrictions on the end date.
    public var timePeriod: BudgetsClientTypes.TimePeriod?

    public init(
        accountId: Swift.String? = nil,
        actionId: Swift.String? = nil,
        budgetName: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        timePeriod: BudgetsClientTypes.TimePeriod? = nil
    )
    {
        self.accountId = accountId
        self.actionId = actionId
        self.budgetName = budgetName
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.timePeriod = timePeriod
    }
}

public struct DescribeBudgetActionHistoriesOutput {
    /// The historical record of the budget action resource.
    /// This member is required.
    public var actionHistories: [BudgetsClientTypes.ActionHistory]?
    /// A generic string.
    public var nextToken: Swift.String?

    public init(
        actionHistories: [BudgetsClientTypes.ActionHistory]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.actionHistories = actionHistories
        self.nextToken = nextToken
    }
}

public struct DescribeBudgetActionsForAccountInput {
    /// The account ID of the user. It's a 12-digit number.
    /// This member is required.
    public var accountId: Swift.String?
    /// An integer that represents how many entries a paginated response contains. The maximum is 100.
    public var maxResults: Swift.Int?
    /// A generic string.
    public var nextToken: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct DescribeBudgetActionsForAccountOutput {
    /// A list of the budget action resources information.
    /// This member is required.
    public var actions: [BudgetsClientTypes.Action]?
    /// A generic string.
    public var nextToken: Swift.String?

    public init(
        actions: [BudgetsClientTypes.Action]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.actions = actions
        self.nextToken = nextToken
    }
}

public struct DescribeBudgetActionsForBudgetInput {
    /// The account ID of the user. It's a 12-digit number.
    /// This member is required.
    public var accountId: Swift.String?
    /// A string that represents the budget name. The ":" and "\" characters, and the "/action/" substring, aren't allowed.
    /// This member is required.
    public var budgetName: Swift.String?
    /// An integer that represents how many entries a paginated response contains. The maximum is 100.
    public var maxResults: Swift.Int?
    /// A generic string.
    public var nextToken: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        budgetName: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.budgetName = budgetName
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct DescribeBudgetActionsForBudgetOutput {
    /// A list of the budget action resources information.
    /// This member is required.
    public var actions: [BudgetsClientTypes.Action]?
    /// A generic string.
    public var nextToken: Swift.String?

    public init(
        actions: [BudgetsClientTypes.Action]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.actions = actions
        self.nextToken = nextToken
    }
}

/// The pagination token expired.
public struct ExpiredNextTokenException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The error message the exception carries.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ExpiredNextTokenException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public struct DescribeBudgetNotificationsForAccountInput {
    /// The account ID of the user. It's a 12-digit number.
    /// This member is required.
    public var accountId: Swift.String?
    /// An integer that represents how many budgets a paginated response contains. The default is 50.
    public var maxResults: Swift.Int?
    /// A generic string.
    public var nextToken: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension BudgetsClientTypes {
    /// The budget name and associated notifications for an account.
    public struct BudgetNotificationsForAccount {
        /// A string that represents the budget name. The ":" and "\" characters, and the "/action/" substring, aren't allowed.
        public var budgetName: Swift.String?
        /// A list of notifications.
        public var notifications: [BudgetsClientTypes.Notification]?

        public init(
            budgetName: Swift.String? = nil,
            notifications: [BudgetsClientTypes.Notification]? = nil
        )
        {
            self.budgetName = budgetName
            self.notifications = notifications
        }
    }

}

public struct DescribeBudgetNotificationsForAccountOutput {
    /// A list of budget names and associated notifications for an account.
    public var budgetNotificationsForAccount: [BudgetsClientTypes.BudgetNotificationsForAccount]?
    /// A generic string.
    public var nextToken: Swift.String?

    public init(
        budgetNotificationsForAccount: [BudgetsClientTypes.BudgetNotificationsForAccount]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.budgetNotificationsForAccount = budgetNotificationsForAccount
        self.nextToken = nextToken
    }
}

public struct DescribeBudgetPerformanceHistoryInput {
    /// The account ID of the user. It's a 12-digit number.
    /// This member is required.
    public var accountId: Swift.String?
    /// A string that represents the budget name. The ":" and "\" characters, and the "/action/" substring, aren't allowed.
    /// This member is required.
    public var budgetName: Swift.String?
    /// An integer that represents how many entries a paginated response contains. The maximum is 100.
    public var maxResults: Swift.Int?
    /// A generic string.
    public var nextToken: Swift.String?
    /// Retrieves how often the budget went into an ALARM state for the specified time period.
    public var timePeriod: BudgetsClientTypes.TimePeriod?

    public init(
        accountId: Swift.String? = nil,
        budgetName: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        timePeriod: BudgetsClientTypes.TimePeriod? = nil
    )
    {
        self.accountId = accountId
        self.budgetName = budgetName
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.timePeriod = timePeriod
    }
}

extension BudgetsClientTypes {
    /// The amount of cost or usage that you created the budget for, compared to your actual costs or usage.
    public struct BudgetedAndActualAmounts {
        /// Your actual costs or usage for a budget period.
        public var actualAmount: BudgetsClientTypes.Spend?
        /// The amount of cost or usage that you created the budget for.
        public var budgetedAmount: BudgetsClientTypes.Spend?
        /// The time period that's covered by this budget comparison.
        public var timePeriod: BudgetsClientTypes.TimePeriod?

        public init(
            actualAmount: BudgetsClientTypes.Spend? = nil,
            budgetedAmount: BudgetsClientTypes.Spend? = nil,
            timePeriod: BudgetsClientTypes.TimePeriod? = nil
        )
        {
            self.actualAmount = actualAmount
            self.budgetedAmount = budgetedAmount
            self.timePeriod = timePeriod
        }
    }

}

extension BudgetsClientTypes {
    /// A history of the state of a budget at the end of the budget's specified time period.
    public struct BudgetPerformanceHistory {
        /// A string that represents the budget name. The ":" and "\" characters, and the "/action/" substring, aren't allowed.
        public var budgetName: Swift.String?
        /// The type of a budget. It must be one of the following types: COST, USAGE, RI_UTILIZATION, RI_COVERAGE, SAVINGS_PLANS_UTILIZATION, or SAVINGS_PLANS_COVERAGE.
        public var budgetType: BudgetsClientTypes.BudgetType?
        /// A list of amounts of cost or usage that you created budgets for, which are compared to your actual costs or usage.
        public var budgetedAndActualAmountsList: [BudgetsClientTypes.BudgetedAndActualAmounts]?
        /// The history of the cost filters for a budget during the specified time period.
        public var costFilters: [Swift.String: [Swift.String]]?
        /// The history of the cost types for a budget during the specified time period.
        public var costTypes: BudgetsClientTypes.CostTypes?
        /// The time unit of the budget, such as MONTHLY or QUARTERLY.
        public var timeUnit: BudgetsClientTypes.TimeUnit?

        public init(
            budgetName: Swift.String? = nil,
            budgetType: BudgetsClientTypes.BudgetType? = nil,
            budgetedAndActualAmountsList: [BudgetsClientTypes.BudgetedAndActualAmounts]? = nil,
            costFilters: [Swift.String: [Swift.String]]? = nil,
            costTypes: BudgetsClientTypes.CostTypes? = nil,
            timeUnit: BudgetsClientTypes.TimeUnit? = nil
        )
        {
            self.budgetName = budgetName
            self.budgetType = budgetType
            self.budgetedAndActualAmountsList = budgetedAndActualAmountsList
            self.costFilters = costFilters
            self.costTypes = costTypes
            self.timeUnit = timeUnit
        }
    }

}

public struct DescribeBudgetPerformanceHistoryOutput {
    /// The history of how often the budget has gone into an ALARM state. For DAILY budgets, the history saves the state of the budget for the last 60 days. For MONTHLY budgets, the history saves the state of the budget for the current month plus the last 12 months. For QUARTERLY budgets, the history saves the state of the budget for the last four quarters.
    public var budgetPerformanceHistory: BudgetsClientTypes.BudgetPerformanceHistory?
    /// A generic string.
    public var nextToken: Swift.String?

    public init(
        budgetPerformanceHistory: BudgetsClientTypes.BudgetPerformanceHistory? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.budgetPerformanceHistory = budgetPerformanceHistory
        self.nextToken = nextToken
    }
}

/// Request of DescribeBudgets
public struct DescribeBudgetsInput {
    /// The accountId that is associated with the budgets that you want to describe.
    /// This member is required.
    public var accountId: Swift.String?
    /// An integer that represents how many budgets a paginated response contains. The default is 100.
    public var maxResults: Swift.Int?
    /// The pagination token that you include in your request to indicate the next set of results that you want to retrieve.
    public var nextToken: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

/// Response of DescribeBudgets
public struct DescribeBudgetsOutput {
    /// A list of budgets.
    public var budgets: [BudgetsClientTypes.Budget]?
    /// The pagination token in the service response that indicates the next set of results that you can retrieve.
    public var nextToken: Swift.String?

    public init(
        budgets: [BudgetsClientTypes.Budget]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.budgets = budgets
        self.nextToken = nextToken
    }
}

/// Request of DescribeNotificationsForBudget
public struct DescribeNotificationsForBudgetInput {
    /// The accountId that is associated with the budget whose notifications you want descriptions of.
    /// This member is required.
    public var accountId: Swift.String?
    /// The name of the budget whose notifications you want descriptions of.
    /// This member is required.
    public var budgetName: Swift.String?
    /// An optional integer that represents how many entries a paginated response contains.
    public var maxResults: Swift.Int?
    /// The pagination token that you include in your request to indicate the next set of results that you want to retrieve.
    public var nextToken: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        budgetName: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.budgetName = budgetName
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

/// Response of GetNotificationsForBudget
public struct DescribeNotificationsForBudgetOutput {
    /// The pagination token in the service response that indicates the next set of results that you can retrieve.
    public var nextToken: Swift.String?
    /// A list of notifications that are associated with a budget.
    public var notifications: [BudgetsClientTypes.Notification]?

    public init(
        nextToken: Swift.String? = nil,
        notifications: [BudgetsClientTypes.Notification]? = nil
    )
    {
        self.nextToken = nextToken
        self.notifications = notifications
    }
}

/// Request of DescribeSubscribersForNotification
public struct DescribeSubscribersForNotificationInput {
    /// The accountId that is associated with the budget whose subscribers you want descriptions of.
    /// This member is required.
    public var accountId: Swift.String?
    /// The name of the budget whose subscribers you want descriptions of.
    /// This member is required.
    public var budgetName: Swift.String?
    /// An optional integer that represents how many entries a paginated response contains.
    public var maxResults: Swift.Int?
    /// The pagination token that you include in your request to indicate the next set of results that you want to retrieve.
    public var nextToken: Swift.String?
    /// The notification whose subscribers you want to list.
    /// This member is required.
    public var notification: BudgetsClientTypes.Notification?

    public init(
        accountId: Swift.String? = nil,
        budgetName: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        notification: BudgetsClientTypes.Notification? = nil
    )
    {
        self.accountId = accountId
        self.budgetName = budgetName
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.notification = notification
    }
}

/// Response of DescribeSubscribersForNotification
public struct DescribeSubscribersForNotificationOutput {
    /// The pagination token in the service response that indicates the next set of results that you can retrieve.
    public var nextToken: Swift.String?
    /// A list of subscribers that are associated with a notification.
    public var subscribers: [BudgetsClientTypes.Subscriber]?

    public init(
        nextToken: Swift.String? = nil,
        subscribers: [BudgetsClientTypes.Subscriber]? = nil
    )
    {
        self.nextToken = nextToken
        self.subscribers = subscribers
    }
}

extension BudgetsClientTypes {

    public enum ExecutionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case approvebudgetaction
        case resetbudgetaction
        case retrybudgetaction
        case reversebudgetaction
        case sdkUnknown(Swift.String)

        public static var allCases: [ExecutionType] {
            return [
                .approvebudgetaction,
                .resetbudgetaction,
                .retrybudgetaction,
                .reversebudgetaction
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .approvebudgetaction: return "APPROVE_BUDGET_ACTION"
            case .resetbudgetaction: return "RESET_BUDGET_ACTION"
            case .retrybudgetaction: return "RETRY_BUDGET_ACTION"
            case .reversebudgetaction: return "REVERSE_BUDGET_ACTION"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct ExecuteBudgetActionInput {
    /// The account ID of the user. It's a 12-digit number.
    /// This member is required.
    public var accountId: Swift.String?
    /// A system-generated universally unique identifier (UUID) for the action.
    /// This member is required.
    public var actionId: Swift.String?
    /// A string that represents the budget name. The ":" and "\" characters, and the "/action/" substring, aren't allowed.
    /// This member is required.
    public var budgetName: Swift.String?
    /// The type of execution.
    /// This member is required.
    public var executionType: BudgetsClientTypes.ExecutionType?

    public init(
        accountId: Swift.String? = nil,
        actionId: Swift.String? = nil,
        budgetName: Swift.String? = nil,
        executionType: BudgetsClientTypes.ExecutionType? = nil
    )
    {
        self.accountId = accountId
        self.actionId = actionId
        self.budgetName = budgetName
        self.executionType = executionType
    }
}

public struct ExecuteBudgetActionOutput {
    /// The account ID of the user. It's a 12-digit number.
    /// This member is required.
    public var accountId: Swift.String?
    /// A system-generated universally unique identifier (UUID) for the action.
    /// This member is required.
    public var actionId: Swift.String?
    /// A string that represents the budget name. The ":" and "\" characters, and the "/action/" substring, aren't allowed.
    /// This member is required.
    public var budgetName: Swift.String?
    /// The type of execution.
    /// This member is required.
    public var executionType: BudgetsClientTypes.ExecutionType?

    public init(
        accountId: Swift.String? = nil,
        actionId: Swift.String? = nil,
        budgetName: Swift.String? = nil,
        executionType: BudgetsClientTypes.ExecutionType? = nil
    )
    {
        self.accountId = accountId
        self.actionId = actionId
        self.budgetName = budgetName
        self.executionType = executionType
    }
}

public struct ListTagsForResourceInput {
    /// The unique identifier for the resource.
    /// This member is required.
    public var resourceARN: Swift.String?

    public init(
        resourceARN: Swift.String? = nil
    )
    {
        self.resourceARN = resourceARN
    }
}

public struct ListTagsForResourceOutput {
    /// The tags associated with the resource.
    public var resourceTags: [BudgetsClientTypes.ResourceTag]?

    public init(
        resourceTags: [BudgetsClientTypes.ResourceTag]? = nil
    )
    {
        self.resourceTags = resourceTags
    }
}

public struct TagResourceInput {
    /// The unique identifier for the resource.
    /// This member is required.
    public var resourceARN: Swift.String?
    /// The tags associated with the resource.
    /// This member is required.
    public var resourceTags: [BudgetsClientTypes.ResourceTag]?

    public init(
        resourceARN: Swift.String? = nil,
        resourceTags: [BudgetsClientTypes.ResourceTag]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.resourceTags = resourceTags
    }
}

public struct TagResourceOutput {

    public init() { }
}

public struct UntagResourceInput {
    /// The unique identifier for the resource.
    /// This member is required.
    public var resourceARN: Swift.String?
    /// The key that's associated with the tag.
    /// This member is required.
    public var resourceTagKeys: [Swift.String]?

    public init(
        resourceARN: Swift.String? = nil,
        resourceTagKeys: [Swift.String]? = nil
    )
    {
        self.resourceARN = resourceARN
        self.resourceTagKeys = resourceTagKeys
    }
}

public struct UntagResourceOutput {

    public init() { }
}

/// Request of UpdateBudget
public struct UpdateBudgetInput {
    /// The accountId that is associated with the budget that you want to update.
    /// This member is required.
    public var accountId: Swift.String?
    /// The budget that you want to update your budget to.
    /// This member is required.
    public var newBudget: BudgetsClientTypes.Budget?

    public init(
        accountId: Swift.String? = nil,
        newBudget: BudgetsClientTypes.Budget? = nil
    )
    {
        self.accountId = accountId
        self.newBudget = newBudget
    }
}

/// Response of UpdateBudget
public struct UpdateBudgetOutput {

    public init() { }
}

public struct UpdateBudgetActionInput {
    /// The account ID of the user. It's a 12-digit number.
    /// This member is required.
    public var accountId: Swift.String?
    /// A system-generated universally unique identifier (UUID) for the action.
    /// This member is required.
    public var actionId: Swift.String?
    /// The trigger threshold of the action.
    public var actionThreshold: BudgetsClientTypes.ActionThreshold?
    /// This specifies if the action needs manual or automatic approval.
    public var approvalModel: BudgetsClientTypes.ApprovalModel?
    /// A string that represents the budget name. The ":" and "\" characters, and the "/action/" substring, aren't allowed.
    /// This member is required.
    public var budgetName: Swift.String?
    /// Specifies all of the type-specific parameters.
    public var definition: BudgetsClientTypes.Definition?
    /// The role passed for action execution and reversion. Roles and actions must be in the same account.
    public var executionRoleArn: Swift.String?
    /// The type of a notification. It must be ACTUAL or FORECASTED.
    public var notificationType: BudgetsClientTypes.NotificationType?
    /// A list of subscribers.
    public var subscribers: [BudgetsClientTypes.Subscriber]?

    public init(
        accountId: Swift.String? = nil,
        actionId: Swift.String? = nil,
        actionThreshold: BudgetsClientTypes.ActionThreshold? = nil,
        approvalModel: BudgetsClientTypes.ApprovalModel? = nil,
        budgetName: Swift.String? = nil,
        definition: BudgetsClientTypes.Definition? = nil,
        executionRoleArn: Swift.String? = nil,
        notificationType: BudgetsClientTypes.NotificationType? = nil,
        subscribers: [BudgetsClientTypes.Subscriber]? = nil
    )
    {
        self.accountId = accountId
        self.actionId = actionId
        self.actionThreshold = actionThreshold
        self.approvalModel = approvalModel
        self.budgetName = budgetName
        self.definition = definition
        self.executionRoleArn = executionRoleArn
        self.notificationType = notificationType
        self.subscribers = subscribers
    }
}

public struct UpdateBudgetActionOutput {
    /// The account ID of the user. It's a 12-digit number.
    /// This member is required.
    public var accountId: Swift.String?
    /// A string that represents the budget name. The ":" and "\" characters, and the "/action/" substring, aren't allowed.
    /// This member is required.
    public var budgetName: Swift.String?
    /// The updated action resource information.
    /// This member is required.
    public var newAction: BudgetsClientTypes.Action?
    /// The previous action resource information.
    /// This member is required.
    public var oldAction: BudgetsClientTypes.Action?

    public init(
        accountId: Swift.String? = nil,
        budgetName: Swift.String? = nil,
        newAction: BudgetsClientTypes.Action? = nil,
        oldAction: BudgetsClientTypes.Action? = nil
    )
    {
        self.accountId = accountId
        self.budgetName = budgetName
        self.newAction = newAction
        self.oldAction = oldAction
    }
}

/// Request of UpdateNotification
public struct UpdateNotificationInput {
    /// The accountId that is associated with the budget whose notification you want to update.
    /// This member is required.
    public var accountId: Swift.String?
    /// The name of the budget whose notification you want to update.
    /// This member is required.
    public var budgetName: Swift.String?
    /// The updated notification to be associated with a budget.
    /// This member is required.
    public var newNotification: BudgetsClientTypes.Notification?
    /// The previous notification that is associated with a budget.
    /// This member is required.
    public var oldNotification: BudgetsClientTypes.Notification?

    public init(
        accountId: Swift.String? = nil,
        budgetName: Swift.String? = nil,
        newNotification: BudgetsClientTypes.Notification? = nil,
        oldNotification: BudgetsClientTypes.Notification? = nil
    )
    {
        self.accountId = accountId
        self.budgetName = budgetName
        self.newNotification = newNotification
        self.oldNotification = oldNotification
    }
}

/// Response of UpdateNotification
public struct UpdateNotificationOutput {

    public init() { }
}

/// Request of UpdateSubscriber
public struct UpdateSubscriberInput {
    /// The accountId that is associated with the budget whose subscriber you want to update.
    /// This member is required.
    public var accountId: Swift.String?
    /// The name of the budget whose subscriber you want to update.
    /// This member is required.
    public var budgetName: Swift.String?
    /// The updated subscriber that is associated with a budget notification.
    /// This member is required.
    public var newSubscriber: BudgetsClientTypes.Subscriber?
    /// The notification whose subscriber you want to update.
    /// This member is required.
    public var notification: BudgetsClientTypes.Notification?
    /// The previous subscriber that is associated with a budget notification.
    /// This member is required.
    public var oldSubscriber: BudgetsClientTypes.Subscriber?

    public init(
        accountId: Swift.String? = nil,
        budgetName: Swift.String? = nil,
        newSubscriber: BudgetsClientTypes.Subscriber? = nil,
        notification: BudgetsClientTypes.Notification? = nil,
        oldSubscriber: BudgetsClientTypes.Subscriber? = nil
    )
    {
        self.accountId = accountId
        self.budgetName = budgetName
        self.newSubscriber = newSubscriber
        self.notification = notification
        self.oldSubscriber = oldSubscriber
    }
}

/// Response of UpdateSubscriber
public struct UpdateSubscriberOutput {

    public init() { }
}

extension CreateBudgetInput {

    static func urlPathProvider(_ value: CreateBudgetInput) -> Swift.String? {
        return "/"
    }
}

extension CreateBudgetActionInput {

    static func urlPathProvider(_ value: CreateBudgetActionInput) -> Swift.String? {
        return "/"
    }
}

extension CreateNotificationInput {

    static func urlPathProvider(_ value: CreateNotificationInput) -> Swift.String? {
        return "/"
    }
}

extension CreateSubscriberInput {

    static func urlPathProvider(_ value: CreateSubscriberInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteBudgetInput {

    static func urlPathProvider(_ value: DeleteBudgetInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteBudgetActionInput {

    static func urlPathProvider(_ value: DeleteBudgetActionInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteNotificationInput {

    static func urlPathProvider(_ value: DeleteNotificationInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteSubscriberInput {

    static func urlPathProvider(_ value: DeleteSubscriberInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeBudgetInput {

    static func urlPathProvider(_ value: DescribeBudgetInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeBudgetActionInput {

    static func urlPathProvider(_ value: DescribeBudgetActionInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeBudgetActionHistoriesInput {

    static func urlPathProvider(_ value: DescribeBudgetActionHistoriesInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeBudgetActionsForAccountInput {

    static func urlPathProvider(_ value: DescribeBudgetActionsForAccountInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeBudgetActionsForBudgetInput {

    static func urlPathProvider(_ value: DescribeBudgetActionsForBudgetInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeBudgetNotificationsForAccountInput {

    static func urlPathProvider(_ value: DescribeBudgetNotificationsForAccountInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeBudgetPerformanceHistoryInput {

    static func urlPathProvider(_ value: DescribeBudgetPerformanceHistoryInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeBudgetsInput {

    static func urlPathProvider(_ value: DescribeBudgetsInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeNotificationsForBudgetInput {

    static func urlPathProvider(_ value: DescribeNotificationsForBudgetInput) -> Swift.String? {
        return "/"
    }
}

extension DescribeSubscribersForNotificationInput {

    static func urlPathProvider(_ value: DescribeSubscribersForNotificationInput) -> Swift.String? {
        return "/"
    }
}

extension ExecuteBudgetActionInput {

    static func urlPathProvider(_ value: ExecuteBudgetActionInput) -> Swift.String? {
        return "/"
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        return "/"
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        return "/"
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateBudgetInput {

    static func urlPathProvider(_ value: UpdateBudgetInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateBudgetActionInput {

    static func urlPathProvider(_ value: UpdateBudgetActionInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateNotificationInput {

    static func urlPathProvider(_ value: UpdateNotificationInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateSubscriberInput {

    static func urlPathProvider(_ value: UpdateSubscriberInput) -> Swift.String? {
        return "/"
    }
}

extension CreateBudgetInput {

    static func write(value: CreateBudgetInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AccountId"].write(value.accountId)
        try writer["Budget"].write(value.budget, with: BudgetsClientTypes.Budget.write(value:to:))
        try writer["NotificationsWithSubscribers"].writeList(value.notificationsWithSubscribers, memberWritingClosure: BudgetsClientTypes.NotificationWithSubscribers.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ResourceTags"].writeList(value.resourceTags, memberWritingClosure: BudgetsClientTypes.ResourceTag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateBudgetActionInput {

    static func write(value: CreateBudgetActionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AccountId"].write(value.accountId)
        try writer["ActionThreshold"].write(value.actionThreshold, with: BudgetsClientTypes.ActionThreshold.write(value:to:))
        try writer["ActionType"].write(value.actionType)
        try writer["ApprovalModel"].write(value.approvalModel)
        try writer["BudgetName"].write(value.budgetName)
        try writer["Definition"].write(value.definition, with: BudgetsClientTypes.Definition.write(value:to:))
        try writer["ExecutionRoleArn"].write(value.executionRoleArn)
        try writer["NotificationType"].write(value.notificationType)
        try writer["ResourceTags"].writeList(value.resourceTags, memberWritingClosure: BudgetsClientTypes.ResourceTag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Subscribers"].writeList(value.subscribers, memberWritingClosure: BudgetsClientTypes.Subscriber.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateNotificationInput {

    static func write(value: CreateNotificationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AccountId"].write(value.accountId)
        try writer["BudgetName"].write(value.budgetName)
        try writer["Notification"].write(value.notification, with: BudgetsClientTypes.Notification.write(value:to:))
        try writer["Subscribers"].writeList(value.subscribers, memberWritingClosure: BudgetsClientTypes.Subscriber.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateSubscriberInput {

    static func write(value: CreateSubscriberInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AccountId"].write(value.accountId)
        try writer["BudgetName"].write(value.budgetName)
        try writer["Notification"].write(value.notification, with: BudgetsClientTypes.Notification.write(value:to:))
        try writer["Subscriber"].write(value.subscriber, with: BudgetsClientTypes.Subscriber.write(value:to:))
    }
}

extension DeleteBudgetInput {

    static func write(value: DeleteBudgetInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AccountId"].write(value.accountId)
        try writer["BudgetName"].write(value.budgetName)
    }
}

extension DeleteBudgetActionInput {

    static func write(value: DeleteBudgetActionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AccountId"].write(value.accountId)
        try writer["ActionId"].write(value.actionId)
        try writer["BudgetName"].write(value.budgetName)
    }
}

extension DeleteNotificationInput {

    static func write(value: DeleteNotificationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AccountId"].write(value.accountId)
        try writer["BudgetName"].write(value.budgetName)
        try writer["Notification"].write(value.notification, with: BudgetsClientTypes.Notification.write(value:to:))
    }
}

extension DeleteSubscriberInput {

    static func write(value: DeleteSubscriberInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AccountId"].write(value.accountId)
        try writer["BudgetName"].write(value.budgetName)
        try writer["Notification"].write(value.notification, with: BudgetsClientTypes.Notification.write(value:to:))
        try writer["Subscriber"].write(value.subscriber, with: BudgetsClientTypes.Subscriber.write(value:to:))
    }
}

extension DescribeBudgetInput {

    static func write(value: DescribeBudgetInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AccountId"].write(value.accountId)
        try writer["BudgetName"].write(value.budgetName)
    }
}

extension DescribeBudgetActionInput {

    static func write(value: DescribeBudgetActionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AccountId"].write(value.accountId)
        try writer["ActionId"].write(value.actionId)
        try writer["BudgetName"].write(value.budgetName)
    }
}

extension DescribeBudgetActionHistoriesInput {

    static func write(value: DescribeBudgetActionHistoriesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AccountId"].write(value.accountId)
        try writer["ActionId"].write(value.actionId)
        try writer["BudgetName"].write(value.budgetName)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["TimePeriod"].write(value.timePeriod, with: BudgetsClientTypes.TimePeriod.write(value:to:))
    }
}

extension DescribeBudgetActionsForAccountInput {

    static func write(value: DescribeBudgetActionsForAccountInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AccountId"].write(value.accountId)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension DescribeBudgetActionsForBudgetInput {

    static func write(value: DescribeBudgetActionsForBudgetInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AccountId"].write(value.accountId)
        try writer["BudgetName"].write(value.budgetName)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension DescribeBudgetNotificationsForAccountInput {

    static func write(value: DescribeBudgetNotificationsForAccountInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AccountId"].write(value.accountId)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension DescribeBudgetPerformanceHistoryInput {

    static func write(value: DescribeBudgetPerformanceHistoryInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AccountId"].write(value.accountId)
        try writer["BudgetName"].write(value.budgetName)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["TimePeriod"].write(value.timePeriod, with: BudgetsClientTypes.TimePeriod.write(value:to:))
    }
}

extension DescribeBudgetsInput {

    static func write(value: DescribeBudgetsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AccountId"].write(value.accountId)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension DescribeNotificationsForBudgetInput {

    static func write(value: DescribeNotificationsForBudgetInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AccountId"].write(value.accountId)
        try writer["BudgetName"].write(value.budgetName)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension DescribeSubscribersForNotificationInput {

    static func write(value: DescribeSubscribersForNotificationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AccountId"].write(value.accountId)
        try writer["BudgetName"].write(value.budgetName)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["Notification"].write(value.notification, with: BudgetsClientTypes.Notification.write(value:to:))
    }
}

extension ExecuteBudgetActionInput {

    static func write(value: ExecuteBudgetActionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AccountId"].write(value.accountId)
        try writer["ActionId"].write(value.actionId)
        try writer["BudgetName"].write(value.budgetName)
        try writer["ExecutionType"].write(value.executionType)
    }
}

extension ListTagsForResourceInput {

    static func write(value: ListTagsForResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceARN"].write(value.resourceARN)
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceARN"].write(value.resourceARN)
        try writer["ResourceTags"].writeList(value.resourceTags, memberWritingClosure: BudgetsClientTypes.ResourceTag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UntagResourceInput {

    static func write(value: UntagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceARN"].write(value.resourceARN)
        try writer["ResourceTagKeys"].writeList(value.resourceTagKeys, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdateBudgetInput {

    static func write(value: UpdateBudgetInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AccountId"].write(value.accountId)
        try writer["NewBudget"].write(value.newBudget, with: BudgetsClientTypes.Budget.write(value:to:))
    }
}

extension UpdateBudgetActionInput {

    static func write(value: UpdateBudgetActionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AccountId"].write(value.accountId)
        try writer["ActionId"].write(value.actionId)
        try writer["ActionThreshold"].write(value.actionThreshold, with: BudgetsClientTypes.ActionThreshold.write(value:to:))
        try writer["ApprovalModel"].write(value.approvalModel)
        try writer["BudgetName"].write(value.budgetName)
        try writer["Definition"].write(value.definition, with: BudgetsClientTypes.Definition.write(value:to:))
        try writer["ExecutionRoleArn"].write(value.executionRoleArn)
        try writer["NotificationType"].write(value.notificationType)
        try writer["Subscribers"].writeList(value.subscribers, memberWritingClosure: BudgetsClientTypes.Subscriber.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdateNotificationInput {

    static func write(value: UpdateNotificationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AccountId"].write(value.accountId)
        try writer["BudgetName"].write(value.budgetName)
        try writer["NewNotification"].write(value.newNotification, with: BudgetsClientTypes.Notification.write(value:to:))
        try writer["OldNotification"].write(value.oldNotification, with: BudgetsClientTypes.Notification.write(value:to:))
    }
}

extension UpdateSubscriberInput {

    static func write(value: UpdateSubscriberInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AccountId"].write(value.accountId)
        try writer["BudgetName"].write(value.budgetName)
        try writer["NewSubscriber"].write(value.newSubscriber, with: BudgetsClientTypes.Subscriber.write(value:to:))
        try writer["Notification"].write(value.notification, with: BudgetsClientTypes.Notification.write(value:to:))
        try writer["OldSubscriber"].write(value.oldSubscriber, with: BudgetsClientTypes.Subscriber.write(value:to:))
    }
}

extension CreateBudgetOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateBudgetOutput {
        return CreateBudgetOutput()
    }
}

extension CreateBudgetActionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateBudgetActionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateBudgetActionOutput()
        value.accountId = try reader["AccountId"].readIfPresent() ?? ""
        value.actionId = try reader["ActionId"].readIfPresent() ?? ""
        value.budgetName = try reader["BudgetName"].readIfPresent() ?? ""
        return value
    }
}

extension CreateNotificationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateNotificationOutput {
        return CreateNotificationOutput()
    }
}

extension CreateSubscriberOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateSubscriberOutput {
        return CreateSubscriberOutput()
    }
}

extension DeleteBudgetOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteBudgetOutput {
        return DeleteBudgetOutput()
    }
}

extension DeleteBudgetActionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteBudgetActionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteBudgetActionOutput()
        value.accountId = try reader["AccountId"].readIfPresent() ?? ""
        value.action = try reader["Action"].readIfPresent(with: BudgetsClientTypes.Action.read(from:))
        value.budgetName = try reader["BudgetName"].readIfPresent() ?? ""
        return value
    }
}

extension DeleteNotificationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteNotificationOutput {
        return DeleteNotificationOutput()
    }
}

extension DeleteSubscriberOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteSubscriberOutput {
        return DeleteSubscriberOutput()
    }
}

extension DescribeBudgetOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeBudgetOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeBudgetOutput()
        value.budget = try reader["Budget"].readIfPresent(with: BudgetsClientTypes.Budget.read(from:))
        return value
    }
}

extension DescribeBudgetActionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeBudgetActionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeBudgetActionOutput()
        value.accountId = try reader["AccountId"].readIfPresent() ?? ""
        value.action = try reader["Action"].readIfPresent(with: BudgetsClientTypes.Action.read(from:))
        value.budgetName = try reader["BudgetName"].readIfPresent() ?? ""
        return value
    }
}

extension DescribeBudgetActionHistoriesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeBudgetActionHistoriesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeBudgetActionHistoriesOutput()
        value.actionHistories = try reader["ActionHistories"].readListIfPresent(memberReadingClosure: BudgetsClientTypes.ActionHistory.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension DescribeBudgetActionsForAccountOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeBudgetActionsForAccountOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeBudgetActionsForAccountOutput()
        value.actions = try reader["Actions"].readListIfPresent(memberReadingClosure: BudgetsClientTypes.Action.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension DescribeBudgetActionsForBudgetOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeBudgetActionsForBudgetOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeBudgetActionsForBudgetOutput()
        value.actions = try reader["Actions"].readListIfPresent(memberReadingClosure: BudgetsClientTypes.Action.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension DescribeBudgetNotificationsForAccountOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeBudgetNotificationsForAccountOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeBudgetNotificationsForAccountOutput()
        value.budgetNotificationsForAccount = try reader["BudgetNotificationsForAccount"].readListIfPresent(memberReadingClosure: BudgetsClientTypes.BudgetNotificationsForAccount.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension DescribeBudgetPerformanceHistoryOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeBudgetPerformanceHistoryOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeBudgetPerformanceHistoryOutput()
        value.budgetPerformanceHistory = try reader["BudgetPerformanceHistory"].readIfPresent(with: BudgetsClientTypes.BudgetPerformanceHistory.read(from:))
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension DescribeBudgetsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeBudgetsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeBudgetsOutput()
        value.budgets = try reader["Budgets"].readListIfPresent(memberReadingClosure: BudgetsClientTypes.Budget.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension DescribeNotificationsForBudgetOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeNotificationsForBudgetOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeNotificationsForBudgetOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.notifications = try reader["Notifications"].readListIfPresent(memberReadingClosure: BudgetsClientTypes.Notification.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension DescribeSubscribersForNotificationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DescribeSubscribersForNotificationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DescribeSubscribersForNotificationOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.subscribers = try reader["Subscribers"].readListIfPresent(memberReadingClosure: BudgetsClientTypes.Subscriber.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ExecuteBudgetActionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ExecuteBudgetActionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ExecuteBudgetActionOutput()
        value.accountId = try reader["AccountId"].readIfPresent() ?? ""
        value.actionId = try reader["ActionId"].readIfPresent() ?? ""
        value.budgetName = try reader["BudgetName"].readIfPresent() ?? ""
        value.executionType = try reader["ExecutionType"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.resourceTags = try reader["ResourceTags"].readListIfPresent(memberReadingClosure: BudgetsClientTypes.ResourceTag.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

extension UpdateBudgetOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateBudgetOutput {
        return UpdateBudgetOutput()
    }
}

extension UpdateBudgetActionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateBudgetActionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateBudgetActionOutput()
        value.accountId = try reader["AccountId"].readIfPresent() ?? ""
        value.budgetName = try reader["BudgetName"].readIfPresent() ?? ""
        value.newAction = try reader["NewAction"].readIfPresent(with: BudgetsClientTypes.Action.read(from:))
        value.oldAction = try reader["OldAction"].readIfPresent(with: BudgetsClientTypes.Action.read(from:))
        return value
    }
}

extension UpdateNotificationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateNotificationOutput {
        return UpdateNotificationOutput()
    }
}

extension UpdateSubscriberOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateSubscriberOutput {
        return UpdateSubscriberOutput()
    }
}

enum CreateBudgetOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "CreationLimitExceededException": return try CreationLimitExceededException.makeError(baseError: baseError)
            case "DuplicateRecordException": return try DuplicateRecordException.makeError(baseError: baseError)
            case "InternalErrorException": return try InternalErrorException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateBudgetActionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "CreationLimitExceededException": return try CreationLimitExceededException.makeError(baseError: baseError)
            case "DuplicateRecordException": return try DuplicateRecordException.makeError(baseError: baseError)
            case "InternalErrorException": return try InternalErrorException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateNotificationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "CreationLimitExceededException": return try CreationLimitExceededException.makeError(baseError: baseError)
            case "DuplicateRecordException": return try DuplicateRecordException.makeError(baseError: baseError)
            case "InternalErrorException": return try InternalErrorException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateSubscriberOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "CreationLimitExceededException": return try CreationLimitExceededException.makeError(baseError: baseError)
            case "DuplicateRecordException": return try DuplicateRecordException.makeError(baseError: baseError)
            case "InternalErrorException": return try InternalErrorException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteBudgetOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalErrorException": return try InternalErrorException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteBudgetActionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalErrorException": return try InternalErrorException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ResourceLockedException": return try ResourceLockedException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteNotificationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalErrorException": return try InternalErrorException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteSubscriberOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalErrorException": return try InternalErrorException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeBudgetOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalErrorException": return try InternalErrorException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeBudgetActionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalErrorException": return try InternalErrorException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeBudgetActionHistoriesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalErrorException": return try InternalErrorException.makeError(baseError: baseError)
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeBudgetActionsForAccountOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalErrorException": return try InternalErrorException.makeError(baseError: baseError)
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeBudgetActionsForBudgetOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalErrorException": return try InternalErrorException.makeError(baseError: baseError)
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeBudgetNotificationsForAccountOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ExpiredNextTokenException": return try ExpiredNextTokenException.makeError(baseError: baseError)
            case "InternalErrorException": return try InternalErrorException.makeError(baseError: baseError)
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeBudgetPerformanceHistoryOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ExpiredNextTokenException": return try ExpiredNextTokenException.makeError(baseError: baseError)
            case "InternalErrorException": return try InternalErrorException.makeError(baseError: baseError)
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeBudgetsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ExpiredNextTokenException": return try ExpiredNextTokenException.makeError(baseError: baseError)
            case "InternalErrorException": return try InternalErrorException.makeError(baseError: baseError)
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeNotificationsForBudgetOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ExpiredNextTokenException": return try ExpiredNextTokenException.makeError(baseError: baseError)
            case "InternalErrorException": return try InternalErrorException.makeError(baseError: baseError)
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DescribeSubscribersForNotificationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ExpiredNextTokenException": return try ExpiredNextTokenException.makeError(baseError: baseError)
            case "InternalErrorException": return try InternalErrorException.makeError(baseError: baseError)
            case "InvalidNextTokenException": return try InvalidNextTokenException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ExecuteBudgetActionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalErrorException": return try InternalErrorException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ResourceLockedException": return try ResourceLockedException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalErrorException": return try InternalErrorException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalErrorException": return try InternalErrorException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalErrorException": return try InternalErrorException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateBudgetOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalErrorException": return try InternalErrorException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateBudgetActionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalErrorException": return try InternalErrorException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ResourceLockedException": return try ResourceLockedException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateNotificationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "DuplicateRecordException": return try DuplicateRecordException.makeError(baseError: baseError)
            case "InternalErrorException": return try InternalErrorException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateSubscriberOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "DuplicateRecordException": return try DuplicateRecordException.makeError(baseError: baseError)
            case "InternalErrorException": return try InternalErrorException.makeError(baseError: baseError)
            case "InvalidParameterException": return try InvalidParameterException.makeError(baseError: baseError)
            case "NotFoundException": return try NotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ServiceQuotaExceededException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ServiceQuotaExceededException {
        let reader = baseError.errorBodyReader
        var value = ServiceQuotaExceededException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidParameterException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidParameterException {
        let reader = baseError.errorBodyReader
        var value = InvalidParameterException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension AccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> AccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = AccessDeniedException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InternalErrorException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InternalErrorException {
        let reader = baseError.errorBodyReader
        var value = InternalErrorException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ThrottlingException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ThrottlingException {
        let reader = baseError.errorBodyReader
        var value = ThrottlingException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension CreationLimitExceededException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> CreationLimitExceededException {
        let reader = baseError.errorBodyReader
        var value = CreationLimitExceededException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension DuplicateRecordException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> DuplicateRecordException {
        let reader = baseError.errorBodyReader
        var value = DuplicateRecordException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension NotFoundException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> NotFoundException {
        let reader = baseError.errorBodyReader
        var value = NotFoundException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceLockedException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ResourceLockedException {
        let reader = baseError.errorBodyReader
        var value = ResourceLockedException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InvalidNextTokenException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InvalidNextTokenException {
        let reader = baseError.errorBodyReader
        var value = InvalidNextTokenException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ExpiredNextTokenException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ExpiredNextTokenException {
        let reader = baseError.errorBodyReader
        var value = ExpiredNextTokenException()
        value.properties.message = try reader["Message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension BudgetsClientTypes.Action {

    static func read(from reader: SmithyJSON.Reader) throws -> BudgetsClientTypes.Action {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BudgetsClientTypes.Action()
        value.actionId = try reader["ActionId"].readIfPresent() ?? ""
        value.budgetName = try reader["BudgetName"].readIfPresent() ?? ""
        value.notificationType = try reader["NotificationType"].readIfPresent() ?? .sdkUnknown("")
        value.actionType = try reader["ActionType"].readIfPresent() ?? .sdkUnknown("")
        value.actionThreshold = try reader["ActionThreshold"].readIfPresent(with: BudgetsClientTypes.ActionThreshold.read(from:))
        value.definition = try reader["Definition"].readIfPresent(with: BudgetsClientTypes.Definition.read(from:))
        value.executionRoleArn = try reader["ExecutionRoleArn"].readIfPresent() ?? ""
        value.approvalModel = try reader["ApprovalModel"].readIfPresent() ?? .sdkUnknown("")
        value.status = try reader["Status"].readIfPresent() ?? .sdkUnknown("")
        value.subscribers = try reader["Subscribers"].readListIfPresent(memberReadingClosure: BudgetsClientTypes.Subscriber.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension BudgetsClientTypes.Subscriber {

    static func write(value: BudgetsClientTypes.Subscriber?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Address"].write(value.address)
        try writer["SubscriptionType"].write(value.subscriptionType)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BudgetsClientTypes.Subscriber {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BudgetsClientTypes.Subscriber()
        value.subscriptionType = try reader["SubscriptionType"].readIfPresent() ?? .sdkUnknown("")
        value.address = try reader["Address"].readIfPresent() ?? ""
        return value
    }
}

extension BudgetsClientTypes.Definition {

    static func write(value: BudgetsClientTypes.Definition?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["IamActionDefinition"].write(value.iamActionDefinition, with: BudgetsClientTypes.IamActionDefinition.write(value:to:))
        try writer["ScpActionDefinition"].write(value.scpActionDefinition, with: BudgetsClientTypes.ScpActionDefinition.write(value:to:))
        try writer["SsmActionDefinition"].write(value.ssmActionDefinition, with: BudgetsClientTypes.SsmActionDefinition.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BudgetsClientTypes.Definition {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BudgetsClientTypes.Definition()
        value.iamActionDefinition = try reader["IamActionDefinition"].readIfPresent(with: BudgetsClientTypes.IamActionDefinition.read(from:))
        value.scpActionDefinition = try reader["ScpActionDefinition"].readIfPresent(with: BudgetsClientTypes.ScpActionDefinition.read(from:))
        value.ssmActionDefinition = try reader["SsmActionDefinition"].readIfPresent(with: BudgetsClientTypes.SsmActionDefinition.read(from:))
        return value
    }
}

extension BudgetsClientTypes.SsmActionDefinition {

    static func write(value: BudgetsClientTypes.SsmActionDefinition?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ActionSubType"].write(value.actionSubType)
        try writer["InstanceIds"].writeList(value.instanceIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Region"].write(value.region)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BudgetsClientTypes.SsmActionDefinition {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BudgetsClientTypes.SsmActionDefinition()
        value.actionSubType = try reader["ActionSubType"].readIfPresent() ?? .sdkUnknown("")
        value.region = try reader["Region"].readIfPresent() ?? ""
        value.instanceIds = try reader["InstanceIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension BudgetsClientTypes.ScpActionDefinition {

    static func write(value: BudgetsClientTypes.ScpActionDefinition?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["PolicyId"].write(value.policyId)
        try writer["TargetIds"].writeList(value.targetIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BudgetsClientTypes.ScpActionDefinition {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BudgetsClientTypes.ScpActionDefinition()
        value.policyId = try reader["PolicyId"].readIfPresent() ?? ""
        value.targetIds = try reader["TargetIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension BudgetsClientTypes.IamActionDefinition {

    static func write(value: BudgetsClientTypes.IamActionDefinition?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Groups"].writeList(value.groups, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["PolicyArn"].write(value.policyArn)
        try writer["Roles"].writeList(value.roles, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Users"].writeList(value.users, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BudgetsClientTypes.IamActionDefinition {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BudgetsClientTypes.IamActionDefinition()
        value.policyArn = try reader["PolicyArn"].readIfPresent() ?? ""
        value.roles = try reader["Roles"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.groups = try reader["Groups"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.users = try reader["Users"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BudgetsClientTypes.ActionThreshold {

    static func write(value: BudgetsClientTypes.ActionThreshold?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ActionThresholdType"].write(value.actionThresholdType)
        try writer["ActionThresholdValue"].write(value.actionThresholdValue)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BudgetsClientTypes.ActionThreshold {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BudgetsClientTypes.ActionThreshold()
        value.actionThresholdValue = try reader["ActionThresholdValue"].readIfPresent() ?? 0
        value.actionThresholdType = try reader["ActionThresholdType"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension BudgetsClientTypes.Budget {

    static func write(value: BudgetsClientTypes.Budget?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AutoAdjustData"].write(value.autoAdjustData, with: BudgetsClientTypes.AutoAdjustData.write(value:to:))
        try writer["BudgetLimit"].write(value.budgetLimit, with: BudgetsClientTypes.Spend.write(value:to:))
        try writer["BudgetName"].write(value.budgetName)
        try writer["BudgetType"].write(value.budgetType)
        try writer["CalculatedSpend"].write(value.calculatedSpend, with: BudgetsClientTypes.CalculatedSpend.write(value:to:))
        try writer["CostFilters"].writeMap(value.costFilters, valueWritingClosure: SmithyReadWrite.listWritingClosure(memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["CostTypes"].write(value.costTypes, with: BudgetsClientTypes.CostTypes.write(value:to:))
        try writer["LastUpdatedTime"].writeTimestamp(value.lastUpdatedTime, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["PlannedBudgetLimits"].writeMap(value.plannedBudgetLimits, valueWritingClosure: BudgetsClientTypes.Spend.write(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["TimePeriod"].write(value.timePeriod, with: BudgetsClientTypes.TimePeriod.write(value:to:))
        try writer["TimeUnit"].write(value.timeUnit)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BudgetsClientTypes.Budget {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BudgetsClientTypes.Budget()
        value.budgetName = try reader["BudgetName"].readIfPresent() ?? ""
        value.budgetLimit = try reader["BudgetLimit"].readIfPresent(with: BudgetsClientTypes.Spend.read(from:))
        value.plannedBudgetLimits = try reader["PlannedBudgetLimits"].readMapIfPresent(valueReadingClosure: BudgetsClientTypes.Spend.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.costFilters = try reader["CostFilters"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.listReadingClosure(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.costTypes = try reader["CostTypes"].readIfPresent(with: BudgetsClientTypes.CostTypes.read(from:))
        value.timeUnit = try reader["TimeUnit"].readIfPresent() ?? .sdkUnknown("")
        value.timePeriod = try reader["TimePeriod"].readIfPresent(with: BudgetsClientTypes.TimePeriod.read(from:))
        value.calculatedSpend = try reader["CalculatedSpend"].readIfPresent(with: BudgetsClientTypes.CalculatedSpend.read(from:))
        value.budgetType = try reader["BudgetType"].readIfPresent() ?? .sdkUnknown("")
        value.lastUpdatedTime = try reader["LastUpdatedTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.autoAdjustData = try reader["AutoAdjustData"].readIfPresent(with: BudgetsClientTypes.AutoAdjustData.read(from:))
        return value
    }
}

extension BudgetsClientTypes.AutoAdjustData {

    static func write(value: BudgetsClientTypes.AutoAdjustData?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AutoAdjustType"].write(value.autoAdjustType)
        try writer["HistoricalOptions"].write(value.historicalOptions, with: BudgetsClientTypes.HistoricalOptions.write(value:to:))
        try writer["LastAutoAdjustTime"].writeTimestamp(value.lastAutoAdjustTime, format: SmithyTimestamps.TimestampFormat.epochSeconds)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BudgetsClientTypes.AutoAdjustData {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BudgetsClientTypes.AutoAdjustData()
        value.autoAdjustType = try reader["AutoAdjustType"].readIfPresent() ?? .sdkUnknown("")
        value.historicalOptions = try reader["HistoricalOptions"].readIfPresent(with: BudgetsClientTypes.HistoricalOptions.read(from:))
        value.lastAutoAdjustTime = try reader["LastAutoAdjustTime"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension BudgetsClientTypes.HistoricalOptions {

    static func write(value: BudgetsClientTypes.HistoricalOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BudgetAdjustmentPeriod"].write(value.budgetAdjustmentPeriod)
        try writer["LookBackAvailablePeriods"].write(value.lookBackAvailablePeriods)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BudgetsClientTypes.HistoricalOptions {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BudgetsClientTypes.HistoricalOptions()
        value.budgetAdjustmentPeriod = try reader["BudgetAdjustmentPeriod"].readIfPresent() ?? 0
        value.lookBackAvailablePeriods = try reader["LookBackAvailablePeriods"].readIfPresent()
        return value
    }
}

extension BudgetsClientTypes.CalculatedSpend {

    static func write(value: BudgetsClientTypes.CalculatedSpend?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ActualSpend"].write(value.actualSpend, with: BudgetsClientTypes.Spend.write(value:to:))
        try writer["ForecastedSpend"].write(value.forecastedSpend, with: BudgetsClientTypes.Spend.write(value:to:))
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BudgetsClientTypes.CalculatedSpend {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BudgetsClientTypes.CalculatedSpend()
        value.actualSpend = try reader["ActualSpend"].readIfPresent(with: BudgetsClientTypes.Spend.read(from:))
        value.forecastedSpend = try reader["ForecastedSpend"].readIfPresent(with: BudgetsClientTypes.Spend.read(from:))
        return value
    }
}

extension BudgetsClientTypes.Spend {

    static func write(value: BudgetsClientTypes.Spend?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Amount"].write(value.amount)
        try writer["Unit"].write(value.unit)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BudgetsClientTypes.Spend {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BudgetsClientTypes.Spend()
        value.amount = try reader["Amount"].readIfPresent() ?? ""
        value.unit = try reader["Unit"].readIfPresent() ?? ""
        return value
    }
}

extension BudgetsClientTypes.TimePeriod {

    static func write(value: BudgetsClientTypes.TimePeriod?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["End"].writeTimestamp(value.end, format: SmithyTimestamps.TimestampFormat.epochSeconds)
        try writer["Start"].writeTimestamp(value.start, format: SmithyTimestamps.TimestampFormat.epochSeconds)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BudgetsClientTypes.TimePeriod {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BudgetsClientTypes.TimePeriod()
        value.start = try reader["Start"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.end = try reader["End"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension BudgetsClientTypes.CostTypes {

    static func write(value: BudgetsClientTypes.CostTypes?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["IncludeCredit"].write(value.includeCredit)
        try writer["IncludeDiscount"].write(value.includeDiscount)
        try writer["IncludeOtherSubscription"].write(value.includeOtherSubscription)
        try writer["IncludeRecurring"].write(value.includeRecurring)
        try writer["IncludeRefund"].write(value.includeRefund)
        try writer["IncludeSubscription"].write(value.includeSubscription)
        try writer["IncludeSupport"].write(value.includeSupport)
        try writer["IncludeTax"].write(value.includeTax)
        try writer["IncludeUpfront"].write(value.includeUpfront)
        try writer["UseAmortized"].write(value.useAmortized)
        try writer["UseBlended"].write(value.useBlended)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BudgetsClientTypes.CostTypes {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BudgetsClientTypes.CostTypes()
        value.includeTax = try reader["IncludeTax"].readIfPresent()
        value.includeSubscription = try reader["IncludeSubscription"].readIfPresent()
        value.useBlended = try reader["UseBlended"].readIfPresent()
        value.includeRefund = try reader["IncludeRefund"].readIfPresent()
        value.includeCredit = try reader["IncludeCredit"].readIfPresent()
        value.includeUpfront = try reader["IncludeUpfront"].readIfPresent()
        value.includeRecurring = try reader["IncludeRecurring"].readIfPresent()
        value.includeOtherSubscription = try reader["IncludeOtherSubscription"].readIfPresent()
        value.includeSupport = try reader["IncludeSupport"].readIfPresent()
        value.includeDiscount = try reader["IncludeDiscount"].readIfPresent()
        value.useAmortized = try reader["UseAmortized"].readIfPresent()
        return value
    }
}

extension BudgetsClientTypes.ActionHistory {

    static func read(from reader: SmithyJSON.Reader) throws -> BudgetsClientTypes.ActionHistory {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BudgetsClientTypes.ActionHistory()
        value.timestamp = try reader["Timestamp"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.status = try reader["Status"].readIfPresent() ?? .sdkUnknown("")
        value.eventType = try reader["EventType"].readIfPresent() ?? .sdkUnknown("")
        value.actionHistoryDetails = try reader["ActionHistoryDetails"].readIfPresent(with: BudgetsClientTypes.ActionHistoryDetails.read(from:))
        return value
    }
}

extension BudgetsClientTypes.ActionHistoryDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> BudgetsClientTypes.ActionHistoryDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BudgetsClientTypes.ActionHistoryDetails()
        value.message = try reader["Message"].readIfPresent() ?? ""
        value.action = try reader["Action"].readIfPresent(with: BudgetsClientTypes.Action.read(from:))
        return value
    }
}

extension BudgetsClientTypes.BudgetNotificationsForAccount {

    static func read(from reader: SmithyJSON.Reader) throws -> BudgetsClientTypes.BudgetNotificationsForAccount {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BudgetsClientTypes.BudgetNotificationsForAccount()
        value.notifications = try reader["Notifications"].readListIfPresent(memberReadingClosure: BudgetsClientTypes.Notification.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.budgetName = try reader["BudgetName"].readIfPresent()
        return value
    }
}

extension BudgetsClientTypes.Notification {

    static func write(value: BudgetsClientTypes.Notification?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ComparisonOperator"].write(value.comparisonOperator)
        try writer["NotificationState"].write(value.notificationState)
        try writer["NotificationType"].write(value.notificationType)
        try writer["Threshold"].write(value.threshold)
        try writer["ThresholdType"].write(value.thresholdType)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BudgetsClientTypes.Notification {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BudgetsClientTypes.Notification()
        value.notificationType = try reader["NotificationType"].readIfPresent() ?? .sdkUnknown("")
        value.comparisonOperator = try reader["ComparisonOperator"].readIfPresent() ?? .sdkUnknown("")
        value.threshold = try reader["Threshold"].readIfPresent() ?? 0
        value.thresholdType = try reader["ThresholdType"].readIfPresent()
        value.notificationState = try reader["NotificationState"].readIfPresent()
        return value
    }
}

extension BudgetsClientTypes.BudgetPerformanceHistory {

    static func read(from reader: SmithyJSON.Reader) throws -> BudgetsClientTypes.BudgetPerformanceHistory {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BudgetsClientTypes.BudgetPerformanceHistory()
        value.budgetName = try reader["BudgetName"].readIfPresent()
        value.budgetType = try reader["BudgetType"].readIfPresent()
        value.costFilters = try reader["CostFilters"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.listReadingClosure(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.costTypes = try reader["CostTypes"].readIfPresent(with: BudgetsClientTypes.CostTypes.read(from:))
        value.timeUnit = try reader["TimeUnit"].readIfPresent()
        value.budgetedAndActualAmountsList = try reader["BudgetedAndActualAmountsList"].readListIfPresent(memberReadingClosure: BudgetsClientTypes.BudgetedAndActualAmounts.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension BudgetsClientTypes.BudgetedAndActualAmounts {

    static func read(from reader: SmithyJSON.Reader) throws -> BudgetsClientTypes.BudgetedAndActualAmounts {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BudgetsClientTypes.BudgetedAndActualAmounts()
        value.budgetedAmount = try reader["BudgetedAmount"].readIfPresent(with: BudgetsClientTypes.Spend.read(from:))
        value.actualAmount = try reader["ActualAmount"].readIfPresent(with: BudgetsClientTypes.Spend.read(from:))
        value.timePeriod = try reader["TimePeriod"].readIfPresent(with: BudgetsClientTypes.TimePeriod.read(from:))
        return value
    }
}

extension BudgetsClientTypes.ResourceTag {

    static func write(value: BudgetsClientTypes.ResourceTag?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Key"].write(value.key)
        try writer["Value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> BudgetsClientTypes.ResourceTag {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = BudgetsClientTypes.ResourceTag()
        value.key = try reader["Key"].readIfPresent() ?? ""
        value.value = try reader["Value"].readIfPresent() ?? ""
        return value
    }
}

extension BudgetsClientTypes.NotificationWithSubscribers {

    static func write(value: BudgetsClientTypes.NotificationWithSubscribers?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Notification"].write(value.notification, with: BudgetsClientTypes.Notification.write(value:to:))
        try writer["Subscribers"].writeList(value.subscribers, memberWritingClosure: BudgetsClientTypes.Subscriber.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

public enum BudgetsClientTypes {}
