// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You are not authorized to use this operation with the given parameters.
public struct AccessDeniedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The error message the exception carries.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension BudgetsClientTypes.Action: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actionId = "ActionId"
        case actionThreshold = "ActionThreshold"
        case actionType = "ActionType"
        case approvalModel = "ApprovalModel"
        case budgetName = "BudgetName"
        case definition = "Definition"
        case executionRoleArn = "ExecutionRoleArn"
        case notificationType = "NotificationType"
        case status = "Status"
        case subscribers = "Subscribers"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actionId = self.actionId {
            try encodeContainer.encode(actionId, forKey: .actionId)
        }
        if let actionThreshold = self.actionThreshold {
            try encodeContainer.encode(actionThreshold, forKey: .actionThreshold)
        }
        if let actionType = self.actionType {
            try encodeContainer.encode(actionType.rawValue, forKey: .actionType)
        }
        if let approvalModel = self.approvalModel {
            try encodeContainer.encode(approvalModel.rawValue, forKey: .approvalModel)
        }
        if let budgetName = self.budgetName {
            try encodeContainer.encode(budgetName, forKey: .budgetName)
        }
        if let definition = self.definition {
            try encodeContainer.encode(definition, forKey: .definition)
        }
        if let executionRoleArn = self.executionRoleArn {
            try encodeContainer.encode(executionRoleArn, forKey: .executionRoleArn)
        }
        if let notificationType = self.notificationType {
            try encodeContainer.encode(notificationType.rawValue, forKey: .notificationType)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let subscribers = subscribers {
            var subscribersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subscribers)
            for subscriber0 in subscribers {
                try subscribersContainer.encode(subscriber0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .actionId)
        actionId = actionIdDecoded
        let budgetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .budgetName)
        budgetName = budgetNameDecoded
        let notificationTypeDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.NotificationType.self, forKey: .notificationType)
        notificationType = notificationTypeDecoded
        let actionTypeDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.ActionType.self, forKey: .actionType)
        actionType = actionTypeDecoded
        let actionThresholdDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.ActionThreshold.self, forKey: .actionThreshold)
        actionThreshold = actionThresholdDecoded
        let definitionDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.Definition.self, forKey: .definition)
        definition = definitionDecoded
        let executionRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .executionRoleArn)
        executionRoleArn = executionRoleArnDecoded
        let approvalModelDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.ApprovalModel.self, forKey: .approvalModel)
        approvalModel = approvalModelDecoded
        let statusDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.ActionStatus.self, forKey: .status)
        status = statusDecoded
        let subscribersContainer = try containerValues.decodeIfPresent([BudgetsClientTypes.Subscriber?].self, forKey: .subscribers)
        var subscribersDecoded0:[BudgetsClientTypes.Subscriber]? = nil
        if let subscribersContainer = subscribersContainer {
            subscribersDecoded0 = [BudgetsClientTypes.Subscriber]()
            for structure0 in subscribersContainer {
                if let structure0 = structure0 {
                    subscribersDecoded0?.append(structure0)
                }
            }
        }
        subscribers = subscribersDecoded0
    }
}

extension BudgetsClientTypes {
    /// A budget action resource.
    public struct Action: Swift.Equatable {
        /// A system-generated universally unique identifier (UUID) for the action.
        /// This member is required.
        public var actionId: Swift.String?
        /// The trigger threshold of the action.
        /// This member is required.
        public var actionThreshold: BudgetsClientTypes.ActionThreshold?
        /// The type of action. This defines the type of tasks that can be carried out by this action. This field also determines the format for definition.
        /// This member is required.
        public var actionType: BudgetsClientTypes.ActionType?
        /// This specifies if the action needs manual or automatic approval.
        /// This member is required.
        public var approvalModel: BudgetsClientTypes.ApprovalModel?
        /// A string that represents the budget name. The ":" and "\" characters aren't allowed.
        /// This member is required.
        public var budgetName: Swift.String?
        /// Where you specify all of the type-specific parameters.
        /// This member is required.
        public var definition: BudgetsClientTypes.Definition?
        /// The role passed for action execution and reversion. Roles and actions must be in the same account.
        /// This member is required.
        public var executionRoleArn: Swift.String?
        /// The type of a notification. It must be ACTUAL or FORECASTED.
        /// This member is required.
        public var notificationType: BudgetsClientTypes.NotificationType?
        /// The status of the action.
        /// This member is required.
        public var status: BudgetsClientTypes.ActionStatus?
        /// A list of subscribers.
        /// This member is required.
        public var subscribers: [BudgetsClientTypes.Subscriber]?

        public init (
            actionId: Swift.String? = nil,
            actionThreshold: BudgetsClientTypes.ActionThreshold? = nil,
            actionType: BudgetsClientTypes.ActionType? = nil,
            approvalModel: BudgetsClientTypes.ApprovalModel? = nil,
            budgetName: Swift.String? = nil,
            definition: BudgetsClientTypes.Definition? = nil,
            executionRoleArn: Swift.String? = nil,
            notificationType: BudgetsClientTypes.NotificationType? = nil,
            status: BudgetsClientTypes.ActionStatus? = nil,
            subscribers: [BudgetsClientTypes.Subscriber]? = nil
        )
        {
            self.actionId = actionId
            self.actionThreshold = actionThreshold
            self.actionType = actionType
            self.approvalModel = approvalModel
            self.budgetName = budgetName
            self.definition = definition
            self.executionRoleArn = executionRoleArn
            self.notificationType = notificationType
            self.status = status
            self.subscribers = subscribers
        }
    }

}

extension BudgetsClientTypes.ActionHistory: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actionHistoryDetails = "ActionHistoryDetails"
        case eventType = "EventType"
        case status = "Status"
        case timestamp = "Timestamp"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actionHistoryDetails = self.actionHistoryDetails {
            try encodeContainer.encode(actionHistoryDetails, forKey: .actionHistoryDetails)
        }
        if let eventType = self.eventType {
            try encodeContainer.encode(eventType.rawValue, forKey: .eventType)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let timestamp = self.timestamp {
            try encodeContainer.encodeTimestamp(timestamp, format: .epochSeconds, forKey: .timestamp)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .timestamp)
        timestamp = timestampDecoded
        let statusDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.ActionStatus.self, forKey: .status)
        status = statusDecoded
        let eventTypeDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.EventType.self, forKey: .eventType)
        eventType = eventTypeDecoded
        let actionHistoryDetailsDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.ActionHistoryDetails.self, forKey: .actionHistoryDetails)
        actionHistoryDetails = actionHistoryDetailsDecoded
    }
}

extension BudgetsClientTypes {
    /// The historical records for a budget action.
    public struct ActionHistory: Swift.Equatable {
        /// The description of the details for the event.
        /// This member is required.
        public var actionHistoryDetails: BudgetsClientTypes.ActionHistoryDetails?
        /// This distinguishes between whether the events are triggered by the user or are generated by the system.
        /// This member is required.
        public var eventType: BudgetsClientTypes.EventType?
        /// The status of action at the time of the event.
        /// This member is required.
        public var status: BudgetsClientTypes.ActionStatus?
        /// A generic time stamp. In Java, it's transformed to a Date object.
        /// This member is required.
        public var timestamp: ClientRuntime.Date?

        public init (
            actionHistoryDetails: BudgetsClientTypes.ActionHistoryDetails? = nil,
            eventType: BudgetsClientTypes.EventType? = nil,
            status: BudgetsClientTypes.ActionStatus? = nil,
            timestamp: ClientRuntime.Date? = nil
        )
        {
            self.actionHistoryDetails = actionHistoryDetails
            self.eventType = eventType
            self.status = status
            self.timestamp = timestamp
        }
    }

}

extension BudgetsClientTypes.ActionHistoryDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action = "Action"
        case message = "Message"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = self.action {
            try encodeContainer.encode(action, forKey: .action)
        }
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let actionDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.Action.self, forKey: .action)
        action = actionDecoded
    }
}

extension BudgetsClientTypes {
    /// The description of the details for the event.
    public struct ActionHistoryDetails: Swift.Equatable {
        /// The budget action resource.
        /// This member is required.
        public var action: BudgetsClientTypes.Action?
        /// A generic string.
        /// This member is required.
        public var message: Swift.String?

        public init (
            action: BudgetsClientTypes.Action? = nil,
            message: Swift.String? = nil
        )
        {
            self.action = action
            self.message = message
        }
    }

}

extension BudgetsClientTypes {
    public enum ActionStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case executionFailure
        case executionInProgress
        case executionSuccess
        case pending
        case resetFailure
        case resetInProgress
        case reverseFailure
        case reverseInProgress
        case reverseSuccess
        case standby
        case sdkUnknown(Swift.String)

        public static var allCases: [ActionStatus] {
            return [
                .executionFailure,
                .executionInProgress,
                .executionSuccess,
                .pending,
                .resetFailure,
                .resetInProgress,
                .reverseFailure,
                .reverseInProgress,
                .reverseSuccess,
                .standby,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .executionFailure: return "EXECUTION_FAILURE"
            case .executionInProgress: return "EXECUTION_IN_PROGRESS"
            case .executionSuccess: return "EXECUTION_SUCCESS"
            case .pending: return "PENDING"
            case .resetFailure: return "RESET_FAILURE"
            case .resetInProgress: return "RESET_IN_PROGRESS"
            case .reverseFailure: return "REVERSE_FAILURE"
            case .reverseInProgress: return "REVERSE_IN_PROGRESS"
            case .reverseSuccess: return "REVERSE_SUCCESS"
            case .standby: return "STANDBY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ActionStatus(rawValue: rawValue) ?? ActionStatus.sdkUnknown(rawValue)
        }
    }
}

extension BudgetsClientTypes {
    public enum ActionSubType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case stopEc2
        case stopRds
        case sdkUnknown(Swift.String)

        public static var allCases: [ActionSubType] {
            return [
                .stopEc2,
                .stopRds,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .stopEc2: return "STOP_EC2_INSTANCES"
            case .stopRds: return "STOP_RDS_INSTANCES"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ActionSubType(rawValue: rawValue) ?? ActionSubType.sdkUnknown(rawValue)
        }
    }
}

extension BudgetsClientTypes.ActionThreshold: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actionThresholdType = "ActionThresholdType"
        case actionThresholdValue = "ActionThresholdValue"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actionThresholdType = self.actionThresholdType {
            try encodeContainer.encode(actionThresholdType.rawValue, forKey: .actionThresholdType)
        }
        if actionThresholdValue != 0.0 {
            try encodeContainer.encode(actionThresholdValue, forKey: .actionThresholdValue)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionThresholdValueDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .actionThresholdValue) ?? 0.0
        actionThresholdValue = actionThresholdValueDecoded
        let actionThresholdTypeDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.ThresholdType.self, forKey: .actionThresholdType)
        actionThresholdType = actionThresholdTypeDecoded
    }
}

extension BudgetsClientTypes {
    /// The trigger threshold of the action.
    public struct ActionThreshold: Swift.Equatable {
        /// The type of threshold for a notification.
        /// This member is required.
        public var actionThresholdType: BudgetsClientTypes.ThresholdType?
        /// The threshold of a notification.
        /// This member is required.
        public var actionThresholdValue: Swift.Double

        public init (
            actionThresholdType: BudgetsClientTypes.ThresholdType? = nil,
            actionThresholdValue: Swift.Double = 0.0
        )
        {
            self.actionThresholdType = actionThresholdType
            self.actionThresholdValue = actionThresholdValue
        }
    }

}

extension BudgetsClientTypes {
    public enum ActionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case iam
        case scp
        case ssm
        case sdkUnknown(Swift.String)

        public static var allCases: [ActionType] {
            return [
                .iam,
                .scp,
                .ssm,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .iam: return "APPLY_IAM_POLICY"
            case .scp: return "APPLY_SCP_POLICY"
            case .ssm: return "RUN_SSM_DOCUMENTS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ActionType(rawValue: rawValue) ?? ActionType.sdkUnknown(rawValue)
        }
    }
}

extension BudgetsClientTypes {
    public enum ApprovalModel: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case auto
        case manual
        case sdkUnknown(Swift.String)

        public static var allCases: [ApprovalModel] {
            return [
                .auto,
                .manual,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .auto: return "AUTOMATIC"
            case .manual: return "MANUAL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ApprovalModel(rawValue: rawValue) ?? ApprovalModel.sdkUnknown(rawValue)
        }
    }
}

extension BudgetsClientTypes.AutoAdjustData: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoAdjustType = "AutoAdjustType"
        case historicalOptions = "HistoricalOptions"
        case lastAutoAdjustTime = "LastAutoAdjustTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let autoAdjustType = self.autoAdjustType {
            try encodeContainer.encode(autoAdjustType.rawValue, forKey: .autoAdjustType)
        }
        if let historicalOptions = self.historicalOptions {
            try encodeContainer.encode(historicalOptions, forKey: .historicalOptions)
        }
        if let lastAutoAdjustTime = self.lastAutoAdjustTime {
            try encodeContainer.encodeTimestamp(lastAutoAdjustTime, format: .epochSeconds, forKey: .lastAutoAdjustTime)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let autoAdjustTypeDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.AutoAdjustType.self, forKey: .autoAdjustType)
        autoAdjustType = autoAdjustTypeDecoded
        let historicalOptionsDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.HistoricalOptions.self, forKey: .historicalOptions)
        historicalOptions = historicalOptionsDecoded
        let lastAutoAdjustTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastAutoAdjustTime)
        lastAutoAdjustTime = lastAutoAdjustTimeDecoded
    }
}

extension BudgetsClientTypes {
    /// The parameters that determine the budget amount for an auto-adjusting budget.
    public struct AutoAdjustData: Swift.Equatable {
        /// The string that defines whether your budget auto-adjusts based on historical or forecasted data.
        /// This member is required.
        public var autoAdjustType: BudgetsClientTypes.AutoAdjustType?
        /// The parameters that define or describe the historical data that your auto-adjusting budget is based on.
        public var historicalOptions: BudgetsClientTypes.HistoricalOptions?
        /// The last time that your budget was auto-adjusted.
        public var lastAutoAdjustTime: ClientRuntime.Date?

        public init (
            autoAdjustType: BudgetsClientTypes.AutoAdjustType? = nil,
            historicalOptions: BudgetsClientTypes.HistoricalOptions? = nil,
            lastAutoAdjustTime: ClientRuntime.Date? = nil
        )
        {
            self.autoAdjustType = autoAdjustType
            self.historicalOptions = historicalOptions
            self.lastAutoAdjustTime = lastAutoAdjustTime
        }
    }

}

extension BudgetsClientTypes {
    public enum AutoAdjustType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case forecast
        case historical
        case sdkUnknown(Swift.String)

        public static var allCases: [AutoAdjustType] {
            return [
                .forecast,
                .historical,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .forecast: return "FORECAST"
            case .historical: return "HISTORICAL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AutoAdjustType(rawValue: rawValue) ?? AutoAdjustType.sdkUnknown(rawValue)
        }
    }
}

extension BudgetsClientTypes.Budget: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoAdjustData = "AutoAdjustData"
        case budgetLimit = "BudgetLimit"
        case budgetName = "BudgetName"
        case budgetType = "BudgetType"
        case calculatedSpend = "CalculatedSpend"
        case costFilters = "CostFilters"
        case costTypes = "CostTypes"
        case lastUpdatedTime = "LastUpdatedTime"
        case plannedBudgetLimits = "PlannedBudgetLimits"
        case timePeriod = "TimePeriod"
        case timeUnit = "TimeUnit"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let autoAdjustData = self.autoAdjustData {
            try encodeContainer.encode(autoAdjustData, forKey: .autoAdjustData)
        }
        if let budgetLimit = self.budgetLimit {
            try encodeContainer.encode(budgetLimit, forKey: .budgetLimit)
        }
        if let budgetName = self.budgetName {
            try encodeContainer.encode(budgetName, forKey: .budgetName)
        }
        if let budgetType = self.budgetType {
            try encodeContainer.encode(budgetType.rawValue, forKey: .budgetType)
        }
        if let calculatedSpend = self.calculatedSpend {
            try encodeContainer.encode(calculatedSpend, forKey: .calculatedSpend)
        }
        if let costFilters = costFilters {
            var costFiltersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .costFilters)
            for (dictKey0, costFilters0) in costFilters {
                var costFilters0Container = costFiltersContainer.nestedUnkeyedContainer(forKey: ClientRuntime.Key(stringValue: dictKey0))
                for dimensionvalue1 in costFilters0 {
                    try costFilters0Container.encode(dimensionvalue1)
                }
            }
        }
        if let costTypes = self.costTypes {
            try encodeContainer.encode(costTypes, forKey: .costTypes)
        }
        if let lastUpdatedTime = self.lastUpdatedTime {
            try encodeContainer.encodeTimestamp(lastUpdatedTime, format: .epochSeconds, forKey: .lastUpdatedTime)
        }
        if let plannedBudgetLimits = plannedBudgetLimits {
            var plannedBudgetLimitsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .plannedBudgetLimits)
            for (dictKey0, plannedBudgetLimits0) in plannedBudgetLimits {
                try plannedBudgetLimitsContainer.encode(plannedBudgetLimits0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let timePeriod = self.timePeriod {
            try encodeContainer.encode(timePeriod, forKey: .timePeriod)
        }
        if let timeUnit = self.timeUnit {
            try encodeContainer.encode(timeUnit.rawValue, forKey: .timeUnit)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let budgetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .budgetName)
        budgetName = budgetNameDecoded
        let budgetLimitDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.Spend.self, forKey: .budgetLimit)
        budgetLimit = budgetLimitDecoded
        let plannedBudgetLimitsContainer = try containerValues.decodeIfPresent([Swift.String: BudgetsClientTypes.Spend?].self, forKey: .plannedBudgetLimits)
        var plannedBudgetLimitsDecoded0: [Swift.String:BudgetsClientTypes.Spend]? = nil
        if let plannedBudgetLimitsContainer = plannedBudgetLimitsContainer {
            plannedBudgetLimitsDecoded0 = [Swift.String:BudgetsClientTypes.Spend]()
            for (key0, spend0) in plannedBudgetLimitsContainer {
                if let spend0 = spend0 {
                    plannedBudgetLimitsDecoded0?[key0] = spend0
                }
            }
        }
        plannedBudgetLimits = plannedBudgetLimitsDecoded0
        let costFiltersContainer = try containerValues.decodeIfPresent([Swift.String: [Swift.String?]?].self, forKey: .costFilters)
        var costFiltersDecoded0: [Swift.String:[Swift.String]]? = nil
        if let costFiltersContainer = costFiltersContainer {
            costFiltersDecoded0 = [Swift.String:[Swift.String]]()
            for (key0, dimensionvalues0) in costFiltersContainer {
                var dimensionvalues0Decoded0: [Swift.String]? = nil
                if let dimensionvalues0 = dimensionvalues0 {
                    dimensionvalues0Decoded0 = [Swift.String]()
                    for string1 in dimensionvalues0 {
                        if let string1 = string1 {
                            dimensionvalues0Decoded0?.append(string1)
                        }
                    }
                }
                costFiltersDecoded0?[key0] = dimensionvalues0Decoded0
            }
        }
        costFilters = costFiltersDecoded0
        let costTypesDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.CostTypes.self, forKey: .costTypes)
        costTypes = costTypesDecoded
        let timeUnitDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.TimeUnit.self, forKey: .timeUnit)
        timeUnit = timeUnitDecoded
        let timePeriodDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.TimePeriod.self, forKey: .timePeriod)
        timePeriod = timePeriodDecoded
        let calculatedSpendDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.CalculatedSpend.self, forKey: .calculatedSpend)
        calculatedSpend = calculatedSpendDecoded
        let budgetTypeDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.BudgetType.self, forKey: .budgetType)
        budgetType = budgetTypeDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
        let autoAdjustDataDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.AutoAdjustData.self, forKey: .autoAdjustData)
        autoAdjustData = autoAdjustDataDecoded
    }
}

extension BudgetsClientTypes {
    /// Represents the output of the CreateBudget operation. The content consists of the detailed metadata and data file information, and the current status of the budget object. This is the Amazon Resource Name (ARN) pattern for a budget: arn:aws:budgets::AccountId:budget/budgetName
    public struct Budget: Swift.Equatable {
        /// The parameters that determine the budget amount for an auto-adjusting budget.
        public var autoAdjustData: BudgetsClientTypes.AutoAdjustData?
        /// The total amount of cost, usage, RI utilization, RI coverage, Savings Plans utilization, or Savings Plans coverage that you want to track with your budget. BudgetLimit is required for cost or usage budgets, but optional for RI or Savings Plans utilization or coverage budgets. RI and Savings Plans utilization or coverage budgets default to 100. This is the only valid value for RI or Savings Plans utilization or coverage budgets. You can't use BudgetLimit with PlannedBudgetLimits for CreateBudget and UpdateBudget actions.
        public var budgetLimit: BudgetsClientTypes.Spend?
        /// The name of a budget. The name must be unique within an account. The : and \ characters aren't allowed in BudgetName.
        /// This member is required.
        public var budgetName: Swift.String?
        /// Specifies whether this budget tracks costs, usage, RI utilization, RI coverage, Savings Plans utilization, or Savings Plans coverage.
        /// This member is required.
        public var budgetType: BudgetsClientTypes.BudgetType?
        /// The actual and forecasted cost or usage that the budget tracks.
        public var calculatedSpend: BudgetsClientTypes.CalculatedSpend?
        /// The cost filters, such as Region, Service, member account, Tag, or Cost Category, that are applied to a budget. Amazon Web Services Budgets supports the following services as a Service filter for RI budgets:
        ///
        /// * Amazon EC2
        ///
        /// * Amazon Redshift
        ///
        /// * Amazon Relational Database Service
        ///
        /// * Amazon ElastiCache
        ///
        /// * Amazon OpenSearch Service
        public var costFilters: [Swift.String:[Swift.String]]?
        /// The types of costs that are included in this COST budget. USAGE, RI_UTILIZATION, RI_COVERAGE, SAVINGS_PLANS_UTILIZATION, and SAVINGS_PLANS_COVERAGE budgets do not have CostTypes.
        public var costTypes: BudgetsClientTypes.CostTypes?
        /// The last time that you updated this budget.
        public var lastUpdatedTime: ClientRuntime.Date?
        /// A map containing multiple BudgetLimit, including current or future limits. PlannedBudgetLimits is available for cost or usage budget and supports both monthly and quarterly TimeUnit. For monthly budgets, provide 12 months of PlannedBudgetLimits values. This must start from the current month and include the next 11 months. The key is the start of the month, UTC in epoch seconds. For quarterly budgets, provide four quarters of PlannedBudgetLimits value entries in standard calendar quarter increments. This must start from the current quarter and include the next three quarters. The key is the start of the quarter, UTC in epoch seconds. If the planned budget expires before 12 months for monthly or four quarters for quarterly, provide the PlannedBudgetLimits values only for the remaining periods. If the budget begins at a date in the future, provide PlannedBudgetLimits values from the start date of the budget. After all of the BudgetLimit values in PlannedBudgetLimits are used, the budget continues to use the last limit as the BudgetLimit. At that point, the planned budget provides the same experience as a fixed budget. DescribeBudget and DescribeBudgets response along with PlannedBudgetLimits also contain BudgetLimit representing the current month or quarter limit present in PlannedBudgetLimits. This only applies to budgets that are created with PlannedBudgetLimits. Budgets that are created without PlannedBudgetLimits only contain BudgetLimit. They don't contain PlannedBudgetLimits.
        public var plannedBudgetLimits: [Swift.String:BudgetsClientTypes.Spend]?
        /// The period of time that's covered by a budget. You setthe start date and end date. The start date must come before the end date. The end date must come before 06/15/87 00:00 UTC. If you create your budget and don't specify a start date, Amazon Web Services defaults to the start of your chosen time period (DAILY, MONTHLY, QUARTERLY, or ANNUALLY). For example, if you created your budget on January 24, 2018, chose DAILY, and didn't set a start date, Amazon Web Services set your start date to 01/24/18 00:00 UTC. If you chose MONTHLY, Amazon Web Services set your start date to 01/01/18 00:00 UTC. If you didn't specify an end date, Amazon Web Services set your end date to 06/15/87 00:00 UTC. The defaults are the same for the Billing and Cost Management console and the API. You can change either date with the UpdateBudget operation. After the end date, Amazon Web Services deletes the budget and all the associated notifications and subscribers.
        public var timePeriod: BudgetsClientTypes.TimePeriod?
        /// The length of time until a budget resets the actual and forecasted spend.
        /// This member is required.
        public var timeUnit: BudgetsClientTypes.TimeUnit?

        public init (
            autoAdjustData: BudgetsClientTypes.AutoAdjustData? = nil,
            budgetLimit: BudgetsClientTypes.Spend? = nil,
            budgetName: Swift.String? = nil,
            budgetType: BudgetsClientTypes.BudgetType? = nil,
            calculatedSpend: BudgetsClientTypes.CalculatedSpend? = nil,
            costFilters: [Swift.String:[Swift.String]]? = nil,
            costTypes: BudgetsClientTypes.CostTypes? = nil,
            lastUpdatedTime: ClientRuntime.Date? = nil,
            plannedBudgetLimits: [Swift.String:BudgetsClientTypes.Spend]? = nil,
            timePeriod: BudgetsClientTypes.TimePeriod? = nil,
            timeUnit: BudgetsClientTypes.TimeUnit? = nil
        )
        {
            self.autoAdjustData = autoAdjustData
            self.budgetLimit = budgetLimit
            self.budgetName = budgetName
            self.budgetType = budgetType
            self.calculatedSpend = calculatedSpend
            self.costFilters = costFilters
            self.costTypes = costTypes
            self.lastUpdatedTime = lastUpdatedTime
            self.plannedBudgetLimits = plannedBudgetLimits
            self.timePeriod = timePeriod
            self.timeUnit = timeUnit
        }
    }

}

extension BudgetsClientTypes.BudgetNotificationsForAccount: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case budgetName = "BudgetName"
        case notifications = "Notifications"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let budgetName = self.budgetName {
            try encodeContainer.encode(budgetName, forKey: .budgetName)
        }
        if let notifications = notifications {
            var notificationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .notifications)
            for notification0 in notifications {
                try notificationsContainer.encode(notification0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let notificationsContainer = try containerValues.decodeIfPresent([BudgetsClientTypes.Notification?].self, forKey: .notifications)
        var notificationsDecoded0:[BudgetsClientTypes.Notification]? = nil
        if let notificationsContainer = notificationsContainer {
            notificationsDecoded0 = [BudgetsClientTypes.Notification]()
            for structure0 in notificationsContainer {
                if let structure0 = structure0 {
                    notificationsDecoded0?.append(structure0)
                }
            }
        }
        notifications = notificationsDecoded0
        let budgetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .budgetName)
        budgetName = budgetNameDecoded
    }
}

extension BudgetsClientTypes {
    /// The budget name and associated notifications for an account.
    public struct BudgetNotificationsForAccount: Swift.Equatable {
        /// A string that represents the budget name. The ":" and "\" characters aren't allowed.
        public var budgetName: Swift.String?
        /// A list of notifications.
        public var notifications: [BudgetsClientTypes.Notification]?

        public init (
            budgetName: Swift.String? = nil,
            notifications: [BudgetsClientTypes.Notification]? = nil
        )
        {
            self.budgetName = budgetName
            self.notifications = notifications
        }
    }

}

extension BudgetsClientTypes.BudgetPerformanceHistory: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case budgetName = "BudgetName"
        case budgetType = "BudgetType"
        case budgetedAndActualAmountsList = "BudgetedAndActualAmountsList"
        case costFilters = "CostFilters"
        case costTypes = "CostTypes"
        case timeUnit = "TimeUnit"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let budgetName = self.budgetName {
            try encodeContainer.encode(budgetName, forKey: .budgetName)
        }
        if let budgetType = self.budgetType {
            try encodeContainer.encode(budgetType.rawValue, forKey: .budgetType)
        }
        if let budgetedAndActualAmountsList = budgetedAndActualAmountsList {
            var budgetedAndActualAmountsListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .budgetedAndActualAmountsList)
            for budgetedandactualamounts0 in budgetedAndActualAmountsList {
                try budgetedAndActualAmountsListContainer.encode(budgetedandactualamounts0)
            }
        }
        if let costFilters = costFilters {
            var costFiltersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .costFilters)
            for (dictKey0, costFilters0) in costFilters {
                var costFilters0Container = costFiltersContainer.nestedUnkeyedContainer(forKey: ClientRuntime.Key(stringValue: dictKey0))
                for dimensionvalue1 in costFilters0 {
                    try costFilters0Container.encode(dimensionvalue1)
                }
            }
        }
        if let costTypes = self.costTypes {
            try encodeContainer.encode(costTypes, forKey: .costTypes)
        }
        if let timeUnit = self.timeUnit {
            try encodeContainer.encode(timeUnit.rawValue, forKey: .timeUnit)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let budgetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .budgetName)
        budgetName = budgetNameDecoded
        let budgetTypeDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.BudgetType.self, forKey: .budgetType)
        budgetType = budgetTypeDecoded
        let costFiltersContainer = try containerValues.decodeIfPresent([Swift.String: [Swift.String?]?].self, forKey: .costFilters)
        var costFiltersDecoded0: [Swift.String:[Swift.String]]? = nil
        if let costFiltersContainer = costFiltersContainer {
            costFiltersDecoded0 = [Swift.String:[Swift.String]]()
            for (key0, dimensionvalues0) in costFiltersContainer {
                var dimensionvalues0Decoded0: [Swift.String]? = nil
                if let dimensionvalues0 = dimensionvalues0 {
                    dimensionvalues0Decoded0 = [Swift.String]()
                    for string1 in dimensionvalues0 {
                        if let string1 = string1 {
                            dimensionvalues0Decoded0?.append(string1)
                        }
                    }
                }
                costFiltersDecoded0?[key0] = dimensionvalues0Decoded0
            }
        }
        costFilters = costFiltersDecoded0
        let costTypesDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.CostTypes.self, forKey: .costTypes)
        costTypes = costTypesDecoded
        let timeUnitDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.TimeUnit.self, forKey: .timeUnit)
        timeUnit = timeUnitDecoded
        let budgetedAndActualAmountsListContainer = try containerValues.decodeIfPresent([BudgetsClientTypes.BudgetedAndActualAmounts?].self, forKey: .budgetedAndActualAmountsList)
        var budgetedAndActualAmountsListDecoded0:[BudgetsClientTypes.BudgetedAndActualAmounts]? = nil
        if let budgetedAndActualAmountsListContainer = budgetedAndActualAmountsListContainer {
            budgetedAndActualAmountsListDecoded0 = [BudgetsClientTypes.BudgetedAndActualAmounts]()
            for structure0 in budgetedAndActualAmountsListContainer {
                if let structure0 = structure0 {
                    budgetedAndActualAmountsListDecoded0?.append(structure0)
                }
            }
        }
        budgetedAndActualAmountsList = budgetedAndActualAmountsListDecoded0
    }
}

extension BudgetsClientTypes {
    /// A history of the state of a budget at the end of the budget's specified time period.
    public struct BudgetPerformanceHistory: Swift.Equatable {
        /// A string that represents the budget name. The ":" and "\" characters aren't allowed.
        public var budgetName: Swift.String?
        /// The type of a budget. It must be one of the following types: COST, USAGE, RI_UTILIZATION, RI_COVERAGE, SAVINGS_PLANS_UTILIZATION, or SAVINGS_PLANS_COVERAGE.
        public var budgetType: BudgetsClientTypes.BudgetType?
        /// A list of amounts of cost or usage that you created budgets for, which are compared to your actual costs or usage.
        public var budgetedAndActualAmountsList: [BudgetsClientTypes.BudgetedAndActualAmounts]?
        /// The history of the cost filters for a budget during the specified time period.
        public var costFilters: [Swift.String:[Swift.String]]?
        /// The history of the cost types for a budget during the specified time period.
        public var costTypes: BudgetsClientTypes.CostTypes?
        /// The time unit of the budget, such as MONTHLY or QUARTERLY.
        public var timeUnit: BudgetsClientTypes.TimeUnit?

        public init (
            budgetName: Swift.String? = nil,
            budgetType: BudgetsClientTypes.BudgetType? = nil,
            budgetedAndActualAmountsList: [BudgetsClientTypes.BudgetedAndActualAmounts]? = nil,
            costFilters: [Swift.String:[Swift.String]]? = nil,
            costTypes: BudgetsClientTypes.CostTypes? = nil,
            timeUnit: BudgetsClientTypes.TimeUnit? = nil
        )
        {
            self.budgetName = budgetName
            self.budgetType = budgetType
            self.budgetedAndActualAmountsList = budgetedAndActualAmountsList
            self.costFilters = costFilters
            self.costTypes = costTypes
            self.timeUnit = timeUnit
        }
    }

}

extension BudgetsClientTypes {
    /// The type of a budget. It must be one of the following types: COST, USAGE, RI_UTILIZATION, RI_COVERAGE, SAVINGS_PLANS_UTILIZATION, or SAVINGS_PLANS_COVERAGE.
    public enum BudgetType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cost
        case ricoverage
        case riutilization
        case spcoverage
        case sputilization
        case usage
        case sdkUnknown(Swift.String)

        public static var allCases: [BudgetType] {
            return [
                .cost,
                .ricoverage,
                .riutilization,
                .spcoverage,
                .sputilization,
                .usage,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cost: return "COST"
            case .ricoverage: return "RI_COVERAGE"
            case .riutilization: return "RI_UTILIZATION"
            case .spcoverage: return "SAVINGS_PLANS_COVERAGE"
            case .sputilization: return "SAVINGS_PLANS_UTILIZATION"
            case .usage: return "USAGE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = BudgetType(rawValue: rawValue) ?? BudgetType.sdkUnknown(rawValue)
        }
    }
}

extension BudgetsClientTypes.BudgetedAndActualAmounts: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actualAmount = "ActualAmount"
        case budgetedAmount = "BudgetedAmount"
        case timePeriod = "TimePeriod"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actualAmount = self.actualAmount {
            try encodeContainer.encode(actualAmount, forKey: .actualAmount)
        }
        if let budgetedAmount = self.budgetedAmount {
            try encodeContainer.encode(budgetedAmount, forKey: .budgetedAmount)
        }
        if let timePeriod = self.timePeriod {
            try encodeContainer.encode(timePeriod, forKey: .timePeriod)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let budgetedAmountDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.Spend.self, forKey: .budgetedAmount)
        budgetedAmount = budgetedAmountDecoded
        let actualAmountDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.Spend.self, forKey: .actualAmount)
        actualAmount = actualAmountDecoded
        let timePeriodDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.TimePeriod.self, forKey: .timePeriod)
        timePeriod = timePeriodDecoded
    }
}

extension BudgetsClientTypes {
    /// The amount of cost or usage that you created the budget for, compared to your actual costs or usage.
    public struct BudgetedAndActualAmounts: Swift.Equatable {
        /// Your actual costs or usage for a budget period.
        public var actualAmount: BudgetsClientTypes.Spend?
        /// The amount of cost or usage that you created the budget for.
        public var budgetedAmount: BudgetsClientTypes.Spend?
        /// The time period that's covered by this budget comparison.
        public var timePeriod: BudgetsClientTypes.TimePeriod?

        public init (
            actualAmount: BudgetsClientTypes.Spend? = nil,
            budgetedAmount: BudgetsClientTypes.Spend? = nil,
            timePeriod: BudgetsClientTypes.TimePeriod? = nil
        )
        {
            self.actualAmount = actualAmount
            self.budgetedAmount = budgetedAmount
            self.timePeriod = timePeriod
        }
    }

}

extension BudgetsClientTypes.CalculatedSpend: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actualSpend = "ActualSpend"
        case forecastedSpend = "ForecastedSpend"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actualSpend = self.actualSpend {
            try encodeContainer.encode(actualSpend, forKey: .actualSpend)
        }
        if let forecastedSpend = self.forecastedSpend {
            try encodeContainer.encode(forecastedSpend, forKey: .forecastedSpend)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actualSpendDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.Spend.self, forKey: .actualSpend)
        actualSpend = actualSpendDecoded
        let forecastedSpendDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.Spend.self, forKey: .forecastedSpend)
        forecastedSpend = forecastedSpendDecoded
    }
}

extension BudgetsClientTypes {
    /// The spend objects that are associated with this budget. The actualSpend tracks how much you've used, cost, usage, RI units, or Savings Plans units and the forecastedSpend tracks how much that you're predicted to spend based on your historical usage profile. For example, if it's the 20th of the month and you have spent 50 dollars on Amazon EC2, your actualSpend is 50 USD, and your forecastedSpend is 75 USD.
    public struct CalculatedSpend: Swift.Equatable {
        /// The amount of cost, usage, RI units, or Savings Plans units that you used.
        /// This member is required.
        public var actualSpend: BudgetsClientTypes.Spend?
        /// The amount of cost, usage, RI units, or Savings Plans units that you're forecasted to use.
        public var forecastedSpend: BudgetsClientTypes.Spend?

        public init (
            actualSpend: BudgetsClientTypes.Spend? = nil,
            forecastedSpend: BudgetsClientTypes.Spend? = nil
        )
        {
            self.actualSpend = actualSpend
            self.forecastedSpend = forecastedSpend
        }
    }

}

extension BudgetsClientTypes {
    /// The comparison operator of a notification. Currently, the service supports the following operators: GREATER_THAN, LESS_THAN, EQUAL_TO
    public enum ComparisonOperator: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case equalTo
        case greaterThan
        case lessThan
        case sdkUnknown(Swift.String)

        public static var allCases: [ComparisonOperator] {
            return [
                .equalTo,
                .greaterThan,
                .lessThan,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .equalTo: return "EQUAL_TO"
            case .greaterThan: return "GREATER_THAN"
            case .lessThan: return "LESS_THAN"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ComparisonOperator(rawValue: rawValue) ?? ComparisonOperator.sdkUnknown(rawValue)
        }
    }
}

extension BudgetsClientTypes.CostTypes: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case includeCredit = "IncludeCredit"
        case includeDiscount = "IncludeDiscount"
        case includeOtherSubscription = "IncludeOtherSubscription"
        case includeRecurring = "IncludeRecurring"
        case includeRefund = "IncludeRefund"
        case includeSubscription = "IncludeSubscription"
        case includeSupport = "IncludeSupport"
        case includeTax = "IncludeTax"
        case includeUpfront = "IncludeUpfront"
        case useAmortized = "UseAmortized"
        case useBlended = "UseBlended"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let includeCredit = self.includeCredit {
            try encodeContainer.encode(includeCredit, forKey: .includeCredit)
        }
        if let includeDiscount = self.includeDiscount {
            try encodeContainer.encode(includeDiscount, forKey: .includeDiscount)
        }
        if let includeOtherSubscription = self.includeOtherSubscription {
            try encodeContainer.encode(includeOtherSubscription, forKey: .includeOtherSubscription)
        }
        if let includeRecurring = self.includeRecurring {
            try encodeContainer.encode(includeRecurring, forKey: .includeRecurring)
        }
        if let includeRefund = self.includeRefund {
            try encodeContainer.encode(includeRefund, forKey: .includeRefund)
        }
        if let includeSubscription = self.includeSubscription {
            try encodeContainer.encode(includeSubscription, forKey: .includeSubscription)
        }
        if let includeSupport = self.includeSupport {
            try encodeContainer.encode(includeSupport, forKey: .includeSupport)
        }
        if let includeTax = self.includeTax {
            try encodeContainer.encode(includeTax, forKey: .includeTax)
        }
        if let includeUpfront = self.includeUpfront {
            try encodeContainer.encode(includeUpfront, forKey: .includeUpfront)
        }
        if let useAmortized = self.useAmortized {
            try encodeContainer.encode(useAmortized, forKey: .useAmortized)
        }
        if let useBlended = self.useBlended {
            try encodeContainer.encode(useBlended, forKey: .useBlended)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let includeTaxDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .includeTax)
        includeTax = includeTaxDecoded
        let includeSubscriptionDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .includeSubscription)
        includeSubscription = includeSubscriptionDecoded
        let useBlendedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .useBlended)
        useBlended = useBlendedDecoded
        let includeRefundDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .includeRefund)
        includeRefund = includeRefundDecoded
        let includeCreditDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .includeCredit)
        includeCredit = includeCreditDecoded
        let includeUpfrontDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .includeUpfront)
        includeUpfront = includeUpfrontDecoded
        let includeRecurringDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .includeRecurring)
        includeRecurring = includeRecurringDecoded
        let includeOtherSubscriptionDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .includeOtherSubscription)
        includeOtherSubscription = includeOtherSubscriptionDecoded
        let includeSupportDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .includeSupport)
        includeSupport = includeSupportDecoded
        let includeDiscountDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .includeDiscount)
        includeDiscount = includeDiscountDecoded
        let useAmortizedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .useAmortized)
        useAmortized = useAmortizedDecoded
    }
}

extension BudgetsClientTypes {
    /// The types of cost that are included in a COST budget, such as tax and subscriptions. USAGE, RI_UTILIZATION, RI_COVERAGE, SAVINGS_PLANS_UTILIZATION, and SAVINGS_PLANS_COVERAGE budgets don't have CostTypes.
    public struct CostTypes: Swift.Equatable {
        /// Specifies whether a budget includes credits. The default value is true.
        public var includeCredit: Swift.Bool?
        /// Specifies whether a budget includes discounts. The default value is true.
        public var includeDiscount: Swift.Bool?
        /// Specifies whether a budget includes non-RI subscription costs. The default value is true.
        public var includeOtherSubscription: Swift.Bool?
        /// Specifies whether a budget includes recurring fees such as monthly RI fees. The default value is true.
        public var includeRecurring: Swift.Bool?
        /// Specifies whether a budget includes refunds. The default value is true.
        public var includeRefund: Swift.Bool?
        /// Specifies whether a budget includes subscriptions. The default value is true.
        public var includeSubscription: Swift.Bool?
        /// Specifies whether a budget includes support subscription fees. The default value is true.
        public var includeSupport: Swift.Bool?
        /// Specifies whether a budget includes taxes. The default value is true.
        public var includeTax: Swift.Bool?
        /// Specifies whether a budget includes upfront RI costs. The default value is true.
        public var includeUpfront: Swift.Bool?
        /// Specifies whether a budget uses the amortized rate. The default value is false.
        public var useAmortized: Swift.Bool?
        /// Specifies whether a budget uses a blended rate. The default value is false.
        public var useBlended: Swift.Bool?

        public init (
            includeCredit: Swift.Bool? = nil,
            includeDiscount: Swift.Bool? = nil,
            includeOtherSubscription: Swift.Bool? = nil,
            includeRecurring: Swift.Bool? = nil,
            includeRefund: Swift.Bool? = nil,
            includeSubscription: Swift.Bool? = nil,
            includeSupport: Swift.Bool? = nil,
            includeTax: Swift.Bool? = nil,
            includeUpfront: Swift.Bool? = nil,
            useAmortized: Swift.Bool? = nil,
            useBlended: Swift.Bool? = nil
        )
        {
            self.includeCredit = includeCredit
            self.includeDiscount = includeDiscount
            self.includeOtherSubscription = includeOtherSubscription
            self.includeRecurring = includeRecurring
            self.includeRefund = includeRefund
            self.includeSubscription = includeSubscription
            self.includeSupport = includeSupport
            self.includeTax = includeTax
            self.includeUpfront = includeUpfront
            self.useAmortized = useAmortized
            self.useBlended = useBlended
        }
    }

}

extension CreateBudgetActionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case actionThreshold = "ActionThreshold"
        case actionType = "ActionType"
        case approvalModel = "ApprovalModel"
        case budgetName = "BudgetName"
        case definition = "Definition"
        case executionRoleArn = "ExecutionRoleArn"
        case notificationType = "NotificationType"
        case subscribers = "Subscribers"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let actionThreshold = self.actionThreshold {
            try encodeContainer.encode(actionThreshold, forKey: .actionThreshold)
        }
        if let actionType = self.actionType {
            try encodeContainer.encode(actionType.rawValue, forKey: .actionType)
        }
        if let approvalModel = self.approvalModel {
            try encodeContainer.encode(approvalModel.rawValue, forKey: .approvalModel)
        }
        if let budgetName = self.budgetName {
            try encodeContainer.encode(budgetName, forKey: .budgetName)
        }
        if let definition = self.definition {
            try encodeContainer.encode(definition, forKey: .definition)
        }
        if let executionRoleArn = self.executionRoleArn {
            try encodeContainer.encode(executionRoleArn, forKey: .executionRoleArn)
        }
        if let notificationType = self.notificationType {
            try encodeContainer.encode(notificationType.rawValue, forKey: .notificationType)
        }
        if let subscribers = subscribers {
            var subscribersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subscribers)
            for subscriber0 in subscribers {
                try subscribersContainer.encode(subscriber0)
            }
        }
    }
}

extension CreateBudgetActionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateBudgetActionInput: Swift.Equatable {
    /// The account ID of the user. It's a 12-digit number.
    /// This member is required.
    public var accountId: Swift.String?
    /// The trigger threshold of the action.
    /// This member is required.
    public var actionThreshold: BudgetsClientTypes.ActionThreshold?
    /// The type of action. This defines the type of tasks that can be carried out by this action. This field also determines the format for definition.
    /// This member is required.
    public var actionType: BudgetsClientTypes.ActionType?
    /// This specifies if the action needs manual or automatic approval.
    /// This member is required.
    public var approvalModel: BudgetsClientTypes.ApprovalModel?
    /// A string that represents the budget name. The ":" and "\" characters aren't allowed.
    /// This member is required.
    public var budgetName: Swift.String?
    /// Specifies all of the type-specific parameters.
    /// This member is required.
    public var definition: BudgetsClientTypes.Definition?
    /// The role passed for action execution and reversion. Roles and actions must be in the same account.
    /// This member is required.
    public var executionRoleArn: Swift.String?
    /// The type of a notification. It must be ACTUAL or FORECASTED.
    /// This member is required.
    public var notificationType: BudgetsClientTypes.NotificationType?
    /// A list of subscribers.
    /// This member is required.
    public var subscribers: [BudgetsClientTypes.Subscriber]?

    public init (
        accountId: Swift.String? = nil,
        actionThreshold: BudgetsClientTypes.ActionThreshold? = nil,
        actionType: BudgetsClientTypes.ActionType? = nil,
        approvalModel: BudgetsClientTypes.ApprovalModel? = nil,
        budgetName: Swift.String? = nil,
        definition: BudgetsClientTypes.Definition? = nil,
        executionRoleArn: Swift.String? = nil,
        notificationType: BudgetsClientTypes.NotificationType? = nil,
        subscribers: [BudgetsClientTypes.Subscriber]? = nil
    )
    {
        self.accountId = accountId
        self.actionThreshold = actionThreshold
        self.actionType = actionType
        self.approvalModel = approvalModel
        self.budgetName = budgetName
        self.definition = definition
        self.executionRoleArn = executionRoleArn
        self.notificationType = notificationType
        self.subscribers = subscribers
    }
}

struct CreateBudgetActionInputBody: Swift.Equatable {
    let accountId: Swift.String?
    let budgetName: Swift.String?
    let notificationType: BudgetsClientTypes.NotificationType?
    let actionType: BudgetsClientTypes.ActionType?
    let actionThreshold: BudgetsClientTypes.ActionThreshold?
    let definition: BudgetsClientTypes.Definition?
    let executionRoleArn: Swift.String?
    let approvalModel: BudgetsClientTypes.ApprovalModel?
    let subscribers: [BudgetsClientTypes.Subscriber]?
}

extension CreateBudgetActionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case actionThreshold = "ActionThreshold"
        case actionType = "ActionType"
        case approvalModel = "ApprovalModel"
        case budgetName = "BudgetName"
        case definition = "Definition"
        case executionRoleArn = "ExecutionRoleArn"
        case notificationType = "NotificationType"
        case subscribers = "Subscribers"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let budgetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .budgetName)
        budgetName = budgetNameDecoded
        let notificationTypeDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.NotificationType.self, forKey: .notificationType)
        notificationType = notificationTypeDecoded
        let actionTypeDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.ActionType.self, forKey: .actionType)
        actionType = actionTypeDecoded
        let actionThresholdDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.ActionThreshold.self, forKey: .actionThreshold)
        actionThreshold = actionThresholdDecoded
        let definitionDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.Definition.self, forKey: .definition)
        definition = definitionDecoded
        let executionRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .executionRoleArn)
        executionRoleArn = executionRoleArnDecoded
        let approvalModelDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.ApprovalModel.self, forKey: .approvalModel)
        approvalModel = approvalModelDecoded
        let subscribersContainer = try containerValues.decodeIfPresent([BudgetsClientTypes.Subscriber?].self, forKey: .subscribers)
        var subscribersDecoded0:[BudgetsClientTypes.Subscriber]? = nil
        if let subscribersContainer = subscribersContainer {
            subscribersDecoded0 = [BudgetsClientTypes.Subscriber]()
            for structure0 in subscribersContainer {
                if let structure0 = structure0 {
                    subscribersDecoded0?.append(structure0)
                }
            }
        }
        subscribers = subscribersDecoded0
    }
}

extension CreateBudgetActionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateBudgetActionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CreationLimitExceededException" : self = .creationLimitExceededException(try CreationLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DuplicateRecordException" : self = .duplicateRecordException(try DuplicateRecordException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateBudgetActionOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case creationLimitExceededException(CreationLimitExceededException)
    case duplicateRecordException(DuplicateRecordException)
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notFoundException(NotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateBudgetActionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateBudgetActionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.accountId = output.accountId
            self.actionId = output.actionId
            self.budgetName = output.budgetName
        } else {
            self.accountId = nil
            self.actionId = nil
            self.budgetName = nil
        }
    }
}

public struct CreateBudgetActionOutputResponse: Swift.Equatable {
    /// The account ID of the user. It's a 12-digit number.
    /// This member is required.
    public var accountId: Swift.String?
    /// A system-generated universally unique identifier (UUID) for the action.
    /// This member is required.
    public var actionId: Swift.String?
    /// A string that represents the budget name. The ":" and "\" characters aren't allowed.
    /// This member is required.
    public var budgetName: Swift.String?

    public init (
        accountId: Swift.String? = nil,
        actionId: Swift.String? = nil,
        budgetName: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.actionId = actionId
        self.budgetName = budgetName
    }
}

struct CreateBudgetActionOutputResponseBody: Swift.Equatable {
    let accountId: Swift.String?
    let budgetName: Swift.String?
    let actionId: Swift.String?
}

extension CreateBudgetActionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case actionId = "ActionId"
        case budgetName = "BudgetName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let budgetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .budgetName)
        budgetName = budgetNameDecoded
        let actionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .actionId)
        actionId = actionIdDecoded
    }
}

extension CreateBudgetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case budget = "Budget"
        case notificationsWithSubscribers = "NotificationsWithSubscribers"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let budget = self.budget {
            try encodeContainer.encode(budget, forKey: .budget)
        }
        if let notificationsWithSubscribers = notificationsWithSubscribers {
            var notificationsWithSubscribersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .notificationsWithSubscribers)
            for notificationwithsubscribers0 in notificationsWithSubscribers {
                try notificationsWithSubscribersContainer.encode(notificationwithsubscribers0)
            }
        }
    }
}

extension CreateBudgetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Request of CreateBudget
public struct CreateBudgetInput: Swift.Equatable {
    /// The accountId that is associated with the budget.
    /// This member is required.
    public var accountId: Swift.String?
    /// The budget object that you want to create.
    /// This member is required.
    public var budget: BudgetsClientTypes.Budget?
    /// A notification that you want to associate with a budget. A budget can have up to five notifications, and each notification can have one SNS subscriber and up to 10 email subscribers. If you include notifications and subscribers in your CreateBudget call, Amazon Web Services creates the notifications and subscribers for you.
    public var notificationsWithSubscribers: [BudgetsClientTypes.NotificationWithSubscribers]?

    public init (
        accountId: Swift.String? = nil,
        budget: BudgetsClientTypes.Budget? = nil,
        notificationsWithSubscribers: [BudgetsClientTypes.NotificationWithSubscribers]? = nil
    )
    {
        self.accountId = accountId
        self.budget = budget
        self.notificationsWithSubscribers = notificationsWithSubscribers
    }
}

struct CreateBudgetInputBody: Swift.Equatable {
    let accountId: Swift.String?
    let budget: BudgetsClientTypes.Budget?
    let notificationsWithSubscribers: [BudgetsClientTypes.NotificationWithSubscribers]?
}

extension CreateBudgetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case budget = "Budget"
        case notificationsWithSubscribers = "NotificationsWithSubscribers"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let budgetDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.Budget.self, forKey: .budget)
        budget = budgetDecoded
        let notificationsWithSubscribersContainer = try containerValues.decodeIfPresent([BudgetsClientTypes.NotificationWithSubscribers?].self, forKey: .notificationsWithSubscribers)
        var notificationsWithSubscribersDecoded0:[BudgetsClientTypes.NotificationWithSubscribers]? = nil
        if let notificationsWithSubscribersContainer = notificationsWithSubscribersContainer {
            notificationsWithSubscribersDecoded0 = [BudgetsClientTypes.NotificationWithSubscribers]()
            for structure0 in notificationsWithSubscribersContainer {
                if let structure0 = structure0 {
                    notificationsWithSubscribersDecoded0?.append(structure0)
                }
            }
        }
        notificationsWithSubscribers = notificationsWithSubscribersDecoded0
    }
}

extension CreateBudgetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateBudgetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CreationLimitExceededException" : self = .creationLimitExceededException(try CreationLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DuplicateRecordException" : self = .duplicateRecordException(try DuplicateRecordException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateBudgetOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case creationLimitExceededException(CreationLimitExceededException)
    case duplicateRecordException(DuplicateRecordException)
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateBudgetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

/// Response of CreateBudget
public struct CreateBudgetOutputResponse: Swift.Equatable {

    public init () { }
}

extension CreateNotificationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case budgetName = "BudgetName"
        case notification = "Notification"
        case subscribers = "Subscribers"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let budgetName = self.budgetName {
            try encodeContainer.encode(budgetName, forKey: .budgetName)
        }
        if let notification = self.notification {
            try encodeContainer.encode(notification, forKey: .notification)
        }
        if let subscribers = subscribers {
            var subscribersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subscribers)
            for subscriber0 in subscribers {
                try subscribersContainer.encode(subscriber0)
            }
        }
    }
}

extension CreateNotificationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Request of CreateNotification
public struct CreateNotificationInput: Swift.Equatable {
    /// The accountId that is associated with the budget that you want to create a notification for.
    /// This member is required.
    public var accountId: Swift.String?
    /// The name of the budget that you want Amazon Web Services to notify you about. Budget names must be unique within an account.
    /// This member is required.
    public var budgetName: Swift.String?
    /// The notification that you want to create.
    /// This member is required.
    public var notification: BudgetsClientTypes.Notification?
    /// A list of subscribers that you want to associate with the notification. Each notification can have one SNS subscriber and up to 10 email subscribers.
    /// This member is required.
    public var subscribers: [BudgetsClientTypes.Subscriber]?

    public init (
        accountId: Swift.String? = nil,
        budgetName: Swift.String? = nil,
        notification: BudgetsClientTypes.Notification? = nil,
        subscribers: [BudgetsClientTypes.Subscriber]? = nil
    )
    {
        self.accountId = accountId
        self.budgetName = budgetName
        self.notification = notification
        self.subscribers = subscribers
    }
}

struct CreateNotificationInputBody: Swift.Equatable {
    let accountId: Swift.String?
    let budgetName: Swift.String?
    let notification: BudgetsClientTypes.Notification?
    let subscribers: [BudgetsClientTypes.Subscriber]?
}

extension CreateNotificationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case budgetName = "BudgetName"
        case notification = "Notification"
        case subscribers = "Subscribers"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let budgetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .budgetName)
        budgetName = budgetNameDecoded
        let notificationDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.Notification.self, forKey: .notification)
        notification = notificationDecoded
        let subscribersContainer = try containerValues.decodeIfPresent([BudgetsClientTypes.Subscriber?].self, forKey: .subscribers)
        var subscribersDecoded0:[BudgetsClientTypes.Subscriber]? = nil
        if let subscribersContainer = subscribersContainer {
            subscribersDecoded0 = [BudgetsClientTypes.Subscriber]()
            for structure0 in subscribersContainer {
                if let structure0 = structure0 {
                    subscribersDecoded0?.append(structure0)
                }
            }
        }
        subscribers = subscribersDecoded0
    }
}

extension CreateNotificationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateNotificationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CreationLimitExceededException" : self = .creationLimitExceededException(try CreationLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DuplicateRecordException" : self = .duplicateRecordException(try DuplicateRecordException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateNotificationOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case creationLimitExceededException(CreationLimitExceededException)
    case duplicateRecordException(DuplicateRecordException)
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notFoundException(NotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateNotificationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

/// Response of CreateNotification
public struct CreateNotificationOutputResponse: Swift.Equatable {

    public init () { }
}

extension CreateSubscriberInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case budgetName = "BudgetName"
        case notification = "Notification"
        case subscriber = "Subscriber"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let budgetName = self.budgetName {
            try encodeContainer.encode(budgetName, forKey: .budgetName)
        }
        if let notification = self.notification {
            try encodeContainer.encode(notification, forKey: .notification)
        }
        if let subscriber = self.subscriber {
            try encodeContainer.encode(subscriber, forKey: .subscriber)
        }
    }
}

extension CreateSubscriberInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Request of CreateSubscriber
public struct CreateSubscriberInput: Swift.Equatable {
    /// The accountId that is associated with the budget that you want to create a subscriber for.
    /// This member is required.
    public var accountId: Swift.String?
    /// The name of the budget that you want to subscribe to. Budget names must be unique within an account.
    /// This member is required.
    public var budgetName: Swift.String?
    /// The notification that you want to create a subscriber for.
    /// This member is required.
    public var notification: BudgetsClientTypes.Notification?
    /// The subscriber that you want to associate with a budget notification.
    /// This member is required.
    public var subscriber: BudgetsClientTypes.Subscriber?

    public init (
        accountId: Swift.String? = nil,
        budgetName: Swift.String? = nil,
        notification: BudgetsClientTypes.Notification? = nil,
        subscriber: BudgetsClientTypes.Subscriber? = nil
    )
    {
        self.accountId = accountId
        self.budgetName = budgetName
        self.notification = notification
        self.subscriber = subscriber
    }
}

struct CreateSubscriberInputBody: Swift.Equatable {
    let accountId: Swift.String?
    let budgetName: Swift.String?
    let notification: BudgetsClientTypes.Notification?
    let subscriber: BudgetsClientTypes.Subscriber?
}

extension CreateSubscriberInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case budgetName = "BudgetName"
        case notification = "Notification"
        case subscriber = "Subscriber"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let budgetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .budgetName)
        budgetName = budgetNameDecoded
        let notificationDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.Notification.self, forKey: .notification)
        notification = notificationDecoded
        let subscriberDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.Subscriber.self, forKey: .subscriber)
        subscriber = subscriberDecoded
    }
}

extension CreateSubscriberOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateSubscriberOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "CreationLimitExceededException" : self = .creationLimitExceededException(try CreationLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DuplicateRecordException" : self = .duplicateRecordException(try DuplicateRecordException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateSubscriberOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case creationLimitExceededException(CreationLimitExceededException)
    case duplicateRecordException(DuplicateRecordException)
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notFoundException(NotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateSubscriberOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

/// Response of CreateSubscriber
public struct CreateSubscriberOutputResponse: Swift.Equatable {

    public init () { }
}

extension CreationLimitExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreationLimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You've exceeded the notification or subscriber limit.
public struct CreationLimitExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The error message the exception carries.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct CreationLimitExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension CreationLimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension BudgetsClientTypes.Definition: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case iamActionDefinition = "IamActionDefinition"
        case scpActionDefinition = "ScpActionDefinition"
        case ssmActionDefinition = "SsmActionDefinition"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let iamActionDefinition = self.iamActionDefinition {
            try encodeContainer.encode(iamActionDefinition, forKey: .iamActionDefinition)
        }
        if let scpActionDefinition = self.scpActionDefinition {
            try encodeContainer.encode(scpActionDefinition, forKey: .scpActionDefinition)
        }
        if let ssmActionDefinition = self.ssmActionDefinition {
            try encodeContainer.encode(ssmActionDefinition, forKey: .ssmActionDefinition)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let iamActionDefinitionDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.IamActionDefinition.self, forKey: .iamActionDefinition)
        iamActionDefinition = iamActionDefinitionDecoded
        let scpActionDefinitionDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.ScpActionDefinition.self, forKey: .scpActionDefinition)
        scpActionDefinition = scpActionDefinitionDecoded
        let ssmActionDefinitionDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.SsmActionDefinition.self, forKey: .ssmActionDefinition)
        ssmActionDefinition = ssmActionDefinitionDecoded
    }
}

extension BudgetsClientTypes {
    /// Specifies all of the type-specific parameters.
    public struct Definition: Swift.Equatable {
        /// The Identity and Access Management (IAM) action definition details.
        public var iamActionDefinition: BudgetsClientTypes.IamActionDefinition?
        /// The service control policies (SCPs) action definition details.
        public var scpActionDefinition: BudgetsClientTypes.ScpActionDefinition?
        /// The Amazon Web Services Systems Manager (SSM) action definition details.
        public var ssmActionDefinition: BudgetsClientTypes.SsmActionDefinition?

        public init (
            iamActionDefinition: BudgetsClientTypes.IamActionDefinition? = nil,
            scpActionDefinition: BudgetsClientTypes.ScpActionDefinition? = nil,
            ssmActionDefinition: BudgetsClientTypes.SsmActionDefinition? = nil
        )
        {
            self.iamActionDefinition = iamActionDefinition
            self.scpActionDefinition = scpActionDefinition
            self.ssmActionDefinition = ssmActionDefinition
        }
    }

}

extension DeleteBudgetActionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case actionId = "ActionId"
        case budgetName = "BudgetName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let actionId = self.actionId {
            try encodeContainer.encode(actionId, forKey: .actionId)
        }
        if let budgetName = self.budgetName {
            try encodeContainer.encode(budgetName, forKey: .budgetName)
        }
    }
}

extension DeleteBudgetActionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteBudgetActionInput: Swift.Equatable {
    /// The account ID of the user. It's a 12-digit number.
    /// This member is required.
    public var accountId: Swift.String?
    /// A system-generated universally unique identifier (UUID) for the action.
    /// This member is required.
    public var actionId: Swift.String?
    /// A string that represents the budget name. The ":" and "\" characters aren't allowed.
    /// This member is required.
    public var budgetName: Swift.String?

    public init (
        accountId: Swift.String? = nil,
        actionId: Swift.String? = nil,
        budgetName: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.actionId = actionId
        self.budgetName = budgetName
    }
}

struct DeleteBudgetActionInputBody: Swift.Equatable {
    let accountId: Swift.String?
    let budgetName: Swift.String?
    let actionId: Swift.String?
}

extension DeleteBudgetActionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case actionId = "ActionId"
        case budgetName = "BudgetName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let budgetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .budgetName)
        budgetName = budgetNameDecoded
        let actionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .actionId)
        actionId = actionIdDecoded
    }
}

extension DeleteBudgetActionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteBudgetActionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLockedException" : self = .resourceLockedException(try ResourceLockedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteBudgetActionOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notFoundException(NotFoundException)
    case resourceLockedException(ResourceLockedException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteBudgetActionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DeleteBudgetActionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.accountId = output.accountId
            self.action = output.action
            self.budgetName = output.budgetName
        } else {
            self.accountId = nil
            self.action = nil
            self.budgetName = nil
        }
    }
}

public struct DeleteBudgetActionOutputResponse: Swift.Equatable {
    /// The account ID of the user. It's a 12-digit number.
    /// This member is required.
    public var accountId: Swift.String?
    /// A budget action resource.
    /// This member is required.
    public var action: BudgetsClientTypes.Action?
    /// A string that represents the budget name. The ":" and "\" characters aren't allowed.
    /// This member is required.
    public var budgetName: Swift.String?

    public init (
        accountId: Swift.String? = nil,
        action: BudgetsClientTypes.Action? = nil,
        budgetName: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.action = action
        self.budgetName = budgetName
    }
}

struct DeleteBudgetActionOutputResponseBody: Swift.Equatable {
    let accountId: Swift.String?
    let budgetName: Swift.String?
    let action: BudgetsClientTypes.Action?
}

extension DeleteBudgetActionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case action = "Action"
        case budgetName = "BudgetName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let budgetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .budgetName)
        budgetName = budgetNameDecoded
        let actionDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.Action.self, forKey: .action)
        action = actionDecoded
    }
}

extension DeleteBudgetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case budgetName = "BudgetName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let budgetName = self.budgetName {
            try encodeContainer.encode(budgetName, forKey: .budgetName)
        }
    }
}

extension DeleteBudgetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Request of DeleteBudget
public struct DeleteBudgetInput: Swift.Equatable {
    /// The accountId that is associated with the budget that you want to delete.
    /// This member is required.
    public var accountId: Swift.String?
    /// The name of the budget that you want to delete.
    /// This member is required.
    public var budgetName: Swift.String?

    public init (
        accountId: Swift.String? = nil,
        budgetName: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.budgetName = budgetName
    }
}

struct DeleteBudgetInputBody: Swift.Equatable {
    let accountId: Swift.String?
    let budgetName: Swift.String?
}

extension DeleteBudgetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case budgetName = "BudgetName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let budgetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .budgetName)
        budgetName = budgetNameDecoded
    }
}

extension DeleteBudgetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteBudgetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteBudgetOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notFoundException(NotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteBudgetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

/// Response of DeleteBudget
public struct DeleteBudgetOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteNotificationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case budgetName = "BudgetName"
        case notification = "Notification"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let budgetName = self.budgetName {
            try encodeContainer.encode(budgetName, forKey: .budgetName)
        }
        if let notification = self.notification {
            try encodeContainer.encode(notification, forKey: .notification)
        }
    }
}

extension DeleteNotificationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Request of DeleteNotification
public struct DeleteNotificationInput: Swift.Equatable {
    /// The accountId that is associated with the budget whose notification you want to delete.
    /// This member is required.
    public var accountId: Swift.String?
    /// The name of the budget whose notification you want to delete.
    /// This member is required.
    public var budgetName: Swift.String?
    /// The notification that you want to delete.
    /// This member is required.
    public var notification: BudgetsClientTypes.Notification?

    public init (
        accountId: Swift.String? = nil,
        budgetName: Swift.String? = nil,
        notification: BudgetsClientTypes.Notification? = nil
    )
    {
        self.accountId = accountId
        self.budgetName = budgetName
        self.notification = notification
    }
}

struct DeleteNotificationInputBody: Swift.Equatable {
    let accountId: Swift.String?
    let budgetName: Swift.String?
    let notification: BudgetsClientTypes.Notification?
}

extension DeleteNotificationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case budgetName = "BudgetName"
        case notification = "Notification"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let budgetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .budgetName)
        budgetName = budgetNameDecoded
        let notificationDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.Notification.self, forKey: .notification)
        notification = notificationDecoded
    }
}

extension DeleteNotificationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteNotificationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteNotificationOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notFoundException(NotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteNotificationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

/// Response of DeleteNotification
public struct DeleteNotificationOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteSubscriberInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case budgetName = "BudgetName"
        case notification = "Notification"
        case subscriber = "Subscriber"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let budgetName = self.budgetName {
            try encodeContainer.encode(budgetName, forKey: .budgetName)
        }
        if let notification = self.notification {
            try encodeContainer.encode(notification, forKey: .notification)
        }
        if let subscriber = self.subscriber {
            try encodeContainer.encode(subscriber, forKey: .subscriber)
        }
    }
}

extension DeleteSubscriberInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Request of DeleteSubscriber
public struct DeleteSubscriberInput: Swift.Equatable {
    /// The accountId that is associated with the budget whose subscriber you want to delete.
    /// This member is required.
    public var accountId: Swift.String?
    /// The name of the budget whose subscriber you want to delete.
    /// This member is required.
    public var budgetName: Swift.String?
    /// The notification whose subscriber you want to delete.
    /// This member is required.
    public var notification: BudgetsClientTypes.Notification?
    /// The subscriber that you want to delete.
    /// This member is required.
    public var subscriber: BudgetsClientTypes.Subscriber?

    public init (
        accountId: Swift.String? = nil,
        budgetName: Swift.String? = nil,
        notification: BudgetsClientTypes.Notification? = nil,
        subscriber: BudgetsClientTypes.Subscriber? = nil
    )
    {
        self.accountId = accountId
        self.budgetName = budgetName
        self.notification = notification
        self.subscriber = subscriber
    }
}

struct DeleteSubscriberInputBody: Swift.Equatable {
    let accountId: Swift.String?
    let budgetName: Swift.String?
    let notification: BudgetsClientTypes.Notification?
    let subscriber: BudgetsClientTypes.Subscriber?
}

extension DeleteSubscriberInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case budgetName = "BudgetName"
        case notification = "Notification"
        case subscriber = "Subscriber"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let budgetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .budgetName)
        budgetName = budgetNameDecoded
        let notificationDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.Notification.self, forKey: .notification)
        notification = notificationDecoded
        let subscriberDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.Subscriber.self, forKey: .subscriber)
        subscriber = subscriberDecoded
    }
}

extension DeleteSubscriberOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteSubscriberOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteSubscriberOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notFoundException(NotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteSubscriberOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

/// Response of DeleteSubscriber
public struct DeleteSubscriberOutputResponse: Swift.Equatable {

    public init () { }
}

extension DescribeBudgetActionHistoriesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case actionId = "ActionId"
        case budgetName = "BudgetName"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case timePeriod = "TimePeriod"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let actionId = self.actionId {
            try encodeContainer.encode(actionId, forKey: .actionId)
        }
        if let budgetName = self.budgetName {
            try encodeContainer.encode(budgetName, forKey: .budgetName)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let timePeriod = self.timePeriod {
            try encodeContainer.encode(timePeriod, forKey: .timePeriod)
        }
    }
}

extension DescribeBudgetActionHistoriesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeBudgetActionHistoriesInput: Swift.Equatable {
    /// The account ID of the user. It's a 12-digit number.
    /// This member is required.
    public var accountId: Swift.String?
    /// A system-generated universally unique identifier (UUID) for the action.
    /// This member is required.
    public var actionId: Swift.String?
    /// A string that represents the budget name. The ":" and "\" characters aren't allowed.
    /// This member is required.
    public var budgetName: Swift.String?
    /// An integer that represents how many entries a paginated response contains. The maximum is 100.
    public var maxResults: Swift.Int?
    /// A generic string.
    public var nextToken: Swift.String?
    /// The period of time that's covered by a budget. The period has a start date and an end date. The start date must come before the end date. There are no restrictions on the end date.
    public var timePeriod: BudgetsClientTypes.TimePeriod?

    public init (
        accountId: Swift.String? = nil,
        actionId: Swift.String? = nil,
        budgetName: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        timePeriod: BudgetsClientTypes.TimePeriod? = nil
    )
    {
        self.accountId = accountId
        self.actionId = actionId
        self.budgetName = budgetName
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.timePeriod = timePeriod
    }
}

struct DescribeBudgetActionHistoriesInputBody: Swift.Equatable {
    let accountId: Swift.String?
    let budgetName: Swift.String?
    let actionId: Swift.String?
    let timePeriod: BudgetsClientTypes.TimePeriod?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension DescribeBudgetActionHistoriesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case actionId = "ActionId"
        case budgetName = "BudgetName"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case timePeriod = "TimePeriod"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let budgetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .budgetName)
        budgetName = budgetNameDecoded
        let actionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .actionId)
        actionId = actionIdDecoded
        let timePeriodDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.TimePeriod.self, forKey: .timePeriod)
        timePeriod = timePeriodDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeBudgetActionHistoriesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeBudgetActionHistoriesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeBudgetActionHistoriesOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalErrorException(InternalErrorException)
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidParameterException(InvalidParameterException)
    case notFoundException(NotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeBudgetActionHistoriesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeBudgetActionHistoriesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.actionHistories = output.actionHistories
            self.nextToken = output.nextToken
        } else {
            self.actionHistories = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeBudgetActionHistoriesOutputResponse: Swift.Equatable {
    /// The historical record of the budget action resource.
    /// This member is required.
    public var actionHistories: [BudgetsClientTypes.ActionHistory]?
    /// A generic string.
    public var nextToken: Swift.String?

    public init (
        actionHistories: [BudgetsClientTypes.ActionHistory]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.actionHistories = actionHistories
        self.nextToken = nextToken
    }
}

struct DescribeBudgetActionHistoriesOutputResponseBody: Swift.Equatable {
    let actionHistories: [BudgetsClientTypes.ActionHistory]?
    let nextToken: Swift.String?
}

extension DescribeBudgetActionHistoriesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actionHistories = "ActionHistories"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionHistoriesContainer = try containerValues.decodeIfPresent([BudgetsClientTypes.ActionHistory?].self, forKey: .actionHistories)
        var actionHistoriesDecoded0:[BudgetsClientTypes.ActionHistory]? = nil
        if let actionHistoriesContainer = actionHistoriesContainer {
            actionHistoriesDecoded0 = [BudgetsClientTypes.ActionHistory]()
            for structure0 in actionHistoriesContainer {
                if let structure0 = structure0 {
                    actionHistoriesDecoded0?.append(structure0)
                }
            }
        }
        actionHistories = actionHistoriesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeBudgetActionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case actionId = "ActionId"
        case budgetName = "BudgetName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let actionId = self.actionId {
            try encodeContainer.encode(actionId, forKey: .actionId)
        }
        if let budgetName = self.budgetName {
            try encodeContainer.encode(budgetName, forKey: .budgetName)
        }
    }
}

extension DescribeBudgetActionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeBudgetActionInput: Swift.Equatable {
    /// The account ID of the user. It's a 12-digit number.
    /// This member is required.
    public var accountId: Swift.String?
    /// A system-generated universally unique identifier (UUID) for the action.
    /// This member is required.
    public var actionId: Swift.String?
    /// A string that represents the budget name. The ":" and "\" characters aren't allowed.
    /// This member is required.
    public var budgetName: Swift.String?

    public init (
        accountId: Swift.String? = nil,
        actionId: Swift.String? = nil,
        budgetName: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.actionId = actionId
        self.budgetName = budgetName
    }
}

struct DescribeBudgetActionInputBody: Swift.Equatable {
    let accountId: Swift.String?
    let budgetName: Swift.String?
    let actionId: Swift.String?
}

extension DescribeBudgetActionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case actionId = "ActionId"
        case budgetName = "BudgetName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let budgetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .budgetName)
        budgetName = budgetNameDecoded
        let actionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .actionId)
        actionId = actionIdDecoded
    }
}

extension DescribeBudgetActionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeBudgetActionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeBudgetActionOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notFoundException(NotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeBudgetActionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeBudgetActionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.accountId = output.accountId
            self.action = output.action
            self.budgetName = output.budgetName
        } else {
            self.accountId = nil
            self.action = nil
            self.budgetName = nil
        }
    }
}

public struct DescribeBudgetActionOutputResponse: Swift.Equatable {
    /// The account ID of the user. It's a 12-digit number.
    /// This member is required.
    public var accountId: Swift.String?
    /// A budget action resource.
    /// This member is required.
    public var action: BudgetsClientTypes.Action?
    /// A string that represents the budget name. The ":" and "\" characters aren't allowed.
    /// This member is required.
    public var budgetName: Swift.String?

    public init (
        accountId: Swift.String? = nil,
        action: BudgetsClientTypes.Action? = nil,
        budgetName: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.action = action
        self.budgetName = budgetName
    }
}

struct DescribeBudgetActionOutputResponseBody: Swift.Equatable {
    let accountId: Swift.String?
    let budgetName: Swift.String?
    let action: BudgetsClientTypes.Action?
}

extension DescribeBudgetActionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case action = "Action"
        case budgetName = "BudgetName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let budgetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .budgetName)
        budgetName = budgetNameDecoded
        let actionDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.Action.self, forKey: .action)
        action = actionDecoded
    }
}

extension DescribeBudgetActionsForAccountInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension DescribeBudgetActionsForAccountInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeBudgetActionsForAccountInput: Swift.Equatable {
    /// The account ID of the user. It's a 12-digit number.
    /// This member is required.
    public var accountId: Swift.String?
    /// An integer that represents how many entries a paginated response contains. The maximum is 100.
    public var maxResults: Swift.Int?
    /// A generic string.
    public var nextToken: Swift.String?

    public init (
        accountId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeBudgetActionsForAccountInputBody: Swift.Equatable {
    let accountId: Swift.String?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension DescribeBudgetActionsForAccountInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeBudgetActionsForAccountOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeBudgetActionsForAccountOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeBudgetActionsForAccountOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalErrorException(InternalErrorException)
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidParameterException(InvalidParameterException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeBudgetActionsForAccountOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeBudgetActionsForAccountOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.actions = output.actions
            self.nextToken = output.nextToken
        } else {
            self.actions = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeBudgetActionsForAccountOutputResponse: Swift.Equatable {
    /// A list of the budget action resources information.
    /// This member is required.
    public var actions: [BudgetsClientTypes.Action]?
    /// A generic string.
    public var nextToken: Swift.String?

    public init (
        actions: [BudgetsClientTypes.Action]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.actions = actions
        self.nextToken = nextToken
    }
}

struct DescribeBudgetActionsForAccountOutputResponseBody: Swift.Equatable {
    let actions: [BudgetsClientTypes.Action]?
    let nextToken: Swift.String?
}

extension DescribeBudgetActionsForAccountOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actions = "Actions"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionsContainer = try containerValues.decodeIfPresent([BudgetsClientTypes.Action?].self, forKey: .actions)
        var actionsDecoded0:[BudgetsClientTypes.Action]? = nil
        if let actionsContainer = actionsContainer {
            actionsDecoded0 = [BudgetsClientTypes.Action]()
            for structure0 in actionsContainer {
                if let structure0 = structure0 {
                    actionsDecoded0?.append(structure0)
                }
            }
        }
        actions = actionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeBudgetActionsForBudgetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case budgetName = "BudgetName"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let budgetName = self.budgetName {
            try encodeContainer.encode(budgetName, forKey: .budgetName)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension DescribeBudgetActionsForBudgetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeBudgetActionsForBudgetInput: Swift.Equatable {
    /// The account ID of the user. It's a 12-digit number.
    /// This member is required.
    public var accountId: Swift.String?
    /// A string that represents the budget name. The ":" and "\" characters aren't allowed.
    /// This member is required.
    public var budgetName: Swift.String?
    /// An integer that represents how many entries a paginated response contains. The maximum is 100.
    public var maxResults: Swift.Int?
    /// A generic string.
    public var nextToken: Swift.String?

    public init (
        accountId: Swift.String? = nil,
        budgetName: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.budgetName = budgetName
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeBudgetActionsForBudgetInputBody: Swift.Equatable {
    let accountId: Swift.String?
    let budgetName: Swift.String?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension DescribeBudgetActionsForBudgetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case budgetName = "BudgetName"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let budgetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .budgetName)
        budgetName = budgetNameDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeBudgetActionsForBudgetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeBudgetActionsForBudgetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeBudgetActionsForBudgetOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalErrorException(InternalErrorException)
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidParameterException(InvalidParameterException)
    case notFoundException(NotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeBudgetActionsForBudgetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeBudgetActionsForBudgetOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.actions = output.actions
            self.nextToken = output.nextToken
        } else {
            self.actions = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeBudgetActionsForBudgetOutputResponse: Swift.Equatable {
    /// A list of the budget action resources information.
    /// This member is required.
    public var actions: [BudgetsClientTypes.Action]?
    /// A generic string.
    public var nextToken: Swift.String?

    public init (
        actions: [BudgetsClientTypes.Action]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.actions = actions
        self.nextToken = nextToken
    }
}

struct DescribeBudgetActionsForBudgetOutputResponseBody: Swift.Equatable {
    let actions: [BudgetsClientTypes.Action]?
    let nextToken: Swift.String?
}

extension DescribeBudgetActionsForBudgetOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actions = "Actions"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionsContainer = try containerValues.decodeIfPresent([BudgetsClientTypes.Action?].self, forKey: .actions)
        var actionsDecoded0:[BudgetsClientTypes.Action]? = nil
        if let actionsContainer = actionsContainer {
            actionsDecoded0 = [BudgetsClientTypes.Action]()
            for structure0 in actionsContainer {
                if let structure0 = structure0 {
                    actionsDecoded0?.append(structure0)
                }
            }
        }
        actions = actionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeBudgetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case budgetName = "BudgetName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let budgetName = self.budgetName {
            try encodeContainer.encode(budgetName, forKey: .budgetName)
        }
    }
}

extension DescribeBudgetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Request of DescribeBudget
public struct DescribeBudgetInput: Swift.Equatable {
    /// The accountId that is associated with the budget that you want a description of.
    /// This member is required.
    public var accountId: Swift.String?
    /// The name of the budget that you want a description of.
    /// This member is required.
    public var budgetName: Swift.String?

    public init (
        accountId: Swift.String? = nil,
        budgetName: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.budgetName = budgetName
    }
}

struct DescribeBudgetInputBody: Swift.Equatable {
    let accountId: Swift.String?
    let budgetName: Swift.String?
}

extension DescribeBudgetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case budgetName = "BudgetName"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let budgetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .budgetName)
        budgetName = budgetNameDecoded
    }
}

extension DescribeBudgetNotificationsForAccountInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension DescribeBudgetNotificationsForAccountInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeBudgetNotificationsForAccountInput: Swift.Equatable {
    /// The account ID of the user. It's a 12-digit number.
    /// This member is required.
    public var accountId: Swift.String?
    /// An integer that shows how many budget name entries a paginated response contains.
    public var maxResults: Swift.Int?
    /// A generic string.
    public var nextToken: Swift.String?

    public init (
        accountId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeBudgetNotificationsForAccountInputBody: Swift.Equatable {
    let accountId: Swift.String?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension DescribeBudgetNotificationsForAccountInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeBudgetNotificationsForAccountOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeBudgetNotificationsForAccountOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ExpiredNextTokenException" : self = .expiredNextTokenException(try ExpiredNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeBudgetNotificationsForAccountOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case expiredNextTokenException(ExpiredNextTokenException)
    case internalErrorException(InternalErrorException)
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidParameterException(InvalidParameterException)
    case notFoundException(NotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeBudgetNotificationsForAccountOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeBudgetNotificationsForAccountOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.budgetNotificationsForAccount = output.budgetNotificationsForAccount
            self.nextToken = output.nextToken
        } else {
            self.budgetNotificationsForAccount = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeBudgetNotificationsForAccountOutputResponse: Swift.Equatable {
    /// A list of budget names and associated notifications for an account.
    public var budgetNotificationsForAccount: [BudgetsClientTypes.BudgetNotificationsForAccount]?
    /// A generic string.
    public var nextToken: Swift.String?

    public init (
        budgetNotificationsForAccount: [BudgetsClientTypes.BudgetNotificationsForAccount]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.budgetNotificationsForAccount = budgetNotificationsForAccount
        self.nextToken = nextToken
    }
}

struct DescribeBudgetNotificationsForAccountOutputResponseBody: Swift.Equatable {
    let budgetNotificationsForAccount: [BudgetsClientTypes.BudgetNotificationsForAccount]?
    let nextToken: Swift.String?
}

extension DescribeBudgetNotificationsForAccountOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case budgetNotificationsForAccount = "BudgetNotificationsForAccount"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let budgetNotificationsForAccountContainer = try containerValues.decodeIfPresent([BudgetsClientTypes.BudgetNotificationsForAccount?].self, forKey: .budgetNotificationsForAccount)
        var budgetNotificationsForAccountDecoded0:[BudgetsClientTypes.BudgetNotificationsForAccount]? = nil
        if let budgetNotificationsForAccountContainer = budgetNotificationsForAccountContainer {
            budgetNotificationsForAccountDecoded0 = [BudgetsClientTypes.BudgetNotificationsForAccount]()
            for structure0 in budgetNotificationsForAccountContainer {
                if let structure0 = structure0 {
                    budgetNotificationsForAccountDecoded0?.append(structure0)
                }
            }
        }
        budgetNotificationsForAccount = budgetNotificationsForAccountDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeBudgetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeBudgetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeBudgetOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notFoundException(NotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeBudgetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeBudgetOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.budget = output.budget
        } else {
            self.budget = nil
        }
    }
}

/// Response of DescribeBudget
public struct DescribeBudgetOutputResponse: Swift.Equatable {
    /// The description of the budget.
    public var budget: BudgetsClientTypes.Budget?

    public init (
        budget: BudgetsClientTypes.Budget? = nil
    )
    {
        self.budget = budget
    }
}

struct DescribeBudgetOutputResponseBody: Swift.Equatable {
    let budget: BudgetsClientTypes.Budget?
}

extension DescribeBudgetOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case budget = "Budget"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let budgetDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.Budget.self, forKey: .budget)
        budget = budgetDecoded
    }
}

extension DescribeBudgetPerformanceHistoryInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case budgetName = "BudgetName"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case timePeriod = "TimePeriod"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let budgetName = self.budgetName {
            try encodeContainer.encode(budgetName, forKey: .budgetName)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let timePeriod = self.timePeriod {
            try encodeContainer.encode(timePeriod, forKey: .timePeriod)
        }
    }
}

extension DescribeBudgetPerformanceHistoryInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeBudgetPerformanceHistoryInput: Swift.Equatable {
    /// The account ID of the user. It's a 12-digit number.
    /// This member is required.
    public var accountId: Swift.String?
    /// A string that represents the budget name. The ":" and "\" characters aren't allowed.
    /// This member is required.
    public var budgetName: Swift.String?
    /// An integer that represents how many entries a paginated response contains. The maximum is 100.
    public var maxResults: Swift.Int?
    /// A generic string.
    public var nextToken: Swift.String?
    /// Retrieves how often the budget went into an ALARM state for the specified time period.
    public var timePeriod: BudgetsClientTypes.TimePeriod?

    public init (
        accountId: Swift.String? = nil,
        budgetName: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        timePeriod: BudgetsClientTypes.TimePeriod? = nil
    )
    {
        self.accountId = accountId
        self.budgetName = budgetName
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.timePeriod = timePeriod
    }
}

struct DescribeBudgetPerformanceHistoryInputBody: Swift.Equatable {
    let accountId: Swift.String?
    let budgetName: Swift.String?
    let timePeriod: BudgetsClientTypes.TimePeriod?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension DescribeBudgetPerformanceHistoryInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case budgetName = "BudgetName"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case timePeriod = "TimePeriod"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let budgetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .budgetName)
        budgetName = budgetNameDecoded
        let timePeriodDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.TimePeriod.self, forKey: .timePeriod)
        timePeriod = timePeriodDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeBudgetPerformanceHistoryOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeBudgetPerformanceHistoryOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ExpiredNextTokenException" : self = .expiredNextTokenException(try ExpiredNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeBudgetPerformanceHistoryOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case expiredNextTokenException(ExpiredNextTokenException)
    case internalErrorException(InternalErrorException)
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidParameterException(InvalidParameterException)
    case notFoundException(NotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeBudgetPerformanceHistoryOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeBudgetPerformanceHistoryOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.budgetPerformanceHistory = output.budgetPerformanceHistory
            self.nextToken = output.nextToken
        } else {
            self.budgetPerformanceHistory = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeBudgetPerformanceHistoryOutputResponse: Swift.Equatable {
    /// The history of how often the budget has gone into an ALARM state. For DAILY budgets, the history saves the state of the budget for the last 60 days. For MONTHLY budgets, the history saves the state of the budget for the current month plus the last 12 months. For QUARTERLY budgets, the history saves the state of the budget for the last four quarters.
    public var budgetPerformanceHistory: BudgetsClientTypes.BudgetPerformanceHistory?
    /// A generic string.
    public var nextToken: Swift.String?

    public init (
        budgetPerformanceHistory: BudgetsClientTypes.BudgetPerformanceHistory? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.budgetPerformanceHistory = budgetPerformanceHistory
        self.nextToken = nextToken
    }
}

struct DescribeBudgetPerformanceHistoryOutputResponseBody: Swift.Equatable {
    let budgetPerformanceHistory: BudgetsClientTypes.BudgetPerformanceHistory?
    let nextToken: Swift.String?
}

extension DescribeBudgetPerformanceHistoryOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case budgetPerformanceHistory = "BudgetPerformanceHistory"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let budgetPerformanceHistoryDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.BudgetPerformanceHistory.self, forKey: .budgetPerformanceHistory)
        budgetPerformanceHistory = budgetPerformanceHistoryDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeBudgetsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension DescribeBudgetsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Request of DescribeBudgets
public struct DescribeBudgetsInput: Swift.Equatable {
    /// The accountId that is associated with the budgets that you want descriptions of.
    /// This member is required.
    public var accountId: Swift.String?
    /// An optional integer that represents how many entries a paginated response contains. The maximum is 100.
    public var maxResults: Swift.Int?
    /// The pagination token that you include in your request to indicate the next set of results that you want to retrieve.
    public var nextToken: Swift.String?

    public init (
        accountId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeBudgetsInputBody: Swift.Equatable {
    let accountId: Swift.String?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension DescribeBudgetsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeBudgetsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeBudgetsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ExpiredNextTokenException" : self = .expiredNextTokenException(try ExpiredNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeBudgetsOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case expiredNextTokenException(ExpiredNextTokenException)
    case internalErrorException(InternalErrorException)
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidParameterException(InvalidParameterException)
    case notFoundException(NotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeBudgetsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeBudgetsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.budgets = output.budgets
            self.nextToken = output.nextToken
        } else {
            self.budgets = nil
            self.nextToken = nil
        }
    }
}

/// Response of DescribeBudgets
public struct DescribeBudgetsOutputResponse: Swift.Equatable {
    /// A list of budgets.
    public var budgets: [BudgetsClientTypes.Budget]?
    /// The pagination token in the service response that indicates the next set of results that you can retrieve.
    public var nextToken: Swift.String?

    public init (
        budgets: [BudgetsClientTypes.Budget]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.budgets = budgets
        self.nextToken = nextToken
    }
}

struct DescribeBudgetsOutputResponseBody: Swift.Equatable {
    let budgets: [BudgetsClientTypes.Budget]?
    let nextToken: Swift.String?
}

extension DescribeBudgetsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case budgets = "Budgets"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let budgetsContainer = try containerValues.decodeIfPresent([BudgetsClientTypes.Budget?].self, forKey: .budgets)
        var budgetsDecoded0:[BudgetsClientTypes.Budget]? = nil
        if let budgetsContainer = budgetsContainer {
            budgetsDecoded0 = [BudgetsClientTypes.Budget]()
            for structure0 in budgetsContainer {
                if let structure0 = structure0 {
                    budgetsDecoded0?.append(structure0)
                }
            }
        }
        budgets = budgetsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeNotificationsForBudgetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case budgetName = "BudgetName"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let budgetName = self.budgetName {
            try encodeContainer.encode(budgetName, forKey: .budgetName)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension DescribeNotificationsForBudgetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Request of DescribeNotificationsForBudget
public struct DescribeNotificationsForBudgetInput: Swift.Equatable {
    /// The accountId that is associated with the budget whose notifications you want descriptions of.
    /// This member is required.
    public var accountId: Swift.String?
    /// The name of the budget whose notifications you want descriptions of.
    /// This member is required.
    public var budgetName: Swift.String?
    /// An optional integer that represents how many entries a paginated response contains. The maximum is 100.
    public var maxResults: Swift.Int?
    /// The pagination token that you include in your request to indicate the next set of results that you want to retrieve.
    public var nextToken: Swift.String?

    public init (
        accountId: Swift.String? = nil,
        budgetName: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.budgetName = budgetName
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeNotificationsForBudgetInputBody: Swift.Equatable {
    let accountId: Swift.String?
    let budgetName: Swift.String?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension DescribeNotificationsForBudgetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case budgetName = "BudgetName"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let budgetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .budgetName)
        budgetName = budgetNameDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeNotificationsForBudgetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeNotificationsForBudgetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ExpiredNextTokenException" : self = .expiredNextTokenException(try ExpiredNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeNotificationsForBudgetOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case expiredNextTokenException(ExpiredNextTokenException)
    case internalErrorException(InternalErrorException)
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidParameterException(InvalidParameterException)
    case notFoundException(NotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeNotificationsForBudgetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeNotificationsForBudgetOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.notifications = output.notifications
        } else {
            self.nextToken = nil
            self.notifications = nil
        }
    }
}

/// Response of GetNotificationsForBudget
public struct DescribeNotificationsForBudgetOutputResponse: Swift.Equatable {
    /// The pagination token in the service response that indicates the next set of results that you can retrieve.
    public var nextToken: Swift.String?
    /// A list of notifications that are associated with a budget.
    public var notifications: [BudgetsClientTypes.Notification]?

    public init (
        nextToken: Swift.String? = nil,
        notifications: [BudgetsClientTypes.Notification]? = nil
    )
    {
        self.nextToken = nextToken
        self.notifications = notifications
    }
}

struct DescribeNotificationsForBudgetOutputResponseBody: Swift.Equatable {
    let notifications: [BudgetsClientTypes.Notification]?
    let nextToken: Swift.String?
}

extension DescribeNotificationsForBudgetOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case notifications = "Notifications"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let notificationsContainer = try containerValues.decodeIfPresent([BudgetsClientTypes.Notification?].self, forKey: .notifications)
        var notificationsDecoded0:[BudgetsClientTypes.Notification]? = nil
        if let notificationsContainer = notificationsContainer {
            notificationsDecoded0 = [BudgetsClientTypes.Notification]()
            for structure0 in notificationsContainer {
                if let structure0 = structure0 {
                    notificationsDecoded0?.append(structure0)
                }
            }
        }
        notifications = notificationsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeSubscribersForNotificationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case budgetName = "BudgetName"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case notification = "Notification"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let budgetName = self.budgetName {
            try encodeContainer.encode(budgetName, forKey: .budgetName)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let notification = self.notification {
            try encodeContainer.encode(notification, forKey: .notification)
        }
    }
}

extension DescribeSubscribersForNotificationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Request of DescribeSubscribersForNotification
public struct DescribeSubscribersForNotificationInput: Swift.Equatable {
    /// The accountId that is associated with the budget whose subscribers you want descriptions of.
    /// This member is required.
    public var accountId: Swift.String?
    /// The name of the budget whose subscribers you want descriptions of.
    /// This member is required.
    public var budgetName: Swift.String?
    /// An optional integer that represents how many entries a paginated response contains. The maximum is 100.
    public var maxResults: Swift.Int?
    /// The pagination token that you include in your request to indicate the next set of results that you want to retrieve.
    public var nextToken: Swift.String?
    /// The notification whose subscribers you want to list.
    /// This member is required.
    public var notification: BudgetsClientTypes.Notification?

    public init (
        accountId: Swift.String? = nil,
        budgetName: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        notification: BudgetsClientTypes.Notification? = nil
    )
    {
        self.accountId = accountId
        self.budgetName = budgetName
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.notification = notification
    }
}

struct DescribeSubscribersForNotificationInputBody: Swift.Equatable {
    let accountId: Swift.String?
    let budgetName: Swift.String?
    let notification: BudgetsClientTypes.Notification?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension DescribeSubscribersForNotificationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case budgetName = "BudgetName"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case notification = "Notification"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let budgetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .budgetName)
        budgetName = budgetNameDecoded
        let notificationDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.Notification.self, forKey: .notification)
        notification = notificationDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeSubscribersForNotificationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeSubscribersForNotificationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ExpiredNextTokenException" : self = .expiredNextTokenException(try ExpiredNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidNextTokenException" : self = .invalidNextTokenException(try InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeSubscribersForNotificationOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case expiredNextTokenException(ExpiredNextTokenException)
    case internalErrorException(InternalErrorException)
    case invalidNextTokenException(InvalidNextTokenException)
    case invalidParameterException(InvalidParameterException)
    case notFoundException(NotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeSubscribersForNotificationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeSubscribersForNotificationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.subscribers = output.subscribers
        } else {
            self.nextToken = nil
            self.subscribers = nil
        }
    }
}

/// Response of DescribeSubscribersForNotification
public struct DescribeSubscribersForNotificationOutputResponse: Swift.Equatable {
    /// The pagination token in the service response that indicates the next set of results that you can retrieve.
    public var nextToken: Swift.String?
    /// A list of subscribers that are associated with a notification.
    public var subscribers: [BudgetsClientTypes.Subscriber]?

    public init (
        nextToken: Swift.String? = nil,
        subscribers: [BudgetsClientTypes.Subscriber]? = nil
    )
    {
        self.nextToken = nextToken
        self.subscribers = subscribers
    }
}

struct DescribeSubscribersForNotificationOutputResponseBody: Swift.Equatable {
    let subscribers: [BudgetsClientTypes.Subscriber]?
    let nextToken: Swift.String?
}

extension DescribeSubscribersForNotificationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case subscribers = "Subscribers"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subscribersContainer = try containerValues.decodeIfPresent([BudgetsClientTypes.Subscriber?].self, forKey: .subscribers)
        var subscribersDecoded0:[BudgetsClientTypes.Subscriber]? = nil
        if let subscribersContainer = subscribersContainer {
            subscribersDecoded0 = [BudgetsClientTypes.Subscriber]()
            for structure0 in subscribersContainer {
                if let structure0 = structure0 {
                    subscribersDecoded0?.append(structure0)
                }
            }
        }
        subscribers = subscribersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DuplicateRecordException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DuplicateRecordExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The budget name already exists. Budget names must be unique within an account.
public struct DuplicateRecordException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The error message the exception carries.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct DuplicateRecordExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension DuplicateRecordExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension BudgetsClientTypes {
    public enum EventType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case createaction
        case deleteaction
        case executeaction
        case system
        case updateaction
        case sdkUnknown(Swift.String)

        public static var allCases: [EventType] {
            return [
                .createaction,
                .deleteaction,
                .executeaction,
                .system,
                .updateaction,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .createaction: return "CREATE_ACTION"
            case .deleteaction: return "DELETE_ACTION"
            case .executeaction: return "EXECUTE_ACTION"
            case .system: return "SYSTEM"
            case .updateaction: return "UPDATE_ACTION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EventType(rawValue: rawValue) ?? EventType.sdkUnknown(rawValue)
        }
    }
}

extension ExecuteBudgetActionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case actionId = "ActionId"
        case budgetName = "BudgetName"
        case executionType = "ExecutionType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let actionId = self.actionId {
            try encodeContainer.encode(actionId, forKey: .actionId)
        }
        if let budgetName = self.budgetName {
            try encodeContainer.encode(budgetName, forKey: .budgetName)
        }
        if let executionType = self.executionType {
            try encodeContainer.encode(executionType.rawValue, forKey: .executionType)
        }
    }
}

extension ExecuteBudgetActionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ExecuteBudgetActionInput: Swift.Equatable {
    /// The account ID of the user. It's a 12-digit number.
    /// This member is required.
    public var accountId: Swift.String?
    /// A system-generated universally unique identifier (UUID) for the action.
    /// This member is required.
    public var actionId: Swift.String?
    /// A string that represents the budget name. The ":" and "\" characters aren't allowed.
    /// This member is required.
    public var budgetName: Swift.String?
    /// The type of execution.
    /// This member is required.
    public var executionType: BudgetsClientTypes.ExecutionType?

    public init (
        accountId: Swift.String? = nil,
        actionId: Swift.String? = nil,
        budgetName: Swift.String? = nil,
        executionType: BudgetsClientTypes.ExecutionType? = nil
    )
    {
        self.accountId = accountId
        self.actionId = actionId
        self.budgetName = budgetName
        self.executionType = executionType
    }
}

struct ExecuteBudgetActionInputBody: Swift.Equatable {
    let accountId: Swift.String?
    let budgetName: Swift.String?
    let actionId: Swift.String?
    let executionType: BudgetsClientTypes.ExecutionType?
}

extension ExecuteBudgetActionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case actionId = "ActionId"
        case budgetName = "BudgetName"
        case executionType = "ExecutionType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let budgetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .budgetName)
        budgetName = budgetNameDecoded
        let actionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .actionId)
        actionId = actionIdDecoded
        let executionTypeDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.ExecutionType.self, forKey: .executionType)
        executionType = executionTypeDecoded
    }
}

extension ExecuteBudgetActionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ExecuteBudgetActionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLockedException" : self = .resourceLockedException(try ResourceLockedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ExecuteBudgetActionOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notFoundException(NotFoundException)
    case resourceLockedException(ResourceLockedException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ExecuteBudgetActionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ExecuteBudgetActionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.accountId = output.accountId
            self.actionId = output.actionId
            self.budgetName = output.budgetName
            self.executionType = output.executionType
        } else {
            self.accountId = nil
            self.actionId = nil
            self.budgetName = nil
            self.executionType = nil
        }
    }
}

public struct ExecuteBudgetActionOutputResponse: Swift.Equatable {
    /// The account ID of the user. It's a 12-digit number.
    /// This member is required.
    public var accountId: Swift.String?
    /// A system-generated universally unique identifier (UUID) for the action.
    /// This member is required.
    public var actionId: Swift.String?
    /// A string that represents the budget name. The ":" and "\" characters aren't allowed.
    /// This member is required.
    public var budgetName: Swift.String?
    /// The type of execution.
    /// This member is required.
    public var executionType: BudgetsClientTypes.ExecutionType?

    public init (
        accountId: Swift.String? = nil,
        actionId: Swift.String? = nil,
        budgetName: Swift.String? = nil,
        executionType: BudgetsClientTypes.ExecutionType? = nil
    )
    {
        self.accountId = accountId
        self.actionId = actionId
        self.budgetName = budgetName
        self.executionType = executionType
    }
}

struct ExecuteBudgetActionOutputResponseBody: Swift.Equatable {
    let accountId: Swift.String?
    let budgetName: Swift.String?
    let actionId: Swift.String?
    let executionType: BudgetsClientTypes.ExecutionType?
}

extension ExecuteBudgetActionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case actionId = "ActionId"
        case budgetName = "BudgetName"
        case executionType = "ExecutionType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let budgetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .budgetName)
        budgetName = budgetNameDecoded
        let actionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .actionId)
        actionId = actionIdDecoded
        let executionTypeDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.ExecutionType.self, forKey: .executionType)
        executionType = executionTypeDecoded
    }
}

extension BudgetsClientTypes {
    public enum ExecutionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case approvebudgetaction
        case resetbudgetaction
        case retrybudgetaction
        case reversebudgetaction
        case sdkUnknown(Swift.String)

        public static var allCases: [ExecutionType] {
            return [
                .approvebudgetaction,
                .resetbudgetaction,
                .retrybudgetaction,
                .reversebudgetaction,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .approvebudgetaction: return "APPROVE_BUDGET_ACTION"
            case .resetbudgetaction: return "RESET_BUDGET_ACTION"
            case .retrybudgetaction: return "RETRY_BUDGET_ACTION"
            case .reversebudgetaction: return "REVERSE_BUDGET_ACTION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ExecutionType(rawValue: rawValue) ?? ExecutionType.sdkUnknown(rawValue)
        }
    }
}

extension ExpiredNextTokenException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ExpiredNextTokenExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The pagination token expired.
public struct ExpiredNextTokenException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The error message the exception carries.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ExpiredNextTokenExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ExpiredNextTokenExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension BudgetsClientTypes.HistoricalOptions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case budgetAdjustmentPeriod = "BudgetAdjustmentPeriod"
        case lookBackAvailablePeriods = "LookBackAvailablePeriods"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let budgetAdjustmentPeriod = self.budgetAdjustmentPeriod {
            try encodeContainer.encode(budgetAdjustmentPeriod, forKey: .budgetAdjustmentPeriod)
        }
        if let lookBackAvailablePeriods = self.lookBackAvailablePeriods {
            try encodeContainer.encode(lookBackAvailablePeriods, forKey: .lookBackAvailablePeriods)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let budgetAdjustmentPeriodDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .budgetAdjustmentPeriod)
        budgetAdjustmentPeriod = budgetAdjustmentPeriodDecoded
        let lookBackAvailablePeriodsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .lookBackAvailablePeriods)
        lookBackAvailablePeriods = lookBackAvailablePeriodsDecoded
    }
}

extension BudgetsClientTypes {
    /// The parameters that define or describe the historical data that your auto-adjusting budget is based on.
    public struct HistoricalOptions: Swift.Equatable {
        /// The number of budget periods included in the moving-average calculation that determines your auto-adjusted budget amount. The maximum value depends on the TimeUnit granularity of the budget:
        ///
        /// * For the DAILY granularity, the maximum value is 60.
        ///
        /// * For the MONTHLY granularity, the maximum value is 12.
        ///
        /// * For the QUARTERLY granularity, the maximum value is 4.
        ///
        /// * For the ANNUALLY granularity, the maximum value is 1.
        /// This member is required.
        public var budgetAdjustmentPeriod: Swift.Int?
        /// The integer that describes how many budget periods in your BudgetAdjustmentPeriod are included in the calculation of your current BudgetLimit. If the first budget period in your BudgetAdjustmentPeriod has no cost data, then that budget period isn’t included in the average that determines your budget limit. For example, if you set BudgetAdjustmentPeriod as 4 quarters, but your account had no cost data in the first quarter, then only the last three quarters are included in the calculation. In this scenario, LookBackAvailablePeriods returns 3. You can’t set your own LookBackAvailablePeriods. The value is automatically calculated from the BudgetAdjustmentPeriod and your historical cost data.
        public var lookBackAvailablePeriods: Swift.Int?

        public init (
            budgetAdjustmentPeriod: Swift.Int? = nil,
            lookBackAvailablePeriods: Swift.Int? = nil
        )
        {
            self.budgetAdjustmentPeriod = budgetAdjustmentPeriod
            self.lookBackAvailablePeriods = lookBackAvailablePeriods
        }
    }

}

extension BudgetsClientTypes.IamActionDefinition: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groups = "Groups"
        case policyArn = "PolicyArn"
        case roles = "Roles"
        case users = "Users"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let groups = groups {
            var groupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .groups)
            for group0 in groups {
                try groupsContainer.encode(group0)
            }
        }
        if let policyArn = self.policyArn {
            try encodeContainer.encode(policyArn, forKey: .policyArn)
        }
        if let roles = roles {
            var rolesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .roles)
            for role0 in roles {
                try rolesContainer.encode(role0)
            }
        }
        if let users = users {
            var usersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .users)
            for user0 in users {
                try usersContainer.encode(user0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyArn)
        policyArn = policyArnDecoded
        let rolesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .roles)
        var rolesDecoded0:[Swift.String]? = nil
        if let rolesContainer = rolesContainer {
            rolesDecoded0 = [Swift.String]()
            for string0 in rolesContainer {
                if let string0 = string0 {
                    rolesDecoded0?.append(string0)
                }
            }
        }
        roles = rolesDecoded0
        let groupsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .groups)
        var groupsDecoded0:[Swift.String]? = nil
        if let groupsContainer = groupsContainer {
            groupsDecoded0 = [Swift.String]()
            for string0 in groupsContainer {
                if let string0 = string0 {
                    groupsDecoded0?.append(string0)
                }
            }
        }
        groups = groupsDecoded0
        let usersContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .users)
        var usersDecoded0:[Swift.String]? = nil
        if let usersContainer = usersContainer {
            usersDecoded0 = [Swift.String]()
            for string0 in usersContainer {
                if let string0 = string0 {
                    usersDecoded0?.append(string0)
                }
            }
        }
        users = usersDecoded0
    }
}

extension BudgetsClientTypes {
    /// The Identity and Access Management (IAM) action definition details.
    public struct IamActionDefinition: Swift.Equatable {
        /// A list of groups to be attached. There must be at least one group.
        public var groups: [Swift.String]?
        /// The Amazon Resource Name (ARN) of the policy to be attached.
        /// This member is required.
        public var policyArn: Swift.String?
        /// A list of roles to be attached. There must be at least one role.
        public var roles: [Swift.String]?
        /// A list of users to be attached. There must be at least one user.
        public var users: [Swift.String]?

        public init (
            groups: [Swift.String]? = nil,
            policyArn: Swift.String? = nil,
            roles: [Swift.String]? = nil,
            users: [Swift.String]? = nil
        )
        {
            self.groups = groups
            self.policyArn = policyArn
            self.roles = roles
            self.users = users
        }
    }

}

extension InternalErrorException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InternalErrorExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// An error on the server occurred during the processing of your request. Try again later.
public struct InternalErrorException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    /// The error message the exception carries.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InternalErrorExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalErrorExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidNextTokenException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidNextTokenExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The pagination token is invalid.
public struct InvalidNextTokenException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The error message the exception carries.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidNextTokenExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidNextTokenExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidParameterException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidParameterExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// An error on the client occurred. Typically, the cause is an invalid input value.
public struct InvalidParameterException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The error message the exception carries.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidParameterExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidParameterExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NotFoundException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: NotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// We can’t locate the resource that you specified.
public struct NotFoundException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The error message the exception carries.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct NotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension NotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension BudgetsClientTypes.Notification: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case comparisonOperator = "ComparisonOperator"
        case notificationState = "NotificationState"
        case notificationType = "NotificationType"
        case threshold = "Threshold"
        case thresholdType = "ThresholdType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let comparisonOperator = self.comparisonOperator {
            try encodeContainer.encode(comparisonOperator.rawValue, forKey: .comparisonOperator)
        }
        if let notificationState = self.notificationState {
            try encodeContainer.encode(notificationState.rawValue, forKey: .notificationState)
        }
        if let notificationType = self.notificationType {
            try encodeContainer.encode(notificationType.rawValue, forKey: .notificationType)
        }
        if threshold != 0.0 {
            try encodeContainer.encode(threshold, forKey: .threshold)
        }
        if let thresholdType = self.thresholdType {
            try encodeContainer.encode(thresholdType.rawValue, forKey: .thresholdType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let notificationTypeDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.NotificationType.self, forKey: .notificationType)
        notificationType = notificationTypeDecoded
        let comparisonOperatorDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.ComparisonOperator.self, forKey: .comparisonOperator)
        comparisonOperator = comparisonOperatorDecoded
        let thresholdDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .threshold) ?? 0.0
        threshold = thresholdDecoded
        let thresholdTypeDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.ThresholdType.self, forKey: .thresholdType)
        thresholdType = thresholdTypeDecoded
        let notificationStateDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.NotificationState.self, forKey: .notificationState)
        notificationState = notificationStateDecoded
    }
}

extension BudgetsClientTypes {
    /// A notification that's associated with a budget. A budget can have up to ten notifications. Each notification must have at least one subscriber. A notification can have one SNS subscriber and up to 10 email subscribers, for a total of 11 subscribers. For example, if you have a budget for 200 dollars and you want to be notified when you go over 160 dollars, create a notification with the following parameters:
    ///
    /// * A notificationType of ACTUAL
    ///
    /// * A thresholdType of PERCENTAGE
    ///
    /// * A comparisonOperator of GREATER_THAN
    ///
    /// * A notification threshold of 80
    public struct Notification: Swift.Equatable {
        /// The comparison that's used for this notification.
        /// This member is required.
        public var comparisonOperator: BudgetsClientTypes.ComparisonOperator?
        /// Specifies whether this notification is in alarm. If a budget notification is in the ALARM state, you passed the set threshold for the budget.
        public var notificationState: BudgetsClientTypes.NotificationState?
        /// Specifies whether the notification is for how much you have spent (ACTUAL) or for how much that you're forecasted to spend (FORECASTED).
        /// This member is required.
        public var notificationType: BudgetsClientTypes.NotificationType?
        /// The threshold that's associated with a notification. Thresholds are always a percentage, and many customers find value being alerted between 50% - 200% of the budgeted amount. The maximum limit for your threshold is 1,000,000% above the budgeted amount.
        /// This member is required.
        public var threshold: Swift.Double
        /// The type of threshold for a notification. For ABSOLUTE_VALUE thresholds, Amazon Web Services notifies you when you go over or are forecasted to go over your total cost threshold. For PERCENTAGE thresholds, Amazon Web Services notifies you when you go over or are forecasted to go over a certain percentage of your forecasted spend. For example, if you have a budget for 200 dollars and you have a PERCENTAGE threshold of 80%, Amazon Web Services notifies you when you go over 160 dollars.
        public var thresholdType: BudgetsClientTypes.ThresholdType?

        public init (
            comparisonOperator: BudgetsClientTypes.ComparisonOperator? = nil,
            notificationState: BudgetsClientTypes.NotificationState? = nil,
            notificationType: BudgetsClientTypes.NotificationType? = nil,
            threshold: Swift.Double = 0.0,
            thresholdType: BudgetsClientTypes.ThresholdType? = nil
        )
        {
            self.comparisonOperator = comparisonOperator
            self.notificationState = notificationState
            self.notificationType = notificationType
            self.threshold = threshold
            self.thresholdType = thresholdType
        }
    }

}

extension BudgetsClientTypes {
    public enum NotificationState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case alarm
        case ok
        case sdkUnknown(Swift.String)

        public static var allCases: [NotificationState] {
            return [
                .alarm,
                .ok,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .alarm: return "ALARM"
            case .ok: return "OK"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = NotificationState(rawValue: rawValue) ?? NotificationState.sdkUnknown(rawValue)
        }
    }
}

extension BudgetsClientTypes {
    /// The type of a notification. It must be ACTUAL or FORECASTED.
    public enum NotificationType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case actual
        case forecasted
        case sdkUnknown(Swift.String)

        public static var allCases: [NotificationType] {
            return [
                .actual,
                .forecasted,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .actual: return "ACTUAL"
            case .forecasted: return "FORECASTED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = NotificationType(rawValue: rawValue) ?? NotificationType.sdkUnknown(rawValue)
        }
    }
}

extension BudgetsClientTypes.NotificationWithSubscribers: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case notification = "Notification"
        case subscribers = "Subscribers"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let notification = self.notification {
            try encodeContainer.encode(notification, forKey: .notification)
        }
        if let subscribers = subscribers {
            var subscribersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subscribers)
            for subscriber0 in subscribers {
                try subscribersContainer.encode(subscriber0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let notificationDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.Notification.self, forKey: .notification)
        notification = notificationDecoded
        let subscribersContainer = try containerValues.decodeIfPresent([BudgetsClientTypes.Subscriber?].self, forKey: .subscribers)
        var subscribersDecoded0:[BudgetsClientTypes.Subscriber]? = nil
        if let subscribersContainer = subscribersContainer {
            subscribersDecoded0 = [BudgetsClientTypes.Subscriber]()
            for structure0 in subscribersContainer {
                if let structure0 = structure0 {
                    subscribersDecoded0?.append(structure0)
                }
            }
        }
        subscribers = subscribersDecoded0
    }
}

extension BudgetsClientTypes {
    /// A notification with subscribers. A notification can have one SNS subscriber and up to 10 email subscribers, for a total of 11 subscribers.
    public struct NotificationWithSubscribers: Swift.Equatable {
        /// The notification that's associated with a budget.
        /// This member is required.
        public var notification: BudgetsClientTypes.Notification?
        /// A list of subscribers who are subscribed to this notification.
        /// This member is required.
        public var subscribers: [BudgetsClientTypes.Subscriber]?

        public init (
            notification: BudgetsClientTypes.Notification? = nil,
            subscribers: [BudgetsClientTypes.Subscriber]? = nil
        )
        {
            self.notification = notification
            self.subscribers = subscribers
        }
    }

}

extension ResourceLockedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ResourceLockedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request was received and recognized by the server, but the server rejected that particular method for the requested resource.
public struct ResourceLockedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The error message the exception carries.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ResourceLockedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceLockedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension BudgetsClientTypes.ScpActionDefinition: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policyId = "PolicyId"
        case targetIds = "TargetIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let policyId = self.policyId {
            try encodeContainer.encode(policyId, forKey: .policyId)
        }
        if let targetIds = targetIds {
            var targetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targetIds)
            for targetid0 in targetIds {
                try targetIdsContainer.encode(targetid0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyId)
        policyId = policyIdDecoded
        let targetIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .targetIds)
        var targetIdsDecoded0:[Swift.String]? = nil
        if let targetIdsContainer = targetIdsContainer {
            targetIdsDecoded0 = [Swift.String]()
            for string0 in targetIdsContainer {
                if let string0 = string0 {
                    targetIdsDecoded0?.append(string0)
                }
            }
        }
        targetIds = targetIdsDecoded0
    }
}

extension BudgetsClientTypes {
    /// The service control policies (SCP) action definition details.
    public struct ScpActionDefinition: Swift.Equatable {
        /// The policy ID attached.
        /// This member is required.
        public var policyId: Swift.String?
        /// A list of target IDs.
        /// This member is required.
        public var targetIds: [Swift.String]?

        public init (
            policyId: Swift.String? = nil,
            targetIds: [Swift.String]? = nil
        )
        {
            self.policyId = policyId
            self.targetIds = targetIds
        }
    }

}

extension BudgetsClientTypes.Spend: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case amount = "Amount"
        case unit = "Unit"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let amount = self.amount {
            try encodeContainer.encode(amount, forKey: .amount)
        }
        if let unit = self.unit {
            try encodeContainer.encode(unit, forKey: .unit)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let amountDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .amount)
        amount = amountDecoded
        let unitDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .unit)
        unit = unitDecoded
    }
}

extension BudgetsClientTypes {
    /// The amount of cost or usage that's measured for a budget. For example, a Spend for 3 GB of S3 usage has the following parameters:
    ///
    /// * An Amount of 3
    ///
    /// * A unit of GB
    public struct Spend: Swift.Equatable {
        /// The cost or usage amount that's associated with a budget forecast, actual spend, or budget threshold.
        /// This member is required.
        public var amount: Swift.String?
        /// The unit of measurement that's used for the budget forecast, actual spend, or budget threshold, such as USD or GBP.
        /// This member is required.
        public var unit: Swift.String?

        public init (
            amount: Swift.String? = nil,
            unit: Swift.String? = nil
        )
        {
            self.amount = amount
            self.unit = unit
        }
    }

}

extension BudgetsClientTypes.SsmActionDefinition: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actionSubType = "ActionSubType"
        case instanceIds = "InstanceIds"
        case region = "Region"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actionSubType = self.actionSubType {
            try encodeContainer.encode(actionSubType.rawValue, forKey: .actionSubType)
        }
        if let instanceIds = instanceIds {
            var instanceIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .instanceIds)
            for instanceid0 in instanceIds {
                try instanceIdsContainer.encode(instanceid0)
            }
        }
        if let region = self.region {
            try encodeContainer.encode(region, forKey: .region)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionSubTypeDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.ActionSubType.self, forKey: .actionSubType)
        actionSubType = actionSubTypeDecoded
        let regionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .region)
        region = regionDecoded
        let instanceIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .instanceIds)
        var instanceIdsDecoded0:[Swift.String]? = nil
        if let instanceIdsContainer = instanceIdsContainer {
            instanceIdsDecoded0 = [Swift.String]()
            for string0 in instanceIdsContainer {
                if let string0 = string0 {
                    instanceIdsDecoded0?.append(string0)
                }
            }
        }
        instanceIds = instanceIdsDecoded0
    }
}

extension BudgetsClientTypes {
    /// The Amazon Web Services Systems Manager (SSM) action definition details.
    public struct SsmActionDefinition: Swift.Equatable {
        /// The action subType.
        /// This member is required.
        public var actionSubType: BudgetsClientTypes.ActionSubType?
        /// The EC2 and RDS instance IDs.
        /// This member is required.
        public var instanceIds: [Swift.String]?
        /// The Region to run the SSM document.
        /// This member is required.
        public var region: Swift.String?

        public init (
            actionSubType: BudgetsClientTypes.ActionSubType? = nil,
            instanceIds: [Swift.String]? = nil,
            region: Swift.String? = nil
        )
        {
            self.actionSubType = actionSubType
            self.instanceIds = instanceIds
            self.region = region
        }
    }

}

extension BudgetsClientTypes.Subscriber: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case address = "Address"
        case subscriptionType = "SubscriptionType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let address = self.address {
            try encodeContainer.encode(address, forKey: .address)
        }
        if let subscriptionType = self.subscriptionType {
            try encodeContainer.encode(subscriptionType.rawValue, forKey: .subscriptionType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subscriptionTypeDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.SubscriptionType.self, forKey: .subscriptionType)
        subscriptionType = subscriptionTypeDecoded
        let addressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .address)
        address = addressDecoded
    }
}

extension BudgetsClientTypes.Subscriber: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Subscriber(subscriptionType: \(Swift.String(describing: subscriptionType)), address: \"CONTENT_REDACTED\")"}
}

extension BudgetsClientTypes {
    /// The subscriber to a budget notification. The subscriber consists of a subscription type and either an Amazon SNS topic or an email address. For example, an email subscriber has the following parameters:
    ///
    /// * A subscriptionType of EMAIL
    ///
    /// * An address of example@example.com
    public struct Subscriber: Swift.Equatable {
        /// The address that Amazon Web Services sends budget notifications to, either an SNS topic or an email. When you create a subscriber, the value of Address can't contain line breaks.
        /// This member is required.
        public var address: Swift.String?
        /// The type of notification that Amazon Web Services sends to a subscriber.
        /// This member is required.
        public var subscriptionType: BudgetsClientTypes.SubscriptionType?

        public init (
            address: Swift.String? = nil,
            subscriptionType: BudgetsClientTypes.SubscriptionType? = nil
        )
        {
            self.address = address
            self.subscriptionType = subscriptionType
        }
    }

}

extension BudgetsClientTypes {
    /// The subscription type of the subscriber. It can be SMS or EMAIL.
    public enum SubscriptionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case email
        case sns
        case sdkUnknown(Swift.String)

        public static var allCases: [SubscriptionType] {
            return [
                .email,
                .sns,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .email: return "EMAIL"
            case .sns: return "SNS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SubscriptionType(rawValue: rawValue) ?? SubscriptionType.sdkUnknown(rawValue)
        }
    }
}

extension BudgetsClientTypes {
    /// The type of threshold for a notification.
    public enum ThresholdType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case absoluteValue
        case percentage
        case sdkUnknown(Swift.String)

        public static var allCases: [ThresholdType] {
            return [
                .absoluteValue,
                .percentage,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .absoluteValue: return "ABSOLUTE_VALUE"
            case .percentage: return "PERCENTAGE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ThresholdType(rawValue: rawValue) ?? ThresholdType.sdkUnknown(rawValue)
        }
    }
}

extension ThrottlingException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The number of API requests has exceeded the maximum allowed API request throttling limit for the account.
public struct ThrottlingException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The error message the exception carries.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension BudgetsClientTypes.TimePeriod: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case end = "End"
        case start = "Start"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let end = self.end {
            try encodeContainer.encodeTimestamp(end, format: .epochSeconds, forKey: .end)
        }
        if let start = self.start {
            try encodeContainer.encodeTimestamp(start, format: .epochSeconds, forKey: .start)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .start)
        start = startDecoded
        let endDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .end)
        end = endDecoded
    }
}

extension BudgetsClientTypes {
    /// The period of time that's covered by a budget. The period has a start date and an end date. The start date must come before the end date. There are no restrictions on the end date.
    public struct TimePeriod: Swift.Equatable {
        /// The end date for a budget. If you didn't specify an end date, Amazon Web Services set your end date to 06/15/87 00:00 UTC. The defaults are the same for the Billing and Cost Management console and the API. After the end date, Amazon Web Services deletes the budget and all the associated notifications and subscribers. You can change your end date with the UpdateBudget operation.
        public var end: ClientRuntime.Date?
        /// The start date for a budget. If you created your budget and didn't specify a start date, Amazon Web Services defaults to the start of your chosen time period (DAILY, MONTHLY, QUARTERLY, or ANNUALLY). For example, if you created your budget on January 24, 2018, chose DAILY, and didn't set a start date, Amazon Web Services set your start date to 01/24/18 00:00 UTC. If you chose MONTHLY, Amazon Web Services set your start date to 01/01/18 00:00 UTC. The defaults are the same for the Billing and Cost Management console and the API. You can change your start date with the UpdateBudget operation.
        public var start: ClientRuntime.Date?

        public init (
            end: ClientRuntime.Date? = nil,
            start: ClientRuntime.Date? = nil
        )
        {
            self.end = end
            self.start = start
        }
    }

}

extension BudgetsClientTypes {
    /// The time unit of the budget, such as MONTHLY or QUARTERLY.
    public enum TimeUnit: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case annually
        case daily
        case monthly
        case quarterly
        case sdkUnknown(Swift.String)

        public static var allCases: [TimeUnit] {
            return [
                .annually,
                .daily,
                .monthly,
                .quarterly,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .annually: return "ANNUALLY"
            case .daily: return "DAILY"
            case .monthly: return "MONTHLY"
            case .quarterly: return "QUARTERLY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TimeUnit(rawValue: rawValue) ?? TimeUnit.sdkUnknown(rawValue)
        }
    }
}

extension UpdateBudgetActionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case actionId = "ActionId"
        case actionThreshold = "ActionThreshold"
        case approvalModel = "ApprovalModel"
        case budgetName = "BudgetName"
        case definition = "Definition"
        case executionRoleArn = "ExecutionRoleArn"
        case notificationType = "NotificationType"
        case subscribers = "Subscribers"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let actionId = self.actionId {
            try encodeContainer.encode(actionId, forKey: .actionId)
        }
        if let actionThreshold = self.actionThreshold {
            try encodeContainer.encode(actionThreshold, forKey: .actionThreshold)
        }
        if let approvalModel = self.approvalModel {
            try encodeContainer.encode(approvalModel.rawValue, forKey: .approvalModel)
        }
        if let budgetName = self.budgetName {
            try encodeContainer.encode(budgetName, forKey: .budgetName)
        }
        if let definition = self.definition {
            try encodeContainer.encode(definition, forKey: .definition)
        }
        if let executionRoleArn = self.executionRoleArn {
            try encodeContainer.encode(executionRoleArn, forKey: .executionRoleArn)
        }
        if let notificationType = self.notificationType {
            try encodeContainer.encode(notificationType.rawValue, forKey: .notificationType)
        }
        if let subscribers = subscribers {
            var subscribersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subscribers)
            for subscriber0 in subscribers {
                try subscribersContainer.encode(subscriber0)
            }
        }
    }
}

extension UpdateBudgetActionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateBudgetActionInput: Swift.Equatable {
    /// The account ID of the user. It's a 12-digit number.
    /// This member is required.
    public var accountId: Swift.String?
    /// A system-generated universally unique identifier (UUID) for the action.
    /// This member is required.
    public var actionId: Swift.String?
    /// The trigger threshold of the action.
    public var actionThreshold: BudgetsClientTypes.ActionThreshold?
    /// This specifies if the action needs manual or automatic approval.
    public var approvalModel: BudgetsClientTypes.ApprovalModel?
    /// A string that represents the budget name. The ":" and "\" characters aren't allowed.
    /// This member is required.
    public var budgetName: Swift.String?
    /// Specifies all of the type-specific parameters.
    public var definition: BudgetsClientTypes.Definition?
    /// The role passed for action execution and reversion. Roles and actions must be in the same account.
    public var executionRoleArn: Swift.String?
    /// The type of a notification. It must be ACTUAL or FORECASTED.
    public var notificationType: BudgetsClientTypes.NotificationType?
    /// A list of subscribers.
    public var subscribers: [BudgetsClientTypes.Subscriber]?

    public init (
        accountId: Swift.String? = nil,
        actionId: Swift.String? = nil,
        actionThreshold: BudgetsClientTypes.ActionThreshold? = nil,
        approvalModel: BudgetsClientTypes.ApprovalModel? = nil,
        budgetName: Swift.String? = nil,
        definition: BudgetsClientTypes.Definition? = nil,
        executionRoleArn: Swift.String? = nil,
        notificationType: BudgetsClientTypes.NotificationType? = nil,
        subscribers: [BudgetsClientTypes.Subscriber]? = nil
    )
    {
        self.accountId = accountId
        self.actionId = actionId
        self.actionThreshold = actionThreshold
        self.approvalModel = approvalModel
        self.budgetName = budgetName
        self.definition = definition
        self.executionRoleArn = executionRoleArn
        self.notificationType = notificationType
        self.subscribers = subscribers
    }
}

struct UpdateBudgetActionInputBody: Swift.Equatable {
    let accountId: Swift.String?
    let budgetName: Swift.String?
    let actionId: Swift.String?
    let notificationType: BudgetsClientTypes.NotificationType?
    let actionThreshold: BudgetsClientTypes.ActionThreshold?
    let definition: BudgetsClientTypes.Definition?
    let executionRoleArn: Swift.String?
    let approvalModel: BudgetsClientTypes.ApprovalModel?
    let subscribers: [BudgetsClientTypes.Subscriber]?
}

extension UpdateBudgetActionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case actionId = "ActionId"
        case actionThreshold = "ActionThreshold"
        case approvalModel = "ApprovalModel"
        case budgetName = "BudgetName"
        case definition = "Definition"
        case executionRoleArn = "ExecutionRoleArn"
        case notificationType = "NotificationType"
        case subscribers = "Subscribers"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let budgetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .budgetName)
        budgetName = budgetNameDecoded
        let actionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .actionId)
        actionId = actionIdDecoded
        let notificationTypeDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.NotificationType.self, forKey: .notificationType)
        notificationType = notificationTypeDecoded
        let actionThresholdDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.ActionThreshold.self, forKey: .actionThreshold)
        actionThreshold = actionThresholdDecoded
        let definitionDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.Definition.self, forKey: .definition)
        definition = definitionDecoded
        let executionRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .executionRoleArn)
        executionRoleArn = executionRoleArnDecoded
        let approvalModelDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.ApprovalModel.self, forKey: .approvalModel)
        approvalModel = approvalModelDecoded
        let subscribersContainer = try containerValues.decodeIfPresent([BudgetsClientTypes.Subscriber?].self, forKey: .subscribers)
        var subscribersDecoded0:[BudgetsClientTypes.Subscriber]? = nil
        if let subscribersContainer = subscribersContainer {
            subscribersDecoded0 = [BudgetsClientTypes.Subscriber]()
            for structure0 in subscribersContainer {
                if let structure0 = structure0 {
                    subscribersDecoded0?.append(structure0)
                }
            }
        }
        subscribers = subscribersDecoded0
    }
}

extension UpdateBudgetActionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateBudgetActionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ResourceLockedException" : self = .resourceLockedException(try ResourceLockedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateBudgetActionOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notFoundException(NotFoundException)
    case resourceLockedException(ResourceLockedException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateBudgetActionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateBudgetActionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.accountId = output.accountId
            self.budgetName = output.budgetName
            self.newAction = output.newAction
            self.oldAction = output.oldAction
        } else {
            self.accountId = nil
            self.budgetName = nil
            self.newAction = nil
            self.oldAction = nil
        }
    }
}

public struct UpdateBudgetActionOutputResponse: Swift.Equatable {
    /// The account ID of the user. It's a 12-digit number.
    /// This member is required.
    public var accountId: Swift.String?
    /// A string that represents the budget name. The ":" and "\" characters aren't allowed.
    /// This member is required.
    public var budgetName: Swift.String?
    /// The updated action resource information.
    /// This member is required.
    public var newAction: BudgetsClientTypes.Action?
    /// The previous action resource information.
    /// This member is required.
    public var oldAction: BudgetsClientTypes.Action?

    public init (
        accountId: Swift.String? = nil,
        budgetName: Swift.String? = nil,
        newAction: BudgetsClientTypes.Action? = nil,
        oldAction: BudgetsClientTypes.Action? = nil
    )
    {
        self.accountId = accountId
        self.budgetName = budgetName
        self.newAction = newAction
        self.oldAction = oldAction
    }
}

struct UpdateBudgetActionOutputResponseBody: Swift.Equatable {
    let accountId: Swift.String?
    let budgetName: Swift.String?
    let oldAction: BudgetsClientTypes.Action?
    let newAction: BudgetsClientTypes.Action?
}

extension UpdateBudgetActionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case budgetName = "BudgetName"
        case newAction = "NewAction"
        case oldAction = "OldAction"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let budgetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .budgetName)
        budgetName = budgetNameDecoded
        let oldActionDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.Action.self, forKey: .oldAction)
        oldAction = oldActionDecoded
        let newActionDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.Action.self, forKey: .newAction)
        newAction = newActionDecoded
    }
}

extension UpdateBudgetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case newBudget = "NewBudget"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let newBudget = self.newBudget {
            try encodeContainer.encode(newBudget, forKey: .newBudget)
        }
    }
}

extension UpdateBudgetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Request of UpdateBudget
public struct UpdateBudgetInput: Swift.Equatable {
    /// The accountId that is associated with the budget that you want to update.
    /// This member is required.
    public var accountId: Swift.String?
    /// The budget that you want to update your budget to.
    /// This member is required.
    public var newBudget: BudgetsClientTypes.Budget?

    public init (
        accountId: Swift.String? = nil,
        newBudget: BudgetsClientTypes.Budget? = nil
    )
    {
        self.accountId = accountId
        self.newBudget = newBudget
    }
}

struct UpdateBudgetInputBody: Swift.Equatable {
    let accountId: Swift.String?
    let newBudget: BudgetsClientTypes.Budget?
}

extension UpdateBudgetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case newBudget = "NewBudget"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let newBudgetDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.Budget.self, forKey: .newBudget)
        newBudget = newBudgetDecoded
    }
}

extension UpdateBudgetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateBudgetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateBudgetOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notFoundException(NotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateBudgetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

/// Response of UpdateBudget
public struct UpdateBudgetOutputResponse: Swift.Equatable {

    public init () { }
}

extension UpdateNotificationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case budgetName = "BudgetName"
        case newNotification = "NewNotification"
        case oldNotification = "OldNotification"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let budgetName = self.budgetName {
            try encodeContainer.encode(budgetName, forKey: .budgetName)
        }
        if let newNotification = self.newNotification {
            try encodeContainer.encode(newNotification, forKey: .newNotification)
        }
        if let oldNotification = self.oldNotification {
            try encodeContainer.encode(oldNotification, forKey: .oldNotification)
        }
    }
}

extension UpdateNotificationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Request of UpdateNotification
public struct UpdateNotificationInput: Swift.Equatable {
    /// The accountId that is associated with the budget whose notification you want to update.
    /// This member is required.
    public var accountId: Swift.String?
    /// The name of the budget whose notification you want to update.
    /// This member is required.
    public var budgetName: Swift.String?
    /// The updated notification to be associated with a budget.
    /// This member is required.
    public var newNotification: BudgetsClientTypes.Notification?
    /// The previous notification that is associated with a budget.
    /// This member is required.
    public var oldNotification: BudgetsClientTypes.Notification?

    public init (
        accountId: Swift.String? = nil,
        budgetName: Swift.String? = nil,
        newNotification: BudgetsClientTypes.Notification? = nil,
        oldNotification: BudgetsClientTypes.Notification? = nil
    )
    {
        self.accountId = accountId
        self.budgetName = budgetName
        self.newNotification = newNotification
        self.oldNotification = oldNotification
    }
}

struct UpdateNotificationInputBody: Swift.Equatable {
    let accountId: Swift.String?
    let budgetName: Swift.String?
    let oldNotification: BudgetsClientTypes.Notification?
    let newNotification: BudgetsClientTypes.Notification?
}

extension UpdateNotificationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case budgetName = "BudgetName"
        case newNotification = "NewNotification"
        case oldNotification = "OldNotification"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let budgetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .budgetName)
        budgetName = budgetNameDecoded
        let oldNotificationDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.Notification.self, forKey: .oldNotification)
        oldNotification = oldNotificationDecoded
        let newNotificationDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.Notification.self, forKey: .newNotification)
        newNotification = newNotificationDecoded
    }
}

extension UpdateNotificationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateNotificationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DuplicateRecordException" : self = .duplicateRecordException(try DuplicateRecordException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateNotificationOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case duplicateRecordException(DuplicateRecordException)
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notFoundException(NotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateNotificationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

/// Response of UpdateNotification
public struct UpdateNotificationOutputResponse: Swift.Equatable {

    public init () { }
}

extension UpdateSubscriberInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case budgetName = "BudgetName"
        case newSubscriber = "NewSubscriber"
        case notification = "Notification"
        case oldSubscriber = "OldSubscriber"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let budgetName = self.budgetName {
            try encodeContainer.encode(budgetName, forKey: .budgetName)
        }
        if let newSubscriber = self.newSubscriber {
            try encodeContainer.encode(newSubscriber, forKey: .newSubscriber)
        }
        if let notification = self.notification {
            try encodeContainer.encode(notification, forKey: .notification)
        }
        if let oldSubscriber = self.oldSubscriber {
            try encodeContainer.encode(oldSubscriber, forKey: .oldSubscriber)
        }
    }
}

extension UpdateSubscriberInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Request of UpdateSubscriber
public struct UpdateSubscriberInput: Swift.Equatable {
    /// The accountId that is associated with the budget whose subscriber you want to update.
    /// This member is required.
    public var accountId: Swift.String?
    /// The name of the budget whose subscriber you want to update.
    /// This member is required.
    public var budgetName: Swift.String?
    /// The updated subscriber that is associated with a budget notification.
    /// This member is required.
    public var newSubscriber: BudgetsClientTypes.Subscriber?
    /// The notification whose subscriber you want to update.
    /// This member is required.
    public var notification: BudgetsClientTypes.Notification?
    /// The previous subscriber that is associated with a budget notification.
    /// This member is required.
    public var oldSubscriber: BudgetsClientTypes.Subscriber?

    public init (
        accountId: Swift.String? = nil,
        budgetName: Swift.String? = nil,
        newSubscriber: BudgetsClientTypes.Subscriber? = nil,
        notification: BudgetsClientTypes.Notification? = nil,
        oldSubscriber: BudgetsClientTypes.Subscriber? = nil
    )
    {
        self.accountId = accountId
        self.budgetName = budgetName
        self.newSubscriber = newSubscriber
        self.notification = notification
        self.oldSubscriber = oldSubscriber
    }
}

struct UpdateSubscriberInputBody: Swift.Equatable {
    let accountId: Swift.String?
    let budgetName: Swift.String?
    let notification: BudgetsClientTypes.Notification?
    let oldSubscriber: BudgetsClientTypes.Subscriber?
    let newSubscriber: BudgetsClientTypes.Subscriber?
}

extension UpdateSubscriberInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case budgetName = "BudgetName"
        case newSubscriber = "NewSubscriber"
        case notification = "Notification"
        case oldSubscriber = "OldSubscriber"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let budgetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .budgetName)
        budgetName = budgetNameDecoded
        let notificationDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.Notification.self, forKey: .notification)
        notification = notificationDecoded
        let oldSubscriberDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.Subscriber.self, forKey: .oldSubscriber)
        oldSubscriber = oldSubscriberDecoded
        let newSubscriberDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.Subscriber.self, forKey: .newSubscriber)
        newSubscriber = newSubscriberDecoded
    }
}

extension UpdateSubscriberOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateSubscriberOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "DuplicateRecordException" : self = .duplicateRecordException(try DuplicateRecordException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalErrorException" : self = .internalErrorException(try InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InvalidParameterException" : self = .invalidParameterException(try InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "NotFoundException" : self = .notFoundException(try NotFoundException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateSubscriberOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case duplicateRecordException(DuplicateRecordException)
    case internalErrorException(InternalErrorException)
    case invalidParameterException(InvalidParameterException)
    case notFoundException(NotFoundException)
    case throttlingException(ThrottlingException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateSubscriberOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

/// Response of UpdateSubscriber
public struct UpdateSubscriberOutputResponse: Swift.Equatable {

    public init () { }
}
