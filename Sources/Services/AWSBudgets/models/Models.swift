// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// You are not authorized to use this operation with the given parameters.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The error message the exception carries.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension BudgetsClientTypes.Action: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actionId = "ActionId"
        case actionThreshold = "ActionThreshold"
        case actionType = "ActionType"
        case approvalModel = "ApprovalModel"
        case budgetName = "BudgetName"
        case definition = "Definition"
        case executionRoleArn = "ExecutionRoleArn"
        case notificationType = "NotificationType"
        case status = "Status"
        case subscribers = "Subscribers"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actionId = self.actionId {
            try encodeContainer.encode(actionId, forKey: .actionId)
        }
        if let actionThreshold = self.actionThreshold {
            try encodeContainer.encode(actionThreshold, forKey: .actionThreshold)
        }
        if let actionType = self.actionType {
            try encodeContainer.encode(actionType.rawValue, forKey: .actionType)
        }
        if let approvalModel = self.approvalModel {
            try encodeContainer.encode(approvalModel.rawValue, forKey: .approvalModel)
        }
        if let budgetName = self.budgetName {
            try encodeContainer.encode(budgetName, forKey: .budgetName)
        }
        if let definition = self.definition {
            try encodeContainer.encode(definition, forKey: .definition)
        }
        if let executionRoleArn = self.executionRoleArn {
            try encodeContainer.encode(executionRoleArn, forKey: .executionRoleArn)
        }
        if let notificationType = self.notificationType {
            try encodeContainer.encode(notificationType.rawValue, forKey: .notificationType)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let subscribers = subscribers {
            var subscribersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subscribers)
            for subscriber0 in subscribers {
                try subscribersContainer.encode(subscriber0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .actionId)
        actionId = actionIdDecoded
        let budgetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .budgetName)
        budgetName = budgetNameDecoded
        let notificationTypeDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.NotificationType.self, forKey: .notificationType)
        notificationType = notificationTypeDecoded
        let actionTypeDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.ActionType.self, forKey: .actionType)
        actionType = actionTypeDecoded
        let actionThresholdDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.ActionThreshold.self, forKey: .actionThreshold)
        actionThreshold = actionThresholdDecoded
        let definitionDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.Definition.self, forKey: .definition)
        definition = definitionDecoded
        let executionRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .executionRoleArn)
        executionRoleArn = executionRoleArnDecoded
        let approvalModelDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.ApprovalModel.self, forKey: .approvalModel)
        approvalModel = approvalModelDecoded
        let statusDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.ActionStatus.self, forKey: .status)
        status = statusDecoded
        let subscribersContainer = try containerValues.decodeIfPresent([BudgetsClientTypes.Subscriber?].self, forKey: .subscribers)
        var subscribersDecoded0:[BudgetsClientTypes.Subscriber]? = nil
        if let subscribersContainer = subscribersContainer {
            subscribersDecoded0 = [BudgetsClientTypes.Subscriber]()
            for structure0 in subscribersContainer {
                if let structure0 = structure0 {
                    subscribersDecoded0?.append(structure0)
                }
            }
        }
        subscribers = subscribersDecoded0
    }
}

extension BudgetsClientTypes {
    /// A budget action resource.
    public struct Action: Swift.Equatable {
        /// A system-generated universally unique identifier (UUID) for the action.
        /// This member is required.
        public var actionId: Swift.String?
        /// The trigger threshold of the action.
        /// This member is required.
        public var actionThreshold: BudgetsClientTypes.ActionThreshold?
        /// The type of action. This defines the type of tasks that can be carried out by this action. This field also determines the format for definition.
        /// This member is required.
        public var actionType: BudgetsClientTypes.ActionType?
        /// This specifies if the action needs manual or automatic approval.
        /// This member is required.
        public var approvalModel: BudgetsClientTypes.ApprovalModel?
        /// A string that represents the budget name. The ":" and "\" characters, and the "/action/" substring, aren't allowed.
        /// This member is required.
        public var budgetName: Swift.String?
        /// Where you specify all of the type-specific parameters.
        /// This member is required.
        public var definition: BudgetsClientTypes.Definition?
        /// The role passed for action execution and reversion. Roles and actions must be in the same account.
        /// This member is required.
        public var executionRoleArn: Swift.String?
        /// The type of a notification. It must be ACTUAL or FORECASTED.
        /// This member is required.
        public var notificationType: BudgetsClientTypes.NotificationType?
        /// The status of the action.
        /// This member is required.
        public var status: BudgetsClientTypes.ActionStatus?
        /// A list of subscribers.
        /// This member is required.
        public var subscribers: [BudgetsClientTypes.Subscriber]?

        public init(
            actionId: Swift.String? = nil,
            actionThreshold: BudgetsClientTypes.ActionThreshold? = nil,
            actionType: BudgetsClientTypes.ActionType? = nil,
            approvalModel: BudgetsClientTypes.ApprovalModel? = nil,
            budgetName: Swift.String? = nil,
            definition: BudgetsClientTypes.Definition? = nil,
            executionRoleArn: Swift.String? = nil,
            notificationType: BudgetsClientTypes.NotificationType? = nil,
            status: BudgetsClientTypes.ActionStatus? = nil,
            subscribers: [BudgetsClientTypes.Subscriber]? = nil
        )
        {
            self.actionId = actionId
            self.actionThreshold = actionThreshold
            self.actionType = actionType
            self.approvalModel = approvalModel
            self.budgetName = budgetName
            self.definition = definition
            self.executionRoleArn = executionRoleArn
            self.notificationType = notificationType
            self.status = status
            self.subscribers = subscribers
        }
    }

}

extension BudgetsClientTypes.ActionHistory: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actionHistoryDetails = "ActionHistoryDetails"
        case eventType = "EventType"
        case status = "Status"
        case timestamp = "Timestamp"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actionHistoryDetails = self.actionHistoryDetails {
            try encodeContainer.encode(actionHistoryDetails, forKey: .actionHistoryDetails)
        }
        if let eventType = self.eventType {
            try encodeContainer.encode(eventType.rawValue, forKey: .eventType)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let timestamp = self.timestamp {
            try encodeContainer.encodeTimestamp(timestamp, format: .epochSeconds, forKey: .timestamp)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let timestampDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .timestamp)
        timestamp = timestampDecoded
        let statusDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.ActionStatus.self, forKey: .status)
        status = statusDecoded
        let eventTypeDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.EventType.self, forKey: .eventType)
        eventType = eventTypeDecoded
        let actionHistoryDetailsDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.ActionHistoryDetails.self, forKey: .actionHistoryDetails)
        actionHistoryDetails = actionHistoryDetailsDecoded
    }
}

extension BudgetsClientTypes {
    /// The historical records for a budget action.
    public struct ActionHistory: Swift.Equatable {
        /// The description of the details for the event.
        /// This member is required.
        public var actionHistoryDetails: BudgetsClientTypes.ActionHistoryDetails?
        /// This distinguishes between whether the events are triggered by the user or are generated by the system.
        /// This member is required.
        public var eventType: BudgetsClientTypes.EventType?
        /// The status of action at the time of the event.
        /// This member is required.
        public var status: BudgetsClientTypes.ActionStatus?
        /// A generic time stamp. In Java, it's transformed to a Date object.
        /// This member is required.
        public var timestamp: ClientRuntime.Date?

        public init(
            actionHistoryDetails: BudgetsClientTypes.ActionHistoryDetails? = nil,
            eventType: BudgetsClientTypes.EventType? = nil,
            status: BudgetsClientTypes.ActionStatus? = nil,
            timestamp: ClientRuntime.Date? = nil
        )
        {
            self.actionHistoryDetails = actionHistoryDetails
            self.eventType = eventType
            self.status = status
            self.timestamp = timestamp
        }
    }

}

extension BudgetsClientTypes.ActionHistoryDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action = "Action"
        case message = "Message"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = self.action {
            try encodeContainer.encode(action, forKey: .action)
        }
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let actionDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.Action.self, forKey: .action)
        action = actionDecoded
    }
}

extension BudgetsClientTypes {
    /// The description of the details for the event.
    public struct ActionHistoryDetails: Swift.Equatable {
        /// The budget action resource.
        /// This member is required.
        public var action: BudgetsClientTypes.Action?
        /// A generic string.
        /// This member is required.
        public var message: Swift.String?

        public init(
            action: BudgetsClientTypes.Action? = nil,
            message: Swift.String? = nil
        )
        {
            self.action = action
            self.message = message
        }
    }

}

extension BudgetsClientTypes {
    public enum ActionStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case executionFailure
        case executionInProgress
        case executionSuccess
        case pending
        case resetFailure
        case resetInProgress
        case reverseFailure
        case reverseInProgress
        case reverseSuccess
        case standby
        case sdkUnknown(Swift.String)

        public static var allCases: [ActionStatus] {
            return [
                .executionFailure,
                .executionInProgress,
                .executionSuccess,
                .pending,
                .resetFailure,
                .resetInProgress,
                .reverseFailure,
                .reverseInProgress,
                .reverseSuccess,
                .standby,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .executionFailure: return "EXECUTION_FAILURE"
            case .executionInProgress: return "EXECUTION_IN_PROGRESS"
            case .executionSuccess: return "EXECUTION_SUCCESS"
            case .pending: return "PENDING"
            case .resetFailure: return "RESET_FAILURE"
            case .resetInProgress: return "RESET_IN_PROGRESS"
            case .reverseFailure: return "REVERSE_FAILURE"
            case .reverseInProgress: return "REVERSE_IN_PROGRESS"
            case .reverseSuccess: return "REVERSE_SUCCESS"
            case .standby: return "STANDBY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ActionStatus(rawValue: rawValue) ?? ActionStatus.sdkUnknown(rawValue)
        }
    }
}

extension BudgetsClientTypes {
    public enum ActionSubType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case stopEc2
        case stopRds
        case sdkUnknown(Swift.String)

        public static var allCases: [ActionSubType] {
            return [
                .stopEc2,
                .stopRds,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .stopEc2: return "STOP_EC2_INSTANCES"
            case .stopRds: return "STOP_RDS_INSTANCES"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ActionSubType(rawValue: rawValue) ?? ActionSubType.sdkUnknown(rawValue)
        }
    }
}

extension BudgetsClientTypes.ActionThreshold: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actionThresholdType = "ActionThresholdType"
        case actionThresholdValue = "ActionThresholdValue"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actionThresholdType = self.actionThresholdType {
            try encodeContainer.encode(actionThresholdType.rawValue, forKey: .actionThresholdType)
        }
        if actionThresholdValue != 0.0 {
            try encodeContainer.encode(actionThresholdValue, forKey: .actionThresholdValue)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionThresholdValueDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .actionThresholdValue) ?? 0.0
        actionThresholdValue = actionThresholdValueDecoded
        let actionThresholdTypeDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.ThresholdType.self, forKey: .actionThresholdType)
        actionThresholdType = actionThresholdTypeDecoded
    }
}

extension BudgetsClientTypes {
    /// The trigger threshold of the action.
    public struct ActionThreshold: Swift.Equatable {
        /// The type of threshold for a notification.
        /// This member is required.
        public var actionThresholdType: BudgetsClientTypes.ThresholdType?
        /// The threshold of a notification.
        /// This member is required.
        public var actionThresholdValue: Swift.Double

        public init(
            actionThresholdType: BudgetsClientTypes.ThresholdType? = nil,
            actionThresholdValue: Swift.Double = 0.0
        )
        {
            self.actionThresholdType = actionThresholdType
            self.actionThresholdValue = actionThresholdValue
        }
    }

}

extension BudgetsClientTypes {
    public enum ActionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case iam
        case scp
        case ssm
        case sdkUnknown(Swift.String)

        public static var allCases: [ActionType] {
            return [
                .iam,
                .scp,
                .ssm,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .iam: return "APPLY_IAM_POLICY"
            case .scp: return "APPLY_SCP_POLICY"
            case .ssm: return "RUN_SSM_DOCUMENTS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ActionType(rawValue: rawValue) ?? ActionType.sdkUnknown(rawValue)
        }
    }
}

extension BudgetsClientTypes {
    public enum ApprovalModel: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case auto
        case manual
        case sdkUnknown(Swift.String)

        public static var allCases: [ApprovalModel] {
            return [
                .auto,
                .manual,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .auto: return "AUTOMATIC"
            case .manual: return "MANUAL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ApprovalModel(rawValue: rawValue) ?? ApprovalModel.sdkUnknown(rawValue)
        }
    }
}

extension BudgetsClientTypes.AutoAdjustData: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoAdjustType = "AutoAdjustType"
        case historicalOptions = "HistoricalOptions"
        case lastAutoAdjustTime = "LastAutoAdjustTime"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let autoAdjustType = self.autoAdjustType {
            try encodeContainer.encode(autoAdjustType.rawValue, forKey: .autoAdjustType)
        }
        if let historicalOptions = self.historicalOptions {
            try encodeContainer.encode(historicalOptions, forKey: .historicalOptions)
        }
        if let lastAutoAdjustTime = self.lastAutoAdjustTime {
            try encodeContainer.encodeTimestamp(lastAutoAdjustTime, format: .epochSeconds, forKey: .lastAutoAdjustTime)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let autoAdjustTypeDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.AutoAdjustType.self, forKey: .autoAdjustType)
        autoAdjustType = autoAdjustTypeDecoded
        let historicalOptionsDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.HistoricalOptions.self, forKey: .historicalOptions)
        historicalOptions = historicalOptionsDecoded
        let lastAutoAdjustTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastAutoAdjustTime)
        lastAutoAdjustTime = lastAutoAdjustTimeDecoded
    }
}

extension BudgetsClientTypes {
    /// The parameters that determine the budget amount for an auto-adjusting budget.
    public struct AutoAdjustData: Swift.Equatable {
        /// The string that defines whether your budget auto-adjusts based on historical or forecasted data.
        /// This member is required.
        public var autoAdjustType: BudgetsClientTypes.AutoAdjustType?
        /// The parameters that define or describe the historical data that your auto-adjusting budget is based on.
        public var historicalOptions: BudgetsClientTypes.HistoricalOptions?
        /// The last time that your budget was auto-adjusted.
        public var lastAutoAdjustTime: ClientRuntime.Date?

        public init(
            autoAdjustType: BudgetsClientTypes.AutoAdjustType? = nil,
            historicalOptions: BudgetsClientTypes.HistoricalOptions? = nil,
            lastAutoAdjustTime: ClientRuntime.Date? = nil
        )
        {
            self.autoAdjustType = autoAdjustType
            self.historicalOptions = historicalOptions
            self.lastAutoAdjustTime = lastAutoAdjustTime
        }
    }

}

extension BudgetsClientTypes {
    public enum AutoAdjustType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case forecast
        case historical
        case sdkUnknown(Swift.String)

        public static var allCases: [AutoAdjustType] {
            return [
                .forecast,
                .historical,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .forecast: return "FORECAST"
            case .historical: return "HISTORICAL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AutoAdjustType(rawValue: rawValue) ?? AutoAdjustType.sdkUnknown(rawValue)
        }
    }
}

extension BudgetsClientTypes.Budget: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoAdjustData = "AutoAdjustData"
        case budgetLimit = "BudgetLimit"
        case budgetName = "BudgetName"
        case budgetType = "BudgetType"
        case calculatedSpend = "CalculatedSpend"
        case costFilters = "CostFilters"
        case costTypes = "CostTypes"
        case lastUpdatedTime = "LastUpdatedTime"
        case plannedBudgetLimits = "PlannedBudgetLimits"
        case timePeriod = "TimePeriod"
        case timeUnit = "TimeUnit"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let autoAdjustData = self.autoAdjustData {
            try encodeContainer.encode(autoAdjustData, forKey: .autoAdjustData)
        }
        if let budgetLimit = self.budgetLimit {
            try encodeContainer.encode(budgetLimit, forKey: .budgetLimit)
        }
        if let budgetName = self.budgetName {
            try encodeContainer.encode(budgetName, forKey: .budgetName)
        }
        if let budgetType = self.budgetType {
            try encodeContainer.encode(budgetType.rawValue, forKey: .budgetType)
        }
        if let calculatedSpend = self.calculatedSpend {
            try encodeContainer.encode(calculatedSpend, forKey: .calculatedSpend)
        }
        if let costFilters = costFilters {
            var costFiltersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .costFilters)
            for (dictKey0, costFilters0) in costFilters {
                var costFilters0Container = costFiltersContainer.nestedUnkeyedContainer(forKey: ClientRuntime.Key(stringValue: dictKey0))
                for dimensionvalue1 in costFilters0 {
                    try costFilters0Container.encode(dimensionvalue1)
                }
            }
        }
        if let costTypes = self.costTypes {
            try encodeContainer.encode(costTypes, forKey: .costTypes)
        }
        if let lastUpdatedTime = self.lastUpdatedTime {
            try encodeContainer.encodeTimestamp(lastUpdatedTime, format: .epochSeconds, forKey: .lastUpdatedTime)
        }
        if let plannedBudgetLimits = plannedBudgetLimits {
            var plannedBudgetLimitsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .plannedBudgetLimits)
            for (dictKey0, plannedBudgetLimits0) in plannedBudgetLimits {
                try plannedBudgetLimitsContainer.encode(plannedBudgetLimits0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let timePeriod = self.timePeriod {
            try encodeContainer.encode(timePeriod, forKey: .timePeriod)
        }
        if let timeUnit = self.timeUnit {
            try encodeContainer.encode(timeUnit.rawValue, forKey: .timeUnit)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let budgetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .budgetName)
        budgetName = budgetNameDecoded
        let budgetLimitDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.Spend.self, forKey: .budgetLimit)
        budgetLimit = budgetLimitDecoded
        let plannedBudgetLimitsContainer = try containerValues.decodeIfPresent([Swift.String: BudgetsClientTypes.Spend?].self, forKey: .plannedBudgetLimits)
        var plannedBudgetLimitsDecoded0: [Swift.String:BudgetsClientTypes.Spend]? = nil
        if let plannedBudgetLimitsContainer = plannedBudgetLimitsContainer {
            plannedBudgetLimitsDecoded0 = [Swift.String:BudgetsClientTypes.Spend]()
            for (key0, spend0) in plannedBudgetLimitsContainer {
                if let spend0 = spend0 {
                    plannedBudgetLimitsDecoded0?[key0] = spend0
                }
            }
        }
        plannedBudgetLimits = plannedBudgetLimitsDecoded0
        let costFiltersContainer = try containerValues.decodeIfPresent([Swift.String: [Swift.String?]?].self, forKey: .costFilters)
        var costFiltersDecoded0: [Swift.String:[Swift.String]]? = nil
        if let costFiltersContainer = costFiltersContainer {
            costFiltersDecoded0 = [Swift.String:[Swift.String]]()
            for (key0, dimensionvalues0) in costFiltersContainer {
                var dimensionvalues0Decoded0: [Swift.String]? = nil
                if let dimensionvalues0 = dimensionvalues0 {
                    dimensionvalues0Decoded0 = [Swift.String]()
                    for string1 in dimensionvalues0 {
                        if let string1 = string1 {
                            dimensionvalues0Decoded0?.append(string1)
                        }
                    }
                }
                costFiltersDecoded0?[key0] = dimensionvalues0Decoded0
            }
        }
        costFilters = costFiltersDecoded0
        let costTypesDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.CostTypes.self, forKey: .costTypes)
        costTypes = costTypesDecoded
        let timeUnitDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.TimeUnit.self, forKey: .timeUnit)
        timeUnit = timeUnitDecoded
        let timePeriodDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.TimePeriod.self, forKey: .timePeriod)
        timePeriod = timePeriodDecoded
        let calculatedSpendDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.CalculatedSpend.self, forKey: .calculatedSpend)
        calculatedSpend = calculatedSpendDecoded
        let budgetTypeDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.BudgetType.self, forKey: .budgetType)
        budgetType = budgetTypeDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
        let autoAdjustDataDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.AutoAdjustData.self, forKey: .autoAdjustData)
        autoAdjustData = autoAdjustDataDecoded
    }
}

extension BudgetsClientTypes {
    /// Represents the output of the CreateBudget operation. The content consists of the detailed metadata and data file information, and the current status of the budget object. This is the Amazon Resource Name (ARN) pattern for a budget: arn:aws:budgets::AccountId:budget/budgetName
    public struct Budget: Swift.Equatable {
        /// The parameters that determine the budget amount for an auto-adjusting budget.
        public var autoAdjustData: BudgetsClientTypes.AutoAdjustData?
        /// The total amount of cost, usage, RI utilization, RI coverage, Savings Plans utilization, or Savings Plans coverage that you want to track with your budget. BudgetLimit is required for cost or usage budgets, but optional for RI or Savings Plans utilization or coverage budgets. RI and Savings Plans utilization or coverage budgets default to 100. This is the only valid value for RI or Savings Plans utilization or coverage budgets. You can't use BudgetLimit with PlannedBudgetLimits for CreateBudget and UpdateBudget actions.
        public var budgetLimit: BudgetsClientTypes.Spend?
        /// The name of a budget. The name must be unique within an account. The : and \ characters, and the "/action/" substring, aren't allowed in BudgetName.
        /// This member is required.
        public var budgetName: Swift.String?
        /// Specifies whether this budget tracks costs, usage, RI utilization, RI coverage, Savings Plans utilization, or Savings Plans coverage.
        /// This member is required.
        public var budgetType: BudgetsClientTypes.BudgetType?
        /// The actual and forecasted cost or usage that the budget tracks.
        public var calculatedSpend: BudgetsClientTypes.CalculatedSpend?
        /// The cost filters, such as Region, Service, member account, Tag, or Cost Category, that are applied to a budget. Amazon Web Services Budgets supports the following services as a Service filter for RI budgets:
        ///
        /// * Amazon EC2
        ///
        /// * Amazon Redshift
        ///
        /// * Amazon Relational Database Service
        ///
        /// * Amazon ElastiCache
        ///
        /// * Amazon OpenSearch Service
        public var costFilters: [Swift.String:[Swift.String]]?
        /// The types of costs that are included in this COST budget. USAGE, RI_UTILIZATION, RI_COVERAGE, SAVINGS_PLANS_UTILIZATION, and SAVINGS_PLANS_COVERAGE budgets do not have CostTypes.
        public var costTypes: BudgetsClientTypes.CostTypes?
        /// The last time that you updated this budget.
        public var lastUpdatedTime: ClientRuntime.Date?
        /// A map containing multiple BudgetLimit, including current or future limits. PlannedBudgetLimits is available for cost or usage budget and supports both monthly and quarterly TimeUnit. For monthly budgets, provide 12 months of PlannedBudgetLimits values. This must start from the current month and include the next 11 months. The key is the start of the month, UTC in epoch seconds. For quarterly budgets, provide four quarters of PlannedBudgetLimits value entries in standard calendar quarter increments. This must start from the current quarter and include the next three quarters. The key is the start of the quarter, UTC in epoch seconds. If the planned budget expires before 12 months for monthly or four quarters for quarterly, provide the PlannedBudgetLimits values only for the remaining periods. If the budget begins at a date in the future, provide PlannedBudgetLimits values from the start date of the budget. After all of the BudgetLimit values in PlannedBudgetLimits are used, the budget continues to use the last limit as the BudgetLimit. At that point, the planned budget provides the same experience as a fixed budget. DescribeBudget and DescribeBudgets response along with PlannedBudgetLimits also contain BudgetLimit representing the current month or quarter limit present in PlannedBudgetLimits. This only applies to budgets that are created with PlannedBudgetLimits. Budgets that are created without PlannedBudgetLimits only contain BudgetLimit. They don't contain PlannedBudgetLimits.
        public var plannedBudgetLimits: [Swift.String:BudgetsClientTypes.Spend]?
        /// The period of time that's covered by a budget. You setthe start date and end date. The start date must come before the end date. The end date must come before 06/15/87 00:00 UTC. If you create your budget and don't specify a start date, Amazon Web Services defaults to the start of your chosen time period (DAILY, MONTHLY, QUARTERLY, or ANNUALLY). For example, if you created your budget on January 24, 2018, chose DAILY, and didn't set a start date, Amazon Web Services set your start date to 01/24/18 00:00 UTC. If you chose MONTHLY, Amazon Web Services set your start date to 01/01/18 00:00 UTC. If you didn't specify an end date, Amazon Web Services set your end date to 06/15/87 00:00 UTC. The defaults are the same for the Billing and Cost Management console and the API. You can change either date with the UpdateBudget operation. After the end date, Amazon Web Services deletes the budget and all the associated notifications and subscribers.
        public var timePeriod: BudgetsClientTypes.TimePeriod?
        /// The length of time until a budget resets the actual and forecasted spend.
        /// This member is required.
        public var timeUnit: BudgetsClientTypes.TimeUnit?

        public init(
            autoAdjustData: BudgetsClientTypes.AutoAdjustData? = nil,
            budgetLimit: BudgetsClientTypes.Spend? = nil,
            budgetName: Swift.String? = nil,
            budgetType: BudgetsClientTypes.BudgetType? = nil,
            calculatedSpend: BudgetsClientTypes.CalculatedSpend? = nil,
            costFilters: [Swift.String:[Swift.String]]? = nil,
            costTypes: BudgetsClientTypes.CostTypes? = nil,
            lastUpdatedTime: ClientRuntime.Date? = nil,
            plannedBudgetLimits: [Swift.String:BudgetsClientTypes.Spend]? = nil,
            timePeriod: BudgetsClientTypes.TimePeriod? = nil,
            timeUnit: BudgetsClientTypes.TimeUnit? = nil
        )
        {
            self.autoAdjustData = autoAdjustData
            self.budgetLimit = budgetLimit
            self.budgetName = budgetName
            self.budgetType = budgetType
            self.calculatedSpend = calculatedSpend
            self.costFilters = costFilters
            self.costTypes = costTypes
            self.lastUpdatedTime = lastUpdatedTime
            self.plannedBudgetLimits = plannedBudgetLimits
            self.timePeriod = timePeriod
            self.timeUnit = timeUnit
        }
    }

}

extension BudgetsClientTypes.BudgetNotificationsForAccount: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case budgetName = "BudgetName"
        case notifications = "Notifications"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let budgetName = self.budgetName {
            try encodeContainer.encode(budgetName, forKey: .budgetName)
        }
        if let notifications = notifications {
            var notificationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .notifications)
            for notification0 in notifications {
                try notificationsContainer.encode(notification0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let notificationsContainer = try containerValues.decodeIfPresent([BudgetsClientTypes.Notification?].self, forKey: .notifications)
        var notificationsDecoded0:[BudgetsClientTypes.Notification]? = nil
        if let notificationsContainer = notificationsContainer {
            notificationsDecoded0 = [BudgetsClientTypes.Notification]()
            for structure0 in notificationsContainer {
                if let structure0 = structure0 {
                    notificationsDecoded0?.append(structure0)
                }
            }
        }
        notifications = notificationsDecoded0
        let budgetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .budgetName)
        budgetName = budgetNameDecoded
    }
}

extension BudgetsClientTypes {
    /// The budget name and associated notifications for an account.
    public struct BudgetNotificationsForAccount: Swift.Equatable {
        /// A string that represents the budget name. The ":" and "\" characters, and the "/action/" substring, aren't allowed.
        public var budgetName: Swift.String?
        /// A list of notifications.
        public var notifications: [BudgetsClientTypes.Notification]?

        public init(
            budgetName: Swift.String? = nil,
            notifications: [BudgetsClientTypes.Notification]? = nil
        )
        {
            self.budgetName = budgetName
            self.notifications = notifications
        }
    }

}

extension BudgetsClientTypes.BudgetPerformanceHistory: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case budgetName = "BudgetName"
        case budgetType = "BudgetType"
        case budgetedAndActualAmountsList = "BudgetedAndActualAmountsList"
        case costFilters = "CostFilters"
        case costTypes = "CostTypes"
        case timeUnit = "TimeUnit"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let budgetName = self.budgetName {
            try encodeContainer.encode(budgetName, forKey: .budgetName)
        }
        if let budgetType = self.budgetType {
            try encodeContainer.encode(budgetType.rawValue, forKey: .budgetType)
        }
        if let budgetedAndActualAmountsList = budgetedAndActualAmountsList {
            var budgetedAndActualAmountsListContainer = encodeContainer.nestedUnkeyedContainer(forKey: .budgetedAndActualAmountsList)
            for budgetedandactualamounts0 in budgetedAndActualAmountsList {
                try budgetedAndActualAmountsListContainer.encode(budgetedandactualamounts0)
            }
        }
        if let costFilters = costFilters {
            var costFiltersContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .costFilters)
            for (dictKey0, costFilters0) in costFilters {
                var costFilters0Container = costFiltersContainer.nestedUnkeyedContainer(forKey: ClientRuntime.Key(stringValue: dictKey0))
                for dimensionvalue1 in costFilters0 {
                    try costFilters0Container.encode(dimensionvalue1)
                }
            }
        }
        if let costTypes = self.costTypes {
            try encodeContainer.encode(costTypes, forKey: .costTypes)
        }
        if let timeUnit = self.timeUnit {
            try encodeContainer.encode(timeUnit.rawValue, forKey: .timeUnit)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let budgetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .budgetName)
        budgetName = budgetNameDecoded
        let budgetTypeDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.BudgetType.self, forKey: .budgetType)
        budgetType = budgetTypeDecoded
        let costFiltersContainer = try containerValues.decodeIfPresent([Swift.String: [Swift.String?]?].self, forKey: .costFilters)
        var costFiltersDecoded0: [Swift.String:[Swift.String]]? = nil
        if let costFiltersContainer = costFiltersContainer {
            costFiltersDecoded0 = [Swift.String:[Swift.String]]()
            for (key0, dimensionvalues0) in costFiltersContainer {
                var dimensionvalues0Decoded0: [Swift.String]? = nil
                if let dimensionvalues0 = dimensionvalues0 {
                    dimensionvalues0Decoded0 = [Swift.String]()
                    for string1 in dimensionvalues0 {
                        if let string1 = string1 {
                            dimensionvalues0Decoded0?.append(string1)
                        }
                    }
                }
                costFiltersDecoded0?[key0] = dimensionvalues0Decoded0
            }
        }
        costFilters = costFiltersDecoded0
        let costTypesDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.CostTypes.self, forKey: .costTypes)
        costTypes = costTypesDecoded
        let timeUnitDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.TimeUnit.self, forKey: .timeUnit)
        timeUnit = timeUnitDecoded
        let budgetedAndActualAmountsListContainer = try containerValues.decodeIfPresent([BudgetsClientTypes.BudgetedAndActualAmounts?].self, forKey: .budgetedAndActualAmountsList)
        var budgetedAndActualAmountsListDecoded0:[BudgetsClientTypes.BudgetedAndActualAmounts]? = nil
        if let budgetedAndActualAmountsListContainer = budgetedAndActualAmountsListContainer {
            budgetedAndActualAmountsListDecoded0 = [BudgetsClientTypes.BudgetedAndActualAmounts]()
            for structure0 in budgetedAndActualAmountsListContainer {
                if let structure0 = structure0 {
                    budgetedAndActualAmountsListDecoded0?.append(structure0)
                }
            }
        }
        budgetedAndActualAmountsList = budgetedAndActualAmountsListDecoded0
    }
}

extension BudgetsClientTypes {
    /// A history of the state of a budget at the end of the budget's specified time period.
    public struct BudgetPerformanceHistory: Swift.Equatable {
        /// A string that represents the budget name. The ":" and "\" characters, and the "/action/" substring, aren't allowed.
        public var budgetName: Swift.String?
        /// The type of a budget. It must be one of the following types: COST, USAGE, RI_UTILIZATION, RI_COVERAGE, SAVINGS_PLANS_UTILIZATION, or SAVINGS_PLANS_COVERAGE.
        public var budgetType: BudgetsClientTypes.BudgetType?
        /// A list of amounts of cost or usage that you created budgets for, which are compared to your actual costs or usage.
        public var budgetedAndActualAmountsList: [BudgetsClientTypes.BudgetedAndActualAmounts]?
        /// The history of the cost filters for a budget during the specified time period.
        public var costFilters: [Swift.String:[Swift.String]]?
        /// The history of the cost types for a budget during the specified time period.
        public var costTypes: BudgetsClientTypes.CostTypes?
        /// The time unit of the budget, such as MONTHLY or QUARTERLY.
        public var timeUnit: BudgetsClientTypes.TimeUnit?

        public init(
            budgetName: Swift.String? = nil,
            budgetType: BudgetsClientTypes.BudgetType? = nil,
            budgetedAndActualAmountsList: [BudgetsClientTypes.BudgetedAndActualAmounts]? = nil,
            costFilters: [Swift.String:[Swift.String]]? = nil,
            costTypes: BudgetsClientTypes.CostTypes? = nil,
            timeUnit: BudgetsClientTypes.TimeUnit? = nil
        )
        {
            self.budgetName = budgetName
            self.budgetType = budgetType
            self.budgetedAndActualAmountsList = budgetedAndActualAmountsList
            self.costFilters = costFilters
            self.costTypes = costTypes
            self.timeUnit = timeUnit
        }
    }

}

extension BudgetsClientTypes {
    /// The type of a budget. It must be one of the following types: COST, USAGE, RI_UTILIZATION, RI_COVERAGE, SAVINGS_PLANS_UTILIZATION, or SAVINGS_PLANS_COVERAGE.
    public enum BudgetType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cost
        case ricoverage
        case riutilization
        case spcoverage
        case sputilization
        case usage
        case sdkUnknown(Swift.String)

        public static var allCases: [BudgetType] {
            return [
                .cost,
                .ricoverage,
                .riutilization,
                .spcoverage,
                .sputilization,
                .usage,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cost: return "COST"
            case .ricoverage: return "RI_COVERAGE"
            case .riutilization: return "RI_UTILIZATION"
            case .spcoverage: return "SAVINGS_PLANS_COVERAGE"
            case .sputilization: return "SAVINGS_PLANS_UTILIZATION"
            case .usage: return "USAGE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = BudgetType(rawValue: rawValue) ?? BudgetType.sdkUnknown(rawValue)
        }
    }
}

extension BudgetsClientTypes.BudgetedAndActualAmounts: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actualAmount = "ActualAmount"
        case budgetedAmount = "BudgetedAmount"
        case timePeriod = "TimePeriod"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actualAmount = self.actualAmount {
            try encodeContainer.encode(actualAmount, forKey: .actualAmount)
        }
        if let budgetedAmount = self.budgetedAmount {
            try encodeContainer.encode(budgetedAmount, forKey: .budgetedAmount)
        }
        if let timePeriod = self.timePeriod {
            try encodeContainer.encode(timePeriod, forKey: .timePeriod)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let budgetedAmountDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.Spend.self, forKey: .budgetedAmount)
        budgetedAmount = budgetedAmountDecoded
        let actualAmountDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.Spend.self, forKey: .actualAmount)
        actualAmount = actualAmountDecoded
        let timePeriodDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.TimePeriod.self, forKey: .timePeriod)
        timePeriod = timePeriodDecoded
    }
}

extension BudgetsClientTypes {
    /// The amount of cost or usage that you created the budget for, compared to your actual costs or usage.
    public struct BudgetedAndActualAmounts: Swift.Equatable {
        /// Your actual costs or usage for a budget period.
        public var actualAmount: BudgetsClientTypes.Spend?
        /// The amount of cost or usage that you created the budget for.
        public var budgetedAmount: BudgetsClientTypes.Spend?
        /// The time period that's covered by this budget comparison.
        public var timePeriod: BudgetsClientTypes.TimePeriod?

        public init(
            actualAmount: BudgetsClientTypes.Spend? = nil,
            budgetedAmount: BudgetsClientTypes.Spend? = nil,
            timePeriod: BudgetsClientTypes.TimePeriod? = nil
        )
        {
            self.actualAmount = actualAmount
            self.budgetedAmount = budgetedAmount
            self.timePeriod = timePeriod
        }
    }

}

extension BudgetsClientTypes.CalculatedSpend: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actualSpend = "ActualSpend"
        case forecastedSpend = "ForecastedSpend"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actualSpend = self.actualSpend {
            try encodeContainer.encode(actualSpend, forKey: .actualSpend)
        }
        if let forecastedSpend = self.forecastedSpend {
            try encodeContainer.encode(forecastedSpend, forKey: .forecastedSpend)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actualSpendDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.Spend.self, forKey: .actualSpend)
        actualSpend = actualSpendDecoded
        let forecastedSpendDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.Spend.self, forKey: .forecastedSpend)
        forecastedSpend = forecastedSpendDecoded
    }
}

extension BudgetsClientTypes {
    /// The spend objects that are associated with this budget. The actualSpend tracks how much you've used, cost, usage, RI units, or Savings Plans units and the forecastedSpend tracks how much that you're predicted to spend based on your historical usage profile. For example, if it's the 20th of the month and you have spent 50 dollars on Amazon EC2, your actualSpend is 50 USD, and your forecastedSpend is 75 USD.
    public struct CalculatedSpend: Swift.Equatable {
        /// The amount of cost, usage, RI units, or Savings Plans units that you used.
        /// This member is required.
        public var actualSpend: BudgetsClientTypes.Spend?
        /// The amount of cost, usage, RI units, or Savings Plans units that you're forecasted to use.
        public var forecastedSpend: BudgetsClientTypes.Spend?

        public init(
            actualSpend: BudgetsClientTypes.Spend? = nil,
            forecastedSpend: BudgetsClientTypes.Spend? = nil
        )
        {
            self.actualSpend = actualSpend
            self.forecastedSpend = forecastedSpend
        }
    }

}

extension BudgetsClientTypes {
    /// The comparison operator of a notification. Currently, the service supports the following operators: GREATER_THAN, LESS_THAN, EQUAL_TO
    public enum ComparisonOperator: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case equalTo
        case greaterThan
        case lessThan
        case sdkUnknown(Swift.String)

        public static var allCases: [ComparisonOperator] {
            return [
                .equalTo,
                .greaterThan,
                .lessThan,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .equalTo: return "EQUAL_TO"
            case .greaterThan: return "GREATER_THAN"
            case .lessThan: return "LESS_THAN"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ComparisonOperator(rawValue: rawValue) ?? ComparisonOperator.sdkUnknown(rawValue)
        }
    }
}

extension BudgetsClientTypes.CostTypes: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case includeCredit = "IncludeCredit"
        case includeDiscount = "IncludeDiscount"
        case includeOtherSubscription = "IncludeOtherSubscription"
        case includeRecurring = "IncludeRecurring"
        case includeRefund = "IncludeRefund"
        case includeSubscription = "IncludeSubscription"
        case includeSupport = "IncludeSupport"
        case includeTax = "IncludeTax"
        case includeUpfront = "IncludeUpfront"
        case useAmortized = "UseAmortized"
        case useBlended = "UseBlended"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let includeCredit = self.includeCredit {
            try encodeContainer.encode(includeCredit, forKey: .includeCredit)
        }
        if let includeDiscount = self.includeDiscount {
            try encodeContainer.encode(includeDiscount, forKey: .includeDiscount)
        }
        if let includeOtherSubscription = self.includeOtherSubscription {
            try encodeContainer.encode(includeOtherSubscription, forKey: .includeOtherSubscription)
        }
        if let includeRecurring = self.includeRecurring {
            try encodeContainer.encode(includeRecurring, forKey: .includeRecurring)
        }
        if let includeRefund = self.includeRefund {
            try encodeContainer.encode(includeRefund, forKey: .includeRefund)
        }
        if let includeSubscription = self.includeSubscription {
            try encodeContainer.encode(includeSubscription, forKey: .includeSubscription)
        }
        if let includeSupport = self.includeSupport {
            try encodeContainer.encode(includeSupport, forKey: .includeSupport)
        }
        if let includeTax = self.includeTax {
            try encodeContainer.encode(includeTax, forKey: .includeTax)
        }
        if let includeUpfront = self.includeUpfront {
            try encodeContainer.encode(includeUpfront, forKey: .includeUpfront)
        }
        if let useAmortized = self.useAmortized {
            try encodeContainer.encode(useAmortized, forKey: .useAmortized)
        }
        if let useBlended = self.useBlended {
            try encodeContainer.encode(useBlended, forKey: .useBlended)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let includeTaxDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .includeTax)
        includeTax = includeTaxDecoded
        let includeSubscriptionDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .includeSubscription)
        includeSubscription = includeSubscriptionDecoded
        let useBlendedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .useBlended)
        useBlended = useBlendedDecoded
        let includeRefundDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .includeRefund)
        includeRefund = includeRefundDecoded
        let includeCreditDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .includeCredit)
        includeCredit = includeCreditDecoded
        let includeUpfrontDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .includeUpfront)
        includeUpfront = includeUpfrontDecoded
        let includeRecurringDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .includeRecurring)
        includeRecurring = includeRecurringDecoded
        let includeOtherSubscriptionDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .includeOtherSubscription)
        includeOtherSubscription = includeOtherSubscriptionDecoded
        let includeSupportDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .includeSupport)
        includeSupport = includeSupportDecoded
        let includeDiscountDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .includeDiscount)
        includeDiscount = includeDiscountDecoded
        let useAmortizedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .useAmortized)
        useAmortized = useAmortizedDecoded
    }
}

extension BudgetsClientTypes {
    /// The types of cost that are included in a COST budget, such as tax and subscriptions. USAGE, RI_UTILIZATION, RI_COVERAGE, SAVINGS_PLANS_UTILIZATION, and SAVINGS_PLANS_COVERAGE budgets don't have CostTypes.
    public struct CostTypes: Swift.Equatable {
        /// Specifies whether a budget includes credits. The default value is true.
        public var includeCredit: Swift.Bool?
        /// Specifies whether a budget includes discounts. The default value is true.
        public var includeDiscount: Swift.Bool?
        /// Specifies whether a budget includes non-RI subscription costs. The default value is true.
        public var includeOtherSubscription: Swift.Bool?
        /// Specifies whether a budget includes recurring fees such as monthly RI fees. The default value is true.
        public var includeRecurring: Swift.Bool?
        /// Specifies whether a budget includes refunds. The default value is true.
        public var includeRefund: Swift.Bool?
        /// Specifies whether a budget includes subscriptions. The default value is true.
        public var includeSubscription: Swift.Bool?
        /// Specifies whether a budget includes support subscription fees. The default value is true.
        public var includeSupport: Swift.Bool?
        /// Specifies whether a budget includes taxes. The default value is true.
        public var includeTax: Swift.Bool?
        /// Specifies whether a budget includes upfront RI costs. The default value is true.
        public var includeUpfront: Swift.Bool?
        /// Specifies whether a budget uses the amortized rate. The default value is false.
        public var useAmortized: Swift.Bool?
        /// Specifies whether a budget uses a blended rate. The default value is false.
        public var useBlended: Swift.Bool?

        public init(
            includeCredit: Swift.Bool? = nil,
            includeDiscount: Swift.Bool? = nil,
            includeOtherSubscription: Swift.Bool? = nil,
            includeRecurring: Swift.Bool? = nil,
            includeRefund: Swift.Bool? = nil,
            includeSubscription: Swift.Bool? = nil,
            includeSupport: Swift.Bool? = nil,
            includeTax: Swift.Bool? = nil,
            includeUpfront: Swift.Bool? = nil,
            useAmortized: Swift.Bool? = nil,
            useBlended: Swift.Bool? = nil
        )
        {
            self.includeCredit = includeCredit
            self.includeDiscount = includeDiscount
            self.includeOtherSubscription = includeOtherSubscription
            self.includeRecurring = includeRecurring
            self.includeRefund = includeRefund
            self.includeSubscription = includeSubscription
            self.includeSupport = includeSupport
            self.includeTax = includeTax
            self.includeUpfront = includeUpfront
            self.useAmortized = useAmortized
            self.useBlended = useBlended
        }
    }

}

extension CreateBudgetActionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case actionThreshold = "ActionThreshold"
        case actionType = "ActionType"
        case approvalModel = "ApprovalModel"
        case budgetName = "BudgetName"
        case definition = "Definition"
        case executionRoleArn = "ExecutionRoleArn"
        case notificationType = "NotificationType"
        case subscribers = "Subscribers"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let actionThreshold = self.actionThreshold {
            try encodeContainer.encode(actionThreshold, forKey: .actionThreshold)
        }
        if let actionType = self.actionType {
            try encodeContainer.encode(actionType.rawValue, forKey: .actionType)
        }
        if let approvalModel = self.approvalModel {
            try encodeContainer.encode(approvalModel.rawValue, forKey: .approvalModel)
        }
        if let budgetName = self.budgetName {
            try encodeContainer.encode(budgetName, forKey: .budgetName)
        }
        if let definition = self.definition {
            try encodeContainer.encode(definition, forKey: .definition)
        }
        if let executionRoleArn = self.executionRoleArn {
            try encodeContainer.encode(executionRoleArn, forKey: .executionRoleArn)
        }
        if let notificationType = self.notificationType {
            try encodeContainer.encode(notificationType.rawValue, forKey: .notificationType)
        }
        if let subscribers = subscribers {
            var subscribersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subscribers)
            for subscriber0 in subscribers {
                try subscribersContainer.encode(subscriber0)
            }
        }
    }
}

extension CreateBudgetActionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateBudgetActionInput: Swift.Equatable {
    /// The account ID of the user. It's a 12-digit number.
    /// This member is required.
    public var accountId: Swift.String?
    /// The trigger threshold of the action.
    /// This member is required.
    public var actionThreshold: BudgetsClientTypes.ActionThreshold?
    /// The type of action. This defines the type of tasks that can be carried out by this action. This field also determines the format for definition.
    /// This member is required.
    public var actionType: BudgetsClientTypes.ActionType?
    /// This specifies if the action needs manual or automatic approval.
    /// This member is required.
    public var approvalModel: BudgetsClientTypes.ApprovalModel?
    /// A string that represents the budget name. The ":" and "\" characters, and the "/action/" substring, aren't allowed.
    /// This member is required.
    public var budgetName: Swift.String?
    /// Specifies all of the type-specific parameters.
    /// This member is required.
    public var definition: BudgetsClientTypes.Definition?
    /// The role passed for action execution and reversion. Roles and actions must be in the same account.
    /// This member is required.
    public var executionRoleArn: Swift.String?
    /// The type of a notification. It must be ACTUAL or FORECASTED.
    /// This member is required.
    public var notificationType: BudgetsClientTypes.NotificationType?
    /// A list of subscribers.
    /// This member is required.
    public var subscribers: [BudgetsClientTypes.Subscriber]?

    public init(
        accountId: Swift.String? = nil,
        actionThreshold: BudgetsClientTypes.ActionThreshold? = nil,
        actionType: BudgetsClientTypes.ActionType? = nil,
        approvalModel: BudgetsClientTypes.ApprovalModel? = nil,
        budgetName: Swift.String? = nil,
        definition: BudgetsClientTypes.Definition? = nil,
        executionRoleArn: Swift.String? = nil,
        notificationType: BudgetsClientTypes.NotificationType? = nil,
        subscribers: [BudgetsClientTypes.Subscriber]? = nil
    )
    {
        self.accountId = accountId
        self.actionThreshold = actionThreshold
        self.actionType = actionType
        self.approvalModel = approvalModel
        self.budgetName = budgetName
        self.definition = definition
        self.executionRoleArn = executionRoleArn
        self.notificationType = notificationType
        self.subscribers = subscribers
    }
}

struct CreateBudgetActionInputBody: Swift.Equatable {
    let accountId: Swift.String?
    let budgetName: Swift.String?
    let notificationType: BudgetsClientTypes.NotificationType?
    let actionType: BudgetsClientTypes.ActionType?
    let actionThreshold: BudgetsClientTypes.ActionThreshold?
    let definition: BudgetsClientTypes.Definition?
    let executionRoleArn: Swift.String?
    let approvalModel: BudgetsClientTypes.ApprovalModel?
    let subscribers: [BudgetsClientTypes.Subscriber]?
}

extension CreateBudgetActionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case actionThreshold = "ActionThreshold"
        case actionType = "ActionType"
        case approvalModel = "ApprovalModel"
        case budgetName = "BudgetName"
        case definition = "Definition"
        case executionRoleArn = "ExecutionRoleArn"
        case notificationType = "NotificationType"
        case subscribers = "Subscribers"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let budgetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .budgetName)
        budgetName = budgetNameDecoded
        let notificationTypeDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.NotificationType.self, forKey: .notificationType)
        notificationType = notificationTypeDecoded
        let actionTypeDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.ActionType.self, forKey: .actionType)
        actionType = actionTypeDecoded
        let actionThresholdDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.ActionThreshold.self, forKey: .actionThreshold)
        actionThreshold = actionThresholdDecoded
        let definitionDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.Definition.self, forKey: .definition)
        definition = definitionDecoded
        let executionRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .executionRoleArn)
        executionRoleArn = executionRoleArnDecoded
        let approvalModelDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.ApprovalModel.self, forKey: .approvalModel)
        approvalModel = approvalModelDecoded
        let subscribersContainer = try containerValues.decodeIfPresent([BudgetsClientTypes.Subscriber?].self, forKey: .subscribers)
        var subscribersDecoded0:[BudgetsClientTypes.Subscriber]? = nil
        if let subscribersContainer = subscribersContainer {
            subscribersDecoded0 = [BudgetsClientTypes.Subscriber]()
            for structure0 in subscribersContainer {
                if let structure0 = structure0 {
                    subscribersDecoded0?.append(structure0)
                }
            }
        }
        subscribers = subscribersDecoded0
    }
}

extension CreateBudgetActionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateBudgetActionOutputBody = try responseDecoder.decode(responseBody: data)
            self.accountId = output.accountId
            self.actionId = output.actionId
            self.budgetName = output.budgetName
        } else {
            self.accountId = nil
            self.actionId = nil
            self.budgetName = nil
        }
    }
}

public struct CreateBudgetActionOutput: Swift.Equatable {
    /// The account ID of the user. It's a 12-digit number.
    /// This member is required.
    public var accountId: Swift.String?
    /// A system-generated universally unique identifier (UUID) for the action.
    /// This member is required.
    public var actionId: Swift.String?
    /// A string that represents the budget name. The ":" and "\" characters, and the "/action/" substring, aren't allowed.
    /// This member is required.
    public var budgetName: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        actionId: Swift.String? = nil,
        budgetName: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.actionId = actionId
        self.budgetName = budgetName
    }
}

struct CreateBudgetActionOutputBody: Swift.Equatable {
    let accountId: Swift.String?
    let budgetName: Swift.String?
    let actionId: Swift.String?
}

extension CreateBudgetActionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case actionId = "ActionId"
        case budgetName = "BudgetName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let budgetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .budgetName)
        budgetName = budgetNameDecoded
        let actionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .actionId)
        actionId = actionIdDecoded
    }
}

enum CreateBudgetActionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "CreationLimitExceededException": return try await CreationLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "DuplicateRecordException": return try await DuplicateRecordException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalErrorException": return try await InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateBudgetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case budget = "Budget"
        case notificationsWithSubscribers = "NotificationsWithSubscribers"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let budget = self.budget {
            try encodeContainer.encode(budget, forKey: .budget)
        }
        if let notificationsWithSubscribers = notificationsWithSubscribers {
            var notificationsWithSubscribersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .notificationsWithSubscribers)
            for notificationwithsubscribers0 in notificationsWithSubscribers {
                try notificationsWithSubscribersContainer.encode(notificationwithsubscribers0)
            }
        }
    }
}

extension CreateBudgetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Request of CreateBudget
public struct CreateBudgetInput: Swift.Equatable {
    /// The accountId that is associated with the budget.
    /// This member is required.
    public var accountId: Swift.String?
    /// The budget object that you want to create.
    /// This member is required.
    public var budget: BudgetsClientTypes.Budget?
    /// A notification that you want to associate with a budget. A budget can have up to five notifications, and each notification can have one SNS subscriber and up to 10 email subscribers. If you include notifications and subscribers in your CreateBudget call, Amazon Web Services creates the notifications and subscribers for you.
    public var notificationsWithSubscribers: [BudgetsClientTypes.NotificationWithSubscribers]?

    public init(
        accountId: Swift.String? = nil,
        budget: BudgetsClientTypes.Budget? = nil,
        notificationsWithSubscribers: [BudgetsClientTypes.NotificationWithSubscribers]? = nil
    )
    {
        self.accountId = accountId
        self.budget = budget
        self.notificationsWithSubscribers = notificationsWithSubscribers
    }
}

struct CreateBudgetInputBody: Swift.Equatable {
    let accountId: Swift.String?
    let budget: BudgetsClientTypes.Budget?
    let notificationsWithSubscribers: [BudgetsClientTypes.NotificationWithSubscribers]?
}

extension CreateBudgetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case budget = "Budget"
        case notificationsWithSubscribers = "NotificationsWithSubscribers"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let budgetDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.Budget.self, forKey: .budget)
        budget = budgetDecoded
        let notificationsWithSubscribersContainer = try containerValues.decodeIfPresent([BudgetsClientTypes.NotificationWithSubscribers?].self, forKey: .notificationsWithSubscribers)
        var notificationsWithSubscribersDecoded0:[BudgetsClientTypes.NotificationWithSubscribers]? = nil
        if let notificationsWithSubscribersContainer = notificationsWithSubscribersContainer {
            notificationsWithSubscribersDecoded0 = [BudgetsClientTypes.NotificationWithSubscribers]()
            for structure0 in notificationsWithSubscribersContainer {
                if let structure0 = structure0 {
                    notificationsWithSubscribersDecoded0?.append(structure0)
                }
            }
        }
        notificationsWithSubscribers = notificationsWithSubscribersDecoded0
    }
}

extension CreateBudgetOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

/// Response of CreateBudget
public struct CreateBudgetOutput: Swift.Equatable {

    public init() { }
}

enum CreateBudgetOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "CreationLimitExceededException": return try await CreationLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "DuplicateRecordException": return try await DuplicateRecordException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalErrorException": return try await InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateNotificationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case budgetName = "BudgetName"
        case notification = "Notification"
        case subscribers = "Subscribers"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let budgetName = self.budgetName {
            try encodeContainer.encode(budgetName, forKey: .budgetName)
        }
        if let notification = self.notification {
            try encodeContainer.encode(notification, forKey: .notification)
        }
        if let subscribers = subscribers {
            var subscribersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subscribers)
            for subscriber0 in subscribers {
                try subscribersContainer.encode(subscriber0)
            }
        }
    }
}

extension CreateNotificationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Request of CreateNotification
public struct CreateNotificationInput: Swift.Equatable {
    /// The accountId that is associated with the budget that you want to create a notification for.
    /// This member is required.
    public var accountId: Swift.String?
    /// The name of the budget that you want Amazon Web Services to notify you about. Budget names must be unique within an account.
    /// This member is required.
    public var budgetName: Swift.String?
    /// The notification that you want to create.
    /// This member is required.
    public var notification: BudgetsClientTypes.Notification?
    /// A list of subscribers that you want to associate with the notification. Each notification can have one SNS subscriber and up to 10 email subscribers.
    /// This member is required.
    public var subscribers: [BudgetsClientTypes.Subscriber]?

    public init(
        accountId: Swift.String? = nil,
        budgetName: Swift.String? = nil,
        notification: BudgetsClientTypes.Notification? = nil,
        subscribers: [BudgetsClientTypes.Subscriber]? = nil
    )
    {
        self.accountId = accountId
        self.budgetName = budgetName
        self.notification = notification
        self.subscribers = subscribers
    }
}

struct CreateNotificationInputBody: Swift.Equatable {
    let accountId: Swift.String?
    let budgetName: Swift.String?
    let notification: BudgetsClientTypes.Notification?
    let subscribers: [BudgetsClientTypes.Subscriber]?
}

extension CreateNotificationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case budgetName = "BudgetName"
        case notification = "Notification"
        case subscribers = "Subscribers"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let budgetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .budgetName)
        budgetName = budgetNameDecoded
        let notificationDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.Notification.self, forKey: .notification)
        notification = notificationDecoded
        let subscribersContainer = try containerValues.decodeIfPresent([BudgetsClientTypes.Subscriber?].self, forKey: .subscribers)
        var subscribersDecoded0:[BudgetsClientTypes.Subscriber]? = nil
        if let subscribersContainer = subscribersContainer {
            subscribersDecoded0 = [BudgetsClientTypes.Subscriber]()
            for structure0 in subscribersContainer {
                if let structure0 = structure0 {
                    subscribersDecoded0?.append(structure0)
                }
            }
        }
        subscribers = subscribersDecoded0
    }
}

extension CreateNotificationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

/// Response of CreateNotification
public struct CreateNotificationOutput: Swift.Equatable {

    public init() { }
}

enum CreateNotificationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "CreationLimitExceededException": return try await CreationLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "DuplicateRecordException": return try await DuplicateRecordException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalErrorException": return try await InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateSubscriberInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case budgetName = "BudgetName"
        case notification = "Notification"
        case subscriber = "Subscriber"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let budgetName = self.budgetName {
            try encodeContainer.encode(budgetName, forKey: .budgetName)
        }
        if let notification = self.notification {
            try encodeContainer.encode(notification, forKey: .notification)
        }
        if let subscriber = self.subscriber {
            try encodeContainer.encode(subscriber, forKey: .subscriber)
        }
    }
}

extension CreateSubscriberInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Request of CreateSubscriber
public struct CreateSubscriberInput: Swift.Equatable {
    /// The accountId that is associated with the budget that you want to create a subscriber for.
    /// This member is required.
    public var accountId: Swift.String?
    /// The name of the budget that you want to subscribe to. Budget names must be unique within an account.
    /// This member is required.
    public var budgetName: Swift.String?
    /// The notification that you want to create a subscriber for.
    /// This member is required.
    public var notification: BudgetsClientTypes.Notification?
    /// The subscriber that you want to associate with a budget notification.
    /// This member is required.
    public var subscriber: BudgetsClientTypes.Subscriber?

    public init(
        accountId: Swift.String? = nil,
        budgetName: Swift.String? = nil,
        notification: BudgetsClientTypes.Notification? = nil,
        subscriber: BudgetsClientTypes.Subscriber? = nil
    )
    {
        self.accountId = accountId
        self.budgetName = budgetName
        self.notification = notification
        self.subscriber = subscriber
    }
}

struct CreateSubscriberInputBody: Swift.Equatable {
    let accountId: Swift.String?
    let budgetName: Swift.String?
    let notification: BudgetsClientTypes.Notification?
    let subscriber: BudgetsClientTypes.Subscriber?
}

extension CreateSubscriberInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case budgetName = "BudgetName"
        case notification = "Notification"
        case subscriber = "Subscriber"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let budgetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .budgetName)
        budgetName = budgetNameDecoded
        let notificationDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.Notification.self, forKey: .notification)
        notification = notificationDecoded
        let subscriberDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.Subscriber.self, forKey: .subscriber)
        subscriber = subscriberDecoded
    }
}

extension CreateSubscriberOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

/// Response of CreateSubscriber
public struct CreateSubscriberOutput: Swift.Equatable {

    public init() { }
}

enum CreateSubscriberOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "CreationLimitExceededException": return try await CreationLimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "DuplicateRecordException": return try await DuplicateRecordException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalErrorException": return try await InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreationLimitExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreationLimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// You've exceeded the notification or subscriber limit.
public struct CreationLimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The error message the exception carries.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "CreationLimitExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct CreationLimitExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension CreationLimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension BudgetsClientTypes.Definition: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case iamActionDefinition = "IamActionDefinition"
        case scpActionDefinition = "ScpActionDefinition"
        case ssmActionDefinition = "SsmActionDefinition"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let iamActionDefinition = self.iamActionDefinition {
            try encodeContainer.encode(iamActionDefinition, forKey: .iamActionDefinition)
        }
        if let scpActionDefinition = self.scpActionDefinition {
            try encodeContainer.encode(scpActionDefinition, forKey: .scpActionDefinition)
        }
        if let ssmActionDefinition = self.ssmActionDefinition {
            try encodeContainer.encode(ssmActionDefinition, forKey: .ssmActionDefinition)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let iamActionDefinitionDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.IamActionDefinition.self, forKey: .iamActionDefinition)
        iamActionDefinition = iamActionDefinitionDecoded
        let scpActionDefinitionDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.ScpActionDefinition.self, forKey: .scpActionDefinition)
        scpActionDefinition = scpActionDefinitionDecoded
        let ssmActionDefinitionDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.SsmActionDefinition.self, forKey: .ssmActionDefinition)
        ssmActionDefinition = ssmActionDefinitionDecoded
    }
}

extension BudgetsClientTypes {
    /// Specifies all of the type-specific parameters.
    public struct Definition: Swift.Equatable {
        /// The Identity and Access Management (IAM) action definition details.
        public var iamActionDefinition: BudgetsClientTypes.IamActionDefinition?
        /// The service control policies (SCPs) action definition details.
        public var scpActionDefinition: BudgetsClientTypes.ScpActionDefinition?
        /// The Amazon Web Services Systems Manager (SSM) action definition details.
        public var ssmActionDefinition: BudgetsClientTypes.SsmActionDefinition?

        public init(
            iamActionDefinition: BudgetsClientTypes.IamActionDefinition? = nil,
            scpActionDefinition: BudgetsClientTypes.ScpActionDefinition? = nil,
            ssmActionDefinition: BudgetsClientTypes.SsmActionDefinition? = nil
        )
        {
            self.iamActionDefinition = iamActionDefinition
            self.scpActionDefinition = scpActionDefinition
            self.ssmActionDefinition = ssmActionDefinition
        }
    }

}

extension DeleteBudgetActionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case actionId = "ActionId"
        case budgetName = "BudgetName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let actionId = self.actionId {
            try encodeContainer.encode(actionId, forKey: .actionId)
        }
        if let budgetName = self.budgetName {
            try encodeContainer.encode(budgetName, forKey: .budgetName)
        }
    }
}

extension DeleteBudgetActionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteBudgetActionInput: Swift.Equatable {
    /// The account ID of the user. It's a 12-digit number.
    /// This member is required.
    public var accountId: Swift.String?
    /// A system-generated universally unique identifier (UUID) for the action.
    /// This member is required.
    public var actionId: Swift.String?
    /// A string that represents the budget name. The ":" and "\" characters, and the "/action/" substring, aren't allowed.
    /// This member is required.
    public var budgetName: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        actionId: Swift.String? = nil,
        budgetName: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.actionId = actionId
        self.budgetName = budgetName
    }
}

struct DeleteBudgetActionInputBody: Swift.Equatable {
    let accountId: Swift.String?
    let budgetName: Swift.String?
    let actionId: Swift.String?
}

extension DeleteBudgetActionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case actionId = "ActionId"
        case budgetName = "BudgetName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let budgetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .budgetName)
        budgetName = budgetNameDecoded
        let actionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .actionId)
        actionId = actionIdDecoded
    }
}

extension DeleteBudgetActionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteBudgetActionOutputBody = try responseDecoder.decode(responseBody: data)
            self.accountId = output.accountId
            self.action = output.action
            self.budgetName = output.budgetName
        } else {
            self.accountId = nil
            self.action = nil
            self.budgetName = nil
        }
    }
}

public struct DeleteBudgetActionOutput: Swift.Equatable {
    /// The account ID of the user. It's a 12-digit number.
    /// This member is required.
    public var accountId: Swift.String?
    /// A budget action resource.
    /// This member is required.
    public var action: BudgetsClientTypes.Action?
    /// A string that represents the budget name. The ":" and "\" characters, and the "/action/" substring, aren't allowed.
    /// This member is required.
    public var budgetName: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        action: BudgetsClientTypes.Action? = nil,
        budgetName: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.action = action
        self.budgetName = budgetName
    }
}

struct DeleteBudgetActionOutputBody: Swift.Equatable {
    let accountId: Swift.String?
    let budgetName: Swift.String?
    let action: BudgetsClientTypes.Action?
}

extension DeleteBudgetActionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case action = "Action"
        case budgetName = "BudgetName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let budgetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .budgetName)
        budgetName = budgetNameDecoded
        let actionDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.Action.self, forKey: .action)
        action = actionDecoded
    }
}

enum DeleteBudgetActionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalErrorException": return try await InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceLockedException": return try await ResourceLockedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteBudgetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case budgetName = "BudgetName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let budgetName = self.budgetName {
            try encodeContainer.encode(budgetName, forKey: .budgetName)
        }
    }
}

extension DeleteBudgetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Request of DeleteBudget
public struct DeleteBudgetInput: Swift.Equatable {
    /// The accountId that is associated with the budget that you want to delete.
    /// This member is required.
    public var accountId: Swift.String?
    /// The name of the budget that you want to delete.
    /// This member is required.
    public var budgetName: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        budgetName: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.budgetName = budgetName
    }
}

struct DeleteBudgetInputBody: Swift.Equatable {
    let accountId: Swift.String?
    let budgetName: Swift.String?
}

extension DeleteBudgetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case budgetName = "BudgetName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let budgetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .budgetName)
        budgetName = budgetNameDecoded
    }
}

extension DeleteBudgetOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

/// Response of DeleteBudget
public struct DeleteBudgetOutput: Swift.Equatable {

    public init() { }
}

enum DeleteBudgetOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalErrorException": return try await InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteNotificationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case budgetName = "BudgetName"
        case notification = "Notification"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let budgetName = self.budgetName {
            try encodeContainer.encode(budgetName, forKey: .budgetName)
        }
        if let notification = self.notification {
            try encodeContainer.encode(notification, forKey: .notification)
        }
    }
}

extension DeleteNotificationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Request of DeleteNotification
public struct DeleteNotificationInput: Swift.Equatable {
    /// The accountId that is associated with the budget whose notification you want to delete.
    /// This member is required.
    public var accountId: Swift.String?
    /// The name of the budget whose notification you want to delete.
    /// This member is required.
    public var budgetName: Swift.String?
    /// The notification that you want to delete.
    /// This member is required.
    public var notification: BudgetsClientTypes.Notification?

    public init(
        accountId: Swift.String? = nil,
        budgetName: Swift.String? = nil,
        notification: BudgetsClientTypes.Notification? = nil
    )
    {
        self.accountId = accountId
        self.budgetName = budgetName
        self.notification = notification
    }
}

struct DeleteNotificationInputBody: Swift.Equatable {
    let accountId: Swift.String?
    let budgetName: Swift.String?
    let notification: BudgetsClientTypes.Notification?
}

extension DeleteNotificationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case budgetName = "BudgetName"
        case notification = "Notification"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let budgetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .budgetName)
        budgetName = budgetNameDecoded
        let notificationDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.Notification.self, forKey: .notification)
        notification = notificationDecoded
    }
}

extension DeleteNotificationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

/// Response of DeleteNotification
public struct DeleteNotificationOutput: Swift.Equatable {

    public init() { }
}

enum DeleteNotificationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalErrorException": return try await InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteSubscriberInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case budgetName = "BudgetName"
        case notification = "Notification"
        case subscriber = "Subscriber"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let budgetName = self.budgetName {
            try encodeContainer.encode(budgetName, forKey: .budgetName)
        }
        if let notification = self.notification {
            try encodeContainer.encode(notification, forKey: .notification)
        }
        if let subscriber = self.subscriber {
            try encodeContainer.encode(subscriber, forKey: .subscriber)
        }
    }
}

extension DeleteSubscriberInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Request of DeleteSubscriber
public struct DeleteSubscriberInput: Swift.Equatable {
    /// The accountId that is associated with the budget whose subscriber you want to delete.
    /// This member is required.
    public var accountId: Swift.String?
    /// The name of the budget whose subscriber you want to delete.
    /// This member is required.
    public var budgetName: Swift.String?
    /// The notification whose subscriber you want to delete.
    /// This member is required.
    public var notification: BudgetsClientTypes.Notification?
    /// The subscriber that you want to delete.
    /// This member is required.
    public var subscriber: BudgetsClientTypes.Subscriber?

    public init(
        accountId: Swift.String? = nil,
        budgetName: Swift.String? = nil,
        notification: BudgetsClientTypes.Notification? = nil,
        subscriber: BudgetsClientTypes.Subscriber? = nil
    )
    {
        self.accountId = accountId
        self.budgetName = budgetName
        self.notification = notification
        self.subscriber = subscriber
    }
}

struct DeleteSubscriberInputBody: Swift.Equatable {
    let accountId: Swift.String?
    let budgetName: Swift.String?
    let notification: BudgetsClientTypes.Notification?
    let subscriber: BudgetsClientTypes.Subscriber?
}

extension DeleteSubscriberInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case budgetName = "BudgetName"
        case notification = "Notification"
        case subscriber = "Subscriber"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let budgetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .budgetName)
        budgetName = budgetNameDecoded
        let notificationDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.Notification.self, forKey: .notification)
        notification = notificationDecoded
        let subscriberDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.Subscriber.self, forKey: .subscriber)
        subscriber = subscriberDecoded
    }
}

extension DeleteSubscriberOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

/// Response of DeleteSubscriber
public struct DeleteSubscriberOutput: Swift.Equatable {

    public init() { }
}

enum DeleteSubscriberOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalErrorException": return try await InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeBudgetActionHistoriesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case actionId = "ActionId"
        case budgetName = "BudgetName"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case timePeriod = "TimePeriod"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let actionId = self.actionId {
            try encodeContainer.encode(actionId, forKey: .actionId)
        }
        if let budgetName = self.budgetName {
            try encodeContainer.encode(budgetName, forKey: .budgetName)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let timePeriod = self.timePeriod {
            try encodeContainer.encode(timePeriod, forKey: .timePeriod)
        }
    }
}

extension DescribeBudgetActionHistoriesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeBudgetActionHistoriesInput: Swift.Equatable {
    /// The account ID of the user. It's a 12-digit number.
    /// This member is required.
    public var accountId: Swift.String?
    /// A system-generated universally unique identifier (UUID) for the action.
    /// This member is required.
    public var actionId: Swift.String?
    /// A string that represents the budget name. The ":" and "\" characters, and the "/action/" substring, aren't allowed.
    /// This member is required.
    public var budgetName: Swift.String?
    /// An integer that represents how many entries a paginated response contains. The maximum is 100.
    public var maxResults: Swift.Int?
    /// A generic string.
    public var nextToken: Swift.String?
    /// The period of time that's covered by a budget. The period has a start date and an end date. The start date must come before the end date. There are no restrictions on the end date.
    public var timePeriod: BudgetsClientTypes.TimePeriod?

    public init(
        accountId: Swift.String? = nil,
        actionId: Swift.String? = nil,
        budgetName: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        timePeriod: BudgetsClientTypes.TimePeriod? = nil
    )
    {
        self.accountId = accountId
        self.actionId = actionId
        self.budgetName = budgetName
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.timePeriod = timePeriod
    }
}

struct DescribeBudgetActionHistoriesInputBody: Swift.Equatable {
    let accountId: Swift.String?
    let budgetName: Swift.String?
    let actionId: Swift.String?
    let timePeriod: BudgetsClientTypes.TimePeriod?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension DescribeBudgetActionHistoriesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case actionId = "ActionId"
        case budgetName = "BudgetName"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case timePeriod = "TimePeriod"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let budgetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .budgetName)
        budgetName = budgetNameDecoded
        let actionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .actionId)
        actionId = actionIdDecoded
        let timePeriodDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.TimePeriod.self, forKey: .timePeriod)
        timePeriod = timePeriodDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeBudgetActionHistoriesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeBudgetActionHistoriesOutputBody = try responseDecoder.decode(responseBody: data)
            self.actionHistories = output.actionHistories
            self.nextToken = output.nextToken
        } else {
            self.actionHistories = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeBudgetActionHistoriesOutput: Swift.Equatable {
    /// The historical record of the budget action resource.
    /// This member is required.
    public var actionHistories: [BudgetsClientTypes.ActionHistory]?
    /// A generic string.
    public var nextToken: Swift.String?

    public init(
        actionHistories: [BudgetsClientTypes.ActionHistory]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.actionHistories = actionHistories
        self.nextToken = nextToken
    }
}

struct DescribeBudgetActionHistoriesOutputBody: Swift.Equatable {
    let actionHistories: [BudgetsClientTypes.ActionHistory]?
    let nextToken: Swift.String?
}

extension DescribeBudgetActionHistoriesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actionHistories = "ActionHistories"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionHistoriesContainer = try containerValues.decodeIfPresent([BudgetsClientTypes.ActionHistory?].self, forKey: .actionHistories)
        var actionHistoriesDecoded0:[BudgetsClientTypes.ActionHistory]? = nil
        if let actionHistoriesContainer = actionHistoriesContainer {
            actionHistoriesDecoded0 = [BudgetsClientTypes.ActionHistory]()
            for structure0 in actionHistoriesContainer {
                if let structure0 = structure0 {
                    actionHistoriesDecoded0?.append(structure0)
                }
            }
        }
        actionHistories = actionHistoriesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum DescribeBudgetActionHistoriesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalErrorException": return try await InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidNextTokenException": return try await InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeBudgetActionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case actionId = "ActionId"
        case budgetName = "BudgetName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let actionId = self.actionId {
            try encodeContainer.encode(actionId, forKey: .actionId)
        }
        if let budgetName = self.budgetName {
            try encodeContainer.encode(budgetName, forKey: .budgetName)
        }
    }
}

extension DescribeBudgetActionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeBudgetActionInput: Swift.Equatable {
    /// The account ID of the user. It's a 12-digit number.
    /// This member is required.
    public var accountId: Swift.String?
    /// A system-generated universally unique identifier (UUID) for the action.
    /// This member is required.
    public var actionId: Swift.String?
    /// A string that represents the budget name. The ":" and "\" characters, and the "/action/" substring, aren't allowed.
    /// This member is required.
    public var budgetName: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        actionId: Swift.String? = nil,
        budgetName: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.actionId = actionId
        self.budgetName = budgetName
    }
}

struct DescribeBudgetActionInputBody: Swift.Equatable {
    let accountId: Swift.String?
    let budgetName: Swift.String?
    let actionId: Swift.String?
}

extension DescribeBudgetActionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case actionId = "ActionId"
        case budgetName = "BudgetName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let budgetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .budgetName)
        budgetName = budgetNameDecoded
        let actionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .actionId)
        actionId = actionIdDecoded
    }
}

extension DescribeBudgetActionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeBudgetActionOutputBody = try responseDecoder.decode(responseBody: data)
            self.accountId = output.accountId
            self.action = output.action
            self.budgetName = output.budgetName
        } else {
            self.accountId = nil
            self.action = nil
            self.budgetName = nil
        }
    }
}

public struct DescribeBudgetActionOutput: Swift.Equatable {
    /// The account ID of the user. It's a 12-digit number.
    /// This member is required.
    public var accountId: Swift.String?
    /// A budget action resource.
    /// This member is required.
    public var action: BudgetsClientTypes.Action?
    /// A string that represents the budget name. The ":" and "\" characters, and the "/action/" substring, aren't allowed.
    /// This member is required.
    public var budgetName: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        action: BudgetsClientTypes.Action? = nil,
        budgetName: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.action = action
        self.budgetName = budgetName
    }
}

struct DescribeBudgetActionOutputBody: Swift.Equatable {
    let accountId: Swift.String?
    let budgetName: Swift.String?
    let action: BudgetsClientTypes.Action?
}

extension DescribeBudgetActionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case action = "Action"
        case budgetName = "BudgetName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let budgetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .budgetName)
        budgetName = budgetNameDecoded
        let actionDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.Action.self, forKey: .action)
        action = actionDecoded
    }
}

enum DescribeBudgetActionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalErrorException": return try await InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeBudgetActionsForAccountInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension DescribeBudgetActionsForAccountInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeBudgetActionsForAccountInput: Swift.Equatable {
    /// The account ID of the user. It's a 12-digit number.
    /// This member is required.
    public var accountId: Swift.String?
    /// An integer that represents how many entries a paginated response contains. The maximum is 100.
    public var maxResults: Swift.Int?
    /// A generic string.
    public var nextToken: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeBudgetActionsForAccountInputBody: Swift.Equatable {
    let accountId: Swift.String?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension DescribeBudgetActionsForAccountInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeBudgetActionsForAccountOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeBudgetActionsForAccountOutputBody = try responseDecoder.decode(responseBody: data)
            self.actions = output.actions
            self.nextToken = output.nextToken
        } else {
            self.actions = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeBudgetActionsForAccountOutput: Swift.Equatable {
    /// A list of the budget action resources information.
    /// This member is required.
    public var actions: [BudgetsClientTypes.Action]?
    /// A generic string.
    public var nextToken: Swift.String?

    public init(
        actions: [BudgetsClientTypes.Action]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.actions = actions
        self.nextToken = nextToken
    }
}

struct DescribeBudgetActionsForAccountOutputBody: Swift.Equatable {
    let actions: [BudgetsClientTypes.Action]?
    let nextToken: Swift.String?
}

extension DescribeBudgetActionsForAccountOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actions = "Actions"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionsContainer = try containerValues.decodeIfPresent([BudgetsClientTypes.Action?].self, forKey: .actions)
        var actionsDecoded0:[BudgetsClientTypes.Action]? = nil
        if let actionsContainer = actionsContainer {
            actionsDecoded0 = [BudgetsClientTypes.Action]()
            for structure0 in actionsContainer {
                if let structure0 = structure0 {
                    actionsDecoded0?.append(structure0)
                }
            }
        }
        actions = actionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum DescribeBudgetActionsForAccountOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalErrorException": return try await InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidNextTokenException": return try await InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeBudgetActionsForBudgetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case budgetName = "BudgetName"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let budgetName = self.budgetName {
            try encodeContainer.encode(budgetName, forKey: .budgetName)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension DescribeBudgetActionsForBudgetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeBudgetActionsForBudgetInput: Swift.Equatable {
    /// The account ID of the user. It's a 12-digit number.
    /// This member is required.
    public var accountId: Swift.String?
    /// A string that represents the budget name. The ":" and "\" characters, and the "/action/" substring, aren't allowed.
    /// This member is required.
    public var budgetName: Swift.String?
    /// An integer that represents how many entries a paginated response contains. The maximum is 100.
    public var maxResults: Swift.Int?
    /// A generic string.
    public var nextToken: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        budgetName: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.budgetName = budgetName
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeBudgetActionsForBudgetInputBody: Swift.Equatable {
    let accountId: Swift.String?
    let budgetName: Swift.String?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension DescribeBudgetActionsForBudgetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case budgetName = "BudgetName"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let budgetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .budgetName)
        budgetName = budgetNameDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeBudgetActionsForBudgetOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeBudgetActionsForBudgetOutputBody = try responseDecoder.decode(responseBody: data)
            self.actions = output.actions
            self.nextToken = output.nextToken
        } else {
            self.actions = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeBudgetActionsForBudgetOutput: Swift.Equatable {
    /// A list of the budget action resources information.
    /// This member is required.
    public var actions: [BudgetsClientTypes.Action]?
    /// A generic string.
    public var nextToken: Swift.String?

    public init(
        actions: [BudgetsClientTypes.Action]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.actions = actions
        self.nextToken = nextToken
    }
}

struct DescribeBudgetActionsForBudgetOutputBody: Swift.Equatable {
    let actions: [BudgetsClientTypes.Action]?
    let nextToken: Swift.String?
}

extension DescribeBudgetActionsForBudgetOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actions = "Actions"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionsContainer = try containerValues.decodeIfPresent([BudgetsClientTypes.Action?].self, forKey: .actions)
        var actionsDecoded0:[BudgetsClientTypes.Action]? = nil
        if let actionsContainer = actionsContainer {
            actionsDecoded0 = [BudgetsClientTypes.Action]()
            for structure0 in actionsContainer {
                if let structure0 = structure0 {
                    actionsDecoded0?.append(structure0)
                }
            }
        }
        actions = actionsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum DescribeBudgetActionsForBudgetOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalErrorException": return try await InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidNextTokenException": return try await InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeBudgetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case budgetName = "BudgetName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let budgetName = self.budgetName {
            try encodeContainer.encode(budgetName, forKey: .budgetName)
        }
    }
}

extension DescribeBudgetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Request of DescribeBudget
public struct DescribeBudgetInput: Swift.Equatable {
    /// The accountId that is associated with the budget that you want a description of.
    /// This member is required.
    public var accountId: Swift.String?
    /// The name of the budget that you want a description of.
    /// This member is required.
    public var budgetName: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        budgetName: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.budgetName = budgetName
    }
}

struct DescribeBudgetInputBody: Swift.Equatable {
    let accountId: Swift.String?
    let budgetName: Swift.String?
}

extension DescribeBudgetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case budgetName = "BudgetName"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let budgetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .budgetName)
        budgetName = budgetNameDecoded
    }
}

extension DescribeBudgetNotificationsForAccountInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension DescribeBudgetNotificationsForAccountInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeBudgetNotificationsForAccountInput: Swift.Equatable {
    /// The account ID of the user. It's a 12-digit number.
    /// This member is required.
    public var accountId: Swift.String?
    /// An integer that represents how many budgets a paginated response contains. The default is 50.
    public var maxResults: Swift.Int?
    /// A generic string.
    public var nextToken: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeBudgetNotificationsForAccountInputBody: Swift.Equatable {
    let accountId: Swift.String?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension DescribeBudgetNotificationsForAccountInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeBudgetNotificationsForAccountOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeBudgetNotificationsForAccountOutputBody = try responseDecoder.decode(responseBody: data)
            self.budgetNotificationsForAccount = output.budgetNotificationsForAccount
            self.nextToken = output.nextToken
        } else {
            self.budgetNotificationsForAccount = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeBudgetNotificationsForAccountOutput: Swift.Equatable {
    /// A list of budget names and associated notifications for an account.
    public var budgetNotificationsForAccount: [BudgetsClientTypes.BudgetNotificationsForAccount]?
    /// A generic string.
    public var nextToken: Swift.String?

    public init(
        budgetNotificationsForAccount: [BudgetsClientTypes.BudgetNotificationsForAccount]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.budgetNotificationsForAccount = budgetNotificationsForAccount
        self.nextToken = nextToken
    }
}

struct DescribeBudgetNotificationsForAccountOutputBody: Swift.Equatable {
    let budgetNotificationsForAccount: [BudgetsClientTypes.BudgetNotificationsForAccount]?
    let nextToken: Swift.String?
}

extension DescribeBudgetNotificationsForAccountOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case budgetNotificationsForAccount = "BudgetNotificationsForAccount"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let budgetNotificationsForAccountContainer = try containerValues.decodeIfPresent([BudgetsClientTypes.BudgetNotificationsForAccount?].self, forKey: .budgetNotificationsForAccount)
        var budgetNotificationsForAccountDecoded0:[BudgetsClientTypes.BudgetNotificationsForAccount]? = nil
        if let budgetNotificationsForAccountContainer = budgetNotificationsForAccountContainer {
            budgetNotificationsForAccountDecoded0 = [BudgetsClientTypes.BudgetNotificationsForAccount]()
            for structure0 in budgetNotificationsForAccountContainer {
                if let structure0 = structure0 {
                    budgetNotificationsForAccountDecoded0?.append(structure0)
                }
            }
        }
        budgetNotificationsForAccount = budgetNotificationsForAccountDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum DescribeBudgetNotificationsForAccountOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ExpiredNextTokenException": return try await ExpiredNextTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalErrorException": return try await InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidNextTokenException": return try await InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeBudgetOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeBudgetOutputBody = try responseDecoder.decode(responseBody: data)
            self.budget = output.budget
        } else {
            self.budget = nil
        }
    }
}

/// Response of DescribeBudget
public struct DescribeBudgetOutput: Swift.Equatable {
    /// The description of the budget.
    public var budget: BudgetsClientTypes.Budget?

    public init(
        budget: BudgetsClientTypes.Budget? = nil
    )
    {
        self.budget = budget
    }
}

struct DescribeBudgetOutputBody: Swift.Equatable {
    let budget: BudgetsClientTypes.Budget?
}

extension DescribeBudgetOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case budget = "Budget"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let budgetDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.Budget.self, forKey: .budget)
        budget = budgetDecoded
    }
}

enum DescribeBudgetOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalErrorException": return try await InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeBudgetPerformanceHistoryInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case budgetName = "BudgetName"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case timePeriod = "TimePeriod"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let budgetName = self.budgetName {
            try encodeContainer.encode(budgetName, forKey: .budgetName)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let timePeriod = self.timePeriod {
            try encodeContainer.encode(timePeriod, forKey: .timePeriod)
        }
    }
}

extension DescribeBudgetPerformanceHistoryInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeBudgetPerformanceHistoryInput: Swift.Equatable {
    /// The account ID of the user. It's a 12-digit number.
    /// This member is required.
    public var accountId: Swift.String?
    /// A string that represents the budget name. The ":" and "\" characters, and the "/action/" substring, aren't allowed.
    /// This member is required.
    public var budgetName: Swift.String?
    /// An integer that represents how many entries a paginated response contains. The maximum is 100.
    public var maxResults: Swift.Int?
    /// A generic string.
    public var nextToken: Swift.String?
    /// Retrieves how often the budget went into an ALARM state for the specified time period.
    public var timePeriod: BudgetsClientTypes.TimePeriod?

    public init(
        accountId: Swift.String? = nil,
        budgetName: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        timePeriod: BudgetsClientTypes.TimePeriod? = nil
    )
    {
        self.accountId = accountId
        self.budgetName = budgetName
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.timePeriod = timePeriod
    }
}

struct DescribeBudgetPerformanceHistoryInputBody: Swift.Equatable {
    let accountId: Swift.String?
    let budgetName: Swift.String?
    let timePeriod: BudgetsClientTypes.TimePeriod?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension DescribeBudgetPerformanceHistoryInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case budgetName = "BudgetName"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case timePeriod = "TimePeriod"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let budgetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .budgetName)
        budgetName = budgetNameDecoded
        let timePeriodDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.TimePeriod.self, forKey: .timePeriod)
        timePeriod = timePeriodDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeBudgetPerformanceHistoryOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeBudgetPerformanceHistoryOutputBody = try responseDecoder.decode(responseBody: data)
            self.budgetPerformanceHistory = output.budgetPerformanceHistory
            self.nextToken = output.nextToken
        } else {
            self.budgetPerformanceHistory = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeBudgetPerformanceHistoryOutput: Swift.Equatable {
    /// The history of how often the budget has gone into an ALARM state. For DAILY budgets, the history saves the state of the budget for the last 60 days. For MONTHLY budgets, the history saves the state of the budget for the current month plus the last 12 months. For QUARTERLY budgets, the history saves the state of the budget for the last four quarters.
    public var budgetPerformanceHistory: BudgetsClientTypes.BudgetPerformanceHistory?
    /// A generic string.
    public var nextToken: Swift.String?

    public init(
        budgetPerformanceHistory: BudgetsClientTypes.BudgetPerformanceHistory? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.budgetPerformanceHistory = budgetPerformanceHistory
        self.nextToken = nextToken
    }
}

struct DescribeBudgetPerformanceHistoryOutputBody: Swift.Equatable {
    let budgetPerformanceHistory: BudgetsClientTypes.BudgetPerformanceHistory?
    let nextToken: Swift.String?
}

extension DescribeBudgetPerformanceHistoryOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case budgetPerformanceHistory = "BudgetPerformanceHistory"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let budgetPerformanceHistoryDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.BudgetPerformanceHistory.self, forKey: .budgetPerformanceHistory)
        budgetPerformanceHistory = budgetPerformanceHistoryDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum DescribeBudgetPerformanceHistoryOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ExpiredNextTokenException": return try await ExpiredNextTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalErrorException": return try await InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidNextTokenException": return try await InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeBudgetsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension DescribeBudgetsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Request of DescribeBudgets
public struct DescribeBudgetsInput: Swift.Equatable {
    /// The accountId that is associated with the budgets that you want to describe.
    /// This member is required.
    public var accountId: Swift.String?
    /// An integer that represents how many budgets a paginated response contains. The default is 100.
    public var maxResults: Swift.Int?
    /// The pagination token that you include in your request to indicate the next set of results that you want to retrieve.
    public var nextToken: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeBudgetsInputBody: Swift.Equatable {
    let accountId: Swift.String?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension DescribeBudgetsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeBudgetsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeBudgetsOutputBody = try responseDecoder.decode(responseBody: data)
            self.budgets = output.budgets
            self.nextToken = output.nextToken
        } else {
            self.budgets = nil
            self.nextToken = nil
        }
    }
}

/// Response of DescribeBudgets
public struct DescribeBudgetsOutput: Swift.Equatable {
    /// A list of budgets.
    public var budgets: [BudgetsClientTypes.Budget]?
    /// The pagination token in the service response that indicates the next set of results that you can retrieve.
    public var nextToken: Swift.String?

    public init(
        budgets: [BudgetsClientTypes.Budget]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.budgets = budgets
        self.nextToken = nextToken
    }
}

struct DescribeBudgetsOutputBody: Swift.Equatable {
    let budgets: [BudgetsClientTypes.Budget]?
    let nextToken: Swift.String?
}

extension DescribeBudgetsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case budgets = "Budgets"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let budgetsContainer = try containerValues.decodeIfPresent([BudgetsClientTypes.Budget?].self, forKey: .budgets)
        var budgetsDecoded0:[BudgetsClientTypes.Budget]? = nil
        if let budgetsContainer = budgetsContainer {
            budgetsDecoded0 = [BudgetsClientTypes.Budget]()
            for structure0 in budgetsContainer {
                if let structure0 = structure0 {
                    budgetsDecoded0?.append(structure0)
                }
            }
        }
        budgets = budgetsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum DescribeBudgetsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ExpiredNextTokenException": return try await ExpiredNextTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalErrorException": return try await InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidNextTokenException": return try await InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeNotificationsForBudgetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case budgetName = "BudgetName"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let budgetName = self.budgetName {
            try encodeContainer.encode(budgetName, forKey: .budgetName)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension DescribeNotificationsForBudgetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Request of DescribeNotificationsForBudget
public struct DescribeNotificationsForBudgetInput: Swift.Equatable {
    /// The accountId that is associated with the budget whose notifications you want descriptions of.
    /// This member is required.
    public var accountId: Swift.String?
    /// The name of the budget whose notifications you want descriptions of.
    /// This member is required.
    public var budgetName: Swift.String?
    /// An optional integer that represents how many entries a paginated response contains.
    public var maxResults: Swift.Int?
    /// The pagination token that you include in your request to indicate the next set of results that you want to retrieve.
    public var nextToken: Swift.String?

    public init(
        accountId: Swift.String? = nil,
        budgetName: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.accountId = accountId
        self.budgetName = budgetName
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeNotificationsForBudgetInputBody: Swift.Equatable {
    let accountId: Swift.String?
    let budgetName: Swift.String?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension DescribeNotificationsForBudgetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case budgetName = "BudgetName"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let budgetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .budgetName)
        budgetName = budgetNameDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeNotificationsForBudgetOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeNotificationsForBudgetOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.notifications = output.notifications
        } else {
            self.nextToken = nil
            self.notifications = nil
        }
    }
}

/// Response of GetNotificationsForBudget
public struct DescribeNotificationsForBudgetOutput: Swift.Equatable {
    /// The pagination token in the service response that indicates the next set of results that you can retrieve.
    public var nextToken: Swift.String?
    /// A list of notifications that are associated with a budget.
    public var notifications: [BudgetsClientTypes.Notification]?

    public init(
        nextToken: Swift.String? = nil,
        notifications: [BudgetsClientTypes.Notification]? = nil
    )
    {
        self.nextToken = nextToken
        self.notifications = notifications
    }
}

struct DescribeNotificationsForBudgetOutputBody: Swift.Equatable {
    let notifications: [BudgetsClientTypes.Notification]?
    let nextToken: Swift.String?
}

extension DescribeNotificationsForBudgetOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case notifications = "Notifications"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let notificationsContainer = try containerValues.decodeIfPresent([BudgetsClientTypes.Notification?].self, forKey: .notifications)
        var notificationsDecoded0:[BudgetsClientTypes.Notification]? = nil
        if let notificationsContainer = notificationsContainer {
            notificationsDecoded0 = [BudgetsClientTypes.Notification]()
            for structure0 in notificationsContainer {
                if let structure0 = structure0 {
                    notificationsDecoded0?.append(structure0)
                }
            }
        }
        notifications = notificationsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum DescribeNotificationsForBudgetOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ExpiredNextTokenException": return try await ExpiredNextTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalErrorException": return try await InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidNextTokenException": return try await InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeSubscribersForNotificationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case budgetName = "BudgetName"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case notification = "Notification"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let budgetName = self.budgetName {
            try encodeContainer.encode(budgetName, forKey: .budgetName)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let notification = self.notification {
            try encodeContainer.encode(notification, forKey: .notification)
        }
    }
}

extension DescribeSubscribersForNotificationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Request of DescribeSubscribersForNotification
public struct DescribeSubscribersForNotificationInput: Swift.Equatable {
    /// The accountId that is associated with the budget whose subscribers you want descriptions of.
    /// This member is required.
    public var accountId: Swift.String?
    /// The name of the budget whose subscribers you want descriptions of.
    /// This member is required.
    public var budgetName: Swift.String?
    /// An optional integer that represents how many entries a paginated response contains.
    public var maxResults: Swift.Int?
    /// The pagination token that you include in your request to indicate the next set of results that you want to retrieve.
    public var nextToken: Swift.String?
    /// The notification whose subscribers you want to list.
    /// This member is required.
    public var notification: BudgetsClientTypes.Notification?

    public init(
        accountId: Swift.String? = nil,
        budgetName: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        notification: BudgetsClientTypes.Notification? = nil
    )
    {
        self.accountId = accountId
        self.budgetName = budgetName
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.notification = notification
    }
}

struct DescribeSubscribersForNotificationInputBody: Swift.Equatable {
    let accountId: Swift.String?
    let budgetName: Swift.String?
    let notification: BudgetsClientTypes.Notification?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension DescribeSubscribersForNotificationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case budgetName = "BudgetName"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case notification = "Notification"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let budgetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .budgetName)
        budgetName = budgetNameDecoded
        let notificationDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.Notification.self, forKey: .notification)
        notification = notificationDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeSubscribersForNotificationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeSubscribersForNotificationOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.subscribers = output.subscribers
        } else {
            self.nextToken = nil
            self.subscribers = nil
        }
    }
}

/// Response of DescribeSubscribersForNotification
public struct DescribeSubscribersForNotificationOutput: Swift.Equatable {
    /// The pagination token in the service response that indicates the next set of results that you can retrieve.
    public var nextToken: Swift.String?
    /// A list of subscribers that are associated with a notification.
    public var subscribers: [BudgetsClientTypes.Subscriber]?

    public init(
        nextToken: Swift.String? = nil,
        subscribers: [BudgetsClientTypes.Subscriber]? = nil
    )
    {
        self.nextToken = nextToken
        self.subscribers = subscribers
    }
}

struct DescribeSubscribersForNotificationOutputBody: Swift.Equatable {
    let subscribers: [BudgetsClientTypes.Subscriber]?
    let nextToken: Swift.String?
}

extension DescribeSubscribersForNotificationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "NextToken"
        case subscribers = "Subscribers"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subscribersContainer = try containerValues.decodeIfPresent([BudgetsClientTypes.Subscriber?].self, forKey: .subscribers)
        var subscribersDecoded0:[BudgetsClientTypes.Subscriber]? = nil
        if let subscribersContainer = subscribersContainer {
            subscribersDecoded0 = [BudgetsClientTypes.Subscriber]()
            for structure0 in subscribersContainer {
                if let structure0 = structure0 {
                    subscribersDecoded0?.append(structure0)
                }
            }
        }
        subscribers = subscribersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum DescribeSubscribersForNotificationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ExpiredNextTokenException": return try await ExpiredNextTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalErrorException": return try await InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidNextTokenException": return try await InvalidNextTokenException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DuplicateRecordException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DuplicateRecordExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The budget name already exists. Budget names must be unique within an account.
public struct DuplicateRecordException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The error message the exception carries.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "DuplicateRecordException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct DuplicateRecordExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension DuplicateRecordExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension BudgetsClientTypes {
    public enum EventType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case createaction
        case deleteaction
        case executeaction
        case system
        case updateaction
        case sdkUnknown(Swift.String)

        public static var allCases: [EventType] {
            return [
                .createaction,
                .deleteaction,
                .executeaction,
                .system,
                .updateaction,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .createaction: return "CREATE_ACTION"
            case .deleteaction: return "DELETE_ACTION"
            case .executeaction: return "EXECUTE_ACTION"
            case .system: return "SYSTEM"
            case .updateaction: return "UPDATE_ACTION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EventType(rawValue: rawValue) ?? EventType.sdkUnknown(rawValue)
        }
    }
}

extension ExecuteBudgetActionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case actionId = "ActionId"
        case budgetName = "BudgetName"
        case executionType = "ExecutionType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let actionId = self.actionId {
            try encodeContainer.encode(actionId, forKey: .actionId)
        }
        if let budgetName = self.budgetName {
            try encodeContainer.encode(budgetName, forKey: .budgetName)
        }
        if let executionType = self.executionType {
            try encodeContainer.encode(executionType.rawValue, forKey: .executionType)
        }
    }
}

extension ExecuteBudgetActionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ExecuteBudgetActionInput: Swift.Equatable {
    /// The account ID of the user. It's a 12-digit number.
    /// This member is required.
    public var accountId: Swift.String?
    /// A system-generated universally unique identifier (UUID) for the action.
    /// This member is required.
    public var actionId: Swift.String?
    /// A string that represents the budget name. The ":" and "\" characters, and the "/action/" substring, aren't allowed.
    /// This member is required.
    public var budgetName: Swift.String?
    /// The type of execution.
    /// This member is required.
    public var executionType: BudgetsClientTypes.ExecutionType?

    public init(
        accountId: Swift.String? = nil,
        actionId: Swift.String? = nil,
        budgetName: Swift.String? = nil,
        executionType: BudgetsClientTypes.ExecutionType? = nil
    )
    {
        self.accountId = accountId
        self.actionId = actionId
        self.budgetName = budgetName
        self.executionType = executionType
    }
}

struct ExecuteBudgetActionInputBody: Swift.Equatable {
    let accountId: Swift.String?
    let budgetName: Swift.String?
    let actionId: Swift.String?
    let executionType: BudgetsClientTypes.ExecutionType?
}

extension ExecuteBudgetActionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case actionId = "ActionId"
        case budgetName = "BudgetName"
        case executionType = "ExecutionType"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let budgetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .budgetName)
        budgetName = budgetNameDecoded
        let actionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .actionId)
        actionId = actionIdDecoded
        let executionTypeDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.ExecutionType.self, forKey: .executionType)
        executionType = executionTypeDecoded
    }
}

extension ExecuteBudgetActionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ExecuteBudgetActionOutputBody = try responseDecoder.decode(responseBody: data)
            self.accountId = output.accountId
            self.actionId = output.actionId
            self.budgetName = output.budgetName
            self.executionType = output.executionType
        } else {
            self.accountId = nil
            self.actionId = nil
            self.budgetName = nil
            self.executionType = nil
        }
    }
}

public struct ExecuteBudgetActionOutput: Swift.Equatable {
    /// The account ID of the user. It's a 12-digit number.
    /// This member is required.
    public var accountId: Swift.String?
    /// A system-generated universally unique identifier (UUID) for the action.
    /// This member is required.
    public var actionId: Swift.String?
    /// A string that represents the budget name. The ":" and "\" characters, and the "/action/" substring, aren't allowed.
    /// This member is required.
    public var budgetName: Swift.String?
    /// The type of execution.
    /// This member is required.
    public var executionType: BudgetsClientTypes.ExecutionType?

    public init(
        accountId: Swift.String? = nil,
        actionId: Swift.String? = nil,
        budgetName: Swift.String? = nil,
        executionType: BudgetsClientTypes.ExecutionType? = nil
    )
    {
        self.accountId = accountId
        self.actionId = actionId
        self.budgetName = budgetName
        self.executionType = executionType
    }
}

struct ExecuteBudgetActionOutputBody: Swift.Equatable {
    let accountId: Swift.String?
    let budgetName: Swift.String?
    let actionId: Swift.String?
    let executionType: BudgetsClientTypes.ExecutionType?
}

extension ExecuteBudgetActionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case actionId = "ActionId"
        case budgetName = "BudgetName"
        case executionType = "ExecutionType"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let budgetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .budgetName)
        budgetName = budgetNameDecoded
        let actionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .actionId)
        actionId = actionIdDecoded
        let executionTypeDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.ExecutionType.self, forKey: .executionType)
        executionType = executionTypeDecoded
    }
}

enum ExecuteBudgetActionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalErrorException": return try await InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceLockedException": return try await ResourceLockedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension BudgetsClientTypes {
    public enum ExecutionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case approvebudgetaction
        case resetbudgetaction
        case retrybudgetaction
        case reversebudgetaction
        case sdkUnknown(Swift.String)

        public static var allCases: [ExecutionType] {
            return [
                .approvebudgetaction,
                .resetbudgetaction,
                .retrybudgetaction,
                .reversebudgetaction,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .approvebudgetaction: return "APPROVE_BUDGET_ACTION"
            case .resetbudgetaction: return "RESET_BUDGET_ACTION"
            case .retrybudgetaction: return "RETRY_BUDGET_ACTION"
            case .reversebudgetaction: return "REVERSE_BUDGET_ACTION"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ExecutionType(rawValue: rawValue) ?? ExecutionType.sdkUnknown(rawValue)
        }
    }
}

extension ExpiredNextTokenException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ExpiredNextTokenExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The pagination token expired.
public struct ExpiredNextTokenException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The error message the exception carries.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ExpiredNextTokenException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ExpiredNextTokenExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ExpiredNextTokenExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension BudgetsClientTypes.HistoricalOptions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case budgetAdjustmentPeriod = "BudgetAdjustmentPeriod"
        case lookBackAvailablePeriods = "LookBackAvailablePeriods"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let budgetAdjustmentPeriod = self.budgetAdjustmentPeriod {
            try encodeContainer.encode(budgetAdjustmentPeriod, forKey: .budgetAdjustmentPeriod)
        }
        if let lookBackAvailablePeriods = self.lookBackAvailablePeriods {
            try encodeContainer.encode(lookBackAvailablePeriods, forKey: .lookBackAvailablePeriods)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let budgetAdjustmentPeriodDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .budgetAdjustmentPeriod)
        budgetAdjustmentPeriod = budgetAdjustmentPeriodDecoded
        let lookBackAvailablePeriodsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .lookBackAvailablePeriods)
        lookBackAvailablePeriods = lookBackAvailablePeriodsDecoded
    }
}

extension BudgetsClientTypes {
    /// The parameters that define or describe the historical data that your auto-adjusting budget is based on.
    public struct HistoricalOptions: Swift.Equatable {
        /// The number of budget periods included in the moving-average calculation that determines your auto-adjusted budget amount. The maximum value depends on the TimeUnit granularity of the budget:
        ///
        /// * For the DAILY granularity, the maximum value is 60.
        ///
        /// * For the MONTHLY granularity, the maximum value is 12.
        ///
        /// * For the QUARTERLY granularity, the maximum value is 4.
        ///
        /// * For the ANNUALLY granularity, the maximum value is 1.
        /// This member is required.
        public var budgetAdjustmentPeriod: Swift.Int?
        /// The integer that describes how many budget periods in your BudgetAdjustmentPeriod are included in the calculation of your current BudgetLimit. If the first budget period in your BudgetAdjustmentPeriod has no cost data, then that budget period isnt included in the average that determines your budget limit. For example, if you set BudgetAdjustmentPeriod as 4 quarters, but your account had no cost data in the first quarter, then only the last three quarters are included in the calculation. In this scenario, LookBackAvailablePeriods returns 3. You cant set your own LookBackAvailablePeriods. The value is automatically calculated from the BudgetAdjustmentPeriod and your historical cost data.
        public var lookBackAvailablePeriods: Swift.Int?

        public init(
            budgetAdjustmentPeriod: Swift.Int? = nil,
            lookBackAvailablePeriods: Swift.Int? = nil
        )
        {
            self.budgetAdjustmentPeriod = budgetAdjustmentPeriod
            self.lookBackAvailablePeriods = lookBackAvailablePeriods
        }
    }

}

extension BudgetsClientTypes.IamActionDefinition: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groups = "Groups"
        case policyArn = "PolicyArn"
        case roles = "Roles"
        case users = "Users"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let groups = groups {
            var groupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .groups)
            for group0 in groups {
                try groupsContainer.encode(group0)
            }
        }
        if let policyArn = self.policyArn {
            try encodeContainer.encode(policyArn, forKey: .policyArn)
        }
        if let roles = roles {
            var rolesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .roles)
            for role0 in roles {
                try rolesContainer.encode(role0)
            }
        }
        if let users = users {
            var usersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .users)
            for user0 in users {
                try usersContainer.encode(user0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyArn)
        policyArn = policyArnDecoded
        let rolesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .roles)
        var rolesDecoded0:[Swift.String]? = nil
        if let rolesContainer = rolesContainer {
            rolesDecoded0 = [Swift.String]()
            for string0 in rolesContainer {
                if let string0 = string0 {
                    rolesDecoded0?.append(string0)
                }
            }
        }
        roles = rolesDecoded0
        let groupsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .groups)
        var groupsDecoded0:[Swift.String]? = nil
        if let groupsContainer = groupsContainer {
            groupsDecoded0 = [Swift.String]()
            for string0 in groupsContainer {
                if let string0 = string0 {
                    groupsDecoded0?.append(string0)
                }
            }
        }
        groups = groupsDecoded0
        let usersContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .users)
        var usersDecoded0:[Swift.String]? = nil
        if let usersContainer = usersContainer {
            usersDecoded0 = [Swift.String]()
            for string0 in usersContainer {
                if let string0 = string0 {
                    usersDecoded0?.append(string0)
                }
            }
        }
        users = usersDecoded0
    }
}

extension BudgetsClientTypes {
    /// The Identity and Access Management (IAM) action definition details.
    public struct IamActionDefinition: Swift.Equatable {
        /// A list of groups to be attached. There must be at least one group.
        public var groups: [Swift.String]?
        /// The Amazon Resource Name (ARN) of the policy to be attached.
        /// This member is required.
        public var policyArn: Swift.String?
        /// A list of roles to be attached. There must be at least one role.
        public var roles: [Swift.String]?
        /// A list of users to be attached. There must be at least one user.
        public var users: [Swift.String]?

        public init(
            groups: [Swift.String]? = nil,
            policyArn: Swift.String? = nil,
            roles: [Swift.String]? = nil,
            users: [Swift.String]? = nil
        )
        {
            self.groups = groups
            self.policyArn = policyArn
            self.roles = roles
            self.users = users
        }
    }

}

extension InternalErrorException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InternalErrorExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// An error on the server occurred during the processing of your request. Try again later.
public struct InternalErrorException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The error message the exception carries.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalErrorException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InternalErrorExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalErrorExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidNextTokenException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidNextTokenExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The pagination token is invalid.
public struct InvalidNextTokenException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The error message the exception carries.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidNextTokenException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidNextTokenExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidNextTokenExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidParameterException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidParameterExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// An error on the client occurred. Typically, the cause is an invalid input value.
public struct InvalidParameterException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The error message the exception carries.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidParameterException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidParameterExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidParameterExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension NotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: NotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// We cant locate the resource that you specified.
public struct NotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The error message the exception carries.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "NotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct NotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension NotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension BudgetsClientTypes.Notification: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case comparisonOperator = "ComparisonOperator"
        case notificationState = "NotificationState"
        case notificationType = "NotificationType"
        case threshold = "Threshold"
        case thresholdType = "ThresholdType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let comparisonOperator = self.comparisonOperator {
            try encodeContainer.encode(comparisonOperator.rawValue, forKey: .comparisonOperator)
        }
        if let notificationState = self.notificationState {
            try encodeContainer.encode(notificationState.rawValue, forKey: .notificationState)
        }
        if let notificationType = self.notificationType {
            try encodeContainer.encode(notificationType.rawValue, forKey: .notificationType)
        }
        if threshold != 0.0 {
            try encodeContainer.encode(threshold, forKey: .threshold)
        }
        if let thresholdType = self.thresholdType {
            try encodeContainer.encode(thresholdType.rawValue, forKey: .thresholdType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let notificationTypeDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.NotificationType.self, forKey: .notificationType)
        notificationType = notificationTypeDecoded
        let comparisonOperatorDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.ComparisonOperator.self, forKey: .comparisonOperator)
        comparisonOperator = comparisonOperatorDecoded
        let thresholdDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .threshold) ?? 0.0
        threshold = thresholdDecoded
        let thresholdTypeDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.ThresholdType.self, forKey: .thresholdType)
        thresholdType = thresholdTypeDecoded
        let notificationStateDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.NotificationState.self, forKey: .notificationState)
        notificationState = notificationStateDecoded
    }
}

extension BudgetsClientTypes {
    /// A notification that's associated with a budget. A budget can have up to ten notifications. Each notification must have at least one subscriber. A notification can have one SNS subscriber and up to 10 email subscribers, for a total of 11 subscribers. For example, if you have a budget for 200 dollars and you want to be notified when you go over 160 dollars, create a notification with the following parameters:
    ///
    /// * A notificationType of ACTUAL
    ///
    /// * A thresholdType of PERCENTAGE
    ///
    /// * A comparisonOperator of GREATER_THAN
    ///
    /// * A notification threshold of 80
    public struct Notification: Swift.Equatable {
        /// The comparison that's used for this notification.
        /// This member is required.
        public var comparisonOperator: BudgetsClientTypes.ComparisonOperator?
        /// Specifies whether this notification is in alarm. If a budget notification is in the ALARM state, you passed the set threshold for the budget.
        public var notificationState: BudgetsClientTypes.NotificationState?
        /// Specifies whether the notification is for how much you have spent (ACTUAL) or for how much that you're forecasted to spend (FORECASTED).
        /// This member is required.
        public var notificationType: BudgetsClientTypes.NotificationType?
        /// The threshold that's associated with a notification. Thresholds are always a percentage, and many customers find value being alerted between 50% - 200% of the budgeted amount. The maximum limit for your threshold is 1,000,000% above the budgeted amount.
        /// This member is required.
        public var threshold: Swift.Double
        /// The type of threshold for a notification. For ABSOLUTE_VALUE thresholds, Amazon Web Services notifies you when you go over or are forecasted to go over your total cost threshold. For PERCENTAGE thresholds, Amazon Web Services notifies you when you go over or are forecasted to go over a certain percentage of your forecasted spend. For example, if you have a budget for 200 dollars and you have a PERCENTAGE threshold of 80%, Amazon Web Services notifies you when you go over 160 dollars.
        public var thresholdType: BudgetsClientTypes.ThresholdType?

        public init(
            comparisonOperator: BudgetsClientTypes.ComparisonOperator? = nil,
            notificationState: BudgetsClientTypes.NotificationState? = nil,
            notificationType: BudgetsClientTypes.NotificationType? = nil,
            threshold: Swift.Double = 0.0,
            thresholdType: BudgetsClientTypes.ThresholdType? = nil
        )
        {
            self.comparisonOperator = comparisonOperator
            self.notificationState = notificationState
            self.notificationType = notificationType
            self.threshold = threshold
            self.thresholdType = thresholdType
        }
    }

}

extension BudgetsClientTypes {
    public enum NotificationState: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case alarm
        case ok
        case sdkUnknown(Swift.String)

        public static var allCases: [NotificationState] {
            return [
                .alarm,
                .ok,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .alarm: return "ALARM"
            case .ok: return "OK"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = NotificationState(rawValue: rawValue) ?? NotificationState.sdkUnknown(rawValue)
        }
    }
}

extension BudgetsClientTypes {
    /// The type of a notification. It must be ACTUAL or FORECASTED.
    public enum NotificationType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case actual
        case forecasted
        case sdkUnknown(Swift.String)

        public static var allCases: [NotificationType] {
            return [
                .actual,
                .forecasted,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .actual: return "ACTUAL"
            case .forecasted: return "FORECASTED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = NotificationType(rawValue: rawValue) ?? NotificationType.sdkUnknown(rawValue)
        }
    }
}

extension BudgetsClientTypes.NotificationWithSubscribers: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case notification = "Notification"
        case subscribers = "Subscribers"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let notification = self.notification {
            try encodeContainer.encode(notification, forKey: .notification)
        }
        if let subscribers = subscribers {
            var subscribersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subscribers)
            for subscriber0 in subscribers {
                try subscribersContainer.encode(subscriber0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let notificationDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.Notification.self, forKey: .notification)
        notification = notificationDecoded
        let subscribersContainer = try containerValues.decodeIfPresent([BudgetsClientTypes.Subscriber?].self, forKey: .subscribers)
        var subscribersDecoded0:[BudgetsClientTypes.Subscriber]? = nil
        if let subscribersContainer = subscribersContainer {
            subscribersDecoded0 = [BudgetsClientTypes.Subscriber]()
            for structure0 in subscribersContainer {
                if let structure0 = structure0 {
                    subscribersDecoded0?.append(structure0)
                }
            }
        }
        subscribers = subscribersDecoded0
    }
}

extension BudgetsClientTypes {
    /// A notification with subscribers. A notification can have one SNS subscriber and up to 10 email subscribers, for a total of 11 subscribers.
    public struct NotificationWithSubscribers: Swift.Equatable {
        /// The notification that's associated with a budget.
        /// This member is required.
        public var notification: BudgetsClientTypes.Notification?
        /// A list of subscribers who are subscribed to this notification.
        /// This member is required.
        public var subscribers: [BudgetsClientTypes.Subscriber]?

        public init(
            notification: BudgetsClientTypes.Notification? = nil,
            subscribers: [BudgetsClientTypes.Subscriber]? = nil
        )
        {
            self.notification = notification
            self.subscribers = subscribers
        }
    }

}

extension ResourceLockedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceLockedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request was received and recognized by the server, but the server rejected that particular method for the requested resource.
public struct ResourceLockedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The error message the exception carries.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceLockedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ResourceLockedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceLockedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension BudgetsClientTypes.ScpActionDefinition: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policyId = "PolicyId"
        case targetIds = "TargetIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let policyId = self.policyId {
            try encodeContainer.encode(policyId, forKey: .policyId)
        }
        if let targetIds = targetIds {
            var targetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .targetIds)
            for targetid0 in targetIds {
                try targetIdsContainer.encode(targetid0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyId)
        policyId = policyIdDecoded
        let targetIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .targetIds)
        var targetIdsDecoded0:[Swift.String]? = nil
        if let targetIdsContainer = targetIdsContainer {
            targetIdsDecoded0 = [Swift.String]()
            for string0 in targetIdsContainer {
                if let string0 = string0 {
                    targetIdsDecoded0?.append(string0)
                }
            }
        }
        targetIds = targetIdsDecoded0
    }
}

extension BudgetsClientTypes {
    /// The service control policies (SCP) action definition details.
    public struct ScpActionDefinition: Swift.Equatable {
        /// The policy ID attached.
        /// This member is required.
        public var policyId: Swift.String?
        /// A list of target IDs.
        /// This member is required.
        public var targetIds: [Swift.String]?

        public init(
            policyId: Swift.String? = nil,
            targetIds: [Swift.String]? = nil
        )
        {
            self.policyId = policyId
            self.targetIds = targetIds
        }
    }

}

extension BudgetsClientTypes.Spend: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case amount = "Amount"
        case unit = "Unit"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let amount = self.amount {
            try encodeContainer.encode(amount, forKey: .amount)
        }
        if let unit = self.unit {
            try encodeContainer.encode(unit, forKey: .unit)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let amountDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .amount)
        amount = amountDecoded
        let unitDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .unit)
        unit = unitDecoded
    }
}

extension BudgetsClientTypes {
    /// The amount of cost or usage that's measured for a budget. Cost example: A Spend for 3 USD of costs has the following parameters:
    ///
    /// * An Amount of 3
    ///
    /// * A Unit of USD
    ///
    ///
    /// Usage example: A Spend for 3 GB of S3 usage has the following parameters:
    ///
    /// * An Amount of 3
    ///
    /// * A Unit of GB
    public struct Spend: Swift.Equatable {
        /// The cost or usage amount that's associated with a budget forecast, actual spend, or budget threshold.
        /// This member is required.
        public var amount: Swift.String?
        /// The unit of measurement that's used for the budget forecast, actual spend, or budget threshold.
        /// This member is required.
        public var unit: Swift.String?

        public init(
            amount: Swift.String? = nil,
            unit: Swift.String? = nil
        )
        {
            self.amount = amount
            self.unit = unit
        }
    }

}

extension BudgetsClientTypes.SsmActionDefinition: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actionSubType = "ActionSubType"
        case instanceIds = "InstanceIds"
        case region = "Region"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actionSubType = self.actionSubType {
            try encodeContainer.encode(actionSubType.rawValue, forKey: .actionSubType)
        }
        if let instanceIds = instanceIds {
            var instanceIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .instanceIds)
            for instanceid0 in instanceIds {
                try instanceIdsContainer.encode(instanceid0)
            }
        }
        if let region = self.region {
            try encodeContainer.encode(region, forKey: .region)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionSubTypeDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.ActionSubType.self, forKey: .actionSubType)
        actionSubType = actionSubTypeDecoded
        let regionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .region)
        region = regionDecoded
        let instanceIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .instanceIds)
        var instanceIdsDecoded0:[Swift.String]? = nil
        if let instanceIdsContainer = instanceIdsContainer {
            instanceIdsDecoded0 = [Swift.String]()
            for string0 in instanceIdsContainer {
                if let string0 = string0 {
                    instanceIdsDecoded0?.append(string0)
                }
            }
        }
        instanceIds = instanceIdsDecoded0
    }
}

extension BudgetsClientTypes {
    /// The Amazon Web Services Systems Manager (SSM) action definition details.
    public struct SsmActionDefinition: Swift.Equatable {
        /// The action subType.
        /// This member is required.
        public var actionSubType: BudgetsClientTypes.ActionSubType?
        /// The EC2 and RDS instance IDs.
        /// This member is required.
        public var instanceIds: [Swift.String]?
        /// The Region to run the SSM document.
        /// This member is required.
        public var region: Swift.String?

        public init(
            actionSubType: BudgetsClientTypes.ActionSubType? = nil,
            instanceIds: [Swift.String]? = nil,
            region: Swift.String? = nil
        )
        {
            self.actionSubType = actionSubType
            self.instanceIds = instanceIds
            self.region = region
        }
    }

}

extension BudgetsClientTypes.Subscriber: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case address = "Address"
        case subscriptionType = "SubscriptionType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let address = self.address {
            try encodeContainer.encode(address, forKey: .address)
        }
        if let subscriptionType = self.subscriptionType {
            try encodeContainer.encode(subscriptionType.rawValue, forKey: .subscriptionType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subscriptionTypeDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.SubscriptionType.self, forKey: .subscriptionType)
        subscriptionType = subscriptionTypeDecoded
        let addressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .address)
        address = addressDecoded
    }
}

extension BudgetsClientTypes.Subscriber: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Subscriber(subscriptionType: \(Swift.String(describing: subscriptionType)), address: \"CONTENT_REDACTED\")"}
}

extension BudgetsClientTypes {
    /// The subscriber to a budget notification. The subscriber consists of a subscription type and either an Amazon SNS topic or an email address. For example, an email subscriber has the following parameters:
    ///
    /// * A subscriptionType of EMAIL
    ///
    /// * An address of example@example.com
    public struct Subscriber: Swift.Equatable {
        /// The address that Amazon Web Services sends budget notifications to, either an SNS topic or an email. When you create a subscriber, the value of Address can't contain line breaks.
        /// This member is required.
        public var address: Swift.String?
        /// The type of notification that Amazon Web Services sends to a subscriber.
        /// This member is required.
        public var subscriptionType: BudgetsClientTypes.SubscriptionType?

        public init(
            address: Swift.String? = nil,
            subscriptionType: BudgetsClientTypes.SubscriptionType? = nil
        )
        {
            self.address = address
            self.subscriptionType = subscriptionType
        }
    }

}

extension BudgetsClientTypes {
    /// The subscription type of the subscriber. It can be SMS or EMAIL.
    public enum SubscriptionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case email
        case sns
        case sdkUnknown(Swift.String)

        public static var allCases: [SubscriptionType] {
            return [
                .email,
                .sns,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .email: return "EMAIL"
            case .sns: return "SNS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SubscriptionType(rawValue: rawValue) ?? SubscriptionType.sdkUnknown(rawValue)
        }
    }
}

extension BudgetsClientTypes {
    /// The type of threshold for a notification.
    public enum ThresholdType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case absoluteValue
        case percentage
        case sdkUnknown(Swift.String)

        public static var allCases: [ThresholdType] {
            return [
                .absoluteValue,
                .percentage,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .absoluteValue: return "ABSOLUTE_VALUE"
            case .percentage: return "PERCENTAGE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ThresholdType(rawValue: rawValue) ?? ThresholdType.sdkUnknown(rawValue)
        }
    }
}

extension ThrottlingException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The number of API requests has exceeded the maximum allowed API request throttling limit for the account.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The error message the exception carries.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension BudgetsClientTypes.TimePeriod: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case end = "End"
        case start = "Start"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let end = self.end {
            try encodeContainer.encodeTimestamp(end, format: .epochSeconds, forKey: .end)
        }
        if let start = self.start {
            try encodeContainer.encodeTimestamp(start, format: .epochSeconds, forKey: .start)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .start)
        start = startDecoded
        let endDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .end)
        end = endDecoded
    }
}

extension BudgetsClientTypes {
    /// The period of time that's covered by a budget. The period has a start date and an end date. The start date must come before the end date. There are no restrictions on the end date.
    public struct TimePeriod: Swift.Equatable {
        /// The end date for a budget. If you didn't specify an end date, Amazon Web Services set your end date to 06/15/87 00:00 UTC. The defaults are the same for the Billing and Cost Management console and the API. After the end date, Amazon Web Services deletes the budget and all the associated notifications and subscribers. You can change your end date with the UpdateBudget operation.
        public var end: ClientRuntime.Date?
        /// The start date for a budget. If you created your budget and didn't specify a start date, Amazon Web Services defaults to the start of your chosen time period (DAILY, MONTHLY, QUARTERLY, or ANNUALLY). For example, if you created your budget on January 24, 2018, chose DAILY, and didn't set a start date, Amazon Web Services set your start date to 01/24/18 00:00 UTC. If you chose MONTHLY, Amazon Web Services set your start date to 01/01/18 00:00 UTC. The defaults are the same for the Billing and Cost Management console and the API. You can change your start date with the UpdateBudget operation.
        public var start: ClientRuntime.Date?

        public init(
            end: ClientRuntime.Date? = nil,
            start: ClientRuntime.Date? = nil
        )
        {
            self.end = end
            self.start = start
        }
    }

}

extension BudgetsClientTypes {
    /// The time unit of the budget, such as MONTHLY or QUARTERLY.
    public enum TimeUnit: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case annually
        case daily
        case monthly
        case quarterly
        case sdkUnknown(Swift.String)

        public static var allCases: [TimeUnit] {
            return [
                .annually,
                .daily,
                .monthly,
                .quarterly,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .annually: return "ANNUALLY"
            case .daily: return "DAILY"
            case .monthly: return "MONTHLY"
            case .quarterly: return "QUARTERLY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TimeUnit(rawValue: rawValue) ?? TimeUnit.sdkUnknown(rawValue)
        }
    }
}

extension UpdateBudgetActionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case actionId = "ActionId"
        case actionThreshold = "ActionThreshold"
        case approvalModel = "ApprovalModel"
        case budgetName = "BudgetName"
        case definition = "Definition"
        case executionRoleArn = "ExecutionRoleArn"
        case notificationType = "NotificationType"
        case subscribers = "Subscribers"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let actionId = self.actionId {
            try encodeContainer.encode(actionId, forKey: .actionId)
        }
        if let actionThreshold = self.actionThreshold {
            try encodeContainer.encode(actionThreshold, forKey: .actionThreshold)
        }
        if let approvalModel = self.approvalModel {
            try encodeContainer.encode(approvalModel.rawValue, forKey: .approvalModel)
        }
        if let budgetName = self.budgetName {
            try encodeContainer.encode(budgetName, forKey: .budgetName)
        }
        if let definition = self.definition {
            try encodeContainer.encode(definition, forKey: .definition)
        }
        if let executionRoleArn = self.executionRoleArn {
            try encodeContainer.encode(executionRoleArn, forKey: .executionRoleArn)
        }
        if let notificationType = self.notificationType {
            try encodeContainer.encode(notificationType.rawValue, forKey: .notificationType)
        }
        if let subscribers = subscribers {
            var subscribersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subscribers)
            for subscriber0 in subscribers {
                try subscribersContainer.encode(subscriber0)
            }
        }
    }
}

extension UpdateBudgetActionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UpdateBudgetActionInput: Swift.Equatable {
    /// The account ID of the user. It's a 12-digit number.
    /// This member is required.
    public var accountId: Swift.String?
    /// A system-generated universally unique identifier (UUID) for the action.
    /// This member is required.
    public var actionId: Swift.String?
    /// The trigger threshold of the action.
    public var actionThreshold: BudgetsClientTypes.ActionThreshold?
    /// This specifies if the action needs manual or automatic approval.
    public var approvalModel: BudgetsClientTypes.ApprovalModel?
    /// A string that represents the budget name. The ":" and "\" characters, and the "/action/" substring, aren't allowed.
    /// This member is required.
    public var budgetName: Swift.String?
    /// Specifies all of the type-specific parameters.
    public var definition: BudgetsClientTypes.Definition?
    /// The role passed for action execution and reversion. Roles and actions must be in the same account.
    public var executionRoleArn: Swift.String?
    /// The type of a notification. It must be ACTUAL or FORECASTED.
    public var notificationType: BudgetsClientTypes.NotificationType?
    /// A list of subscribers.
    public var subscribers: [BudgetsClientTypes.Subscriber]?

    public init(
        accountId: Swift.String? = nil,
        actionId: Swift.String? = nil,
        actionThreshold: BudgetsClientTypes.ActionThreshold? = nil,
        approvalModel: BudgetsClientTypes.ApprovalModel? = nil,
        budgetName: Swift.String? = nil,
        definition: BudgetsClientTypes.Definition? = nil,
        executionRoleArn: Swift.String? = nil,
        notificationType: BudgetsClientTypes.NotificationType? = nil,
        subscribers: [BudgetsClientTypes.Subscriber]? = nil
    )
    {
        self.accountId = accountId
        self.actionId = actionId
        self.actionThreshold = actionThreshold
        self.approvalModel = approvalModel
        self.budgetName = budgetName
        self.definition = definition
        self.executionRoleArn = executionRoleArn
        self.notificationType = notificationType
        self.subscribers = subscribers
    }
}

struct UpdateBudgetActionInputBody: Swift.Equatable {
    let accountId: Swift.String?
    let budgetName: Swift.String?
    let actionId: Swift.String?
    let notificationType: BudgetsClientTypes.NotificationType?
    let actionThreshold: BudgetsClientTypes.ActionThreshold?
    let definition: BudgetsClientTypes.Definition?
    let executionRoleArn: Swift.String?
    let approvalModel: BudgetsClientTypes.ApprovalModel?
    let subscribers: [BudgetsClientTypes.Subscriber]?
}

extension UpdateBudgetActionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case actionId = "ActionId"
        case actionThreshold = "ActionThreshold"
        case approvalModel = "ApprovalModel"
        case budgetName = "BudgetName"
        case definition = "Definition"
        case executionRoleArn = "ExecutionRoleArn"
        case notificationType = "NotificationType"
        case subscribers = "Subscribers"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let budgetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .budgetName)
        budgetName = budgetNameDecoded
        let actionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .actionId)
        actionId = actionIdDecoded
        let notificationTypeDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.NotificationType.self, forKey: .notificationType)
        notificationType = notificationTypeDecoded
        let actionThresholdDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.ActionThreshold.self, forKey: .actionThreshold)
        actionThreshold = actionThresholdDecoded
        let definitionDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.Definition.self, forKey: .definition)
        definition = definitionDecoded
        let executionRoleArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .executionRoleArn)
        executionRoleArn = executionRoleArnDecoded
        let approvalModelDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.ApprovalModel.self, forKey: .approvalModel)
        approvalModel = approvalModelDecoded
        let subscribersContainer = try containerValues.decodeIfPresent([BudgetsClientTypes.Subscriber?].self, forKey: .subscribers)
        var subscribersDecoded0:[BudgetsClientTypes.Subscriber]? = nil
        if let subscribersContainer = subscribersContainer {
            subscribersDecoded0 = [BudgetsClientTypes.Subscriber]()
            for structure0 in subscribersContainer {
                if let structure0 = structure0 {
                    subscribersDecoded0?.append(structure0)
                }
            }
        }
        subscribers = subscribersDecoded0
    }
}

extension UpdateBudgetActionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateBudgetActionOutputBody = try responseDecoder.decode(responseBody: data)
            self.accountId = output.accountId
            self.budgetName = output.budgetName
            self.newAction = output.newAction
            self.oldAction = output.oldAction
        } else {
            self.accountId = nil
            self.budgetName = nil
            self.newAction = nil
            self.oldAction = nil
        }
    }
}

public struct UpdateBudgetActionOutput: Swift.Equatable {
    /// The account ID of the user. It's a 12-digit number.
    /// This member is required.
    public var accountId: Swift.String?
    /// A string that represents the budget name. The ":" and "\" characters, and the "/action/" substring, aren't allowed.
    /// This member is required.
    public var budgetName: Swift.String?
    /// The updated action resource information.
    /// This member is required.
    public var newAction: BudgetsClientTypes.Action?
    /// The previous action resource information.
    /// This member is required.
    public var oldAction: BudgetsClientTypes.Action?

    public init(
        accountId: Swift.String? = nil,
        budgetName: Swift.String? = nil,
        newAction: BudgetsClientTypes.Action? = nil,
        oldAction: BudgetsClientTypes.Action? = nil
    )
    {
        self.accountId = accountId
        self.budgetName = budgetName
        self.newAction = newAction
        self.oldAction = oldAction
    }
}

struct UpdateBudgetActionOutputBody: Swift.Equatable {
    let accountId: Swift.String?
    let budgetName: Swift.String?
    let oldAction: BudgetsClientTypes.Action?
    let newAction: BudgetsClientTypes.Action?
}

extension UpdateBudgetActionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case budgetName = "BudgetName"
        case newAction = "NewAction"
        case oldAction = "OldAction"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let budgetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .budgetName)
        budgetName = budgetNameDecoded
        let oldActionDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.Action.self, forKey: .oldAction)
        oldAction = oldActionDecoded
        let newActionDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.Action.self, forKey: .newAction)
        newAction = newActionDecoded
    }
}

enum UpdateBudgetActionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalErrorException": return try await InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceLockedException": return try await ResourceLockedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateBudgetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case newBudget = "NewBudget"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let newBudget = self.newBudget {
            try encodeContainer.encode(newBudget, forKey: .newBudget)
        }
    }
}

extension UpdateBudgetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Request of UpdateBudget
public struct UpdateBudgetInput: Swift.Equatable {
    /// The accountId that is associated with the budget that you want to update.
    /// This member is required.
    public var accountId: Swift.String?
    /// The budget that you want to update your budget to.
    /// This member is required.
    public var newBudget: BudgetsClientTypes.Budget?

    public init(
        accountId: Swift.String? = nil,
        newBudget: BudgetsClientTypes.Budget? = nil
    )
    {
        self.accountId = accountId
        self.newBudget = newBudget
    }
}

struct UpdateBudgetInputBody: Swift.Equatable {
    let accountId: Swift.String?
    let newBudget: BudgetsClientTypes.Budget?
}

extension UpdateBudgetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case newBudget = "NewBudget"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let newBudgetDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.Budget.self, forKey: .newBudget)
        newBudget = newBudgetDecoded
    }
}

extension UpdateBudgetOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

/// Response of UpdateBudget
public struct UpdateBudgetOutput: Swift.Equatable {

    public init() { }
}

enum UpdateBudgetOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalErrorException": return try await InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateNotificationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case budgetName = "BudgetName"
        case newNotification = "NewNotification"
        case oldNotification = "OldNotification"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let budgetName = self.budgetName {
            try encodeContainer.encode(budgetName, forKey: .budgetName)
        }
        if let newNotification = self.newNotification {
            try encodeContainer.encode(newNotification, forKey: .newNotification)
        }
        if let oldNotification = self.oldNotification {
            try encodeContainer.encode(oldNotification, forKey: .oldNotification)
        }
    }
}

extension UpdateNotificationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Request of UpdateNotification
public struct UpdateNotificationInput: Swift.Equatable {
    /// The accountId that is associated with the budget whose notification you want to update.
    /// This member is required.
    public var accountId: Swift.String?
    /// The name of the budget whose notification you want to update.
    /// This member is required.
    public var budgetName: Swift.String?
    /// The updated notification to be associated with a budget.
    /// This member is required.
    public var newNotification: BudgetsClientTypes.Notification?
    /// The previous notification that is associated with a budget.
    /// This member is required.
    public var oldNotification: BudgetsClientTypes.Notification?

    public init(
        accountId: Swift.String? = nil,
        budgetName: Swift.String? = nil,
        newNotification: BudgetsClientTypes.Notification? = nil,
        oldNotification: BudgetsClientTypes.Notification? = nil
    )
    {
        self.accountId = accountId
        self.budgetName = budgetName
        self.newNotification = newNotification
        self.oldNotification = oldNotification
    }
}

struct UpdateNotificationInputBody: Swift.Equatable {
    let accountId: Swift.String?
    let budgetName: Swift.String?
    let oldNotification: BudgetsClientTypes.Notification?
    let newNotification: BudgetsClientTypes.Notification?
}

extension UpdateNotificationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case budgetName = "BudgetName"
        case newNotification = "NewNotification"
        case oldNotification = "OldNotification"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let budgetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .budgetName)
        budgetName = budgetNameDecoded
        let oldNotificationDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.Notification.self, forKey: .oldNotification)
        oldNotification = oldNotificationDecoded
        let newNotificationDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.Notification.self, forKey: .newNotification)
        newNotification = newNotificationDecoded
    }
}

extension UpdateNotificationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

/// Response of UpdateNotification
public struct UpdateNotificationOutput: Swift.Equatable {

    public init() { }
}

enum UpdateNotificationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "DuplicateRecordException": return try await DuplicateRecordException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalErrorException": return try await InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateSubscriberInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case budgetName = "BudgetName"
        case newSubscriber = "NewSubscriber"
        case notification = "Notification"
        case oldSubscriber = "OldSubscriber"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let budgetName = self.budgetName {
            try encodeContainer.encode(budgetName, forKey: .budgetName)
        }
        if let newSubscriber = self.newSubscriber {
            try encodeContainer.encode(newSubscriber, forKey: .newSubscriber)
        }
        if let notification = self.notification {
            try encodeContainer.encode(notification, forKey: .notification)
        }
        if let oldSubscriber = self.oldSubscriber {
            try encodeContainer.encode(oldSubscriber, forKey: .oldSubscriber)
        }
    }
}

extension UpdateSubscriberInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Request of UpdateSubscriber
public struct UpdateSubscriberInput: Swift.Equatable {
    /// The accountId that is associated with the budget whose subscriber you want to update.
    /// This member is required.
    public var accountId: Swift.String?
    /// The name of the budget whose subscriber you want to update.
    /// This member is required.
    public var budgetName: Swift.String?
    /// The updated subscriber that is associated with a budget notification.
    /// This member is required.
    public var newSubscriber: BudgetsClientTypes.Subscriber?
    /// The notification whose subscriber you want to update.
    /// This member is required.
    public var notification: BudgetsClientTypes.Notification?
    /// The previous subscriber that is associated with a budget notification.
    /// This member is required.
    public var oldSubscriber: BudgetsClientTypes.Subscriber?

    public init(
        accountId: Swift.String? = nil,
        budgetName: Swift.String? = nil,
        newSubscriber: BudgetsClientTypes.Subscriber? = nil,
        notification: BudgetsClientTypes.Notification? = nil,
        oldSubscriber: BudgetsClientTypes.Subscriber? = nil
    )
    {
        self.accountId = accountId
        self.budgetName = budgetName
        self.newSubscriber = newSubscriber
        self.notification = notification
        self.oldSubscriber = oldSubscriber
    }
}

struct UpdateSubscriberInputBody: Swift.Equatable {
    let accountId: Swift.String?
    let budgetName: Swift.String?
    let notification: BudgetsClientTypes.Notification?
    let oldSubscriber: BudgetsClientTypes.Subscriber?
    let newSubscriber: BudgetsClientTypes.Subscriber?
}

extension UpdateSubscriberInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "AccountId"
        case budgetName = "BudgetName"
        case newSubscriber = "NewSubscriber"
        case notification = "Notification"
        case oldSubscriber = "OldSubscriber"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let budgetNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .budgetName)
        budgetName = budgetNameDecoded
        let notificationDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.Notification.self, forKey: .notification)
        notification = notificationDecoded
        let oldSubscriberDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.Subscriber.self, forKey: .oldSubscriber)
        oldSubscriber = oldSubscriberDecoded
        let newSubscriberDecoded = try containerValues.decodeIfPresent(BudgetsClientTypes.Subscriber.self, forKey: .newSubscriber)
        newSubscriber = newSubscriberDecoded
    }
}

extension UpdateSubscriberOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

/// Response of UpdateSubscriber
public struct UpdateSubscriberOutput: Swift.Equatable {

    public init() { }
}

enum UpdateSubscriberOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "DuplicateRecordException": return try await DuplicateRecordException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalErrorException": return try await InternalErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "NotFoundException": return try await NotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}
