// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension HealthClientTypes.AffectedEntity: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsAccountId
        case entityArn
        case entityUrl
        case entityValue
        case eventArn
        case lastUpdatedTime
        case statusCode
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let awsAccountId = self.awsAccountId {
            try encodeContainer.encode(awsAccountId, forKey: .awsAccountId)
        }
        if let entityArn = self.entityArn {
            try encodeContainer.encode(entityArn, forKey: .entityArn)
        }
        if let entityUrl = self.entityUrl {
            try encodeContainer.encode(entityUrl, forKey: .entityUrl)
        }
        if let entityValue = self.entityValue {
            try encodeContainer.encode(entityValue, forKey: .entityValue)
        }
        if let eventArn = self.eventArn {
            try encodeContainer.encode(eventArn, forKey: .eventArn)
        }
        if let lastUpdatedTime = self.lastUpdatedTime {
            try encodeContainer.encodeTimestamp(lastUpdatedTime, format: .epochSeconds, forKey: .lastUpdatedTime)
        }
        if let statusCode = self.statusCode {
            try encodeContainer.encode(statusCode.rawValue, forKey: .statusCode)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagSet0) in tags {
                try tagsContainer.encode(tagSet0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entityArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entityArn)
        entityArn = entityArnDecoded
        let eventArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventArn)
        eventArn = eventArnDecoded
        let entityValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entityValue)
        entityValue = entityValueDecoded
        let entityUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entityUrl)
        entityUrl = entityUrlDecoded
        let awsAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsAccountId)
        awsAccountId = awsAccountIdDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
        let statusCodeDecoded = try containerValues.decodeIfPresent(HealthClientTypes.EntityStatusCode.self, forKey: .statusCode)
        statusCode = statusCodeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension HealthClientTypes {
    /// Information about an entity that is affected by a Health event.
    public struct AffectedEntity: Swift.Equatable {
        /// The 12-digit Amazon Web Services account number that contains the affected entity.
        public var awsAccountId: Swift.String?
        /// The unique identifier for the entity. Format: arn:aws:health:entity-region:aws-account:entity/entity-id . Example: arn:aws:health:us-east-1:111222333444:entity/AVh5GGT7ul1arKr1sE1K
        public var entityArn: Swift.String?
        /// The URL of the affected entity.
        public var entityUrl: Swift.String?
        /// The ID of the affected entity.
        public var entityValue: Swift.String?
        /// The unique identifier for the event. The event ARN has the arn:aws:health:event-region::event/SERVICE/EVENT_TYPE_CODE/EVENT_TYPE_PLUS_ID  format. For example, an event ARN might look like the following: arn:aws:health:us-east-1::event/EC2/EC2_INSTANCE_RETIREMENT_SCHEDULED/EC2_INSTANCE_RETIREMENT_SCHEDULED_ABC123-DEF456
        public var eventArn: Swift.String?
        /// The most recent time that the entity was updated.
        public var lastUpdatedTime: ClientRuntime.Date?
        /// The most recent status of the entity affected by the event. The possible values are IMPAIRED, UNIMPAIRED, and UNKNOWN.
        public var statusCode: HealthClientTypes.EntityStatusCode?
        /// A map of entity tags attached to the affected entity. Currently, the tags property isn't supported.
        public var tags: [Swift.String:Swift.String]?

        public init (
            awsAccountId: Swift.String? = nil,
            entityArn: Swift.String? = nil,
            entityUrl: Swift.String? = nil,
            entityValue: Swift.String? = nil,
            eventArn: Swift.String? = nil,
            lastUpdatedTime: ClientRuntime.Date? = nil,
            statusCode: HealthClientTypes.EntityStatusCode? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.awsAccountId = awsAccountId
            self.entityArn = entityArn
            self.entityUrl = entityUrl
            self.entityValue = entityValue
            self.eventArn = eventArn
            self.lastUpdatedTime = lastUpdatedTime
            self.statusCode = statusCode
            self.tags = tags
        }
    }

}

extension ConcurrentModificationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ConcurrentModificationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// [EnableHealthServiceAccessForOrganization](https://docs.aws.amazon.com/health/latest/APIReference/API_EnableHealthServiceAccessForOrganization.html) is already in progress. Wait for the action to complete before trying again. To get the current status, use the [DescribeHealthServiceStatusForOrganization](https://docs.aws.amazon.com/health/latest/APIReference/API_DescribeHealthServiceStatusForOrganization.html) operation.
public struct ConcurrentModificationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ConcurrentModificationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ConcurrentModificationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension HealthClientTypes.DateTimeRange: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case from
        case to
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let from = self.from {
            try encodeContainer.encodeTimestamp(from, format: .epochSeconds, forKey: .from)
        }
        if let to = self.to {
            try encodeContainer.encodeTimestamp(to, format: .epochSeconds, forKey: .to)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fromDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .from)
        from = fromDecoded
        let toDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .to)
        to = toDecoded
    }
}

extension HealthClientTypes {
    /// A range of dates and times that is used by the [EventFilter](https://docs.aws.amazon.com/health/latest/APIReference/API_EventFilter.html) and [EntityFilter](https://docs.aws.amazon.com/health/latest/APIReference/API_EntityFilter.html) objects. If from is set and to is set: match items where the timestamp (startTime, endTime, or lastUpdatedTime) is between from and to inclusive. If from is set and to is not set: match items where the timestamp value is equal to or after from. If from is not set and to is set: match items where the timestamp value is equal to or before to.
    public struct DateTimeRange: Swift.Equatable {
        /// The starting date and time of a time range.
        public var from: ClientRuntime.Date?
        /// The ending date and time of a time range.
        public var to: ClientRuntime.Date?

        public init (
            from: ClientRuntime.Date? = nil,
            to: ClientRuntime.Date? = nil
        )
        {
            self.from = from
            self.to = to
        }
    }

}

extension DescribeAffectedAccountsForOrganizationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventArn
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eventArn = self.eventArn {
            try encodeContainer.encode(eventArn, forKey: .eventArn)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension DescribeAffectedAccountsForOrganizationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeAffectedAccountsForOrganizationInput: Swift.Equatable {
    /// The unique identifier for the event. The event ARN has the arn:aws:health:event-region::event/SERVICE/EVENT_TYPE_CODE/EVENT_TYPE_PLUS_ID  format. For example, an event ARN might look like the following: arn:aws:health:us-east-1::event/EC2/EC2_INSTANCE_RETIREMENT_SCHEDULED/EC2_INSTANCE_RETIREMENT_SCHEDULED_ABC123-DEF456
    /// This member is required.
    public var eventArn: Swift.String?
    /// The maximum number of items to return in one batch, between 10 and 100, inclusive.
    public var maxResults: Swift.Int?
    /// If the results of a search are large, only a portion of the results are returned, and a nextToken pagination token is returned in the response. To retrieve the next batch of results, reissue the search request and include the returned token. When all results have been returned, the response does not contain a pagination token value.
    public var nextToken: Swift.String?

    public init (
        eventArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.eventArn = eventArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeAffectedAccountsForOrganizationInputBody: Swift.Equatable {
    let eventArn: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension DescribeAffectedAccountsForOrganizationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventArn
        case maxResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventArn)
        eventArn = eventArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension DescribeAffectedAccountsForOrganizationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeAffectedAccountsForOrganizationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidPaginationToken" : self = .invalidPaginationToken(try InvalidPaginationToken(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeAffectedAccountsForOrganizationOutputError: Swift.Error, Swift.Equatable {
    case invalidPaginationToken(InvalidPaginationToken)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeAffectedAccountsForOrganizationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeAffectedAccountsForOrganizationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.affectedAccounts = output.affectedAccounts
            self.eventScopeCode = output.eventScopeCode
            self.nextToken = output.nextToken
        } else {
            self.affectedAccounts = nil
            self.eventScopeCode = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeAffectedAccountsForOrganizationOutputResponse: Swift.Equatable {
    /// A JSON set of elements of the affected accounts.
    public var affectedAccounts: [Swift.String]?
    /// This parameter specifies if the Health event is a public Amazon Web Services service event or an account-specific event.
    ///
    /// * If the eventScopeCode value is PUBLIC, then the affectedAccounts value is always empty.
    ///
    /// * If the eventScopeCode value is ACCOUNT_SPECIFIC, then the affectedAccounts value lists the affected Amazon Web Services accounts in your organization. For example, if an event affects a service such as Amazon Elastic Compute Cloud and you have Amazon Web Services accounts that use that service, those account IDs appear in the response.
    ///
    /// * If the eventScopeCode value is NONE, then the eventArn that you specified in the request is invalid or doesn't exist.
    public var eventScopeCode: HealthClientTypes.EventScopeCode?
    /// If the results of a search are large, only a portion of the results are returned, and a nextToken pagination token is returned in the response. To retrieve the next batch of results, reissue the search request and include the returned token. When all results have been returned, the response does not contain a pagination token value.
    public var nextToken: Swift.String?

    public init (
        affectedAccounts: [Swift.String]? = nil,
        eventScopeCode: HealthClientTypes.EventScopeCode? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.affectedAccounts = affectedAccounts
        self.eventScopeCode = eventScopeCode
        self.nextToken = nextToken
    }
}

struct DescribeAffectedAccountsForOrganizationOutputResponseBody: Swift.Equatable {
    let affectedAccounts: [Swift.String]?
    let eventScopeCode: HealthClientTypes.EventScopeCode?
    let nextToken: Swift.String?
}

extension DescribeAffectedAccountsForOrganizationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case affectedAccounts
        case eventScopeCode
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let affectedAccountsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .affectedAccounts)
        var affectedAccountsDecoded0:[Swift.String]? = nil
        if let affectedAccountsContainer = affectedAccountsContainer {
            affectedAccountsDecoded0 = [Swift.String]()
            for string0 in affectedAccountsContainer {
                if let string0 = string0 {
                    affectedAccountsDecoded0?.append(string0)
                }
            }
        }
        affectedAccounts = affectedAccountsDecoded0
        let eventScopeCodeDecoded = try containerValues.decodeIfPresent(HealthClientTypes.EventScopeCode.self, forKey: .eventScopeCode)
        eventScopeCode = eventScopeCodeDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeAffectedEntitiesForOrganizationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case locale
        case maxResults
        case nextToken
        case organizationEntityFilters
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let locale = self.locale {
            try encodeContainer.encode(locale, forKey: .locale)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let organizationEntityFilters = organizationEntityFilters {
            var organizationEntityFiltersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .organizationEntityFilters)
            for eventaccountfilter0 in organizationEntityFilters {
                try organizationEntityFiltersContainer.encode(eventaccountfilter0)
            }
        }
    }
}

extension DescribeAffectedEntitiesForOrganizationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeAffectedEntitiesForOrganizationInput: Swift.Equatable {
    /// The locale (language) to return information in. English (en) is the default and the only supported value at this time.
    public var locale: Swift.String?
    /// The maximum number of items to return in one batch, between 10 and 100, inclusive.
    public var maxResults: Swift.Int?
    /// If the results of a search are large, only a portion of the results are returned, and a nextToken pagination token is returned in the response. To retrieve the next batch of results, reissue the search request and include the returned token. When all results have been returned, the response does not contain a pagination token value.
    public var nextToken: Swift.String?
    /// A JSON set of elements including the awsAccountId and the eventArn.
    /// This member is required.
    public var organizationEntityFilters: [HealthClientTypes.EventAccountFilter]?

    public init (
        locale: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        organizationEntityFilters: [HealthClientTypes.EventAccountFilter]? = nil
    )
    {
        self.locale = locale
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.organizationEntityFilters = organizationEntityFilters
    }
}

struct DescribeAffectedEntitiesForOrganizationInputBody: Swift.Equatable {
    let organizationEntityFilters: [HealthClientTypes.EventAccountFilter]?
    let locale: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension DescribeAffectedEntitiesForOrganizationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case locale
        case maxResults
        case nextToken
        case organizationEntityFilters
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationEntityFiltersContainer = try containerValues.decodeIfPresent([HealthClientTypes.EventAccountFilter?].self, forKey: .organizationEntityFilters)
        var organizationEntityFiltersDecoded0:[HealthClientTypes.EventAccountFilter]? = nil
        if let organizationEntityFiltersContainer = organizationEntityFiltersContainer {
            organizationEntityFiltersDecoded0 = [HealthClientTypes.EventAccountFilter]()
            for structure0 in organizationEntityFiltersContainer {
                if let structure0 = structure0 {
                    organizationEntityFiltersDecoded0?.append(structure0)
                }
            }
        }
        organizationEntityFilters = organizationEntityFiltersDecoded0
        let localeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .locale)
        locale = localeDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension DescribeAffectedEntitiesForOrganizationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeAffectedEntitiesForOrganizationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidPaginationToken" : self = .invalidPaginationToken(try InvalidPaginationToken(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedLocale" : self = .unsupportedLocale(try UnsupportedLocale(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeAffectedEntitiesForOrganizationOutputError: Swift.Error, Swift.Equatable {
    case invalidPaginationToken(InvalidPaginationToken)
    case unsupportedLocale(UnsupportedLocale)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeAffectedEntitiesForOrganizationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeAffectedEntitiesForOrganizationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.entities = output.entities
            self.failedSet = output.failedSet
            self.nextToken = output.nextToken
        } else {
            self.entities = nil
            self.failedSet = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeAffectedEntitiesForOrganizationOutputResponse: Swift.Equatable {
    /// A JSON set of elements including the awsAccountId and its entityArn, entityValue and its entityArn, lastUpdatedTime, and statusCode.
    public var entities: [HealthClientTypes.AffectedEntity]?
    /// A JSON set of elements of the failed response, including the awsAccountId, errorMessage, errorName, and eventArn.
    public var failedSet: [HealthClientTypes.OrganizationAffectedEntitiesErrorItem]?
    /// If the results of a search are large, only a portion of the results are returned, and a nextToken pagination token is returned in the response. To retrieve the next batch of results, reissue the search request and include the returned token. When all results have been returned, the response does not contain a pagination token value.
    public var nextToken: Swift.String?

    public init (
        entities: [HealthClientTypes.AffectedEntity]? = nil,
        failedSet: [HealthClientTypes.OrganizationAffectedEntitiesErrorItem]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.entities = entities
        self.failedSet = failedSet
        self.nextToken = nextToken
    }
}

struct DescribeAffectedEntitiesForOrganizationOutputResponseBody: Swift.Equatable {
    let entities: [HealthClientTypes.AffectedEntity]?
    let failedSet: [HealthClientTypes.OrganizationAffectedEntitiesErrorItem]?
    let nextToken: Swift.String?
}

extension DescribeAffectedEntitiesForOrganizationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entities
        case failedSet
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entitiesContainer = try containerValues.decodeIfPresent([HealthClientTypes.AffectedEntity?].self, forKey: .entities)
        var entitiesDecoded0:[HealthClientTypes.AffectedEntity]? = nil
        if let entitiesContainer = entitiesContainer {
            entitiesDecoded0 = [HealthClientTypes.AffectedEntity]()
            for structure0 in entitiesContainer {
                if let structure0 = structure0 {
                    entitiesDecoded0?.append(structure0)
                }
            }
        }
        entities = entitiesDecoded0
        let failedSetContainer = try containerValues.decodeIfPresent([HealthClientTypes.OrganizationAffectedEntitiesErrorItem?].self, forKey: .failedSet)
        var failedSetDecoded0:[HealthClientTypes.OrganizationAffectedEntitiesErrorItem]? = nil
        if let failedSetContainer = failedSetContainer {
            failedSetDecoded0 = [HealthClientTypes.OrganizationAffectedEntitiesErrorItem]()
            for structure0 in failedSetContainer {
                if let structure0 = structure0 {
                    failedSetDecoded0?.append(structure0)
                }
            }
        }
        failedSet = failedSetDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeAffectedEntitiesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter
        case locale
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filter = self.filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
        if let locale = self.locale {
            try encodeContainer.encode(locale, forKey: .locale)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension DescribeAffectedEntitiesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeAffectedEntitiesInput: Swift.Equatable {
    /// Values to narrow the results returned. At least one event ARN is required.
    /// This member is required.
    public var filter: HealthClientTypes.EntityFilter?
    /// The locale (language) to return information in. English (en) is the default and the only supported value at this time.
    public var locale: Swift.String?
    /// The maximum number of items to return in one batch, between 10 and 100, inclusive.
    public var maxResults: Swift.Int?
    /// If the results of a search are large, only a portion of the results are returned, and a nextToken pagination token is returned in the response. To retrieve the next batch of results, reissue the search request and include the returned token. When all results have been returned, the response does not contain a pagination token value.
    public var nextToken: Swift.String?

    public init (
        filter: HealthClientTypes.EntityFilter? = nil,
        locale: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filter = filter
        self.locale = locale
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeAffectedEntitiesInputBody: Swift.Equatable {
    let filter: HealthClientTypes.EntityFilter?
    let locale: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension DescribeAffectedEntitiesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter
        case locale
        case maxResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filterDecoded = try containerValues.decodeIfPresent(HealthClientTypes.EntityFilter.self, forKey: .filter)
        filter = filterDecoded
        let localeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .locale)
        locale = localeDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension DescribeAffectedEntitiesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeAffectedEntitiesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidPaginationToken" : self = .invalidPaginationToken(try InvalidPaginationToken(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedLocale" : self = .unsupportedLocale(try UnsupportedLocale(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeAffectedEntitiesOutputError: Swift.Error, Swift.Equatable {
    case invalidPaginationToken(InvalidPaginationToken)
    case unsupportedLocale(UnsupportedLocale)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeAffectedEntitiesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeAffectedEntitiesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.entities = output.entities
            self.nextToken = output.nextToken
        } else {
            self.entities = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeAffectedEntitiesOutputResponse: Swift.Equatable {
    /// The entities that match the filter criteria.
    public var entities: [HealthClientTypes.AffectedEntity]?
    /// If the results of a search are large, only a portion of the results are returned, and a nextToken pagination token is returned in the response. To retrieve the next batch of results, reissue the search request and include the returned token. When all results have been returned, the response does not contain a pagination token value.
    public var nextToken: Swift.String?

    public init (
        entities: [HealthClientTypes.AffectedEntity]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.entities = entities
        self.nextToken = nextToken
    }
}

struct DescribeAffectedEntitiesOutputResponseBody: Swift.Equatable {
    let entities: [HealthClientTypes.AffectedEntity]?
    let nextToken: Swift.String?
}

extension DescribeAffectedEntitiesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entities
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entitiesContainer = try containerValues.decodeIfPresent([HealthClientTypes.AffectedEntity?].self, forKey: .entities)
        var entitiesDecoded0:[HealthClientTypes.AffectedEntity]? = nil
        if let entitiesContainer = entitiesContainer {
            entitiesDecoded0 = [HealthClientTypes.AffectedEntity]()
            for structure0 in entitiesContainer {
                if let structure0 = structure0 {
                    entitiesDecoded0?.append(structure0)
                }
            }
        }
        entities = entitiesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeEntityAggregatesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventArns
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eventArns = eventArns {
            var eventArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .eventArns)
            for eventarn0 in eventArns {
                try eventArnsContainer.encode(eventarn0)
            }
        }
    }
}

extension DescribeEntityAggregatesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeEntityAggregatesInput: Swift.Equatable {
    /// A list of event ARNs (unique identifiers). For example: "arn:aws:health:us-east-1::event/EC2/EC2_INSTANCE_RETIREMENT_SCHEDULED/EC2_INSTANCE_RETIREMENT_SCHEDULED_ABC123-CDE456", "arn:aws:health:us-west-1::event/EBS/AWS_EBS_LOST_VOLUME/AWS_EBS_LOST_VOLUME_CHI789_JKL101"
    public var eventArns: [Swift.String]?

    public init (
        eventArns: [Swift.String]? = nil
    )
    {
        self.eventArns = eventArns
    }
}

struct DescribeEntityAggregatesInputBody: Swift.Equatable {
    let eventArns: [Swift.String]?
}

extension DescribeEntityAggregatesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventArns
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .eventArns)
        var eventArnsDecoded0:[Swift.String]? = nil
        if let eventArnsContainer = eventArnsContainer {
            eventArnsDecoded0 = [Swift.String]()
            for string0 in eventArnsContainer {
                if let string0 = string0 {
                    eventArnsDecoded0?.append(string0)
                }
            }
        }
        eventArns = eventArnsDecoded0
    }
}

extension DescribeEntityAggregatesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeEntityAggregatesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeEntityAggregatesOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeEntityAggregatesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeEntityAggregatesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.entityAggregates = output.entityAggregates
        } else {
            self.entityAggregates = nil
        }
    }
}

public struct DescribeEntityAggregatesOutputResponse: Swift.Equatable {
    /// The number of entities that are affected by each of the specified events.
    public var entityAggregates: [HealthClientTypes.EntityAggregate]?

    public init (
        entityAggregates: [HealthClientTypes.EntityAggregate]? = nil
    )
    {
        self.entityAggregates = entityAggregates
    }
}

struct DescribeEntityAggregatesOutputResponseBody: Swift.Equatable {
    let entityAggregates: [HealthClientTypes.EntityAggregate]?
}

extension DescribeEntityAggregatesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entityAggregates
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entityAggregatesContainer = try containerValues.decodeIfPresent([HealthClientTypes.EntityAggregate?].self, forKey: .entityAggregates)
        var entityAggregatesDecoded0:[HealthClientTypes.EntityAggregate]? = nil
        if let entityAggregatesContainer = entityAggregatesContainer {
            entityAggregatesDecoded0 = [HealthClientTypes.EntityAggregate]()
            for structure0 in entityAggregatesContainer {
                if let structure0 = structure0 {
                    entityAggregatesDecoded0?.append(structure0)
                }
            }
        }
        entityAggregates = entityAggregatesDecoded0
    }
}

extension DescribeEventAggregatesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aggregateField
        case filter
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aggregateField = self.aggregateField {
            try encodeContainer.encode(aggregateField.rawValue, forKey: .aggregateField)
        }
        if let filter = self.filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension DescribeEventAggregatesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeEventAggregatesInput: Swift.Equatable {
    /// The only currently supported value is eventTypeCategory.
    /// This member is required.
    public var aggregateField: HealthClientTypes.EventAggregateField?
    /// Values to narrow the results returned.
    public var filter: HealthClientTypes.EventFilter?
    /// The maximum number of items to return in one batch, between 10 and 100, inclusive.
    public var maxResults: Swift.Int?
    /// If the results of a search are large, only a portion of the results are returned, and a nextToken pagination token is returned in the response. To retrieve the next batch of results, reissue the search request and include the returned token. When all results have been returned, the response does not contain a pagination token value.
    public var nextToken: Swift.String?

    public init (
        aggregateField: HealthClientTypes.EventAggregateField? = nil,
        filter: HealthClientTypes.EventFilter? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.aggregateField = aggregateField
        self.filter = filter
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeEventAggregatesInputBody: Swift.Equatable {
    let filter: HealthClientTypes.EventFilter?
    let aggregateField: HealthClientTypes.EventAggregateField?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension DescribeEventAggregatesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aggregateField
        case filter
        case maxResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filterDecoded = try containerValues.decodeIfPresent(HealthClientTypes.EventFilter.self, forKey: .filter)
        filter = filterDecoded
        let aggregateFieldDecoded = try containerValues.decodeIfPresent(HealthClientTypes.EventAggregateField.self, forKey: .aggregateField)
        aggregateField = aggregateFieldDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeEventAggregatesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeEventAggregatesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidPaginationToken" : self = .invalidPaginationToken(try InvalidPaginationToken(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeEventAggregatesOutputError: Swift.Error, Swift.Equatable {
    case invalidPaginationToken(InvalidPaginationToken)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeEventAggregatesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeEventAggregatesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.eventAggregates = output.eventAggregates
            self.nextToken = output.nextToken
        } else {
            self.eventAggregates = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeEventAggregatesOutputResponse: Swift.Equatable {
    /// The number of events in each category that meet the optional filter criteria.
    public var eventAggregates: [HealthClientTypes.EventAggregate]?
    /// If the results of a search are large, only a portion of the results are returned, and a nextToken pagination token is returned in the response. To retrieve the next batch of results, reissue the search request and include the returned token. When all results have been returned, the response does not contain a pagination token value.
    public var nextToken: Swift.String?

    public init (
        eventAggregates: [HealthClientTypes.EventAggregate]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.eventAggregates = eventAggregates
        self.nextToken = nextToken
    }
}

struct DescribeEventAggregatesOutputResponseBody: Swift.Equatable {
    let eventAggregates: [HealthClientTypes.EventAggregate]?
    let nextToken: Swift.String?
}

extension DescribeEventAggregatesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventAggregates
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventAggregatesContainer = try containerValues.decodeIfPresent([HealthClientTypes.EventAggregate?].self, forKey: .eventAggregates)
        var eventAggregatesDecoded0:[HealthClientTypes.EventAggregate]? = nil
        if let eventAggregatesContainer = eventAggregatesContainer {
            eventAggregatesDecoded0 = [HealthClientTypes.EventAggregate]()
            for structure0 in eventAggregatesContainer {
                if let structure0 = structure0 {
                    eventAggregatesDecoded0?.append(structure0)
                }
            }
        }
        eventAggregates = eventAggregatesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeEventDetailsForOrganizationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case locale
        case organizationEventDetailFilters
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let locale = self.locale {
            try encodeContainer.encode(locale, forKey: .locale)
        }
        if let organizationEventDetailFilters = organizationEventDetailFilters {
            var organizationEventDetailFiltersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .organizationEventDetailFilters)
            for eventaccountfilter0 in organizationEventDetailFilters {
                try organizationEventDetailFiltersContainer.encode(eventaccountfilter0)
            }
        }
    }
}

extension DescribeEventDetailsForOrganizationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeEventDetailsForOrganizationInput: Swift.Equatable {
    /// The locale (language) to return information in. English (en) is the default and the only supported value at this time.
    public var locale: Swift.String?
    /// A set of JSON elements that includes the awsAccountId and the eventArn.
    /// This member is required.
    public var organizationEventDetailFilters: [HealthClientTypes.EventAccountFilter]?

    public init (
        locale: Swift.String? = nil,
        organizationEventDetailFilters: [HealthClientTypes.EventAccountFilter]? = nil
    )
    {
        self.locale = locale
        self.organizationEventDetailFilters = organizationEventDetailFilters
    }
}

struct DescribeEventDetailsForOrganizationInputBody: Swift.Equatable {
    let organizationEventDetailFilters: [HealthClientTypes.EventAccountFilter]?
    let locale: Swift.String?
}

extension DescribeEventDetailsForOrganizationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case locale
        case organizationEventDetailFilters
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationEventDetailFiltersContainer = try containerValues.decodeIfPresent([HealthClientTypes.EventAccountFilter?].self, forKey: .organizationEventDetailFilters)
        var organizationEventDetailFiltersDecoded0:[HealthClientTypes.EventAccountFilter]? = nil
        if let organizationEventDetailFiltersContainer = organizationEventDetailFiltersContainer {
            organizationEventDetailFiltersDecoded0 = [HealthClientTypes.EventAccountFilter]()
            for structure0 in organizationEventDetailFiltersContainer {
                if let structure0 = structure0 {
                    organizationEventDetailFiltersDecoded0?.append(structure0)
                }
            }
        }
        organizationEventDetailFilters = organizationEventDetailFiltersDecoded0
        let localeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .locale)
        locale = localeDecoded
    }
}

extension DescribeEventDetailsForOrganizationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeEventDetailsForOrganizationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "UnsupportedLocale" : self = .unsupportedLocale(try UnsupportedLocale(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeEventDetailsForOrganizationOutputError: Swift.Error, Swift.Equatable {
    case unsupportedLocale(UnsupportedLocale)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeEventDetailsForOrganizationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeEventDetailsForOrganizationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.failedSet = output.failedSet
            self.successfulSet = output.successfulSet
        } else {
            self.failedSet = nil
            self.successfulSet = nil
        }
    }
}

public struct DescribeEventDetailsForOrganizationOutputResponse: Swift.Equatable {
    /// Error messages for any events that could not be retrieved.
    public var failedSet: [HealthClientTypes.OrganizationEventDetailsErrorItem]?
    /// Information about the events that could be retrieved.
    public var successfulSet: [HealthClientTypes.OrganizationEventDetails]?

    public init (
        failedSet: [HealthClientTypes.OrganizationEventDetailsErrorItem]? = nil,
        successfulSet: [HealthClientTypes.OrganizationEventDetails]? = nil
    )
    {
        self.failedSet = failedSet
        self.successfulSet = successfulSet
    }
}

struct DescribeEventDetailsForOrganizationOutputResponseBody: Swift.Equatable {
    let successfulSet: [HealthClientTypes.OrganizationEventDetails]?
    let failedSet: [HealthClientTypes.OrganizationEventDetailsErrorItem]?
}

extension DescribeEventDetailsForOrganizationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failedSet
        case successfulSet
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let successfulSetContainer = try containerValues.decodeIfPresent([HealthClientTypes.OrganizationEventDetails?].self, forKey: .successfulSet)
        var successfulSetDecoded0:[HealthClientTypes.OrganizationEventDetails]? = nil
        if let successfulSetContainer = successfulSetContainer {
            successfulSetDecoded0 = [HealthClientTypes.OrganizationEventDetails]()
            for structure0 in successfulSetContainer {
                if let structure0 = structure0 {
                    successfulSetDecoded0?.append(structure0)
                }
            }
        }
        successfulSet = successfulSetDecoded0
        let failedSetContainer = try containerValues.decodeIfPresent([HealthClientTypes.OrganizationEventDetailsErrorItem?].self, forKey: .failedSet)
        var failedSetDecoded0:[HealthClientTypes.OrganizationEventDetailsErrorItem]? = nil
        if let failedSetContainer = failedSetContainer {
            failedSetDecoded0 = [HealthClientTypes.OrganizationEventDetailsErrorItem]()
            for structure0 in failedSetContainer {
                if let structure0 = structure0 {
                    failedSetDecoded0?.append(structure0)
                }
            }
        }
        failedSet = failedSetDecoded0
    }
}

extension DescribeEventDetailsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventArns
        case locale
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eventArns = eventArns {
            var eventArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .eventArns)
            for eventarn0 in eventArns {
                try eventArnsContainer.encode(eventarn0)
            }
        }
        if let locale = self.locale {
            try encodeContainer.encode(locale, forKey: .locale)
        }
    }
}

extension DescribeEventDetailsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeEventDetailsInput: Swift.Equatable {
    /// A list of event ARNs (unique identifiers). For example: "arn:aws:health:us-east-1::event/EC2/EC2_INSTANCE_RETIREMENT_SCHEDULED/EC2_INSTANCE_RETIREMENT_SCHEDULED_ABC123-CDE456", "arn:aws:health:us-west-1::event/EBS/AWS_EBS_LOST_VOLUME/AWS_EBS_LOST_VOLUME_CHI789_JKL101"
    /// This member is required.
    public var eventArns: [Swift.String]?
    /// The locale (language) to return information in. English (en) is the default and the only supported value at this time.
    public var locale: Swift.String?

    public init (
        eventArns: [Swift.String]? = nil,
        locale: Swift.String? = nil
    )
    {
        self.eventArns = eventArns
        self.locale = locale
    }
}

struct DescribeEventDetailsInputBody: Swift.Equatable {
    let eventArns: [Swift.String]?
    let locale: Swift.String?
}

extension DescribeEventDetailsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventArns
        case locale
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .eventArns)
        var eventArnsDecoded0:[Swift.String]? = nil
        if let eventArnsContainer = eventArnsContainer {
            eventArnsDecoded0 = [Swift.String]()
            for string0 in eventArnsContainer {
                if let string0 = string0 {
                    eventArnsDecoded0?.append(string0)
                }
            }
        }
        eventArns = eventArnsDecoded0
        let localeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .locale)
        locale = localeDecoded
    }
}

extension DescribeEventDetailsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeEventDetailsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "UnsupportedLocale" : self = .unsupportedLocale(try UnsupportedLocale(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeEventDetailsOutputError: Swift.Error, Swift.Equatable {
    case unsupportedLocale(UnsupportedLocale)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeEventDetailsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeEventDetailsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.failedSet = output.failedSet
            self.successfulSet = output.successfulSet
        } else {
            self.failedSet = nil
            self.successfulSet = nil
        }
    }
}

public struct DescribeEventDetailsOutputResponse: Swift.Equatable {
    /// Error messages for any events that could not be retrieved.
    public var failedSet: [HealthClientTypes.EventDetailsErrorItem]?
    /// Information about the events that could be retrieved.
    public var successfulSet: [HealthClientTypes.EventDetails]?

    public init (
        failedSet: [HealthClientTypes.EventDetailsErrorItem]? = nil,
        successfulSet: [HealthClientTypes.EventDetails]? = nil
    )
    {
        self.failedSet = failedSet
        self.successfulSet = successfulSet
    }
}

struct DescribeEventDetailsOutputResponseBody: Swift.Equatable {
    let successfulSet: [HealthClientTypes.EventDetails]?
    let failedSet: [HealthClientTypes.EventDetailsErrorItem]?
}

extension DescribeEventDetailsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failedSet
        case successfulSet
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let successfulSetContainer = try containerValues.decodeIfPresent([HealthClientTypes.EventDetails?].self, forKey: .successfulSet)
        var successfulSetDecoded0:[HealthClientTypes.EventDetails]? = nil
        if let successfulSetContainer = successfulSetContainer {
            successfulSetDecoded0 = [HealthClientTypes.EventDetails]()
            for structure0 in successfulSetContainer {
                if let structure0 = structure0 {
                    successfulSetDecoded0?.append(structure0)
                }
            }
        }
        successfulSet = successfulSetDecoded0
        let failedSetContainer = try containerValues.decodeIfPresent([HealthClientTypes.EventDetailsErrorItem?].self, forKey: .failedSet)
        var failedSetDecoded0:[HealthClientTypes.EventDetailsErrorItem]? = nil
        if let failedSetContainer = failedSetContainer {
            failedSetDecoded0 = [HealthClientTypes.EventDetailsErrorItem]()
            for structure0 in failedSetContainer {
                if let structure0 = structure0 {
                    failedSetDecoded0?.append(structure0)
                }
            }
        }
        failedSet = failedSetDecoded0
    }
}

extension DescribeEventTypesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter
        case locale
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filter = self.filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
        if let locale = self.locale {
            try encodeContainer.encode(locale, forKey: .locale)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension DescribeEventTypesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeEventTypesInput: Swift.Equatable {
    /// Values to narrow the results returned.
    public var filter: HealthClientTypes.EventTypeFilter?
    /// The locale (language) to return information in. English (en) is the default and the only supported value at this time.
    public var locale: Swift.String?
    /// The maximum number of items to return in one batch, between 10 and 100, inclusive.
    public var maxResults: Swift.Int?
    /// If the results of a search are large, only a portion of the results are returned, and a nextToken pagination token is returned in the response. To retrieve the next batch of results, reissue the search request and include the returned token. When all results have been returned, the response does not contain a pagination token value.
    public var nextToken: Swift.String?

    public init (
        filter: HealthClientTypes.EventTypeFilter? = nil,
        locale: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filter = filter
        self.locale = locale
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeEventTypesInputBody: Swift.Equatable {
    let filter: HealthClientTypes.EventTypeFilter?
    let locale: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension DescribeEventTypesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter
        case locale
        case maxResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filterDecoded = try containerValues.decodeIfPresent(HealthClientTypes.EventTypeFilter.self, forKey: .filter)
        filter = filterDecoded
        let localeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .locale)
        locale = localeDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension DescribeEventTypesOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeEventTypesOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidPaginationToken" : self = .invalidPaginationToken(try InvalidPaginationToken(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedLocale" : self = .unsupportedLocale(try UnsupportedLocale(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeEventTypesOutputError: Swift.Error, Swift.Equatable {
    case invalidPaginationToken(InvalidPaginationToken)
    case unsupportedLocale(UnsupportedLocale)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeEventTypesOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeEventTypesOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.eventTypes = output.eventTypes
            self.nextToken = output.nextToken
        } else {
            self.eventTypes = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeEventTypesOutputResponse: Swift.Equatable {
    /// A list of event types that match the filter criteria. Event types have a category (issue, accountNotification, or scheduledChange), a service (for example, EC2, RDS, DATAPIPELINE, BILLING), and a code (in the format AWS_SERVICE_DESCRIPTION ; for example, AWS_EC2_SYSTEM_MAINTENANCE_EVENT).
    public var eventTypes: [HealthClientTypes.EventType]?
    /// If the results of a search are large, only a portion of the results are returned, and a nextToken pagination token is returned in the response. To retrieve the next batch of results, reissue the search request and include the returned token. When all results have been returned, the response does not contain a pagination token value.
    public var nextToken: Swift.String?

    public init (
        eventTypes: [HealthClientTypes.EventType]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.eventTypes = eventTypes
        self.nextToken = nextToken
    }
}

struct DescribeEventTypesOutputResponseBody: Swift.Equatable {
    let eventTypes: [HealthClientTypes.EventType]?
    let nextToken: Swift.String?
}

extension DescribeEventTypesOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventTypes
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventTypesContainer = try containerValues.decodeIfPresent([HealthClientTypes.EventType?].self, forKey: .eventTypes)
        var eventTypesDecoded0:[HealthClientTypes.EventType]? = nil
        if let eventTypesContainer = eventTypesContainer {
            eventTypesDecoded0 = [HealthClientTypes.EventType]()
            for structure0 in eventTypesContainer {
                if let structure0 = structure0 {
                    eventTypesDecoded0?.append(structure0)
                }
            }
        }
        eventTypes = eventTypesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeEventsForOrganizationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter
        case locale
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filter = self.filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
        if let locale = self.locale {
            try encodeContainer.encode(locale, forKey: .locale)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension DescribeEventsForOrganizationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeEventsForOrganizationInput: Swift.Equatable {
    /// Values to narrow the results returned.
    public var filter: HealthClientTypes.OrganizationEventFilter?
    /// The locale (language) to return information in. English (en) is the default and the only supported value at this time.
    public var locale: Swift.String?
    /// The maximum number of items to return in one batch, between 10 and 100, inclusive.
    public var maxResults: Swift.Int?
    /// If the results of a search are large, only a portion of the results are returned, and a nextToken pagination token is returned in the response. To retrieve the next batch of results, reissue the search request and include the returned token. When all results have been returned, the response does not contain a pagination token value.
    public var nextToken: Swift.String?

    public init (
        filter: HealthClientTypes.OrganizationEventFilter? = nil,
        locale: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filter = filter
        self.locale = locale
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeEventsForOrganizationInputBody: Swift.Equatable {
    let filter: HealthClientTypes.OrganizationEventFilter?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
    let locale: Swift.String?
}

extension DescribeEventsForOrganizationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter
        case locale
        case maxResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filterDecoded = try containerValues.decodeIfPresent(HealthClientTypes.OrganizationEventFilter.self, forKey: .filter)
        filter = filterDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let localeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .locale)
        locale = localeDecoded
    }
}

extension DescribeEventsForOrganizationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeEventsForOrganizationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidPaginationToken" : self = .invalidPaginationToken(try InvalidPaginationToken(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedLocale" : self = .unsupportedLocale(try UnsupportedLocale(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeEventsForOrganizationOutputError: Swift.Error, Swift.Equatable {
    case invalidPaginationToken(InvalidPaginationToken)
    case unsupportedLocale(UnsupportedLocale)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeEventsForOrganizationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeEventsForOrganizationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.events = output.events
            self.nextToken = output.nextToken
        } else {
            self.events = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeEventsForOrganizationOutputResponse: Swift.Equatable {
    /// The events that match the specified filter criteria.
    public var events: [HealthClientTypes.OrganizationEvent]?
    /// If the results of a search are large, only a portion of the results are returned, and a nextToken pagination token is returned in the response. To retrieve the next batch of results, reissue the search request and include the returned token. When all results have been returned, the response does not contain a pagination token value.
    public var nextToken: Swift.String?

    public init (
        events: [HealthClientTypes.OrganizationEvent]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.events = events
        self.nextToken = nextToken
    }
}

struct DescribeEventsForOrganizationOutputResponseBody: Swift.Equatable {
    let events: [HealthClientTypes.OrganizationEvent]?
    let nextToken: Swift.String?
}

extension DescribeEventsForOrganizationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case events
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventsContainer = try containerValues.decodeIfPresent([HealthClientTypes.OrganizationEvent?].self, forKey: .events)
        var eventsDecoded0:[HealthClientTypes.OrganizationEvent]? = nil
        if let eventsContainer = eventsContainer {
            eventsDecoded0 = [HealthClientTypes.OrganizationEvent]()
            for structure0 in eventsContainer {
                if let structure0 = structure0 {
                    eventsDecoded0?.append(structure0)
                }
            }
        }
        events = eventsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeEventsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter
        case locale
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filter = self.filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
        if let locale = self.locale {
            try encodeContainer.encode(locale, forKey: .locale)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension DescribeEventsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeEventsInput: Swift.Equatable {
    /// Values to narrow the results returned.
    public var filter: HealthClientTypes.EventFilter?
    /// The locale (language) to return information in. English (en) is the default and the only supported value at this time.
    public var locale: Swift.String?
    /// The maximum number of items to return in one batch, between 10 and 100, inclusive.
    public var maxResults: Swift.Int?
    /// If the results of a search are large, only a portion of the results are returned, and a nextToken pagination token is returned in the response. To retrieve the next batch of results, reissue the search request and include the returned token. When all results have been returned, the response does not contain a pagination token value.
    public var nextToken: Swift.String?

    public init (
        filter: HealthClientTypes.EventFilter? = nil,
        locale: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filter = filter
        self.locale = locale
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeEventsInputBody: Swift.Equatable {
    let filter: HealthClientTypes.EventFilter?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
    let locale: Swift.String?
}

extension DescribeEventsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter
        case locale
        case maxResults
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filterDecoded = try containerValues.decodeIfPresent(HealthClientTypes.EventFilter.self, forKey: .filter)
        filter = filterDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let localeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .locale)
        locale = localeDecoded
    }
}

extension DescribeEventsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeEventsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "InvalidPaginationToken" : self = .invalidPaginationToken(try InvalidPaginationToken(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "UnsupportedLocale" : self = .unsupportedLocale(try UnsupportedLocale(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeEventsOutputError: Swift.Error, Swift.Equatable {
    case invalidPaginationToken(InvalidPaginationToken)
    case unsupportedLocale(UnsupportedLocale)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeEventsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeEventsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.events = output.events
            self.nextToken = output.nextToken
        } else {
            self.events = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeEventsOutputResponse: Swift.Equatable {
    /// The events that match the specified filter criteria.
    public var events: [HealthClientTypes.Event]?
    /// If the results of a search are large, only a portion of the results are returned, and a nextToken pagination token is returned in the response. To retrieve the next batch of results, reissue the search request and include the returned token. When all results have been returned, the response does not contain a pagination token value.
    public var nextToken: Swift.String?

    public init (
        events: [HealthClientTypes.Event]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.events = events
        self.nextToken = nextToken
    }
}

struct DescribeEventsOutputResponseBody: Swift.Equatable {
    let events: [HealthClientTypes.Event]?
    let nextToken: Swift.String?
}

extension DescribeEventsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case events
        case nextToken
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventsContainer = try containerValues.decodeIfPresent([HealthClientTypes.Event?].self, forKey: .events)
        var eventsDecoded0:[HealthClientTypes.Event]? = nil
        if let eventsContainer = eventsContainer {
            eventsDecoded0 = [HealthClientTypes.Event]()
            for structure0 in eventsContainer {
                if let structure0 = structure0 {
                    eventsDecoded0?.append(structure0)
                }
            }
        }
        events = eventsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeHealthServiceStatusForOrganizationInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension DescribeHealthServiceStatusForOrganizationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeHealthServiceStatusForOrganizationInput: Swift.Equatable {

    public init () { }
}

struct DescribeHealthServiceStatusForOrganizationInputBody: Swift.Equatable {
}

extension DescribeHealthServiceStatusForOrganizationInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeHealthServiceStatusForOrganizationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeHealthServiceStatusForOrganizationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeHealthServiceStatusForOrganizationOutputError: Swift.Error, Swift.Equatable {
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeHealthServiceStatusForOrganizationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeHealthServiceStatusForOrganizationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.healthServiceAccessStatusForOrganization = output.healthServiceAccessStatusForOrganization
        } else {
            self.healthServiceAccessStatusForOrganization = nil
        }
    }
}

public struct DescribeHealthServiceStatusForOrganizationOutputResponse: Swift.Equatable {
    /// Information about the status of enabling or disabling the Health organizational view feature in your organization. Valid values are ENABLED | DISABLED | PENDING.
    public var healthServiceAccessStatusForOrganization: Swift.String?

    public init (
        healthServiceAccessStatusForOrganization: Swift.String? = nil
    )
    {
        self.healthServiceAccessStatusForOrganization = healthServiceAccessStatusForOrganization
    }
}

struct DescribeHealthServiceStatusForOrganizationOutputResponseBody: Swift.Equatable {
    let healthServiceAccessStatusForOrganization: Swift.String?
}

extension DescribeHealthServiceStatusForOrganizationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case healthServiceAccessStatusForOrganization
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let healthServiceAccessStatusForOrganizationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .healthServiceAccessStatusForOrganization)
        healthServiceAccessStatusForOrganization = healthServiceAccessStatusForOrganizationDecoded
    }
}

extension DisableHealthServiceAccessForOrganizationInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension DisableHealthServiceAccessForOrganizationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DisableHealthServiceAccessForOrganizationInput: Swift.Equatable {

    public init () { }
}

struct DisableHealthServiceAccessForOrganizationInputBody: Swift.Equatable {
}

extension DisableHealthServiceAccessForOrganizationInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DisableHealthServiceAccessForOrganizationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisableHealthServiceAccessForOrganizationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DisableHealthServiceAccessForOrganizationOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisableHealthServiceAccessForOrganizationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DisableHealthServiceAccessForOrganizationOutputResponse: Swift.Equatable {

    public init () { }
}

extension EnableHealthServiceAccessForOrganizationInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension EnableHealthServiceAccessForOrganizationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct EnableHealthServiceAccessForOrganizationInput: Swift.Equatable {

    public init () { }
}

struct EnableHealthServiceAccessForOrganizationInputBody: Swift.Equatable {
}

extension EnableHealthServiceAccessForOrganizationInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension EnableHealthServiceAccessForOrganizationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension EnableHealthServiceAccessForOrganizationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "ConcurrentModificationException" : self = .concurrentModificationException(try ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum EnableHealthServiceAccessForOrganizationOutputError: Swift.Error, Swift.Equatable {
    case concurrentModificationException(ConcurrentModificationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension EnableHealthServiceAccessForOrganizationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct EnableHealthServiceAccessForOrganizationOutputResponse: Swift.Equatable {

    public init () { }
}

extension HealthClientTypes.EntityAggregate: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case count
        case eventArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if count != 0 {
            try encodeContainer.encode(count, forKey: .count)
        }
        if let eventArn = self.eventArn {
            try encodeContainer.encode(eventArn, forKey: .eventArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventArn)
        eventArn = eventArnDecoded
        let countDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .count) ?? 0
        count = countDecoded
    }
}

extension HealthClientTypes {
    /// The number of entities that are affected by one or more events. Returned by the [DescribeEntityAggregates](https://docs.aws.amazon.com/health/latest/APIReference/API_DescribeEntityAggregates.html) operation.
    public struct EntityAggregate: Swift.Equatable {
        /// The number of entities that match the criteria for the specified events.
        public var count: Swift.Int
        /// The unique identifier for the event. The event ARN has the arn:aws:health:event-region::event/SERVICE/EVENT_TYPE_CODE/EVENT_TYPE_PLUS_ID  format. For example, an event ARN might look like the following: arn:aws:health:us-east-1::event/EC2/EC2_INSTANCE_RETIREMENT_SCHEDULED/EC2_INSTANCE_RETIREMENT_SCHEDULED_ABC123-DEF456
        public var eventArn: Swift.String?

        public init (
            count: Swift.Int = 0,
            eventArn: Swift.String? = nil
        )
        {
            self.count = count
            self.eventArn = eventArn
        }
    }

}

extension HealthClientTypes.EntityFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entityArns
        case entityValues
        case eventArns
        case lastUpdatedTimes
        case statusCodes
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let entityArns = entityArns {
            var entityArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .entityArns)
            for entityarn0 in entityArns {
                try entityArnsContainer.encode(entityarn0)
            }
        }
        if let entityValues = entityValues {
            var entityValuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .entityValues)
            for entityvalue0 in entityValues {
                try entityValuesContainer.encode(entityvalue0)
            }
        }
        if let eventArns = eventArns {
            var eventArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .eventArns)
            for eventarn0 in eventArns {
                try eventArnsContainer.encode(eventarn0)
            }
        }
        if let lastUpdatedTimes = lastUpdatedTimes {
            var lastUpdatedTimesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .lastUpdatedTimes)
            for datetimerange0 in lastUpdatedTimes {
                try lastUpdatedTimesContainer.encode(datetimerange0)
            }
        }
        if let statusCodes = statusCodes {
            var statusCodesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .statusCodes)
            for entitystatuscode0 in statusCodes {
                try statusCodesContainer.encode(entitystatuscode0.rawValue)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tagset0 in tags {
                var tagset0Container = tagsContainer.nestedContainer(keyedBy: ClientRuntime.Key.self)
                for (dictKey1, tagSet1) in tagset0 {
                    try tagset0Container.encode(tagSet1, forKey: ClientRuntime.Key(stringValue: dictKey1))
                }
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .eventArns)
        var eventArnsDecoded0:[Swift.String]? = nil
        if let eventArnsContainer = eventArnsContainer {
            eventArnsDecoded0 = [Swift.String]()
            for string0 in eventArnsContainer {
                if let string0 = string0 {
                    eventArnsDecoded0?.append(string0)
                }
            }
        }
        eventArns = eventArnsDecoded0
        let entityArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .entityArns)
        var entityArnsDecoded0:[Swift.String]? = nil
        if let entityArnsContainer = entityArnsContainer {
            entityArnsDecoded0 = [Swift.String]()
            for string0 in entityArnsContainer {
                if let string0 = string0 {
                    entityArnsDecoded0?.append(string0)
                }
            }
        }
        entityArns = entityArnsDecoded0
        let entityValuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .entityValues)
        var entityValuesDecoded0:[Swift.String]? = nil
        if let entityValuesContainer = entityValuesContainer {
            entityValuesDecoded0 = [Swift.String]()
            for string0 in entityValuesContainer {
                if let string0 = string0 {
                    entityValuesDecoded0?.append(string0)
                }
            }
        }
        entityValues = entityValuesDecoded0
        let lastUpdatedTimesContainer = try containerValues.decodeIfPresent([HealthClientTypes.DateTimeRange?].self, forKey: .lastUpdatedTimes)
        var lastUpdatedTimesDecoded0:[HealthClientTypes.DateTimeRange]? = nil
        if let lastUpdatedTimesContainer = lastUpdatedTimesContainer {
            lastUpdatedTimesDecoded0 = [HealthClientTypes.DateTimeRange]()
            for structure0 in lastUpdatedTimesContainer {
                if let structure0 = structure0 {
                    lastUpdatedTimesDecoded0?.append(structure0)
                }
            }
        }
        lastUpdatedTimes = lastUpdatedTimesDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([[Swift.String: Swift.String?]?].self, forKey: .tags)
        var tagsDecoded0:[[Swift.String:Swift.String]]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [[Swift.String:Swift.String]]()
            for map0 in tagsContainer {
                var tagsContainerDecoded0: [Swift.String: Swift.String]? = nil
                if let map0 = map0 {
                    tagsContainerDecoded0 = [Swift.String: Swift.String]()
                    for (key1, tagvalue1) in map0 {
                        if let tagvalue1 = tagvalue1 {
                            tagsContainerDecoded0?[key1] = tagvalue1
                        }
                    }
                }
                if let tagsContainerDecoded0 = tagsContainerDecoded0 {
                    tagsDecoded0?.append(tagsContainerDecoded0)
                }
            }
        }
        tags = tagsDecoded0
        let statusCodesContainer = try containerValues.decodeIfPresent([HealthClientTypes.EntityStatusCode?].self, forKey: .statusCodes)
        var statusCodesDecoded0:[HealthClientTypes.EntityStatusCode]? = nil
        if let statusCodesContainer = statusCodesContainer {
            statusCodesDecoded0 = [HealthClientTypes.EntityStatusCode]()
            for string0 in statusCodesContainer {
                if let string0 = string0 {
                    statusCodesDecoded0?.append(string0)
                }
            }
        }
        statusCodes = statusCodesDecoded0
    }
}

extension HealthClientTypes {
    /// The values to use to filter results from the [DescribeAffectedEntities](https://docs.aws.amazon.com/health/latest/APIReference/API_DescribeAffectedEntities.html) operation.
    public struct EntityFilter: Swift.Equatable {
        /// A list of entity ARNs (unique identifiers).
        public var entityArns: [Swift.String]?
        /// A list of IDs for affected entities.
        public var entityValues: [Swift.String]?
        /// A list of event ARNs (unique identifiers). For example: "arn:aws:health:us-east-1::event/EC2/EC2_INSTANCE_RETIREMENT_SCHEDULED/EC2_INSTANCE_RETIREMENT_SCHEDULED_ABC123-CDE456", "arn:aws:health:us-west-1::event/EBS/AWS_EBS_LOST_VOLUME/AWS_EBS_LOST_VOLUME_CHI789_JKL101"
        /// This member is required.
        public var eventArns: [Swift.String]?
        /// A list of the most recent dates and times that the entity was updated.
        public var lastUpdatedTimes: [HealthClientTypes.DateTimeRange]?
        /// A list of entity status codes (IMPAIRED, UNIMPAIRED, or UNKNOWN).
        public var statusCodes: [HealthClientTypes.EntityStatusCode]?
        /// A map of entity tags attached to the affected entity. Currently, the tags property isn't supported.
        public var tags: [[Swift.String:Swift.String]]?

        public init (
            entityArns: [Swift.String]? = nil,
            entityValues: [Swift.String]? = nil,
            eventArns: [Swift.String]? = nil,
            lastUpdatedTimes: [HealthClientTypes.DateTimeRange]? = nil,
            statusCodes: [HealthClientTypes.EntityStatusCode]? = nil,
            tags: [[Swift.String:Swift.String]]? = nil
        )
        {
            self.entityArns = entityArns
            self.entityValues = entityValues
            self.eventArns = eventArns
            self.lastUpdatedTimes = lastUpdatedTimes
            self.statusCodes = statusCodes
            self.tags = tags
        }
    }

}

extension HealthClientTypes {
    public enum EntityStatusCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case impaired
        case unimpaired
        case unknown
        case sdkUnknown(Swift.String)

        public static var allCases: [EntityStatusCode] {
            return [
                .impaired,
                .unimpaired,
                .unknown,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .impaired: return "IMPAIRED"
            case .unimpaired: return "UNIMPAIRED"
            case .unknown: return "UNKNOWN"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EntityStatusCode(rawValue: rawValue) ?? EntityStatusCode.sdkUnknown(rawValue)
        }
    }
}

extension HealthClientTypes.Event: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case availabilityZone
        case endTime
        case eventScopeCode
        case eventTypeCategory
        case eventTypeCode
        case lastUpdatedTime
        case region
        case service
        case startTime
        case statusCode
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let availabilityZone = self.availabilityZone {
            try encodeContainer.encode(availabilityZone, forKey: .availabilityZone)
        }
        if let endTime = self.endTime {
            try encodeContainer.encodeTimestamp(endTime, format: .epochSeconds, forKey: .endTime)
        }
        if let eventScopeCode = self.eventScopeCode {
            try encodeContainer.encode(eventScopeCode.rawValue, forKey: .eventScopeCode)
        }
        if let eventTypeCategory = self.eventTypeCategory {
            try encodeContainer.encode(eventTypeCategory.rawValue, forKey: .eventTypeCategory)
        }
        if let eventTypeCode = self.eventTypeCode {
            try encodeContainer.encode(eventTypeCode, forKey: .eventTypeCode)
        }
        if let lastUpdatedTime = self.lastUpdatedTime {
            try encodeContainer.encodeTimestamp(lastUpdatedTime, format: .epochSeconds, forKey: .lastUpdatedTime)
        }
        if let region = self.region {
            try encodeContainer.encode(region, forKey: .region)
        }
        if let service = self.service {
            try encodeContainer.encode(service, forKey: .service)
        }
        if let startTime = self.startTime {
            try encodeContainer.encodeTimestamp(startTime, format: .epochSeconds, forKey: .startTime)
        }
        if let statusCode = self.statusCode {
            try encodeContainer.encode(statusCode.rawValue, forKey: .statusCode)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let serviceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .service)
        service = serviceDecoded
        let eventTypeCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventTypeCode)
        eventTypeCode = eventTypeCodeDecoded
        let eventTypeCategoryDecoded = try containerValues.decodeIfPresent(HealthClientTypes.EventTypeCategory.self, forKey: .eventTypeCategory)
        eventTypeCategory = eventTypeCategoryDecoded
        let regionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .region)
        region = regionDecoded
        let availabilityZoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .availabilityZone)
        availabilityZone = availabilityZoneDecoded
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endTime)
        endTime = endTimeDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
        let statusCodeDecoded = try containerValues.decodeIfPresent(HealthClientTypes.EventStatusCode.self, forKey: .statusCode)
        statusCode = statusCodeDecoded
        let eventScopeCodeDecoded = try containerValues.decodeIfPresent(HealthClientTypes.EventScopeCode.self, forKey: .eventScopeCode)
        eventScopeCode = eventScopeCodeDecoded
    }
}

extension HealthClientTypes {
    /// Summary information about an Health event. Health events can be public or account-specific:
    ///
    /// * Public events might be service events that are not specific to an Amazon Web Services account. For example, if there is an issue with an Amazon Web Services Region, Health provides information about the event, even if you don't use services or resources in that Region.
    ///
    /// * Account-specific events are specific to either your Amazon Web Services account or an account in your organization. For example, if there's an issue with Amazon Elastic Compute Cloud in a Region that you use, Health provides information about the event and the affected resources in the account.
    ///
    ///
    /// You can determine if an event is public or account-specific by using the eventScopeCode parameter. For more information, see [eventScopeCode](https://docs.aws.amazon.com/health/latest/APIReference/API_Event.html#AWSHealth-Type-Event-eventScopeCode).
    public struct Event: Swift.Equatable {
        /// The unique identifier for the event. The event ARN has the arn:aws:health:event-region::event/SERVICE/EVENT_TYPE_CODE/EVENT_TYPE_PLUS_ID  format. For example, an event ARN might look like the following: arn:aws:health:us-east-1::event/EC2/EC2_INSTANCE_RETIREMENT_SCHEDULED/EC2_INSTANCE_RETIREMENT_SCHEDULED_ABC123-DEF456
        public var arn: Swift.String?
        /// The Amazon Web Services Availability Zone of the event. For example, us-east-1a.
        public var availabilityZone: Swift.String?
        /// The date and time that the event ended.
        public var endTime: ClientRuntime.Date?
        /// This parameter specifies if the Health event is a public Amazon Web Services service event or an account-specific event.
        ///
        /// * If the eventScopeCode value is PUBLIC, then the affectedAccounts value is always empty.
        ///
        /// * If the eventScopeCode value is ACCOUNT_SPECIFIC, then the affectedAccounts value lists the affected Amazon Web Services accounts in your organization. For example, if an event affects a service such as Amazon Elastic Compute Cloud and you have Amazon Web Services accounts that use that service, those account IDs appear in the response.
        ///
        /// * If the eventScopeCode value is NONE, then the eventArn that you specified in the request is invalid or doesn't exist.
        public var eventScopeCode: HealthClientTypes.EventScopeCode?
        /// A list of event type category codes. Possible values are issue, accountNotification, or scheduledChange. Currently, the investigation value isn't supported at this time.
        public var eventTypeCategory: HealthClientTypes.EventTypeCategory?
        /// The unique identifier for the event type. The format is AWS_SERVICE_DESCRIPTION ; for example, AWS_EC2_SYSTEM_MAINTENANCE_EVENT.
        public var eventTypeCode: Swift.String?
        /// The most recent date and time that the event was updated.
        public var lastUpdatedTime: ClientRuntime.Date?
        /// The Amazon Web Services Region name of the event.
        public var region: Swift.String?
        /// The Amazon Web Services service that is affected by the event. For example, EC2, RDS.
        public var service: Swift.String?
        /// The date and time that the event began.
        public var startTime: ClientRuntime.Date?
        /// The most recent status of the event. Possible values are open, closed, and upcoming.
        public var statusCode: HealthClientTypes.EventStatusCode?

        public init (
            arn: Swift.String? = nil,
            availabilityZone: Swift.String? = nil,
            endTime: ClientRuntime.Date? = nil,
            eventScopeCode: HealthClientTypes.EventScopeCode? = nil,
            eventTypeCategory: HealthClientTypes.EventTypeCategory? = nil,
            eventTypeCode: Swift.String? = nil,
            lastUpdatedTime: ClientRuntime.Date? = nil,
            region: Swift.String? = nil,
            service: Swift.String? = nil,
            startTime: ClientRuntime.Date? = nil,
            statusCode: HealthClientTypes.EventStatusCode? = nil
        )
        {
            self.arn = arn
            self.availabilityZone = availabilityZone
            self.endTime = endTime
            self.eventScopeCode = eventScopeCode
            self.eventTypeCategory = eventTypeCategory
            self.eventTypeCode = eventTypeCode
            self.lastUpdatedTime = lastUpdatedTime
            self.region = region
            self.service = service
            self.startTime = startTime
            self.statusCode = statusCode
        }
    }

}

extension HealthClientTypes.EventAccountFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsAccountId
        case eventArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let awsAccountId = self.awsAccountId {
            try encodeContainer.encode(awsAccountId, forKey: .awsAccountId)
        }
        if let eventArn = self.eventArn {
            try encodeContainer.encode(eventArn, forKey: .eventArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventArn)
        eventArn = eventArnDecoded
        let awsAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsAccountId)
        awsAccountId = awsAccountIdDecoded
    }
}

extension HealthClientTypes {
    /// The values used to filter results from the [DescribeEventDetailsForOrganization](https://docs.aws.amazon.com/health/latest/APIReference/API_DescribeEventDetailsForOrganization.html) and [DescribeAffectedEntitiesForOrganization](https://docs.aws.amazon.com/health/latest/APIReference/API_DescribeAffectedEntitiesForOrganization.html) operations.
    public struct EventAccountFilter: Swift.Equatable {
        /// The 12-digit Amazon Web Services account numbers that contains the affected entities.
        public var awsAccountId: Swift.String?
        /// The unique identifier for the event. The event ARN has the arn:aws:health:event-region::event/SERVICE/EVENT_TYPE_CODE/EVENT_TYPE_PLUS_ID  format. For example, an event ARN might look like the following: arn:aws:health:us-east-1::event/EC2/EC2_INSTANCE_RETIREMENT_SCHEDULED/EC2_INSTANCE_RETIREMENT_SCHEDULED_ABC123-DEF456
        /// This member is required.
        public var eventArn: Swift.String?

        public init (
            awsAccountId: Swift.String? = nil,
            eventArn: Swift.String? = nil
        )
        {
            self.awsAccountId = awsAccountId
            self.eventArn = eventArn
        }
    }

}

extension HealthClientTypes.EventAggregate: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aggregateValue
        case count
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aggregateValue = self.aggregateValue {
            try encodeContainer.encode(aggregateValue, forKey: .aggregateValue)
        }
        if count != 0 {
            try encodeContainer.encode(count, forKey: .count)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aggregateValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .aggregateValue)
        aggregateValue = aggregateValueDecoded
        let countDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .count) ?? 0
        count = countDecoded
    }
}

extension HealthClientTypes {
    /// The number of events of each issue type. Returned by the [DescribeEventAggregates](https://docs.aws.amazon.com/health/latest/APIReference/API_DescribeEventAggregates.html) operation.
    public struct EventAggregate: Swift.Equatable {
        /// The issue type for the associated count.
        public var aggregateValue: Swift.String?
        /// The number of events of the associated issue type.
        public var count: Swift.Int

        public init (
            aggregateValue: Swift.String? = nil,
            count: Swift.Int = 0
        )
        {
            self.aggregateValue = aggregateValue
            self.count = count
        }
    }

}

extension HealthClientTypes {
    public enum EventAggregateField: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case eventtypecategory
        case sdkUnknown(Swift.String)

        public static var allCases: [EventAggregateField] {
            return [
                .eventtypecategory,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .eventtypecategory: return "eventTypeCategory"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EventAggregateField(rawValue: rawValue) ?? EventAggregateField.sdkUnknown(rawValue)
        }
    }
}

extension HealthClientTypes.EventDescription: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case latestDescription
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let latestDescription = self.latestDescription {
            try encodeContainer.encode(latestDescription, forKey: .latestDescription)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let latestDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .latestDescription)
        latestDescription = latestDescriptionDecoded
    }
}

extension HealthClientTypes {
    /// The detailed description of the event. Included in the information returned by the [DescribeEventDetails](https://docs.aws.amazon.com/health/latest/APIReference/API_DescribeEventDetails.html) operation.
    public struct EventDescription: Swift.Equatable {
        /// The most recent description of the event.
        public var latestDescription: Swift.String?

        public init (
            latestDescription: Swift.String? = nil
        )
        {
            self.latestDescription = latestDescription
        }
    }

}

extension HealthClientTypes.EventDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case event
        case eventDescription
        case eventMetadata
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let event = self.event {
            try encodeContainer.encode(event, forKey: .event)
        }
        if let eventDescription = self.eventDescription {
            try encodeContainer.encode(eventDescription, forKey: .eventDescription)
        }
        if let eventMetadata = eventMetadata {
            var eventMetadataContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .eventMetadata)
            for (dictKey0, eventMetadata0) in eventMetadata {
                try eventMetadataContainer.encode(eventMetadata0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventDecoded = try containerValues.decodeIfPresent(HealthClientTypes.Event.self, forKey: .event)
        event = eventDecoded
        let eventDescriptionDecoded = try containerValues.decodeIfPresent(HealthClientTypes.EventDescription.self, forKey: .eventDescription)
        eventDescription = eventDescriptionDecoded
        let eventMetadataContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .eventMetadata)
        var eventMetadataDecoded0: [Swift.String:Swift.String]? = nil
        if let eventMetadataContainer = eventMetadataContainer {
            eventMetadataDecoded0 = [Swift.String:Swift.String]()
            for (key0, metadatavalue0) in eventMetadataContainer {
                if let metadatavalue0 = metadatavalue0 {
                    eventMetadataDecoded0?[key0] = metadatavalue0
                }
            }
        }
        eventMetadata = eventMetadataDecoded0
    }
}

extension HealthClientTypes {
    /// Detailed information about an event. A combination of an [Event](https://docs.aws.amazon.com/health/latest/APIReference/API_Event.html) object, an [EventDescription](https://docs.aws.amazon.com/health/latest/APIReference/API_EventDescription.html) object, and additional metadata about the event. Returned by the [DescribeEventDetails](https://docs.aws.amazon.com/health/latest/APIReference/API_DescribeEventDetails.html) operation.
    public struct EventDetails: Swift.Equatable {
        /// Summary information about the event.
        public var event: HealthClientTypes.Event?
        /// The most recent description of the event.
        public var eventDescription: HealthClientTypes.EventDescription?
        /// Additional metadata about the event.
        public var eventMetadata: [Swift.String:Swift.String]?

        public init (
            event: HealthClientTypes.Event? = nil,
            eventDescription: HealthClientTypes.EventDescription? = nil,
            eventMetadata: [Swift.String:Swift.String]? = nil
        )
        {
            self.event = event
            self.eventDescription = eventDescription
            self.eventMetadata = eventMetadata
        }
    }

}

extension HealthClientTypes.EventDetailsErrorItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorMessage
        case errorName
        case eventArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorMessage = self.errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let errorName = self.errorName {
            try encodeContainer.encode(errorName, forKey: .errorName)
        }
        if let eventArn = self.eventArn {
            try encodeContainer.encode(eventArn, forKey: .eventArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventArn)
        eventArn = eventArnDecoded
        let errorNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorName)
        errorName = errorNameDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension HealthClientTypes {
    /// Error information returned when a [DescribeEventDetails](https://docs.aws.amazon.com/health/latest/APIReference/API_DescribeEventDetails.html) operation can't find a specified event.
    public struct EventDetailsErrorItem: Swift.Equatable {
        /// A message that describes the error.
        public var errorMessage: Swift.String?
        /// The name of the error.
        public var errorName: Swift.String?
        /// The unique identifier for the event. The event ARN has the arn:aws:health:event-region::event/SERVICE/EVENT_TYPE_CODE/EVENT_TYPE_PLUS_ID  format. For example, an event ARN might look like the following: arn:aws:health:us-east-1::event/EC2/EC2_INSTANCE_RETIREMENT_SCHEDULED/EC2_INSTANCE_RETIREMENT_SCHEDULED_ABC123-DEF456
        public var eventArn: Swift.String?

        public init (
            errorMessage: Swift.String? = nil,
            errorName: Swift.String? = nil,
            eventArn: Swift.String? = nil
        )
        {
            self.errorMessage = errorMessage
            self.errorName = errorName
            self.eventArn = eventArn
        }
    }

}

extension HealthClientTypes.EventFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case availabilityZones
        case endTimes
        case entityArns
        case entityValues
        case eventArns
        case eventStatusCodes
        case eventTypeCategories
        case eventTypeCodes
        case lastUpdatedTimes
        case regions
        case services
        case startTimes
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let availabilityZones = availabilityZones {
            var availabilityZonesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .availabilityZones)
            for availabilityzone0 in availabilityZones {
                try availabilityZonesContainer.encode(availabilityzone0)
            }
        }
        if let endTimes = endTimes {
            var endTimesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .endTimes)
            for datetimerange0 in endTimes {
                try endTimesContainer.encode(datetimerange0)
            }
        }
        if let entityArns = entityArns {
            var entityArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .entityArns)
            for entityarn0 in entityArns {
                try entityArnsContainer.encode(entityarn0)
            }
        }
        if let entityValues = entityValues {
            var entityValuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .entityValues)
            for entityvalue0 in entityValues {
                try entityValuesContainer.encode(entityvalue0)
            }
        }
        if let eventArns = eventArns {
            var eventArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .eventArns)
            for eventarn0 in eventArns {
                try eventArnsContainer.encode(eventarn0)
            }
        }
        if let eventStatusCodes = eventStatusCodes {
            var eventStatusCodesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .eventStatusCodes)
            for eventstatuscode0 in eventStatusCodes {
                try eventStatusCodesContainer.encode(eventstatuscode0.rawValue)
            }
        }
        if let eventTypeCategories = eventTypeCategories {
            var eventTypeCategoriesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .eventTypeCategories)
            for eventtypecategory0 in eventTypeCategories {
                try eventTypeCategoriesContainer.encode(eventtypecategory0.rawValue)
            }
        }
        if let eventTypeCodes = eventTypeCodes {
            var eventTypeCodesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .eventTypeCodes)
            for eventtype20 in eventTypeCodes {
                try eventTypeCodesContainer.encode(eventtype20)
            }
        }
        if let lastUpdatedTimes = lastUpdatedTimes {
            var lastUpdatedTimesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .lastUpdatedTimes)
            for datetimerange0 in lastUpdatedTimes {
                try lastUpdatedTimesContainer.encode(datetimerange0)
            }
        }
        if let regions = regions {
            var regionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .regions)
            for region0 in regions {
                try regionsContainer.encode(region0)
            }
        }
        if let services = services {
            var servicesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .services)
            for service0 in services {
                try servicesContainer.encode(service0)
            }
        }
        if let startTimes = startTimes {
            var startTimesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .startTimes)
            for datetimerange0 in startTimes {
                try startTimesContainer.encode(datetimerange0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tagset0 in tags {
                var tagset0Container = tagsContainer.nestedContainer(keyedBy: ClientRuntime.Key.self)
                for (dictKey1, tagSet1) in tagset0 {
                    try tagset0Container.encode(tagSet1, forKey: ClientRuntime.Key(stringValue: dictKey1))
                }
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .eventArns)
        var eventArnsDecoded0:[Swift.String]? = nil
        if let eventArnsContainer = eventArnsContainer {
            eventArnsDecoded0 = [Swift.String]()
            for string0 in eventArnsContainer {
                if let string0 = string0 {
                    eventArnsDecoded0?.append(string0)
                }
            }
        }
        eventArns = eventArnsDecoded0
        let eventTypeCodesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .eventTypeCodes)
        var eventTypeCodesDecoded0:[Swift.String]? = nil
        if let eventTypeCodesContainer = eventTypeCodesContainer {
            eventTypeCodesDecoded0 = [Swift.String]()
            for string0 in eventTypeCodesContainer {
                if let string0 = string0 {
                    eventTypeCodesDecoded0?.append(string0)
                }
            }
        }
        eventTypeCodes = eventTypeCodesDecoded0
        let servicesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .services)
        var servicesDecoded0:[Swift.String]? = nil
        if let servicesContainer = servicesContainer {
            servicesDecoded0 = [Swift.String]()
            for string0 in servicesContainer {
                if let string0 = string0 {
                    servicesDecoded0?.append(string0)
                }
            }
        }
        services = servicesDecoded0
        let regionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .regions)
        var regionsDecoded0:[Swift.String]? = nil
        if let regionsContainer = regionsContainer {
            regionsDecoded0 = [Swift.String]()
            for string0 in regionsContainer {
                if let string0 = string0 {
                    regionsDecoded0?.append(string0)
                }
            }
        }
        regions = regionsDecoded0
        let availabilityZonesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .availabilityZones)
        var availabilityZonesDecoded0:[Swift.String]? = nil
        if let availabilityZonesContainer = availabilityZonesContainer {
            availabilityZonesDecoded0 = [Swift.String]()
            for string0 in availabilityZonesContainer {
                if let string0 = string0 {
                    availabilityZonesDecoded0?.append(string0)
                }
            }
        }
        availabilityZones = availabilityZonesDecoded0
        let startTimesContainer = try containerValues.decodeIfPresent([HealthClientTypes.DateTimeRange?].self, forKey: .startTimes)
        var startTimesDecoded0:[HealthClientTypes.DateTimeRange]? = nil
        if let startTimesContainer = startTimesContainer {
            startTimesDecoded0 = [HealthClientTypes.DateTimeRange]()
            for structure0 in startTimesContainer {
                if let structure0 = structure0 {
                    startTimesDecoded0?.append(structure0)
                }
            }
        }
        startTimes = startTimesDecoded0
        let endTimesContainer = try containerValues.decodeIfPresent([HealthClientTypes.DateTimeRange?].self, forKey: .endTimes)
        var endTimesDecoded0:[HealthClientTypes.DateTimeRange]? = nil
        if let endTimesContainer = endTimesContainer {
            endTimesDecoded0 = [HealthClientTypes.DateTimeRange]()
            for structure0 in endTimesContainer {
                if let structure0 = structure0 {
                    endTimesDecoded0?.append(structure0)
                }
            }
        }
        endTimes = endTimesDecoded0
        let lastUpdatedTimesContainer = try containerValues.decodeIfPresent([HealthClientTypes.DateTimeRange?].self, forKey: .lastUpdatedTimes)
        var lastUpdatedTimesDecoded0:[HealthClientTypes.DateTimeRange]? = nil
        if let lastUpdatedTimesContainer = lastUpdatedTimesContainer {
            lastUpdatedTimesDecoded0 = [HealthClientTypes.DateTimeRange]()
            for structure0 in lastUpdatedTimesContainer {
                if let structure0 = structure0 {
                    lastUpdatedTimesDecoded0?.append(structure0)
                }
            }
        }
        lastUpdatedTimes = lastUpdatedTimesDecoded0
        let entityArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .entityArns)
        var entityArnsDecoded0:[Swift.String]? = nil
        if let entityArnsContainer = entityArnsContainer {
            entityArnsDecoded0 = [Swift.String]()
            for string0 in entityArnsContainer {
                if let string0 = string0 {
                    entityArnsDecoded0?.append(string0)
                }
            }
        }
        entityArns = entityArnsDecoded0
        let entityValuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .entityValues)
        var entityValuesDecoded0:[Swift.String]? = nil
        if let entityValuesContainer = entityValuesContainer {
            entityValuesDecoded0 = [Swift.String]()
            for string0 in entityValuesContainer {
                if let string0 = string0 {
                    entityValuesDecoded0?.append(string0)
                }
            }
        }
        entityValues = entityValuesDecoded0
        let eventTypeCategoriesContainer = try containerValues.decodeIfPresent([HealthClientTypes.EventTypeCategory?].self, forKey: .eventTypeCategories)
        var eventTypeCategoriesDecoded0:[HealthClientTypes.EventTypeCategory]? = nil
        if let eventTypeCategoriesContainer = eventTypeCategoriesContainer {
            eventTypeCategoriesDecoded0 = [HealthClientTypes.EventTypeCategory]()
            for string0 in eventTypeCategoriesContainer {
                if let string0 = string0 {
                    eventTypeCategoriesDecoded0?.append(string0)
                }
            }
        }
        eventTypeCategories = eventTypeCategoriesDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([[Swift.String: Swift.String?]?].self, forKey: .tags)
        var tagsDecoded0:[[Swift.String:Swift.String]]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [[Swift.String:Swift.String]]()
            for map0 in tagsContainer {
                var tagsContainerDecoded0: [Swift.String: Swift.String]? = nil
                if let map0 = map0 {
                    tagsContainerDecoded0 = [Swift.String: Swift.String]()
                    for (key1, tagvalue1) in map0 {
                        if let tagvalue1 = tagvalue1 {
                            tagsContainerDecoded0?[key1] = tagvalue1
                        }
                    }
                }
                if let tagsContainerDecoded0 = tagsContainerDecoded0 {
                    tagsDecoded0?.append(tagsContainerDecoded0)
                }
            }
        }
        tags = tagsDecoded0
        let eventStatusCodesContainer = try containerValues.decodeIfPresent([HealthClientTypes.EventStatusCode?].self, forKey: .eventStatusCodes)
        var eventStatusCodesDecoded0:[HealthClientTypes.EventStatusCode]? = nil
        if let eventStatusCodesContainer = eventStatusCodesContainer {
            eventStatusCodesDecoded0 = [HealthClientTypes.EventStatusCode]()
            for string0 in eventStatusCodesContainer {
                if let string0 = string0 {
                    eventStatusCodesDecoded0?.append(string0)
                }
            }
        }
        eventStatusCodes = eventStatusCodesDecoded0
    }
}

extension HealthClientTypes {
    /// The values to use to filter results from the [DescribeEvents](https://docs.aws.amazon.com/health/latest/APIReference/API_DescribeEvents.html) and [DescribeEventAggregates](https://docs.aws.amazon.com/health/latest/APIReference/API_DescribeEventAggregates.html) operations.
    public struct EventFilter: Swift.Equatable {
        /// A list of Amazon Web Services Availability Zones.
        public var availabilityZones: [Swift.String]?
        /// A list of dates and times that the event ended.
        public var endTimes: [HealthClientTypes.DateTimeRange]?
        /// A list of entity ARNs (unique identifiers).
        public var entityArns: [Swift.String]?
        /// A list of entity identifiers, such as EC2 instance IDs (i-34ab692e) or EBS volumes (vol-426ab23e).
        public var entityValues: [Swift.String]?
        /// A list of event ARNs (unique identifiers). For example: "arn:aws:health:us-east-1::event/EC2/EC2_INSTANCE_RETIREMENT_SCHEDULED/EC2_INSTANCE_RETIREMENT_SCHEDULED_ABC123-CDE456", "arn:aws:health:us-west-1::event/EBS/AWS_EBS_LOST_VOLUME/AWS_EBS_LOST_VOLUME_CHI789_JKL101"
        public var eventArns: [Swift.String]?
        /// A list of event status codes.
        public var eventStatusCodes: [HealthClientTypes.EventStatusCode]?
        /// A list of event type category codes. Possible values are issue, accountNotification, or scheduledChange. Currently, the investigation value isn't supported at this time.
        public var eventTypeCategories: [HealthClientTypes.EventTypeCategory]?
        /// A list of unique identifiers for event types. For example, "AWS_EC2_SYSTEM_MAINTENANCE_EVENT","AWS_RDS_MAINTENANCE_SCHEDULED".
        public var eventTypeCodes: [Swift.String]?
        /// A list of dates and times that the event was last updated.
        public var lastUpdatedTimes: [HealthClientTypes.DateTimeRange]?
        /// A list of Amazon Web Services Regions.
        public var regions: [Swift.String]?
        /// The Amazon Web Services services associated with the event. For example, EC2, RDS.
        public var services: [Swift.String]?
        /// A list of dates and times that the event began.
        public var startTimes: [HealthClientTypes.DateTimeRange]?
        /// A map of entity tags attached to the affected entity. Currently, the tags property isn't supported.
        public var tags: [[Swift.String:Swift.String]]?

        public init (
            availabilityZones: [Swift.String]? = nil,
            endTimes: [HealthClientTypes.DateTimeRange]? = nil,
            entityArns: [Swift.String]? = nil,
            entityValues: [Swift.String]? = nil,
            eventArns: [Swift.String]? = nil,
            eventStatusCodes: [HealthClientTypes.EventStatusCode]? = nil,
            eventTypeCategories: [HealthClientTypes.EventTypeCategory]? = nil,
            eventTypeCodes: [Swift.String]? = nil,
            lastUpdatedTimes: [HealthClientTypes.DateTimeRange]? = nil,
            regions: [Swift.String]? = nil,
            services: [Swift.String]? = nil,
            startTimes: [HealthClientTypes.DateTimeRange]? = nil,
            tags: [[Swift.String:Swift.String]]? = nil
        )
        {
            self.availabilityZones = availabilityZones
            self.endTimes = endTimes
            self.entityArns = entityArns
            self.entityValues = entityValues
            self.eventArns = eventArns
            self.eventStatusCodes = eventStatusCodes
            self.eventTypeCategories = eventTypeCategories
            self.eventTypeCodes = eventTypeCodes
            self.lastUpdatedTimes = lastUpdatedTimes
            self.regions = regions
            self.services = services
            self.startTimes = startTimes
            self.tags = tags
        }
    }

}

extension HealthClientTypes {
    public enum EventScopeCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case accountSpecific
        case `none`
        case `public`
        case sdkUnknown(Swift.String)

        public static var allCases: [EventScopeCode] {
            return [
                .accountSpecific,
                .none,
                .public,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .accountSpecific: return "ACCOUNT_SPECIFIC"
            case .none: return "NONE"
            case .public: return "PUBLIC"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EventScopeCode(rawValue: rawValue) ?? EventScopeCode.sdkUnknown(rawValue)
        }
    }
}

extension HealthClientTypes {
    public enum EventStatusCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case closed
        case `open`
        case upcoming
        case sdkUnknown(Swift.String)

        public static var allCases: [EventStatusCode] {
            return [
                .closed,
                .open,
                .upcoming,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .closed: return "closed"
            case .open: return "open"
            case .upcoming: return "upcoming"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EventStatusCode(rawValue: rawValue) ?? EventStatusCode.sdkUnknown(rawValue)
        }
    }
}

extension HealthClientTypes.EventType: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case category
        case code
        case service
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let category = self.category {
            try encodeContainer.encode(category.rawValue, forKey: .category)
        }
        if let code = self.code {
            try encodeContainer.encode(code, forKey: .code)
        }
        if let service = self.service {
            try encodeContainer.encode(service, forKey: .service)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .service)
        service = serviceDecoded
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let categoryDecoded = try containerValues.decodeIfPresent(HealthClientTypes.EventTypeCategory.self, forKey: .category)
        category = categoryDecoded
    }
}

extension HealthClientTypes {
    /// Contains the metadata about a type of event that is reported by Health. The EventType shows the category, service, and the event type code of the event. For example, an issue might be the category, EC2 the service, and AWS_EC2_SYSTEM_MAINTENANCE_EVENT the event type code. You can use the [DescribeEventTypes](https://docs.aws.amazon.com/health/latest/APIReference/API_DescribeEventTypes.html) API operation to return this information about an event. You can also use the Amazon CloudWatch Events console to create a rule so that you can get notified or take action when Health delivers a specific event to your Amazon Web Services account. For more information, see [Monitor for Health events with Amazon CloudWatch Events](https://docs.aws.amazon.com/health/latest/ug/cloudwatch-events-health.html) in the Health User Guide.
    public struct EventType: Swift.Equatable {
        /// A list of event type category codes. Possible values are issue, accountNotification, or scheduledChange. Currently, the investigation value isn't supported at this time.
        public var category: HealthClientTypes.EventTypeCategory?
        /// The unique identifier for the event type. The format is AWS_SERVICE_DESCRIPTION ; for example, AWS_EC2_SYSTEM_MAINTENANCE_EVENT.
        public var code: Swift.String?
        /// The Amazon Web Services service that is affected by the event. For example, EC2, RDS.
        public var service: Swift.String?

        public init (
            category: HealthClientTypes.EventTypeCategory? = nil,
            code: Swift.String? = nil,
            service: Swift.String? = nil
        )
        {
            self.category = category
            self.code = code
            self.service = service
        }
    }

}

extension HealthClientTypes {
    public enum EventTypeCategory: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case accountNotification
        case investigation
        case issue
        case scheduledChange
        case sdkUnknown(Swift.String)

        public static var allCases: [EventTypeCategory] {
            return [
                .accountNotification,
                .investigation,
                .issue,
                .scheduledChange,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .accountNotification: return "accountNotification"
            case .investigation: return "investigation"
            case .issue: return "issue"
            case .scheduledChange: return "scheduledChange"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EventTypeCategory(rawValue: rawValue) ?? EventTypeCategory.sdkUnknown(rawValue)
        }
    }
}

extension HealthClientTypes.EventTypeFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventTypeCategories
        case eventTypeCodes
        case services
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eventTypeCategories = eventTypeCategories {
            var eventTypeCategoriesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .eventTypeCategories)
            for eventtypecategory0 in eventTypeCategories {
                try eventTypeCategoriesContainer.encode(eventtypecategory0.rawValue)
            }
        }
        if let eventTypeCodes = eventTypeCodes {
            var eventTypeCodesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .eventTypeCodes)
            for eventtypecode0 in eventTypeCodes {
                try eventTypeCodesContainer.encode(eventtypecode0)
            }
        }
        if let services = services {
            var servicesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .services)
            for service0 in services {
                try servicesContainer.encode(service0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventTypeCodesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .eventTypeCodes)
        var eventTypeCodesDecoded0:[Swift.String]? = nil
        if let eventTypeCodesContainer = eventTypeCodesContainer {
            eventTypeCodesDecoded0 = [Swift.String]()
            for string0 in eventTypeCodesContainer {
                if let string0 = string0 {
                    eventTypeCodesDecoded0?.append(string0)
                }
            }
        }
        eventTypeCodes = eventTypeCodesDecoded0
        let servicesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .services)
        var servicesDecoded0:[Swift.String]? = nil
        if let servicesContainer = servicesContainer {
            servicesDecoded0 = [Swift.String]()
            for string0 in servicesContainer {
                if let string0 = string0 {
                    servicesDecoded0?.append(string0)
                }
            }
        }
        services = servicesDecoded0
        let eventTypeCategoriesContainer = try containerValues.decodeIfPresent([HealthClientTypes.EventTypeCategory?].self, forKey: .eventTypeCategories)
        var eventTypeCategoriesDecoded0:[HealthClientTypes.EventTypeCategory]? = nil
        if let eventTypeCategoriesContainer = eventTypeCategoriesContainer {
            eventTypeCategoriesDecoded0 = [HealthClientTypes.EventTypeCategory]()
            for string0 in eventTypeCategoriesContainer {
                if let string0 = string0 {
                    eventTypeCategoriesDecoded0?.append(string0)
                }
            }
        }
        eventTypeCategories = eventTypeCategoriesDecoded0
    }
}

extension HealthClientTypes {
    /// The values to use to filter results from the [DescribeEventTypes](https://docs.aws.amazon.com/health/latest/APIReference/API_DescribeEventTypes.html) operation.
    public struct EventTypeFilter: Swift.Equatable {
        /// A list of event type category codes. Possible values are issue, accountNotification, or scheduledChange. Currently, the investigation value isn't supported at this time.
        public var eventTypeCategories: [HealthClientTypes.EventTypeCategory]?
        /// A list of event type codes.
        public var eventTypeCodes: [Swift.String]?
        /// The Amazon Web Services services associated with the event. For example, EC2, RDS.
        public var services: [Swift.String]?

        public init (
            eventTypeCategories: [HealthClientTypes.EventTypeCategory]? = nil,
            eventTypeCodes: [Swift.String]? = nil,
            services: [Swift.String]? = nil
        )
        {
            self.eventTypeCategories = eventTypeCategories
            self.eventTypeCodes = eventTypeCodes
            self.services = services
        }
    }

}

extension InvalidPaginationToken {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InvalidPaginationTokenBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified pagination token (nextToken) is not valid.
public struct InvalidPaginationToken: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InvalidPaginationTokenBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidPaginationTokenBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension HealthClientTypes.OrganizationAffectedEntitiesErrorItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsAccountId
        case errorMessage
        case errorName
        case eventArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let awsAccountId = self.awsAccountId {
            try encodeContainer.encode(awsAccountId, forKey: .awsAccountId)
        }
        if let errorMessage = self.errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let errorName = self.errorName {
            try encodeContainer.encode(errorName, forKey: .errorName)
        }
        if let eventArn = self.eventArn {
            try encodeContainer.encode(eventArn, forKey: .eventArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let awsAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsAccountId)
        awsAccountId = awsAccountIdDecoded
        let eventArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventArn)
        eventArn = eventArnDecoded
        let errorNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorName)
        errorName = errorNameDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension HealthClientTypes {
    /// Error information returned when a [DescribeAffectedEntitiesForOrganization](https://docs.aws.amazon.com/health/latest/APIReference/API_DescribeAffectedEntitiesForOrganization.html) operation can't find or process a specific entity.
    public struct OrganizationAffectedEntitiesErrorItem: Swift.Equatable {
        /// The 12-digit Amazon Web Services account numbers that contains the affected entities.
        public var awsAccountId: Swift.String?
        /// The unique identifier for the event type. The format is AWS_SERVICE_DESCRIPTION. For example, AWS_EC2_SYSTEM_MAINTENANCE_EVENT.
        public var errorMessage: Swift.String?
        /// The name of the error.
        public var errorName: Swift.String?
        /// The unique identifier for the event. The event ARN has the arn:aws:health:event-region::event/SERVICE/EVENT_TYPE_CODE/EVENT_TYPE_PLUS_ID  format. For example, an event ARN might look like the following: arn:aws:health:us-east-1::event/EC2/EC2_INSTANCE_RETIREMENT_SCHEDULED/EC2_INSTANCE_RETIREMENT_SCHEDULED_ABC123-DEF456
        public var eventArn: Swift.String?

        public init (
            awsAccountId: Swift.String? = nil,
            errorMessage: Swift.String? = nil,
            errorName: Swift.String? = nil,
            eventArn: Swift.String? = nil
        )
        {
            self.awsAccountId = awsAccountId
            self.errorMessage = errorMessage
            self.errorName = errorName
            self.eventArn = eventArn
        }
    }

}

extension HealthClientTypes.OrganizationEvent: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case endTime
        case eventScopeCode
        case eventTypeCategory
        case eventTypeCode
        case lastUpdatedTime
        case region
        case service
        case startTime
        case statusCode
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let endTime = self.endTime {
            try encodeContainer.encodeTimestamp(endTime, format: .epochSeconds, forKey: .endTime)
        }
        if let eventScopeCode = self.eventScopeCode {
            try encodeContainer.encode(eventScopeCode.rawValue, forKey: .eventScopeCode)
        }
        if let eventTypeCategory = self.eventTypeCategory {
            try encodeContainer.encode(eventTypeCategory.rawValue, forKey: .eventTypeCategory)
        }
        if let eventTypeCode = self.eventTypeCode {
            try encodeContainer.encode(eventTypeCode, forKey: .eventTypeCode)
        }
        if let lastUpdatedTime = self.lastUpdatedTime {
            try encodeContainer.encodeTimestamp(lastUpdatedTime, format: .epochSeconds, forKey: .lastUpdatedTime)
        }
        if let region = self.region {
            try encodeContainer.encode(region, forKey: .region)
        }
        if let service = self.service {
            try encodeContainer.encode(service, forKey: .service)
        }
        if let startTime = self.startTime {
            try encodeContainer.encodeTimestamp(startTime, format: .epochSeconds, forKey: .startTime)
        }
        if let statusCode = self.statusCode {
            try encodeContainer.encode(statusCode.rawValue, forKey: .statusCode)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let serviceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .service)
        service = serviceDecoded
        let eventTypeCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventTypeCode)
        eventTypeCode = eventTypeCodeDecoded
        let eventTypeCategoryDecoded = try containerValues.decodeIfPresent(HealthClientTypes.EventTypeCategory.self, forKey: .eventTypeCategory)
        eventTypeCategory = eventTypeCategoryDecoded
        let eventScopeCodeDecoded = try containerValues.decodeIfPresent(HealthClientTypes.EventScopeCode.self, forKey: .eventScopeCode)
        eventScopeCode = eventScopeCodeDecoded
        let regionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .region)
        region = regionDecoded
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endTime)
        endTime = endTimeDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
        let statusCodeDecoded = try containerValues.decodeIfPresent(HealthClientTypes.EventStatusCode.self, forKey: .statusCode)
        statusCode = statusCodeDecoded
    }
}

extension HealthClientTypes {
    /// Summary information about an event, returned by the [DescribeEventsForOrganization](https://docs.aws.amazon.com/health/latest/APIReference/API_DescribeEventsForOrganization.html) operation.
    public struct OrganizationEvent: Swift.Equatable {
        /// The unique identifier for the event. The event ARN has the arn:aws:health:event-region::event/SERVICE/EVENT_TYPE_CODE/EVENT_TYPE_PLUS_ID  format. For example, an event ARN might look like the following: arn:aws:health:us-east-1::event/EC2/EC2_INSTANCE_RETIREMENT_SCHEDULED/EC2_INSTANCE_RETIREMENT_SCHEDULED_ABC123-DEF456
        public var arn: Swift.String?
        /// The date and time that the event ended.
        public var endTime: ClientRuntime.Date?
        /// This parameter specifies if the Health event is a public Amazon Web Services service event or an account-specific event.
        ///
        /// * If the eventScopeCode value is PUBLIC, then the affectedAccounts value is always empty.
        ///
        /// * If the eventScopeCode value is ACCOUNT_SPECIFIC, then the affectedAccounts value lists the affected Amazon Web Services accounts in your organization. For example, if an event affects a service such as Amazon Elastic Compute Cloud and you have Amazon Web Services accounts that use that service, those account IDs appear in the response.
        ///
        /// * If the eventScopeCode value is NONE, then the eventArn that you specified in the request is invalid or doesn't exist.
        public var eventScopeCode: HealthClientTypes.EventScopeCode?
        /// A list of event type category codes. Possible values are issue, accountNotification, or scheduledChange. Currently, the investigation value isn't supported at this time.
        public var eventTypeCategory: HealthClientTypes.EventTypeCategory?
        /// The unique identifier for the event type. The format is AWS_SERVICE_DESCRIPTION. For example, AWS_EC2_SYSTEM_MAINTENANCE_EVENT.
        public var eventTypeCode: Swift.String?
        /// The most recent date and time that the event was updated.
        public var lastUpdatedTime: ClientRuntime.Date?
        /// The Amazon Web Services Region name of the event.
        public var region: Swift.String?
        /// The Amazon Web Services service that is affected by the event, such as EC2 and RDS.
        public var service: Swift.String?
        /// The date and time that the event began.
        public var startTime: ClientRuntime.Date?
        /// The most recent status of the event. Possible values are open, closed, and upcoming.
        public var statusCode: HealthClientTypes.EventStatusCode?

        public init (
            arn: Swift.String? = nil,
            endTime: ClientRuntime.Date? = nil,
            eventScopeCode: HealthClientTypes.EventScopeCode? = nil,
            eventTypeCategory: HealthClientTypes.EventTypeCategory? = nil,
            eventTypeCode: Swift.String? = nil,
            lastUpdatedTime: ClientRuntime.Date? = nil,
            region: Swift.String? = nil,
            service: Swift.String? = nil,
            startTime: ClientRuntime.Date? = nil,
            statusCode: HealthClientTypes.EventStatusCode? = nil
        )
        {
            self.arn = arn
            self.endTime = endTime
            self.eventScopeCode = eventScopeCode
            self.eventTypeCategory = eventTypeCategory
            self.eventTypeCode = eventTypeCode
            self.lastUpdatedTime = lastUpdatedTime
            self.region = region
            self.service = service
            self.startTime = startTime
            self.statusCode = statusCode
        }
    }

}

extension HealthClientTypes.OrganizationEventDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsAccountId
        case event
        case eventDescription
        case eventMetadata
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let awsAccountId = self.awsAccountId {
            try encodeContainer.encode(awsAccountId, forKey: .awsAccountId)
        }
        if let event = self.event {
            try encodeContainer.encode(event, forKey: .event)
        }
        if let eventDescription = self.eventDescription {
            try encodeContainer.encode(eventDescription, forKey: .eventDescription)
        }
        if let eventMetadata = eventMetadata {
            var eventMetadataContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .eventMetadata)
            for (dictKey0, eventMetadata0) in eventMetadata {
                try eventMetadataContainer.encode(eventMetadata0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let awsAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsAccountId)
        awsAccountId = awsAccountIdDecoded
        let eventDecoded = try containerValues.decodeIfPresent(HealthClientTypes.Event.self, forKey: .event)
        event = eventDecoded
        let eventDescriptionDecoded = try containerValues.decodeIfPresent(HealthClientTypes.EventDescription.self, forKey: .eventDescription)
        eventDescription = eventDescriptionDecoded
        let eventMetadataContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .eventMetadata)
        var eventMetadataDecoded0: [Swift.String:Swift.String]? = nil
        if let eventMetadataContainer = eventMetadataContainer {
            eventMetadataDecoded0 = [Swift.String:Swift.String]()
            for (key0, metadatavalue0) in eventMetadataContainer {
                if let metadatavalue0 = metadatavalue0 {
                    eventMetadataDecoded0?[key0] = metadatavalue0
                }
            }
        }
        eventMetadata = eventMetadataDecoded0
    }
}

extension HealthClientTypes {
    /// Detailed information about an event. A combination of an [Event](https://docs.aws.amazon.com/health/latest/APIReference/API_Event.html) object, an [EventDescription](https://docs.aws.amazon.com/health/latest/APIReference/API_EventDescription.html) object, and additional metadata about the event. Returned by the [DescribeEventDetailsForOrganization](https://docs.aws.amazon.com/health/latest/APIReference/API_DescribeEventDetailsForOrganization.html) operation.
    public struct OrganizationEventDetails: Swift.Equatable {
        /// The 12-digit Amazon Web Services account numbers that contains the affected entities.
        public var awsAccountId: Swift.String?
        /// Summary information about an Health event. Health events can be public or account-specific:
        ///
        /// * Public events might be service events that are not specific to an Amazon Web Services account. For example, if there is an issue with an Amazon Web Services Region, Health provides information about the event, even if you don't use services or resources in that Region.
        ///
        /// * Account-specific events are specific to either your Amazon Web Services account or an account in your organization. For example, if there's an issue with Amazon Elastic Compute Cloud in a Region that you use, Health provides information about the event and the affected resources in the account.
        ///
        ///
        /// You can determine if an event is public or account-specific by using the eventScopeCode parameter. For more information, see [eventScopeCode](https://docs.aws.amazon.com/health/latest/APIReference/API_Event.html#AWSHealth-Type-Event-eventScopeCode).
        public var event: HealthClientTypes.Event?
        /// The detailed description of the event. Included in the information returned by the [DescribeEventDetails](https://docs.aws.amazon.com/health/latest/APIReference/API_DescribeEventDetails.html) operation.
        public var eventDescription: HealthClientTypes.EventDescription?
        /// Additional metadata about the event.
        public var eventMetadata: [Swift.String:Swift.String]?

        public init (
            awsAccountId: Swift.String? = nil,
            event: HealthClientTypes.Event? = nil,
            eventDescription: HealthClientTypes.EventDescription? = nil,
            eventMetadata: [Swift.String:Swift.String]? = nil
        )
        {
            self.awsAccountId = awsAccountId
            self.event = event
            self.eventDescription = eventDescription
            self.eventMetadata = eventMetadata
        }
    }

}

extension HealthClientTypes.OrganizationEventDetailsErrorItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsAccountId
        case errorMessage
        case errorName
        case eventArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let awsAccountId = self.awsAccountId {
            try encodeContainer.encode(awsAccountId, forKey: .awsAccountId)
        }
        if let errorMessage = self.errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let errorName = self.errorName {
            try encodeContainer.encode(errorName, forKey: .errorName)
        }
        if let eventArn = self.eventArn {
            try encodeContainer.encode(eventArn, forKey: .eventArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let awsAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsAccountId)
        awsAccountId = awsAccountIdDecoded
        let eventArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventArn)
        eventArn = eventArnDecoded
        let errorNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorName)
        errorName = errorNameDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension HealthClientTypes {
    /// Error information returned when a [DescribeEventDetailsForOrganization](https://docs.aws.amazon.com/health/latest/APIReference/API_DescribeEventDetailsForOrganization.html) operation can't find a specified event.
    public struct OrganizationEventDetailsErrorItem: Swift.Equatable {
        /// Error information returned when a [DescribeEventDetailsForOrganization](https://docs.aws.amazon.com/health/latest/APIReference/API_DescribeEventDetailsForOrganization.html) operation can't find a specified event.
        public var awsAccountId: Swift.String?
        /// A message that describes the error. If you call the DescribeEventDetailsForOrganization operation and receive one of the following errors, follow the recommendations in the message:
        ///
        /// * We couldn't find a public event that matches your request. To find an event that is account specific, you must enter an Amazon Web Services account ID in the request.
        ///
        /// * We couldn't find an account specific event for the specified Amazon Web Services account. To find an event that is public, you must enter a null value for the Amazon Web Services account ID in the request.
        ///
        /// * Your Amazon Web Services account doesn't include the Amazon Web Services Support plan required to use the Health API. You must have either a Business, Enterprise On-Ramp, or Enterprise Support plan.
        public var errorMessage: Swift.String?
        /// The name of the error.
        public var errorName: Swift.String?
        /// The unique identifier for the event. The event ARN has the arn:aws:health:event-region::event/SERVICE/EVENT_TYPE_CODE/EVENT_TYPE_PLUS_ID  format. For example, an event ARN might look like the following: arn:aws:health:us-east-1::event/EC2/EC2_INSTANCE_RETIREMENT_SCHEDULED/EC2_INSTANCE_RETIREMENT_SCHEDULED_ABC123-DEF456
        public var eventArn: Swift.String?

        public init (
            awsAccountId: Swift.String? = nil,
            errorMessage: Swift.String? = nil,
            errorName: Swift.String? = nil,
            eventArn: Swift.String? = nil
        )
        {
            self.awsAccountId = awsAccountId
            self.errorMessage = errorMessage
            self.errorName = errorName
            self.eventArn = eventArn
        }
    }

}

extension HealthClientTypes.OrganizationEventFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsAccountIds
        case endTime
        case entityArns
        case entityValues
        case eventStatusCodes
        case eventTypeCategories
        case eventTypeCodes
        case lastUpdatedTime
        case regions
        case services
        case startTime
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let awsAccountIds = awsAccountIds {
            var awsAccountIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .awsAccountIds)
            for accountid0 in awsAccountIds {
                try awsAccountIdsContainer.encode(accountid0)
            }
        }
        if let endTime = self.endTime {
            try encodeContainer.encode(endTime, forKey: .endTime)
        }
        if let entityArns = entityArns {
            var entityArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .entityArns)
            for entityarn0 in entityArns {
                try entityArnsContainer.encode(entityarn0)
            }
        }
        if let entityValues = entityValues {
            var entityValuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .entityValues)
            for entityvalue0 in entityValues {
                try entityValuesContainer.encode(entityvalue0)
            }
        }
        if let eventStatusCodes = eventStatusCodes {
            var eventStatusCodesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .eventStatusCodes)
            for eventstatuscode0 in eventStatusCodes {
                try eventStatusCodesContainer.encode(eventstatuscode0.rawValue)
            }
        }
        if let eventTypeCategories = eventTypeCategories {
            var eventTypeCategoriesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .eventTypeCategories)
            for eventtypecategory0 in eventTypeCategories {
                try eventTypeCategoriesContainer.encode(eventtypecategory0.rawValue)
            }
        }
        if let eventTypeCodes = eventTypeCodes {
            var eventTypeCodesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .eventTypeCodes)
            for eventtype20 in eventTypeCodes {
                try eventTypeCodesContainer.encode(eventtype20)
            }
        }
        if let lastUpdatedTime = self.lastUpdatedTime {
            try encodeContainer.encode(lastUpdatedTime, forKey: .lastUpdatedTime)
        }
        if let regions = regions {
            var regionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .regions)
            for region0 in regions {
                try regionsContainer.encode(region0)
            }
        }
        if let services = services {
            var servicesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .services)
            for service0 in services {
                try servicesContainer.encode(service0)
            }
        }
        if let startTime = self.startTime {
            try encodeContainer.encode(startTime, forKey: .startTime)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventTypeCodesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .eventTypeCodes)
        var eventTypeCodesDecoded0:[Swift.String]? = nil
        if let eventTypeCodesContainer = eventTypeCodesContainer {
            eventTypeCodesDecoded0 = [Swift.String]()
            for string0 in eventTypeCodesContainer {
                if let string0 = string0 {
                    eventTypeCodesDecoded0?.append(string0)
                }
            }
        }
        eventTypeCodes = eventTypeCodesDecoded0
        let awsAccountIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .awsAccountIds)
        var awsAccountIdsDecoded0:[Swift.String]? = nil
        if let awsAccountIdsContainer = awsAccountIdsContainer {
            awsAccountIdsDecoded0 = [Swift.String]()
            for string0 in awsAccountIdsContainer {
                if let string0 = string0 {
                    awsAccountIdsDecoded0?.append(string0)
                }
            }
        }
        awsAccountIds = awsAccountIdsDecoded0
        let servicesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .services)
        var servicesDecoded0:[Swift.String]? = nil
        if let servicesContainer = servicesContainer {
            servicesDecoded0 = [Swift.String]()
            for string0 in servicesContainer {
                if let string0 = string0 {
                    servicesDecoded0?.append(string0)
                }
            }
        }
        services = servicesDecoded0
        let regionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .regions)
        var regionsDecoded0:[Swift.String]? = nil
        if let regionsContainer = regionsContainer {
            regionsDecoded0 = [Swift.String]()
            for string0 in regionsContainer {
                if let string0 = string0 {
                    regionsDecoded0?.append(string0)
                }
            }
        }
        regions = regionsDecoded0
        let startTimeDecoded = try containerValues.decodeIfPresent(HealthClientTypes.DateTimeRange.self, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(HealthClientTypes.DateTimeRange.self, forKey: .endTime)
        endTime = endTimeDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeIfPresent(HealthClientTypes.DateTimeRange.self, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
        let entityArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .entityArns)
        var entityArnsDecoded0:[Swift.String]? = nil
        if let entityArnsContainer = entityArnsContainer {
            entityArnsDecoded0 = [Swift.String]()
            for string0 in entityArnsContainer {
                if let string0 = string0 {
                    entityArnsDecoded0?.append(string0)
                }
            }
        }
        entityArns = entityArnsDecoded0
        let entityValuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .entityValues)
        var entityValuesDecoded0:[Swift.String]? = nil
        if let entityValuesContainer = entityValuesContainer {
            entityValuesDecoded0 = [Swift.String]()
            for string0 in entityValuesContainer {
                if let string0 = string0 {
                    entityValuesDecoded0?.append(string0)
                }
            }
        }
        entityValues = entityValuesDecoded0
        let eventTypeCategoriesContainer = try containerValues.decodeIfPresent([HealthClientTypes.EventTypeCategory?].self, forKey: .eventTypeCategories)
        var eventTypeCategoriesDecoded0:[HealthClientTypes.EventTypeCategory]? = nil
        if let eventTypeCategoriesContainer = eventTypeCategoriesContainer {
            eventTypeCategoriesDecoded0 = [HealthClientTypes.EventTypeCategory]()
            for string0 in eventTypeCategoriesContainer {
                if let string0 = string0 {
                    eventTypeCategoriesDecoded0?.append(string0)
                }
            }
        }
        eventTypeCategories = eventTypeCategoriesDecoded0
        let eventStatusCodesContainer = try containerValues.decodeIfPresent([HealthClientTypes.EventStatusCode?].self, forKey: .eventStatusCodes)
        var eventStatusCodesDecoded0:[HealthClientTypes.EventStatusCode]? = nil
        if let eventStatusCodesContainer = eventStatusCodesContainer {
            eventStatusCodesDecoded0 = [HealthClientTypes.EventStatusCode]()
            for string0 in eventStatusCodesContainer {
                if let string0 = string0 {
                    eventStatusCodesDecoded0?.append(string0)
                }
            }
        }
        eventStatusCodes = eventStatusCodesDecoded0
    }
}

extension HealthClientTypes {
    /// The values to filter results from the [DescribeEventsForOrganization](https://docs.aws.amazon.com/health/latest/APIReference/API_DescribeEventsForOrganization.html) operation.
    public struct OrganizationEventFilter: Swift.Equatable {
        /// A list of 12-digit Amazon Web Services account numbers that contains the affected entities.
        public var awsAccountIds: [Swift.String]?
        /// A range of dates and times that is used by the [EventFilter](https://docs.aws.amazon.com/health/latest/APIReference/API_EventFilter.html) and [EntityFilter](https://docs.aws.amazon.com/health/latest/APIReference/API_EntityFilter.html) objects. If from is set and to is set: match items where the timestamp (startTime, endTime, or lastUpdatedTime) is between from and to inclusive. If from is set and to is not set: match items where the timestamp value is equal to or after from. If from is not set and to is set: match items where the timestamp value is equal to or before to.
        public var endTime: HealthClientTypes.DateTimeRange?
        /// A list of entity ARNs (unique identifiers).
        public var entityArns: [Swift.String]?
        /// A list of entity identifiers, such as EC2 instance IDs (i-34ab692e) or EBS volumes (vol-426ab23e).
        public var entityValues: [Swift.String]?
        /// A list of event status codes.
        public var eventStatusCodes: [HealthClientTypes.EventStatusCode]?
        /// A list of event type category codes. Possible values are issue, accountNotification, or scheduledChange. Currently, the investigation value isn't supported at this time.
        public var eventTypeCategories: [HealthClientTypes.EventTypeCategory]?
        /// A list of unique identifiers for event types. For example, "AWS_EC2_SYSTEM_MAINTENANCE_EVENT","AWS_RDS_MAINTENANCE_SCHEDULED".
        public var eventTypeCodes: [Swift.String]?
        /// A range of dates and times that is used by the [EventFilter](https://docs.aws.amazon.com/health/latest/APIReference/API_EventFilter.html) and [EntityFilter](https://docs.aws.amazon.com/health/latest/APIReference/API_EntityFilter.html) objects. If from is set and to is set: match items where the timestamp (startTime, endTime, or lastUpdatedTime) is between from and to inclusive. If from is set and to is not set: match items where the timestamp value is equal to or after from. If from is not set and to is set: match items where the timestamp value is equal to or before to.
        public var lastUpdatedTime: HealthClientTypes.DateTimeRange?
        /// A list of Amazon Web Services Regions.
        public var regions: [Swift.String]?
        /// The Amazon Web Services services associated with the event. For example, EC2, RDS.
        public var services: [Swift.String]?
        /// A range of dates and times that is used by the [EventFilter](https://docs.aws.amazon.com/health/latest/APIReference/API_EventFilter.html) and [EntityFilter](https://docs.aws.amazon.com/health/latest/APIReference/API_EntityFilter.html) objects. If from is set and to is set: match items where the timestamp (startTime, endTime, or lastUpdatedTime) is between from and to inclusive. If from is set and to is not set: match items where the timestamp value is equal to or after from. If from is not set and to is set: match items where the timestamp value is equal to or before to.
        public var startTime: HealthClientTypes.DateTimeRange?

        public init (
            awsAccountIds: [Swift.String]? = nil,
            endTime: HealthClientTypes.DateTimeRange? = nil,
            entityArns: [Swift.String]? = nil,
            entityValues: [Swift.String]? = nil,
            eventStatusCodes: [HealthClientTypes.EventStatusCode]? = nil,
            eventTypeCategories: [HealthClientTypes.EventTypeCategory]? = nil,
            eventTypeCodes: [Swift.String]? = nil,
            lastUpdatedTime: HealthClientTypes.DateTimeRange? = nil,
            regions: [Swift.String]? = nil,
            services: [Swift.String]? = nil,
            startTime: HealthClientTypes.DateTimeRange? = nil
        )
        {
            self.awsAccountIds = awsAccountIds
            self.endTime = endTime
            self.entityArns = entityArns
            self.entityValues = entityValues
            self.eventStatusCodes = eventStatusCodes
            self.eventTypeCategories = eventTypeCategories
            self.eventTypeCodes = eventTypeCodes
            self.lastUpdatedTime = lastUpdatedTime
            self.regions = regions
            self.services = services
            self.startTime = startTime
        }
    }

}

extension UnsupportedLocale {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UnsupportedLocaleBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The specified locale is not supported.
public struct UnsupportedLocale: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct UnsupportedLocaleBody: Swift.Equatable {
    let message: Swift.String?
}

extension UnsupportedLocaleBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}
