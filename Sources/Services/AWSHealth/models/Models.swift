// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension HealthClientTypes.AccountEntityAggregate: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId
        case count
        case statuses
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if count != 0 {
            try encodeContainer.encode(count, forKey: .count)
        }
        if let statuses = statuses {
            var statusesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .statuses)
            for (dictKey0, entityStatuses0) in statuses {
                try statusesContainer.encode(entityStatuses0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let countDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .count) ?? 0
        count = countDecoded
        let statusesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.Int?].self, forKey: .statuses)
        var statusesDecoded0: [Swift.String:Swift.Int]? = nil
        if let statusesContainer = statusesContainer {
            statusesDecoded0 = [Swift.String:Swift.Int]()
            for (key0, count0) in statusesContainer {
                if let count0 = count0 {
                    statusesDecoded0?[key0] = count0
                }
            }
        }
        statuses = statusesDecoded0
    }
}

extension HealthClientTypes {
    /// The number of entities in an account that are impacted by a specific event aggregated by the entity status codes.
    public struct AccountEntityAggregate: Swift.Equatable {
        /// The 12-digit Amazon Web Services account numbers that contains the affected entities.
        public var accountId: Swift.String?
        /// The number of entities that match the filter criteria for the specified events.
        public var count: Swift.Int
        /// The number of affected entities aggregated by the entity status codes.
        public var statuses: [Swift.String:Swift.Int]?

        public init(
            accountId: Swift.String? = nil,
            count: Swift.Int = 0,
            statuses: [Swift.String:Swift.Int]? = nil
        )
        {
            self.accountId = accountId
            self.count = count
            self.statuses = statuses
        }
    }

}

extension HealthClientTypes.AffectedEntity: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsAccountId
        case entityArn
        case entityUrl
        case entityValue
        case eventArn
        case lastUpdatedTime
        case statusCode
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let awsAccountId = self.awsAccountId {
            try encodeContainer.encode(awsAccountId, forKey: .awsAccountId)
        }
        if let entityArn = self.entityArn {
            try encodeContainer.encode(entityArn, forKey: .entityArn)
        }
        if let entityUrl = self.entityUrl {
            try encodeContainer.encode(entityUrl, forKey: .entityUrl)
        }
        if let entityValue = self.entityValue {
            try encodeContainer.encode(entityValue, forKey: .entityValue)
        }
        if let eventArn = self.eventArn {
            try encodeContainer.encode(eventArn, forKey: .eventArn)
        }
        if let lastUpdatedTime = self.lastUpdatedTime {
            try encodeContainer.encodeTimestamp(lastUpdatedTime, format: .epochSeconds, forKey: .lastUpdatedTime)
        }
        if let statusCode = self.statusCode {
            try encodeContainer.encode(statusCode.rawValue, forKey: .statusCode)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagSet0) in tags {
                try tagsContainer.encode(tagSet0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entityArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entityArn)
        entityArn = entityArnDecoded
        let eventArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventArn)
        eventArn = eventArnDecoded
        let entityValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entityValue)
        entityValue = entityValueDecoded
        let entityUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .entityUrl)
        entityUrl = entityUrlDecoded
        let awsAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsAccountId)
        awsAccountId = awsAccountIdDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
        let statusCodeDecoded = try containerValues.decodeIfPresent(HealthClientTypes.EntityStatusCode.self, forKey: .statusCode)
        statusCode = statusCodeDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension HealthClientTypes {
    /// Information about an entity that is affected by a Health event.
    public struct AffectedEntity: Swift.Equatable {
        /// The 12-digit Amazon Web Services account number that contains the affected entity.
        public var awsAccountId: Swift.String?
        /// The unique identifier for the entity. Format: arn:aws:health:entity-region:aws-account:entity/entity-id . Example: arn:aws:health:us-east-1:111222333444:entity/AVh5GGT7ul1arKr1sE1K
        public var entityArn: Swift.String?
        /// The URL of the affected entity.
        public var entityUrl: Swift.String?
        /// The ID of the affected entity.
        public var entityValue: Swift.String?
        /// The unique identifier for the event. The event ARN has the arn:aws:health:event-region::event/SERVICE/EVENT_TYPE_CODE/EVENT_TYPE_PLUS_ID  format. For example, an event ARN might look like the following: arn:aws:health:us-east-1::event/EC2/EC2_INSTANCE_RETIREMENT_SCHEDULED/EC2_INSTANCE_RETIREMENT_SCHEDULED_ABC123-DEF456
        public var eventArn: Swift.String?
        /// The most recent time that the entity was updated.
        public var lastUpdatedTime: ClientRuntime.Date?
        /// The most recent status of the entity affected by the event. The possible values are IMPAIRED, UNIMPAIRED, and UNKNOWN.
        public var statusCode: HealthClientTypes.EntityStatusCode?
        /// A map of entity tags attached to the affected entity. Currently, the tags property isn't supported.
        public var tags: [Swift.String:Swift.String]?

        public init(
            awsAccountId: Swift.String? = nil,
            entityArn: Swift.String? = nil,
            entityUrl: Swift.String? = nil,
            entityValue: Swift.String? = nil,
            eventArn: Swift.String? = nil,
            lastUpdatedTime: ClientRuntime.Date? = nil,
            statusCode: HealthClientTypes.EntityStatusCode? = nil,
            tags: [Swift.String:Swift.String]? = nil
        )
        {
            self.awsAccountId = awsAccountId
            self.entityArn = entityArn
            self.entityUrl = entityUrl
            self.entityValue = entityValue
            self.eventArn = eventArn
            self.lastUpdatedTime = lastUpdatedTime
            self.statusCode = statusCode
            self.tags = tags
        }
    }

}

extension ConcurrentModificationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ConcurrentModificationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// [EnableHealthServiceAccessForOrganization](https://docs.aws.amazon.com/health/latest/APIReference/API_EnableHealthServiceAccessForOrganization.html) is already in progress. Wait for the action to complete before trying again. To get the current status, use the [DescribeHealthServiceStatusForOrganization](https://docs.aws.amazon.com/health/latest/APIReference/API_DescribeHealthServiceStatusForOrganization.html) operation.
public struct ConcurrentModificationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConcurrentModificationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ConcurrentModificationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ConcurrentModificationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension HealthClientTypes.DateTimeRange: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case from
        case to
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let from = self.from {
            try encodeContainer.encodeTimestamp(from, format: .epochSeconds, forKey: .from)
        }
        if let to = self.to {
            try encodeContainer.encodeTimestamp(to, format: .epochSeconds, forKey: .to)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let fromDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .from)
        from = fromDecoded
        let toDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .to)
        to = toDecoded
    }
}

extension HealthClientTypes {
    /// A range of dates and times that is used by the [EventFilter](https://docs.aws.amazon.com/health/latest/APIReference/API_EventFilter.html) and [EntityFilter](https://docs.aws.amazon.com/health/latest/APIReference/API_EntityFilter.html) objects. If from is set and to is set: match items where the timestamp (startTime, endTime, or lastUpdatedTime) is between from and to inclusive. If from is set and to is not set: match items where the timestamp value is equal to or after from. If from is not set and to is set: match items where the timestamp value is equal to or before to.
    public struct DateTimeRange: Swift.Equatable {
        /// The starting date and time of a time range.
        public var from: ClientRuntime.Date?
        /// The ending date and time of a time range.
        public var to: ClientRuntime.Date?

        public init(
            from: ClientRuntime.Date? = nil,
            to: ClientRuntime.Date? = nil
        )
        {
            self.from = from
            self.to = to
        }
    }

}

extension DescribeAffectedAccountsForOrganizationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventArn
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eventArn = self.eventArn {
            try encodeContainer.encode(eventArn, forKey: .eventArn)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension DescribeAffectedAccountsForOrganizationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeAffectedAccountsForOrganizationInput: Swift.Equatable {
    /// The unique identifier for the event. The event ARN has the arn:aws:health:event-region::event/SERVICE/EVENT_TYPE_CODE/EVENT_TYPE_PLUS_ID  format. For example, an event ARN might look like the following: arn:aws:health:us-east-1::event/EC2/EC2_INSTANCE_RETIREMENT_SCHEDULED/EC2_INSTANCE_RETIREMENT_SCHEDULED_ABC123-DEF456
    /// This member is required.
    public var eventArn: Swift.String?
    /// The maximum number of items to return in one batch, between 10 and 100, inclusive.
    public var maxResults: Swift.Int?
    /// If the results of a search are large, only a portion of the results are returned, and a nextToken pagination token is returned in the response. To retrieve the next batch of results, reissue the search request and include the returned token. When all results have been returned, the response does not contain a pagination token value.
    public var nextToken: Swift.String?

    public init(
        eventArn: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.eventArn = eventArn
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeAffectedAccountsForOrganizationInputBody: Swift.Equatable {
    let eventArn: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension DescribeAffectedAccountsForOrganizationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventArn
        case maxResults
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventArn)
        eventArn = eventArnDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension DescribeAffectedAccountsForOrganizationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeAffectedAccountsForOrganizationOutputBody = try responseDecoder.decode(responseBody: data)
            self.affectedAccounts = output.affectedAccounts
            self.eventScopeCode = output.eventScopeCode
            self.nextToken = output.nextToken
        } else {
            self.affectedAccounts = nil
            self.eventScopeCode = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeAffectedAccountsForOrganizationOutput: Swift.Equatable {
    /// A JSON set of elements of the affected accounts.
    public var affectedAccounts: [Swift.String]?
    /// This parameter specifies if the Health event is a public Amazon Web Service event or an account-specific event.
    ///
    /// * If the eventScopeCode value is PUBLIC, then the affectedAccounts value is always empty.
    ///
    /// * If the eventScopeCode value is ACCOUNT_SPECIFIC, then the affectedAccounts value lists the affected Amazon Web Services accounts in your organization. For example, if an event affects a service such as Amazon Elastic Compute Cloud and you have Amazon Web Services accounts that use that service, those account IDs appear in the response.
    ///
    /// * If the eventScopeCode value is NONE, then the eventArn that you specified in the request is invalid or doesn't exist.
    public var eventScopeCode: HealthClientTypes.EventScopeCode?
    /// If the results of a search are large, only a portion of the results are returned, and a nextToken pagination token is returned in the response. To retrieve the next batch of results, reissue the search request and include the returned token. When all results have been returned, the response does not contain a pagination token value.
    public var nextToken: Swift.String?

    public init(
        affectedAccounts: [Swift.String]? = nil,
        eventScopeCode: HealthClientTypes.EventScopeCode? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.affectedAccounts = affectedAccounts
        self.eventScopeCode = eventScopeCode
        self.nextToken = nextToken
    }
}

struct DescribeAffectedAccountsForOrganizationOutputBody: Swift.Equatable {
    let affectedAccounts: [Swift.String]?
    let eventScopeCode: HealthClientTypes.EventScopeCode?
    let nextToken: Swift.String?
}

extension DescribeAffectedAccountsForOrganizationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case affectedAccounts
        case eventScopeCode
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let affectedAccountsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .affectedAccounts)
        var affectedAccountsDecoded0:[Swift.String]? = nil
        if let affectedAccountsContainer = affectedAccountsContainer {
            affectedAccountsDecoded0 = [Swift.String]()
            for string0 in affectedAccountsContainer {
                if let string0 = string0 {
                    affectedAccountsDecoded0?.append(string0)
                }
            }
        }
        affectedAccounts = affectedAccountsDecoded0
        let eventScopeCodeDecoded = try containerValues.decodeIfPresent(HealthClientTypes.EventScopeCode.self, forKey: .eventScopeCode)
        eventScopeCode = eventScopeCodeDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum DescribeAffectedAccountsForOrganizationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidPaginationToken": return try await InvalidPaginationToken(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeAffectedEntitiesForOrganizationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case locale
        case maxResults
        case nextToken
        case organizationEntityAccountFilters
        case organizationEntityFilters
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let locale = self.locale {
            try encodeContainer.encode(locale, forKey: .locale)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let organizationEntityAccountFilters = organizationEntityAccountFilters {
            var organizationEntityAccountFiltersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .organizationEntityAccountFilters)
            for entityaccountfilter0 in organizationEntityAccountFilters {
                try organizationEntityAccountFiltersContainer.encode(entityaccountfilter0)
            }
        }
        if let organizationEntityFilters = organizationEntityFilters {
            var organizationEntityFiltersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .organizationEntityFilters)
            for eventaccountfilter0 in organizationEntityFilters {
                try organizationEntityFiltersContainer.encode(eventaccountfilter0)
            }
        }
    }
}

extension DescribeAffectedEntitiesForOrganizationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeAffectedEntitiesForOrganizationInput: Swift.Equatable {
    /// The locale (language) to return information in. English (en) is the default and the only supported value at this time.
    public var locale: Swift.String?
    /// The maximum number of items to return in one batch, between 10 and 100, inclusive.
    public var maxResults: Swift.Int?
    /// If the results of a search are large, only a portion of the results are returned, and a nextToken pagination token is returned in the response. To retrieve the next batch of results, reissue the search request and include the returned token. When all results have been returned, the response does not contain a pagination token value.
    public var nextToken: Swift.String?
    /// A JSON set of elements including the awsAccountId, eventArn and a set of statusCodes.
    public var organizationEntityAccountFilters: [HealthClientTypes.EntityAccountFilter]?
    /// A JSON set of elements including the awsAccountId and the eventArn.
    @available(*, deprecated, message: "This property is deprecated, use organizationEntityAccountFilters instead.")
    public var organizationEntityFilters: [HealthClientTypes.EventAccountFilter]?

    public init(
        locale: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        organizationEntityAccountFilters: [HealthClientTypes.EntityAccountFilter]? = nil,
        organizationEntityFilters: [HealthClientTypes.EventAccountFilter]? = nil
    )
    {
        self.locale = locale
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.organizationEntityAccountFilters = organizationEntityAccountFilters
        self.organizationEntityFilters = organizationEntityFilters
    }
}

struct DescribeAffectedEntitiesForOrganizationInputBody: Swift.Equatable {
    let organizationEntityFilters: [HealthClientTypes.EventAccountFilter]?
    let locale: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
    let organizationEntityAccountFilters: [HealthClientTypes.EntityAccountFilter]?
}

extension DescribeAffectedEntitiesForOrganizationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case locale
        case maxResults
        case nextToken
        case organizationEntityAccountFilters
        case organizationEntityFilters
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationEntityFiltersContainer = try containerValues.decodeIfPresent([HealthClientTypes.EventAccountFilter?].self, forKey: .organizationEntityFilters)
        var organizationEntityFiltersDecoded0:[HealthClientTypes.EventAccountFilter]? = nil
        if let organizationEntityFiltersContainer = organizationEntityFiltersContainer {
            organizationEntityFiltersDecoded0 = [HealthClientTypes.EventAccountFilter]()
            for structure0 in organizationEntityFiltersContainer {
                if let structure0 = structure0 {
                    organizationEntityFiltersDecoded0?.append(structure0)
                }
            }
        }
        organizationEntityFilters = organizationEntityFiltersDecoded0
        let localeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .locale)
        locale = localeDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let organizationEntityAccountFiltersContainer = try containerValues.decodeIfPresent([HealthClientTypes.EntityAccountFilter?].self, forKey: .organizationEntityAccountFilters)
        var organizationEntityAccountFiltersDecoded0:[HealthClientTypes.EntityAccountFilter]? = nil
        if let organizationEntityAccountFiltersContainer = organizationEntityAccountFiltersContainer {
            organizationEntityAccountFiltersDecoded0 = [HealthClientTypes.EntityAccountFilter]()
            for structure0 in organizationEntityAccountFiltersContainer {
                if let structure0 = structure0 {
                    organizationEntityAccountFiltersDecoded0?.append(structure0)
                }
            }
        }
        organizationEntityAccountFilters = organizationEntityAccountFiltersDecoded0
    }
}

extension DescribeAffectedEntitiesForOrganizationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeAffectedEntitiesForOrganizationOutputBody = try responseDecoder.decode(responseBody: data)
            self.entities = output.entities
            self.failedSet = output.failedSet
            self.nextToken = output.nextToken
        } else {
            self.entities = nil
            self.failedSet = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeAffectedEntitiesForOrganizationOutput: Swift.Equatable {
    /// A JSON set of elements including the awsAccountId and its entityArn, entityValue and its entityArn, lastUpdatedTime, and statusCode.
    public var entities: [HealthClientTypes.AffectedEntity]?
    /// A JSON set of elements of the failed response, including the awsAccountId, errorMessage, errorName, and eventArn.
    public var failedSet: [HealthClientTypes.OrganizationAffectedEntitiesErrorItem]?
    /// If the results of a search are large, only a portion of the results are returned, and a nextToken pagination token is returned in the response. To retrieve the next batch of results, reissue the search request and include the returned token. When all results have been returned, the response does not contain a pagination token value.
    public var nextToken: Swift.String?

    public init(
        entities: [HealthClientTypes.AffectedEntity]? = nil,
        failedSet: [HealthClientTypes.OrganizationAffectedEntitiesErrorItem]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.entities = entities
        self.failedSet = failedSet
        self.nextToken = nextToken
    }
}

struct DescribeAffectedEntitiesForOrganizationOutputBody: Swift.Equatable {
    let entities: [HealthClientTypes.AffectedEntity]?
    let failedSet: [HealthClientTypes.OrganizationAffectedEntitiesErrorItem]?
    let nextToken: Swift.String?
}

extension DescribeAffectedEntitiesForOrganizationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entities
        case failedSet
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entitiesContainer = try containerValues.decodeIfPresent([HealthClientTypes.AffectedEntity?].self, forKey: .entities)
        var entitiesDecoded0:[HealthClientTypes.AffectedEntity]? = nil
        if let entitiesContainer = entitiesContainer {
            entitiesDecoded0 = [HealthClientTypes.AffectedEntity]()
            for structure0 in entitiesContainer {
                if let structure0 = structure0 {
                    entitiesDecoded0?.append(structure0)
                }
            }
        }
        entities = entitiesDecoded0
        let failedSetContainer = try containerValues.decodeIfPresent([HealthClientTypes.OrganizationAffectedEntitiesErrorItem?].self, forKey: .failedSet)
        var failedSetDecoded0:[HealthClientTypes.OrganizationAffectedEntitiesErrorItem]? = nil
        if let failedSetContainer = failedSetContainer {
            failedSetDecoded0 = [HealthClientTypes.OrganizationAffectedEntitiesErrorItem]()
            for structure0 in failedSetContainer {
                if let structure0 = structure0 {
                    failedSetDecoded0?.append(structure0)
                }
            }
        }
        failedSet = failedSetDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum DescribeAffectedEntitiesForOrganizationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidPaginationToken": return try await InvalidPaginationToken(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnsupportedLocale": return try await UnsupportedLocale(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeAffectedEntitiesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter
        case locale
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filter = self.filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
        if let locale = self.locale {
            try encodeContainer.encode(locale, forKey: .locale)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension DescribeAffectedEntitiesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeAffectedEntitiesInput: Swift.Equatable {
    /// Values to narrow the results returned. At least one event ARN is required.
    /// This member is required.
    public var filter: HealthClientTypes.EntityFilter?
    /// The locale (language) to return information in. English (en) is the default and the only supported value at this time.
    public var locale: Swift.String?
    /// The maximum number of items to return in one batch, between 10 and 100, inclusive.
    public var maxResults: Swift.Int?
    /// If the results of a search are large, only a portion of the results are returned, and a nextToken pagination token is returned in the response. To retrieve the next batch of results, reissue the search request and include the returned token. When all results have been returned, the response does not contain a pagination token value.
    public var nextToken: Swift.String?

    public init(
        filter: HealthClientTypes.EntityFilter? = nil,
        locale: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filter = filter
        self.locale = locale
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeAffectedEntitiesInputBody: Swift.Equatable {
    let filter: HealthClientTypes.EntityFilter?
    let locale: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension DescribeAffectedEntitiesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter
        case locale
        case maxResults
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filterDecoded = try containerValues.decodeIfPresent(HealthClientTypes.EntityFilter.self, forKey: .filter)
        filter = filterDecoded
        let localeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .locale)
        locale = localeDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension DescribeAffectedEntitiesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeAffectedEntitiesOutputBody = try responseDecoder.decode(responseBody: data)
            self.entities = output.entities
            self.nextToken = output.nextToken
        } else {
            self.entities = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeAffectedEntitiesOutput: Swift.Equatable {
    /// The entities that match the filter criteria.
    public var entities: [HealthClientTypes.AffectedEntity]?
    /// If the results of a search are large, only a portion of the results are returned, and a nextToken pagination token is returned in the response. To retrieve the next batch of results, reissue the search request and include the returned token. When all results have been returned, the response does not contain a pagination token value.
    public var nextToken: Swift.String?

    public init(
        entities: [HealthClientTypes.AffectedEntity]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.entities = entities
        self.nextToken = nextToken
    }
}

struct DescribeAffectedEntitiesOutputBody: Swift.Equatable {
    let entities: [HealthClientTypes.AffectedEntity]?
    let nextToken: Swift.String?
}

extension DescribeAffectedEntitiesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entities
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entitiesContainer = try containerValues.decodeIfPresent([HealthClientTypes.AffectedEntity?].self, forKey: .entities)
        var entitiesDecoded0:[HealthClientTypes.AffectedEntity]? = nil
        if let entitiesContainer = entitiesContainer {
            entitiesDecoded0 = [HealthClientTypes.AffectedEntity]()
            for structure0 in entitiesContainer {
                if let structure0 = structure0 {
                    entitiesDecoded0?.append(structure0)
                }
            }
        }
        entities = entitiesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum DescribeAffectedEntitiesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidPaginationToken": return try await InvalidPaginationToken(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnsupportedLocale": return try await UnsupportedLocale(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeEntityAggregatesForOrganizationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsAccountIds
        case eventArns
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let awsAccountIds = awsAccountIds {
            var awsAccountIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .awsAccountIds)
            for accountid0 in awsAccountIds {
                try awsAccountIdsContainer.encode(accountid0)
            }
        }
        if let eventArns = eventArns {
            var eventArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .eventArns)
            for eventarn0 in eventArns {
                try eventArnsContainer.encode(eventarn0)
            }
        }
    }
}

extension DescribeEntityAggregatesForOrganizationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeEntityAggregatesForOrganizationInput: Swift.Equatable {
    /// A list of 12-digit Amazon Web Services account numbers that contains the affected entities.
    public var awsAccountIds: [Swift.String]?
    /// A list of event ARNs (unique identifiers). For example: "arn:aws:health:us-east-1::event/EC2/EC2_INSTANCE_RETIREMENT_SCHEDULED/EC2_INSTANCE_RETIREMENT_SCHEDULED_ABC123-CDE456", "arn:aws:health:us-west-1::event/EBS/AWS_EBS_LOST_VOLUME/AWS_EBS_LOST_VOLUME_CHI789_JKL101"
    /// This member is required.
    public var eventArns: [Swift.String]?

    public init(
        awsAccountIds: [Swift.String]? = nil,
        eventArns: [Swift.String]? = nil
    )
    {
        self.awsAccountIds = awsAccountIds
        self.eventArns = eventArns
    }
}

struct DescribeEntityAggregatesForOrganizationInputBody: Swift.Equatable {
    let eventArns: [Swift.String]?
    let awsAccountIds: [Swift.String]?
}

extension DescribeEntityAggregatesForOrganizationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsAccountIds
        case eventArns
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .eventArns)
        var eventArnsDecoded0:[Swift.String]? = nil
        if let eventArnsContainer = eventArnsContainer {
            eventArnsDecoded0 = [Swift.String]()
            for string0 in eventArnsContainer {
                if let string0 = string0 {
                    eventArnsDecoded0?.append(string0)
                }
            }
        }
        eventArns = eventArnsDecoded0
        let awsAccountIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .awsAccountIds)
        var awsAccountIdsDecoded0:[Swift.String]? = nil
        if let awsAccountIdsContainer = awsAccountIdsContainer {
            awsAccountIdsDecoded0 = [Swift.String]()
            for string0 in awsAccountIdsContainer {
                if let string0 = string0 {
                    awsAccountIdsDecoded0?.append(string0)
                }
            }
        }
        awsAccountIds = awsAccountIdsDecoded0
    }
}

extension DescribeEntityAggregatesForOrganizationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeEntityAggregatesForOrganizationOutputBody = try responseDecoder.decode(responseBody: data)
            self.organizationEntityAggregates = output.organizationEntityAggregates
        } else {
            self.organizationEntityAggregates = nil
        }
    }
}

public struct DescribeEntityAggregatesForOrganizationOutput: Swift.Equatable {
    /// The list of entity aggregates for each of the specified accounts that are affected by each of the specified events.
    public var organizationEntityAggregates: [HealthClientTypes.OrganizationEntityAggregate]?

    public init(
        organizationEntityAggregates: [HealthClientTypes.OrganizationEntityAggregate]? = nil
    )
    {
        self.organizationEntityAggregates = organizationEntityAggregates
    }
}

struct DescribeEntityAggregatesForOrganizationOutputBody: Swift.Equatable {
    let organizationEntityAggregates: [HealthClientTypes.OrganizationEntityAggregate]?
}

extension DescribeEntityAggregatesForOrganizationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case organizationEntityAggregates
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationEntityAggregatesContainer = try containerValues.decodeIfPresent([HealthClientTypes.OrganizationEntityAggregate?].self, forKey: .organizationEntityAggregates)
        var organizationEntityAggregatesDecoded0:[HealthClientTypes.OrganizationEntityAggregate]? = nil
        if let organizationEntityAggregatesContainer = organizationEntityAggregatesContainer {
            organizationEntityAggregatesDecoded0 = [HealthClientTypes.OrganizationEntityAggregate]()
            for structure0 in organizationEntityAggregatesContainer {
                if let structure0 = structure0 {
                    organizationEntityAggregatesDecoded0?.append(structure0)
                }
            }
        }
        organizationEntityAggregates = organizationEntityAggregatesDecoded0
    }
}

enum DescribeEntityAggregatesForOrganizationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeEntityAggregatesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventArns
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eventArns = eventArns {
            var eventArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .eventArns)
            for eventarn0 in eventArns {
                try eventArnsContainer.encode(eventarn0)
            }
        }
    }
}

extension DescribeEntityAggregatesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeEntityAggregatesInput: Swift.Equatable {
    /// A list of event ARNs (unique identifiers). For example: "arn:aws:health:us-east-1::event/EC2/EC2_INSTANCE_RETIREMENT_SCHEDULED/EC2_INSTANCE_RETIREMENT_SCHEDULED_ABC123-CDE456", "arn:aws:health:us-west-1::event/EBS/AWS_EBS_LOST_VOLUME/AWS_EBS_LOST_VOLUME_CHI789_JKL101"
    public var eventArns: [Swift.String]?

    public init(
        eventArns: [Swift.String]? = nil
    )
    {
        self.eventArns = eventArns
    }
}

struct DescribeEntityAggregatesInputBody: Swift.Equatable {
    let eventArns: [Swift.String]?
}

extension DescribeEntityAggregatesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventArns
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .eventArns)
        var eventArnsDecoded0:[Swift.String]? = nil
        if let eventArnsContainer = eventArnsContainer {
            eventArnsDecoded0 = [Swift.String]()
            for string0 in eventArnsContainer {
                if let string0 = string0 {
                    eventArnsDecoded0?.append(string0)
                }
            }
        }
        eventArns = eventArnsDecoded0
    }
}

extension DescribeEntityAggregatesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeEntityAggregatesOutputBody = try responseDecoder.decode(responseBody: data)
            self.entityAggregates = output.entityAggregates
        } else {
            self.entityAggregates = nil
        }
    }
}

public struct DescribeEntityAggregatesOutput: Swift.Equatable {
    /// The number of entities that are affected by each of the specified events.
    public var entityAggregates: [HealthClientTypes.EntityAggregate]?

    public init(
        entityAggregates: [HealthClientTypes.EntityAggregate]? = nil
    )
    {
        self.entityAggregates = entityAggregates
    }
}

struct DescribeEntityAggregatesOutputBody: Swift.Equatable {
    let entityAggregates: [HealthClientTypes.EntityAggregate]?
}

extension DescribeEntityAggregatesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entityAggregates
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let entityAggregatesContainer = try containerValues.decodeIfPresent([HealthClientTypes.EntityAggregate?].self, forKey: .entityAggregates)
        var entityAggregatesDecoded0:[HealthClientTypes.EntityAggregate]? = nil
        if let entityAggregatesContainer = entityAggregatesContainer {
            entityAggregatesDecoded0 = [HealthClientTypes.EntityAggregate]()
            for structure0 in entityAggregatesContainer {
                if let structure0 = structure0 {
                    entityAggregatesDecoded0?.append(structure0)
                }
            }
        }
        entityAggregates = entityAggregatesDecoded0
    }
}

enum DescribeEntityAggregatesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeEventAggregatesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aggregateField
        case filter
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aggregateField = self.aggregateField {
            try encodeContainer.encode(aggregateField.rawValue, forKey: .aggregateField)
        }
        if let filter = self.filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension DescribeEventAggregatesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeEventAggregatesInput: Swift.Equatable {
    /// The only currently supported value is eventTypeCategory.
    /// This member is required.
    public var aggregateField: HealthClientTypes.EventAggregateField?
    /// Values to narrow the results returned.
    public var filter: HealthClientTypes.EventFilter?
    /// The maximum number of items to return in one batch, between 10 and 100, inclusive.
    public var maxResults: Swift.Int?
    /// If the results of a search are large, only a portion of the results are returned, and a nextToken pagination token is returned in the response. To retrieve the next batch of results, reissue the search request and include the returned token. When all results have been returned, the response does not contain a pagination token value.
    public var nextToken: Swift.String?

    public init(
        aggregateField: HealthClientTypes.EventAggregateField? = nil,
        filter: HealthClientTypes.EventFilter? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.aggregateField = aggregateField
        self.filter = filter
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeEventAggregatesInputBody: Swift.Equatable {
    let filter: HealthClientTypes.EventFilter?
    let aggregateField: HealthClientTypes.EventAggregateField?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension DescribeEventAggregatesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aggregateField
        case filter
        case maxResults
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filterDecoded = try containerValues.decodeIfPresent(HealthClientTypes.EventFilter.self, forKey: .filter)
        filter = filterDecoded
        let aggregateFieldDecoded = try containerValues.decodeIfPresent(HealthClientTypes.EventAggregateField.self, forKey: .aggregateField)
        aggregateField = aggregateFieldDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeEventAggregatesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeEventAggregatesOutputBody = try responseDecoder.decode(responseBody: data)
            self.eventAggregates = output.eventAggregates
            self.nextToken = output.nextToken
        } else {
            self.eventAggregates = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeEventAggregatesOutput: Swift.Equatable {
    /// The number of events in each category that meet the optional filter criteria.
    public var eventAggregates: [HealthClientTypes.EventAggregate]?
    /// If the results of a search are large, only a portion of the results are returned, and a nextToken pagination token is returned in the response. To retrieve the next batch of results, reissue the search request and include the returned token. When all results have been returned, the response does not contain a pagination token value.
    public var nextToken: Swift.String?

    public init(
        eventAggregates: [HealthClientTypes.EventAggregate]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.eventAggregates = eventAggregates
        self.nextToken = nextToken
    }
}

struct DescribeEventAggregatesOutputBody: Swift.Equatable {
    let eventAggregates: [HealthClientTypes.EventAggregate]?
    let nextToken: Swift.String?
}

extension DescribeEventAggregatesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventAggregates
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventAggregatesContainer = try containerValues.decodeIfPresent([HealthClientTypes.EventAggregate?].self, forKey: .eventAggregates)
        var eventAggregatesDecoded0:[HealthClientTypes.EventAggregate]? = nil
        if let eventAggregatesContainer = eventAggregatesContainer {
            eventAggregatesDecoded0 = [HealthClientTypes.EventAggregate]()
            for structure0 in eventAggregatesContainer {
                if let structure0 = structure0 {
                    eventAggregatesDecoded0?.append(structure0)
                }
            }
        }
        eventAggregates = eventAggregatesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum DescribeEventAggregatesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidPaginationToken": return try await InvalidPaginationToken(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeEventDetailsForOrganizationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case locale
        case organizationEventDetailFilters
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let locale = self.locale {
            try encodeContainer.encode(locale, forKey: .locale)
        }
        if let organizationEventDetailFilters = organizationEventDetailFilters {
            var organizationEventDetailFiltersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .organizationEventDetailFilters)
            for eventaccountfilter0 in organizationEventDetailFilters {
                try organizationEventDetailFiltersContainer.encode(eventaccountfilter0)
            }
        }
    }
}

extension DescribeEventDetailsForOrganizationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeEventDetailsForOrganizationInput: Swift.Equatable {
    /// The locale (language) to return information in. English (en) is the default and the only supported value at this time.
    public var locale: Swift.String?
    /// A set of JSON elements that includes the awsAccountId and the eventArn.
    /// This member is required.
    public var organizationEventDetailFilters: [HealthClientTypes.EventAccountFilter]?

    public init(
        locale: Swift.String? = nil,
        organizationEventDetailFilters: [HealthClientTypes.EventAccountFilter]? = nil
    )
    {
        self.locale = locale
        self.organizationEventDetailFilters = organizationEventDetailFilters
    }
}

struct DescribeEventDetailsForOrganizationInputBody: Swift.Equatable {
    let organizationEventDetailFilters: [HealthClientTypes.EventAccountFilter]?
    let locale: Swift.String?
}

extension DescribeEventDetailsForOrganizationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case locale
        case organizationEventDetailFilters
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationEventDetailFiltersContainer = try containerValues.decodeIfPresent([HealthClientTypes.EventAccountFilter?].self, forKey: .organizationEventDetailFilters)
        var organizationEventDetailFiltersDecoded0:[HealthClientTypes.EventAccountFilter]? = nil
        if let organizationEventDetailFiltersContainer = organizationEventDetailFiltersContainer {
            organizationEventDetailFiltersDecoded0 = [HealthClientTypes.EventAccountFilter]()
            for structure0 in organizationEventDetailFiltersContainer {
                if let structure0 = structure0 {
                    organizationEventDetailFiltersDecoded0?.append(structure0)
                }
            }
        }
        organizationEventDetailFilters = organizationEventDetailFiltersDecoded0
        let localeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .locale)
        locale = localeDecoded
    }
}

extension DescribeEventDetailsForOrganizationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeEventDetailsForOrganizationOutputBody = try responseDecoder.decode(responseBody: data)
            self.failedSet = output.failedSet
            self.successfulSet = output.successfulSet
        } else {
            self.failedSet = nil
            self.successfulSet = nil
        }
    }
}

public struct DescribeEventDetailsForOrganizationOutput: Swift.Equatable {
    /// Error messages for any events that could not be retrieved.
    public var failedSet: [HealthClientTypes.OrganizationEventDetailsErrorItem]?
    /// Information about the events that could be retrieved.
    public var successfulSet: [HealthClientTypes.OrganizationEventDetails]?

    public init(
        failedSet: [HealthClientTypes.OrganizationEventDetailsErrorItem]? = nil,
        successfulSet: [HealthClientTypes.OrganizationEventDetails]? = nil
    )
    {
        self.failedSet = failedSet
        self.successfulSet = successfulSet
    }
}

struct DescribeEventDetailsForOrganizationOutputBody: Swift.Equatable {
    let successfulSet: [HealthClientTypes.OrganizationEventDetails]?
    let failedSet: [HealthClientTypes.OrganizationEventDetailsErrorItem]?
}

extension DescribeEventDetailsForOrganizationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failedSet
        case successfulSet
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let successfulSetContainer = try containerValues.decodeIfPresent([HealthClientTypes.OrganizationEventDetails?].self, forKey: .successfulSet)
        var successfulSetDecoded0:[HealthClientTypes.OrganizationEventDetails]? = nil
        if let successfulSetContainer = successfulSetContainer {
            successfulSetDecoded0 = [HealthClientTypes.OrganizationEventDetails]()
            for structure0 in successfulSetContainer {
                if let structure0 = structure0 {
                    successfulSetDecoded0?.append(structure0)
                }
            }
        }
        successfulSet = successfulSetDecoded0
        let failedSetContainer = try containerValues.decodeIfPresent([HealthClientTypes.OrganizationEventDetailsErrorItem?].self, forKey: .failedSet)
        var failedSetDecoded0:[HealthClientTypes.OrganizationEventDetailsErrorItem]? = nil
        if let failedSetContainer = failedSetContainer {
            failedSetDecoded0 = [HealthClientTypes.OrganizationEventDetailsErrorItem]()
            for structure0 in failedSetContainer {
                if let structure0 = structure0 {
                    failedSetDecoded0?.append(structure0)
                }
            }
        }
        failedSet = failedSetDecoded0
    }
}

enum DescribeEventDetailsForOrganizationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "UnsupportedLocale": return try await UnsupportedLocale(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeEventDetailsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventArns
        case locale
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eventArns = eventArns {
            var eventArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .eventArns)
            for eventarn0 in eventArns {
                try eventArnsContainer.encode(eventarn0)
            }
        }
        if let locale = self.locale {
            try encodeContainer.encode(locale, forKey: .locale)
        }
    }
}

extension DescribeEventDetailsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeEventDetailsInput: Swift.Equatable {
    /// A list of event ARNs (unique identifiers). For example: "arn:aws:health:us-east-1::event/EC2/EC2_INSTANCE_RETIREMENT_SCHEDULED/EC2_INSTANCE_RETIREMENT_SCHEDULED_ABC123-CDE456", "arn:aws:health:us-west-1::event/EBS/AWS_EBS_LOST_VOLUME/AWS_EBS_LOST_VOLUME_CHI789_JKL101"
    /// This member is required.
    public var eventArns: [Swift.String]?
    /// The locale (language) to return information in. English (en) is the default and the only supported value at this time.
    public var locale: Swift.String?

    public init(
        eventArns: [Swift.String]? = nil,
        locale: Swift.String? = nil
    )
    {
        self.eventArns = eventArns
        self.locale = locale
    }
}

struct DescribeEventDetailsInputBody: Swift.Equatable {
    let eventArns: [Swift.String]?
    let locale: Swift.String?
}

extension DescribeEventDetailsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventArns
        case locale
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .eventArns)
        var eventArnsDecoded0:[Swift.String]? = nil
        if let eventArnsContainer = eventArnsContainer {
            eventArnsDecoded0 = [Swift.String]()
            for string0 in eventArnsContainer {
                if let string0 = string0 {
                    eventArnsDecoded0?.append(string0)
                }
            }
        }
        eventArns = eventArnsDecoded0
        let localeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .locale)
        locale = localeDecoded
    }
}

extension DescribeEventDetailsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeEventDetailsOutputBody = try responseDecoder.decode(responseBody: data)
            self.failedSet = output.failedSet
            self.successfulSet = output.successfulSet
        } else {
            self.failedSet = nil
            self.successfulSet = nil
        }
    }
}

public struct DescribeEventDetailsOutput: Swift.Equatable {
    /// Error messages for any events that could not be retrieved.
    public var failedSet: [HealthClientTypes.EventDetailsErrorItem]?
    /// Information about the events that could be retrieved.
    public var successfulSet: [HealthClientTypes.EventDetails]?

    public init(
        failedSet: [HealthClientTypes.EventDetailsErrorItem]? = nil,
        successfulSet: [HealthClientTypes.EventDetails]? = nil
    )
    {
        self.failedSet = failedSet
        self.successfulSet = successfulSet
    }
}

struct DescribeEventDetailsOutputBody: Swift.Equatable {
    let successfulSet: [HealthClientTypes.EventDetails]?
    let failedSet: [HealthClientTypes.EventDetailsErrorItem]?
}

extension DescribeEventDetailsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failedSet
        case successfulSet
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let successfulSetContainer = try containerValues.decodeIfPresent([HealthClientTypes.EventDetails?].self, forKey: .successfulSet)
        var successfulSetDecoded0:[HealthClientTypes.EventDetails]? = nil
        if let successfulSetContainer = successfulSetContainer {
            successfulSetDecoded0 = [HealthClientTypes.EventDetails]()
            for structure0 in successfulSetContainer {
                if let structure0 = structure0 {
                    successfulSetDecoded0?.append(structure0)
                }
            }
        }
        successfulSet = successfulSetDecoded0
        let failedSetContainer = try containerValues.decodeIfPresent([HealthClientTypes.EventDetailsErrorItem?].self, forKey: .failedSet)
        var failedSetDecoded0:[HealthClientTypes.EventDetailsErrorItem]? = nil
        if let failedSetContainer = failedSetContainer {
            failedSetDecoded0 = [HealthClientTypes.EventDetailsErrorItem]()
            for structure0 in failedSetContainer {
                if let structure0 = structure0 {
                    failedSetDecoded0?.append(structure0)
                }
            }
        }
        failedSet = failedSetDecoded0
    }
}

enum DescribeEventDetailsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "UnsupportedLocale": return try await UnsupportedLocale(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeEventTypesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter
        case locale
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filter = self.filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
        if let locale = self.locale {
            try encodeContainer.encode(locale, forKey: .locale)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension DescribeEventTypesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeEventTypesInput: Swift.Equatable {
    /// Values to narrow the results returned.
    public var filter: HealthClientTypes.EventTypeFilter?
    /// The locale (language) to return information in. English (en) is the default and the only supported value at this time.
    public var locale: Swift.String?
    /// The maximum number of items to return in one batch, between 10 and 100, inclusive. If you don't specify the maxResults parameter, this operation returns a maximum of 30 items by default.
    public var maxResults: Swift.Int?
    /// If the results of a search are large, only a portion of the results are returned, and a nextToken pagination token is returned in the response. To retrieve the next batch of results, reissue the search request and include the returned token. When all results have been returned, the response does not contain a pagination token value.
    public var nextToken: Swift.String?

    public init(
        filter: HealthClientTypes.EventTypeFilter? = nil,
        locale: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filter = filter
        self.locale = locale
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeEventTypesInputBody: Swift.Equatable {
    let filter: HealthClientTypes.EventTypeFilter?
    let locale: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension DescribeEventTypesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter
        case locale
        case maxResults
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filterDecoded = try containerValues.decodeIfPresent(HealthClientTypes.EventTypeFilter.self, forKey: .filter)
        filter = filterDecoded
        let localeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .locale)
        locale = localeDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension DescribeEventTypesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeEventTypesOutputBody = try responseDecoder.decode(responseBody: data)
            self.eventTypes = output.eventTypes
            self.nextToken = output.nextToken
        } else {
            self.eventTypes = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeEventTypesOutput: Swift.Equatable {
    /// A list of event types that match the filter criteria. Event types have a category (issue, accountNotification, or scheduledChange), a service (for example, EC2, RDS, DATAPIPELINE, BILLING), and a code (in the format AWS_SERVICE_DESCRIPTION ; for example, AWS_EC2_SYSTEM_MAINTENANCE_EVENT).
    public var eventTypes: [HealthClientTypes.EventType]?
    /// If the results of a search are large, only a portion of the results are returned, and a nextToken pagination token is returned in the response. To retrieve the next batch of results, reissue the search request and include the returned token. When all results have been returned, the response does not contain a pagination token value.
    public var nextToken: Swift.String?

    public init(
        eventTypes: [HealthClientTypes.EventType]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.eventTypes = eventTypes
        self.nextToken = nextToken
    }
}

struct DescribeEventTypesOutputBody: Swift.Equatable {
    let eventTypes: [HealthClientTypes.EventType]?
    let nextToken: Swift.String?
}

extension DescribeEventTypesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventTypes
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventTypesContainer = try containerValues.decodeIfPresent([HealthClientTypes.EventType?].self, forKey: .eventTypes)
        var eventTypesDecoded0:[HealthClientTypes.EventType]? = nil
        if let eventTypesContainer = eventTypesContainer {
            eventTypesDecoded0 = [HealthClientTypes.EventType]()
            for structure0 in eventTypesContainer {
                if let structure0 = structure0 {
                    eventTypesDecoded0?.append(structure0)
                }
            }
        }
        eventTypes = eventTypesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum DescribeEventTypesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidPaginationToken": return try await InvalidPaginationToken(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnsupportedLocale": return try await UnsupportedLocale(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeEventsForOrganizationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter
        case locale
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filter = self.filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
        if let locale = self.locale {
            try encodeContainer.encode(locale, forKey: .locale)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension DescribeEventsForOrganizationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeEventsForOrganizationInput: Swift.Equatable {
    /// Values to narrow the results returned.
    public var filter: HealthClientTypes.OrganizationEventFilter?
    /// The locale (language) to return information in. English (en) is the default and the only supported value at this time.
    public var locale: Swift.String?
    /// The maximum number of items to return in one batch, between 10 and 100, inclusive.
    public var maxResults: Swift.Int?
    /// If the results of a search are large, only a portion of the results are returned, and a nextToken pagination token is returned in the response. To retrieve the next batch of results, reissue the search request and include the returned token. When all results have been returned, the response does not contain a pagination token value.
    public var nextToken: Swift.String?

    public init(
        filter: HealthClientTypes.OrganizationEventFilter? = nil,
        locale: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filter = filter
        self.locale = locale
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeEventsForOrganizationInputBody: Swift.Equatable {
    let filter: HealthClientTypes.OrganizationEventFilter?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
    let locale: Swift.String?
}

extension DescribeEventsForOrganizationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter
        case locale
        case maxResults
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filterDecoded = try containerValues.decodeIfPresent(HealthClientTypes.OrganizationEventFilter.self, forKey: .filter)
        filter = filterDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let localeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .locale)
        locale = localeDecoded
    }
}

extension DescribeEventsForOrganizationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeEventsForOrganizationOutputBody = try responseDecoder.decode(responseBody: data)
            self.events = output.events
            self.nextToken = output.nextToken
        } else {
            self.events = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeEventsForOrganizationOutput: Swift.Equatable {
    /// The events that match the specified filter criteria.
    public var events: [HealthClientTypes.OrganizationEvent]?
    /// If the results of a search are large, only a portion of the results are returned, and a nextToken pagination token is returned in the response. To retrieve the next batch of results, reissue the search request and include the returned token. When all results have been returned, the response does not contain a pagination token value.
    public var nextToken: Swift.String?

    public init(
        events: [HealthClientTypes.OrganizationEvent]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.events = events
        self.nextToken = nextToken
    }
}

struct DescribeEventsForOrganizationOutputBody: Swift.Equatable {
    let events: [HealthClientTypes.OrganizationEvent]?
    let nextToken: Swift.String?
}

extension DescribeEventsForOrganizationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case events
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventsContainer = try containerValues.decodeIfPresent([HealthClientTypes.OrganizationEvent?].self, forKey: .events)
        var eventsDecoded0:[HealthClientTypes.OrganizationEvent]? = nil
        if let eventsContainer = eventsContainer {
            eventsDecoded0 = [HealthClientTypes.OrganizationEvent]()
            for structure0 in eventsContainer {
                if let structure0 = structure0 {
                    eventsDecoded0?.append(structure0)
                }
            }
        }
        events = eventsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum DescribeEventsForOrganizationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidPaginationToken": return try await InvalidPaginationToken(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnsupportedLocale": return try await UnsupportedLocale(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeEventsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter
        case locale
        case maxResults
        case nextToken
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filter = self.filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
        if let locale = self.locale {
            try encodeContainer.encode(locale, forKey: .locale)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
    }
}

extension DescribeEventsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeEventsInput: Swift.Equatable {
    /// Values to narrow the results returned.
    public var filter: HealthClientTypes.EventFilter?
    /// The locale (language) to return information in. English (en) is the default and the only supported value at this time.
    public var locale: Swift.String?
    /// The maximum number of items to return in one batch, between 10 and 100, inclusive.
    public var maxResults: Swift.Int?
    /// If the results of a search are large, only a portion of the results are returned, and a nextToken pagination token is returned in the response. To retrieve the next batch of results, reissue the search request and include the returned token. When all results have been returned, the response does not contain a pagination token value.
    public var nextToken: Swift.String?

    public init(
        filter: HealthClientTypes.EventFilter? = nil,
        locale: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filter = filter
        self.locale = locale
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeEventsInputBody: Swift.Equatable {
    let filter: HealthClientTypes.EventFilter?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
    let locale: Swift.String?
}

extension DescribeEventsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter
        case locale
        case maxResults
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filterDecoded = try containerValues.decodeIfPresent(HealthClientTypes.EventFilter.self, forKey: .filter)
        filter = filterDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let localeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .locale)
        locale = localeDecoded
    }
}

extension DescribeEventsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeEventsOutputBody = try responseDecoder.decode(responseBody: data)
            self.events = output.events
            self.nextToken = output.nextToken
        } else {
            self.events = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeEventsOutput: Swift.Equatable {
    /// The events that match the specified filter criteria.
    public var events: [HealthClientTypes.Event]?
    /// If the results of a search are large, only a portion of the results are returned, and a nextToken pagination token is returned in the response. To retrieve the next batch of results, reissue the search request and include the returned token. When all results have been returned, the response does not contain a pagination token value.
    public var nextToken: Swift.String?

    public init(
        events: [HealthClientTypes.Event]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.events = events
        self.nextToken = nextToken
    }
}

struct DescribeEventsOutputBody: Swift.Equatable {
    let events: [HealthClientTypes.Event]?
    let nextToken: Swift.String?
}

extension DescribeEventsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case events
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventsContainer = try containerValues.decodeIfPresent([HealthClientTypes.Event?].self, forKey: .events)
        var eventsDecoded0:[HealthClientTypes.Event]? = nil
        if let eventsContainer = eventsContainer {
            eventsDecoded0 = [HealthClientTypes.Event]()
            for structure0 in eventsContainer {
                if let structure0 = structure0 {
                    eventsDecoded0?.append(structure0)
                }
            }
        }
        events = eventsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum DescribeEventsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidPaginationToken": return try await InvalidPaginationToken(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnsupportedLocale": return try await UnsupportedLocale(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeHealthServiceStatusForOrganizationInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension DescribeHealthServiceStatusForOrganizationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeHealthServiceStatusForOrganizationInput: Swift.Equatable {

    public init() { }
}

struct DescribeHealthServiceStatusForOrganizationInputBody: Swift.Equatable {
}

extension DescribeHealthServiceStatusForOrganizationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeHealthServiceStatusForOrganizationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeHealthServiceStatusForOrganizationOutputBody = try responseDecoder.decode(responseBody: data)
            self.healthServiceAccessStatusForOrganization = output.healthServiceAccessStatusForOrganization
        } else {
            self.healthServiceAccessStatusForOrganization = nil
        }
    }
}

public struct DescribeHealthServiceStatusForOrganizationOutput: Swift.Equatable {
    /// Information about the status of enabling or disabling the Health organizational view feature in your organization. Valid values are ENABLED | DISABLED | PENDING.
    public var healthServiceAccessStatusForOrganization: Swift.String?

    public init(
        healthServiceAccessStatusForOrganization: Swift.String? = nil
    )
    {
        self.healthServiceAccessStatusForOrganization = healthServiceAccessStatusForOrganization
    }
}

struct DescribeHealthServiceStatusForOrganizationOutputBody: Swift.Equatable {
    let healthServiceAccessStatusForOrganization: Swift.String?
}

extension DescribeHealthServiceStatusForOrganizationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case healthServiceAccessStatusForOrganization
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let healthServiceAccessStatusForOrganizationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .healthServiceAccessStatusForOrganization)
        healthServiceAccessStatusForOrganization = healthServiceAccessStatusForOrganizationDecoded
    }
}

enum DescribeHealthServiceStatusForOrganizationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DisableHealthServiceAccessForOrganizationInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension DisableHealthServiceAccessForOrganizationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DisableHealthServiceAccessForOrganizationInput: Swift.Equatable {

    public init() { }
}

struct DisableHealthServiceAccessForOrganizationInputBody: Swift.Equatable {
}

extension DisableHealthServiceAccessForOrganizationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DisableHealthServiceAccessForOrganizationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DisableHealthServiceAccessForOrganizationOutput: Swift.Equatable {

    public init() { }
}

enum DisableHealthServiceAccessForOrganizationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConcurrentModificationException": return try await ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension EnableHealthServiceAccessForOrganizationInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension EnableHealthServiceAccessForOrganizationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct EnableHealthServiceAccessForOrganizationInput: Swift.Equatable {

    public init() { }
}

struct EnableHealthServiceAccessForOrganizationInputBody: Swift.Equatable {
}

extension EnableHealthServiceAccessForOrganizationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension EnableHealthServiceAccessForOrganizationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct EnableHealthServiceAccessForOrganizationOutput: Swift.Equatable {

    public init() { }
}

enum EnableHealthServiceAccessForOrganizationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ConcurrentModificationException": return try await ConcurrentModificationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension HealthClientTypes.EntityAccountFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsAccountId
        case eventArn
        case statusCodes
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let awsAccountId = self.awsAccountId {
            try encodeContainer.encode(awsAccountId, forKey: .awsAccountId)
        }
        if let eventArn = self.eventArn {
            try encodeContainer.encode(eventArn, forKey: .eventArn)
        }
        if let statusCodes = statusCodes {
            var statusCodesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .statusCodes)
            for entitystatuscode0 in statusCodes {
                try statusCodesContainer.encode(entitystatuscode0.rawValue)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventArn)
        eventArn = eventArnDecoded
        let awsAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsAccountId)
        awsAccountId = awsAccountIdDecoded
        let statusCodesContainer = try containerValues.decodeIfPresent([HealthClientTypes.EntityStatusCode?].self, forKey: .statusCodes)
        var statusCodesDecoded0:[HealthClientTypes.EntityStatusCode]? = nil
        if let statusCodesContainer = statusCodesContainer {
            statusCodesDecoded0 = [HealthClientTypes.EntityStatusCode]()
            for enum0 in statusCodesContainer {
                if let enum0 = enum0 {
                    statusCodesDecoded0?.append(enum0)
                }
            }
        }
        statusCodes = statusCodesDecoded0
    }
}

extension HealthClientTypes {
    /// A JSON set of elements including the awsAccountId, eventArn and a set of statusCodes.
    public struct EntityAccountFilter: Swift.Equatable {
        /// The 12-digit Amazon Web Services account numbers that contains the affected entities.
        public var awsAccountId: Swift.String?
        /// The unique identifier for the event. The event ARN has the arn:aws:health:event-region::event/SERVICE/EVENT_TYPE_CODE/EVENT_TYPE_PLUS_ID  format. For example, an event ARN might look like the following: arn:aws:health:us-east-1::event/EC2/EC2_INSTANCE_RETIREMENT_SCHEDULED/EC2_INSTANCE_RETIREMENT_SCHEDULED_ABC123-DEF456
        /// This member is required.
        public var eventArn: Swift.String?
        /// A list of entity status codes.
        public var statusCodes: [HealthClientTypes.EntityStatusCode]?

        public init(
            awsAccountId: Swift.String? = nil,
            eventArn: Swift.String? = nil,
            statusCodes: [HealthClientTypes.EntityStatusCode]? = nil
        )
        {
            self.awsAccountId = awsAccountId
            self.eventArn = eventArn
            self.statusCodes = statusCodes
        }
    }

}

extension HealthClientTypes.EntityAggregate: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case count
        case eventArn
        case statuses
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if count != 0 {
            try encodeContainer.encode(count, forKey: .count)
        }
        if let eventArn = self.eventArn {
            try encodeContainer.encode(eventArn, forKey: .eventArn)
        }
        if let statuses = statuses {
            var statusesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .statuses)
            for (dictKey0, entityStatuses0) in statuses {
                try statusesContainer.encode(entityStatuses0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventArn)
        eventArn = eventArnDecoded
        let countDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .count) ?? 0
        count = countDecoded
        let statusesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.Int?].self, forKey: .statuses)
        var statusesDecoded0: [Swift.String:Swift.Int]? = nil
        if let statusesContainer = statusesContainer {
            statusesDecoded0 = [Swift.String:Swift.Int]()
            for (key0, count0) in statusesContainer {
                if let count0 = count0 {
                    statusesDecoded0?[key0] = count0
                }
            }
        }
        statuses = statusesDecoded0
    }
}

extension HealthClientTypes {
    /// The number of entities that are affected by one or more events. Returned by the [DescribeEntityAggregates](https://docs.aws.amazon.com/health/latest/APIReference/API_DescribeEntityAggregates.html) operation.
    public struct EntityAggregate: Swift.Equatable {
        /// The number of entities that match the criteria for the specified events.
        public var count: Swift.Int
        /// The unique identifier for the event. The event ARN has the arn:aws:health:event-region::event/SERVICE/EVENT_TYPE_CODE/EVENT_TYPE_PLUS_ID  format. For example, an event ARN might look like the following: arn:aws:health:us-east-1::event/EC2/EC2_INSTANCE_RETIREMENT_SCHEDULED/EC2_INSTANCE_RETIREMENT_SCHEDULED_ABC123-DEF456
        public var eventArn: Swift.String?
        /// The number of affected entities aggregated by the entity status codes.
        public var statuses: [Swift.String:Swift.Int]?

        public init(
            count: Swift.Int = 0,
            eventArn: Swift.String? = nil,
            statuses: [Swift.String:Swift.Int]? = nil
        )
        {
            self.count = count
            self.eventArn = eventArn
            self.statuses = statuses
        }
    }

}

extension HealthClientTypes.EntityFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case entityArns
        case entityValues
        case eventArns
        case lastUpdatedTimes
        case statusCodes
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let entityArns = entityArns {
            var entityArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .entityArns)
            for entityarn0 in entityArns {
                try entityArnsContainer.encode(entityarn0)
            }
        }
        if let entityValues = entityValues {
            var entityValuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .entityValues)
            for entityvalue0 in entityValues {
                try entityValuesContainer.encode(entityvalue0)
            }
        }
        if let eventArns = eventArns {
            var eventArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .eventArns)
            for eventarn0 in eventArns {
                try eventArnsContainer.encode(eventarn0)
            }
        }
        if let lastUpdatedTimes = lastUpdatedTimes {
            var lastUpdatedTimesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .lastUpdatedTimes)
            for datetimerange0 in lastUpdatedTimes {
                try lastUpdatedTimesContainer.encode(datetimerange0)
            }
        }
        if let statusCodes = statusCodes {
            var statusCodesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .statusCodes)
            for entitystatuscode0 in statusCodes {
                try statusCodesContainer.encode(entitystatuscode0.rawValue)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tagset0 in tags {
                var tagset0Container = tagsContainer.nestedContainer(keyedBy: ClientRuntime.Key.self)
                for (dictKey1, tagSet1) in tagset0 {
                    try tagset0Container.encode(tagSet1, forKey: ClientRuntime.Key(stringValue: dictKey1))
                }
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .eventArns)
        var eventArnsDecoded0:[Swift.String]? = nil
        if let eventArnsContainer = eventArnsContainer {
            eventArnsDecoded0 = [Swift.String]()
            for string0 in eventArnsContainer {
                if let string0 = string0 {
                    eventArnsDecoded0?.append(string0)
                }
            }
        }
        eventArns = eventArnsDecoded0
        let entityArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .entityArns)
        var entityArnsDecoded0:[Swift.String]? = nil
        if let entityArnsContainer = entityArnsContainer {
            entityArnsDecoded0 = [Swift.String]()
            for string0 in entityArnsContainer {
                if let string0 = string0 {
                    entityArnsDecoded0?.append(string0)
                }
            }
        }
        entityArns = entityArnsDecoded0
        let entityValuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .entityValues)
        var entityValuesDecoded0:[Swift.String]? = nil
        if let entityValuesContainer = entityValuesContainer {
            entityValuesDecoded0 = [Swift.String]()
            for string0 in entityValuesContainer {
                if let string0 = string0 {
                    entityValuesDecoded0?.append(string0)
                }
            }
        }
        entityValues = entityValuesDecoded0
        let lastUpdatedTimesContainer = try containerValues.decodeIfPresent([HealthClientTypes.DateTimeRange?].self, forKey: .lastUpdatedTimes)
        var lastUpdatedTimesDecoded0:[HealthClientTypes.DateTimeRange]? = nil
        if let lastUpdatedTimesContainer = lastUpdatedTimesContainer {
            lastUpdatedTimesDecoded0 = [HealthClientTypes.DateTimeRange]()
            for structure0 in lastUpdatedTimesContainer {
                if let structure0 = structure0 {
                    lastUpdatedTimesDecoded0?.append(structure0)
                }
            }
        }
        lastUpdatedTimes = lastUpdatedTimesDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([[Swift.String: Swift.String?]?].self, forKey: .tags)
        var tagsDecoded0:[[Swift.String:Swift.String]]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [[Swift.String:Swift.String]]()
            for map0 in tagsContainer {
                var tagsContainerDecoded0: [Swift.String: Swift.String]? = nil
                if let map0 = map0 {
                    tagsContainerDecoded0 = [Swift.String: Swift.String]()
                    for (key1, tagvalue1) in map0 {
                        if let tagvalue1 = tagvalue1 {
                            tagsContainerDecoded0?[key1] = tagvalue1
                        }
                    }
                }
                if let tagsContainerDecoded0 = tagsContainerDecoded0 {
                    tagsDecoded0?.append(tagsContainerDecoded0)
                }
            }
        }
        tags = tagsDecoded0
        let statusCodesContainer = try containerValues.decodeIfPresent([HealthClientTypes.EntityStatusCode?].self, forKey: .statusCodes)
        var statusCodesDecoded0:[HealthClientTypes.EntityStatusCode]? = nil
        if let statusCodesContainer = statusCodesContainer {
            statusCodesDecoded0 = [HealthClientTypes.EntityStatusCode]()
            for enum0 in statusCodesContainer {
                if let enum0 = enum0 {
                    statusCodesDecoded0?.append(enum0)
                }
            }
        }
        statusCodes = statusCodesDecoded0
    }
}

extension HealthClientTypes {
    /// The values to use to filter results from the [DescribeAffectedEntities](https://docs.aws.amazon.com/health/latest/APIReference/API_DescribeAffectedEntities.html) operation.
    public struct EntityFilter: Swift.Equatable {
        /// A list of entity ARNs (unique identifiers).
        public var entityArns: [Swift.String]?
        /// A list of IDs for affected entities.
        public var entityValues: [Swift.String]?
        /// A list of event ARNs (unique identifiers). For example: "arn:aws:health:us-east-1::event/EC2/EC2_INSTANCE_RETIREMENT_SCHEDULED/EC2_INSTANCE_RETIREMENT_SCHEDULED_ABC123-CDE456", "arn:aws:health:us-west-1::event/EBS/AWS_EBS_LOST_VOLUME/AWS_EBS_LOST_VOLUME_CHI789_JKL101"
        /// This member is required.
        public var eventArns: [Swift.String]?
        /// A list of the most recent dates and times that the entity was updated.
        public var lastUpdatedTimes: [HealthClientTypes.DateTimeRange]?
        /// A list of entity status codes (IMPAIRED, UNIMPAIRED, or UNKNOWN).
        public var statusCodes: [HealthClientTypes.EntityStatusCode]?
        /// A map of entity tags attached to the affected entity. Currently, the tags property isn't supported.
        public var tags: [[Swift.String:Swift.String]]?

        public init(
            entityArns: [Swift.String]? = nil,
            entityValues: [Swift.String]? = nil,
            eventArns: [Swift.String]? = nil,
            lastUpdatedTimes: [HealthClientTypes.DateTimeRange]? = nil,
            statusCodes: [HealthClientTypes.EntityStatusCode]? = nil,
            tags: [[Swift.String:Swift.String]]? = nil
        )
        {
            self.entityArns = entityArns
            self.entityValues = entityValues
            self.eventArns = eventArns
            self.lastUpdatedTimes = lastUpdatedTimes
            self.statusCodes = statusCodes
            self.tags = tags
        }
    }

}

extension HealthClientTypes {
    public enum EntityStatusCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case impaired
        case pending
        case resolved
        case unimpaired
        case unknown
        case sdkUnknown(Swift.String)

        public static var allCases: [EntityStatusCode] {
            return [
                .impaired,
                .pending,
                .resolved,
                .unimpaired,
                .unknown,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .impaired: return "IMPAIRED"
            case .pending: return "PENDING"
            case .resolved: return "RESOLVED"
            case .unimpaired: return "UNIMPAIRED"
            case .unknown: return "UNKNOWN"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EntityStatusCode(rawValue: rawValue) ?? EntityStatusCode.sdkUnknown(rawValue)
        }
    }
}

extension HealthClientTypes.Event: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case availabilityZone
        case endTime
        case eventScopeCode
        case eventTypeCategory
        case eventTypeCode
        case lastUpdatedTime
        case region
        case service
        case startTime
        case statusCode
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let availabilityZone = self.availabilityZone {
            try encodeContainer.encode(availabilityZone, forKey: .availabilityZone)
        }
        if let endTime = self.endTime {
            try encodeContainer.encodeTimestamp(endTime, format: .epochSeconds, forKey: .endTime)
        }
        if let eventScopeCode = self.eventScopeCode {
            try encodeContainer.encode(eventScopeCode.rawValue, forKey: .eventScopeCode)
        }
        if let eventTypeCategory = self.eventTypeCategory {
            try encodeContainer.encode(eventTypeCategory.rawValue, forKey: .eventTypeCategory)
        }
        if let eventTypeCode = self.eventTypeCode {
            try encodeContainer.encode(eventTypeCode, forKey: .eventTypeCode)
        }
        if let lastUpdatedTime = self.lastUpdatedTime {
            try encodeContainer.encodeTimestamp(lastUpdatedTime, format: .epochSeconds, forKey: .lastUpdatedTime)
        }
        if let region = self.region {
            try encodeContainer.encode(region, forKey: .region)
        }
        if let service = self.service {
            try encodeContainer.encode(service, forKey: .service)
        }
        if let startTime = self.startTime {
            try encodeContainer.encodeTimestamp(startTime, format: .epochSeconds, forKey: .startTime)
        }
        if let statusCode = self.statusCode {
            try encodeContainer.encode(statusCode.rawValue, forKey: .statusCode)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let serviceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .service)
        service = serviceDecoded
        let eventTypeCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventTypeCode)
        eventTypeCode = eventTypeCodeDecoded
        let eventTypeCategoryDecoded = try containerValues.decodeIfPresent(HealthClientTypes.EventTypeCategory.self, forKey: .eventTypeCategory)
        eventTypeCategory = eventTypeCategoryDecoded
        let regionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .region)
        region = regionDecoded
        let availabilityZoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .availabilityZone)
        availabilityZone = availabilityZoneDecoded
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endTime)
        endTime = endTimeDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
        let statusCodeDecoded = try containerValues.decodeIfPresent(HealthClientTypes.EventStatusCode.self, forKey: .statusCode)
        statusCode = statusCodeDecoded
        let eventScopeCodeDecoded = try containerValues.decodeIfPresent(HealthClientTypes.EventScopeCode.self, forKey: .eventScopeCode)
        eventScopeCode = eventScopeCodeDecoded
    }
}

extension HealthClientTypes {
    /// Summary information about an Health event. Health events can be public or account-specific:
    ///
    /// * Public events might be service events that are not specific to an Amazon Web Services account. For example, if there is an issue with an Amazon Web Services Region, Health provides information about the event, even if you don't use services or resources in that Region.
    ///
    /// * Account-specific events are specific to either your Amazon Web Services account or an account in your organization. For example, if there's an issue with Amazon Elastic Compute Cloud in a Region that you use, Health provides information about the event and the affected resources in the account.
    ///
    ///
    /// You can determine if an event is public or account-specific by using the eventScopeCode parameter. For more information, see [eventScopeCode](https://docs.aws.amazon.com/health/latest/APIReference/API_Event.html#AWSHealth-Type-Event-eventScopeCode).
    public struct Event: Swift.Equatable {
        /// The unique identifier for the event. The event ARN has the arn:aws:health:event-region::event/SERVICE/EVENT_TYPE_CODE/EVENT_TYPE_PLUS_ID  format. For example, an event ARN might look like the following: arn:aws:health:us-east-1::event/EC2/EC2_INSTANCE_RETIREMENT_SCHEDULED/EC2_INSTANCE_RETIREMENT_SCHEDULED_ABC123-DEF456
        public var arn: Swift.String?
        /// The Amazon Web Services Availability Zone of the event. For example, us-east-1a.
        public var availabilityZone: Swift.String?
        /// The date and time that the event ended.
        public var endTime: ClientRuntime.Date?
        /// This parameter specifies if the Health event is a public Amazon Web Service event or an account-specific event.
        ///
        /// * If the eventScopeCode value is PUBLIC, then the affectedAccounts value is always empty.
        ///
        /// * If the eventScopeCode value is ACCOUNT_SPECIFIC, then the affectedAccounts value lists the affected Amazon Web Services accounts in your organization. For example, if an event affects a service such as Amazon Elastic Compute Cloud and you have Amazon Web Services accounts that use that service, those account IDs appear in the response.
        ///
        /// * If the eventScopeCode value is NONE, then the eventArn that you specified in the request is invalid or doesn't exist.
        public var eventScopeCode: HealthClientTypes.EventScopeCode?
        /// A list of event type category codes. Possible values are issue, accountNotification, or scheduledChange. Currently, the investigation value isn't supported at this time.
        public var eventTypeCategory: HealthClientTypes.EventTypeCategory?
        /// The unique identifier for the event type. The format is AWS_SERVICE_DESCRIPTION ; for example, AWS_EC2_SYSTEM_MAINTENANCE_EVENT.
        public var eventTypeCode: Swift.String?
        /// The most recent date and time that the event was updated.
        public var lastUpdatedTime: ClientRuntime.Date?
        /// The Amazon Web Services Region name of the event.
        public var region: Swift.String?
        /// The Amazon Web Service that is affected by the event. For example, EC2, RDS.
        public var service: Swift.String?
        /// The date and time that the event began.
        public var startTime: ClientRuntime.Date?
        /// The most recent status of the event. Possible values are open, closed, and upcoming.
        public var statusCode: HealthClientTypes.EventStatusCode?

        public init(
            arn: Swift.String? = nil,
            availabilityZone: Swift.String? = nil,
            endTime: ClientRuntime.Date? = nil,
            eventScopeCode: HealthClientTypes.EventScopeCode? = nil,
            eventTypeCategory: HealthClientTypes.EventTypeCategory? = nil,
            eventTypeCode: Swift.String? = nil,
            lastUpdatedTime: ClientRuntime.Date? = nil,
            region: Swift.String? = nil,
            service: Swift.String? = nil,
            startTime: ClientRuntime.Date? = nil,
            statusCode: HealthClientTypes.EventStatusCode? = nil
        )
        {
            self.arn = arn
            self.availabilityZone = availabilityZone
            self.endTime = endTime
            self.eventScopeCode = eventScopeCode
            self.eventTypeCategory = eventTypeCategory
            self.eventTypeCode = eventTypeCode
            self.lastUpdatedTime = lastUpdatedTime
            self.region = region
            self.service = service
            self.startTime = startTime
            self.statusCode = statusCode
        }
    }

}

extension HealthClientTypes.EventAccountFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsAccountId
        case eventArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let awsAccountId = self.awsAccountId {
            try encodeContainer.encode(awsAccountId, forKey: .awsAccountId)
        }
        if let eventArn = self.eventArn {
            try encodeContainer.encode(eventArn, forKey: .eventArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventArn)
        eventArn = eventArnDecoded
        let awsAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsAccountId)
        awsAccountId = awsAccountIdDecoded
    }
}

extension HealthClientTypes {
    /// The values used to filter results from the [DescribeEventDetailsForOrganization](https://docs.aws.amazon.com/health/latest/APIReference/API_DescribeEventDetailsForOrganization.html) and [DescribeAffectedEntitiesForOrganization](https://docs.aws.amazon.com/health/latest/APIReference/API_DescribeAffectedEntitiesForOrganization.html) operations.
    public struct EventAccountFilter: Swift.Equatable {
        /// The 12-digit Amazon Web Services account numbers that contains the affected entities.
        public var awsAccountId: Swift.String?
        /// The unique identifier for the event. The event ARN has the arn:aws:health:event-region::event/SERVICE/EVENT_TYPE_CODE/EVENT_TYPE_PLUS_ID  format. For example, an event ARN might look like the following: arn:aws:health:us-east-1::event/EC2/EC2_INSTANCE_RETIREMENT_SCHEDULED/EC2_INSTANCE_RETIREMENT_SCHEDULED_ABC123-DEF456
        /// This member is required.
        public var eventArn: Swift.String?

        public init(
            awsAccountId: Swift.String? = nil,
            eventArn: Swift.String? = nil
        )
        {
            self.awsAccountId = awsAccountId
            self.eventArn = eventArn
        }
    }

}

extension HealthClientTypes.EventAggregate: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case aggregateValue
        case count
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let aggregateValue = self.aggregateValue {
            try encodeContainer.encode(aggregateValue, forKey: .aggregateValue)
        }
        if count != 0 {
            try encodeContainer.encode(count, forKey: .count)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let aggregateValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .aggregateValue)
        aggregateValue = aggregateValueDecoded
        let countDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .count) ?? 0
        count = countDecoded
    }
}

extension HealthClientTypes {
    /// The number of events of each issue type. Returned by the [DescribeEventAggregates](https://docs.aws.amazon.com/health/latest/APIReference/API_DescribeEventAggregates.html) operation.
    public struct EventAggregate: Swift.Equatable {
        /// The issue type for the associated count.
        public var aggregateValue: Swift.String?
        /// The number of events of the associated issue type.
        public var count: Swift.Int

        public init(
            aggregateValue: Swift.String? = nil,
            count: Swift.Int = 0
        )
        {
            self.aggregateValue = aggregateValue
            self.count = count
        }
    }

}

extension HealthClientTypes {
    public enum EventAggregateField: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case eventtypecategory
        case sdkUnknown(Swift.String)

        public static var allCases: [EventAggregateField] {
            return [
                .eventtypecategory,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .eventtypecategory: return "eventTypeCategory"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EventAggregateField(rawValue: rawValue) ?? EventAggregateField.sdkUnknown(rawValue)
        }
    }
}

extension HealthClientTypes.EventDescription: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case latestDescription
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let latestDescription = self.latestDescription {
            try encodeContainer.encode(latestDescription, forKey: .latestDescription)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let latestDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .latestDescription)
        latestDescription = latestDescriptionDecoded
    }
}

extension HealthClientTypes {
    /// The detailed description of the event. Included in the information returned by the [DescribeEventDetails](https://docs.aws.amazon.com/health/latest/APIReference/API_DescribeEventDetails.html) operation.
    public struct EventDescription: Swift.Equatable {
        /// The most recent description of the event.
        public var latestDescription: Swift.String?

        public init(
            latestDescription: Swift.String? = nil
        )
        {
            self.latestDescription = latestDescription
        }
    }

}

extension HealthClientTypes.EventDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case event
        case eventDescription
        case eventMetadata
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let event = self.event {
            try encodeContainer.encode(event, forKey: .event)
        }
        if let eventDescription = self.eventDescription {
            try encodeContainer.encode(eventDescription, forKey: .eventDescription)
        }
        if let eventMetadata = eventMetadata {
            var eventMetadataContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .eventMetadata)
            for (dictKey0, eventMetadata0) in eventMetadata {
                try eventMetadataContainer.encode(eventMetadata0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventDecoded = try containerValues.decodeIfPresent(HealthClientTypes.Event.self, forKey: .event)
        event = eventDecoded
        let eventDescriptionDecoded = try containerValues.decodeIfPresent(HealthClientTypes.EventDescription.self, forKey: .eventDescription)
        eventDescription = eventDescriptionDecoded
        let eventMetadataContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .eventMetadata)
        var eventMetadataDecoded0: [Swift.String:Swift.String]? = nil
        if let eventMetadataContainer = eventMetadataContainer {
            eventMetadataDecoded0 = [Swift.String:Swift.String]()
            for (key0, metadatavalue0) in eventMetadataContainer {
                if let metadatavalue0 = metadatavalue0 {
                    eventMetadataDecoded0?[key0] = metadatavalue0
                }
            }
        }
        eventMetadata = eventMetadataDecoded0
    }
}

extension HealthClientTypes {
    /// Detailed information about an event. A combination of an [Event](https://docs.aws.amazon.com/health/latest/APIReference/API_Event.html) object, an [EventDescription](https://docs.aws.amazon.com/health/latest/APIReference/API_EventDescription.html) object, and additional metadata about the event. Returned by the [DescribeEventDetails](https://docs.aws.amazon.com/health/latest/APIReference/API_DescribeEventDetails.html) operation.
    public struct EventDetails: Swift.Equatable {
        /// Summary information about the event.
        public var event: HealthClientTypes.Event?
        /// The most recent description of the event.
        public var eventDescription: HealthClientTypes.EventDescription?
        /// Additional metadata about the event.
        public var eventMetadata: [Swift.String:Swift.String]?

        public init(
            event: HealthClientTypes.Event? = nil,
            eventDescription: HealthClientTypes.EventDescription? = nil,
            eventMetadata: [Swift.String:Swift.String]? = nil
        )
        {
            self.event = event
            self.eventDescription = eventDescription
            self.eventMetadata = eventMetadata
        }
    }

}

extension HealthClientTypes.EventDetailsErrorItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorMessage
        case errorName
        case eventArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorMessage = self.errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let errorName = self.errorName {
            try encodeContainer.encode(errorName, forKey: .errorName)
        }
        if let eventArn = self.eventArn {
            try encodeContainer.encode(eventArn, forKey: .eventArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventArn)
        eventArn = eventArnDecoded
        let errorNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorName)
        errorName = errorNameDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension HealthClientTypes {
    /// Error information returned when a [DescribeEventDetails](https://docs.aws.amazon.com/health/latest/APIReference/API_DescribeEventDetails.html) operation can't find a specified event.
    public struct EventDetailsErrorItem: Swift.Equatable {
        /// A message that describes the error.
        public var errorMessage: Swift.String?
        /// The name of the error.
        public var errorName: Swift.String?
        /// The unique identifier for the event. The event ARN has the arn:aws:health:event-region::event/SERVICE/EVENT_TYPE_CODE/EVENT_TYPE_PLUS_ID  format. For example, an event ARN might look like the following: arn:aws:health:us-east-1::event/EC2/EC2_INSTANCE_RETIREMENT_SCHEDULED/EC2_INSTANCE_RETIREMENT_SCHEDULED_ABC123-DEF456
        public var eventArn: Swift.String?

        public init(
            errorMessage: Swift.String? = nil,
            errorName: Swift.String? = nil,
            eventArn: Swift.String? = nil
        )
        {
            self.errorMessage = errorMessage
            self.errorName = errorName
            self.eventArn = eventArn
        }
    }

}

extension HealthClientTypes.EventFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case availabilityZones
        case endTimes
        case entityArns
        case entityValues
        case eventArns
        case eventStatusCodes
        case eventTypeCategories
        case eventTypeCodes
        case lastUpdatedTimes
        case regions
        case services
        case startTimes
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let availabilityZones = availabilityZones {
            var availabilityZonesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .availabilityZones)
            for availabilityzone0 in availabilityZones {
                try availabilityZonesContainer.encode(availabilityzone0)
            }
        }
        if let endTimes = endTimes {
            var endTimesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .endTimes)
            for datetimerange0 in endTimes {
                try endTimesContainer.encode(datetimerange0)
            }
        }
        if let entityArns = entityArns {
            var entityArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .entityArns)
            for entityarn0 in entityArns {
                try entityArnsContainer.encode(entityarn0)
            }
        }
        if let entityValues = entityValues {
            var entityValuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .entityValues)
            for entityvalue0 in entityValues {
                try entityValuesContainer.encode(entityvalue0)
            }
        }
        if let eventArns = eventArns {
            var eventArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .eventArns)
            for eventarn0 in eventArns {
                try eventArnsContainer.encode(eventarn0)
            }
        }
        if let eventStatusCodes = eventStatusCodes {
            var eventStatusCodesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .eventStatusCodes)
            for eventstatuscode0 in eventStatusCodes {
                try eventStatusCodesContainer.encode(eventstatuscode0.rawValue)
            }
        }
        if let eventTypeCategories = eventTypeCategories {
            var eventTypeCategoriesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .eventTypeCategories)
            for eventtypecategory0 in eventTypeCategories {
                try eventTypeCategoriesContainer.encode(eventtypecategory0.rawValue)
            }
        }
        if let eventTypeCodes = eventTypeCodes {
            var eventTypeCodesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .eventTypeCodes)
            for eventtype20 in eventTypeCodes {
                try eventTypeCodesContainer.encode(eventtype20)
            }
        }
        if let lastUpdatedTimes = lastUpdatedTimes {
            var lastUpdatedTimesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .lastUpdatedTimes)
            for datetimerange0 in lastUpdatedTimes {
                try lastUpdatedTimesContainer.encode(datetimerange0)
            }
        }
        if let regions = regions {
            var regionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .regions)
            for region0 in regions {
                try regionsContainer.encode(region0)
            }
        }
        if let services = services {
            var servicesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .services)
            for service0 in services {
                try servicesContainer.encode(service0)
            }
        }
        if let startTimes = startTimes {
            var startTimesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .startTimes)
            for datetimerange0 in startTimes {
                try startTimesContainer.encode(datetimerange0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tagset0 in tags {
                var tagset0Container = tagsContainer.nestedContainer(keyedBy: ClientRuntime.Key.self)
                for (dictKey1, tagSet1) in tagset0 {
                    try tagset0Container.encode(tagSet1, forKey: ClientRuntime.Key(stringValue: dictKey1))
                }
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .eventArns)
        var eventArnsDecoded0:[Swift.String]? = nil
        if let eventArnsContainer = eventArnsContainer {
            eventArnsDecoded0 = [Swift.String]()
            for string0 in eventArnsContainer {
                if let string0 = string0 {
                    eventArnsDecoded0?.append(string0)
                }
            }
        }
        eventArns = eventArnsDecoded0
        let eventTypeCodesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .eventTypeCodes)
        var eventTypeCodesDecoded0:[Swift.String]? = nil
        if let eventTypeCodesContainer = eventTypeCodesContainer {
            eventTypeCodesDecoded0 = [Swift.String]()
            for string0 in eventTypeCodesContainer {
                if let string0 = string0 {
                    eventTypeCodesDecoded0?.append(string0)
                }
            }
        }
        eventTypeCodes = eventTypeCodesDecoded0
        let servicesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .services)
        var servicesDecoded0:[Swift.String]? = nil
        if let servicesContainer = servicesContainer {
            servicesDecoded0 = [Swift.String]()
            for string0 in servicesContainer {
                if let string0 = string0 {
                    servicesDecoded0?.append(string0)
                }
            }
        }
        services = servicesDecoded0
        let regionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .regions)
        var regionsDecoded0:[Swift.String]? = nil
        if let regionsContainer = regionsContainer {
            regionsDecoded0 = [Swift.String]()
            for string0 in regionsContainer {
                if let string0 = string0 {
                    regionsDecoded0?.append(string0)
                }
            }
        }
        regions = regionsDecoded0
        let availabilityZonesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .availabilityZones)
        var availabilityZonesDecoded0:[Swift.String]? = nil
        if let availabilityZonesContainer = availabilityZonesContainer {
            availabilityZonesDecoded0 = [Swift.String]()
            for string0 in availabilityZonesContainer {
                if let string0 = string0 {
                    availabilityZonesDecoded0?.append(string0)
                }
            }
        }
        availabilityZones = availabilityZonesDecoded0
        let startTimesContainer = try containerValues.decodeIfPresent([HealthClientTypes.DateTimeRange?].self, forKey: .startTimes)
        var startTimesDecoded0:[HealthClientTypes.DateTimeRange]? = nil
        if let startTimesContainer = startTimesContainer {
            startTimesDecoded0 = [HealthClientTypes.DateTimeRange]()
            for structure0 in startTimesContainer {
                if let structure0 = structure0 {
                    startTimesDecoded0?.append(structure0)
                }
            }
        }
        startTimes = startTimesDecoded0
        let endTimesContainer = try containerValues.decodeIfPresent([HealthClientTypes.DateTimeRange?].self, forKey: .endTimes)
        var endTimesDecoded0:[HealthClientTypes.DateTimeRange]? = nil
        if let endTimesContainer = endTimesContainer {
            endTimesDecoded0 = [HealthClientTypes.DateTimeRange]()
            for structure0 in endTimesContainer {
                if let structure0 = structure0 {
                    endTimesDecoded0?.append(structure0)
                }
            }
        }
        endTimes = endTimesDecoded0
        let lastUpdatedTimesContainer = try containerValues.decodeIfPresent([HealthClientTypes.DateTimeRange?].self, forKey: .lastUpdatedTimes)
        var lastUpdatedTimesDecoded0:[HealthClientTypes.DateTimeRange]? = nil
        if let lastUpdatedTimesContainer = lastUpdatedTimesContainer {
            lastUpdatedTimesDecoded0 = [HealthClientTypes.DateTimeRange]()
            for structure0 in lastUpdatedTimesContainer {
                if let structure0 = structure0 {
                    lastUpdatedTimesDecoded0?.append(structure0)
                }
            }
        }
        lastUpdatedTimes = lastUpdatedTimesDecoded0
        let entityArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .entityArns)
        var entityArnsDecoded0:[Swift.String]? = nil
        if let entityArnsContainer = entityArnsContainer {
            entityArnsDecoded0 = [Swift.String]()
            for string0 in entityArnsContainer {
                if let string0 = string0 {
                    entityArnsDecoded0?.append(string0)
                }
            }
        }
        entityArns = entityArnsDecoded0
        let entityValuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .entityValues)
        var entityValuesDecoded0:[Swift.String]? = nil
        if let entityValuesContainer = entityValuesContainer {
            entityValuesDecoded0 = [Swift.String]()
            for string0 in entityValuesContainer {
                if let string0 = string0 {
                    entityValuesDecoded0?.append(string0)
                }
            }
        }
        entityValues = entityValuesDecoded0
        let eventTypeCategoriesContainer = try containerValues.decodeIfPresent([HealthClientTypes.EventTypeCategory?].self, forKey: .eventTypeCategories)
        var eventTypeCategoriesDecoded0:[HealthClientTypes.EventTypeCategory]? = nil
        if let eventTypeCategoriesContainer = eventTypeCategoriesContainer {
            eventTypeCategoriesDecoded0 = [HealthClientTypes.EventTypeCategory]()
            for enum0 in eventTypeCategoriesContainer {
                if let enum0 = enum0 {
                    eventTypeCategoriesDecoded0?.append(enum0)
                }
            }
        }
        eventTypeCategories = eventTypeCategoriesDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([[Swift.String: Swift.String?]?].self, forKey: .tags)
        var tagsDecoded0:[[Swift.String:Swift.String]]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [[Swift.String:Swift.String]]()
            for map0 in tagsContainer {
                var tagsContainerDecoded0: [Swift.String: Swift.String]? = nil
                if let map0 = map0 {
                    tagsContainerDecoded0 = [Swift.String: Swift.String]()
                    for (key1, tagvalue1) in map0 {
                        if let tagvalue1 = tagvalue1 {
                            tagsContainerDecoded0?[key1] = tagvalue1
                        }
                    }
                }
                if let tagsContainerDecoded0 = tagsContainerDecoded0 {
                    tagsDecoded0?.append(tagsContainerDecoded0)
                }
            }
        }
        tags = tagsDecoded0
        let eventStatusCodesContainer = try containerValues.decodeIfPresent([HealthClientTypes.EventStatusCode?].self, forKey: .eventStatusCodes)
        var eventStatusCodesDecoded0:[HealthClientTypes.EventStatusCode]? = nil
        if let eventStatusCodesContainer = eventStatusCodesContainer {
            eventStatusCodesDecoded0 = [HealthClientTypes.EventStatusCode]()
            for enum0 in eventStatusCodesContainer {
                if let enum0 = enum0 {
                    eventStatusCodesDecoded0?.append(enum0)
                }
            }
        }
        eventStatusCodes = eventStatusCodesDecoded0
    }
}

extension HealthClientTypes {
    /// The values to use to filter results from the [DescribeEvents](https://docs.aws.amazon.com/health/latest/APIReference/API_DescribeEvents.html) and [DescribeEventAggregates](https://docs.aws.amazon.com/health/latest/APIReference/API_DescribeEventAggregates.html) operations.
    public struct EventFilter: Swift.Equatable {
        /// A list of Amazon Web Services Availability Zones.
        public var availabilityZones: [Swift.String]?
        /// A list of dates and times that the event ended.
        public var endTimes: [HealthClientTypes.DateTimeRange]?
        /// A list of entity ARNs (unique identifiers).
        public var entityArns: [Swift.String]?
        /// A list of entity identifiers, such as EC2 instance IDs (i-34ab692e) or EBS volumes (vol-426ab23e).
        public var entityValues: [Swift.String]?
        /// A list of event ARNs (unique identifiers). For example: "arn:aws:health:us-east-1::event/EC2/EC2_INSTANCE_RETIREMENT_SCHEDULED/EC2_INSTANCE_RETIREMENT_SCHEDULED_ABC123-CDE456", "arn:aws:health:us-west-1::event/EBS/AWS_EBS_LOST_VOLUME/AWS_EBS_LOST_VOLUME_CHI789_JKL101"
        public var eventArns: [Swift.String]?
        /// A list of event status codes.
        public var eventStatusCodes: [HealthClientTypes.EventStatusCode]?
        /// A list of event type category codes. Possible values are issue, accountNotification, or scheduledChange. Currently, the investigation value isn't supported at this time.
        public var eventTypeCategories: [HealthClientTypes.EventTypeCategory]?
        /// A list of unique identifiers for event types. For example, "AWS_EC2_SYSTEM_MAINTENANCE_EVENT","AWS_RDS_MAINTENANCE_SCHEDULED".
        public var eventTypeCodes: [Swift.String]?
        /// A list of dates and times that the event was last updated.
        public var lastUpdatedTimes: [HealthClientTypes.DateTimeRange]?
        /// A list of Amazon Web Services Regions.
        public var regions: [Swift.String]?
        /// The Amazon Web Services associated with the event. For example, EC2, RDS.
        public var services: [Swift.String]?
        /// A list of dates and times that the event began.
        public var startTimes: [HealthClientTypes.DateTimeRange]?
        /// A map of entity tags attached to the affected entity. Currently, the tags property isn't supported.
        public var tags: [[Swift.String:Swift.String]]?

        public init(
            availabilityZones: [Swift.String]? = nil,
            endTimes: [HealthClientTypes.DateTimeRange]? = nil,
            entityArns: [Swift.String]? = nil,
            entityValues: [Swift.String]? = nil,
            eventArns: [Swift.String]? = nil,
            eventStatusCodes: [HealthClientTypes.EventStatusCode]? = nil,
            eventTypeCategories: [HealthClientTypes.EventTypeCategory]? = nil,
            eventTypeCodes: [Swift.String]? = nil,
            lastUpdatedTimes: [HealthClientTypes.DateTimeRange]? = nil,
            regions: [Swift.String]? = nil,
            services: [Swift.String]? = nil,
            startTimes: [HealthClientTypes.DateTimeRange]? = nil,
            tags: [[Swift.String:Swift.String]]? = nil
        )
        {
            self.availabilityZones = availabilityZones
            self.endTimes = endTimes
            self.entityArns = entityArns
            self.entityValues = entityValues
            self.eventArns = eventArns
            self.eventStatusCodes = eventStatusCodes
            self.eventTypeCategories = eventTypeCategories
            self.eventTypeCodes = eventTypeCodes
            self.lastUpdatedTimes = lastUpdatedTimes
            self.regions = regions
            self.services = services
            self.startTimes = startTimes
            self.tags = tags
        }
    }

}

extension HealthClientTypes {
    public enum EventScopeCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case accountSpecific
        case `none`
        case `public`
        case sdkUnknown(Swift.String)

        public static var allCases: [EventScopeCode] {
            return [
                .accountSpecific,
                .none,
                .public,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .accountSpecific: return "ACCOUNT_SPECIFIC"
            case .none: return "NONE"
            case .public: return "PUBLIC"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EventScopeCode(rawValue: rawValue) ?? EventScopeCode.sdkUnknown(rawValue)
        }
    }
}

extension HealthClientTypes {
    public enum EventStatusCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case closed
        case `open`
        case upcoming
        case sdkUnknown(Swift.String)

        public static var allCases: [EventStatusCode] {
            return [
                .closed,
                .open,
                .upcoming,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .closed: return "closed"
            case .open: return "open"
            case .upcoming: return "upcoming"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EventStatusCode(rawValue: rawValue) ?? EventStatusCode.sdkUnknown(rawValue)
        }
    }
}

extension HealthClientTypes.EventType: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case category
        case code
        case service
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let category = self.category {
            try encodeContainer.encode(category.rawValue, forKey: .category)
        }
        if let code = self.code {
            try encodeContainer.encode(code, forKey: .code)
        }
        if let service = self.service {
            try encodeContainer.encode(service, forKey: .service)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let serviceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .service)
        service = serviceDecoded
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let categoryDecoded = try containerValues.decodeIfPresent(HealthClientTypes.EventTypeCategory.self, forKey: .category)
        category = categoryDecoded
    }
}

extension HealthClientTypes {
    /// Contains the metadata about a type of event that is reported by Health. The EventType shows the category, service, and the event type code of the event. For example, an issue might be the category, EC2 the service, and AWS_EC2_SYSTEM_MAINTENANCE_EVENT the event type code. You can use the [DescribeEventTypes](https://docs.aws.amazon.com/health/latest/APIReference/API_DescribeEventTypes.html) API operation to return this information about an event. You can also use the Amazon CloudWatch Events console to create a rule so that you can get notified or take action when Health delivers a specific event to your Amazon Web Services account. For more information, see [Monitor for Health events with Amazon CloudWatch Events](https://docs.aws.amazon.com/health/latest/ug/cloudwatch-events-health.html) in the Health User Guide.
    public struct EventType: Swift.Equatable {
        /// A list of event type category codes. Possible values are issue, accountNotification, or scheduledChange. Currently, the investigation value isn't supported at this time.
        public var category: HealthClientTypes.EventTypeCategory?
        /// The unique identifier for the event type. The format is AWS_SERVICE_DESCRIPTION ; for example, AWS_EC2_SYSTEM_MAINTENANCE_EVENT.
        public var code: Swift.String?
        /// The Amazon Web Service that is affected by the event. For example, EC2, RDS.
        public var service: Swift.String?

        public init(
            category: HealthClientTypes.EventTypeCategory? = nil,
            code: Swift.String? = nil,
            service: Swift.String? = nil
        )
        {
            self.category = category
            self.code = code
            self.service = service
        }
    }

}

extension HealthClientTypes {
    public enum EventTypeCategory: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case accountNotification
        case investigation
        case issue
        case scheduledChange
        case sdkUnknown(Swift.String)

        public static var allCases: [EventTypeCategory] {
            return [
                .accountNotification,
                .investigation,
                .issue,
                .scheduledChange,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .accountNotification: return "accountNotification"
            case .investigation: return "investigation"
            case .issue: return "issue"
            case .scheduledChange: return "scheduledChange"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EventTypeCategory(rawValue: rawValue) ?? EventTypeCategory.sdkUnknown(rawValue)
        }
    }
}

extension HealthClientTypes.EventTypeFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eventTypeCategories
        case eventTypeCodes
        case services
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eventTypeCategories = eventTypeCategories {
            var eventTypeCategoriesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .eventTypeCategories)
            for eventtypecategory0 in eventTypeCategories {
                try eventTypeCategoriesContainer.encode(eventtypecategory0.rawValue)
            }
        }
        if let eventTypeCodes = eventTypeCodes {
            var eventTypeCodesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .eventTypeCodes)
            for eventtypecode0 in eventTypeCodes {
                try eventTypeCodesContainer.encode(eventtypecode0)
            }
        }
        if let services = services {
            var servicesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .services)
            for service0 in services {
                try servicesContainer.encode(service0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventTypeCodesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .eventTypeCodes)
        var eventTypeCodesDecoded0:[Swift.String]? = nil
        if let eventTypeCodesContainer = eventTypeCodesContainer {
            eventTypeCodesDecoded0 = [Swift.String]()
            for string0 in eventTypeCodesContainer {
                if let string0 = string0 {
                    eventTypeCodesDecoded0?.append(string0)
                }
            }
        }
        eventTypeCodes = eventTypeCodesDecoded0
        let servicesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .services)
        var servicesDecoded0:[Swift.String]? = nil
        if let servicesContainer = servicesContainer {
            servicesDecoded0 = [Swift.String]()
            for string0 in servicesContainer {
                if let string0 = string0 {
                    servicesDecoded0?.append(string0)
                }
            }
        }
        services = servicesDecoded0
        let eventTypeCategoriesContainer = try containerValues.decodeIfPresent([HealthClientTypes.EventTypeCategory?].self, forKey: .eventTypeCategories)
        var eventTypeCategoriesDecoded0:[HealthClientTypes.EventTypeCategory]? = nil
        if let eventTypeCategoriesContainer = eventTypeCategoriesContainer {
            eventTypeCategoriesDecoded0 = [HealthClientTypes.EventTypeCategory]()
            for enum0 in eventTypeCategoriesContainer {
                if let enum0 = enum0 {
                    eventTypeCategoriesDecoded0?.append(enum0)
                }
            }
        }
        eventTypeCategories = eventTypeCategoriesDecoded0
    }
}

extension HealthClientTypes {
    /// The values to use to filter results from the [DescribeEventTypes](https://docs.aws.amazon.com/health/latest/APIReference/API_DescribeEventTypes.html) operation.
    public struct EventTypeFilter: Swift.Equatable {
        /// A list of event type category codes. Possible values are issue, accountNotification, or scheduledChange. Currently, the investigation value isn't supported at this time.
        public var eventTypeCategories: [HealthClientTypes.EventTypeCategory]?
        /// A list of event type codes.
        public var eventTypeCodes: [Swift.String]?
        /// The Amazon Web Services associated with the event. For example, EC2, RDS.
        public var services: [Swift.String]?

        public init(
            eventTypeCategories: [HealthClientTypes.EventTypeCategory]? = nil,
            eventTypeCodes: [Swift.String]? = nil,
            services: [Swift.String]? = nil
        )
        {
            self.eventTypeCategories = eventTypeCategories
            self.eventTypeCodes = eventTypeCodes
            self.services = services
        }
    }

}

extension InvalidPaginationToken {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidPaginationTokenBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The specified pagination token (nextToken) is not valid.
public struct InvalidPaginationToken: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidPaginationToken" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidPaginationTokenBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidPaginationTokenBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension HealthClientTypes.OrganizationAffectedEntitiesErrorItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsAccountId
        case errorMessage
        case errorName
        case eventArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let awsAccountId = self.awsAccountId {
            try encodeContainer.encode(awsAccountId, forKey: .awsAccountId)
        }
        if let errorMessage = self.errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let errorName = self.errorName {
            try encodeContainer.encode(errorName, forKey: .errorName)
        }
        if let eventArn = self.eventArn {
            try encodeContainer.encode(eventArn, forKey: .eventArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let awsAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsAccountId)
        awsAccountId = awsAccountIdDecoded
        let eventArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventArn)
        eventArn = eventArnDecoded
        let errorNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorName)
        errorName = errorNameDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension HealthClientTypes {
    /// Error information returned when a [DescribeAffectedEntitiesForOrganization](https://docs.aws.amazon.com/health/latest/APIReference/API_DescribeAffectedEntitiesForOrganization.html) operation can't find or process a specific entity.
    public struct OrganizationAffectedEntitiesErrorItem: Swift.Equatable {
        /// The 12-digit Amazon Web Services account numbers that contains the affected entities.
        public var awsAccountId: Swift.String?
        /// A message that describes the error. Follow the error message and retry your request. For example, the InvalidAccountInputError error message appears if you call the DescribeAffectedEntitiesForOrganization operation and specify the AccountSpecific value for the EventScopeCode parameter, but don't specify an Amazon Web Services account.
        public var errorMessage: Swift.String?
        /// The name of the error.
        public var errorName: Swift.String?
        /// The unique identifier for the event. The event ARN has the arn:aws:health:event-region::event/SERVICE/EVENT_TYPE_CODE/EVENT_TYPE_PLUS_ID  format. For example, an event ARN might look like the following: arn:aws:health:us-east-1::event/EC2/EC2_INSTANCE_RETIREMENT_SCHEDULED/EC2_INSTANCE_RETIREMENT_SCHEDULED_ABC123-DEF456
        public var eventArn: Swift.String?

        public init(
            awsAccountId: Swift.String? = nil,
            errorMessage: Swift.String? = nil,
            errorName: Swift.String? = nil,
            eventArn: Swift.String? = nil
        )
        {
            self.awsAccountId = awsAccountId
            self.errorMessage = errorMessage
            self.errorName = errorName
            self.eventArn = eventArn
        }
    }

}

extension HealthClientTypes.OrganizationEntityAggregate: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accounts
        case count
        case eventArn
        case statuses
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accounts = accounts {
            var accountsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accounts)
            for accountentityaggregate0 in accounts {
                try accountsContainer.encode(accountentityaggregate0)
            }
        }
        if count != 0 {
            try encodeContainer.encode(count, forKey: .count)
        }
        if let eventArn = self.eventArn {
            try encodeContainer.encode(eventArn, forKey: .eventArn)
        }
        if let statuses = statuses {
            var statusesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .statuses)
            for (dictKey0, entityStatuses0) in statuses {
                try statusesContainer.encode(entityStatuses0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventArn)
        eventArn = eventArnDecoded
        let countDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .count) ?? 0
        count = countDecoded
        let statusesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.Int?].self, forKey: .statuses)
        var statusesDecoded0: [Swift.String:Swift.Int]? = nil
        if let statusesContainer = statusesContainer {
            statusesDecoded0 = [Swift.String:Swift.Int]()
            for (key0, count0) in statusesContainer {
                if let count0 = count0 {
                    statusesDecoded0?[key0] = count0
                }
            }
        }
        statuses = statusesDecoded0
        let accountsContainer = try containerValues.decodeIfPresent([HealthClientTypes.AccountEntityAggregate?].self, forKey: .accounts)
        var accountsDecoded0:[HealthClientTypes.AccountEntityAggregate]? = nil
        if let accountsContainer = accountsContainer {
            accountsDecoded0 = [HealthClientTypes.AccountEntityAggregate]()
            for structure0 in accountsContainer {
                if let structure0 = structure0 {
                    accountsDecoded0?.append(structure0)
                }
            }
        }
        accounts = accountsDecoded0
    }
}

extension HealthClientTypes {
    /// The aggregate results of entities affected by the specified event in your organization. The results are aggregated by the entity status codes for the specified set of accountsIDs.
    public struct OrganizationEntityAggregate: Swift.Equatable {
        /// A list of entity aggregates for each of the specified accounts in your organization that are affected by a specific event. If there are no awsAccountIds provided in the request, this field will be empty in the response.
        public var accounts: [HealthClientTypes.AccountEntityAggregate]?
        /// The number of entities for the organization that match the filter criteria for the specified events.
        public var count: Swift.Int
        /// A list of event ARNs (unique identifiers). For example: "arn:aws:health:us-east-1::event/EC2/EC2_INSTANCE_RETIREMENT_SCHEDULED/EC2_INSTANCE_RETIREMENT_SCHEDULED_ABC123-CDE456", "arn:aws:health:us-west-1::event/EBS/AWS_EBS_LOST_VOLUME/AWS_EBS_LOST_VOLUME_CHI789_JKL101"
        public var eventArn: Swift.String?
        /// The number of affected entities aggregated by the entitiy status codes.
        public var statuses: [Swift.String:Swift.Int]?

        public init(
            accounts: [HealthClientTypes.AccountEntityAggregate]? = nil,
            count: Swift.Int = 0,
            eventArn: Swift.String? = nil,
            statuses: [Swift.String:Swift.Int]? = nil
        )
        {
            self.accounts = accounts
            self.count = count
            self.eventArn = eventArn
            self.statuses = statuses
        }
    }

}

extension HealthClientTypes.OrganizationEvent: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case endTime
        case eventScopeCode
        case eventTypeCategory
        case eventTypeCode
        case lastUpdatedTime
        case region
        case service
        case startTime
        case statusCode
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let endTime = self.endTime {
            try encodeContainer.encodeTimestamp(endTime, format: .epochSeconds, forKey: .endTime)
        }
        if let eventScopeCode = self.eventScopeCode {
            try encodeContainer.encode(eventScopeCode.rawValue, forKey: .eventScopeCode)
        }
        if let eventTypeCategory = self.eventTypeCategory {
            try encodeContainer.encode(eventTypeCategory.rawValue, forKey: .eventTypeCategory)
        }
        if let eventTypeCode = self.eventTypeCode {
            try encodeContainer.encode(eventTypeCode, forKey: .eventTypeCode)
        }
        if let lastUpdatedTime = self.lastUpdatedTime {
            try encodeContainer.encodeTimestamp(lastUpdatedTime, format: .epochSeconds, forKey: .lastUpdatedTime)
        }
        if let region = self.region {
            try encodeContainer.encode(region, forKey: .region)
        }
        if let service = self.service {
            try encodeContainer.encode(service, forKey: .service)
        }
        if let startTime = self.startTime {
            try encodeContainer.encodeTimestamp(startTime, format: .epochSeconds, forKey: .startTime)
        }
        if let statusCode = self.statusCode {
            try encodeContainer.encode(statusCode.rawValue, forKey: .statusCode)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let serviceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .service)
        service = serviceDecoded
        let eventTypeCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventTypeCode)
        eventTypeCode = eventTypeCodeDecoded
        let eventTypeCategoryDecoded = try containerValues.decodeIfPresent(HealthClientTypes.EventTypeCategory.self, forKey: .eventTypeCategory)
        eventTypeCategory = eventTypeCategoryDecoded
        let eventScopeCodeDecoded = try containerValues.decodeIfPresent(HealthClientTypes.EventScopeCode.self, forKey: .eventScopeCode)
        eventScopeCode = eventScopeCodeDecoded
        let regionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .region)
        region = regionDecoded
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .endTime)
        endTime = endTimeDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
        let statusCodeDecoded = try containerValues.decodeIfPresent(HealthClientTypes.EventStatusCode.self, forKey: .statusCode)
        statusCode = statusCodeDecoded
    }
}

extension HealthClientTypes {
    /// Summary information about an event, returned by the [DescribeEventsForOrganization](https://docs.aws.amazon.com/health/latest/APIReference/API_DescribeEventsForOrganization.html) operation.
    public struct OrganizationEvent: Swift.Equatable {
        /// The unique identifier for the event. The event ARN has the arn:aws:health:event-region::event/SERVICE/EVENT_TYPE_CODE/EVENT_TYPE_PLUS_ID  format. For example, an event ARN might look like the following: arn:aws:health:us-east-1::event/EC2/EC2_INSTANCE_RETIREMENT_SCHEDULED/EC2_INSTANCE_RETIREMENT_SCHEDULED_ABC123-DEF456
        public var arn: Swift.String?
        /// The date and time that the event ended.
        public var endTime: ClientRuntime.Date?
        /// This parameter specifies if the Health event is a public Amazon Web Service event or an account-specific event.
        ///
        /// * If the eventScopeCode value is PUBLIC, then the affectedAccounts value is always empty.
        ///
        /// * If the eventScopeCode value is ACCOUNT_SPECIFIC, then the affectedAccounts value lists the affected Amazon Web Services accounts in your organization. For example, if an event affects a service such as Amazon Elastic Compute Cloud and you have Amazon Web Services accounts that use that service, those account IDs appear in the response.
        ///
        /// * If the eventScopeCode value is NONE, then the eventArn that you specified in the request is invalid or doesn't exist.
        public var eventScopeCode: HealthClientTypes.EventScopeCode?
        /// A list of event type category codes. Possible values are issue, accountNotification, or scheduledChange. Currently, the investigation value isn't supported at this time.
        public var eventTypeCategory: HealthClientTypes.EventTypeCategory?
        /// The unique identifier for the event type. The format is AWS_SERVICE_DESCRIPTION. For example, AWS_EC2_SYSTEM_MAINTENANCE_EVENT.
        public var eventTypeCode: Swift.String?
        /// The most recent date and time that the event was updated.
        public var lastUpdatedTime: ClientRuntime.Date?
        /// The Amazon Web Services Region name of the event.
        public var region: Swift.String?
        /// The Amazon Web Service that is affected by the event, such as EC2 and RDS.
        public var service: Swift.String?
        /// The date and time that the event began.
        public var startTime: ClientRuntime.Date?
        /// The most recent status of the event. Possible values are open, closed, and upcoming.
        public var statusCode: HealthClientTypes.EventStatusCode?

        public init(
            arn: Swift.String? = nil,
            endTime: ClientRuntime.Date? = nil,
            eventScopeCode: HealthClientTypes.EventScopeCode? = nil,
            eventTypeCategory: HealthClientTypes.EventTypeCategory? = nil,
            eventTypeCode: Swift.String? = nil,
            lastUpdatedTime: ClientRuntime.Date? = nil,
            region: Swift.String? = nil,
            service: Swift.String? = nil,
            startTime: ClientRuntime.Date? = nil,
            statusCode: HealthClientTypes.EventStatusCode? = nil
        )
        {
            self.arn = arn
            self.endTime = endTime
            self.eventScopeCode = eventScopeCode
            self.eventTypeCategory = eventTypeCategory
            self.eventTypeCode = eventTypeCode
            self.lastUpdatedTime = lastUpdatedTime
            self.region = region
            self.service = service
            self.startTime = startTime
            self.statusCode = statusCode
        }
    }

}

extension HealthClientTypes.OrganizationEventDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsAccountId
        case event
        case eventDescription
        case eventMetadata
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let awsAccountId = self.awsAccountId {
            try encodeContainer.encode(awsAccountId, forKey: .awsAccountId)
        }
        if let event = self.event {
            try encodeContainer.encode(event, forKey: .event)
        }
        if let eventDescription = self.eventDescription {
            try encodeContainer.encode(eventDescription, forKey: .eventDescription)
        }
        if let eventMetadata = eventMetadata {
            var eventMetadataContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .eventMetadata)
            for (dictKey0, eventMetadata0) in eventMetadata {
                try eventMetadataContainer.encode(eventMetadata0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let awsAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsAccountId)
        awsAccountId = awsAccountIdDecoded
        let eventDecoded = try containerValues.decodeIfPresent(HealthClientTypes.Event.self, forKey: .event)
        event = eventDecoded
        let eventDescriptionDecoded = try containerValues.decodeIfPresent(HealthClientTypes.EventDescription.self, forKey: .eventDescription)
        eventDescription = eventDescriptionDecoded
        let eventMetadataContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .eventMetadata)
        var eventMetadataDecoded0: [Swift.String:Swift.String]? = nil
        if let eventMetadataContainer = eventMetadataContainer {
            eventMetadataDecoded0 = [Swift.String:Swift.String]()
            for (key0, metadatavalue0) in eventMetadataContainer {
                if let metadatavalue0 = metadatavalue0 {
                    eventMetadataDecoded0?[key0] = metadatavalue0
                }
            }
        }
        eventMetadata = eventMetadataDecoded0
    }
}

extension HealthClientTypes {
    /// Detailed information about an event. A combination of an [Event](https://docs.aws.amazon.com/health/latest/APIReference/API_Event.html) object, an [EventDescription](https://docs.aws.amazon.com/health/latest/APIReference/API_EventDescription.html) object, and additional metadata about the event. Returned by the [DescribeEventDetailsForOrganization](https://docs.aws.amazon.com/health/latest/APIReference/API_DescribeEventDetailsForOrganization.html) operation.
    public struct OrganizationEventDetails: Swift.Equatable {
        /// The 12-digit Amazon Web Services account numbers that contains the affected entities.
        public var awsAccountId: Swift.String?
        /// Summary information about an Health event. Health events can be public or account-specific:
        ///
        /// * Public events might be service events that are not specific to an Amazon Web Services account. For example, if there is an issue with an Amazon Web Services Region, Health provides information about the event, even if you don't use services or resources in that Region.
        ///
        /// * Account-specific events are specific to either your Amazon Web Services account or an account in your organization. For example, if there's an issue with Amazon Elastic Compute Cloud in a Region that you use, Health provides information about the event and the affected resources in the account.
        ///
        ///
        /// You can determine if an event is public or account-specific by using the eventScopeCode parameter. For more information, see [eventScopeCode](https://docs.aws.amazon.com/health/latest/APIReference/API_Event.html#AWSHealth-Type-Event-eventScopeCode).
        public var event: HealthClientTypes.Event?
        /// The detailed description of the event. Included in the information returned by the [DescribeEventDetails](https://docs.aws.amazon.com/health/latest/APIReference/API_DescribeEventDetails.html) operation.
        public var eventDescription: HealthClientTypes.EventDescription?
        /// Additional metadata about the event.
        public var eventMetadata: [Swift.String:Swift.String]?

        public init(
            awsAccountId: Swift.String? = nil,
            event: HealthClientTypes.Event? = nil,
            eventDescription: HealthClientTypes.EventDescription? = nil,
            eventMetadata: [Swift.String:Swift.String]? = nil
        )
        {
            self.awsAccountId = awsAccountId
            self.event = event
            self.eventDescription = eventDescription
            self.eventMetadata = eventMetadata
        }
    }

}

extension HealthClientTypes.OrganizationEventDetailsErrorItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsAccountId
        case errorMessage
        case errorName
        case eventArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let awsAccountId = self.awsAccountId {
            try encodeContainer.encode(awsAccountId, forKey: .awsAccountId)
        }
        if let errorMessage = self.errorMessage {
            try encodeContainer.encode(errorMessage, forKey: .errorMessage)
        }
        if let errorName = self.errorName {
            try encodeContainer.encode(errorName, forKey: .errorName)
        }
        if let eventArn = self.eventArn {
            try encodeContainer.encode(eventArn, forKey: .eventArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let awsAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsAccountId)
        awsAccountId = awsAccountIdDecoded
        let eventArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventArn)
        eventArn = eventArnDecoded
        let errorNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorName)
        errorName = errorNameDecoded
        let errorMessageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorMessage)
        errorMessage = errorMessageDecoded
    }
}

extension HealthClientTypes {
    /// Error information returned when a [DescribeEventDetailsForOrganization](https://docs.aws.amazon.com/health/latest/APIReference/API_DescribeEventDetailsForOrganization.html) operation can't find a specified event.
    public struct OrganizationEventDetailsErrorItem: Swift.Equatable {
        /// Error information returned when a [DescribeEventDetailsForOrganization](https://docs.aws.amazon.com/health/latest/APIReference/API_DescribeEventDetailsForOrganization.html) operation can't find a specified event.
        public var awsAccountId: Swift.String?
        /// A message that describes the error. If you call the DescribeEventDetailsForOrganization operation and receive one of the following errors, follow the recommendations in the message:
        ///
        /// * We couldn't find a public event that matches your request. To find an event that is account specific, you must enter an Amazon Web Services account ID in the request.
        ///
        /// * We couldn't find an account specific event for the specified Amazon Web Services account. To find an event that is public, you must enter a null value for the Amazon Web Services account ID in the request.
        ///
        /// * Your Amazon Web Services account doesn't include the Amazon Web Services Support plan required to use the Health API. You must have either a Business, Enterprise On-Ramp, or Enterprise Support plan.
        public var errorMessage: Swift.String?
        /// The name of the error.
        public var errorName: Swift.String?
        /// The unique identifier for the event. The event ARN has the arn:aws:health:event-region::event/SERVICE/EVENT_TYPE_CODE/EVENT_TYPE_PLUS_ID  format. For example, an event ARN might look like the following: arn:aws:health:us-east-1::event/EC2/EC2_INSTANCE_RETIREMENT_SCHEDULED/EC2_INSTANCE_RETIREMENT_SCHEDULED_ABC123-DEF456
        public var eventArn: Swift.String?

        public init(
            awsAccountId: Swift.String? = nil,
            errorMessage: Swift.String? = nil,
            errorName: Swift.String? = nil,
            eventArn: Swift.String? = nil
        )
        {
            self.awsAccountId = awsAccountId
            self.errorMessage = errorMessage
            self.errorName = errorName
            self.eventArn = eventArn
        }
    }

}

extension HealthClientTypes.OrganizationEventFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsAccountIds
        case endTime
        case entityArns
        case entityValues
        case eventStatusCodes
        case eventTypeCategories
        case eventTypeCodes
        case lastUpdatedTime
        case regions
        case services
        case startTime
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let awsAccountIds = awsAccountIds {
            var awsAccountIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .awsAccountIds)
            for accountid0 in awsAccountIds {
                try awsAccountIdsContainer.encode(accountid0)
            }
        }
        if let endTime = self.endTime {
            try encodeContainer.encode(endTime, forKey: .endTime)
        }
        if let entityArns = entityArns {
            var entityArnsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .entityArns)
            for entityarn0 in entityArns {
                try entityArnsContainer.encode(entityarn0)
            }
        }
        if let entityValues = entityValues {
            var entityValuesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .entityValues)
            for entityvalue0 in entityValues {
                try entityValuesContainer.encode(entityvalue0)
            }
        }
        if let eventStatusCodes = eventStatusCodes {
            var eventStatusCodesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .eventStatusCodes)
            for eventstatuscode0 in eventStatusCodes {
                try eventStatusCodesContainer.encode(eventstatuscode0.rawValue)
            }
        }
        if let eventTypeCategories = eventTypeCategories {
            var eventTypeCategoriesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .eventTypeCategories)
            for eventtypecategory0 in eventTypeCategories {
                try eventTypeCategoriesContainer.encode(eventtypecategory0.rawValue)
            }
        }
        if let eventTypeCodes = eventTypeCodes {
            var eventTypeCodesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .eventTypeCodes)
            for eventtype20 in eventTypeCodes {
                try eventTypeCodesContainer.encode(eventtype20)
            }
        }
        if let lastUpdatedTime = self.lastUpdatedTime {
            try encodeContainer.encode(lastUpdatedTime, forKey: .lastUpdatedTime)
        }
        if let regions = regions {
            var regionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .regions)
            for region0 in regions {
                try regionsContainer.encode(region0)
            }
        }
        if let services = services {
            var servicesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .services)
            for service0 in services {
                try servicesContainer.encode(service0)
            }
        }
        if let startTime = self.startTime {
            try encodeContainer.encode(startTime, forKey: .startTime)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eventTypeCodesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .eventTypeCodes)
        var eventTypeCodesDecoded0:[Swift.String]? = nil
        if let eventTypeCodesContainer = eventTypeCodesContainer {
            eventTypeCodesDecoded0 = [Swift.String]()
            for string0 in eventTypeCodesContainer {
                if let string0 = string0 {
                    eventTypeCodesDecoded0?.append(string0)
                }
            }
        }
        eventTypeCodes = eventTypeCodesDecoded0
        let awsAccountIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .awsAccountIds)
        var awsAccountIdsDecoded0:[Swift.String]? = nil
        if let awsAccountIdsContainer = awsAccountIdsContainer {
            awsAccountIdsDecoded0 = [Swift.String]()
            for string0 in awsAccountIdsContainer {
                if let string0 = string0 {
                    awsAccountIdsDecoded0?.append(string0)
                }
            }
        }
        awsAccountIds = awsAccountIdsDecoded0
        let servicesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .services)
        var servicesDecoded0:[Swift.String]? = nil
        if let servicesContainer = servicesContainer {
            servicesDecoded0 = [Swift.String]()
            for string0 in servicesContainer {
                if let string0 = string0 {
                    servicesDecoded0?.append(string0)
                }
            }
        }
        services = servicesDecoded0
        let regionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .regions)
        var regionsDecoded0:[Swift.String]? = nil
        if let regionsContainer = regionsContainer {
            regionsDecoded0 = [Swift.String]()
            for string0 in regionsContainer {
                if let string0 = string0 {
                    regionsDecoded0?.append(string0)
                }
            }
        }
        regions = regionsDecoded0
        let startTimeDecoded = try containerValues.decodeIfPresent(HealthClientTypes.DateTimeRange.self, forKey: .startTime)
        startTime = startTimeDecoded
        let endTimeDecoded = try containerValues.decodeIfPresent(HealthClientTypes.DateTimeRange.self, forKey: .endTime)
        endTime = endTimeDecoded
        let lastUpdatedTimeDecoded = try containerValues.decodeIfPresent(HealthClientTypes.DateTimeRange.self, forKey: .lastUpdatedTime)
        lastUpdatedTime = lastUpdatedTimeDecoded
        let entityArnsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .entityArns)
        var entityArnsDecoded0:[Swift.String]? = nil
        if let entityArnsContainer = entityArnsContainer {
            entityArnsDecoded0 = [Swift.String]()
            for string0 in entityArnsContainer {
                if let string0 = string0 {
                    entityArnsDecoded0?.append(string0)
                }
            }
        }
        entityArns = entityArnsDecoded0
        let entityValuesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .entityValues)
        var entityValuesDecoded0:[Swift.String]? = nil
        if let entityValuesContainer = entityValuesContainer {
            entityValuesDecoded0 = [Swift.String]()
            for string0 in entityValuesContainer {
                if let string0 = string0 {
                    entityValuesDecoded0?.append(string0)
                }
            }
        }
        entityValues = entityValuesDecoded0
        let eventTypeCategoriesContainer = try containerValues.decodeIfPresent([HealthClientTypes.EventTypeCategory?].self, forKey: .eventTypeCategories)
        var eventTypeCategoriesDecoded0:[HealthClientTypes.EventTypeCategory]? = nil
        if let eventTypeCategoriesContainer = eventTypeCategoriesContainer {
            eventTypeCategoriesDecoded0 = [HealthClientTypes.EventTypeCategory]()
            for enum0 in eventTypeCategoriesContainer {
                if let enum0 = enum0 {
                    eventTypeCategoriesDecoded0?.append(enum0)
                }
            }
        }
        eventTypeCategories = eventTypeCategoriesDecoded0
        let eventStatusCodesContainer = try containerValues.decodeIfPresent([HealthClientTypes.EventStatusCode?].self, forKey: .eventStatusCodes)
        var eventStatusCodesDecoded0:[HealthClientTypes.EventStatusCode]? = nil
        if let eventStatusCodesContainer = eventStatusCodesContainer {
            eventStatusCodesDecoded0 = [HealthClientTypes.EventStatusCode]()
            for enum0 in eventStatusCodesContainer {
                if let enum0 = enum0 {
                    eventStatusCodesDecoded0?.append(enum0)
                }
            }
        }
        eventStatusCodes = eventStatusCodesDecoded0
    }
}

extension HealthClientTypes {
    /// The values to filter results from the [DescribeEventsForOrganization](https://docs.aws.amazon.com/health/latest/APIReference/API_DescribeEventsForOrganization.html) operation.
    public struct OrganizationEventFilter: Swift.Equatable {
        /// A list of 12-digit Amazon Web Services account numbers that contains the affected entities.
        public var awsAccountIds: [Swift.String]?
        /// A range of dates and times that is used by the [EventFilter](https://docs.aws.amazon.com/health/latest/APIReference/API_EventFilter.html) and [EntityFilter](https://docs.aws.amazon.com/health/latest/APIReference/API_EntityFilter.html) objects. If from is set and to is set: match items where the timestamp (startTime, endTime, or lastUpdatedTime) is between from and to inclusive. If from is set and to is not set: match items where the timestamp value is equal to or after from. If from is not set and to is set: match items where the timestamp value is equal to or before to.
        public var endTime: HealthClientTypes.DateTimeRange?
        /// A list of entity ARNs (unique identifiers).
        public var entityArns: [Swift.String]?
        /// A list of entity identifiers, such as EC2 instance IDs (i-34ab692e) or EBS volumes (vol-426ab23e).
        public var entityValues: [Swift.String]?
        /// A list of event status codes.
        public var eventStatusCodes: [HealthClientTypes.EventStatusCode]?
        /// A list of event type category codes. Possible values are issue, accountNotification, or scheduledChange. Currently, the investigation value isn't supported at this time.
        public var eventTypeCategories: [HealthClientTypes.EventTypeCategory]?
        /// A list of unique identifiers for event types. For example, "AWS_EC2_SYSTEM_MAINTENANCE_EVENT","AWS_RDS_MAINTENANCE_SCHEDULED".
        public var eventTypeCodes: [Swift.String]?
        /// A range of dates and times that is used by the [EventFilter](https://docs.aws.amazon.com/health/latest/APIReference/API_EventFilter.html) and [EntityFilter](https://docs.aws.amazon.com/health/latest/APIReference/API_EntityFilter.html) objects. If from is set and to is set: match items where the timestamp (startTime, endTime, or lastUpdatedTime) is between from and to inclusive. If from is set and to is not set: match items where the timestamp value is equal to or after from. If from is not set and to is set: match items where the timestamp value is equal to or before to.
        public var lastUpdatedTime: HealthClientTypes.DateTimeRange?
        /// A list of Amazon Web Services Regions.
        public var regions: [Swift.String]?
        /// The Amazon Web Services associated with the event. For example, EC2, RDS.
        public var services: [Swift.String]?
        /// A range of dates and times that is used by the [EventFilter](https://docs.aws.amazon.com/health/latest/APIReference/API_EventFilter.html) and [EntityFilter](https://docs.aws.amazon.com/health/latest/APIReference/API_EntityFilter.html) objects. If from is set and to is set: match items where the timestamp (startTime, endTime, or lastUpdatedTime) is between from and to inclusive. If from is set and to is not set: match items where the timestamp value is equal to or after from. If from is not set and to is set: match items where the timestamp value is equal to or before to.
        public var startTime: HealthClientTypes.DateTimeRange?

        public init(
            awsAccountIds: [Swift.String]? = nil,
            endTime: HealthClientTypes.DateTimeRange? = nil,
            entityArns: [Swift.String]? = nil,
            entityValues: [Swift.String]? = nil,
            eventStatusCodes: [HealthClientTypes.EventStatusCode]? = nil,
            eventTypeCategories: [HealthClientTypes.EventTypeCategory]? = nil,
            eventTypeCodes: [Swift.String]? = nil,
            lastUpdatedTime: HealthClientTypes.DateTimeRange? = nil,
            regions: [Swift.String]? = nil,
            services: [Swift.String]? = nil,
            startTime: HealthClientTypes.DateTimeRange? = nil
        )
        {
            self.awsAccountIds = awsAccountIds
            self.endTime = endTime
            self.entityArns = entityArns
            self.entityValues = entityValues
            self.eventStatusCodes = eventStatusCodes
            self.eventTypeCategories = eventTypeCategories
            self.eventTypeCodes = eventTypeCodes
            self.lastUpdatedTime = lastUpdatedTime
            self.regions = regions
            self.services = services
            self.startTime = startTime
        }
    }

}

extension UnsupportedLocale {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UnsupportedLocaleBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The specified locale is not supported.
public struct UnsupportedLocale: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "UnsupportedLocale" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct UnsupportedLocaleBody: Swift.Equatable {
    let message: Swift.String?
}

extension UnsupportedLocaleBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}
