//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.AWSJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
@_spi(SmithyReadWrite) import struct SmithyReadWrite.WritingClosureBox

extension EvsClientTypes {

    /// Stores information about a field passed inside a request that resulted in an exception.
    public struct ValidationExceptionField: Swift.Sendable {
        /// A message describing why the field failed validation.
        /// This member is required.
        public var message: Swift.String?
        /// The field name.
        /// This member is required.
        public var name: Swift.String?

        public init(
            message: Swift.String? = nil,
            name: Swift.String? = nil
        ) {
            self.message = message
            self.name = name
        }
    }
}

extension EvsClientTypes {

    public enum ValidationExceptionReason: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case cannotParse
        case fieldValidationFailed
        case other
        case unknownOperation
        case sdkUnknown(Swift.String)

        public static var allCases: [ValidationExceptionReason] {
            return [
                .cannotParse,
                .fieldValidationFailed,
                .other,
                .unknownOperation
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .cannotParse: return "cannotParse"
            case .fieldValidationFailed: return "fieldValidationFailed"
            case .other: return "other"
            case .unknownOperation: return "unknownOperation"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// The input fails to satisfy the specified constraints. You will see this exception if invalid inputs are provided for any of the Amazon EVS environment operations, or if a list operation is performed on an environment resource that is still initializing.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// A list of fields that didn't validate.
        public internal(set) var fieldList: [EvsClientTypes.ValidationExceptionField]? = nil
        /// Describes the error encountered.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The reason for the exception.
        /// This member is required.
        public internal(set) var reason: EvsClientTypes.ValidationExceptionReason? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        fieldList: [EvsClientTypes.ValidationExceptionField]? = nil,
        message: Swift.String? = nil,
        reason: EvsClientTypes.ValidationExceptionReason? = nil
    ) {
        self.properties.fieldList = fieldList
        self.properties.message = message
        self.properties.reason = reason
    }
}

extension EvsClientTypes {

    /// The connectivity configuration for the environment. Amazon EVS requires that you specify two route server peer IDs. During environment creation, the route server endpoints peer with the NSX uplink VLAN for connectivity to the NSX overlay network.
    public struct ConnectivityInfo: Swift.Sendable {
        /// The unique IDs for private route server peers.
        /// This member is required.
        public var privateRouteServerPeerings: [Swift.String]?

        public init(
            privateRouteServerPeerings: [Swift.String]? = nil
        ) {
            self.privateRouteServerPeerings = privateRouteServerPeerings
        }
    }
}

extension EvsClientTypes {

    public enum InstanceType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case i4iMetal
        case sdkUnknown(Swift.String)

        public static var allCases: [InstanceType] {
            return [
                .i4iMetal
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .i4iMetal: return "i4i.metal"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension EvsClientTypes {

    /// An object that represents a host. You cannot use dedicatedHostId and placementGroupId together in the same HostInfoForCreateobject. This results in a ValidationException response.
    public struct HostInfoForCreate: Swift.Sendable {
        /// The unique ID of the Amazon EC2 Dedicated Host.
        public var dedicatedHostId: Swift.String?
        /// The DNS hostname of the host. DNS hostnames for hosts must be unique across Amazon EVS environments and within VCF.
        /// This member is required.
        public var hostName: Swift.String?
        /// The EC2 instance type that represents the host.
        /// This member is required.
        public var instanceType: EvsClientTypes.InstanceType?
        /// The name of the SSH key that is used to access the host.
        /// This member is required.
        public var keyName: Swift.String?
        /// The unique ID of the placement group where the host is placed.
        public var placementGroupId: Swift.String?

        public init(
            dedicatedHostId: Swift.String? = nil,
            hostName: Swift.String? = nil,
            instanceType: EvsClientTypes.InstanceType? = nil,
            keyName: Swift.String? = nil,
            placementGroupId: Swift.String? = nil
        ) {
            self.dedicatedHostId = dedicatedHostId
            self.hostName = hostName
            self.instanceType = instanceType
            self.keyName = keyName
            self.placementGroupId = placementGroupId
        }
    }
}

extension EvsClientTypes {

    /// An object that represents an initial VLAN subnet for the environment. Amazon EVS creates initial VLAN subnets when you first create the environment. You must specify a non-overlapping CIDR block for each VLAN subnet. Amazon EVS creates the following 10 VLAN subnets: host management VLAN, vMotion VLAN, vSAN VLAN, VTEP VLAN, Edge VTEP VLAN, Management VM VLAN, HCX uplink VLAN, NSX uplink VLAN, expansion VLAN 1, expansion VLAN 2.
    public struct InitialVlanInfo: Swift.Sendable {
        /// The CIDR block that you provide to create a VLAN subnet. VLAN CIDR blocks must not overlap with other subnets in the VPC.
        /// This member is required.
        public var cidr: Swift.String?

        public init(
            cidr: Swift.String? = nil
        ) {
            self.cidr = cidr
        }
    }
}

extension EvsClientTypes {

    /// The initial VLAN subnets for the environment. You must specify a non-overlapping CIDR block for each VLAN subnet.
    public struct InitialVlans: Swift.Sendable {
        /// The edge VTEP VLAN subnet. This VLAN subnet manages traffic flowing between the internal network and external networks, including internet access and other site connections.
        /// This member is required.
        public var edgeVTep: EvsClientTypes.InitialVlanInfo?
        /// An additional VLAN subnet that can be used to extend VCF capabilities once configured. For example, you can configure an expansion VLAN subnet to use NSX Federation for centralized management and synchronization of multiple NSX deployments across different locations.
        /// This member is required.
        public var expansionVlan1: EvsClientTypes.InitialVlanInfo?
        /// An additional VLAN subnet that can be used to extend VCF capabilities once configured. For example, you can configure an expansion VLAN subnet to use NSX Federation for centralized management and synchronization of multiple NSX deployments across different locations.
        /// This member is required.
        public var expansionVlan2: EvsClientTypes.InitialVlanInfo?
        /// The HCX VLAN subnet. This VLAN subnet allows the HCX Interconnnect (IX) and HCX Network Extension (NE) to reach their peers and enable HCX Service Mesh creation.
        /// This member is required.
        public var hcx: EvsClientTypes.InitialVlanInfo?
        /// The NSX uplink VLAN subnet. This VLAN subnet allows connectivity to the NSX overlay network.
        /// This member is required.
        public var nsxUplink: EvsClientTypes.InitialVlanInfo?
        /// The vMotion VLAN subnet. This VLAN subnet carries traffic for vSphere vMotion.
        /// This member is required.
        public var vMotion: EvsClientTypes.InitialVlanInfo?
        /// The vSAN VLAN subnet. This VLAN subnet carries the communication between ESXi hosts to implement a vSAN shared storage pool.
        /// This member is required.
        public var vSan: EvsClientTypes.InitialVlanInfo?
        /// The VTEP VLAN subnet. This VLAN subnet handles internal network traffic between virtual machines within a VCF instance.
        /// This member is required.
        public var vTep: EvsClientTypes.InitialVlanInfo?
        /// The VM management VLAN subnet. This VLAN subnet carries traffic for vSphere virtual machines.
        /// This member is required.
        public var vmManagement: EvsClientTypes.InitialVlanInfo?
        /// The VMkernel management VLAN subnet. This VLAN subnet carries traffic for managing ESXi hosts and communicating with VMware vCenter Server.
        /// This member is required.
        public var vmkManagement: EvsClientTypes.InitialVlanInfo?

        public init(
            edgeVTep: EvsClientTypes.InitialVlanInfo? = nil,
            expansionVlan1: EvsClientTypes.InitialVlanInfo? = nil,
            expansionVlan2: EvsClientTypes.InitialVlanInfo? = nil,
            hcx: EvsClientTypes.InitialVlanInfo? = nil,
            nsxUplink: EvsClientTypes.InitialVlanInfo? = nil,
            vMotion: EvsClientTypes.InitialVlanInfo? = nil,
            vSan: EvsClientTypes.InitialVlanInfo? = nil,
            vTep: EvsClientTypes.InitialVlanInfo? = nil,
            vmManagement: EvsClientTypes.InitialVlanInfo? = nil,
            vmkManagement: EvsClientTypes.InitialVlanInfo? = nil
        ) {
            self.edgeVTep = edgeVTep
            self.expansionVlan1 = expansionVlan1
            self.expansionVlan2 = expansionVlan2
            self.hcx = hcx
            self.nsxUplink = nsxUplink
            self.vMotion = vMotion
            self.vSan = vSan
            self.vTep = vTep
            self.vmManagement = vmManagement
            self.vmkManagement = vmkManagement
        }
    }
}

extension EvsClientTypes {

    /// The license information that Amazon EVS requires to create an environment. Amazon EVS requires two license keys: a VCF solution key and a vSAN license key.
    public struct LicenseInfo: Swift.Sendable {
        /// The VCF solution key. This license unlocks VMware VCF product features, including vSphere, NSX, SDDC Manager, and vCenter Server.
        /// This member is required.
        public var solutionKey: Swift.String?
        /// The VSAN license key. This license unlocks vSAN features.
        /// This member is required.
        public var vsanKey: Swift.String?

        public init(
            solutionKey: Swift.String? = nil,
            vsanKey: Swift.String? = nil
        ) {
            self.solutionKey = solutionKey
            self.vsanKey = vsanKey
        }
    }
}

extension EvsClientTypes {

    /// The security groups that allow traffic between the Amazon EVS control plane and your VPC for Amazon EVS service access. If a security group is not specified, Amazon EVS uses the default security group in your account for service access.
    public struct ServiceAccessSecurityGroups: Swift.Sendable {
        /// The security groups that allow service access.
        public var securityGroups: [Swift.String]?

        public init(
            securityGroups: [Swift.String]? = nil
        ) {
            self.securityGroups = securityGroups
        }
    }
}

extension EvsClientTypes {

    /// The DNS hostnames that Amazon EVS uses to install VMware vCenter Server, NSX, SDDC Manager, and Cloud Builder. Each hostname must be unique, and resolve to a domain name that you've registered in your DNS service of choice. Hostnames cannot be changed. VMware VCF requires the deployment of two NSX Edge nodes, and three NSX Manager virtual machines.
    public struct VcfHostnames: Swift.Sendable {
        /// The hostname for VMware Cloud Builder.
        /// This member is required.
        public var cloudBuilder: Swift.String?
        /// The VMware NSX hostname.
        /// This member is required.
        public var nsx: Swift.String?
        /// The hostname for the first NSX Edge node.
        /// This member is required.
        public var nsxEdge1: Swift.String?
        /// The hostname for the second NSX Edge node.
        /// This member is required.
        public var nsxEdge2: Swift.String?
        /// The hostname for the first VMware NSX Manager virtual machine (VM).
        /// This member is required.
        public var nsxManager1: Swift.String?
        /// The hostname for the second VMware NSX Manager virtual machine (VM).
        /// This member is required.
        public var nsxManager2: Swift.String?
        /// The hostname for the third VMware NSX Manager virtual machine (VM).
        /// This member is required.
        public var nsxManager3: Swift.String?
        /// The hostname for SDDC Manager.
        /// This member is required.
        public var sddcManager: Swift.String?
        /// The VMware vCenter hostname.
        /// This member is required.
        public var vCenter: Swift.String?

        public init(
            cloudBuilder: Swift.String? = nil,
            nsx: Swift.String? = nil,
            nsxEdge1: Swift.String? = nil,
            nsxEdge2: Swift.String? = nil,
            nsxManager1: Swift.String? = nil,
            nsxManager2: Swift.String? = nil,
            nsxManager3: Swift.String? = nil,
            sddcManager: Swift.String? = nil,
            vCenter: Swift.String? = nil
        ) {
            self.cloudBuilder = cloudBuilder
            self.nsx = nsx
            self.nsxEdge1 = nsxEdge1
            self.nsxEdge2 = nsxEdge2
            self.nsxManager1 = nsxManager1
            self.nsxManager2 = nsxManager2
            self.nsxManager3 = nsxManager3
            self.sddcManager = sddcManager
            self.vCenter = vCenter
        }
    }
}

extension EvsClientTypes {

    public enum VcfVersion: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case vcf521
        case sdkUnknown(Swift.String)

        public static var allCases: [VcfVersion] {
            return [
                .vcf521
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .vcf521: return "VCF-5.2.1"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateEnvironmentInput: Swift.Sendable {
    /// This parameter is not used in Amazon EVS currently. If you supply input for this parameter, it will have no effect. A unique, case-sensitive identifier that you provide to ensure the idempotency of the environment creation request. If you do not specify a client token, a randomly generated token is used for the request to ensure idempotency.
    public var clientToken: Swift.String?
    /// The connectivity configuration for the environment. Amazon EVS requires that you specify two route server peer IDs. During environment creation, the route server endpoints peer with the NSX edges over the NSX, providing BGP dynamic routing for overlay networks.
    /// This member is required.
    public var connectivityInfo: EvsClientTypes.ConnectivityInfo?
    /// The name to give to your environment. The name can contain only alphanumeric characters (case-sensitive), hyphens, and underscores. It must start with an alphanumeric character, and can't be longer than 100 characters. The name must be unique within the Amazon Web Services Region and Amazon Web Services account that you're creating the environment in.
    public var environmentName: Swift.String?
    /// The ESXi hosts to add to the environment. Amazon EVS requires that you provide details for a minimum of 4 hosts during environment creation. For each host, you must provide the desired hostname, EC2 SSH key, and EC2 instance type. Optionally, you can also provide a partition or cluster placement group to use, or use Amazon EC2 Dedicated Hosts.
    /// This member is required.
    public var hosts: [EvsClientTypes.HostInfoForCreate]?
    /// The initial VLAN subnets for the environment. You must specify a non-overlapping CIDR block for each VLAN subnet.
    /// This member is required.
    public var initialVlans: EvsClientTypes.InitialVlans?
    /// A unique ID for the customer-managed KMS key that is used to encrypt the VCF credential pairs for SDDC Manager, NSX Manager, and vCenter appliances. These credentials are stored in Amazon Web Services Secrets Manager.
    public var kmsKeyId: Swift.String?
    /// The license information that Amazon EVS requires to create an environment. Amazon EVS requires two license keys: a VCF solution key and a vSAN license key. VCF licenses must have sufficient core entitlements to cover vCPU core and vSAN storage capacity needs. VCF licenses can be used for only one Amazon EVS environment. Amazon EVS does not support reuse of VCF licenses for multiple environments. VCF license information can be retrieved from the Broadcom portal.
    /// This member is required.
    public var licenseInfo: [EvsClientTypes.LicenseInfo]?
    /// The security group that controls communication between the Amazon EVS control plane and VPC. The default security group is used if a custom security group isn't specified. The security group should allow access to the following.
    ///
    /// * TCP/UDP access to the DNS servers
    ///
    /// * HTTPS/SSH access to the host management VLAN subnet
    ///
    /// * HTTPS/SSH access to the Management VM VLAN subnet
    ///
    ///
    /// You should avoid modifying the security group rules after deployment, as this can break the persistent connection between the Amazon EVS control plane and VPC. This can cause future environment actions like adding or removing hosts to fail.
    public var serviceAccessSecurityGroups: EvsClientTypes.ServiceAccessSecurityGroups?
    /// The subnet that is used to establish connectivity between the Amazon EVS control plane and VPC. Amazon EVS uses this subnet to validate mandatory DNS records for your VCF appliances and hosts and create the environment.
    /// This member is required.
    public var serviceAccessSubnetId: Swift.String?
    /// The Broadcom Site ID that is allocated to you as part of your electronic software delivery. This ID allows customer access to the Broadcom portal, and is provided to you by Broadcom at the close of your software contract or contract renewal. Amazon EVS uses the Broadcom Site ID that you provide to meet Broadcom VCF license usage reporting requirements for Amazon EVS.
    /// This member is required.
    public var siteId: Swift.String?
    /// Metadata that assists with categorization and organization. Each tag consists of a key and an optional value. You define both. Tags don't propagate to any other cluster or Amazon Web Services resources.
    public var tags: [Swift.String: Swift.String]?
    /// Customer confirmation that the customer has purchased and maintains sufficient VCF software licenses to cover all physical processor cores in the environment, in compliance with VMware's licensing requirements and terms of use.
    /// This member is required.
    public var termsAccepted: Swift.Bool?
    /// The DNS hostnames for the virtual machines that host the VCF management appliances. Amazon EVS requires that you provide DNS hostnames for the following appliances: vCenter, NSX Manager, SDDC Manager, and Cloud Builder.
    /// This member is required.
    public var vcfHostnames: EvsClientTypes.VcfHostnames?
    /// The VCF version to use for the environment. Amazon EVS only supports VCF version 5.2.1 at this time.
    /// This member is required.
    public var vcfVersion: EvsClientTypes.VcfVersion?
    /// A unique ID for the VPC that connects to the environment control plane for service access. Amazon EVS requires that all VPC subnets exist in a single Availability Zone in a Region where the service is available. The VPC that you select must have a valid DHCP option set with domain name, at least two DNS servers, and an NTP server. These settings are used to configure your VCF appliances and hosts. If you plan to use HCX over the internet, choose a VPC that has a primary CIDR block and a /28 secondary CIDR block from an IPAM pool. Make sure that your VPC also has an attached internet gateway. Amazon EVS does not support the following Amazon Web Services networking options for NSX overlay connectivity: cross-Region VPC peering, Amazon S3 gateway endpoints, or Amazon Web Services Direct Connect virtual private gateway associations.
    /// This member is required.
    public var vpcId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        connectivityInfo: EvsClientTypes.ConnectivityInfo? = nil,
        environmentName: Swift.String? = nil,
        hosts: [EvsClientTypes.HostInfoForCreate]? = nil,
        initialVlans: EvsClientTypes.InitialVlans? = nil,
        kmsKeyId: Swift.String? = nil,
        licenseInfo: [EvsClientTypes.LicenseInfo]? = nil,
        serviceAccessSecurityGroups: EvsClientTypes.ServiceAccessSecurityGroups? = nil,
        serviceAccessSubnetId: Swift.String? = nil,
        siteId: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        termsAccepted: Swift.Bool? = nil,
        vcfHostnames: EvsClientTypes.VcfHostnames? = nil,
        vcfVersion: EvsClientTypes.VcfVersion? = nil,
        vpcId: Swift.String? = nil
    ) {
        self.clientToken = clientToken
        self.connectivityInfo = connectivityInfo
        self.environmentName = environmentName
        self.hosts = hosts
        self.initialVlans = initialVlans
        self.kmsKeyId = kmsKeyId
        self.licenseInfo = licenseInfo
        self.serviceAccessSecurityGroups = serviceAccessSecurityGroups
        self.serviceAccessSubnetId = serviceAccessSubnetId
        self.siteId = siteId
        self.tags = tags
        self.termsAccepted = termsAccepted
        self.vcfHostnames = vcfHostnames
        self.vcfVersion = vcfVersion
        self.vpcId = vpcId
    }
}

extension EvsClientTypes {

    public enum CheckResult: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case failed
        case passed
        case unknown
        case sdkUnknown(Swift.String)

        public static var allCases: [CheckResult] {
            return [
                .failed,
                .passed,
                .unknown
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .passed: return "PASSED"
            case .unknown: return "UNKNOWN"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension EvsClientTypes {

    public enum CheckType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case hostCount
        case keyCoverage
        case keyReuse
        case reachability
        case sdkUnknown(Swift.String)

        public static var allCases: [CheckType] {
            return [
                .hostCount,
                .keyCoverage,
                .keyReuse,
                .reachability
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .hostCount: return "HOST_COUNT"
            case .keyCoverage: return "KEY_COVERAGE"
            case .keyReuse: return "KEY_REUSE"
            case .reachability: return "REACHABILITY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension EvsClientTypes {

    /// A check on the environment to identify environment health and validate VMware VCF licensing compliance.
    public struct Check: Swift.Sendable {
        /// The time when environment health began to be impaired.
        public var impairedSince: Foundation.Date?
        /// The check result.
        public var result: EvsClientTypes.CheckResult?
        /// The check type. Amazon EVS performs the following checks.
        ///
        /// * KEY_REUSE: checks that the VCF license key is not used by another Amazon EVS environment. This check fails if a used license is added to the environment.
        ///
        /// * KEY_COVERAGE: checks that your VCF license key allocates sufficient vCPU cores for all deployed hosts. The check fails when any assigned hosts in the EVS environment are not covered by license keys, or when any unassigned hosts cannot be covered by available vCPU cores in keys.
        ///
        /// * REACHABILITY: checks that the Amazon EVS control plane has a persistent connection to SDDC Manager. If Amazon EVS cannot reach the environment, this check fails.
        ///
        /// * HOST_COUNT: Checks that your environment has a minimum of 4 hosts, which is a requirement for VCF 5.2.1. If this check fails, you will need to add hosts so that your environment meets this minimum requirement. Amazon EVS only supports environments with 4-16 hosts.
        public var type: EvsClientTypes.CheckType?

        public init(
            impairedSince: Foundation.Date? = nil,
            result: EvsClientTypes.CheckResult? = nil,
            type: EvsClientTypes.CheckType? = nil
        ) {
            self.impairedSince = impairedSince
            self.result = result
            self.type = type
        }
    }
}

extension EvsClientTypes {

    /// A managed secret that contains the credentials for installing vCenter Server, NSX, and SDDC Manager. During environment creation, the Amazon EVS control plane uses Amazon Web Services Secrets Manager to create, encrypt, validate, and store secrets. If you choose to delete your environment, Amazon EVS also deletes the secrets that are associated with your environment. Amazon EVS does not provide managed rotation of secrets. We recommend that you rotate secrets regularly to ensure that secrets are not long-lived.
    public struct Secret: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the secret.
        public var secretArn: Swift.String?

        public init(
            secretArn: Swift.String? = nil
        ) {
            self.secretArn = secretArn
        }
    }
}

extension EvsClientTypes {

    public enum EnvironmentState: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case created
        case createFailed
        case creating
        case deleted
        case deleting
        case sdkUnknown(Swift.String)

        public static var allCases: [EnvironmentState] {
            return [
                .created,
                .createFailed,
                .creating,
                .deleted,
                .deleting
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .created: return "CREATED"
            case .createFailed: return "CREATE_FAILED"
            case .creating: return "CREATING"
            case .deleted: return "DELETED"
            case .deleting: return "DELETING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension EvsClientTypes {

    /// An object that represents an Amazon EVS environment.
    public struct Environment: Swift.Sendable {
        /// A check on the environment to identify instance health and VMware VCF licensing issues.
        public var checks: [EvsClientTypes.Check]?
        /// The connectivity configuration for the environment. Amazon EVS requires that you specify two route server peer IDs. During environment creation, the route server endpoints peer with the NSX uplink VLAN for connectivity to the NSX overlay network.
        public var connectivityInfo: EvsClientTypes.ConnectivityInfo?
        /// The date and time that the environment was created.
        public var createdAt: Foundation.Date?
        /// The VCF credentials that are stored as Amazon EVS managed secrets in Amazon Web Services Secrets Manager. Amazon EVS stores credentials that are needed to install vCenter Server, NSX, and SDDC Manager.
        public var credentials: [EvsClientTypes.Secret]?
        /// The Amazon Resource Name (ARN) that is associated with the environment.
        public var environmentArn: Swift.String?
        /// The unique ID for the environment.
        public var environmentId: Swift.String?
        /// The name of the environment.
        public var environmentName: Swift.String?
        /// The state of an environment.
        public var environmentState: EvsClientTypes.EnvironmentState?
        /// Reports impaired functionality that stems from issues internal to the environment, such as impaired reachability.
        public var environmentStatus: EvsClientTypes.CheckResult?
        /// The Amazon Web Services KMS key ID that Amazon Web Services Secrets Manager uses to encrypt secrets that are associated with the environment. These secrets contain the VCF credentials that are needed to install vCenter Server, NSX, and SDDC Manager. By default, Amazon EVS use the Amazon Web Services Secrets Manager managed key aws/secretsmanager. You can also specify a customer managed key.
        public var kmsKeyId: Swift.String?
        /// The license information that Amazon EVS requires to create an environment. Amazon EVS requires two license keys: a VCF solution key and a vSAN license key.
        public var licenseInfo: [EvsClientTypes.LicenseInfo]?
        /// The date and time that the environment was modified.
        public var modifiedAt: Foundation.Date?
        /// The security groups that allow traffic between the Amazon EVS control plane and your VPC for service access. If a security group is not specified, Amazon EVS uses the default security group in your account for service access.
        public var serviceAccessSecurityGroups: EvsClientTypes.ServiceAccessSecurityGroups?
        /// The subnet that is used to establish connectivity between the Amazon EVS control plane and VPC. Amazon EVS uses this subnet to perform validations and create the environment.
        public var serviceAccessSubnetId: Swift.String?
        /// The Broadcom Site ID that is associated with your Amazon EVS environment. Amazon EVS uses the Broadcom Site ID that you provide to meet Broadcom VCF license usage reporting requirements for Amazon EVS.
        public var siteId: Swift.String?
        /// A detailed description of the environmentState of an environment.
        public var stateDetails: Swift.String?
        /// Customer confirmation that the customer has purchased and maintains sufficient VCF software licenses to cover all physical processor cores in the environment, in compliance with VMware's licensing requirements and terms of use.
        public var termsAccepted: Swift.Bool?
        /// The DNS hostnames to be used by the VCF management appliances in your environment. For environment creation to be successful, each hostname entry must resolve to a domain name that you've registered in your DNS service of choice and configured in the DHCP option set of your VPC. DNS hostnames cannot be changed after environment creation has started.
        public var vcfHostnames: EvsClientTypes.VcfHostnames?
        /// The VCF version of the environment.
        public var vcfVersion: EvsClientTypes.VcfVersion?
        /// The VPC associated with the environment.
        public var vpcId: Swift.String?

        public init(
            checks: [EvsClientTypes.Check]? = nil,
            connectivityInfo: EvsClientTypes.ConnectivityInfo? = nil,
            createdAt: Foundation.Date? = nil,
            credentials: [EvsClientTypes.Secret]? = nil,
            environmentArn: Swift.String? = nil,
            environmentId: Swift.String? = nil,
            environmentName: Swift.String? = nil,
            environmentState: EvsClientTypes.EnvironmentState? = nil,
            environmentStatus: EvsClientTypes.CheckResult? = nil,
            kmsKeyId: Swift.String? = nil,
            licenseInfo: [EvsClientTypes.LicenseInfo]? = nil,
            modifiedAt: Foundation.Date? = nil,
            serviceAccessSecurityGroups: EvsClientTypes.ServiceAccessSecurityGroups? = nil,
            serviceAccessSubnetId: Swift.String? = nil,
            siteId: Swift.String? = nil,
            stateDetails: Swift.String? = nil,
            termsAccepted: Swift.Bool? = nil,
            vcfHostnames: EvsClientTypes.VcfHostnames? = nil,
            vcfVersion: EvsClientTypes.VcfVersion? = nil,
            vpcId: Swift.String? = nil
        ) {
            self.checks = checks
            self.connectivityInfo = connectivityInfo
            self.createdAt = createdAt
            self.credentials = credentials
            self.environmentArn = environmentArn
            self.environmentId = environmentId
            self.environmentName = environmentName
            self.environmentState = environmentState
            self.environmentStatus = environmentStatus
            self.kmsKeyId = kmsKeyId
            self.licenseInfo = licenseInfo
            self.modifiedAt = modifiedAt
            self.serviceAccessSecurityGroups = serviceAccessSecurityGroups
            self.serviceAccessSubnetId = serviceAccessSubnetId
            self.siteId = siteId
            self.stateDetails = stateDetails
            self.termsAccepted = termsAccepted
            self.vcfHostnames = vcfHostnames
            self.vcfVersion = vcfVersion
            self.vpcId = vpcId
        }
    }
}

public struct CreateEnvironmentOutput: Swift.Sendable {
    /// A description of the created environment.
    public var environment: EvsClientTypes.Environment?

    public init(
        environment: EvsClientTypes.Environment? = nil
    ) {
        self.environment = environment
    }
}

/// The CreateEnvironmentHost operation couldn't be performed because the service is throttling requests. This exception is thrown when the CreateEnvironmentHost request exceeds concurrency of 1 transaction per second (TPS).
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// Describes the error encountered.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The seconds to wait to retry.
        public internal(set) var retryAfterSeconds: Swift.Int? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        retryAfterSeconds: Swift.Int? = nil
    ) {
        self.properties.message = message
        self.properties.retryAfterSeconds = retryAfterSeconds
    }
}

public struct CreateEnvironmentHostInput: Swift.Sendable {
    /// This parameter is not used in Amazon EVS currently. If you supply input for this parameter, it will have no effect. A unique, case-sensitive identifier that you provide to ensure the idempotency of the host creation request. If you do not specify a client token, a randomly generated token is used for the request to ensure idempotency.
    public var clientToken: Swift.String?
    /// A unique ID for the environment that the host is added to.
    /// This member is required.
    public var environmentId: Swift.String?
    /// The host that is created and added to the environment.
    /// This member is required.
    public var host: EvsClientTypes.HostInfoForCreate?

    public init(
        clientToken: Swift.String? = nil,
        environmentId: Swift.String? = nil,
        host: EvsClientTypes.HostInfoForCreate? = nil
    ) {
        self.clientToken = clientToken
        self.environmentId = environmentId
        self.host = host
    }
}

extension EvsClientTypes {

    /// A list of environments with summarized environment details.
    public struct EnvironmentSummary: Swift.Sendable {
        /// The date and time that the environment was created.
        public var createdAt: Foundation.Date?
        /// The Amazon Resource Name (ARN) that is associated with the environment.
        public var environmentArn: Swift.String?
        /// A unique ID for the environment.
        public var environmentId: Swift.String?
        /// The name of the environment.
        public var environmentName: Swift.String?
        /// The state of an environment.
        public var environmentState: EvsClientTypes.EnvironmentState?
        /// Reports impaired functionality that stems from issues internal to the environment, such as impaired reachability.
        public var environmentStatus: EvsClientTypes.CheckResult?
        /// The date and time that the environment was modified.
        public var modifiedAt: Foundation.Date?
        /// The VCF version of the environment.
        public var vcfVersion: EvsClientTypes.VcfVersion?

        public init(
            createdAt: Foundation.Date? = nil,
            environmentArn: Swift.String? = nil,
            environmentId: Swift.String? = nil,
            environmentName: Swift.String? = nil,
            environmentState: EvsClientTypes.EnvironmentState? = nil,
            environmentStatus: EvsClientTypes.CheckResult? = nil,
            modifiedAt: Foundation.Date? = nil,
            vcfVersion: EvsClientTypes.VcfVersion? = nil
        ) {
            self.createdAt = createdAt
            self.environmentArn = environmentArn
            self.environmentId = environmentId
            self.environmentName = environmentName
            self.environmentState = environmentState
            self.environmentStatus = environmentStatus
            self.modifiedAt = modifiedAt
            self.vcfVersion = vcfVersion
        }
    }
}

extension EvsClientTypes {

    public enum HostState: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case created
        case createFailed
        case creating
        case deleted
        case deleting
        case updateFailed
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [HostState] {
            return [
                .created,
                .createFailed,
                .creating,
                .deleted,
                .deleting,
                .updateFailed,
                .updating
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .created: return "CREATED"
            case .createFailed: return "CREATE_FAILED"
            case .creating: return "CREATING"
            case .deleted: return "DELETED"
            case .deleting: return "DELETING"
            case .updateFailed: return "UPDATE_FAILED"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension EvsClientTypes {

    /// An elastic network interface (ENI) that connects hosts to the VLAN subnets. Amazon EVS provisions two identically configured ENIs in the VMkernel management subnet during host creation. One ENI is active, and the other is in standby mode for automatic switchover during a failure scenario.
    public struct NetworkInterface: Swift.Sendable {
        /// The unique ID of the elastic network interface.
        public var networkInterfaceId: Swift.String?

        public init(
            networkInterfaceId: Swift.String? = nil
        ) {
            self.networkInterfaceId = networkInterfaceId
        }
    }
}

extension EvsClientTypes {

    /// An ESXi host that runs on an Amazon EC2 bare metal instance. Four hosts are created in an Amazon EVS environment during environment creation. You can add hosts to an environment using the CreateEnvironmentHost operation. Amazon EVS supports 4-16 hosts per environment.
    public struct Host: Swift.Sendable {
        /// The date and time that the host was created.
        public var createdAt: Foundation.Date?
        /// The unique ID of the Amazon EC2 Dedicated Host.
        public var dedicatedHostId: Swift.String?
        /// The unique ID of the EC2 instance that represents the host.
        public var ec2InstanceId: Swift.String?
        /// The DNS hostname of the host. DNS hostnames for hosts must be unique across Amazon EVS environments and within VCF.
        public var hostName: Swift.String?
        /// The state of the host.
        public var hostState: EvsClientTypes.HostState?
        /// The EC2 instance type of the host. EC2 instances created through Amazon EVS do not support associating an IAM instance profile.
        public var instanceType: EvsClientTypes.InstanceType?
        /// The IP address of the host.
        public var ipAddress: Swift.String?
        /// The name of the SSH key that is used to access the host.
        public var keyName: Swift.String?
        /// The date and time that the host was modified.
        public var modifiedAt: Foundation.Date?
        /// The elastic network interfaces that are attached to the host.
        public var networkInterfaces: [EvsClientTypes.NetworkInterface]?
        /// The unique ID of the placement group where the host is placed.
        public var placementGroupId: Swift.String?
        /// A detailed description of the hostState of a host.
        public var stateDetails: Swift.String?

        public init(
            createdAt: Foundation.Date? = nil,
            dedicatedHostId: Swift.String? = nil,
            ec2InstanceId: Swift.String? = nil,
            hostName: Swift.String? = nil,
            hostState: EvsClientTypes.HostState? = nil,
            instanceType: EvsClientTypes.InstanceType? = nil,
            ipAddress: Swift.String? = nil,
            keyName: Swift.String? = nil,
            modifiedAt: Foundation.Date? = nil,
            networkInterfaces: [EvsClientTypes.NetworkInterface]? = nil,
            placementGroupId: Swift.String? = nil,
            stateDetails: Swift.String? = nil
        ) {
            self.createdAt = createdAt
            self.dedicatedHostId = dedicatedHostId
            self.ec2InstanceId = ec2InstanceId
            self.hostName = hostName
            self.hostState = hostState
            self.instanceType = instanceType
            self.ipAddress = ipAddress
            self.keyName = keyName
            self.modifiedAt = modifiedAt
            self.networkInterfaces = networkInterfaces
            self.placementGroupId = placementGroupId
            self.stateDetails = stateDetails
        }
    }
}

public struct CreateEnvironmentHostOutput: Swift.Sendable {
    /// A summary of the environment that the host is created in.
    public var environmentSummary: EvsClientTypes.EnvironmentSummary?
    /// A description of the created host.
    public var host: EvsClientTypes.Host?

    public init(
        environmentSummary: EvsClientTypes.EnvironmentSummary? = nil,
        host: EvsClientTypes.Host? = nil
    ) {
        self.environmentSummary = environmentSummary
        self.host = host
    }
}

/// A service resource associated with the request could not be found. The resource might not be specified correctly, or it may have a state of DELETED.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// Describes the error encountered.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The ID of the resource that could not be found.
        /// This member is required.
        public internal(set) var resourceId: Swift.String? = nil
        /// The type of the resource that is associated with the error.
        /// This member is required.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    ) {
        self.properties.message = message
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
    }
}

public struct DeleteEnvironmentInput: Swift.Sendable {
    /// This parameter is not used in Amazon EVS currently. If you supply input for this parameter, it will have no effect. A unique, case-sensitive identifier that you provide to ensure the idempotency of the environment deletion request. If you do not specify a client token, a randomly generated token is used for the request to ensure idempotency.
    public var clientToken: Swift.String?
    /// A unique ID associated with the environment to be deleted.
    /// This member is required.
    public var environmentId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        environmentId: Swift.String? = nil
    ) {
        self.clientToken = clientToken
        self.environmentId = environmentId
    }
}

public struct DeleteEnvironmentOutput: Swift.Sendable {
    /// A description of the deleted environment.
    public var environment: EvsClientTypes.Environment?

    public init(
        environment: EvsClientTypes.Environment? = nil
    ) {
        self.environment = environment
    }
}

public struct DeleteEnvironmentHostInput: Swift.Sendable {
    /// This parameter is not used in Amazon EVS currently. If you supply input for this parameter, it will have no effect. A unique, case-sensitive identifier that you provide to ensure the idempotency of the host deletion request. If you do not specify a client token, a randomly generated token is used for the request to ensure idempotency.
    public var clientToken: Swift.String?
    /// A unique ID for the host's environment.
    /// This member is required.
    public var environmentId: Swift.String?
    /// The DNS hostname associated with the host to be deleted.
    /// This member is required.
    public var hostName: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        environmentId: Swift.String? = nil,
        hostName: Swift.String? = nil
    ) {
        self.clientToken = clientToken
        self.environmentId = environmentId
        self.hostName = hostName
    }
}

public struct DeleteEnvironmentHostOutput: Swift.Sendable {
    /// A summary of the environment that the host was deleted from.
    public var environmentSummary: EvsClientTypes.EnvironmentSummary?
    /// A description of the deleted host.
    public var host: EvsClientTypes.Host?

    public init(
        environmentSummary: EvsClientTypes.EnvironmentSummary? = nil,
        host: EvsClientTypes.Host? = nil
    ) {
        self.environmentSummary = environmentSummary
        self.host = host
    }
}

public struct GetEnvironmentInput: Swift.Sendable {
    /// A unique ID for the environment.
    /// This member is required.
    public var environmentId: Swift.String?

    public init(
        environmentId: Swift.String? = nil
    ) {
        self.environmentId = environmentId
    }
}

public struct GetEnvironmentOutput: Swift.Sendable {
    /// A description of the requested environment.
    public var environment: EvsClientTypes.Environment?

    public init(
        environment: EvsClientTypes.Environment? = nil
    ) {
        self.environment = environment
    }
}

public struct ListEnvironmentHostsInput: Swift.Sendable {
    /// A unique ID for the environment.
    /// This member is required.
    public var environmentId: Swift.String?
    /// The maximum number of results to return. If you specify MaxResults in the request, the response includes information up to the limit specified.
    public var maxResults: Swift.Int?
    /// A unique pagination token for each page. If nextToken is returned, there are more results available. Make the call again using the returned token with all other arguments unchanged to retrieve the next page. Each pagination token expires after 24 hours. Using an expired pagination token will return an HTTP 400 InvalidToken error.
    public var nextToken: Swift.String?

    public init(
        environmentId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.environmentId = environmentId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListEnvironmentHostsOutput: Swift.Sendable {
    /// A list of hosts in the environment.
    public var environmentHosts: [EvsClientTypes.Host]?
    /// A unique pagination token for next page results. Make the call again using this token to retrieve the next page.
    public var nextToken: Swift.String?

    public init(
        environmentHosts: [EvsClientTypes.Host]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.environmentHosts = environmentHosts
        self.nextToken = nextToken
    }
}

public struct ListEnvironmentsInput: Swift.Sendable {
    /// The maximum number of results to return. If you specify MaxResults in the request, the response includes information up to the limit specified.
    public var maxResults: Swift.Int?
    /// A unique pagination token for each page. If nextToken is returned, there are more results available. Make the call again using the returned token with all other arguments unchanged to retrieve the next page. Each pagination token expires after 24 hours. Using an expired pagination token will return an HTTP 400 InvalidToken error.
    public var nextToken: Swift.String?
    /// The state of an environment. Used to filter response results to return only environments with the specified environmentState.
    public var state: [EvsClientTypes.EnvironmentState]?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        state: [EvsClientTypes.EnvironmentState]? = nil
    ) {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.state = state
    }
}

public struct ListEnvironmentsOutput: Swift.Sendable {
    /// A list of environments with summarized environment details.
    public var environmentSummaries: [EvsClientTypes.EnvironmentSummary]?
    /// A unique pagination token for next page results. Make the call again using this token to retrieve the next page.
    public var nextToken: Swift.String?

    public init(
        environmentSummaries: [EvsClientTypes.EnvironmentSummary]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.environmentSummaries = environmentSummaries
        self.nextToken = nextToken
    }
}

public struct ListEnvironmentVlansInput: Swift.Sendable {
    /// A unique ID for the environment.
    /// This member is required.
    public var environmentId: Swift.String?
    /// The maximum number of results to return. If you specify MaxResults in the request, the response includes information up to the limit specified.
    public var maxResults: Swift.Int?
    /// A unique pagination token for each page. If nextToken is returned, there are more results available. Make the call again using the returned token with all other arguments unchanged to retrieve the next page. Each pagination token expires after 24 hours. Using an expired pagination token will return an HTTP 400 InvalidToken error.
    public var nextToken: Swift.String?

    public init(
        environmentId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.environmentId = environmentId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension EvsClientTypes {

    public enum VlanState: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case created
        case createFailed
        case creating
        case deleted
        case deleting
        case sdkUnknown(Swift.String)

        public static var allCases: [VlanState] {
            return [
                .created,
                .createFailed,
                .creating,
                .deleted,
                .deleting
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .created: return "CREATED"
            case .createFailed: return "CREATE_FAILED"
            case .creating: return "CREATING"
            case .deleted: return "DELETED"
            case .deleting: return "DELETING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension EvsClientTypes {

    /// The VLANs that Amazon EVS creates during environment creation.
    public struct Vlan: Swift.Sendable {
        /// The availability zone of the VLAN.
        public var availabilityZone: Swift.String?
        /// The CIDR block of the VLAN.
        public var cidr: Swift.String?
        /// The date and time that the VLAN was created.
        public var createdAt: Foundation.Date?
        /// The VMware VCF traffic type that is carried over the VLAN. For example, a VLAN with a functionName of hcx is being used to carry VMware HCX traffic.
        public var functionName: Swift.String?
        /// The date and time that the VLAN was modified.
        public var modifiedAt: Foundation.Date?
        /// The state details of the VLAN.
        public var stateDetails: Swift.String?
        /// The unique ID of the VLAN subnet.
        public var subnetId: Swift.String?
        /// The unique ID of the VLAN.
        public var vlanId: Swift.Int?
        /// The state of the VLAN.
        public var vlanState: EvsClientTypes.VlanState?

        public init(
            availabilityZone: Swift.String? = nil,
            cidr: Swift.String? = nil,
            createdAt: Foundation.Date? = nil,
            functionName: Swift.String? = nil,
            modifiedAt: Foundation.Date? = nil,
            stateDetails: Swift.String? = nil,
            subnetId: Swift.String? = nil,
            vlanId: Swift.Int? = nil,
            vlanState: EvsClientTypes.VlanState? = nil
        ) {
            self.availabilityZone = availabilityZone
            self.cidr = cidr
            self.createdAt = createdAt
            self.functionName = functionName
            self.modifiedAt = modifiedAt
            self.stateDetails = stateDetails
            self.subnetId = subnetId
            self.vlanId = vlanId
            self.vlanState = vlanState
        }
    }
}

public struct ListEnvironmentVlansOutput: Swift.Sendable {
    /// A list of VLANs that are associated with the specified environment.
    public var environmentVlans: [EvsClientTypes.Vlan]?
    /// A unique pagination token for next page results. Make the call again using this token to retrieve the next page.
    public var nextToken: Swift.String?

    public init(
        environmentVlans: [EvsClientTypes.Vlan]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.environmentVlans = environmentVlans
        self.nextToken = nextToken
    }
}

public struct ListTagsForResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) that identifies the resource to list tags for.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    ) {
        self.resourceArn = resourceArn
    }
}

public struct ListTagsForResourceOutput: Swift.Sendable {
    /// The tags for the resource.
    public var tags: [Swift.String: Swift.String]?

    public init(
        tags: [Swift.String: Swift.String]? = nil
    ) {
        self.tags = tags
    }
}

/// The request doesn't comply with IAM tag policy. Correct your request and then retry it.
public struct TagPolicyException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// Describes the error encountered
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TagPolicyException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

/// A service resource associated with the request has more than 200 tags.
public struct TooManyTagsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// Describes the error encountered.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyTagsException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

public struct TagResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the resource to add tags to.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// Metadata that assists with categorization and organization. Each tag consists of a key and an optional value. You define both. Tags don't propagate to any other environment or Amazon Web Services resources.
    /// This member is required.
    public var tags: [Swift.String: Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    ) {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

public struct TagResourceOutput: Swift.Sendable {

    public init() { }
}

public struct UntagResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the resource to delete tags from.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The keys of the tags to delete.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    ) {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

public struct UntagResourceOutput: Swift.Sendable {

    public init() { }
}

extension CreateEnvironmentInput {

    static func urlPathProvider(_ value: CreateEnvironmentInput) -> Swift.String? {
        return "/"
    }
}

extension CreateEnvironmentHostInput {

    static func urlPathProvider(_ value: CreateEnvironmentHostInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteEnvironmentInput {

    static func urlPathProvider(_ value: DeleteEnvironmentInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteEnvironmentHostInput {

    static func urlPathProvider(_ value: DeleteEnvironmentHostInput) -> Swift.String? {
        return "/"
    }
}

extension GetEnvironmentInput {

    static func urlPathProvider(_ value: GetEnvironmentInput) -> Swift.String? {
        return "/"
    }
}

extension ListEnvironmentHostsInput {

    static func urlPathProvider(_ value: ListEnvironmentHostsInput) -> Swift.String? {
        return "/"
    }
}

extension ListEnvironmentsInput {

    static func urlPathProvider(_ value: ListEnvironmentsInput) -> Swift.String? {
        return "/"
    }
}

extension ListEnvironmentVlansInput {

    static func urlPathProvider(_ value: ListEnvironmentVlansInput) -> Swift.String? {
        return "/"
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        return "/"
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        return "/"
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        return "/"
    }
}

extension CreateEnvironmentInput {

    static func write(value: CreateEnvironmentInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["connectivityInfo"].write(value.connectivityInfo, with: EvsClientTypes.ConnectivityInfo.write(value:to:))
        try writer["environmentName"].write(value.environmentName)
        try writer["hosts"].writeList(value.hosts, memberWritingClosure: EvsClientTypes.HostInfoForCreate.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["initialVlans"].write(value.initialVlans, with: EvsClientTypes.InitialVlans.write(value:to:))
        try writer["kmsKeyId"].write(value.kmsKeyId)
        try writer["licenseInfo"].writeList(value.licenseInfo, memberWritingClosure: EvsClientTypes.LicenseInfo.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["serviceAccessSecurityGroups"].write(value.serviceAccessSecurityGroups, with: EvsClientTypes.ServiceAccessSecurityGroups.write(value:to:))
        try writer["serviceAccessSubnetId"].write(value.serviceAccessSubnetId)
        try writer["siteId"].write(value.siteId)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["termsAccepted"].write(value.termsAccepted)
        try writer["vcfHostnames"].write(value.vcfHostnames, with: EvsClientTypes.VcfHostnames.write(value:to:))
        try writer["vcfVersion"].write(value.vcfVersion)
        try writer["vpcId"].write(value.vpcId)
    }
}

extension CreateEnvironmentHostInput {

    static func write(value: CreateEnvironmentHostInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["environmentId"].write(value.environmentId)
        try writer["host"].write(value.host, with: EvsClientTypes.HostInfoForCreate.write(value:to:))
    }
}

extension DeleteEnvironmentInput {

    static func write(value: DeleteEnvironmentInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["environmentId"].write(value.environmentId)
    }
}

extension DeleteEnvironmentHostInput {

    static func write(value: DeleteEnvironmentHostInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["environmentId"].write(value.environmentId)
        try writer["hostName"].write(value.hostName)
    }
}

extension GetEnvironmentInput {

    static func write(value: GetEnvironmentInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["environmentId"].write(value.environmentId)
    }
}

extension ListEnvironmentHostsInput {

    static func write(value: ListEnvironmentHostsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["environmentId"].write(value.environmentId)
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension ListEnvironmentsInput {

    static func write(value: ListEnvironmentsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
        try writer["state"].writeList(value.state, memberWritingClosure: SmithyReadWrite.WritingClosureBox<EvsClientTypes.EnvironmentState>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension ListEnvironmentVlansInput {

    static func write(value: ListEnvironmentVlansInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["environmentId"].write(value.environmentId)
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension ListTagsForResourceInput {

    static func write(value: ListTagsForResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["resourceArn"].write(value.resourceArn)
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["resourceArn"].write(value.resourceArn)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension UntagResourceInput {

    static func write(value: UntagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["resourceArn"].write(value.resourceArn)
        try writer["tagKeys"].writeList(value.tagKeys, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension CreateEnvironmentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateEnvironmentOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateEnvironmentOutput()
        value.environment = try reader["environment"].readIfPresent(with: EvsClientTypes.Environment.read(from:))
        return value
    }
}

extension CreateEnvironmentHostOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateEnvironmentHostOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateEnvironmentHostOutput()
        value.environmentSummary = try reader["environmentSummary"].readIfPresent(with: EvsClientTypes.EnvironmentSummary.read(from:))
        value.host = try reader["host"].readIfPresent(with: EvsClientTypes.Host.read(from:))
        return value
    }
}

extension DeleteEnvironmentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteEnvironmentOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteEnvironmentOutput()
        value.environment = try reader["environment"].readIfPresent(with: EvsClientTypes.Environment.read(from:))
        return value
    }
}

extension DeleteEnvironmentHostOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteEnvironmentHostOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteEnvironmentHostOutput()
        value.environmentSummary = try reader["environmentSummary"].readIfPresent(with: EvsClientTypes.EnvironmentSummary.read(from:))
        value.host = try reader["host"].readIfPresent(with: EvsClientTypes.Host.read(from:))
        return value
    }
}

extension GetEnvironmentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetEnvironmentOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetEnvironmentOutput()
        value.environment = try reader["environment"].readIfPresent(with: EvsClientTypes.Environment.read(from:))
        return value
    }
}

extension ListEnvironmentHostsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListEnvironmentHostsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListEnvironmentHostsOutput()
        value.environmentHosts = try reader["environmentHosts"].readListIfPresent(memberReadingClosure: EvsClientTypes.Host.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListEnvironmentsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListEnvironmentsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListEnvironmentsOutput()
        value.environmentSummaries = try reader["environmentSummaries"].readListIfPresent(memberReadingClosure: EvsClientTypes.EnvironmentSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListEnvironmentVlansOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListEnvironmentVlansOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListEnvironmentVlansOutput()
        value.environmentVlans = try reader["environmentVlans"].readListIfPresent(memberReadingClosure: EvsClientTypes.Vlan.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

enum CreateEnvironmentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateEnvironmentHostOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteEnvironmentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteEnvironmentHostOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetEnvironmentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListEnvironmentHostsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListEnvironmentsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListEnvironmentVlansOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "TagPolicyException": return try TagPolicyException.makeError(baseError: baseError)
            case "TooManyTagsException": return try TooManyTagsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "TagPolicyException": return try TagPolicyException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ValidationException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ValidationException {
        let reader = baseError.errorBodyReader
        var value = ValidationException()
        value.properties.fieldList = try reader["fieldList"].readListIfPresent(memberReadingClosure: EvsClientTypes.ValidationExceptionField.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.properties.reason = try reader["reason"].readIfPresent() ?? .sdkUnknown("")
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ThrottlingException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ThrottlingException {
        let reader = baseError.errorBodyReader
        let httpResponse = baseError.httpResponse
        var value = ThrottlingException()
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            value.properties.retryAfterSeconds = Swift.Int(retryAfterSecondsHeaderValue) ?? 0
        }
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.properties.resourceId = try reader["resourceId"].readIfPresent() ?? ""
        value.properties.resourceType = try reader["resourceType"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension TagPolicyException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> TagPolicyException {
        let reader = baseError.errorBodyReader
        var value = TagPolicyException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension TooManyTagsException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> TooManyTagsException {
        let reader = baseError.errorBodyReader
        var value = TooManyTagsException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension EvsClientTypes.Environment {

    static func read(from reader: SmithyJSON.Reader) throws -> EvsClientTypes.Environment {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = EvsClientTypes.Environment()
        value.environmentId = try reader["environmentId"].readIfPresent()
        value.environmentState = try reader["environmentState"].readIfPresent()
        value.stateDetails = try reader["stateDetails"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.modifiedAt = try reader["modifiedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.environmentArn = try reader["environmentArn"].readIfPresent()
        value.environmentName = try reader["environmentName"].readIfPresent()
        value.vpcId = try reader["vpcId"].readIfPresent()
        value.serviceAccessSubnetId = try reader["serviceAccessSubnetId"].readIfPresent()
        value.vcfVersion = try reader["vcfVersion"].readIfPresent()
        value.termsAccepted = try reader["termsAccepted"].readIfPresent()
        value.licenseInfo = try reader["licenseInfo"].readListIfPresent(memberReadingClosure: EvsClientTypes.LicenseInfo.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.siteId = try reader["siteId"].readIfPresent()
        value.environmentStatus = try reader["environmentStatus"].readIfPresent()
        value.checks = try reader["checks"].readListIfPresent(memberReadingClosure: EvsClientTypes.Check.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.connectivityInfo = try reader["connectivityInfo"].readIfPresent(with: EvsClientTypes.ConnectivityInfo.read(from:))
        value.vcfHostnames = try reader["vcfHostnames"].readIfPresent(with: EvsClientTypes.VcfHostnames.read(from:))
        value.kmsKeyId = try reader["kmsKeyId"].readIfPresent()
        value.serviceAccessSecurityGroups = try reader["serviceAccessSecurityGroups"].readIfPresent(with: EvsClientTypes.ServiceAccessSecurityGroups.read(from:))
        value.credentials = try reader["credentials"].readListIfPresent(memberReadingClosure: EvsClientTypes.Secret.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension EvsClientTypes.Secret {

    static func read(from reader: SmithyJSON.Reader) throws -> EvsClientTypes.Secret {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = EvsClientTypes.Secret()
        value.secretArn = try reader["secretArn"].readIfPresent()
        return value
    }
}

extension EvsClientTypes.ServiceAccessSecurityGroups {

    static func write(value: EvsClientTypes.ServiceAccessSecurityGroups?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["securityGroups"].writeList(value.securityGroups, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> EvsClientTypes.ServiceAccessSecurityGroups {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = EvsClientTypes.ServiceAccessSecurityGroups()
        value.securityGroups = try reader["securityGroups"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension EvsClientTypes.VcfHostnames {

    static func write(value: EvsClientTypes.VcfHostnames?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["cloudBuilder"].write(value.cloudBuilder)
        try writer["nsx"].write(value.nsx)
        try writer["nsxEdge1"].write(value.nsxEdge1)
        try writer["nsxEdge2"].write(value.nsxEdge2)
        try writer["nsxManager1"].write(value.nsxManager1)
        try writer["nsxManager2"].write(value.nsxManager2)
        try writer["nsxManager3"].write(value.nsxManager3)
        try writer["sddcManager"].write(value.sddcManager)
        try writer["vCenter"].write(value.vCenter)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> EvsClientTypes.VcfHostnames {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = EvsClientTypes.VcfHostnames()
        value.vCenter = try reader["vCenter"].readIfPresent() ?? ""
        value.nsx = try reader["nsx"].readIfPresent() ?? ""
        value.nsxManager1 = try reader["nsxManager1"].readIfPresent() ?? ""
        value.nsxManager2 = try reader["nsxManager2"].readIfPresent() ?? ""
        value.nsxManager3 = try reader["nsxManager3"].readIfPresent() ?? ""
        value.nsxEdge1 = try reader["nsxEdge1"].readIfPresent() ?? ""
        value.nsxEdge2 = try reader["nsxEdge2"].readIfPresent() ?? ""
        value.sddcManager = try reader["sddcManager"].readIfPresent() ?? ""
        value.cloudBuilder = try reader["cloudBuilder"].readIfPresent() ?? ""
        return value
    }
}

extension EvsClientTypes.ConnectivityInfo {

    static func write(value: EvsClientTypes.ConnectivityInfo?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["privateRouteServerPeerings"].writeList(value.privateRouteServerPeerings, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> EvsClientTypes.ConnectivityInfo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = EvsClientTypes.ConnectivityInfo()
        value.privateRouteServerPeerings = try reader["privateRouteServerPeerings"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension EvsClientTypes.Check {

    static func read(from reader: SmithyJSON.Reader) throws -> EvsClientTypes.Check {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = EvsClientTypes.Check()
        value.type = try reader["type"].readIfPresent()
        value.result = try reader["result"].readIfPresent()
        value.impairedSince = try reader["impairedSince"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension EvsClientTypes.LicenseInfo {

    static func write(value: EvsClientTypes.LicenseInfo?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["solutionKey"].write(value.solutionKey)
        try writer["vsanKey"].write(value.vsanKey)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> EvsClientTypes.LicenseInfo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = EvsClientTypes.LicenseInfo()
        value.solutionKey = try reader["solutionKey"].readIfPresent() ?? ""
        value.vsanKey = try reader["vsanKey"].readIfPresent() ?? ""
        return value
    }
}

extension EvsClientTypes.EnvironmentSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> EvsClientTypes.EnvironmentSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = EvsClientTypes.EnvironmentSummary()
        value.environmentId = try reader["environmentId"].readIfPresent()
        value.environmentName = try reader["environmentName"].readIfPresent()
        value.vcfVersion = try reader["vcfVersion"].readIfPresent()
        value.environmentStatus = try reader["environmentStatus"].readIfPresent()
        value.environmentState = try reader["environmentState"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.modifiedAt = try reader["modifiedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.environmentArn = try reader["environmentArn"].readIfPresent()
        return value
    }
}

extension EvsClientTypes.Host {

    static func read(from reader: SmithyJSON.Reader) throws -> EvsClientTypes.Host {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = EvsClientTypes.Host()
        value.hostName = try reader["hostName"].readIfPresent()
        value.ipAddress = try reader["ipAddress"].readIfPresent()
        value.keyName = try reader["keyName"].readIfPresent()
        value.instanceType = try reader["instanceType"].readIfPresent()
        value.placementGroupId = try reader["placementGroupId"].readIfPresent()
        value.dedicatedHostId = try reader["dedicatedHostId"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.modifiedAt = try reader["modifiedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.hostState = try reader["hostState"].readIfPresent()
        value.stateDetails = try reader["stateDetails"].readIfPresent()
        value.ec2InstanceId = try reader["ec2InstanceId"].readIfPresent()
        value.networkInterfaces = try reader["networkInterfaces"].readListIfPresent(memberReadingClosure: EvsClientTypes.NetworkInterface.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension EvsClientTypes.NetworkInterface {

    static func read(from reader: SmithyJSON.Reader) throws -> EvsClientTypes.NetworkInterface {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = EvsClientTypes.NetworkInterface()
        value.networkInterfaceId = try reader["networkInterfaceId"].readIfPresent()
        return value
    }
}

extension EvsClientTypes.Vlan {

    static func read(from reader: SmithyJSON.Reader) throws -> EvsClientTypes.Vlan {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = EvsClientTypes.Vlan()
        value.vlanId = try reader["vlanId"].readIfPresent()
        value.cidr = try reader["cidr"].readIfPresent()
        value.availabilityZone = try reader["availabilityZone"].readIfPresent()
        value.functionName = try reader["functionName"].readIfPresent()
        value.subnetId = try reader["subnetId"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.modifiedAt = try reader["modifiedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.vlanState = try reader["vlanState"].readIfPresent()
        value.stateDetails = try reader["stateDetails"].readIfPresent()
        return value
    }
}

extension EvsClientTypes.ValidationExceptionField {

    static func read(from reader: SmithyJSON.Reader) throws -> EvsClientTypes.ValidationExceptionField {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = EvsClientTypes.ValidationExceptionField()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.message = try reader["message"].readIfPresent() ?? ""
        return value
    }
}

extension EvsClientTypes.InitialVlans {

    static func write(value: EvsClientTypes.InitialVlans?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["edgeVTep"].write(value.edgeVTep, with: EvsClientTypes.InitialVlanInfo.write(value:to:))
        try writer["expansionVlan1"].write(value.expansionVlan1, with: EvsClientTypes.InitialVlanInfo.write(value:to:))
        try writer["expansionVlan2"].write(value.expansionVlan2, with: EvsClientTypes.InitialVlanInfo.write(value:to:))
        try writer["hcx"].write(value.hcx, with: EvsClientTypes.InitialVlanInfo.write(value:to:))
        try writer["nsxUplink"].write(value.nsxUplink, with: EvsClientTypes.InitialVlanInfo.write(value:to:))
        try writer["vMotion"].write(value.vMotion, with: EvsClientTypes.InitialVlanInfo.write(value:to:))
        try writer["vSan"].write(value.vSan, with: EvsClientTypes.InitialVlanInfo.write(value:to:))
        try writer["vTep"].write(value.vTep, with: EvsClientTypes.InitialVlanInfo.write(value:to:))
        try writer["vmManagement"].write(value.vmManagement, with: EvsClientTypes.InitialVlanInfo.write(value:to:))
        try writer["vmkManagement"].write(value.vmkManagement, with: EvsClientTypes.InitialVlanInfo.write(value:to:))
    }
}

extension EvsClientTypes.InitialVlanInfo {

    static func write(value: EvsClientTypes.InitialVlanInfo?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["cidr"].write(value.cidr)
    }
}

extension EvsClientTypes.HostInfoForCreate {

    static func write(value: EvsClientTypes.HostInfoForCreate?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["dedicatedHostId"].write(value.dedicatedHostId)
        try writer["hostName"].write(value.hostName)
        try writer["instanceType"].write(value.instanceType)
        try writer["keyName"].write(value.keyName)
        try writer["placementGroupId"].write(value.placementGroupId)
    }
}

public enum EvsClientTypes {}
