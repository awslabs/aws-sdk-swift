//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.AWSJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
@_spi(SmithyReadWrite) import struct SmithyReadWrite.ReadingClosureBox
@_spi(SmithyReadWrite) import struct SmithyReadWrite.WritingClosureBox

/// A service resource associated with the request could not be found. The resource might not be specified correctly, or it may have a state of DELETED.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// Describes the error encountered.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The ID of the resource that could not be found.
        /// This member is required.
        public internal(set) var resourceId: Swift.String? = nil
        /// The type of the resource that is associated with the error.
        /// This member is required.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    ) {
        self.properties.message = message
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
    }
}

/// The operation could not be performed because the service is throttling requests. This exception is thrown when the service endpoint receives too many concurrent requests.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// Describes the error encountered.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The seconds to wait to retry.
        public internal(set) var retryAfterSeconds: Swift.Int? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        retryAfterSeconds: Swift.Int? = nil
    ) {
        self.properties.message = message
        self.properties.retryAfterSeconds = retryAfterSeconds
    }
}

extension EvsClientTypes {

    /// Stores information about a field passed inside a request that resulted in an exception.
    public struct ValidationExceptionField: Swift.Sendable {
        /// A message describing why the field failed validation.
        /// This member is required.
        public var message: Swift.String?
        /// The field name.
        /// This member is required.
        public var name: Swift.String?

        public init(
            message: Swift.String? = nil,
            name: Swift.String? = nil
        ) {
            self.message = message
            self.name = name
        }
    }
}

extension EvsClientTypes {

    public enum ValidationExceptionReason: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case cannotParse
        case fieldValidationFailed
        case other
        case unknownOperation
        case sdkUnknown(Swift.String)

        public static var allCases: [ValidationExceptionReason] {
            return [
                .cannotParse,
                .fieldValidationFailed,
                .other,
                .unknownOperation
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .cannotParse: return "cannotParse"
            case .fieldValidationFailed: return "fieldValidationFailed"
            case .other: return "other"
            case .unknownOperation: return "unknownOperation"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// The input fails to satisfy the specified constraints. You will see this exception if invalid inputs are provided for any of the Amazon EVS environment operations, or if a list operation is performed on an environment resource that is still initializing.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// A list of fields that didn't validate.
        public internal(set) var fieldList: [EvsClientTypes.ValidationExceptionField]? = nil
        /// Describes the error encountered.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The reason for the exception.
        /// This member is required.
        public internal(set) var reason: EvsClientTypes.ValidationExceptionReason? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        fieldList: [EvsClientTypes.ValidationExceptionField]? = nil,
        message: Swift.String? = nil,
        reason: EvsClientTypes.ValidationExceptionReason? = nil
    ) {
        self.properties.fieldList = fieldList
        self.properties.message = message
        self.properties.reason = reason
    }
}

public struct AssociateEipToVlanInput: Swift.Sendable {
    /// The Elastic IP address allocation ID.
    /// This member is required.
    public var allocationId: Swift.String?
    /// This parameter is not used in Amazon EVS currently. If you supply input for this parameter, it will have no effect. A unique, case-sensitive identifier that you provide to ensure the idempotency of the environment creation request. If you do not specify a client token, a randomly generated token is used for the request to ensure idempotency.
    public var clientToken: Swift.String?
    /// A unique ID for the environment containing the VLAN that the Elastic IP address associates with.
    /// This member is required.
    public var environmentId: Swift.String?
    /// The name of the VLAN. hcx is the only accepted VLAN name at this time.
    /// This member is required.
    public var vlanName: Swift.String?

    public init(
        allocationId: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        environmentId: Swift.String? = nil,
        vlanName: Swift.String? = nil
    ) {
        self.allocationId = allocationId
        self.clientToken = clientToken
        self.environmentId = environmentId
        self.vlanName = vlanName
    }
}

extension EvsClientTypes {

    /// An Elastic IP address association with the elastic network interface in the VLAN subnet.
    public struct EipAssociation: Swift.Sendable {
        /// The Elastic IP address allocation ID.
        public var allocationId: Swift.String?
        /// A unique ID for the elastic IP address association with the VLAN subnet.
        public var associationId: Swift.String?
        /// The Elastic IP address.
        public var ipAddress: Swift.String?

        public init(
            allocationId: Swift.String? = nil,
            associationId: Swift.String? = nil,
            ipAddress: Swift.String? = nil
        ) {
            self.allocationId = allocationId
            self.associationId = associationId
            self.ipAddress = ipAddress
        }
    }
}

extension EvsClientTypes {

    public enum VlanState: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case created
        case createFailed
        case creating
        case deleted
        case deleting
        case sdkUnknown(Swift.String)

        public static var allCases: [VlanState] {
            return [
                .created,
                .createFailed,
                .creating,
                .deleted,
                .deleting
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .created: return "CREATED"
            case .createFailed: return "CREATE_FAILED"
            case .creating: return "CREATING"
            case .deleted: return "DELETED"
            case .deleting: return "DELETING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension EvsClientTypes {

    /// The VLANs that Amazon EVS creates during environment creation.
    public struct Vlan: Swift.Sendable {
        /// The availability zone of the VLAN.
        public var availabilityZone: Swift.String?
        /// The CIDR block of the VLAN. Amazon EVS VLAN subnets have a minimum CIDR block size of /28 and a maximum size of /24.
        public var cidr: Swift.String?
        /// The date and time that the VLAN was created.
        public var createdAt: Foundation.Date?
        /// An array of Elastic IP address associations.
        public var eipAssociations: [EvsClientTypes.EipAssociation]?
        /// The VMware VCF traffic type that is carried over the VLAN. For example, a VLAN with a functionName of hcx is being used to carry VMware HCX traffic.
        public var functionName: Swift.String?
        /// Determines if the VLAN that Amazon EVS provisions is public or private.
        public var isPublic: Swift.Bool?
        /// The date and time that the VLAN was modified.
        public var modifiedAt: Foundation.Date?
        /// A unique ID for a network access control list.
        public var networkAclId: Swift.String?
        /// The state details of the VLAN.
        public var stateDetails: Swift.String?
        /// The unique ID of the VLAN subnet.
        public var subnetId: Swift.String?
        /// The unique ID of the VLAN.
        public var vlanId: Swift.Int?
        /// The state of the VLAN.
        public var vlanState: EvsClientTypes.VlanState?

        public init(
            availabilityZone: Swift.String? = nil,
            cidr: Swift.String? = nil,
            createdAt: Foundation.Date? = nil,
            eipAssociations: [EvsClientTypes.EipAssociation]? = nil,
            functionName: Swift.String? = nil,
            isPublic: Swift.Bool? = nil,
            modifiedAt: Foundation.Date? = nil,
            networkAclId: Swift.String? = nil,
            stateDetails: Swift.String? = nil,
            subnetId: Swift.String? = nil,
            vlanId: Swift.Int? = nil,
            vlanState: EvsClientTypes.VlanState? = nil
        ) {
            self.availabilityZone = availabilityZone
            self.cidr = cidr
            self.createdAt = createdAt
            self.eipAssociations = eipAssociations
            self.functionName = functionName
            self.isPublic = isPublic
            self.modifiedAt = modifiedAt
            self.networkAclId = networkAclId
            self.stateDetails = stateDetails
            self.subnetId = subnetId
            self.vlanId = vlanId
            self.vlanState = vlanState
        }
    }
}

public struct AssociateEipToVlanOutput: Swift.Sendable {
    /// The VLANs that Amazon EVS creates during environment creation.
    public var vlan: EvsClientTypes.Vlan?

    public init(
        vlan: EvsClientTypes.Vlan? = nil
    ) {
        self.vlan = vlan
    }
}

extension EvsClientTypes {

    /// The connectivity configuration for the environment. Amazon EVS requires that you specify two route server peer IDs. During environment creation, the route server endpoints peer with the NSX uplink VLAN for connectivity to the NSX overlay network.
    public struct ConnectivityInfo: Swift.Sendable {
        /// The unique IDs for private route server peers.
        /// This member is required.
        public var privateRouteServerPeerings: [Swift.String]?

        public init(
            privateRouteServerPeerings: [Swift.String]? = nil
        ) {
            self.privateRouteServerPeerings = privateRouteServerPeerings
        }
    }
}

extension EvsClientTypes {

    public enum InstanceType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case i4iMetal
        case sdkUnknown(Swift.String)

        public static var allCases: [InstanceType] {
            return [
                .i4iMetal
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .i4iMetal: return "i4i.metal"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension EvsClientTypes {

    /// An object that represents a host. You cannot use dedicatedHostId and placementGroupId together in the same HostInfoForCreateobject. This results in a ValidationException response.
    public struct HostInfoForCreate: Swift.Sendable {
        /// The unique ID of the Amazon EC2 Dedicated Host.
        public var dedicatedHostId: Swift.String?
        /// The DNS hostname of the host. DNS hostnames for hosts must be unique across Amazon EVS environments and within VCF.
        /// This member is required.
        public var hostName: Swift.String?
        /// The EC2 instance type that represents the host. Currently, Amazon EVS supports only the i4i.metal instance type.
        /// This member is required.
        public var instanceType: EvsClientTypes.InstanceType?
        /// The name of the SSH key that is used to access the host.
        /// This member is required.
        public var keyName: Swift.String?
        /// The unique ID of the placement group where the host is placed.
        public var placementGroupId: Swift.String?

        public init(
            dedicatedHostId: Swift.String? = nil,
            hostName: Swift.String? = nil,
            instanceType: EvsClientTypes.InstanceType? = nil,
            keyName: Swift.String? = nil,
            placementGroupId: Swift.String? = nil
        ) {
            self.dedicatedHostId = dedicatedHostId
            self.hostName = hostName
            self.instanceType = instanceType
            self.keyName = keyName
            self.placementGroupId = placementGroupId
        }
    }
}

extension EvsClientTypes {

    /// An object that represents an initial VLAN subnet for the Amazon EVS environment. Amazon EVS creates initial VLAN subnets when you first create the environment. Amazon EVS creates the following 10 VLAN subnets: host management VLAN, vMotion VLAN, vSAN VLAN, VTEP VLAN, Edge VTEP VLAN, Management VM VLAN, HCX uplink VLAN, NSX uplink VLAN, expansion VLAN 1, expansion VLAN 2. For each Amazon EVS VLAN subnet, you must specify a non-overlapping CIDR block. Amazon EVS VLAN subnets have a minimum CIDR block size of /28 and a maximum size of /24.
    public struct InitialVlanInfo: Swift.Sendable {
        /// The CIDR block that you provide to create an Amazon EVS VLAN subnet. Amazon EVS VLAN subnets have a minimum CIDR block size of /28 and a maximum size of /24. Amazon EVS VLAN subnet CIDR blocks must not overlap with other subnets in the VPC.
        /// This member is required.
        public var cidr: Swift.String?

        public init(
            cidr: Swift.String? = nil
        ) {
            self.cidr = cidr
        }
    }
}

extension EvsClientTypes {

    /// The initial VLAN subnets for the environment. Amazon EVS VLAN subnets have a minimum CIDR block size of /28 and a maximum size of /24. Amazon EVS VLAN subnet CIDR blocks must not overlap with other subnets in the VPC.
    public struct InitialVlans: Swift.Sendable {
        /// The edge VTEP VLAN subnet. This VLAN subnet manages traffic flowing between the internal network and external networks, including internet access and other site connections.
        /// This member is required.
        public var edgeVTep: EvsClientTypes.InitialVlanInfo?
        /// An additional VLAN subnet that can be used to extend VCF capabilities once configured. For example, you can configure an expansion VLAN subnet to use NSX Federation for centralized management and synchronization of multiple NSX deployments across different locations.
        /// This member is required.
        public var expansionVlan1: EvsClientTypes.InitialVlanInfo?
        /// An additional VLAN subnet that can be used to extend VCF capabilities once configured. For example, you can configure an expansion VLAN subnet to use NSX Federation for centralized management and synchronization of multiple NSX deployments across different locations.
        /// This member is required.
        public var expansionVlan2: EvsClientTypes.InitialVlanInfo?
        /// The HCX VLAN subnet. This VLAN subnet allows the HCX Interconnnect (IX) and HCX Network Extension (NE) to reach their peers and enable HCX Service Mesh creation. If you plan to use a public HCX VLAN subnet, the following requirements must be met:
        ///
        /// * Must have a /28 netmask and be allocated from the IPAM public pool. Required for HCX internet access configuration.
        ///
        /// * The HCX public VLAN CIDR block must be added to the VPC as a secondary CIDR block.
        ///
        /// * Must have at least two Elastic IP addresses to be allocated from the public IPAM pool for HCX components.
        /// This member is required.
        public var hcx: EvsClientTypes.InitialVlanInfo?
        /// A unique ID for a network access control list that the HCX VLAN uses. Required when isHcxPublic is set to true.
        public var hcxNetworkAclId: Swift.String?
        /// Determines if the HCX VLAN that Amazon EVS provisions is public or private.
        public var isHcxPublic: Swift.Bool
        /// The NSX uplink VLAN subnet. This VLAN subnet allows connectivity to the NSX overlay network.
        /// This member is required.
        public var nsxUplink: EvsClientTypes.InitialVlanInfo?
        /// The vMotion VLAN subnet. This VLAN subnet carries traffic for vSphere vMotion.
        /// This member is required.
        public var vMotion: EvsClientTypes.InitialVlanInfo?
        /// The vSAN VLAN subnet. This VLAN subnet carries the communication between ESX hosts to implement a vSAN shared storage pool.
        /// This member is required.
        public var vSan: EvsClientTypes.InitialVlanInfo?
        /// The VTEP VLAN subnet. This VLAN subnet handles internal network traffic between virtual machines within a VCF instance.
        /// This member is required.
        public var vTep: EvsClientTypes.InitialVlanInfo?
        /// The VM management VLAN subnet. This VLAN subnet carries traffic for vSphere virtual machines.
        /// This member is required.
        public var vmManagement: EvsClientTypes.InitialVlanInfo?
        /// The host VMkernel management VLAN subnet. This VLAN subnet carries traffic for managing ESX hosts and communicating with VMware vCenter Server.
        /// This member is required.
        public var vmkManagement: EvsClientTypes.InitialVlanInfo?

        public init(
            edgeVTep: EvsClientTypes.InitialVlanInfo? = nil,
            expansionVlan1: EvsClientTypes.InitialVlanInfo? = nil,
            expansionVlan2: EvsClientTypes.InitialVlanInfo? = nil,
            hcx: EvsClientTypes.InitialVlanInfo? = nil,
            hcxNetworkAclId: Swift.String? = nil,
            isHcxPublic: Swift.Bool = false,
            nsxUplink: EvsClientTypes.InitialVlanInfo? = nil,
            vMotion: EvsClientTypes.InitialVlanInfo? = nil,
            vSan: EvsClientTypes.InitialVlanInfo? = nil,
            vTep: EvsClientTypes.InitialVlanInfo? = nil,
            vmManagement: EvsClientTypes.InitialVlanInfo? = nil,
            vmkManagement: EvsClientTypes.InitialVlanInfo? = nil
        ) {
            self.edgeVTep = edgeVTep
            self.expansionVlan1 = expansionVlan1
            self.expansionVlan2 = expansionVlan2
            self.hcx = hcx
            self.hcxNetworkAclId = hcxNetworkAclId
            self.isHcxPublic = isHcxPublic
            self.nsxUplink = nsxUplink
            self.vMotion = vMotion
            self.vSan = vSan
            self.vTep = vTep
            self.vmManagement = vmManagement
            self.vmkManagement = vmkManagement
        }
    }
}

extension EvsClientTypes {

    /// The license information that Amazon EVS requires to create an environment. Amazon EVS requires two license keys: a VCF solution key and a vSAN license key.
    public struct LicenseInfo: Swift.Sendable {
        /// The VCF solution key. This license unlocks VMware VCF product features, including vSphere, NSX, SDDC Manager, and vCenter Server. The VCF solution key must cover a minimum of 256 cores.
        /// This member is required.
        public var solutionKey: Swift.String?
        /// The VSAN license key. This license unlocks vSAN features. The vSAN license key must provide at least 110 TiB of vSAN capacity.
        /// This member is required.
        public var vsanKey: Swift.String?

        public init(
            solutionKey: Swift.String? = nil,
            vsanKey: Swift.String? = nil
        ) {
            self.solutionKey = solutionKey
            self.vsanKey = vsanKey
        }
    }
}

extension EvsClientTypes {

    /// The security groups that allow traffic between the Amazon EVS control plane and your VPC for Amazon EVS service access. If a security group is not specified, Amazon EVS uses the default security group in your account for service access.
    public struct ServiceAccessSecurityGroups: Swift.Sendable {
        /// The security groups that allow service access.
        public var securityGroups: [Swift.String]?

        public init(
            securityGroups: [Swift.String]? = nil
        ) {
            self.securityGroups = securityGroups
        }
    }
}

extension EvsClientTypes {

    /// The DNS hostnames that Amazon EVS uses to install VMware vCenter Server, NSX, SDDC Manager, and Cloud Builder. Each hostname must be unique, and resolve to a domain name that you've registered in your DNS service of choice. Hostnames cannot be changed. VMware VCF requires the deployment of two NSX Edge nodes, and three NSX Manager virtual machines.
    public struct VcfHostnames: Swift.Sendable {
        /// The hostname for VMware Cloud Builder.
        /// This member is required.
        public var cloudBuilder: Swift.String?
        /// The VMware NSX hostname.
        /// This member is required.
        public var nsx: Swift.String?
        /// The hostname for the first NSX Edge node.
        /// This member is required.
        public var nsxEdge1: Swift.String?
        /// The hostname for the second NSX Edge node.
        /// This member is required.
        public var nsxEdge2: Swift.String?
        /// The hostname for the first VMware NSX Manager virtual machine (VM).
        /// This member is required.
        public var nsxManager1: Swift.String?
        /// The hostname for the second VMware NSX Manager virtual machine (VM).
        /// This member is required.
        public var nsxManager2: Swift.String?
        /// The hostname for the third VMware NSX Manager virtual machine (VM).
        /// This member is required.
        public var nsxManager3: Swift.String?
        /// The hostname for SDDC Manager.
        /// This member is required.
        public var sddcManager: Swift.String?
        /// The VMware vCenter hostname.
        /// This member is required.
        public var vCenter: Swift.String?

        public init(
            cloudBuilder: Swift.String? = nil,
            nsx: Swift.String? = nil,
            nsxEdge1: Swift.String? = nil,
            nsxEdge2: Swift.String? = nil,
            nsxManager1: Swift.String? = nil,
            nsxManager2: Swift.String? = nil,
            nsxManager3: Swift.String? = nil,
            sddcManager: Swift.String? = nil,
            vCenter: Swift.String? = nil
        ) {
            self.cloudBuilder = cloudBuilder
            self.nsx = nsx
            self.nsxEdge1 = nsxEdge1
            self.nsxEdge2 = nsxEdge2
            self.nsxManager1 = nsxManager1
            self.nsxManager2 = nsxManager2
            self.nsxManager3 = nsxManager3
            self.sddcManager = sddcManager
            self.vCenter = vCenter
        }
    }
}

extension EvsClientTypes {

    public enum VcfVersion: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case vcf521
        case vcf522
        case sdkUnknown(Swift.String)

        public static var allCases: [VcfVersion] {
            return [
                .vcf521,
                .vcf522
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .vcf521: return "VCF-5.2.1"
            case .vcf522: return "VCF-5.2.2"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateEnvironmentInput: Swift.Sendable {
    /// This parameter is not used in Amazon EVS currently. If you supply input for this parameter, it will have no effect. A unique, case-sensitive identifier that you provide to ensure the idempotency of the environment creation request. If you do not specify a client token, a randomly generated token is used for the request to ensure idempotency.
    public var clientToken: Swift.String?
    /// The connectivity configuration for the environment. Amazon EVS requires that you specify two route server peer IDs. During environment creation, the route server endpoints peer with the NSX edges over the NSX uplink subnet, providing BGP-based dynamic routing for overlay networks.
    /// This member is required.
    public var connectivityInfo: EvsClientTypes.ConnectivityInfo?
    /// The name to give to your environment. The name can contain only alphanumeric characters (case-sensitive), hyphens, and underscores. It must start with an alphanumeric character, and can't be longer than 100 characters. The name must be unique within the Amazon Web Services Region and Amazon Web Services account that you're creating the environment in.
    public var environmentName: Swift.String?
    /// The ESX hosts to add to the environment. Amazon EVS requires that you provide details for a minimum of 4 hosts during environment creation. For each host, you must provide the desired hostname, EC2 SSH keypair name, and EC2 instance type. Optionally, you can also provide a partition or cluster placement group to use, or use Amazon EC2 Dedicated Hosts.
    /// This member is required.
    public var hosts: [EvsClientTypes.HostInfoForCreate]?
    /// The initial VLAN subnets for the Amazon EVS environment. For each Amazon EVS VLAN subnet, you must specify a non-overlapping CIDR block. Amazon EVS VLAN subnets have a minimum CIDR block size of /28 and a maximum size of /24.
    /// This member is required.
    public var initialVlans: EvsClientTypes.InitialVlans?
    /// A unique ID for the customer-managed KMS key that is used to encrypt the VCF credential pairs for SDDC Manager, NSX Manager, and vCenter appliances. These credentials are stored in Amazon Web Services Secrets Manager.
    public var kmsKeyId: Swift.String?
    /// The license information that Amazon EVS requires to create an environment. Amazon EVS requires two license keys: a VCF solution key and a vSAN license key. The VCF solution key must cover a minimum of 256 cores. The vSAN license key must provide at least 110 TiB of vSAN capacity. VCF licenses can be used for only one Amazon EVS environment. Amazon EVS does not support reuse of VCF licenses for multiple environments. VCF license information can be retrieved from the Broadcom portal.
    /// This member is required.
    public var licenseInfo: [EvsClientTypes.LicenseInfo]?
    /// The security group that controls communication between the Amazon EVS control plane and VPC. The default security group is used if a custom security group isn't specified. The security group should allow access to the following.
    ///
    /// * TCP/UDP access to the DNS servers
    ///
    /// * HTTPS/SSH access to the host management VLAN subnet
    ///
    /// * HTTPS/SSH access to the Management VM VLAN subnet
    ///
    ///
    /// You should avoid modifying the security group rules after deployment, as this can break the persistent connection between the Amazon EVS control plane and VPC. This can cause future environment actions like adding or removing hosts to fail.
    public var serviceAccessSecurityGroups: EvsClientTypes.ServiceAccessSecurityGroups?
    /// The subnet that is used to establish connectivity between the Amazon EVS control plane and VPC. Amazon EVS uses this subnet to validate mandatory DNS records for your VCF appliances and hosts and create the environment.
    /// This member is required.
    public var serviceAccessSubnetId: Swift.String?
    /// The Broadcom Site ID that is allocated to you as part of your electronic software delivery. This ID allows customer access to the Broadcom portal, and is provided to you by Broadcom at the close of your software contract or contract renewal. Amazon EVS uses the Broadcom Site ID that you provide to meet Broadcom VCF license usage reporting requirements for Amazon EVS.
    /// This member is required.
    public var siteId: Swift.String?
    /// Metadata that assists with categorization and organization. Each tag consists of a key and an optional value. You define both. Tags don't propagate to any other cluster or Amazon Web Services resources.
    public var tags: [Swift.String: Swift.String]?
    /// Customer confirmation that the customer has purchased and will continue to maintain the required number of VCF software licenses to cover all physical processor cores in the Amazon EVS environment. Information about your VCF software in Amazon EVS will be shared with Broadcom to verify license compliance. Amazon EVS does not validate license keys. To validate license keys, visit the Broadcom support portal.
    /// This member is required.
    public var termsAccepted: Swift.Bool?
    /// The DNS hostnames for the virtual machines that host the VCF management appliances. Amazon EVS requires that you provide DNS hostnames for the following appliances: vCenter, NSX Manager, SDDC Manager, and Cloud Builder.
    /// This member is required.
    public var vcfHostnames: EvsClientTypes.VcfHostnames?
    /// The VCF version to use for the environment.
    /// This member is required.
    public var vcfVersion: EvsClientTypes.VcfVersion?
    /// A unique ID for the VPC that the environment is deployed inside. Amazon EVS requires that all VPC subnets exist in a single Availability Zone in a Region where the service is available. The VPC that you specify must have a valid DHCP option set with domain name, at least two DNS servers, and an NTP server. These settings are used to configure your VCF appliances and hosts. The VPC cannot be used with any other deployed Amazon EVS environment. Amazon EVS does not provide multi-VPC support for environments at this time. Amazon EVS does not support the following Amazon Web Services networking options for NSX overlay connectivity: cross-Region VPC peering, Amazon S3 gateway endpoints, or Amazon Web Services Direct Connect virtual private gateway associations. Ensure that you specify a VPC that is adequately sized to accommodate the Amazon EVS subnets.
    /// This member is required.
    public var vpcId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        connectivityInfo: EvsClientTypes.ConnectivityInfo? = nil,
        environmentName: Swift.String? = nil,
        hosts: [EvsClientTypes.HostInfoForCreate]? = nil,
        initialVlans: EvsClientTypes.InitialVlans? = nil,
        kmsKeyId: Swift.String? = nil,
        licenseInfo: [EvsClientTypes.LicenseInfo]? = nil,
        serviceAccessSecurityGroups: EvsClientTypes.ServiceAccessSecurityGroups? = nil,
        serviceAccessSubnetId: Swift.String? = nil,
        siteId: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil,
        termsAccepted: Swift.Bool? = nil,
        vcfHostnames: EvsClientTypes.VcfHostnames? = nil,
        vcfVersion: EvsClientTypes.VcfVersion? = nil,
        vpcId: Swift.String? = nil
    ) {
        self.clientToken = clientToken
        self.connectivityInfo = connectivityInfo
        self.environmentName = environmentName
        self.hosts = hosts
        self.initialVlans = initialVlans
        self.kmsKeyId = kmsKeyId
        self.licenseInfo = licenseInfo
        self.serviceAccessSecurityGroups = serviceAccessSecurityGroups
        self.serviceAccessSubnetId = serviceAccessSubnetId
        self.siteId = siteId
        self.tags = tags
        self.termsAccepted = termsAccepted
        self.vcfHostnames = vcfHostnames
        self.vcfVersion = vcfVersion
        self.vpcId = vpcId
    }
}

extension EvsClientTypes {

    public enum CheckResult: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case failed
        case passed
        case unknown
        case sdkUnknown(Swift.String)

        public static var allCases: [CheckResult] {
            return [
                .failed,
                .passed,
                .unknown
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .passed: return "PASSED"
            case .unknown: return "UNKNOWN"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension EvsClientTypes {

    public enum CheckType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case hostCount
        case keyCoverage
        case keyReuse
        case reachability
        case sdkUnknown(Swift.String)

        public static var allCases: [CheckType] {
            return [
                .hostCount,
                .keyCoverage,
                .keyReuse,
                .reachability
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .hostCount: return "HOST_COUNT"
            case .keyCoverage: return "KEY_COVERAGE"
            case .keyReuse: return "KEY_REUSE"
            case .reachability: return "REACHABILITY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension EvsClientTypes {

    /// A check on the environment to identify environment health and validate VMware VCF licensing compliance.
    public struct Check: Swift.Sendable {
        /// The time when environment health began to be impaired.
        public var impairedSince: Foundation.Date?
        /// The check result.
        public var result: EvsClientTypes.CheckResult?
        /// The check type. Amazon EVS performs the following checks.
        ///
        /// * KEY_REUSE: checks that the VCF license key is not used by another Amazon EVS environment. This check fails if a used license is added to the environment.
        ///
        /// * KEY_COVERAGE: checks that your VCF license key allocates sufficient vCPU cores for all deployed hosts. The check fails when any assigned hosts in the EVS environment are not covered by license keys, or when any unassigned hosts cannot be covered by available vCPU cores in keys.
        ///
        /// * REACHABILITY: checks that the Amazon EVS control plane has a persistent connection to SDDC Manager. If Amazon EVS cannot reach the environment, this check fails.
        ///
        /// * HOST_COUNT: Checks that your environment has a minimum of 4 hosts. If this check fails, you will need to add hosts so that your environment meets this minimum requirement. Amazon EVS only supports environments with 4-16 hosts.
        public var type: EvsClientTypes.CheckType?

        public init(
            impairedSince: Foundation.Date? = nil,
            result: EvsClientTypes.CheckResult? = nil,
            type: EvsClientTypes.CheckType? = nil
        ) {
            self.impairedSince = impairedSince
            self.result = result
            self.type = type
        }
    }
}

extension EvsClientTypes {

    /// A managed secret that contains the credentials for installing vCenter Server, NSX, and SDDC Manager. During environment creation, the Amazon EVS control plane uses Amazon Web Services Secrets Manager to create, encrypt, validate, and store secrets. If you choose to delete your environment, Amazon EVS also deletes the secrets that are associated with your environment. Amazon EVS does not provide managed rotation of secrets. We recommend that you rotate secrets regularly to ensure that secrets are not long-lived.
    public struct Secret: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the secret.
        public var secretArn: Swift.String?

        public init(
            secretArn: Swift.String? = nil
        ) {
            self.secretArn = secretArn
        }
    }
}

extension EvsClientTypes {

    public enum EnvironmentState: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case created
        case createFailed
        case creating
        case deleted
        case deleting
        case sdkUnknown(Swift.String)

        public static var allCases: [EnvironmentState] {
            return [
                .created,
                .createFailed,
                .creating,
                .deleted,
                .deleting
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .created: return "CREATED"
            case .createFailed: return "CREATE_FAILED"
            case .creating: return "CREATING"
            case .deleted: return "DELETED"
            case .deleting: return "DELETING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension EvsClientTypes {

    /// An object that represents an Amazon EVS environment.
    public struct Environment: Swift.Sendable {
        /// A check on the environment to identify instance health and VMware VCF licensing issues.
        public var checks: [EvsClientTypes.Check]?
        /// The connectivity configuration for the environment. Amazon EVS requires that you specify two route server peer IDs. During environment creation, the route server endpoints peer with the NSX uplink VLAN for connectivity to the NSX overlay network.
        public var connectivityInfo: EvsClientTypes.ConnectivityInfo?
        /// The date and time that the environment was created.
        public var createdAt: Foundation.Date?
        /// The VCF credentials that are stored as Amazon EVS managed secrets in Amazon Web Services Secrets Manager. Amazon EVS stores credentials that are needed to install vCenter Server, NSX, and SDDC Manager.
        public var credentials: [EvsClientTypes.Secret]?
        /// The Amazon Resource Name (ARN) that is associated with the environment.
        public var environmentArn: Swift.String?
        /// The unique ID for the environment.
        public var environmentId: Swift.String?
        /// The name of the environment.
        public var environmentName: Swift.String?
        /// The state of an environment.
        public var environmentState: EvsClientTypes.EnvironmentState?
        /// Reports impaired functionality that stems from issues internal to the environment, such as impaired reachability.
        public var environmentStatus: EvsClientTypes.CheckResult?
        /// The Amazon Web Services KMS key ID that Amazon Web Services Secrets Manager uses to encrypt secrets that are associated with the environment. These secrets contain the VCF credentials that are needed to install vCenter Server, NSX, and SDDC Manager. By default, Amazon EVS use the Amazon Web Services Secrets Manager managed key aws/secretsmanager. You can also specify a customer managed key.
        public var kmsKeyId: Swift.String?
        /// The license information that Amazon EVS requires to create an environment. Amazon EVS requires two license keys: a VCF solution key and a vSAN license key. The VCF solution key must cover a minimum of 256 cores. The vSAN license key must provide at least 110 TiB of vSAN capacity.
        public var licenseInfo: [EvsClientTypes.LicenseInfo]?
        /// The date and time that the environment was modified.
        public var modifiedAt: Foundation.Date?
        /// The security groups that allow traffic between the Amazon EVS control plane and your VPC for service access. If a security group is not specified, Amazon EVS uses the default security group in your account for service access.
        public var serviceAccessSecurityGroups: EvsClientTypes.ServiceAccessSecurityGroups?
        /// The subnet that is used to establish connectivity between the Amazon EVS control plane and VPC. Amazon EVS uses this subnet to perform validations and create the environment.
        public var serviceAccessSubnetId: Swift.String?
        /// The Broadcom Site ID that is associated with your Amazon EVS environment. Amazon EVS uses the Broadcom Site ID that you provide to meet Broadcom VCF license usage reporting requirements for Amazon EVS.
        public var siteId: Swift.String?
        /// A detailed description of the environmentState of an environment.
        public var stateDetails: Swift.String?
        /// Customer confirmation that the customer has purchased and will continue to maintain the required number of VCF software licenses to cover all physical processor cores in the Amazon EVS environment. Information about your VCF software in Amazon EVS will be shared with Broadcom to verify license compliance. Amazon EVS does not validate license keys. To validate license keys, visit the Broadcom support portal.
        public var termsAccepted: Swift.Bool?
        /// The DNS hostnames to be used by the VCF management appliances in your environment. For environment creation to be successful, each hostname entry must resolve to a domain name that you've registered in your DNS service of choice and configured in the DHCP option set of your VPC. DNS hostnames cannot be changed after environment creation has started.
        public var vcfHostnames: EvsClientTypes.VcfHostnames?
        /// The VCF version of the environment.
        public var vcfVersion: EvsClientTypes.VcfVersion?
        /// The VPC associated with the environment.
        public var vpcId: Swift.String?

        public init(
            checks: [EvsClientTypes.Check]? = nil,
            connectivityInfo: EvsClientTypes.ConnectivityInfo? = nil,
            createdAt: Foundation.Date? = nil,
            credentials: [EvsClientTypes.Secret]? = nil,
            environmentArn: Swift.String? = nil,
            environmentId: Swift.String? = nil,
            environmentName: Swift.String? = nil,
            environmentState: EvsClientTypes.EnvironmentState? = nil,
            environmentStatus: EvsClientTypes.CheckResult? = nil,
            kmsKeyId: Swift.String? = nil,
            licenseInfo: [EvsClientTypes.LicenseInfo]? = nil,
            modifiedAt: Foundation.Date? = nil,
            serviceAccessSecurityGroups: EvsClientTypes.ServiceAccessSecurityGroups? = nil,
            serviceAccessSubnetId: Swift.String? = nil,
            siteId: Swift.String? = nil,
            stateDetails: Swift.String? = nil,
            termsAccepted: Swift.Bool? = nil,
            vcfHostnames: EvsClientTypes.VcfHostnames? = nil,
            vcfVersion: EvsClientTypes.VcfVersion? = nil,
            vpcId: Swift.String? = nil
        ) {
            self.checks = checks
            self.connectivityInfo = connectivityInfo
            self.createdAt = createdAt
            self.credentials = credentials
            self.environmentArn = environmentArn
            self.environmentId = environmentId
            self.environmentName = environmentName
            self.environmentState = environmentState
            self.environmentStatus = environmentStatus
            self.kmsKeyId = kmsKeyId
            self.licenseInfo = licenseInfo
            self.modifiedAt = modifiedAt
            self.serviceAccessSecurityGroups = serviceAccessSecurityGroups
            self.serviceAccessSubnetId = serviceAccessSubnetId
            self.siteId = siteId
            self.stateDetails = stateDetails
            self.termsAccepted = termsAccepted
            self.vcfHostnames = vcfHostnames
            self.vcfVersion = vcfVersion
            self.vpcId = vpcId
        }
    }
}

public struct CreateEnvironmentOutput: Swift.Sendable {
    /// A description of the created environment.
    public var environment: EvsClientTypes.Environment?

    public init(
        environment: EvsClientTypes.Environment? = nil
    ) {
        self.environment = environment
    }
}

public struct CreateEnvironmentHostInput: Swift.Sendable {
    /// This parameter is not used in Amazon EVS currently. If you supply input for this parameter, it will have no effect. A unique, case-sensitive identifier that you provide to ensure the idempotency of the host creation request. If you do not specify a client token, a randomly generated token is used for the request to ensure idempotency.
    public var clientToken: Swift.String?
    /// A unique ID for the environment that the host is added to.
    /// This member is required.
    public var environmentId: Swift.String?
    /// The ESX version to use for the host.
    public var esxVersion: Swift.String?
    /// The host that is created and added to the environment.
    /// This member is required.
    public var host: EvsClientTypes.HostInfoForCreate?

    public init(
        clientToken: Swift.String? = nil,
        environmentId: Swift.String? = nil,
        esxVersion: Swift.String? = nil,
        host: EvsClientTypes.HostInfoForCreate? = nil
    ) {
        self.clientToken = clientToken
        self.environmentId = environmentId
        self.esxVersion = esxVersion
        self.host = host
    }
}

extension EvsClientTypes {

    /// A list of environments with summarized environment details.
    public struct EnvironmentSummary: Swift.Sendable {
        /// The date and time that the environment was created.
        public var createdAt: Foundation.Date?
        /// The Amazon Resource Name (ARN) that is associated with the environment.
        public var environmentArn: Swift.String?
        /// A unique ID for the environment.
        public var environmentId: Swift.String?
        /// The name of the environment.
        public var environmentName: Swift.String?
        /// The state of an environment.
        public var environmentState: EvsClientTypes.EnvironmentState?
        /// Reports impaired functionality that stems from issues internal to the environment, such as impaired reachability.
        public var environmentStatus: EvsClientTypes.CheckResult?
        /// The date and time that the environment was modified.
        public var modifiedAt: Foundation.Date?
        /// The VCF version of the environment.
        public var vcfVersion: EvsClientTypes.VcfVersion?

        public init(
            createdAt: Foundation.Date? = nil,
            environmentArn: Swift.String? = nil,
            environmentId: Swift.String? = nil,
            environmentName: Swift.String? = nil,
            environmentState: EvsClientTypes.EnvironmentState? = nil,
            environmentStatus: EvsClientTypes.CheckResult? = nil,
            modifiedAt: Foundation.Date? = nil,
            vcfVersion: EvsClientTypes.VcfVersion? = nil
        ) {
            self.createdAt = createdAt
            self.environmentArn = environmentArn
            self.environmentId = environmentId
            self.environmentName = environmentName
            self.environmentState = environmentState
            self.environmentStatus = environmentStatus
            self.modifiedAt = modifiedAt
            self.vcfVersion = vcfVersion
        }
    }
}

extension EvsClientTypes {

    public enum HostState: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case created
        case createFailed
        case creating
        case deleted
        case deleting
        case updateFailed
        case updating
        case sdkUnknown(Swift.String)

        public static var allCases: [HostState] {
            return [
                .created,
                .createFailed,
                .creating,
                .deleted,
                .deleting,
                .updateFailed,
                .updating
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .created: return "CREATED"
            case .createFailed: return "CREATE_FAILED"
            case .creating: return "CREATING"
            case .deleted: return "DELETED"
            case .deleting: return "DELETING"
            case .updateFailed: return "UPDATE_FAILED"
            case .updating: return "UPDATING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension EvsClientTypes {

    /// An elastic network interface (ENI) that connects hosts to the VLAN subnets. Amazon EVS provisions two identically configured ENIs in the VMkernel management subnet during host creation. One ENI is active, and the other is in standby mode for automatic switchover during a failure scenario.
    public struct NetworkInterface: Swift.Sendable {
        /// The unique ID of the elastic network interface.
        public var networkInterfaceId: Swift.String?

        public init(
            networkInterfaceId: Swift.String? = nil
        ) {
            self.networkInterfaceId = networkInterfaceId
        }
    }
}

extension EvsClientTypes {

    /// An ESX host that runs on an Amazon EC2 bare metal instance. Four hosts are created in an Amazon EVS environment during environment creation. You can add hosts to an environment using the CreateEnvironmentHost operation. Amazon EVS supports 4-16 hosts per environment.
    public struct Host: Swift.Sendable {
        /// The date and time that the host was created.
        public var createdAt: Foundation.Date?
        /// The unique ID of the Amazon EC2 Dedicated Host.
        public var dedicatedHostId: Swift.String?
        /// The unique ID of the EC2 instance that represents the host.
        public var ec2InstanceId: Swift.String?
        /// The DNS hostname of the host. DNS hostnames for hosts must be unique across Amazon EVS environments and within VCF.
        public var hostName: Swift.String?
        /// The state of the host.
        public var hostState: EvsClientTypes.HostState?
        /// The EC2 instance type of the host. Currently, Amazon EVS supports only the i4i.metal instance type. EC2 instances created through Amazon EVS do not support associating an IAM instance profile.
        public var instanceType: EvsClientTypes.InstanceType?
        /// The IP address of the host.
        public var ipAddress: Swift.String?
        /// The name of the SSH key that is used to access the host.
        public var keyName: Swift.String?
        /// The date and time that the host was modified.
        public var modifiedAt: Foundation.Date?
        /// The elastic network interfaces that are attached to the host.
        public var networkInterfaces: [EvsClientTypes.NetworkInterface]?
        /// The unique ID of the placement group where the host is placed.
        public var placementGroupId: Swift.String?
        /// A detailed description of the hostState of a host.
        public var stateDetails: Swift.String?

        public init(
            createdAt: Foundation.Date? = nil,
            dedicatedHostId: Swift.String? = nil,
            ec2InstanceId: Swift.String? = nil,
            hostName: Swift.String? = nil,
            hostState: EvsClientTypes.HostState? = nil,
            instanceType: EvsClientTypes.InstanceType? = nil,
            ipAddress: Swift.String? = nil,
            keyName: Swift.String? = nil,
            modifiedAt: Foundation.Date? = nil,
            networkInterfaces: [EvsClientTypes.NetworkInterface]? = nil,
            placementGroupId: Swift.String? = nil,
            stateDetails: Swift.String? = nil
        ) {
            self.createdAt = createdAt
            self.dedicatedHostId = dedicatedHostId
            self.ec2InstanceId = ec2InstanceId
            self.hostName = hostName
            self.hostState = hostState
            self.instanceType = instanceType
            self.ipAddress = ipAddress
            self.keyName = keyName
            self.modifiedAt = modifiedAt
            self.networkInterfaces = networkInterfaces
            self.placementGroupId = placementGroupId
            self.stateDetails = stateDetails
        }
    }
}

public struct CreateEnvironmentHostOutput: Swift.Sendable {
    /// A summary of the environment that the host is created in.
    public var environmentSummary: EvsClientTypes.EnvironmentSummary?
    /// A description of the created host.
    public var host: EvsClientTypes.Host?

    public init(
        environmentSummary: EvsClientTypes.EnvironmentSummary? = nil,
        host: EvsClientTypes.Host? = nil
    ) {
        self.environmentSummary = environmentSummary
        self.host = host
    }
}

public struct DeleteEnvironmentInput: Swift.Sendable {
    /// This parameter is not used in Amazon EVS currently. If you supply input for this parameter, it will have no effect. A unique, case-sensitive identifier that you provide to ensure the idempotency of the environment deletion request. If you do not specify a client token, a randomly generated token is used for the request to ensure idempotency.
    public var clientToken: Swift.String?
    /// A unique ID associated with the environment to be deleted.
    /// This member is required.
    public var environmentId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        environmentId: Swift.String? = nil
    ) {
        self.clientToken = clientToken
        self.environmentId = environmentId
    }
}

public struct DeleteEnvironmentOutput: Swift.Sendable {
    /// A description of the deleted environment.
    public var environment: EvsClientTypes.Environment?

    public init(
        environment: EvsClientTypes.Environment? = nil
    ) {
        self.environment = environment
    }
}

public struct DeleteEnvironmentHostInput: Swift.Sendable {
    /// This parameter is not used in Amazon EVS currently. If you supply input for this parameter, it will have no effect. A unique, case-sensitive identifier that you provide to ensure the idempotency of the host deletion request. If you do not specify a client token, a randomly generated token is used for the request to ensure idempotency.
    public var clientToken: Swift.String?
    /// A unique ID for the host's environment.
    /// This member is required.
    public var environmentId: Swift.String?
    /// The DNS hostname associated with the host to be deleted.
    /// This member is required.
    public var hostName: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        environmentId: Swift.String? = nil,
        hostName: Swift.String? = nil
    ) {
        self.clientToken = clientToken
        self.environmentId = environmentId
        self.hostName = hostName
    }
}

public struct DeleteEnvironmentHostOutput: Swift.Sendable {
    /// A summary of the environment that the host was deleted from.
    public var environmentSummary: EvsClientTypes.EnvironmentSummary?
    /// A description of the deleted host.
    public var host: EvsClientTypes.Host?

    public init(
        environmentSummary: EvsClientTypes.EnvironmentSummary? = nil,
        host: EvsClientTypes.Host? = nil
    ) {
        self.environmentSummary = environmentSummary
        self.host = host
    }
}

public struct DisassociateEipFromVlanInput: Swift.Sendable {
    /// A unique ID for the Elastic IP address association.
    /// This member is required.
    public var associationId: Swift.String?
    /// This parameter is not used in Amazon EVS currently. If you supply input for this parameter, it will have no effect. A unique, case-sensitive identifier that you provide to ensure the idempotency of the environment creation request. If you do not specify a client token, a randomly generated token is used for the request to ensure idempotency.
    public var clientToken: Swift.String?
    /// A unique ID for the environment containing the VLAN that the Elastic IP address disassociates from.
    /// This member is required.
    public var environmentId: Swift.String?
    /// The name of the VLAN. hcx is the only accepted VLAN name at this time.
    /// This member is required.
    public var vlanName: Swift.String?

    public init(
        associationId: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        environmentId: Swift.String? = nil,
        vlanName: Swift.String? = nil
    ) {
        self.associationId = associationId
        self.clientToken = clientToken
        self.environmentId = environmentId
        self.vlanName = vlanName
    }
}

public struct DisassociateEipFromVlanOutput: Swift.Sendable {
    /// The VLANs that Amazon EVS creates during environment creation.
    public var vlan: EvsClientTypes.Vlan?

    public init(
        vlan: EvsClientTypes.Vlan? = nil
    ) {
        self.vlan = vlan
    }
}

public struct GetEnvironmentInput: Swift.Sendable {
    /// A unique ID for the environment.
    /// This member is required.
    public var environmentId: Swift.String?

    public init(
        environmentId: Swift.String? = nil
    ) {
        self.environmentId = environmentId
    }
}

public struct GetEnvironmentOutput: Swift.Sendable {
    /// A description of the requested environment.
    public var environment: EvsClientTypes.Environment?

    public init(
        environment: EvsClientTypes.Environment? = nil
    ) {
        self.environment = environment
    }
}

public struct ListEnvironmentHostsInput: Swift.Sendable {
    /// A unique ID for the environment.
    /// This member is required.
    public var environmentId: Swift.String?
    /// The maximum number of results to return. If you specify MaxResults in the request, the response includes information up to the limit specified.
    public var maxResults: Swift.Int?
    /// A unique pagination token for each page. If nextToken is returned, there are more results available. Make the call again using the returned token with all other arguments unchanged to retrieve the next page. Each pagination token expires after 24 hours. Using an expired pagination token will return an HTTP 400 InvalidToken error.
    public var nextToken: Swift.String?

    public init(
        environmentId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.environmentId = environmentId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListEnvironmentHostsOutput: Swift.Sendable {
    /// A list of hosts in the environment.
    public var environmentHosts: [EvsClientTypes.Host]?
    /// A unique pagination token for next page results. Make the call again using this token to retrieve the next page.
    public var nextToken: Swift.String?

    public init(
        environmentHosts: [EvsClientTypes.Host]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.environmentHosts = environmentHosts
        self.nextToken = nextToken
    }
}

public struct ListEnvironmentsInput: Swift.Sendable {
    /// The maximum number of results to return. If you specify MaxResults in the request, the response includes information up to the limit specified.
    public var maxResults: Swift.Int?
    /// A unique pagination token for each page. If nextToken is returned, there are more results available. Make the call again using the returned token with all other arguments unchanged to retrieve the next page. Each pagination token expires after 24 hours. Using an expired pagination token will return an HTTP 400 InvalidToken error.
    public var nextToken: Swift.String?
    /// The state of an environment. Used to filter response results to return only environments with the specified environmentState.
    public var state: [EvsClientTypes.EnvironmentState]?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        state: [EvsClientTypes.EnvironmentState]? = nil
    ) {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.state = state
    }
}

public struct ListEnvironmentsOutput: Swift.Sendable {
    /// A list of environments with summarized environment details.
    public var environmentSummaries: [EvsClientTypes.EnvironmentSummary]?
    /// A unique pagination token for next page results. Make the call again using this token to retrieve the next page.
    public var nextToken: Swift.String?

    public init(
        environmentSummaries: [EvsClientTypes.EnvironmentSummary]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.environmentSummaries = environmentSummaries
        self.nextToken = nextToken
    }
}

public struct ListEnvironmentVlansInput: Swift.Sendable {
    /// A unique ID for the environment.
    /// This member is required.
    public var environmentId: Swift.String?
    /// The maximum number of results to return. If you specify MaxResults in the request, the response includes information up to the limit specified.
    public var maxResults: Swift.Int?
    /// A unique pagination token for each page. If nextToken is returned, there are more results available. Make the call again using the returned token with all other arguments unchanged to retrieve the next page. Each pagination token expires after 24 hours. Using an expired pagination token will return an HTTP 400 InvalidToken error.
    public var nextToken: Swift.String?

    public init(
        environmentId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.environmentId = environmentId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListEnvironmentVlansOutput: Swift.Sendable {
    /// A list of VLANs that are associated with the specified environment.
    public var environmentVlans: [EvsClientTypes.Vlan]?
    /// A unique pagination token for next page results. Make the call again using this token to retrieve the next page.
    public var nextToken: Swift.String?

    public init(
        environmentVlans: [EvsClientTypes.Vlan]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.environmentVlans = environmentVlans
        self.nextToken = nextToken
    }
}

/// An internal server error occurred. Retry your request.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// Describes the error encountered.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

public struct GetVersionsInput: Swift.Sendable {

    public init() { }
}

extension EvsClientTypes {

    /// Information about ESX versions offered for each EC2 instance type.
    public struct InstanceTypeEsxVersionsInfo: Swift.Sendable {
        /// The list of ESX versions offered for this instance type.
        /// This member is required.
        public var esxVersions: [Swift.String]?
        /// The EC2 instance type.
        /// This member is required.
        public var instanceType: EvsClientTypes.InstanceType?

        public init(
            esxVersions: [Swift.String]? = nil,
            instanceType: EvsClientTypes.InstanceType? = nil
        ) {
            self.esxVersions = esxVersions
            self.instanceType = instanceType
        }
    }
}

extension EvsClientTypes {

    /// Information about a VCF versions provided by Amazon EVS, including its status, default ESX version, and EC2 instance types.
    public struct VcfVersionInfo: Swift.Sendable {
        /// The default ESX version for this VCF version. It is based on Broadcom's Bill Of Materials (BOM).
        /// This member is required.
        public var defaultEsxVersion: Swift.String?
        /// EC2 instance types provided by Amazon EVS for this VCF version for creating environments.
        /// This member is required.
        public var instanceTypes: [EvsClientTypes.InstanceType]?
        /// The status for this VCF version. Valid values are:
        ///
        /// * AVAILABLE - This VCF version is available to you.
        ///
        /// * RESTRICTED - This VCF version has limited availability.
        ///
        ///
        /// If the version you need shows RESTRICTED, and you require, check out [VCF versions and EC2 instance types provided by Amazon EVS](https://docs.aws.amazon.com/evs/latest/userguide/versions-provided.html) for more information.
        /// This member is required.
        public var status: Swift.String?
        /// The VCF version number.
        /// This member is required.
        public var vcfVersion: EvsClientTypes.VcfVersion?

        public init(
            defaultEsxVersion: Swift.String? = nil,
            instanceTypes: [EvsClientTypes.InstanceType]? = nil,
            status: Swift.String? = nil,
            vcfVersion: EvsClientTypes.VcfVersion? = nil
        ) {
            self.defaultEsxVersion = defaultEsxVersion
            self.instanceTypes = instanceTypes
            self.status = status
            self.vcfVersion = vcfVersion
        }
    }
}

public struct GetVersionsOutput: Swift.Sendable {
    /// A list of EC2 instance types and their available ESX versions.
    /// This member is required.
    public var instanceTypeEsxVersions: [EvsClientTypes.InstanceTypeEsxVersionsInfo]?
    /// A list of VCF versions with their availability status, default ESX version, and instance types.
    /// This member is required.
    public var vcfVersions: [EvsClientTypes.VcfVersionInfo]?

    public init(
        instanceTypeEsxVersions: [EvsClientTypes.InstanceTypeEsxVersionsInfo]? = nil,
        vcfVersions: [EvsClientTypes.VcfVersionInfo]? = nil
    ) {
        self.instanceTypeEsxVersions = instanceTypeEsxVersions
        self.vcfVersions = vcfVersions
    }
}

public struct ListTagsForResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) that identifies the resource to list tags for.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    ) {
        self.resourceArn = resourceArn
    }
}

public struct ListTagsForResourceOutput: Swift.Sendable {
    /// The tags for the resource.
    public var tags: [Swift.String: Swift.String]?

    public init(
        tags: [Swift.String: Swift.String]? = nil
    ) {
        self.tags = tags
    }
}

/// The number of one or more Amazon EVS resources exceeds the maximum allowed. For a list of Amazon EVS quotas, see [Amazon EVS endpoints and quotas](https://docs.aws.amazon.com/evs/latest/userguide/service-quotas-evs.html) in the Amazon EVS User Guide. Delete some resources or request an increase in your service quota. To request an increase, see [Amazon Web Services Service Quotas](https://docs.aws.amazon.com/general/latest/gr/aws_service_limits.html) in the Amazon Web Services General Reference Guide.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// Describes the error encountered.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

/// TagPolicyException is deprecated. See [ValidationException](https://docs.aws.amazon.com/evs/latest/APIReference/API_ValidationException.html) instead. The request doesn't comply with IAM tag policy. Correct your request and then retry it.
public struct TagPolicyException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// Describes the error encountered
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TagPolicyException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

/// TooManyTagsException is deprecated. See [ServiceQuotaExceededException](https://docs.aws.amazon.com/evs/latest/APIReference/API_ServiceQuotaExceededException.html) instead. A service resource associated with the request has more than 200 tags.
public struct TooManyTagsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// Describes the error encountered.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyTagsException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

public struct TagResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the resource to add tags to.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// Metadata that assists with categorization and organization. Each tag consists of a key and an optional value. You define both. Tags don't propagate to any other environment or Amazon Web Services resources.
    /// This member is required.
    public var tags: [Swift.String: Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    ) {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

public struct TagResourceOutput: Swift.Sendable {

    public init() { }
}

public struct UntagResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the resource to delete tags from.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The keys of the tags to delete.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    ) {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

public struct UntagResourceOutput: Swift.Sendable {

    public init() { }
}

extension AssociateEipToVlanInput {

    static func urlPathProvider(_ value: AssociateEipToVlanInput) -> Swift.String? {
        return "/"
    }
}

extension CreateEnvironmentInput {

    static func urlPathProvider(_ value: CreateEnvironmentInput) -> Swift.String? {
        return "/"
    }
}

extension CreateEnvironmentHostInput {

    static func urlPathProvider(_ value: CreateEnvironmentHostInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteEnvironmentInput {

    static func urlPathProvider(_ value: DeleteEnvironmentInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteEnvironmentHostInput {

    static func urlPathProvider(_ value: DeleteEnvironmentHostInput) -> Swift.String? {
        return "/"
    }
}

extension DisassociateEipFromVlanInput {

    static func urlPathProvider(_ value: DisassociateEipFromVlanInput) -> Swift.String? {
        return "/"
    }
}

extension GetEnvironmentInput {

    static func urlPathProvider(_ value: GetEnvironmentInput) -> Swift.String? {
        return "/"
    }
}

extension GetVersionsInput {

    static func urlPathProvider(_ value: GetVersionsInput) -> Swift.String? {
        return "/"
    }
}

extension ListEnvironmentHostsInput {

    static func urlPathProvider(_ value: ListEnvironmentHostsInput) -> Swift.String? {
        return "/"
    }
}

extension ListEnvironmentsInput {

    static func urlPathProvider(_ value: ListEnvironmentsInput) -> Swift.String? {
        return "/"
    }
}

extension ListEnvironmentVlansInput {

    static func urlPathProvider(_ value: ListEnvironmentVlansInput) -> Swift.String? {
        return "/"
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        return "/"
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        return "/"
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        return "/"
    }
}

extension AssociateEipToVlanInput {

    static func write(value: AssociateEipToVlanInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["allocationId"].write(value.allocationId)
        try writer["clientToken"].write(value.clientToken)
        try writer["environmentId"].write(value.environmentId)
        try writer["vlanName"].write(value.vlanName)
    }
}

extension CreateEnvironmentInput {

    static func write(value: CreateEnvironmentInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["connectivityInfo"].write(value.connectivityInfo, with: EvsClientTypes.ConnectivityInfo.write(value:to:))
        try writer["environmentName"].write(value.environmentName)
        try writer["hosts"].writeList(value.hosts, memberWritingClosure: EvsClientTypes.HostInfoForCreate.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["initialVlans"].write(value.initialVlans, with: EvsClientTypes.InitialVlans.write(value:to:))
        try writer["kmsKeyId"].write(value.kmsKeyId)
        try writer["licenseInfo"].writeList(value.licenseInfo, memberWritingClosure: EvsClientTypes.LicenseInfo.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["serviceAccessSecurityGroups"].write(value.serviceAccessSecurityGroups, with: EvsClientTypes.ServiceAccessSecurityGroups.write(value:to:))
        try writer["serviceAccessSubnetId"].write(value.serviceAccessSubnetId)
        try writer["siteId"].write(value.siteId)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["termsAccepted"].write(value.termsAccepted)
        try writer["vcfHostnames"].write(value.vcfHostnames, with: EvsClientTypes.VcfHostnames.write(value:to:))
        try writer["vcfVersion"].write(value.vcfVersion)
        try writer["vpcId"].write(value.vpcId)
    }
}

extension CreateEnvironmentHostInput {

    static func write(value: CreateEnvironmentHostInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["environmentId"].write(value.environmentId)
        try writer["esxVersion"].write(value.esxVersion)
        try writer["host"].write(value.host, with: EvsClientTypes.HostInfoForCreate.write(value:to:))
    }
}

extension DeleteEnvironmentInput {

    static func write(value: DeleteEnvironmentInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["environmentId"].write(value.environmentId)
    }
}

extension DeleteEnvironmentHostInput {

    static func write(value: DeleteEnvironmentHostInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["environmentId"].write(value.environmentId)
        try writer["hostName"].write(value.hostName)
    }
}

extension DisassociateEipFromVlanInput {

    static func write(value: DisassociateEipFromVlanInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["associationId"].write(value.associationId)
        try writer["clientToken"].write(value.clientToken)
        try writer["environmentId"].write(value.environmentId)
        try writer["vlanName"].write(value.vlanName)
    }
}

extension GetEnvironmentInput {

    static func write(value: GetEnvironmentInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["environmentId"].write(value.environmentId)
    }
}

extension GetVersionsInput {

    static func write(value: GetVersionsInput?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }
}

extension ListEnvironmentHostsInput {

    static func write(value: ListEnvironmentHostsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["environmentId"].write(value.environmentId)
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension ListEnvironmentsInput {

    static func write(value: ListEnvironmentsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
        try writer["state"].writeList(value.state, memberWritingClosure: SmithyReadWrite.WritingClosureBox<EvsClientTypes.EnvironmentState>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension ListEnvironmentVlansInput {

    static func write(value: ListEnvironmentVlansInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["environmentId"].write(value.environmentId)
        try writer["maxResults"].write(value.maxResults)
        try writer["nextToken"].write(value.nextToken)
    }
}

extension ListTagsForResourceInput {

    static func write(value: ListTagsForResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["resourceArn"].write(value.resourceArn)
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["resourceArn"].write(value.resourceArn)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension UntagResourceInput {

    static func write(value: UntagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["resourceArn"].write(value.resourceArn)
        try writer["tagKeys"].writeList(value.tagKeys, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension AssociateEipToVlanOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AssociateEipToVlanOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = AssociateEipToVlanOutput()
        value.vlan = try reader["vlan"].readIfPresent(with: EvsClientTypes.Vlan.read(from:))
        return value
    }
}

extension CreateEnvironmentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateEnvironmentOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateEnvironmentOutput()
        value.environment = try reader["environment"].readIfPresent(with: EvsClientTypes.Environment.read(from:))
        return value
    }
}

extension CreateEnvironmentHostOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateEnvironmentHostOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateEnvironmentHostOutput()
        value.environmentSummary = try reader["environmentSummary"].readIfPresent(with: EvsClientTypes.EnvironmentSummary.read(from:))
        value.host = try reader["host"].readIfPresent(with: EvsClientTypes.Host.read(from:))
        return value
    }
}

extension DeleteEnvironmentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteEnvironmentOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteEnvironmentOutput()
        value.environment = try reader["environment"].readIfPresent(with: EvsClientTypes.Environment.read(from:))
        return value
    }
}

extension DeleteEnvironmentHostOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteEnvironmentHostOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DeleteEnvironmentHostOutput()
        value.environmentSummary = try reader["environmentSummary"].readIfPresent(with: EvsClientTypes.EnvironmentSummary.read(from:))
        value.host = try reader["host"].readIfPresent(with: EvsClientTypes.Host.read(from:))
        return value
    }
}

extension DisassociateEipFromVlanOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DisassociateEipFromVlanOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = DisassociateEipFromVlanOutput()
        value.vlan = try reader["vlan"].readIfPresent(with: EvsClientTypes.Vlan.read(from:))
        return value
    }
}

extension GetEnvironmentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetEnvironmentOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetEnvironmentOutput()
        value.environment = try reader["environment"].readIfPresent(with: EvsClientTypes.Environment.read(from:))
        return value
    }
}

extension GetVersionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetVersionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetVersionsOutput()
        value.instanceTypeEsxVersions = try reader["instanceTypeEsxVersions"].readListIfPresent(memberReadingClosure: EvsClientTypes.InstanceTypeEsxVersionsInfo.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.vcfVersions = try reader["vcfVersions"].readListIfPresent(memberReadingClosure: EvsClientTypes.VcfVersionInfo.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension ListEnvironmentHostsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListEnvironmentHostsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListEnvironmentHostsOutput()
        value.environmentHosts = try reader["environmentHosts"].readListIfPresent(memberReadingClosure: EvsClientTypes.Host.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListEnvironmentsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListEnvironmentsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListEnvironmentsOutput()
        value.environmentSummaries = try reader["environmentSummaries"].readListIfPresent(memberReadingClosure: EvsClientTypes.EnvironmentSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListEnvironmentVlansOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListEnvironmentVlansOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListEnvironmentVlansOutput()
        value.environmentVlans = try reader["environmentVlans"].readListIfPresent(memberReadingClosure: EvsClientTypes.Vlan.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

enum AssociateEipToVlanOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateEnvironmentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateEnvironmentHostOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteEnvironmentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteEnvironmentHostOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DisassociateEipFromVlanOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetEnvironmentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetVersionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListEnvironmentHostsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListEnvironmentsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListEnvironmentVlansOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "TagPolicyException": return try TagPolicyException.makeError(baseError: baseError)
            case "TooManyTagsException": return try TooManyTagsException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "TagPolicyException": return try TagPolicyException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.properties.resourceId = try reader["resourceId"].readIfPresent() ?? ""
        value.properties.resourceType = try reader["resourceType"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ThrottlingException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ThrottlingException {
        let reader = baseError.errorBodyReader
        let httpResponse = baseError.httpResponse
        var value = ThrottlingException()
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            value.properties.retryAfterSeconds = Swift.Int(retryAfterSecondsHeaderValue) ?? 0
        }
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ValidationException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ValidationException {
        let reader = baseError.errorBodyReader
        var value = ValidationException()
        value.properties.fieldList = try reader["fieldList"].readListIfPresent(memberReadingClosure: EvsClientTypes.ValidationExceptionField.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.properties.reason = try reader["reason"].readIfPresent() ?? .sdkUnknown("")
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InternalServerException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InternalServerException {
        let reader = baseError.errorBodyReader
        var value = InternalServerException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ServiceQuotaExceededException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ServiceQuotaExceededException {
        let reader = baseError.errorBodyReader
        var value = ServiceQuotaExceededException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension TagPolicyException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> TagPolicyException {
        let reader = baseError.errorBodyReader
        var value = TagPolicyException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension TooManyTagsException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> TooManyTagsException {
        let reader = baseError.errorBodyReader
        var value = TooManyTagsException()
        value.properties.message = try reader["message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension EvsClientTypes.Vlan {

    static func read(from reader: SmithyJSON.Reader) throws -> EvsClientTypes.Vlan {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = EvsClientTypes.Vlan()
        value.vlanId = try reader["vlanId"].readIfPresent()
        value.cidr = try reader["cidr"].readIfPresent()
        value.availabilityZone = try reader["availabilityZone"].readIfPresent()
        value.functionName = try reader["functionName"].readIfPresent()
        value.subnetId = try reader["subnetId"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.modifiedAt = try reader["modifiedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.vlanState = try reader["vlanState"].readIfPresent()
        value.stateDetails = try reader["stateDetails"].readIfPresent()
        value.eipAssociations = try reader["eipAssociations"].readListIfPresent(memberReadingClosure: EvsClientTypes.EipAssociation.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.isPublic = try reader["isPublic"].readIfPresent()
        value.networkAclId = try reader["networkAclId"].readIfPresent()
        return value
    }
}

extension EvsClientTypes.EipAssociation {

    static func read(from reader: SmithyJSON.Reader) throws -> EvsClientTypes.EipAssociation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = EvsClientTypes.EipAssociation()
        value.associationId = try reader["associationId"].readIfPresent()
        value.allocationId = try reader["allocationId"].readIfPresent()
        value.ipAddress = try reader["ipAddress"].readIfPresent()
        return value
    }
}

extension EvsClientTypes.Environment {

    static func read(from reader: SmithyJSON.Reader) throws -> EvsClientTypes.Environment {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = EvsClientTypes.Environment()
        value.environmentId = try reader["environmentId"].readIfPresent()
        value.environmentState = try reader["environmentState"].readIfPresent()
        value.stateDetails = try reader["stateDetails"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.modifiedAt = try reader["modifiedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.environmentArn = try reader["environmentArn"].readIfPresent()
        value.environmentName = try reader["environmentName"].readIfPresent()
        value.vpcId = try reader["vpcId"].readIfPresent()
        value.serviceAccessSubnetId = try reader["serviceAccessSubnetId"].readIfPresent()
        value.vcfVersion = try reader["vcfVersion"].readIfPresent()
        value.termsAccepted = try reader["termsAccepted"].readIfPresent()
        value.licenseInfo = try reader["licenseInfo"].readListIfPresent(memberReadingClosure: EvsClientTypes.LicenseInfo.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.siteId = try reader["siteId"].readIfPresent()
        value.environmentStatus = try reader["environmentStatus"].readIfPresent()
        value.checks = try reader["checks"].readListIfPresent(memberReadingClosure: EvsClientTypes.Check.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.connectivityInfo = try reader["connectivityInfo"].readIfPresent(with: EvsClientTypes.ConnectivityInfo.read(from:))
        value.vcfHostnames = try reader["vcfHostnames"].readIfPresent(with: EvsClientTypes.VcfHostnames.read(from:))
        value.kmsKeyId = try reader["kmsKeyId"].readIfPresent()
        value.serviceAccessSecurityGroups = try reader["serviceAccessSecurityGroups"].readIfPresent(with: EvsClientTypes.ServiceAccessSecurityGroups.read(from:))
        value.credentials = try reader["credentials"].readListIfPresent(memberReadingClosure: EvsClientTypes.Secret.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension EvsClientTypes.Secret {

    static func read(from reader: SmithyJSON.Reader) throws -> EvsClientTypes.Secret {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = EvsClientTypes.Secret()
        value.secretArn = try reader["secretArn"].readIfPresent()
        return value
    }
}

extension EvsClientTypes.ServiceAccessSecurityGroups {

    static func write(value: EvsClientTypes.ServiceAccessSecurityGroups?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["securityGroups"].writeList(value.securityGroups, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> EvsClientTypes.ServiceAccessSecurityGroups {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = EvsClientTypes.ServiceAccessSecurityGroups()
        value.securityGroups = try reader["securityGroups"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension EvsClientTypes.VcfHostnames {

    static func write(value: EvsClientTypes.VcfHostnames?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["cloudBuilder"].write(value.cloudBuilder)
        try writer["nsx"].write(value.nsx)
        try writer["nsxEdge1"].write(value.nsxEdge1)
        try writer["nsxEdge2"].write(value.nsxEdge2)
        try writer["nsxManager1"].write(value.nsxManager1)
        try writer["nsxManager2"].write(value.nsxManager2)
        try writer["nsxManager3"].write(value.nsxManager3)
        try writer["sddcManager"].write(value.sddcManager)
        try writer["vCenter"].write(value.vCenter)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> EvsClientTypes.VcfHostnames {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = EvsClientTypes.VcfHostnames()
        value.vCenter = try reader["vCenter"].readIfPresent() ?? ""
        value.nsx = try reader["nsx"].readIfPresent() ?? ""
        value.nsxManager1 = try reader["nsxManager1"].readIfPresent() ?? ""
        value.nsxManager2 = try reader["nsxManager2"].readIfPresent() ?? ""
        value.nsxManager3 = try reader["nsxManager3"].readIfPresent() ?? ""
        value.nsxEdge1 = try reader["nsxEdge1"].readIfPresent() ?? ""
        value.nsxEdge2 = try reader["nsxEdge2"].readIfPresent() ?? ""
        value.sddcManager = try reader["sddcManager"].readIfPresent() ?? ""
        value.cloudBuilder = try reader["cloudBuilder"].readIfPresent() ?? ""
        return value
    }
}

extension EvsClientTypes.ConnectivityInfo {

    static func write(value: EvsClientTypes.ConnectivityInfo?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["privateRouteServerPeerings"].writeList(value.privateRouteServerPeerings, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> EvsClientTypes.ConnectivityInfo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = EvsClientTypes.ConnectivityInfo()
        value.privateRouteServerPeerings = try reader["privateRouteServerPeerings"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension EvsClientTypes.Check {

    static func read(from reader: SmithyJSON.Reader) throws -> EvsClientTypes.Check {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = EvsClientTypes.Check()
        value.type = try reader["type"].readIfPresent()
        value.result = try reader["result"].readIfPresent()
        value.impairedSince = try reader["impairedSince"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        return value
    }
}

extension EvsClientTypes.LicenseInfo {

    static func write(value: EvsClientTypes.LicenseInfo?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["solutionKey"].write(value.solutionKey)
        try writer["vsanKey"].write(value.vsanKey)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> EvsClientTypes.LicenseInfo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = EvsClientTypes.LicenseInfo()
        value.solutionKey = try reader["solutionKey"].readIfPresent() ?? ""
        value.vsanKey = try reader["vsanKey"].readIfPresent() ?? ""
        return value
    }
}

extension EvsClientTypes.EnvironmentSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> EvsClientTypes.EnvironmentSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = EvsClientTypes.EnvironmentSummary()
        value.environmentId = try reader["environmentId"].readIfPresent()
        value.environmentName = try reader["environmentName"].readIfPresent()
        value.vcfVersion = try reader["vcfVersion"].readIfPresent()
        value.environmentStatus = try reader["environmentStatus"].readIfPresent()
        value.environmentState = try reader["environmentState"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.modifiedAt = try reader["modifiedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.environmentArn = try reader["environmentArn"].readIfPresent()
        return value
    }
}

extension EvsClientTypes.Host {

    static func read(from reader: SmithyJSON.Reader) throws -> EvsClientTypes.Host {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = EvsClientTypes.Host()
        value.hostName = try reader["hostName"].readIfPresent()
        value.ipAddress = try reader["ipAddress"].readIfPresent()
        value.keyName = try reader["keyName"].readIfPresent()
        value.instanceType = try reader["instanceType"].readIfPresent()
        value.placementGroupId = try reader["placementGroupId"].readIfPresent()
        value.dedicatedHostId = try reader["dedicatedHostId"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.modifiedAt = try reader["modifiedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.hostState = try reader["hostState"].readIfPresent()
        value.stateDetails = try reader["stateDetails"].readIfPresent()
        value.ec2InstanceId = try reader["ec2InstanceId"].readIfPresent()
        value.networkInterfaces = try reader["networkInterfaces"].readListIfPresent(memberReadingClosure: EvsClientTypes.NetworkInterface.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension EvsClientTypes.NetworkInterface {

    static func read(from reader: SmithyJSON.Reader) throws -> EvsClientTypes.NetworkInterface {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = EvsClientTypes.NetworkInterface()
        value.networkInterfaceId = try reader["networkInterfaceId"].readIfPresent()
        return value
    }
}

extension EvsClientTypes.VcfVersionInfo {

    static func read(from reader: SmithyJSON.Reader) throws -> EvsClientTypes.VcfVersionInfo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = EvsClientTypes.VcfVersionInfo()
        value.vcfVersion = try reader["vcfVersion"].readIfPresent() ?? .sdkUnknown("")
        value.status = try reader["status"].readIfPresent() ?? ""
        value.defaultEsxVersion = try reader["defaultEsxVersion"].readIfPresent() ?? ""
        value.instanceTypes = try reader["instanceTypes"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<EvsClientTypes.InstanceType>().read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension EvsClientTypes.InstanceTypeEsxVersionsInfo {

    static func read(from reader: SmithyJSON.Reader) throws -> EvsClientTypes.InstanceTypeEsxVersionsInfo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = EvsClientTypes.InstanceTypeEsxVersionsInfo()
        value.instanceType = try reader["instanceType"].readIfPresent() ?? .sdkUnknown("")
        value.esxVersions = try reader["esxVersions"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension EvsClientTypes.ValidationExceptionField {

    static func read(from reader: SmithyJSON.Reader) throws -> EvsClientTypes.ValidationExceptionField {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = EvsClientTypes.ValidationExceptionField()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.message = try reader["message"].readIfPresent() ?? ""
        return value
    }
}

extension EvsClientTypes.InitialVlans {

    static func write(value: EvsClientTypes.InitialVlans?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["edgeVTep"].write(value.edgeVTep, with: EvsClientTypes.InitialVlanInfo.write(value:to:))
        try writer["expansionVlan1"].write(value.expansionVlan1, with: EvsClientTypes.InitialVlanInfo.write(value:to:))
        try writer["expansionVlan2"].write(value.expansionVlan2, with: EvsClientTypes.InitialVlanInfo.write(value:to:))
        try writer["hcx"].write(value.hcx, with: EvsClientTypes.InitialVlanInfo.write(value:to:))
        try writer["hcxNetworkAclId"].write(value.hcxNetworkAclId)
        try writer["isHcxPublic"].write(value.isHcxPublic)
        try writer["nsxUplink"].write(value.nsxUplink, with: EvsClientTypes.InitialVlanInfo.write(value:to:))
        try writer["vMotion"].write(value.vMotion, with: EvsClientTypes.InitialVlanInfo.write(value:to:))
        try writer["vSan"].write(value.vSan, with: EvsClientTypes.InitialVlanInfo.write(value:to:))
        try writer["vTep"].write(value.vTep, with: EvsClientTypes.InitialVlanInfo.write(value:to:))
        try writer["vmManagement"].write(value.vmManagement, with: EvsClientTypes.InitialVlanInfo.write(value:to:))
        try writer["vmkManagement"].write(value.vmkManagement, with: EvsClientTypes.InitialVlanInfo.write(value:to:))
    }
}

extension EvsClientTypes.InitialVlanInfo {

    static func write(value: EvsClientTypes.InitialVlanInfo?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["cidr"].write(value.cidr)
    }
}

extension EvsClientTypes.HostInfoForCreate {

    static func write(value: EvsClientTypes.HostInfoForCreate?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["dedicatedHostId"].write(value.dedicatedHostId)
        try writer["hostName"].write(value.hostName)
        try writer["instanceType"].write(value.instanceType)
        try writer["keyName"].write(value.keyName)
        try writer["placementGroupId"].write(value.placementGroupId)
    }
}

public enum EvsClientTypes {}
