// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime
import SmithyJSON
import SmithyReadWrite

extension AccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> AccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = AccessDeniedException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// Exception that access has been denied due to insufficient access
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension TrustedAdvisorClientTypes.AccountRecommendationLifecycleSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AccountRecommendationLifecycleSummary(accountId: \(Swift.String(describing: accountId)), accountRecommendationArn: \(Swift.String(describing: accountRecommendationArn)), lastUpdatedAt: \(Swift.String(describing: lastUpdatedAt)), lifecycleStage: \(Swift.String(describing: lifecycleStage)), updateReasonCode: \(Swift.String(describing: updateReasonCode)), updatedOnBehalfOf: \(Swift.String(describing: updatedOnBehalfOf)), updatedOnBehalfOfJobTitle: \(Swift.String(describing: updatedOnBehalfOfJobTitle)), updateReason: \"CONTENT_REDACTED\")"}
}

extension TrustedAdvisorClientTypes.AccountRecommendationLifecycleSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> TrustedAdvisorClientTypes.AccountRecommendationLifecycleSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = TrustedAdvisorClientTypes.AccountRecommendationLifecycleSummary()
        value.accountId = try reader["accountId"].readIfPresent()
        value.accountRecommendationArn = try reader["accountRecommendationArn"].readIfPresent()
        value.lifecycleStage = try reader["lifecycleStage"].readIfPresent()
        value.updatedOnBehalfOf = try reader["updatedOnBehalfOf"].readIfPresent()
        value.updatedOnBehalfOfJobTitle = try reader["updatedOnBehalfOfJobTitle"].readIfPresent()
        value.updateReason = try reader["updateReason"].readIfPresent()
        value.updateReasonCode = try reader["updateReasonCode"].readIfPresent()
        value.lastUpdatedAt = try reader["lastUpdatedAt"].readTimestampIfPresent(format: .dateTime)
        return value
    }
}

extension TrustedAdvisorClientTypes {
    /// Summary of an AccountRecommendationLifecycle for an Organization Recommendation
    public struct AccountRecommendationLifecycleSummary {
        /// The AWS account ID
        public var accountId: Swift.String?
        /// The Recommendation ARN
        public var accountRecommendationArn: Swift.String?
        /// When the Recommendation was last updated
        public var lastUpdatedAt: ClientRuntime.Date?
        /// The lifecycle stage from AWS Trusted Advisor Priority
        public var lifecycleStage: TrustedAdvisorClientTypes.RecommendationLifecycleStage?
        /// Reason for the lifecycle stage change
        public var updateReason: Swift.String?
        /// Reason code for the lifecycle state change
        public var updateReasonCode: TrustedAdvisorClientTypes.UpdateRecommendationLifecycleStageReasonCode?
        /// The person on whose behalf a Technical Account Manager (TAM) updated the recommendation. This information is only available when a Technical Account Manager takes an action on a recommendation managed by AWS Trusted Advisor Priority
        public var updatedOnBehalfOf: Swift.String?
        /// The job title of the person on whose behalf a Technical Account Manager (TAM) updated the recommendation. This information is only available when a Technical Account Manager takes an action on a recommendation managed by AWS Trusted Advisor Priority
        public var updatedOnBehalfOfJobTitle: Swift.String?

        public init(
            accountId: Swift.String? = nil,
            accountRecommendationArn: Swift.String? = nil,
            lastUpdatedAt: ClientRuntime.Date? = nil,
            lifecycleStage: TrustedAdvisorClientTypes.RecommendationLifecycleStage? = nil,
            updateReason: Swift.String? = nil,
            updateReasonCode: TrustedAdvisorClientTypes.UpdateRecommendationLifecycleStageReasonCode? = nil,
            updatedOnBehalfOf: Swift.String? = nil,
            updatedOnBehalfOfJobTitle: Swift.String? = nil
        )
        {
            self.accountId = accountId
            self.accountRecommendationArn = accountRecommendationArn
            self.lastUpdatedAt = lastUpdatedAt
            self.lifecycleStage = lifecycleStage
            self.updateReason = updateReason
            self.updateReasonCode = updateReasonCode
            self.updatedOnBehalfOf = updatedOnBehalfOf
            self.updatedOnBehalfOfJobTitle = updatedOnBehalfOfJobTitle
        }
    }

}

extension BatchUpdateRecommendationResourceExclusionInput {

    static func urlPathProvider(_ value: BatchUpdateRecommendationResourceExclusionInput) -> Swift.String? {
        return "/v1/batch-update-recommendation-resource-exclusion"
    }
}

extension BatchUpdateRecommendationResourceExclusionInput {

    static func write(value: BatchUpdateRecommendationResourceExclusionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["recommendationResourceExclusions"].writeList(value.recommendationResourceExclusions, memberWritingClosure: TrustedAdvisorClientTypes.RecommendationResourceExclusion.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

public struct BatchUpdateRecommendationResourceExclusionInput {
    /// A list of recommendation resource ARNs and exclusion status to update
    /// This member is required.
    public var recommendationResourceExclusions: [TrustedAdvisorClientTypes.RecommendationResourceExclusion]?

    public init(
        recommendationResourceExclusions: [TrustedAdvisorClientTypes.RecommendationResourceExclusion]? = nil
    )
    {
        self.recommendationResourceExclusions = recommendationResourceExclusions
    }
}

extension BatchUpdateRecommendationResourceExclusionOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> BatchUpdateRecommendationResourceExclusionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = BatchUpdateRecommendationResourceExclusionOutput()
        value.batchUpdateRecommendationResourceExclusionErrors = try reader["batchUpdateRecommendationResourceExclusionErrors"].readListIfPresent(memberReadingClosure: TrustedAdvisorClientTypes.UpdateRecommendationResourceExclusionError.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

public struct BatchUpdateRecommendationResourceExclusionOutput {
    /// A list of recommendation resource ARNs whose exclusion status failed to update, if any
    /// This member is required.
    public var batchUpdateRecommendationResourceExclusionErrors: [TrustedAdvisorClientTypes.UpdateRecommendationResourceExclusionError]?

    public init(
        batchUpdateRecommendationResourceExclusionErrors: [TrustedAdvisorClientTypes.UpdateRecommendationResourceExclusionError]? = nil
    )
    {
        self.batchUpdateRecommendationResourceExclusionErrors = batchUpdateRecommendationResourceExclusionErrors
    }
}

enum BatchUpdateRecommendationResourceExclusionOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension TrustedAdvisorClientTypes.CheckSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> TrustedAdvisorClientTypes.CheckSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = TrustedAdvisorClientTypes.CheckSummary()
        value.id = try reader["id"].readIfPresent()
        value.arn = try reader["arn"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.pillars = try reader["pillars"].readListIfPresent(memberReadingClosure: TrustedAdvisorClientTypes.RecommendationPillar.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.awsServices = try reader["awsServices"].readListIfPresent(memberReadingClosure: Swift.String.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.source = try reader["source"].readIfPresent()
        value.metadata = try reader["metadata"].readMapIfPresent(valueReadingClosure: Swift.String.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension TrustedAdvisorClientTypes {
    /// A summary of an AWS Trusted Advisor Check
    public struct CheckSummary {
        /// The ARN of the AWS Trusted Advisor Check
        /// This member is required.
        public var arn: Swift.String?
        /// The AWS Services that the Check applies to
        /// This member is required.
        public var awsServices: [Swift.String]?
        /// A description of what the AWS Trusted Advisor Check is monitoring
        /// This member is required.
        public var description: Swift.String?
        /// The unique identifier of the AWS Trusted Advisor Check
        /// This member is required.
        public var id: Swift.String?
        /// The column headings for the metadata returned in the resource
        /// This member is required.
        public var metadata: [Swift.String:Swift.String]?
        /// The name of the AWS Trusted Advisor Check
        /// This member is required.
        public var name: Swift.String?
        /// The Recommendation pillars that the AWS Trusted Advisor Check falls under
        /// This member is required.
        public var pillars: [TrustedAdvisorClientTypes.RecommendationPillar]?
        /// The source of the Recommendation
        /// This member is required.
        public var source: TrustedAdvisorClientTypes.RecommendationSource?

        public init(
            arn: Swift.String? = nil,
            awsServices: [Swift.String]? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            metadata: [Swift.String:Swift.String]? = nil,
            name: Swift.String? = nil,
            pillars: [TrustedAdvisorClientTypes.RecommendationPillar]? = nil,
            source: TrustedAdvisorClientTypes.RecommendationSource? = nil
        )
        {
            self.arn = arn
            self.awsServices = awsServices
            self.description = description
            self.id = id
            self.metadata = metadata
            self.name = name
            self.pillars = pillars
            self.source = source
        }
    }

}

extension ConflictException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ConflictException {
        let reader = baseError.errorBodyReader
        var value = ConflictException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// Exception that the request was denied due to conflictions in state
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension TrustedAdvisorClientTypes {

    public enum ExclusionStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case excluded
        case included
        case sdkUnknown(Swift.String)

        public static var allCases: [ExclusionStatus] {
            return [
                .excluded,
                .included,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .excluded: return "excluded"
            case .included: return "included"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension GetOrganizationRecommendationInput {

    static func urlPathProvider(_ value: GetOrganizationRecommendationInput) -> Swift.String? {
        guard let organizationRecommendationIdentifier = value.organizationRecommendationIdentifier else {
            return nil
        }
        return "/v1/organization-recommendations/\(organizationRecommendationIdentifier.urlPercentEncoding())"
    }
}

public struct GetOrganizationRecommendationInput {
    /// The Recommendation identifier
    /// This member is required.
    public var organizationRecommendationIdentifier: Swift.String?

    public init(
        organizationRecommendationIdentifier: Swift.String? = nil
    )
    {
        self.organizationRecommendationIdentifier = organizationRecommendationIdentifier
    }
}

extension GetOrganizationRecommendationOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> GetOrganizationRecommendationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetOrganizationRecommendationOutput()
        value.organizationRecommendation = try reader["organizationRecommendation"].readIfPresent(with: TrustedAdvisorClientTypes.OrganizationRecommendation.read(from:))
        return value
    }
}

public struct GetOrganizationRecommendationOutput {
    /// The Recommendation
    public var organizationRecommendation: TrustedAdvisorClientTypes.OrganizationRecommendation?

    public init(
        organizationRecommendation: TrustedAdvisorClientTypes.OrganizationRecommendation? = nil
    )
    {
        self.organizationRecommendation = organizationRecommendation
    }
}

enum GetOrganizationRecommendationOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension GetRecommendationInput {

    static func urlPathProvider(_ value: GetRecommendationInput) -> Swift.String? {
        guard let recommendationIdentifier = value.recommendationIdentifier else {
            return nil
        }
        return "/v1/recommendations/\(recommendationIdentifier.urlPercentEncoding())"
    }
}

public struct GetRecommendationInput {
    /// The Recommendation identifier
    /// This member is required.
    public var recommendationIdentifier: Swift.String?

    public init(
        recommendationIdentifier: Swift.String? = nil
    )
    {
        self.recommendationIdentifier = recommendationIdentifier
    }
}

extension GetRecommendationOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> GetRecommendationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetRecommendationOutput()
        value.recommendation = try reader["recommendation"].readIfPresent(with: TrustedAdvisorClientTypes.Recommendation.read(from:))
        return value
    }
}

public struct GetRecommendationOutput {
    /// The Recommendation
    public var recommendation: TrustedAdvisorClientTypes.Recommendation?

    public init(
        recommendation: TrustedAdvisorClientTypes.Recommendation? = nil
    )
    {
        self.recommendation = recommendation
    }
}

enum GetRecommendationOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension InternalServerException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InternalServerException {
        let reader = baseError.errorBodyReader
        var value = InternalServerException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// Exception to notify that an unexpected internal error occurred during processing of the request
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension ListChecksInput {

    static func queryItemProvider(_ value: ListChecksInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let pillar = value.pillar {
            let pillarQueryItem = ClientRuntime.SDKURLQueryItem(name: "pillar".urlPercentEncoding(), value: Swift.String(pillar.rawValue).urlPercentEncoding())
            items.append(pillarQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let language = value.language {
            let languageQueryItem = ClientRuntime.SDKURLQueryItem(name: "language".urlPercentEncoding(), value: Swift.String(language.rawValue).urlPercentEncoding())
            items.append(languageQueryItem)
        }
        if let source = value.source {
            let sourceQueryItem = ClientRuntime.SDKURLQueryItem(name: "source".urlPercentEncoding(), value: Swift.String(source.rawValue).urlPercentEncoding())
            items.append(sourceQueryItem)
        }
        if let awsService = value.awsService {
            let awsServiceQueryItem = ClientRuntime.SDKURLQueryItem(name: "awsService".urlPercentEncoding(), value: Swift.String(awsService).urlPercentEncoding())
            items.append(awsServiceQueryItem)
        }
        return items
    }
}

extension ListChecksInput {

    static func urlPathProvider(_ value: ListChecksInput) -> Swift.String? {
        return "/v1/checks"
    }
}

public struct ListChecksInput {
    /// The aws service associated with the check
    public var awsService: Swift.String?
    /// The ISO 639-1 code for the language that you want your checks to appear in.
    public var language: TrustedAdvisorClientTypes.RecommendationLanguage?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The pillar of the check
    public var pillar: TrustedAdvisorClientTypes.RecommendationPillar?
    /// The source of the check
    public var source: TrustedAdvisorClientTypes.RecommendationSource?

    public init(
        awsService: Swift.String? = nil,
        language: TrustedAdvisorClientTypes.RecommendationLanguage? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        pillar: TrustedAdvisorClientTypes.RecommendationPillar? = nil,
        source: TrustedAdvisorClientTypes.RecommendationSource? = nil
    )
    {
        self.awsService = awsService
        self.language = language
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.pillar = pillar
        self.source = source
    }
}

extension ListChecksOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListChecksOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListChecksOutput()
        value.checkSummaries = try reader["checkSummaries"].readListIfPresent(memberReadingClosure: TrustedAdvisorClientTypes.CheckSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

public struct ListChecksOutput {
    /// The list of Checks
    /// This member is required.
    public var checkSummaries: [TrustedAdvisorClientTypes.CheckSummary]?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        checkSummaries: [TrustedAdvisorClientTypes.CheckSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.checkSummaries = checkSummaries
        self.nextToken = nextToken
    }
}

enum ListChecksOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ListOrganizationRecommendationAccountsInput {

    static func queryItemProvider(_ value: ListOrganizationRecommendationAccountsInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let affectedAccountId = value.affectedAccountId {
            let affectedAccountIdQueryItem = ClientRuntime.SDKURLQueryItem(name: "affectedAccountId".urlPercentEncoding(), value: Swift.String(affectedAccountId).urlPercentEncoding())
            items.append(affectedAccountIdQueryItem)
        }
        return items
    }
}

extension ListOrganizationRecommendationAccountsInput {

    static func urlPathProvider(_ value: ListOrganizationRecommendationAccountsInput) -> Swift.String? {
        guard let organizationRecommendationIdentifier = value.organizationRecommendationIdentifier else {
            return nil
        }
        return "/v1/organization-recommendations/\(organizationRecommendationIdentifier.urlPercentEncoding())/accounts"
    }
}

public struct ListOrganizationRecommendationAccountsInput {
    /// An account affected by this organization recommendation
    public var affectedAccountId: Swift.String?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The Recommendation identifier
    /// This member is required.
    public var organizationRecommendationIdentifier: Swift.String?

    public init(
        affectedAccountId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        organizationRecommendationIdentifier: Swift.String? = nil
    )
    {
        self.affectedAccountId = affectedAccountId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.organizationRecommendationIdentifier = organizationRecommendationIdentifier
    }
}

extension ListOrganizationRecommendationAccountsOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListOrganizationRecommendationAccountsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListOrganizationRecommendationAccountsOutput()
        value.accountRecommendationLifecycleSummaries = try reader["accountRecommendationLifecycleSummaries"].readListIfPresent(memberReadingClosure: TrustedAdvisorClientTypes.AccountRecommendationLifecycleSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

public struct ListOrganizationRecommendationAccountsOutput {
    /// The account recommendations lifecycles that are applicable to the Recommendation
    /// This member is required.
    public var accountRecommendationLifecycleSummaries: [TrustedAdvisorClientTypes.AccountRecommendationLifecycleSummary]?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        accountRecommendationLifecycleSummaries: [TrustedAdvisorClientTypes.AccountRecommendationLifecycleSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.accountRecommendationLifecycleSummaries = accountRecommendationLifecycleSummaries
        self.nextToken = nextToken
    }
}

enum ListOrganizationRecommendationAccountsOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ListOrganizationRecommendationResourcesInput {

    static func queryItemProvider(_ value: ListOrganizationRecommendationResourcesInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let regionCode = value.regionCode {
            let regionCodeQueryItem = ClientRuntime.SDKURLQueryItem(name: "regionCode".urlPercentEncoding(), value: Swift.String(regionCode).urlPercentEncoding())
            items.append(regionCodeQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let exclusionStatus = value.exclusionStatus {
            let exclusionStatusQueryItem = ClientRuntime.SDKURLQueryItem(name: "exclusionStatus".urlPercentEncoding(), value: Swift.String(exclusionStatus.rawValue).urlPercentEncoding())
            items.append(exclusionStatusQueryItem)
        }
        if let affectedAccountId = value.affectedAccountId {
            let affectedAccountIdQueryItem = ClientRuntime.SDKURLQueryItem(name: "affectedAccountId".urlPercentEncoding(), value: Swift.String(affectedAccountId).urlPercentEncoding())
            items.append(affectedAccountIdQueryItem)
        }
        if let status = value.status {
            let statusQueryItem = ClientRuntime.SDKURLQueryItem(name: "status".urlPercentEncoding(), value: Swift.String(status.rawValue).urlPercentEncoding())
            items.append(statusQueryItem)
        }
        return items
    }
}

extension ListOrganizationRecommendationResourcesInput {

    static func urlPathProvider(_ value: ListOrganizationRecommendationResourcesInput) -> Swift.String? {
        guard let organizationRecommendationIdentifier = value.organizationRecommendationIdentifier else {
            return nil
        }
        return "/v1/organization-recommendations/\(organizationRecommendationIdentifier.urlPercentEncoding())/resources"
    }
}

public struct ListOrganizationRecommendationResourcesInput {
    /// An account affected by this organization recommendation
    public var affectedAccountId: Swift.String?
    /// The exclusion status of the resource
    public var exclusionStatus: TrustedAdvisorClientTypes.ExclusionStatus?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The AWS Organization organization's Recommendation identifier
    /// This member is required.
    public var organizationRecommendationIdentifier: Swift.String?
    /// The AWS Region code of the resource
    public var regionCode: Swift.String?
    /// The status of the resource
    public var status: TrustedAdvisorClientTypes.ResourceStatus?

    public init(
        affectedAccountId: Swift.String? = nil,
        exclusionStatus: TrustedAdvisorClientTypes.ExclusionStatus? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        organizationRecommendationIdentifier: Swift.String? = nil,
        regionCode: Swift.String? = nil,
        status: TrustedAdvisorClientTypes.ResourceStatus? = nil
    )
    {
        self.affectedAccountId = affectedAccountId
        self.exclusionStatus = exclusionStatus
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.organizationRecommendationIdentifier = organizationRecommendationIdentifier
        self.regionCode = regionCode
        self.status = status
    }
}

extension ListOrganizationRecommendationResourcesOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListOrganizationRecommendationResourcesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListOrganizationRecommendationResourcesOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.organizationRecommendationResourceSummaries = try reader["organizationRecommendationResourceSummaries"].readListIfPresent(memberReadingClosure: TrustedAdvisorClientTypes.OrganizationRecommendationResourceSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

public struct ListOrganizationRecommendationResourcesOutput {
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// A list of Recommendation Resources
    /// This member is required.
    public var organizationRecommendationResourceSummaries: [TrustedAdvisorClientTypes.OrganizationRecommendationResourceSummary]?

    public init(
        nextToken: Swift.String? = nil,
        organizationRecommendationResourceSummaries: [TrustedAdvisorClientTypes.OrganizationRecommendationResourceSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.organizationRecommendationResourceSummaries = organizationRecommendationResourceSummaries
    }
}

enum ListOrganizationRecommendationResourcesOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ListOrganizationRecommendationsInput {

    static func queryItemProvider(_ value: ListOrganizationRecommendationsInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let beforeLastUpdatedAt = value.beforeLastUpdatedAt {
            let beforeLastUpdatedAtQueryItem = ClientRuntime.SDKURLQueryItem(name: "beforeLastUpdatedAt".urlPercentEncoding(), value: Swift.String(TimestampFormatter(format: .dateTime).string(from: beforeLastUpdatedAt)).urlPercentEncoding())
            items.append(beforeLastUpdatedAtQueryItem)
        }
        if let pillar = value.pillar {
            let pillarQueryItem = ClientRuntime.SDKURLQueryItem(name: "pillar".urlPercentEncoding(), value: Swift.String(pillar.rawValue).urlPercentEncoding())
            items.append(pillarQueryItem)
        }
        if let afterLastUpdatedAt = value.afterLastUpdatedAt {
            let afterLastUpdatedAtQueryItem = ClientRuntime.SDKURLQueryItem(name: "afterLastUpdatedAt".urlPercentEncoding(), value: Swift.String(TimestampFormatter(format: .dateTime).string(from: afterLastUpdatedAt)).urlPercentEncoding())
            items.append(afterLastUpdatedAtQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let checkIdentifier = value.checkIdentifier {
            let checkIdentifierQueryItem = ClientRuntime.SDKURLQueryItem(name: "checkIdentifier".urlPercentEncoding(), value: Swift.String(checkIdentifier).urlPercentEncoding())
            items.append(checkIdentifierQueryItem)
        }
        if let source = value.source {
            let sourceQueryItem = ClientRuntime.SDKURLQueryItem(name: "source".urlPercentEncoding(), value: Swift.String(source.rawValue).urlPercentEncoding())
            items.append(sourceQueryItem)
        }
        if let type = value.type {
            let typeQueryItem = ClientRuntime.SDKURLQueryItem(name: "type".urlPercentEncoding(), value: Swift.String(type.rawValue).urlPercentEncoding())
            items.append(typeQueryItem)
        }
        if let awsService = value.awsService {
            let awsServiceQueryItem = ClientRuntime.SDKURLQueryItem(name: "awsService".urlPercentEncoding(), value: Swift.String(awsService).urlPercentEncoding())
            items.append(awsServiceQueryItem)
        }
        if let status = value.status {
            let statusQueryItem = ClientRuntime.SDKURLQueryItem(name: "status".urlPercentEncoding(), value: Swift.String(status.rawValue).urlPercentEncoding())
            items.append(statusQueryItem)
        }
        return items
    }
}

extension ListOrganizationRecommendationsInput {

    static func urlPathProvider(_ value: ListOrganizationRecommendationsInput) -> Swift.String? {
        return "/v1/organization-recommendations"
    }
}

public struct ListOrganizationRecommendationsInput {
    /// After the last update of the Recommendation
    public var afterLastUpdatedAt: ClientRuntime.Date?
    /// The aws service associated with the Recommendation
    public var awsService: Swift.String?
    /// Before the last update of the Recommendation
    public var beforeLastUpdatedAt: ClientRuntime.Date?
    /// The check identifier of the Recommendation
    public var checkIdentifier: Swift.String?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The pillar of the Recommendation
    public var pillar: TrustedAdvisorClientTypes.RecommendationPillar?
    /// The source of the Recommendation
    public var source: TrustedAdvisorClientTypes.RecommendationSource?
    /// The status of the Recommendation
    public var status: TrustedAdvisorClientTypes.RecommendationStatus?
    /// The type of the Recommendation
    public var type: TrustedAdvisorClientTypes.RecommendationType?

    public init(
        afterLastUpdatedAt: ClientRuntime.Date? = nil,
        awsService: Swift.String? = nil,
        beforeLastUpdatedAt: ClientRuntime.Date? = nil,
        checkIdentifier: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        pillar: TrustedAdvisorClientTypes.RecommendationPillar? = nil,
        source: TrustedAdvisorClientTypes.RecommendationSource? = nil,
        status: TrustedAdvisorClientTypes.RecommendationStatus? = nil,
        type: TrustedAdvisorClientTypes.RecommendationType? = nil
    )
    {
        self.afterLastUpdatedAt = afterLastUpdatedAt
        self.awsService = awsService
        self.beforeLastUpdatedAt = beforeLastUpdatedAt
        self.checkIdentifier = checkIdentifier
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.pillar = pillar
        self.source = source
        self.status = status
        self.type = type
    }
}

extension ListOrganizationRecommendationsOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListOrganizationRecommendationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListOrganizationRecommendationsOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.organizationRecommendationSummaries = try reader["organizationRecommendationSummaries"].readListIfPresent(memberReadingClosure: TrustedAdvisorClientTypes.OrganizationRecommendationSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

public struct ListOrganizationRecommendationsOutput {
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The list of Recommendations
    /// This member is required.
    public var organizationRecommendationSummaries: [TrustedAdvisorClientTypes.OrganizationRecommendationSummary]?

    public init(
        nextToken: Swift.String? = nil,
        organizationRecommendationSummaries: [TrustedAdvisorClientTypes.OrganizationRecommendationSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.organizationRecommendationSummaries = organizationRecommendationSummaries
    }
}

enum ListOrganizationRecommendationsOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ListRecommendationResourcesInput {

    static func queryItemProvider(_ value: ListRecommendationResourcesInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let regionCode = value.regionCode {
            let regionCodeQueryItem = ClientRuntime.SDKURLQueryItem(name: "regionCode".urlPercentEncoding(), value: Swift.String(regionCode).urlPercentEncoding())
            items.append(regionCodeQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let exclusionStatus = value.exclusionStatus {
            let exclusionStatusQueryItem = ClientRuntime.SDKURLQueryItem(name: "exclusionStatus".urlPercentEncoding(), value: Swift.String(exclusionStatus.rawValue).urlPercentEncoding())
            items.append(exclusionStatusQueryItem)
        }
        if let status = value.status {
            let statusQueryItem = ClientRuntime.SDKURLQueryItem(name: "status".urlPercentEncoding(), value: Swift.String(status.rawValue).urlPercentEncoding())
            items.append(statusQueryItem)
        }
        return items
    }
}

extension ListRecommendationResourcesInput {

    static func urlPathProvider(_ value: ListRecommendationResourcesInput) -> Swift.String? {
        guard let recommendationIdentifier = value.recommendationIdentifier else {
            return nil
        }
        return "/v1/recommendations/\(recommendationIdentifier.urlPercentEncoding())/resources"
    }
}

public struct ListRecommendationResourcesInput {
    /// The exclusion status of the resource
    public var exclusionStatus: TrustedAdvisorClientTypes.ExclusionStatus?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The Recommendation identifier
    /// This member is required.
    public var recommendationIdentifier: Swift.String?
    /// The AWS Region code of the resource
    public var regionCode: Swift.String?
    /// The status of the resource
    public var status: TrustedAdvisorClientTypes.ResourceStatus?

    public init(
        exclusionStatus: TrustedAdvisorClientTypes.ExclusionStatus? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        recommendationIdentifier: Swift.String? = nil,
        regionCode: Swift.String? = nil,
        status: TrustedAdvisorClientTypes.ResourceStatus? = nil
    )
    {
        self.exclusionStatus = exclusionStatus
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.recommendationIdentifier = recommendationIdentifier
        self.regionCode = regionCode
        self.status = status
    }
}

extension ListRecommendationResourcesOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListRecommendationResourcesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListRecommendationResourcesOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.recommendationResourceSummaries = try reader["recommendationResourceSummaries"].readListIfPresent(memberReadingClosure: TrustedAdvisorClientTypes.RecommendationResourceSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

public struct ListRecommendationResourcesOutput {
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// A list of Recommendation Resources
    /// This member is required.
    public var recommendationResourceSummaries: [TrustedAdvisorClientTypes.RecommendationResourceSummary]?

    public init(
        nextToken: Swift.String? = nil,
        recommendationResourceSummaries: [TrustedAdvisorClientTypes.RecommendationResourceSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.recommendationResourceSummaries = recommendationResourceSummaries
    }
}

enum ListRecommendationResourcesOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension ListRecommendationsInput {

    static func queryItemProvider(_ value: ListRecommendationsInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let beforeLastUpdatedAt = value.beforeLastUpdatedAt {
            let beforeLastUpdatedAtQueryItem = ClientRuntime.SDKURLQueryItem(name: "beforeLastUpdatedAt".urlPercentEncoding(), value: Swift.String(TimestampFormatter(format: .dateTime).string(from: beforeLastUpdatedAt)).urlPercentEncoding())
            items.append(beforeLastUpdatedAtQueryItem)
        }
        if let pillar = value.pillar {
            let pillarQueryItem = ClientRuntime.SDKURLQueryItem(name: "pillar".urlPercentEncoding(), value: Swift.String(pillar.rawValue).urlPercentEncoding())
            items.append(pillarQueryItem)
        }
        if let afterLastUpdatedAt = value.afterLastUpdatedAt {
            let afterLastUpdatedAtQueryItem = ClientRuntime.SDKURLQueryItem(name: "afterLastUpdatedAt".urlPercentEncoding(), value: Swift.String(TimestampFormatter(format: .dateTime).string(from: afterLastUpdatedAt)).urlPercentEncoding())
            items.append(afterLastUpdatedAtQueryItem)
        }
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        if let checkIdentifier = value.checkIdentifier {
            let checkIdentifierQueryItem = ClientRuntime.SDKURLQueryItem(name: "checkIdentifier".urlPercentEncoding(), value: Swift.String(checkIdentifier).urlPercentEncoding())
            items.append(checkIdentifierQueryItem)
        }
        if let source = value.source {
            let sourceQueryItem = ClientRuntime.SDKURLQueryItem(name: "source".urlPercentEncoding(), value: Swift.String(source.rawValue).urlPercentEncoding())
            items.append(sourceQueryItem)
        }
        if let type = value.type {
            let typeQueryItem = ClientRuntime.SDKURLQueryItem(name: "type".urlPercentEncoding(), value: Swift.String(type.rawValue).urlPercentEncoding())
            items.append(typeQueryItem)
        }
        if let awsService = value.awsService {
            let awsServiceQueryItem = ClientRuntime.SDKURLQueryItem(name: "awsService".urlPercentEncoding(), value: Swift.String(awsService).urlPercentEncoding())
            items.append(awsServiceQueryItem)
        }
        if let status = value.status {
            let statusQueryItem = ClientRuntime.SDKURLQueryItem(name: "status".urlPercentEncoding(), value: Swift.String(status.rawValue).urlPercentEncoding())
            items.append(statusQueryItem)
        }
        return items
    }
}

extension ListRecommendationsInput {

    static func urlPathProvider(_ value: ListRecommendationsInput) -> Swift.String? {
        return "/v1/recommendations"
    }
}

public struct ListRecommendationsInput {
    /// After the last update of the Recommendation
    public var afterLastUpdatedAt: ClientRuntime.Date?
    /// The aws service associated with the Recommendation
    public var awsService: Swift.String?
    /// Before the last update of the Recommendation
    public var beforeLastUpdatedAt: ClientRuntime.Date?
    /// The check identifier of the Recommendation
    public var checkIdentifier: Swift.String?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The pillar of the Recommendation
    public var pillar: TrustedAdvisorClientTypes.RecommendationPillar?
    /// The source of the Recommendation
    public var source: TrustedAdvisorClientTypes.RecommendationSource?
    /// The status of the Recommendation
    public var status: TrustedAdvisorClientTypes.RecommendationStatus?
    /// The type of the Recommendation
    public var type: TrustedAdvisorClientTypes.RecommendationType?

    public init(
        afterLastUpdatedAt: ClientRuntime.Date? = nil,
        awsService: Swift.String? = nil,
        beforeLastUpdatedAt: ClientRuntime.Date? = nil,
        checkIdentifier: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        pillar: TrustedAdvisorClientTypes.RecommendationPillar? = nil,
        source: TrustedAdvisorClientTypes.RecommendationSource? = nil,
        status: TrustedAdvisorClientTypes.RecommendationStatus? = nil,
        type: TrustedAdvisorClientTypes.RecommendationType? = nil
    )
    {
        self.afterLastUpdatedAt = afterLastUpdatedAt
        self.awsService = awsService
        self.beforeLastUpdatedAt = beforeLastUpdatedAt
        self.checkIdentifier = checkIdentifier
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.pillar = pillar
        self.source = source
        self.status = status
        self.type = type
    }
}

extension ListRecommendationsOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> ListRecommendationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListRecommendationsOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.recommendationSummaries = try reader["recommendationSummaries"].readListIfPresent(memberReadingClosure: TrustedAdvisorClientTypes.RecommendationSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

public struct ListRecommendationsOutput {
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The list of Recommendations
    /// This member is required.
    public var recommendationSummaries: [TrustedAdvisorClientTypes.RecommendationSummary]?

    public init(
        nextToken: Swift.String? = nil,
        recommendationSummaries: [TrustedAdvisorClientTypes.RecommendationSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.recommendationSummaries = recommendationSummaries
    }
}

enum ListRecommendationsOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension TrustedAdvisorClientTypes.OrganizationRecommendation: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "OrganizationRecommendation(arn: \(Swift.String(describing: arn)), awsServices: \(Swift.String(describing: awsServices)), checkArn: \(Swift.String(describing: checkArn)), createdAt: \(Swift.String(describing: createdAt)), createdBy: \(Swift.String(describing: createdBy)), description: \(Swift.String(describing: description)), id: \(Swift.String(describing: id)), lastUpdatedAt: \(Swift.String(describing: lastUpdatedAt)), lifecycleStage: \(Swift.String(describing: lifecycleStage)), name: \(Swift.String(describing: name)), pillarSpecificAggregates: \(Swift.String(describing: pillarSpecificAggregates)), pillars: \(Swift.String(describing: pillars)), resolvedAt: \(Swift.String(describing: resolvedAt)), resourcesAggregates: \(Swift.String(describing: resourcesAggregates)), source: \(Swift.String(describing: source)), status: \(Swift.String(describing: status)), type: \(Swift.String(describing: type)), updateReasonCode: \(Swift.String(describing: updateReasonCode)), updatedOnBehalfOf: \(Swift.String(describing: updatedOnBehalfOf)), updatedOnBehalfOfJobTitle: \(Swift.String(describing: updatedOnBehalfOfJobTitle)), updateReason: \"CONTENT_REDACTED\")"}
}

extension TrustedAdvisorClientTypes.OrganizationRecommendation {

    static func read(from reader: SmithyJSON.Reader) throws -> TrustedAdvisorClientTypes.OrganizationRecommendation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = TrustedAdvisorClientTypes.OrganizationRecommendation()
        value.id = try reader["id"].readIfPresent()
        value.type = try reader["type"].readIfPresent()
        value.checkArn = try reader["checkArn"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.lifecycleStage = try reader["lifecycleStage"].readIfPresent()
        value.pillars = try reader["pillars"].readListIfPresent(memberReadingClosure: TrustedAdvisorClientTypes.RecommendationPillar.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.source = try reader["source"].readIfPresent()
        value.awsServices = try reader["awsServices"].readListIfPresent(memberReadingClosure: Swift.String.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.name = try reader["name"].readIfPresent()
        value.resourcesAggregates = try reader["resourcesAggregates"].readIfPresent(with: TrustedAdvisorClientTypes.RecommendationResourcesAggregates.read(from:))
        value.pillarSpecificAggregates = try reader["pillarSpecificAggregates"].readIfPresent(with: TrustedAdvisorClientTypes.RecommendationPillarSpecificAggregates.read(from:))
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: .dateTime)
        value.lastUpdatedAt = try reader["lastUpdatedAt"].readTimestampIfPresent(format: .dateTime)
        value.arn = try reader["arn"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.createdBy = try reader["createdBy"].readIfPresent()
        value.updatedOnBehalfOf = try reader["updatedOnBehalfOf"].readIfPresent()
        value.updatedOnBehalfOfJobTitle = try reader["updatedOnBehalfOfJobTitle"].readIfPresent()
        value.updateReason = try reader["updateReason"].readIfPresent()
        value.updateReasonCode = try reader["updateReasonCode"].readIfPresent()
        value.resolvedAt = try reader["resolvedAt"].readTimestampIfPresent(format: .dateTime)
        return value
    }
}

extension TrustedAdvisorClientTypes {
    /// A Recommendation for accounts within an Organization
    public struct OrganizationRecommendation {
        /// The ARN of the Recommendation
        /// This member is required.
        public var arn: Swift.String?
        /// The AWS Services that the Recommendation applies to
        public var awsServices: [Swift.String]?
        /// The AWS Trusted Advisor Check ARN that relates to the Recommendation
        public var checkArn: Swift.String?
        /// When the Recommendation was created, if created by AWS Trusted Advisor Priority
        public var createdAt: ClientRuntime.Date?
        /// The creator, if created by AWS Trusted Advisor Priority
        public var createdBy: Swift.String?
        /// A description for AWS Trusted Advisor recommendations
        /// This member is required.
        public var description: Swift.String?
        /// The ID which identifies where the Recommendation was produced
        /// This member is required.
        public var id: Swift.String?
        /// When the Recommendation was last updated
        public var lastUpdatedAt: ClientRuntime.Date?
        /// The lifecycle stage from AWS Trusted Advisor Priority
        public var lifecycleStage: TrustedAdvisorClientTypes.RecommendationLifecycleStage?
        /// The name of the AWS Trusted Advisor Recommendation
        /// This member is required.
        public var name: Swift.String?
        /// The pillar aggregations for cost savings
        public var pillarSpecificAggregates: TrustedAdvisorClientTypes.RecommendationPillarSpecificAggregates?
        /// The Pillars that the Recommendation is optimizing
        /// This member is required.
        public var pillars: [TrustedAdvisorClientTypes.RecommendationPillar]?
        /// When the Recommendation was resolved
        public var resolvedAt: ClientRuntime.Date?
        /// An aggregation of all resources
        /// This member is required.
        public var resourcesAggregates: TrustedAdvisorClientTypes.RecommendationResourcesAggregates?
        /// The source of the Recommendation
        /// This member is required.
        public var source: TrustedAdvisorClientTypes.RecommendationSource?
        /// The status of the Recommendation
        /// This member is required.
        public var status: TrustedAdvisorClientTypes.RecommendationStatus?
        /// Whether the Recommendation was automated or generated by AWS Trusted Advisor Priority
        /// This member is required.
        public var type: TrustedAdvisorClientTypes.RecommendationType?
        /// Reason for the lifecycle stage change
        public var updateReason: Swift.String?
        /// Reason code for the lifecycle state change
        public var updateReasonCode: TrustedAdvisorClientTypes.UpdateRecommendationLifecycleStageReasonCode?
        /// The person on whose behalf a Technical Account Manager (TAM) updated the recommendation. This information is only available when a Technical Account Manager takes an action on a recommendation managed by AWS Trusted Advisor Priority
        public var updatedOnBehalfOf: Swift.String?
        /// The job title of the person on whose behalf a Technical Account Manager (TAM) updated the recommendation. This information is only available when a Technical Account Manager takes an action on a recommendation managed by AWS Trusted Advisor Priority
        public var updatedOnBehalfOfJobTitle: Swift.String?

        public init(
            arn: Swift.String? = nil,
            awsServices: [Swift.String]? = nil,
            checkArn: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            createdBy: Swift.String? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            lastUpdatedAt: ClientRuntime.Date? = nil,
            lifecycleStage: TrustedAdvisorClientTypes.RecommendationLifecycleStage? = nil,
            name: Swift.String? = nil,
            pillarSpecificAggregates: TrustedAdvisorClientTypes.RecommendationPillarSpecificAggregates? = nil,
            pillars: [TrustedAdvisorClientTypes.RecommendationPillar]? = nil,
            resolvedAt: ClientRuntime.Date? = nil,
            resourcesAggregates: TrustedAdvisorClientTypes.RecommendationResourcesAggregates? = nil,
            source: TrustedAdvisorClientTypes.RecommendationSource? = nil,
            status: TrustedAdvisorClientTypes.RecommendationStatus? = nil,
            type: TrustedAdvisorClientTypes.RecommendationType? = nil,
            updateReason: Swift.String? = nil,
            updateReasonCode: TrustedAdvisorClientTypes.UpdateRecommendationLifecycleStageReasonCode? = nil,
            updatedOnBehalfOf: Swift.String? = nil,
            updatedOnBehalfOfJobTitle: Swift.String? = nil
        )
        {
            self.arn = arn
            self.awsServices = awsServices
            self.checkArn = checkArn
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.description = description
            self.id = id
            self.lastUpdatedAt = lastUpdatedAt
            self.lifecycleStage = lifecycleStage
            self.name = name
            self.pillarSpecificAggregates = pillarSpecificAggregates
            self.pillars = pillars
            self.resolvedAt = resolvedAt
            self.resourcesAggregates = resourcesAggregates
            self.source = source
            self.status = status
            self.type = type
            self.updateReason = updateReason
            self.updateReasonCode = updateReasonCode
            self.updatedOnBehalfOf = updatedOnBehalfOf
            self.updatedOnBehalfOfJobTitle = updatedOnBehalfOfJobTitle
        }
    }

}

extension TrustedAdvisorClientTypes.OrganizationRecommendationResourceSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> TrustedAdvisorClientTypes.OrganizationRecommendationResourceSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = TrustedAdvisorClientTypes.OrganizationRecommendationResourceSummary()
        value.id = try reader["id"].readIfPresent()
        value.arn = try reader["arn"].readIfPresent()
        value.awsResourceId = try reader["awsResourceId"].readIfPresent()
        value.regionCode = try reader["regionCode"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.metadata = try reader["metadata"].readMapIfPresent(valueReadingClosure: Swift.String.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.lastUpdatedAt = try reader["lastUpdatedAt"].readTimestampIfPresent(format: .dateTime)
        value.exclusionStatus = try reader["exclusionStatus"].readIfPresent() ?? .included
        value.accountId = try reader["accountId"].readIfPresent()
        value.recommendationArn = try reader["recommendationArn"].readIfPresent()
        return value
    }
}

extension TrustedAdvisorClientTypes {
    /// Organization Recommendation Resource Summary
    public struct OrganizationRecommendationResourceSummary {
        /// The AWS account ID
        public var accountId: Swift.String?
        /// The ARN of the Recommendation Resource
        /// This member is required.
        public var arn: Swift.String?
        /// The AWS resource identifier
        /// This member is required.
        public var awsResourceId: Swift.String?
        /// The exclusion status of the Recommendation Resource
        public var exclusionStatus: TrustedAdvisorClientTypes.ExclusionStatus?
        /// The ID of the Recommendation Resource
        /// This member is required.
        public var id: Swift.String?
        /// When the Recommendation Resource was last updated
        /// This member is required.
        public var lastUpdatedAt: ClientRuntime.Date?
        /// Metadata associated with the Recommendation Resource
        /// This member is required.
        public var metadata: [Swift.String:Swift.String]?
        /// The Recommendation ARN
        /// This member is required.
        public var recommendationArn: Swift.String?
        /// The AWS Region code that the Recommendation Resource is in
        /// This member is required.
        public var regionCode: Swift.String?
        /// The current status of the Recommendation Resource
        /// This member is required.
        public var status: TrustedAdvisorClientTypes.ResourceStatus?

        public init(
            accountId: Swift.String? = nil,
            arn: Swift.String? = nil,
            awsResourceId: Swift.String? = nil,
            exclusionStatus: TrustedAdvisorClientTypes.ExclusionStatus? = nil,
            id: Swift.String? = nil,
            lastUpdatedAt: ClientRuntime.Date? = nil,
            metadata: [Swift.String:Swift.String]? = nil,
            recommendationArn: Swift.String? = nil,
            regionCode: Swift.String? = nil,
            status: TrustedAdvisorClientTypes.ResourceStatus? = nil
        )
        {
            self.accountId = accountId
            self.arn = arn
            self.awsResourceId = awsResourceId
            self.exclusionStatus = exclusionStatus
            self.id = id
            self.lastUpdatedAt = lastUpdatedAt
            self.metadata = metadata
            self.recommendationArn = recommendationArn
            self.regionCode = regionCode
            self.status = status
        }
    }

}

extension TrustedAdvisorClientTypes.OrganizationRecommendationSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> TrustedAdvisorClientTypes.OrganizationRecommendationSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = TrustedAdvisorClientTypes.OrganizationRecommendationSummary()
        value.id = try reader["id"].readIfPresent()
        value.type = try reader["type"].readIfPresent()
        value.checkArn = try reader["checkArn"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.lifecycleStage = try reader["lifecycleStage"].readIfPresent()
        value.pillars = try reader["pillars"].readListIfPresent(memberReadingClosure: TrustedAdvisorClientTypes.RecommendationPillar.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.source = try reader["source"].readIfPresent()
        value.awsServices = try reader["awsServices"].readListIfPresent(memberReadingClosure: Swift.String.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.name = try reader["name"].readIfPresent()
        value.resourcesAggregates = try reader["resourcesAggregates"].readIfPresent(with: TrustedAdvisorClientTypes.RecommendationResourcesAggregates.read(from:))
        value.pillarSpecificAggregates = try reader["pillarSpecificAggregates"].readIfPresent(with: TrustedAdvisorClientTypes.RecommendationPillarSpecificAggregates.read(from:))
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: .dateTime)
        value.lastUpdatedAt = try reader["lastUpdatedAt"].readTimestampIfPresent(format: .dateTime)
        value.arn = try reader["arn"].readIfPresent()
        return value
    }
}

extension TrustedAdvisorClientTypes {
    /// Summary of recommendation for accounts within an Organization
    public struct OrganizationRecommendationSummary {
        /// The ARN of the Recommendation
        /// This member is required.
        public var arn: Swift.String?
        /// The AWS Services that the Recommendation applies to
        public var awsServices: [Swift.String]?
        /// The AWS Trusted Advisor Check ARN that relates to the Recommendation
        public var checkArn: Swift.String?
        /// When the Recommendation was created, if created by AWS Trusted Advisor Priority
        public var createdAt: ClientRuntime.Date?
        /// The ID which identifies where the Recommendation was produced
        /// This member is required.
        public var id: Swift.String?
        /// When the Recommendation was last updated
        public var lastUpdatedAt: ClientRuntime.Date?
        /// The lifecycle stage from AWS Trusted Advisor Priority
        public var lifecycleStage: TrustedAdvisorClientTypes.RecommendationLifecycleStage?
        /// The name of the AWS Trusted Advisor Recommendation
        /// This member is required.
        public var name: Swift.String?
        /// The pillar aggregations for cost savings
        public var pillarSpecificAggregates: TrustedAdvisorClientTypes.RecommendationPillarSpecificAggregates?
        /// The Pillars that the Recommendation is optimizing
        /// This member is required.
        public var pillars: [TrustedAdvisorClientTypes.RecommendationPillar]?
        /// An aggregation of all resources
        /// This member is required.
        public var resourcesAggregates: TrustedAdvisorClientTypes.RecommendationResourcesAggregates?
        /// The source of the Recommendation
        /// This member is required.
        public var source: TrustedAdvisorClientTypes.RecommendationSource?
        /// The status of the Recommendation
        /// This member is required.
        public var status: TrustedAdvisorClientTypes.RecommendationStatus?
        /// Whether the Recommendation was automated or generated by AWS Trusted Advisor Priority
        /// This member is required.
        public var type: TrustedAdvisorClientTypes.RecommendationType?

        public init(
            arn: Swift.String? = nil,
            awsServices: [Swift.String]? = nil,
            checkArn: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            id: Swift.String? = nil,
            lastUpdatedAt: ClientRuntime.Date? = nil,
            lifecycleStage: TrustedAdvisorClientTypes.RecommendationLifecycleStage? = nil,
            name: Swift.String? = nil,
            pillarSpecificAggregates: TrustedAdvisorClientTypes.RecommendationPillarSpecificAggregates? = nil,
            pillars: [TrustedAdvisorClientTypes.RecommendationPillar]? = nil,
            resourcesAggregates: TrustedAdvisorClientTypes.RecommendationResourcesAggregates? = nil,
            source: TrustedAdvisorClientTypes.RecommendationSource? = nil,
            status: TrustedAdvisorClientTypes.RecommendationStatus? = nil,
            type: TrustedAdvisorClientTypes.RecommendationType? = nil
        )
        {
            self.arn = arn
            self.awsServices = awsServices
            self.checkArn = checkArn
            self.createdAt = createdAt
            self.id = id
            self.lastUpdatedAt = lastUpdatedAt
            self.lifecycleStage = lifecycleStage
            self.name = name
            self.pillarSpecificAggregates = pillarSpecificAggregates
            self.pillars = pillars
            self.resourcesAggregates = resourcesAggregates
            self.source = source
            self.status = status
            self.type = type
        }
    }

}

extension TrustedAdvisorClientTypes.Recommendation: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Recommendation(arn: \(Swift.String(describing: arn)), awsServices: \(Swift.String(describing: awsServices)), checkArn: \(Swift.String(describing: checkArn)), createdAt: \(Swift.String(describing: createdAt)), createdBy: \(Swift.String(describing: createdBy)), description: \(Swift.String(describing: description)), id: \(Swift.String(describing: id)), lastUpdatedAt: \(Swift.String(describing: lastUpdatedAt)), lifecycleStage: \(Swift.String(describing: lifecycleStage)), name: \(Swift.String(describing: name)), pillarSpecificAggregates: \(Swift.String(describing: pillarSpecificAggregates)), pillars: \(Swift.String(describing: pillars)), resolvedAt: \(Swift.String(describing: resolvedAt)), resourcesAggregates: \(Swift.String(describing: resourcesAggregates)), source: \(Swift.String(describing: source)), status: \(Swift.String(describing: status)), type: \(Swift.String(describing: type)), updateReasonCode: \(Swift.String(describing: updateReasonCode)), updatedOnBehalfOf: \(Swift.String(describing: updatedOnBehalfOf)), updatedOnBehalfOfJobTitle: \(Swift.String(describing: updatedOnBehalfOfJobTitle)), updateReason: \"CONTENT_REDACTED\")"}
}

extension TrustedAdvisorClientTypes.Recommendation {

    static func read(from reader: SmithyJSON.Reader) throws -> TrustedAdvisorClientTypes.Recommendation {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = TrustedAdvisorClientTypes.Recommendation()
        value.id = try reader["id"].readIfPresent()
        value.type = try reader["type"].readIfPresent()
        value.checkArn = try reader["checkArn"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.lifecycleStage = try reader["lifecycleStage"].readIfPresent()
        value.pillars = try reader["pillars"].readListIfPresent(memberReadingClosure: TrustedAdvisorClientTypes.RecommendationPillar.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.source = try reader["source"].readIfPresent()
        value.awsServices = try reader["awsServices"].readListIfPresent(memberReadingClosure: Swift.String.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.name = try reader["name"].readIfPresent()
        value.resourcesAggregates = try reader["resourcesAggregates"].readIfPresent(with: TrustedAdvisorClientTypes.RecommendationResourcesAggregates.read(from:))
        value.pillarSpecificAggregates = try reader["pillarSpecificAggregates"].readIfPresent(with: TrustedAdvisorClientTypes.RecommendationPillarSpecificAggregates.read(from:))
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: .dateTime)
        value.lastUpdatedAt = try reader["lastUpdatedAt"].readTimestampIfPresent(format: .dateTime)
        value.arn = try reader["arn"].readIfPresent()
        value.description = try reader["description"].readIfPresent()
        value.createdBy = try reader["createdBy"].readIfPresent()
        value.updatedOnBehalfOf = try reader["updatedOnBehalfOf"].readIfPresent()
        value.updatedOnBehalfOfJobTitle = try reader["updatedOnBehalfOfJobTitle"].readIfPresent()
        value.updateReason = try reader["updateReason"].readIfPresent()
        value.updateReasonCode = try reader["updateReasonCode"].readIfPresent()
        value.resolvedAt = try reader["resolvedAt"].readTimestampIfPresent(format: .dateTime)
        return value
    }
}

extension TrustedAdvisorClientTypes {
    /// A Recommendation for an Account
    public struct Recommendation {
        /// The ARN of the Recommendation
        /// This member is required.
        public var arn: Swift.String?
        /// The AWS Services that the Recommendation applies to
        public var awsServices: [Swift.String]?
        /// The AWS Trusted Advisor Check ARN that relates to the Recommendation
        public var checkArn: Swift.String?
        /// When the Recommendation was created, if created by AWS Trusted Advisor Priority
        public var createdAt: ClientRuntime.Date?
        /// The creator, if created by AWS Trusted Advisor Priority
        public var createdBy: Swift.String?
        /// A description for AWS Trusted Advisor recommendations
        /// This member is required.
        public var description: Swift.String?
        /// The ID which identifies where the Recommendation was produced
        /// This member is required.
        public var id: Swift.String?
        /// When the Recommendation was last updated
        public var lastUpdatedAt: ClientRuntime.Date?
        /// The lifecycle stage from AWS Trusted Advisor Priority
        public var lifecycleStage: TrustedAdvisorClientTypes.RecommendationLifecycleStage?
        /// The name of the AWS Trusted Advisor Recommendation
        /// This member is required.
        public var name: Swift.String?
        /// The pillar aggregations for cost savings
        public var pillarSpecificAggregates: TrustedAdvisorClientTypes.RecommendationPillarSpecificAggregates?
        /// The Pillars that the Recommendation is optimizing
        /// This member is required.
        public var pillars: [TrustedAdvisorClientTypes.RecommendationPillar]?
        /// When the Recommendation was resolved
        public var resolvedAt: ClientRuntime.Date?
        /// An aggregation of all resources
        /// This member is required.
        public var resourcesAggregates: TrustedAdvisorClientTypes.RecommendationResourcesAggregates?
        /// The source of the Recommendation
        /// This member is required.
        public var source: TrustedAdvisorClientTypes.RecommendationSource?
        /// The status of the Recommendation
        /// This member is required.
        public var status: TrustedAdvisorClientTypes.RecommendationStatus?
        /// Whether the Recommendation was automated or generated by AWS Trusted Advisor Priority
        /// This member is required.
        public var type: TrustedAdvisorClientTypes.RecommendationType?
        /// Reason for the lifecycle stage change
        public var updateReason: Swift.String?
        /// Reason code for the lifecycle state change
        public var updateReasonCode: TrustedAdvisorClientTypes.UpdateRecommendationLifecycleStageReasonCode?
        /// The person on whose behalf a Technical Account Manager (TAM) updated the recommendation. This information is only available when a Technical Account Manager takes an action on a recommendation managed by AWS Trusted Advisor Priority
        public var updatedOnBehalfOf: Swift.String?
        /// The job title of the person on whose behalf a Technical Account Manager (TAM) updated the recommendation. This information is only available when a Technical Account Manager takes an action on a recommendation managed by AWS Trusted Advisor Priority
        public var updatedOnBehalfOfJobTitle: Swift.String?

        public init(
            arn: Swift.String? = nil,
            awsServices: [Swift.String]? = nil,
            checkArn: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            createdBy: Swift.String? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            lastUpdatedAt: ClientRuntime.Date? = nil,
            lifecycleStage: TrustedAdvisorClientTypes.RecommendationLifecycleStage? = nil,
            name: Swift.String? = nil,
            pillarSpecificAggregates: TrustedAdvisorClientTypes.RecommendationPillarSpecificAggregates? = nil,
            pillars: [TrustedAdvisorClientTypes.RecommendationPillar]? = nil,
            resolvedAt: ClientRuntime.Date? = nil,
            resourcesAggregates: TrustedAdvisorClientTypes.RecommendationResourcesAggregates? = nil,
            source: TrustedAdvisorClientTypes.RecommendationSource? = nil,
            status: TrustedAdvisorClientTypes.RecommendationStatus? = nil,
            type: TrustedAdvisorClientTypes.RecommendationType? = nil,
            updateReason: Swift.String? = nil,
            updateReasonCode: TrustedAdvisorClientTypes.UpdateRecommendationLifecycleStageReasonCode? = nil,
            updatedOnBehalfOf: Swift.String? = nil,
            updatedOnBehalfOfJobTitle: Swift.String? = nil
        )
        {
            self.arn = arn
            self.awsServices = awsServices
            self.checkArn = checkArn
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.description = description
            self.id = id
            self.lastUpdatedAt = lastUpdatedAt
            self.lifecycleStage = lifecycleStage
            self.name = name
            self.pillarSpecificAggregates = pillarSpecificAggregates
            self.pillars = pillars
            self.resolvedAt = resolvedAt
            self.resourcesAggregates = resourcesAggregates
            self.source = source
            self.status = status
            self.type = type
            self.updateReason = updateReason
            self.updateReasonCode = updateReasonCode
            self.updatedOnBehalfOf = updatedOnBehalfOf
            self.updatedOnBehalfOfJobTitle = updatedOnBehalfOfJobTitle
        }
    }

}

extension TrustedAdvisorClientTypes.RecommendationCostOptimizingAggregates {

    static func read(from reader: SmithyJSON.Reader) throws -> TrustedAdvisorClientTypes.RecommendationCostOptimizingAggregates {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = TrustedAdvisorClientTypes.RecommendationCostOptimizingAggregates()
        value.estimatedMonthlySavings = try reader["estimatedMonthlySavings"].readIfPresent()
        value.estimatedPercentMonthlySavings = try reader["estimatedPercentMonthlySavings"].readIfPresent()
        return value
    }
}

extension TrustedAdvisorClientTypes {
    /// Cost optimizing aggregates for a Recommendation
    public struct RecommendationCostOptimizingAggregates {
        /// The estimated monthly savings
        /// This member is required.
        public var estimatedMonthlySavings: Swift.Double?
        /// The estimated percently monthly savings
        /// This member is required.
        public var estimatedPercentMonthlySavings: Swift.Double?

        public init(
            estimatedMonthlySavings: Swift.Double? = nil,
            estimatedPercentMonthlySavings: Swift.Double? = nil
        )
        {
            self.estimatedMonthlySavings = estimatedMonthlySavings
            self.estimatedPercentMonthlySavings = estimatedPercentMonthlySavings
        }
    }

}

extension TrustedAdvisorClientTypes {

    public enum RecommendationLanguage: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case bahasaIndonesia
        case brazilianPortuguese
        case chinese
        case english
        case french
        case german
        case italian
        case japanese
        case korean
        case spanish
        case traditionalChinese
        case sdkUnknown(Swift.String)

        public static var allCases: [RecommendationLanguage] {
            return [
                .bahasaIndonesia,
                .brazilianPortuguese,
                .chinese,
                .english,
                .french,
                .german,
                .italian,
                .japanese,
                .korean,
                .spanish,
                .traditionalChinese,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .bahasaIndonesia: return "id"
            case .brazilianPortuguese: return "pt_BR"
            case .chinese: return "zh"
            case .english: return "en"
            case .french: return "fr"
            case .german: return "de"
            case .italian: return "it"
            case .japanese: return "ja"
            case .korean: return "ko"
            case .spanish: return "es"
            case .traditionalChinese: return "zh_TW"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension TrustedAdvisorClientTypes {

    public enum RecommendationLifecycleStage: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case dismissed
        case inProgress
        case pendingResponse
        case resolved
        case sdkUnknown(Swift.String)

        public static var allCases: [RecommendationLifecycleStage] {
            return [
                .dismissed,
                .inProgress,
                .pendingResponse,
                .resolved,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .dismissed: return "dismissed"
            case .inProgress: return "in_progress"
            case .pendingResponse: return "pending_response"
            case .resolved: return "resolved"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension TrustedAdvisorClientTypes {

    public enum RecommendationPillar: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case costOptimizing
        case faultTolerance
        case operationalExcellence
        case performance
        case security
        case serviceLimits
        case sdkUnknown(Swift.String)

        public static var allCases: [RecommendationPillar] {
            return [
                .costOptimizing,
                .faultTolerance,
                .operationalExcellence,
                .performance,
                .security,
                .serviceLimits,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .costOptimizing: return "cost_optimizing"
            case .faultTolerance: return "fault_tolerance"
            case .operationalExcellence: return "operational_excellence"
            case .performance: return "performance"
            case .security: return "security"
            case .serviceLimits: return "service_limits"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension TrustedAdvisorClientTypes.RecommendationPillarSpecificAggregates {

    static func read(from reader: SmithyJSON.Reader) throws -> TrustedAdvisorClientTypes.RecommendationPillarSpecificAggregates {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = TrustedAdvisorClientTypes.RecommendationPillarSpecificAggregates()
        value.costOptimizing = try reader["costOptimizing"].readIfPresent(with: TrustedAdvisorClientTypes.RecommendationCostOptimizingAggregates.read(from:))
        return value
    }
}

extension TrustedAdvisorClientTypes {
    /// Recommendation pillar aggregates
    public struct RecommendationPillarSpecificAggregates {
        /// Cost optimizing aggregates
        public var costOptimizing: TrustedAdvisorClientTypes.RecommendationCostOptimizingAggregates?

        public init(
            costOptimizing: TrustedAdvisorClientTypes.RecommendationCostOptimizingAggregates? = nil
        )
        {
            self.costOptimizing = costOptimizing
        }
    }

}

extension TrustedAdvisorClientTypes.RecommendationResourceExclusion {

    static func write(value: TrustedAdvisorClientTypes.RecommendationResourceExclusion?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["arn"].write(value.arn)
        try writer["isExcluded"].write(value.isExcluded)
    }
}

extension TrustedAdvisorClientTypes {
    /// The request entry for Recommendation Resource exclusion. Each entry is a combination of Recommendation Resource ARN and corresponding exclusion status
    public struct RecommendationResourceExclusion {
        /// The ARN of the Recommendation Resource
        /// This member is required.
        public var arn: Swift.String?
        /// The exclusion status
        /// This member is required.
        public var isExcluded: Swift.Bool?

        public init(
            arn: Swift.String? = nil,
            isExcluded: Swift.Bool? = nil
        )
        {
            self.arn = arn
            self.isExcluded = isExcluded
        }
    }

}

extension TrustedAdvisorClientTypes.RecommendationResourceSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> TrustedAdvisorClientTypes.RecommendationResourceSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = TrustedAdvisorClientTypes.RecommendationResourceSummary()
        value.id = try reader["id"].readIfPresent()
        value.arn = try reader["arn"].readIfPresent()
        value.awsResourceId = try reader["awsResourceId"].readIfPresent()
        value.regionCode = try reader["regionCode"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.metadata = try reader["metadata"].readMapIfPresent(valueReadingClosure: Swift.String.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.lastUpdatedAt = try reader["lastUpdatedAt"].readTimestampIfPresent(format: .dateTime)
        value.exclusionStatus = try reader["exclusionStatus"].readIfPresent() ?? .included
        value.recommendationArn = try reader["recommendationArn"].readIfPresent()
        return value
    }
}

extension TrustedAdvisorClientTypes {
    /// Summary of a Recommendation Resource
    public struct RecommendationResourceSummary {
        /// The ARN of the Recommendation Resource
        /// This member is required.
        public var arn: Swift.String?
        /// The AWS resource identifier
        /// This member is required.
        public var awsResourceId: Swift.String?
        /// The exclusion status of the Recommendation Resource
        public var exclusionStatus: TrustedAdvisorClientTypes.ExclusionStatus?
        /// The ID of the Recommendation Resource
        /// This member is required.
        public var id: Swift.String?
        /// When the Recommendation Resource was last updated
        /// This member is required.
        public var lastUpdatedAt: ClientRuntime.Date?
        /// Metadata associated with the Recommendation Resource
        /// This member is required.
        public var metadata: [Swift.String:Swift.String]?
        /// The Recommendation ARN
        /// This member is required.
        public var recommendationArn: Swift.String?
        /// The AWS Region code that the Recommendation Resource is in
        /// This member is required.
        public var regionCode: Swift.String?
        /// The current status of the Recommendation Resource
        /// This member is required.
        public var status: TrustedAdvisorClientTypes.ResourceStatus?

        public init(
            arn: Swift.String? = nil,
            awsResourceId: Swift.String? = nil,
            exclusionStatus: TrustedAdvisorClientTypes.ExclusionStatus? = nil,
            id: Swift.String? = nil,
            lastUpdatedAt: ClientRuntime.Date? = nil,
            metadata: [Swift.String:Swift.String]? = nil,
            recommendationArn: Swift.String? = nil,
            regionCode: Swift.String? = nil,
            status: TrustedAdvisorClientTypes.ResourceStatus? = nil
        )
        {
            self.arn = arn
            self.awsResourceId = awsResourceId
            self.exclusionStatus = exclusionStatus
            self.id = id
            self.lastUpdatedAt = lastUpdatedAt
            self.metadata = metadata
            self.recommendationArn = recommendationArn
            self.regionCode = regionCode
            self.status = status
        }
    }

}

extension TrustedAdvisorClientTypes.RecommendationResourcesAggregates {

    static func read(from reader: SmithyJSON.Reader) throws -> TrustedAdvisorClientTypes.RecommendationResourcesAggregates {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = TrustedAdvisorClientTypes.RecommendationResourcesAggregates()
        value.okCount = try reader["okCount"].readIfPresent()
        value.warningCount = try reader["warningCount"].readIfPresent()
        value.errorCount = try reader["errorCount"].readIfPresent()
        return value
    }
}

extension TrustedAdvisorClientTypes {
    /// Aggregation of Recommendation Resources
    public struct RecommendationResourcesAggregates {
        /// The number of AWS resources that were flagged to have errors according to the Trusted Advisor check
        /// This member is required.
        public var errorCount: Swift.Int?
        /// The number of AWS resources that were flagged to be OK according to the Trusted Advisor check
        /// This member is required.
        public var okCount: Swift.Int?
        /// The number of AWS resources that were flagged to have warning according to the Trusted Advisor check
        /// This member is required.
        public var warningCount: Swift.Int?

        public init(
            errorCount: Swift.Int? = nil,
            okCount: Swift.Int? = nil,
            warningCount: Swift.Int? = nil
        )
        {
            self.errorCount = errorCount
            self.okCount = okCount
            self.warningCount = warningCount
        }
    }

}

extension TrustedAdvisorClientTypes {

    public enum RecommendationSource: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case awsConfig
        case computeOptimizer
        case costExplorer
        case lse
        case manual
        case pse
        case rds
        case resilience
        case resilienceHub
        case securityHub
        case stir
        case taCheck
        case wellArchitected
        case sdkUnknown(Swift.String)

        public static var allCases: [RecommendationSource] {
            return [
                .awsConfig,
                .computeOptimizer,
                .costExplorer,
                .lse,
                .manual,
                .pse,
                .rds,
                .resilience,
                .resilienceHub,
                .securityHub,
                .stir,
                .taCheck,
                .wellArchitected,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .awsConfig: return "aws_config"
            case .computeOptimizer: return "compute_optimizer"
            case .costExplorer: return "cost_explorer"
            case .lse: return "lse"
            case .manual: return "manual"
            case .pse: return "pse"
            case .rds: return "rds"
            case .resilience: return "resilience"
            case .resilienceHub: return "resilience_hub"
            case .securityHub: return "security_hub"
            case .stir: return "stir"
            case .taCheck: return "ta_check"
            case .wellArchitected: return "well_architected"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension TrustedAdvisorClientTypes {

    public enum RecommendationStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case error
        case ok
        case warning
        case sdkUnknown(Swift.String)

        public static var allCases: [RecommendationStatus] {
            return [
                .error,
                .ok,
                .warning,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .error: return "error"
            case .ok: return "ok"
            case .warning: return "warning"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension TrustedAdvisorClientTypes.RecommendationSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> TrustedAdvisorClientTypes.RecommendationSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = TrustedAdvisorClientTypes.RecommendationSummary()
        value.id = try reader["id"].readIfPresent()
        value.type = try reader["type"].readIfPresent()
        value.checkArn = try reader["checkArn"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.lifecycleStage = try reader["lifecycleStage"].readIfPresent()
        value.pillars = try reader["pillars"].readListIfPresent(memberReadingClosure: TrustedAdvisorClientTypes.RecommendationPillar.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.source = try reader["source"].readIfPresent()
        value.awsServices = try reader["awsServices"].readListIfPresent(memberReadingClosure: Swift.String.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.name = try reader["name"].readIfPresent()
        value.resourcesAggregates = try reader["resourcesAggregates"].readIfPresent(with: TrustedAdvisorClientTypes.RecommendationResourcesAggregates.read(from:))
        value.pillarSpecificAggregates = try reader["pillarSpecificAggregates"].readIfPresent(with: TrustedAdvisorClientTypes.RecommendationPillarSpecificAggregates.read(from:))
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: .dateTime)
        value.lastUpdatedAt = try reader["lastUpdatedAt"].readTimestampIfPresent(format: .dateTime)
        value.arn = try reader["arn"].readIfPresent()
        return value
    }
}

extension TrustedAdvisorClientTypes {
    /// Summary of Recommendation for an Account
    public struct RecommendationSummary {
        /// The ARN of the Recommendation
        /// This member is required.
        public var arn: Swift.String?
        /// The AWS Services that the Recommendation applies to
        public var awsServices: [Swift.String]?
        /// The AWS Trusted Advisor Check ARN that relates to the Recommendation
        public var checkArn: Swift.String?
        /// When the Recommendation was created, if created by AWS Trusted Advisor Priority
        public var createdAt: ClientRuntime.Date?
        /// The ID which identifies where the Recommendation was produced
        /// This member is required.
        public var id: Swift.String?
        /// When the Recommendation was last updated
        public var lastUpdatedAt: ClientRuntime.Date?
        /// The lifecycle stage from AWS Trusted Advisor Priority
        public var lifecycleStage: TrustedAdvisorClientTypes.RecommendationLifecycleStage?
        /// The name of the AWS Trusted Advisor Recommendation
        /// This member is required.
        public var name: Swift.String?
        /// The pillar aggregations for cost savings
        public var pillarSpecificAggregates: TrustedAdvisorClientTypes.RecommendationPillarSpecificAggregates?
        /// The Pillars that the Recommendation is optimizing
        /// This member is required.
        public var pillars: [TrustedAdvisorClientTypes.RecommendationPillar]?
        /// An aggregation of all resources
        /// This member is required.
        public var resourcesAggregates: TrustedAdvisorClientTypes.RecommendationResourcesAggregates?
        /// The source of the Recommendation
        /// This member is required.
        public var source: TrustedAdvisorClientTypes.RecommendationSource?
        /// The status of the Recommendation
        /// This member is required.
        public var status: TrustedAdvisorClientTypes.RecommendationStatus?
        /// Whether the Recommendation was automated or generated by AWS Trusted Advisor Priority
        /// This member is required.
        public var type: TrustedAdvisorClientTypes.RecommendationType?

        public init(
            arn: Swift.String? = nil,
            awsServices: [Swift.String]? = nil,
            checkArn: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            id: Swift.String? = nil,
            lastUpdatedAt: ClientRuntime.Date? = nil,
            lifecycleStage: TrustedAdvisorClientTypes.RecommendationLifecycleStage? = nil,
            name: Swift.String? = nil,
            pillarSpecificAggregates: TrustedAdvisorClientTypes.RecommendationPillarSpecificAggregates? = nil,
            pillars: [TrustedAdvisorClientTypes.RecommendationPillar]? = nil,
            resourcesAggregates: TrustedAdvisorClientTypes.RecommendationResourcesAggregates? = nil,
            source: TrustedAdvisorClientTypes.RecommendationSource? = nil,
            status: TrustedAdvisorClientTypes.RecommendationStatus? = nil,
            type: TrustedAdvisorClientTypes.RecommendationType? = nil
        )
        {
            self.arn = arn
            self.awsServices = awsServices
            self.checkArn = checkArn
            self.createdAt = createdAt
            self.id = id
            self.lastUpdatedAt = lastUpdatedAt
            self.lifecycleStage = lifecycleStage
            self.name = name
            self.pillarSpecificAggregates = pillarSpecificAggregates
            self.pillars = pillars
            self.resourcesAggregates = resourcesAggregates
            self.source = source
            self.status = status
            self.type = type
        }
    }

}

extension TrustedAdvisorClientTypes {

    public enum RecommendationType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case priority
        case standard
        case sdkUnknown(Swift.String)

        public static var allCases: [RecommendationType] {
            return [
                .priority,
                .standard,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .priority: return "priority"
            case .standard: return "standard"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// Exception that the requested resource has not been found
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension TrustedAdvisorClientTypes {

    public enum ResourceStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case error
        case ok
        case warning
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceStatus] {
            return [
                .error,
                .ok,
                .warning,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .error: return "error"
            case .ok: return "ok"
            case .warning: return "warning"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension ThrottlingException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ThrottlingException {
        let reader = baseError.errorBodyReader
        var value = ThrottlingException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// Exception to notify that requests are being throttled
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { true }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

public enum TrustedAdvisorClientTypes {}

extension UpdateOrganizationRecommendationLifecycleInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateOrganizationRecommendationLifecycleInput(lifecycleStage: \(Swift.String(describing: lifecycleStage)), organizationRecommendationIdentifier: \(Swift.String(describing: organizationRecommendationIdentifier)), updateReasonCode: \(Swift.String(describing: updateReasonCode)), updateReason: \"CONTENT_REDACTED\")"}
}

extension UpdateOrganizationRecommendationLifecycleInput {

    static func urlPathProvider(_ value: UpdateOrganizationRecommendationLifecycleInput) -> Swift.String? {
        guard let organizationRecommendationIdentifier = value.organizationRecommendationIdentifier else {
            return nil
        }
        return "/v1/organization-recommendations/\(organizationRecommendationIdentifier.urlPercentEncoding())/lifecycle"
    }
}

extension UpdateOrganizationRecommendationLifecycleInput {

    static func write(value: UpdateOrganizationRecommendationLifecycleInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["lifecycleStage"].write(value.lifecycleStage)
        try writer["updateReason"].write(value.updateReason)
        try writer["updateReasonCode"].write(value.updateReasonCode)
    }
}

public struct UpdateOrganizationRecommendationLifecycleInput {
    /// The new lifecycle stage
    /// This member is required.
    public var lifecycleStage: TrustedAdvisorClientTypes.UpdateRecommendationLifecycleStage?
    /// The Recommendation identifier for AWS Trusted Advisor Priority recommendations
    /// This member is required.
    public var organizationRecommendationIdentifier: Swift.String?
    /// Reason for the lifecycle stage change
    public var updateReason: Swift.String?
    /// Reason code for the lifecycle state change
    public var updateReasonCode: TrustedAdvisorClientTypes.UpdateRecommendationLifecycleStageReasonCode?

    public init(
        lifecycleStage: TrustedAdvisorClientTypes.UpdateRecommendationLifecycleStage? = nil,
        organizationRecommendationIdentifier: Swift.String? = nil,
        updateReason: Swift.String? = nil,
        updateReasonCode: TrustedAdvisorClientTypes.UpdateRecommendationLifecycleStageReasonCode? = nil
    )
    {
        self.lifecycleStage = lifecycleStage
        self.organizationRecommendationIdentifier = organizationRecommendationIdentifier
        self.updateReason = updateReason
        self.updateReasonCode = updateReasonCode
    }
}

extension UpdateOrganizationRecommendationLifecycleOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> UpdateOrganizationRecommendationLifecycleOutput {
        return UpdateOrganizationRecommendationLifecycleOutput()
    }
}

public struct UpdateOrganizationRecommendationLifecycleOutput {

    public init() { }
}

enum UpdateOrganizationRecommendationLifecycleOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension UpdateRecommendationLifecycleInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateRecommendationLifecycleInput(lifecycleStage: \(Swift.String(describing: lifecycleStage)), recommendationIdentifier: \(Swift.String(describing: recommendationIdentifier)), updateReasonCode: \(Swift.String(describing: updateReasonCode)), updateReason: \"CONTENT_REDACTED\")"}
}

extension UpdateRecommendationLifecycleInput {

    static func urlPathProvider(_ value: UpdateRecommendationLifecycleInput) -> Swift.String? {
        guard let recommendationIdentifier = value.recommendationIdentifier else {
            return nil
        }
        return "/v1/recommendations/\(recommendationIdentifier.urlPercentEncoding())/lifecycle"
    }
}

extension UpdateRecommendationLifecycleInput {

    static func write(value: UpdateRecommendationLifecycleInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["lifecycleStage"].write(value.lifecycleStage)
        try writer["updateReason"].write(value.updateReason)
        try writer["updateReasonCode"].write(value.updateReasonCode)
    }
}

public struct UpdateRecommendationLifecycleInput {
    /// The new lifecycle stage
    /// This member is required.
    public var lifecycleStage: TrustedAdvisorClientTypes.UpdateRecommendationLifecycleStage?
    /// The Recommendation identifier for AWS Trusted Advisor Priority recommendations
    /// This member is required.
    public var recommendationIdentifier: Swift.String?
    /// Reason for the lifecycle stage change
    public var updateReason: Swift.String?
    /// Reason code for the lifecycle state change
    public var updateReasonCode: TrustedAdvisorClientTypes.UpdateRecommendationLifecycleStageReasonCode?

    public init(
        lifecycleStage: TrustedAdvisorClientTypes.UpdateRecommendationLifecycleStage? = nil,
        recommendationIdentifier: Swift.String? = nil,
        updateReason: Swift.String? = nil,
        updateReasonCode: TrustedAdvisorClientTypes.UpdateRecommendationLifecycleStageReasonCode? = nil
    )
    {
        self.lifecycleStage = lifecycleStage
        self.recommendationIdentifier = recommendationIdentifier
        self.updateReason = updateReason
        self.updateReasonCode = updateReasonCode
    }
}

extension UpdateRecommendationLifecycleOutput {

    static func httpOutput(from httpResponse: ClientRuntime.HttpResponse) async throws -> UpdateRecommendationLifecycleOutput {
        return UpdateRecommendationLifecycleOutput()
    }
}

public struct UpdateRecommendationLifecycleOutput {

    public init() { }
}

enum UpdateRecommendationLifecycleOutputError {

    static func httpError(from httpResponse: ClientRuntime.HttpResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension TrustedAdvisorClientTypes {

    public enum UpdateRecommendationLifecycleStage: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case dismissed
        case inProgress
        case pendingResponse
        case resolved
        case sdkUnknown(Swift.String)

        public static var allCases: [UpdateRecommendationLifecycleStage] {
            return [
                .dismissed,
                .inProgress,
                .pendingResponse,
                .resolved,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .dismissed: return "dismissed"
            case .inProgress: return "in_progress"
            case .pendingResponse: return "pending_response"
            case .resolved: return "resolved"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension TrustedAdvisorClientTypes {

    public enum UpdateRecommendationLifecycleStageReasonCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case lowPriority
        case nonCriticalAccount
        case notApplicable
        case other
        case otherMethodsAvailable
        case temporaryAccount
        case validBusinessCase
        case sdkUnknown(Swift.String)

        public static var allCases: [UpdateRecommendationLifecycleStageReasonCode] {
            return [
                .lowPriority,
                .nonCriticalAccount,
                .notApplicable,
                .other,
                .otherMethodsAvailable,
                .temporaryAccount,
                .validBusinessCase,
                .sdkUnknown("")
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .lowPriority: return "low_priority"
            case .nonCriticalAccount: return "non_critical_account"
            case .notApplicable: return "not_applicable"
            case .other: return "other"
            case .otherMethodsAvailable: return "other_methods_available"
            case .temporaryAccount: return "temporary_account"
            case .validBusinessCase: return "valid_business_case"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension TrustedAdvisorClientTypes.UpdateRecommendationResourceExclusionError {

    static func read(from reader: SmithyJSON.Reader) throws -> TrustedAdvisorClientTypes.UpdateRecommendationResourceExclusionError {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = TrustedAdvisorClientTypes.UpdateRecommendationResourceExclusionError()
        value.arn = try reader["arn"].readIfPresent()
        value.errorCode = try reader["errorCode"].readIfPresent()
        value.errorMessage = try reader["errorMessage"].readIfPresent()
        return value
    }
}

extension TrustedAdvisorClientTypes {
    /// The error entry for Recommendation Resource exclusion. Each entry is a combination of Recommendation Resource ARN, error code and error message
    public struct UpdateRecommendationResourceExclusionError {
        /// The ARN of the Recommendation Resource
        public var arn: Swift.String?
        /// The error code
        public var errorCode: Swift.String?
        /// The error message
        public var errorMessage: Swift.String?

        public init(
            arn: Swift.String? = nil,
            errorCode: Swift.String? = nil,
            errorMessage: Swift.String? = nil
        )
        {
            self.arn = arn
            self.errorCode = errorCode
            self.errorMessage = errorMessage
        }
    }

}

extension ValidationException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ValidationException {
        let reader = baseError.errorBodyReader
        var value = ValidationException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

/// Exception that the request failed to satisfy service constraints
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}
