// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Exception that access has been denied due to insufficient access
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TrustedAdvisorClientTypes.AccountRecommendationLifecycleSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId
        case accountRecommendationArn
        case lastUpdatedAt
        case lifecycleStage
        case updateReason
        case updateReasonCode
        case updatedOnBehalfOf
        case updatedOnBehalfOfJobTitle
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let accountRecommendationArn = self.accountRecommendationArn {
            try encodeContainer.encode(accountRecommendationArn, forKey: .accountRecommendationArn)
        }
        if let lastUpdatedAt = self.lastUpdatedAt {
            try encodeContainer.encodeTimestamp(lastUpdatedAt, format: .dateTime, forKey: .lastUpdatedAt)
        }
        if let lifecycleStage = self.lifecycleStage {
            try encodeContainer.encode(lifecycleStage.rawValue, forKey: .lifecycleStage)
        }
        if let updateReason = self.updateReason {
            try encodeContainer.encode(updateReason, forKey: .updateReason)
        }
        if let updateReasonCode = self.updateReasonCode {
            try encodeContainer.encode(updateReasonCode.rawValue, forKey: .updateReasonCode)
        }
        if let updatedOnBehalfOf = self.updatedOnBehalfOf {
            try encodeContainer.encode(updatedOnBehalfOf, forKey: .updatedOnBehalfOf)
        }
        if let updatedOnBehalfOfJobTitle = self.updatedOnBehalfOfJobTitle {
            try encodeContainer.encode(updatedOnBehalfOfJobTitle, forKey: .updatedOnBehalfOfJobTitle)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let accountRecommendationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountRecommendationArn)
        accountRecommendationArn = accountRecommendationArnDecoded
        let lifecycleStageDecoded = try containerValues.decodeIfPresent(TrustedAdvisorClientTypes.RecommendationLifecycleStage.self, forKey: .lifecycleStage)
        lifecycleStage = lifecycleStageDecoded
        let updatedOnBehalfOfDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .updatedOnBehalfOf)
        updatedOnBehalfOf = updatedOnBehalfOfDecoded
        let updatedOnBehalfOfJobTitleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .updatedOnBehalfOfJobTitle)
        updatedOnBehalfOfJobTitle = updatedOnBehalfOfJobTitleDecoded
        let updateReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .updateReason)
        updateReason = updateReasonDecoded
        let updateReasonCodeDecoded = try containerValues.decodeIfPresent(TrustedAdvisorClientTypes.UpdateRecommendationLifecycleStageReasonCode.self, forKey: .updateReasonCode)
        updateReasonCode = updateReasonCodeDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
    }
}

extension TrustedAdvisorClientTypes.AccountRecommendationLifecycleSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AccountRecommendationLifecycleSummary(accountId: \(Swift.String(describing: accountId)), accountRecommendationArn: \(Swift.String(describing: accountRecommendationArn)), lastUpdatedAt: \(Swift.String(describing: lastUpdatedAt)), lifecycleStage: \(Swift.String(describing: lifecycleStage)), updateReasonCode: \(Swift.String(describing: updateReasonCode)), updatedOnBehalfOf: \(Swift.String(describing: updatedOnBehalfOf)), updatedOnBehalfOfJobTitle: \(Swift.String(describing: updatedOnBehalfOfJobTitle)), updateReason: \"CONTENT_REDACTED\")"}
}

extension TrustedAdvisorClientTypes {
    /// Summary of an AccountRecommendationLifecycle for an Organization Recommendation
    public struct AccountRecommendationLifecycleSummary: Swift.Equatable {
        /// The AWS account ID
        public var accountId: Swift.String?
        /// The Recommendation ARN
        public var accountRecommendationArn: Swift.String?
        /// When the Recommendation was last updated
        public var lastUpdatedAt: ClientRuntime.Date?
        /// The lifecycle stage from AWS Trusted Advisor Priority
        public var lifecycleStage: TrustedAdvisorClientTypes.RecommendationLifecycleStage?
        /// Reason for the lifecycle stage change
        public var updateReason: Swift.String?
        /// Reason code for the lifecycle state change
        public var updateReasonCode: TrustedAdvisorClientTypes.UpdateRecommendationLifecycleStageReasonCode?
        /// The person on whose behalf a Technical Account Manager (TAM) updated the recommendation. This information is only available when a Technical Account Manager takes an action on a recommendation managed by AWS Trusted Advisor Priority
        public var updatedOnBehalfOf: Swift.String?
        /// The job title of the person on whose behalf a Technical Account Manager (TAM) updated the recommendation. This information is only available when a Technical Account Manager takes an action on a recommendation managed by AWS Trusted Advisor Priority
        public var updatedOnBehalfOfJobTitle: Swift.String?

        public init(
            accountId: Swift.String? = nil,
            accountRecommendationArn: Swift.String? = nil,
            lastUpdatedAt: ClientRuntime.Date? = nil,
            lifecycleStage: TrustedAdvisorClientTypes.RecommendationLifecycleStage? = nil,
            updateReason: Swift.String? = nil,
            updateReasonCode: TrustedAdvisorClientTypes.UpdateRecommendationLifecycleStageReasonCode? = nil,
            updatedOnBehalfOf: Swift.String? = nil,
            updatedOnBehalfOfJobTitle: Swift.String? = nil
        )
        {
            self.accountId = accountId
            self.accountRecommendationArn = accountRecommendationArn
            self.lastUpdatedAt = lastUpdatedAt
            self.lifecycleStage = lifecycleStage
            self.updateReason = updateReason
            self.updateReasonCode = updateReasonCode
            self.updatedOnBehalfOf = updatedOnBehalfOf
            self.updatedOnBehalfOfJobTitle = updatedOnBehalfOfJobTitle
        }
    }

}

extension TrustedAdvisorClientTypes.CheckSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case awsServices
        case description
        case id
        case metadata
        case name
        case pillars
        case source
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let awsServices = awsServices {
            var awsServicesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .awsServices)
            for recommendationawsservice0 in awsServices {
                try awsServicesContainer.encode(recommendationawsservice0)
            }
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let metadata = metadata {
            var metadataContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .metadata)
            for (dictKey0, stringMap0) in metadata {
                try metadataContainer.encode(stringMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let pillars = pillars {
            var pillarsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .pillars)
            for recommendationpillar0 in pillars {
                try pillarsContainer.encode(recommendationpillar0.rawValue)
            }
        }
        if let source = self.source {
            try encodeContainer.encode(source.rawValue, forKey: .source)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let pillarsContainer = try containerValues.decodeIfPresent([TrustedAdvisorClientTypes.RecommendationPillar?].self, forKey: .pillars)
        var pillarsDecoded0:[TrustedAdvisorClientTypes.RecommendationPillar]? = nil
        if let pillarsContainer = pillarsContainer {
            pillarsDecoded0 = [TrustedAdvisorClientTypes.RecommendationPillar]()
            for enum0 in pillarsContainer {
                if let enum0 = enum0 {
                    pillarsDecoded0?.append(enum0)
                }
            }
        }
        pillars = pillarsDecoded0
        let awsServicesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .awsServices)
        var awsServicesDecoded0:[Swift.String]? = nil
        if let awsServicesContainer = awsServicesContainer {
            awsServicesDecoded0 = [Swift.String]()
            for string0 in awsServicesContainer {
                if let string0 = string0 {
                    awsServicesDecoded0?.append(string0)
                }
            }
        }
        awsServices = awsServicesDecoded0
        let sourceDecoded = try containerValues.decodeIfPresent(TrustedAdvisorClientTypes.RecommendationSource.self, forKey: .source)
        source = sourceDecoded
        let metadataContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .metadata)
        var metadataDecoded0: [Swift.String:Swift.String]? = nil
        if let metadataContainer = metadataContainer {
            metadataDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in metadataContainer {
                if let string0 = string0 {
                    metadataDecoded0?[key0] = string0
                }
            }
        }
        metadata = metadataDecoded0
    }
}

extension TrustedAdvisorClientTypes {
    /// A summary of an AWS Trusted Advisor Check
    public struct CheckSummary: Swift.Equatable {
        /// The ARN of the AWS Trusted Advisor Check
        /// This member is required.
        public var arn: Swift.String?
        /// The AWS Services that the Check applies to
        /// This member is required.
        public var awsServices: [Swift.String]?
        /// A description of what the AWS Trusted Advisor Check is monitoring
        /// This member is required.
        public var description: Swift.String?
        /// The unique identifier of the AWS Trusted Advisor Check
        /// This member is required.
        public var id: Swift.String?
        /// The column headings for the metadata returned in the resource
        /// This member is required.
        public var metadata: [Swift.String:Swift.String]?
        /// The name of the AWS Trusted Advisor Check
        /// This member is required.
        public var name: Swift.String?
        /// The Recommendation pillars that the AWS Trusted Advisor Check falls under
        /// This member is required.
        public var pillars: [TrustedAdvisorClientTypes.RecommendationPillar]?
        /// The source of the Recommendation
        /// This member is required.
        public var source: TrustedAdvisorClientTypes.RecommendationSource?

        public init(
            arn: Swift.String? = nil,
            awsServices: [Swift.String]? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            metadata: [Swift.String:Swift.String]? = nil,
            name: Swift.String? = nil,
            pillars: [TrustedAdvisorClientTypes.RecommendationPillar]? = nil,
            source: TrustedAdvisorClientTypes.RecommendationSource? = nil
        )
        {
            self.arn = arn
            self.awsServices = awsServices
            self.description = description
            self.id = id
            self.metadata = metadata
            self.name = name
            self.pillars = pillars
            self.source = source
        }
    }

}

extension ConflictException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Exception that the request was denied due to conflictions in state
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension GetOrganizationRecommendationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let organizationRecommendationIdentifier = organizationRecommendationIdentifier else {
            return nil
        }
        return "/v1/organization-recommendations/\(organizationRecommendationIdentifier.urlPercentEncoding())"
    }
}

public struct GetOrganizationRecommendationInput: Swift.Equatable {
    /// The Recommendation identifier
    /// This member is required.
    public var organizationRecommendationIdentifier: Swift.String?

    public init(
        organizationRecommendationIdentifier: Swift.String? = nil
    )
    {
        self.organizationRecommendationIdentifier = organizationRecommendationIdentifier
    }
}

struct GetOrganizationRecommendationInputBody: Swift.Equatable {
}

extension GetOrganizationRecommendationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetOrganizationRecommendationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetOrganizationRecommendationOutputBody = try responseDecoder.decode(responseBody: data)
            self.organizationRecommendation = output.organizationRecommendation
        } else {
            self.organizationRecommendation = nil
        }
    }
}

public struct GetOrganizationRecommendationOutput: Swift.Equatable {
    /// The Recommendation
    public var organizationRecommendation: TrustedAdvisorClientTypes.OrganizationRecommendation?

    public init(
        organizationRecommendation: TrustedAdvisorClientTypes.OrganizationRecommendation? = nil
    )
    {
        self.organizationRecommendation = organizationRecommendation
    }
}

struct GetOrganizationRecommendationOutputBody: Swift.Equatable {
    let organizationRecommendation: TrustedAdvisorClientTypes.OrganizationRecommendation?
}

extension GetOrganizationRecommendationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case organizationRecommendation
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let organizationRecommendationDecoded = try containerValues.decodeIfPresent(TrustedAdvisorClientTypes.OrganizationRecommendation.self, forKey: .organizationRecommendation)
        organizationRecommendation = organizationRecommendationDecoded
    }
}

enum GetOrganizationRecommendationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetRecommendationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let recommendationIdentifier = recommendationIdentifier else {
            return nil
        }
        return "/v1/recommendations/\(recommendationIdentifier.urlPercentEncoding())"
    }
}

public struct GetRecommendationInput: Swift.Equatable {
    /// The Recommendation identifier
    /// This member is required.
    public var recommendationIdentifier: Swift.String?

    public init(
        recommendationIdentifier: Swift.String? = nil
    )
    {
        self.recommendationIdentifier = recommendationIdentifier
    }
}

struct GetRecommendationInputBody: Swift.Equatable {
}

extension GetRecommendationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetRecommendationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetRecommendationOutputBody = try responseDecoder.decode(responseBody: data)
            self.recommendation = output.recommendation
        } else {
            self.recommendation = nil
        }
    }
}

public struct GetRecommendationOutput: Swift.Equatable {
    /// The Recommendation
    public var recommendation: TrustedAdvisorClientTypes.Recommendation?

    public init(
        recommendation: TrustedAdvisorClientTypes.Recommendation? = nil
    )
    {
        self.recommendation = recommendation
    }
}

struct GetRecommendationOutputBody: Swift.Equatable {
    let recommendation: TrustedAdvisorClientTypes.Recommendation?
}

extension GetRecommendationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case recommendation
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recommendationDecoded = try containerValues.decodeIfPresent(TrustedAdvisorClientTypes.Recommendation.self, forKey: .recommendation)
        recommendation = recommendationDecoded
    }
}

enum GetRecommendationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension InternalServerException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Exception to notify that an unexpected internal error occurred during processing of the request
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListChecksInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let pillar = pillar {
                let pillarQueryItem = ClientRuntime.URLQueryItem(name: "pillar".urlPercentEncoding(), value: Swift.String(pillar.rawValue).urlPercentEncoding())
                items.append(pillarQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let language = language {
                let languageQueryItem = ClientRuntime.URLQueryItem(name: "language".urlPercentEncoding(), value: Swift.String(language.rawValue).urlPercentEncoding())
                items.append(languageQueryItem)
            }
            if let source = source {
                let sourceQueryItem = ClientRuntime.URLQueryItem(name: "source".urlPercentEncoding(), value: Swift.String(source.rawValue).urlPercentEncoding())
                items.append(sourceQueryItem)
            }
            if let awsService = awsService {
                let awsServiceQueryItem = ClientRuntime.URLQueryItem(name: "awsService".urlPercentEncoding(), value: Swift.String(awsService).urlPercentEncoding())
                items.append(awsServiceQueryItem)
            }
            return items
        }
    }
}

extension ListChecksInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/checks"
    }
}

public struct ListChecksInput: Swift.Equatable {
    /// The aws service associated with the check
    public var awsService: Swift.String?
    /// The ISO 639-1 code for the language that you want your checks to appear in.
    public var language: TrustedAdvisorClientTypes.RecommendationLanguage?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The pillar of the check
    public var pillar: TrustedAdvisorClientTypes.RecommendationPillar?
    /// The source of the check
    public var source: TrustedAdvisorClientTypes.RecommendationSource?

    public init(
        awsService: Swift.String? = nil,
        language: TrustedAdvisorClientTypes.RecommendationLanguage? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        pillar: TrustedAdvisorClientTypes.RecommendationPillar? = nil,
        source: TrustedAdvisorClientTypes.RecommendationSource? = nil
    )
    {
        self.awsService = awsService
        self.language = language
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.pillar = pillar
        self.source = source
    }
}

struct ListChecksInputBody: Swift.Equatable {
}

extension ListChecksInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListChecksOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListChecksOutputBody = try responseDecoder.decode(responseBody: data)
            self.checkSummaries = output.checkSummaries
            self.nextToken = output.nextToken
        } else {
            self.checkSummaries = nil
            self.nextToken = nil
        }
    }
}

public struct ListChecksOutput: Swift.Equatable {
    /// The list of Checks
    /// This member is required.
    public var checkSummaries: [TrustedAdvisorClientTypes.CheckSummary]?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        checkSummaries: [TrustedAdvisorClientTypes.CheckSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.checkSummaries = checkSummaries
        self.nextToken = nextToken
    }
}

struct ListChecksOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let checkSummaries: [TrustedAdvisorClientTypes.CheckSummary]?
}

extension ListChecksOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case checkSummaries
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let checkSummariesContainer = try containerValues.decodeIfPresent([TrustedAdvisorClientTypes.CheckSummary?].self, forKey: .checkSummaries)
        var checkSummariesDecoded0:[TrustedAdvisorClientTypes.CheckSummary]? = nil
        if let checkSummariesContainer = checkSummariesContainer {
            checkSummariesDecoded0 = [TrustedAdvisorClientTypes.CheckSummary]()
            for structure0 in checkSummariesContainer {
                if let structure0 = structure0 {
                    checkSummariesDecoded0?.append(structure0)
                }
            }
        }
        checkSummaries = checkSummariesDecoded0
    }
}

enum ListChecksOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListOrganizationRecommendationAccountsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let affectedAccountId = affectedAccountId {
                let affectedAccountIdQueryItem = ClientRuntime.URLQueryItem(name: "affectedAccountId".urlPercentEncoding(), value: Swift.String(affectedAccountId).urlPercentEncoding())
                items.append(affectedAccountIdQueryItem)
            }
            return items
        }
    }
}

extension ListOrganizationRecommendationAccountsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let organizationRecommendationIdentifier = organizationRecommendationIdentifier else {
            return nil
        }
        return "/v1/organization-recommendations/\(organizationRecommendationIdentifier.urlPercentEncoding())/accounts"
    }
}

public struct ListOrganizationRecommendationAccountsInput: Swift.Equatable {
    /// An account affected by this organization recommendation
    public var affectedAccountId: Swift.String?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The Recommendation identifier
    /// This member is required.
    public var organizationRecommendationIdentifier: Swift.String?

    public init(
        affectedAccountId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        organizationRecommendationIdentifier: Swift.String? = nil
    )
    {
        self.affectedAccountId = affectedAccountId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.organizationRecommendationIdentifier = organizationRecommendationIdentifier
    }
}

struct ListOrganizationRecommendationAccountsInputBody: Swift.Equatable {
}

extension ListOrganizationRecommendationAccountsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListOrganizationRecommendationAccountsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListOrganizationRecommendationAccountsOutputBody = try responseDecoder.decode(responseBody: data)
            self.accountRecommendationLifecycleSummaries = output.accountRecommendationLifecycleSummaries
            self.nextToken = output.nextToken
        } else {
            self.accountRecommendationLifecycleSummaries = nil
            self.nextToken = nil
        }
    }
}

public struct ListOrganizationRecommendationAccountsOutput: Swift.Equatable {
    /// The account recommendations lifecycles that are applicable to the Recommendation
    /// This member is required.
    public var accountRecommendationLifecycleSummaries: [TrustedAdvisorClientTypes.AccountRecommendationLifecycleSummary]?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?

    public init(
        accountRecommendationLifecycleSummaries: [TrustedAdvisorClientTypes.AccountRecommendationLifecycleSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.accountRecommendationLifecycleSummaries = accountRecommendationLifecycleSummaries
        self.nextToken = nextToken
    }
}

struct ListOrganizationRecommendationAccountsOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let accountRecommendationLifecycleSummaries: [TrustedAdvisorClientTypes.AccountRecommendationLifecycleSummary]?
}

extension ListOrganizationRecommendationAccountsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountRecommendationLifecycleSummaries
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let accountRecommendationLifecycleSummariesContainer = try containerValues.decodeIfPresent([TrustedAdvisorClientTypes.AccountRecommendationLifecycleSummary?].self, forKey: .accountRecommendationLifecycleSummaries)
        var accountRecommendationLifecycleSummariesDecoded0:[TrustedAdvisorClientTypes.AccountRecommendationLifecycleSummary]? = nil
        if let accountRecommendationLifecycleSummariesContainer = accountRecommendationLifecycleSummariesContainer {
            accountRecommendationLifecycleSummariesDecoded0 = [TrustedAdvisorClientTypes.AccountRecommendationLifecycleSummary]()
            for structure0 in accountRecommendationLifecycleSummariesContainer {
                if let structure0 = structure0 {
                    accountRecommendationLifecycleSummariesDecoded0?.append(structure0)
                }
            }
        }
        accountRecommendationLifecycleSummaries = accountRecommendationLifecycleSummariesDecoded0
    }
}

enum ListOrganizationRecommendationAccountsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListOrganizationRecommendationResourcesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let regionCode = regionCode {
                let regionCodeQueryItem = ClientRuntime.URLQueryItem(name: "regionCode".urlPercentEncoding(), value: Swift.String(regionCode).urlPercentEncoding())
                items.append(regionCodeQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let affectedAccountId = affectedAccountId {
                let affectedAccountIdQueryItem = ClientRuntime.URLQueryItem(name: "affectedAccountId".urlPercentEncoding(), value: Swift.String(affectedAccountId).urlPercentEncoding())
                items.append(affectedAccountIdQueryItem)
            }
            if let status = status {
                let statusQueryItem = ClientRuntime.URLQueryItem(name: "status".urlPercentEncoding(), value: Swift.String(status.rawValue).urlPercentEncoding())
                items.append(statusQueryItem)
            }
            return items
        }
    }
}

extension ListOrganizationRecommendationResourcesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let organizationRecommendationIdentifier = organizationRecommendationIdentifier else {
            return nil
        }
        return "/v1/organization-recommendations/\(organizationRecommendationIdentifier.urlPercentEncoding())/resources"
    }
}

public struct ListOrganizationRecommendationResourcesInput: Swift.Equatable {
    /// An account affected by this organization recommendation
    public var affectedAccountId: Swift.String?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The AWS Organization organization's Recommendation identifier
    /// This member is required.
    public var organizationRecommendationIdentifier: Swift.String?
    /// The AWS Region code of the resource
    public var regionCode: Swift.String?
    /// The status of the resource
    public var status: TrustedAdvisorClientTypes.ResourceStatus?

    public init(
        affectedAccountId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        organizationRecommendationIdentifier: Swift.String? = nil,
        regionCode: Swift.String? = nil,
        status: TrustedAdvisorClientTypes.ResourceStatus? = nil
    )
    {
        self.affectedAccountId = affectedAccountId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.organizationRecommendationIdentifier = organizationRecommendationIdentifier
        self.regionCode = regionCode
        self.status = status
    }
}

struct ListOrganizationRecommendationResourcesInputBody: Swift.Equatable {
}

extension ListOrganizationRecommendationResourcesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListOrganizationRecommendationResourcesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListOrganizationRecommendationResourcesOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.organizationRecommendationResourceSummaries = output.organizationRecommendationResourceSummaries
        } else {
            self.nextToken = nil
            self.organizationRecommendationResourceSummaries = nil
        }
    }
}

public struct ListOrganizationRecommendationResourcesOutput: Swift.Equatable {
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// A list of Recommendation Resources
    /// This member is required.
    public var organizationRecommendationResourceSummaries: [TrustedAdvisorClientTypes.OrganizationRecommendationResourceSummary]?

    public init(
        nextToken: Swift.String? = nil,
        organizationRecommendationResourceSummaries: [TrustedAdvisorClientTypes.OrganizationRecommendationResourceSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.organizationRecommendationResourceSummaries = organizationRecommendationResourceSummaries
    }
}

struct ListOrganizationRecommendationResourcesOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let organizationRecommendationResourceSummaries: [TrustedAdvisorClientTypes.OrganizationRecommendationResourceSummary]?
}

extension ListOrganizationRecommendationResourcesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case organizationRecommendationResourceSummaries
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let organizationRecommendationResourceSummariesContainer = try containerValues.decodeIfPresent([TrustedAdvisorClientTypes.OrganizationRecommendationResourceSummary?].self, forKey: .organizationRecommendationResourceSummaries)
        var organizationRecommendationResourceSummariesDecoded0:[TrustedAdvisorClientTypes.OrganizationRecommendationResourceSummary]? = nil
        if let organizationRecommendationResourceSummariesContainer = organizationRecommendationResourceSummariesContainer {
            organizationRecommendationResourceSummariesDecoded0 = [TrustedAdvisorClientTypes.OrganizationRecommendationResourceSummary]()
            for structure0 in organizationRecommendationResourceSummariesContainer {
                if let structure0 = structure0 {
                    organizationRecommendationResourceSummariesDecoded0?.append(structure0)
                }
            }
        }
        organizationRecommendationResourceSummaries = organizationRecommendationResourceSummariesDecoded0
    }
}

enum ListOrganizationRecommendationResourcesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListOrganizationRecommendationsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let beforeLastUpdatedAt = beforeLastUpdatedAt {
                let beforeLastUpdatedAtQueryItem = ClientRuntime.URLQueryItem(name: "beforeLastUpdatedAt".urlPercentEncoding(), value: Swift.String(TimestampFormatter(format: .dateTime).string(from: beforeLastUpdatedAt)).urlPercentEncoding())
                items.append(beforeLastUpdatedAtQueryItem)
            }
            if let pillar = pillar {
                let pillarQueryItem = ClientRuntime.URLQueryItem(name: "pillar".urlPercentEncoding(), value: Swift.String(pillar.rawValue).urlPercentEncoding())
                items.append(pillarQueryItem)
            }
            if let afterLastUpdatedAt = afterLastUpdatedAt {
                let afterLastUpdatedAtQueryItem = ClientRuntime.URLQueryItem(name: "afterLastUpdatedAt".urlPercentEncoding(), value: Swift.String(TimestampFormatter(format: .dateTime).string(from: afterLastUpdatedAt)).urlPercentEncoding())
                items.append(afterLastUpdatedAtQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let checkIdentifier = checkIdentifier {
                let checkIdentifierQueryItem = ClientRuntime.URLQueryItem(name: "checkIdentifier".urlPercentEncoding(), value: Swift.String(checkIdentifier).urlPercentEncoding())
                items.append(checkIdentifierQueryItem)
            }
            if let source = source {
                let sourceQueryItem = ClientRuntime.URLQueryItem(name: "source".urlPercentEncoding(), value: Swift.String(source.rawValue).urlPercentEncoding())
                items.append(sourceQueryItem)
            }
            if let type = type {
                let typeQueryItem = ClientRuntime.URLQueryItem(name: "type".urlPercentEncoding(), value: Swift.String(type.rawValue).urlPercentEncoding())
                items.append(typeQueryItem)
            }
            if let awsService = awsService {
                let awsServiceQueryItem = ClientRuntime.URLQueryItem(name: "awsService".urlPercentEncoding(), value: Swift.String(awsService).urlPercentEncoding())
                items.append(awsServiceQueryItem)
            }
            if let status = status {
                let statusQueryItem = ClientRuntime.URLQueryItem(name: "status".urlPercentEncoding(), value: Swift.String(status.rawValue).urlPercentEncoding())
                items.append(statusQueryItem)
            }
            return items
        }
    }
}

extension ListOrganizationRecommendationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/organization-recommendations"
    }
}

public struct ListOrganizationRecommendationsInput: Swift.Equatable {
    /// After the last update of the Recommendation
    public var afterLastUpdatedAt: ClientRuntime.Date?
    /// The aws service associated with the Recommendation
    public var awsService: Swift.String?
    /// Before the last update of the Recommendation
    public var beforeLastUpdatedAt: ClientRuntime.Date?
    /// The check identifier of the Recommendation
    public var checkIdentifier: Swift.String?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The pillar of the Recommendation
    public var pillar: TrustedAdvisorClientTypes.RecommendationPillar?
    /// The source of the Recommendation
    public var source: TrustedAdvisorClientTypes.RecommendationSource?
    /// The status of the Recommendation
    public var status: TrustedAdvisorClientTypes.RecommendationStatus?
    /// The type of the Recommendation
    public var type: TrustedAdvisorClientTypes.RecommendationType?

    public init(
        afterLastUpdatedAt: ClientRuntime.Date? = nil,
        awsService: Swift.String? = nil,
        beforeLastUpdatedAt: ClientRuntime.Date? = nil,
        checkIdentifier: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        pillar: TrustedAdvisorClientTypes.RecommendationPillar? = nil,
        source: TrustedAdvisorClientTypes.RecommendationSource? = nil,
        status: TrustedAdvisorClientTypes.RecommendationStatus? = nil,
        type: TrustedAdvisorClientTypes.RecommendationType? = nil
    )
    {
        self.afterLastUpdatedAt = afterLastUpdatedAt
        self.awsService = awsService
        self.beforeLastUpdatedAt = beforeLastUpdatedAt
        self.checkIdentifier = checkIdentifier
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.pillar = pillar
        self.source = source
        self.status = status
        self.type = type
    }
}

struct ListOrganizationRecommendationsInputBody: Swift.Equatable {
}

extension ListOrganizationRecommendationsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListOrganizationRecommendationsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListOrganizationRecommendationsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.organizationRecommendationSummaries = output.organizationRecommendationSummaries
        } else {
            self.nextToken = nil
            self.organizationRecommendationSummaries = nil
        }
    }
}

public struct ListOrganizationRecommendationsOutput: Swift.Equatable {
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The list of Recommendations
    /// This member is required.
    public var organizationRecommendationSummaries: [TrustedAdvisorClientTypes.OrganizationRecommendationSummary]?

    public init(
        nextToken: Swift.String? = nil,
        organizationRecommendationSummaries: [TrustedAdvisorClientTypes.OrganizationRecommendationSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.organizationRecommendationSummaries = organizationRecommendationSummaries
    }
}

struct ListOrganizationRecommendationsOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let organizationRecommendationSummaries: [TrustedAdvisorClientTypes.OrganizationRecommendationSummary]?
}

extension ListOrganizationRecommendationsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case organizationRecommendationSummaries
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let organizationRecommendationSummariesContainer = try containerValues.decodeIfPresent([TrustedAdvisorClientTypes.OrganizationRecommendationSummary?].self, forKey: .organizationRecommendationSummaries)
        var organizationRecommendationSummariesDecoded0:[TrustedAdvisorClientTypes.OrganizationRecommendationSummary]? = nil
        if let organizationRecommendationSummariesContainer = organizationRecommendationSummariesContainer {
            organizationRecommendationSummariesDecoded0 = [TrustedAdvisorClientTypes.OrganizationRecommendationSummary]()
            for structure0 in organizationRecommendationSummariesContainer {
                if let structure0 = structure0 {
                    organizationRecommendationSummariesDecoded0?.append(structure0)
                }
            }
        }
        organizationRecommendationSummaries = organizationRecommendationSummariesDecoded0
    }
}

enum ListOrganizationRecommendationsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListRecommendationResourcesInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let regionCode = regionCode {
                let regionCodeQueryItem = ClientRuntime.URLQueryItem(name: "regionCode".urlPercentEncoding(), value: Swift.String(regionCode).urlPercentEncoding())
                items.append(regionCodeQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let status = status {
                let statusQueryItem = ClientRuntime.URLQueryItem(name: "status".urlPercentEncoding(), value: Swift.String(status.rawValue).urlPercentEncoding())
                items.append(statusQueryItem)
            }
            return items
        }
    }
}

extension ListRecommendationResourcesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let recommendationIdentifier = recommendationIdentifier else {
            return nil
        }
        return "/v1/recommendations/\(recommendationIdentifier.urlPercentEncoding())/resources"
    }
}

public struct ListRecommendationResourcesInput: Swift.Equatable {
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The Recommendation identifier
    /// This member is required.
    public var recommendationIdentifier: Swift.String?
    /// The AWS Region code of the resource
    public var regionCode: Swift.String?
    /// The status of the resource
    public var status: TrustedAdvisorClientTypes.ResourceStatus?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        recommendationIdentifier: Swift.String? = nil,
        regionCode: Swift.String? = nil,
        status: TrustedAdvisorClientTypes.ResourceStatus? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.recommendationIdentifier = recommendationIdentifier
        self.regionCode = regionCode
        self.status = status
    }
}

struct ListRecommendationResourcesInputBody: Swift.Equatable {
}

extension ListRecommendationResourcesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListRecommendationResourcesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListRecommendationResourcesOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.recommendationResourceSummaries = output.recommendationResourceSummaries
        } else {
            self.nextToken = nil
            self.recommendationResourceSummaries = nil
        }
    }
}

public struct ListRecommendationResourcesOutput: Swift.Equatable {
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// A list of Recommendation Resources
    /// This member is required.
    public var recommendationResourceSummaries: [TrustedAdvisorClientTypes.RecommendationResourceSummary]?

    public init(
        nextToken: Swift.String? = nil,
        recommendationResourceSummaries: [TrustedAdvisorClientTypes.RecommendationResourceSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.recommendationResourceSummaries = recommendationResourceSummaries
    }
}

struct ListRecommendationResourcesOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let recommendationResourceSummaries: [TrustedAdvisorClientTypes.RecommendationResourceSummary]?
}

extension ListRecommendationResourcesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case recommendationResourceSummaries
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let recommendationResourceSummariesContainer = try containerValues.decodeIfPresent([TrustedAdvisorClientTypes.RecommendationResourceSummary?].self, forKey: .recommendationResourceSummaries)
        var recommendationResourceSummariesDecoded0:[TrustedAdvisorClientTypes.RecommendationResourceSummary]? = nil
        if let recommendationResourceSummariesContainer = recommendationResourceSummariesContainer {
            recommendationResourceSummariesDecoded0 = [TrustedAdvisorClientTypes.RecommendationResourceSummary]()
            for structure0 in recommendationResourceSummariesContainer {
                if let structure0 = structure0 {
                    recommendationResourceSummariesDecoded0?.append(structure0)
                }
            }
        }
        recommendationResourceSummaries = recommendationResourceSummariesDecoded0
    }
}

enum ListRecommendationResourcesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListRecommendationsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let beforeLastUpdatedAt = beforeLastUpdatedAt {
                let beforeLastUpdatedAtQueryItem = ClientRuntime.URLQueryItem(name: "beforeLastUpdatedAt".urlPercentEncoding(), value: Swift.String(TimestampFormatter(format: .dateTime).string(from: beforeLastUpdatedAt)).urlPercentEncoding())
                items.append(beforeLastUpdatedAtQueryItem)
            }
            if let pillar = pillar {
                let pillarQueryItem = ClientRuntime.URLQueryItem(name: "pillar".urlPercentEncoding(), value: Swift.String(pillar.rawValue).urlPercentEncoding())
                items.append(pillarQueryItem)
            }
            if let afterLastUpdatedAt = afterLastUpdatedAt {
                let afterLastUpdatedAtQueryItem = ClientRuntime.URLQueryItem(name: "afterLastUpdatedAt".urlPercentEncoding(), value: Swift.String(TimestampFormatter(format: .dateTime).string(from: afterLastUpdatedAt)).urlPercentEncoding())
                items.append(afterLastUpdatedAtQueryItem)
            }
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let checkIdentifier = checkIdentifier {
                let checkIdentifierQueryItem = ClientRuntime.URLQueryItem(name: "checkIdentifier".urlPercentEncoding(), value: Swift.String(checkIdentifier).urlPercentEncoding())
                items.append(checkIdentifierQueryItem)
            }
            if let source = source {
                let sourceQueryItem = ClientRuntime.URLQueryItem(name: "source".urlPercentEncoding(), value: Swift.String(source.rawValue).urlPercentEncoding())
                items.append(sourceQueryItem)
            }
            if let type = type {
                let typeQueryItem = ClientRuntime.URLQueryItem(name: "type".urlPercentEncoding(), value: Swift.String(type.rawValue).urlPercentEncoding())
                items.append(typeQueryItem)
            }
            if let awsService = awsService {
                let awsServiceQueryItem = ClientRuntime.URLQueryItem(name: "awsService".urlPercentEncoding(), value: Swift.String(awsService).urlPercentEncoding())
                items.append(awsServiceQueryItem)
            }
            if let status = status {
                let statusQueryItem = ClientRuntime.URLQueryItem(name: "status".urlPercentEncoding(), value: Swift.String(status.rawValue).urlPercentEncoding())
                items.append(statusQueryItem)
            }
            return items
        }
    }
}

extension ListRecommendationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/v1/recommendations"
    }
}

public struct ListRecommendationsInput: Swift.Equatable {
    /// After the last update of the Recommendation
    public var afterLastUpdatedAt: ClientRuntime.Date?
    /// The aws service associated with the Recommendation
    public var awsService: Swift.String?
    /// Before the last update of the Recommendation
    public var beforeLastUpdatedAt: ClientRuntime.Date?
    /// The check identifier of the Recommendation
    public var checkIdentifier: Swift.String?
    /// The maximum number of results to return per page.
    public var maxResults: Swift.Int?
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The pillar of the Recommendation
    public var pillar: TrustedAdvisorClientTypes.RecommendationPillar?
    /// The source of the Recommendation
    public var source: TrustedAdvisorClientTypes.RecommendationSource?
    /// The status of the Recommendation
    public var status: TrustedAdvisorClientTypes.RecommendationStatus?
    /// The type of the Recommendation
    public var type: TrustedAdvisorClientTypes.RecommendationType?

    public init(
        afterLastUpdatedAt: ClientRuntime.Date? = nil,
        awsService: Swift.String? = nil,
        beforeLastUpdatedAt: ClientRuntime.Date? = nil,
        checkIdentifier: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        pillar: TrustedAdvisorClientTypes.RecommendationPillar? = nil,
        source: TrustedAdvisorClientTypes.RecommendationSource? = nil,
        status: TrustedAdvisorClientTypes.RecommendationStatus? = nil,
        type: TrustedAdvisorClientTypes.RecommendationType? = nil
    )
    {
        self.afterLastUpdatedAt = afterLastUpdatedAt
        self.awsService = awsService
        self.beforeLastUpdatedAt = beforeLastUpdatedAt
        self.checkIdentifier = checkIdentifier
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.pillar = pillar
        self.source = source
        self.status = status
        self.type = type
    }
}

struct ListRecommendationsInputBody: Swift.Equatable {
}

extension ListRecommendationsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListRecommendationsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListRecommendationsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.recommendationSummaries = output.recommendationSummaries
        } else {
            self.nextToken = nil
            self.recommendationSummaries = nil
        }
    }
}

public struct ListRecommendationsOutput: Swift.Equatable {
    /// The token for the next set of results. Use the value returned in the previous response in the next request to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The list of Recommendations
    /// This member is required.
    public var recommendationSummaries: [TrustedAdvisorClientTypes.RecommendationSummary]?

    public init(
        nextToken: Swift.String? = nil,
        recommendationSummaries: [TrustedAdvisorClientTypes.RecommendationSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.recommendationSummaries = recommendationSummaries
    }
}

struct ListRecommendationsOutputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let recommendationSummaries: [TrustedAdvisorClientTypes.RecommendationSummary]?
}

extension ListRecommendationsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case recommendationSummaries
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let recommendationSummariesContainer = try containerValues.decodeIfPresent([TrustedAdvisorClientTypes.RecommendationSummary?].self, forKey: .recommendationSummaries)
        var recommendationSummariesDecoded0:[TrustedAdvisorClientTypes.RecommendationSummary]? = nil
        if let recommendationSummariesContainer = recommendationSummariesContainer {
            recommendationSummariesDecoded0 = [TrustedAdvisorClientTypes.RecommendationSummary]()
            for structure0 in recommendationSummariesContainer {
                if let structure0 = structure0 {
                    recommendationSummariesDecoded0?.append(structure0)
                }
            }
        }
        recommendationSummaries = recommendationSummariesDecoded0
    }
}

enum ListRecommendationsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension TrustedAdvisorClientTypes.OrganizationRecommendation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case awsServices
        case checkArn
        case createdAt
        case createdBy
        case description
        case id
        case lastUpdatedAt
        case lifecycleStage
        case name
        case pillarSpecificAggregates
        case pillars
        case resolvedAt
        case resourcesAggregates
        case source
        case status
        case type
        case updateReason
        case updateReasonCode
        case updatedOnBehalfOf
        case updatedOnBehalfOfJobTitle
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let awsServices = awsServices {
            var awsServicesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .awsServices)
            for recommendationawsservice0 in awsServices {
                try awsServicesContainer.encode(recommendationawsservice0)
            }
        }
        if let checkArn = self.checkArn {
            try encodeContainer.encode(checkArn, forKey: .checkArn)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .dateTime, forKey: .createdAt)
        }
        if let createdBy = self.createdBy {
            try encodeContainer.encode(createdBy, forKey: .createdBy)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let lastUpdatedAt = self.lastUpdatedAt {
            try encodeContainer.encodeTimestamp(lastUpdatedAt, format: .dateTime, forKey: .lastUpdatedAt)
        }
        if let lifecycleStage = self.lifecycleStage {
            try encodeContainer.encode(lifecycleStage.rawValue, forKey: .lifecycleStage)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let pillarSpecificAggregates = self.pillarSpecificAggregates {
            try encodeContainer.encode(pillarSpecificAggregates, forKey: .pillarSpecificAggregates)
        }
        if let pillars = pillars {
            var pillarsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .pillars)
            for recommendationpillar0 in pillars {
                try pillarsContainer.encode(recommendationpillar0.rawValue)
            }
        }
        if let resolvedAt = self.resolvedAt {
            try encodeContainer.encodeTimestamp(resolvedAt, format: .dateTime, forKey: .resolvedAt)
        }
        if let resourcesAggregates = self.resourcesAggregates {
            try encodeContainer.encode(resourcesAggregates, forKey: .resourcesAggregates)
        }
        if let source = self.source {
            try encodeContainer.encode(source.rawValue, forKey: .source)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let updateReason = self.updateReason {
            try encodeContainer.encode(updateReason, forKey: .updateReason)
        }
        if let updateReasonCode = self.updateReasonCode {
            try encodeContainer.encode(updateReasonCode.rawValue, forKey: .updateReasonCode)
        }
        if let updatedOnBehalfOf = self.updatedOnBehalfOf {
            try encodeContainer.encode(updatedOnBehalfOf, forKey: .updatedOnBehalfOf)
        }
        if let updatedOnBehalfOfJobTitle = self.updatedOnBehalfOfJobTitle {
            try encodeContainer.encode(updatedOnBehalfOfJobTitle, forKey: .updatedOnBehalfOfJobTitle)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let typeDecoded = try containerValues.decodeIfPresent(TrustedAdvisorClientTypes.RecommendationType.self, forKey: .type)
        type = typeDecoded
        let checkArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .checkArn)
        checkArn = checkArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(TrustedAdvisorClientTypes.RecommendationStatus.self, forKey: .status)
        status = statusDecoded
        let lifecycleStageDecoded = try containerValues.decodeIfPresent(TrustedAdvisorClientTypes.RecommendationLifecycleStage.self, forKey: .lifecycleStage)
        lifecycleStage = lifecycleStageDecoded
        let pillarsContainer = try containerValues.decodeIfPresent([TrustedAdvisorClientTypes.RecommendationPillar?].self, forKey: .pillars)
        var pillarsDecoded0:[TrustedAdvisorClientTypes.RecommendationPillar]? = nil
        if let pillarsContainer = pillarsContainer {
            pillarsDecoded0 = [TrustedAdvisorClientTypes.RecommendationPillar]()
            for enum0 in pillarsContainer {
                if let enum0 = enum0 {
                    pillarsDecoded0?.append(enum0)
                }
            }
        }
        pillars = pillarsDecoded0
        let sourceDecoded = try containerValues.decodeIfPresent(TrustedAdvisorClientTypes.RecommendationSource.self, forKey: .source)
        source = sourceDecoded
        let awsServicesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .awsServices)
        var awsServicesDecoded0:[Swift.String]? = nil
        if let awsServicesContainer = awsServicesContainer {
            awsServicesDecoded0 = [Swift.String]()
            for string0 in awsServicesContainer {
                if let string0 = string0 {
                    awsServicesDecoded0?.append(string0)
                }
            }
        }
        awsServices = awsServicesDecoded0
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let resourcesAggregatesDecoded = try containerValues.decodeIfPresent(TrustedAdvisorClientTypes.RecommendationResourcesAggregates.self, forKey: .resourcesAggregates)
        resourcesAggregates = resourcesAggregatesDecoded
        let pillarSpecificAggregatesDecoded = try containerValues.decodeIfPresent(TrustedAdvisorClientTypes.RecommendationPillarSpecificAggregates.self, forKey: .pillarSpecificAggregates)
        pillarSpecificAggregates = pillarSpecificAggregatesDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let updatedOnBehalfOfDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .updatedOnBehalfOf)
        updatedOnBehalfOf = updatedOnBehalfOfDecoded
        let updatedOnBehalfOfJobTitleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .updatedOnBehalfOfJobTitle)
        updatedOnBehalfOfJobTitle = updatedOnBehalfOfJobTitleDecoded
        let updateReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .updateReason)
        updateReason = updateReasonDecoded
        let updateReasonCodeDecoded = try containerValues.decodeIfPresent(TrustedAdvisorClientTypes.UpdateRecommendationLifecycleStageReasonCode.self, forKey: .updateReasonCode)
        updateReasonCode = updateReasonCodeDecoded
        let resolvedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .resolvedAt)
        resolvedAt = resolvedAtDecoded
    }
}

extension TrustedAdvisorClientTypes.OrganizationRecommendation: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "OrganizationRecommendation(arn: \(Swift.String(describing: arn)), awsServices: \(Swift.String(describing: awsServices)), checkArn: \(Swift.String(describing: checkArn)), createdAt: \(Swift.String(describing: createdAt)), createdBy: \(Swift.String(describing: createdBy)), description: \(Swift.String(describing: description)), id: \(Swift.String(describing: id)), lastUpdatedAt: \(Swift.String(describing: lastUpdatedAt)), lifecycleStage: \(Swift.String(describing: lifecycleStage)), name: \(Swift.String(describing: name)), pillarSpecificAggregates: \(Swift.String(describing: pillarSpecificAggregates)), pillars: \(Swift.String(describing: pillars)), resolvedAt: \(Swift.String(describing: resolvedAt)), resourcesAggregates: \(Swift.String(describing: resourcesAggregates)), source: \(Swift.String(describing: source)), status: \(Swift.String(describing: status)), type: \(Swift.String(describing: type)), updateReasonCode: \(Swift.String(describing: updateReasonCode)), updatedOnBehalfOf: \(Swift.String(describing: updatedOnBehalfOf)), updatedOnBehalfOfJobTitle: \(Swift.String(describing: updatedOnBehalfOfJobTitle)), updateReason: \"CONTENT_REDACTED\")"}
}

extension TrustedAdvisorClientTypes {
    /// A Recommendation for accounts within an Organization
    public struct OrganizationRecommendation: Swift.Equatable {
        /// The ARN of the Recommendation
        /// This member is required.
        public var arn: Swift.String?
        /// The AWS Services that the Recommendation applies to
        public var awsServices: [Swift.String]?
        /// The AWS Trusted Advisor Check ARN that relates to the Recommendation
        public var checkArn: Swift.String?
        /// When the Recommendation was created, if created by AWS Trusted Advisor Priority
        public var createdAt: ClientRuntime.Date?
        /// The creator, if created by AWS Trusted Advisor Priority
        public var createdBy: Swift.String?
        /// A description for AWS Trusted Advisor recommendations
        /// This member is required.
        public var description: Swift.String?
        /// The ID which identifies where the Recommendation was produced
        /// This member is required.
        public var id: Swift.String?
        /// When the Recommendation was last updated
        public var lastUpdatedAt: ClientRuntime.Date?
        /// The lifecycle stage from AWS Trusted Advisor Priority
        public var lifecycleStage: TrustedAdvisorClientTypes.RecommendationLifecycleStage?
        /// The name of the AWS Trusted Advisor Recommendation
        /// This member is required.
        public var name: Swift.String?
        /// The pillar aggregations for cost savings
        public var pillarSpecificAggregates: TrustedAdvisorClientTypes.RecommendationPillarSpecificAggregates?
        /// The Pillars that the Recommendation is optimizing
        /// This member is required.
        public var pillars: [TrustedAdvisorClientTypes.RecommendationPillar]?
        /// When the Recommendation was resolved
        public var resolvedAt: ClientRuntime.Date?
        /// An aggregation of all resources
        /// This member is required.
        public var resourcesAggregates: TrustedAdvisorClientTypes.RecommendationResourcesAggregates?
        /// The source of the Recommendation
        /// This member is required.
        public var source: TrustedAdvisorClientTypes.RecommendationSource?
        /// The status of the Recommendation
        /// This member is required.
        public var status: TrustedAdvisorClientTypes.RecommendationStatus?
        /// Whether the Recommendation was automated or generated by AWS Trusted Advisor Priority
        /// This member is required.
        public var type: TrustedAdvisorClientTypes.RecommendationType?
        /// Reason for the lifecycle stage change
        public var updateReason: Swift.String?
        /// Reason code for the lifecycle state change
        public var updateReasonCode: TrustedAdvisorClientTypes.UpdateRecommendationLifecycleStageReasonCode?
        /// The person on whose behalf a Technical Account Manager (TAM) updated the recommendation. This information is only available when a Technical Account Manager takes an action on a recommendation managed by AWS Trusted Advisor Priority
        public var updatedOnBehalfOf: Swift.String?
        /// The job title of the person on whose behalf a Technical Account Manager (TAM) updated the recommendation. This information is only available when a Technical Account Manager takes an action on a recommendation managed by AWS Trusted Advisor Priority
        public var updatedOnBehalfOfJobTitle: Swift.String?

        public init(
            arn: Swift.String? = nil,
            awsServices: [Swift.String]? = nil,
            checkArn: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            createdBy: Swift.String? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            lastUpdatedAt: ClientRuntime.Date? = nil,
            lifecycleStage: TrustedAdvisorClientTypes.RecommendationLifecycleStage? = nil,
            name: Swift.String? = nil,
            pillarSpecificAggregates: TrustedAdvisorClientTypes.RecommendationPillarSpecificAggregates? = nil,
            pillars: [TrustedAdvisorClientTypes.RecommendationPillar]? = nil,
            resolvedAt: ClientRuntime.Date? = nil,
            resourcesAggregates: TrustedAdvisorClientTypes.RecommendationResourcesAggregates? = nil,
            source: TrustedAdvisorClientTypes.RecommendationSource? = nil,
            status: TrustedAdvisorClientTypes.RecommendationStatus? = nil,
            type: TrustedAdvisorClientTypes.RecommendationType? = nil,
            updateReason: Swift.String? = nil,
            updateReasonCode: TrustedAdvisorClientTypes.UpdateRecommendationLifecycleStageReasonCode? = nil,
            updatedOnBehalfOf: Swift.String? = nil,
            updatedOnBehalfOfJobTitle: Swift.String? = nil
        )
        {
            self.arn = arn
            self.awsServices = awsServices
            self.checkArn = checkArn
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.description = description
            self.id = id
            self.lastUpdatedAt = lastUpdatedAt
            self.lifecycleStage = lifecycleStage
            self.name = name
            self.pillarSpecificAggregates = pillarSpecificAggregates
            self.pillars = pillars
            self.resolvedAt = resolvedAt
            self.resourcesAggregates = resourcesAggregates
            self.source = source
            self.status = status
            self.type = type
            self.updateReason = updateReason
            self.updateReasonCode = updateReasonCode
            self.updatedOnBehalfOf = updatedOnBehalfOf
            self.updatedOnBehalfOfJobTitle = updatedOnBehalfOfJobTitle
        }
    }

}

extension TrustedAdvisorClientTypes.OrganizationRecommendationResourceSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId
        case arn
        case awsResourceId
        case id
        case lastUpdatedAt
        case metadata
        case recommendationArn
        case regionCode
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let awsResourceId = self.awsResourceId {
            try encodeContainer.encode(awsResourceId, forKey: .awsResourceId)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let lastUpdatedAt = self.lastUpdatedAt {
            try encodeContainer.encodeTimestamp(lastUpdatedAt, format: .dateTime, forKey: .lastUpdatedAt)
        }
        if let metadata = metadata {
            var metadataContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .metadata)
            for (dictKey0, stringMap0) in metadata {
                try metadataContainer.encode(stringMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let recommendationArn = self.recommendationArn {
            try encodeContainer.encode(recommendationArn, forKey: .recommendationArn)
        }
        if let regionCode = self.regionCode {
            try encodeContainer.encode(regionCode, forKey: .regionCode)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let awsResourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsResourceId)
        awsResourceId = awsResourceIdDecoded
        let regionCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .regionCode)
        regionCode = regionCodeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(TrustedAdvisorClientTypes.ResourceStatus.self, forKey: .status)
        status = statusDecoded
        let metadataContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .metadata)
        var metadataDecoded0: [Swift.String:Swift.String]? = nil
        if let metadataContainer = metadataContainer {
            metadataDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in metadataContainer {
                if let string0 = string0 {
                    metadataDecoded0?[key0] = string0
                }
            }
        }
        metadata = metadataDecoded0
        let lastUpdatedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let recommendationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recommendationArn)
        recommendationArn = recommendationArnDecoded
    }
}

extension TrustedAdvisorClientTypes {
    /// Organization Recommendation Resource Summary
    public struct OrganizationRecommendationResourceSummary: Swift.Equatable {
        /// The AWS account ID
        public var accountId: Swift.String?
        /// The ARN of the Recommendation Resource
        /// This member is required.
        public var arn: Swift.String?
        /// The AWS resource identifier
        /// This member is required.
        public var awsResourceId: Swift.String?
        /// The ID of the Recommendation Resource
        /// This member is required.
        public var id: Swift.String?
        /// When the Recommendation Resource was last updated
        /// This member is required.
        public var lastUpdatedAt: ClientRuntime.Date?
        /// Metadata associated with the Recommendation Resource
        /// This member is required.
        public var metadata: [Swift.String:Swift.String]?
        /// The Recommendation ARN
        /// This member is required.
        public var recommendationArn: Swift.String?
        /// The AWS Region code that the Recommendation Resource is in
        /// This member is required.
        public var regionCode: Swift.String?
        /// The current status of the Recommendation Resource
        /// This member is required.
        public var status: TrustedAdvisorClientTypes.ResourceStatus?

        public init(
            accountId: Swift.String? = nil,
            arn: Swift.String? = nil,
            awsResourceId: Swift.String? = nil,
            id: Swift.String? = nil,
            lastUpdatedAt: ClientRuntime.Date? = nil,
            metadata: [Swift.String:Swift.String]? = nil,
            recommendationArn: Swift.String? = nil,
            regionCode: Swift.String? = nil,
            status: TrustedAdvisorClientTypes.ResourceStatus? = nil
        )
        {
            self.accountId = accountId
            self.arn = arn
            self.awsResourceId = awsResourceId
            self.id = id
            self.lastUpdatedAt = lastUpdatedAt
            self.metadata = metadata
            self.recommendationArn = recommendationArn
            self.regionCode = regionCode
            self.status = status
        }
    }

}

extension TrustedAdvisorClientTypes.OrganizationRecommendationSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case awsServices
        case checkArn
        case createdAt
        case id
        case lastUpdatedAt
        case lifecycleStage
        case name
        case pillarSpecificAggregates
        case pillars
        case resourcesAggregates
        case source
        case status
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let awsServices = awsServices {
            var awsServicesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .awsServices)
            for recommendationawsservice0 in awsServices {
                try awsServicesContainer.encode(recommendationawsservice0)
            }
        }
        if let checkArn = self.checkArn {
            try encodeContainer.encode(checkArn, forKey: .checkArn)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .dateTime, forKey: .createdAt)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let lastUpdatedAt = self.lastUpdatedAt {
            try encodeContainer.encodeTimestamp(lastUpdatedAt, format: .dateTime, forKey: .lastUpdatedAt)
        }
        if let lifecycleStage = self.lifecycleStage {
            try encodeContainer.encode(lifecycleStage.rawValue, forKey: .lifecycleStage)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let pillarSpecificAggregates = self.pillarSpecificAggregates {
            try encodeContainer.encode(pillarSpecificAggregates, forKey: .pillarSpecificAggregates)
        }
        if let pillars = pillars {
            var pillarsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .pillars)
            for recommendationpillar0 in pillars {
                try pillarsContainer.encode(recommendationpillar0.rawValue)
            }
        }
        if let resourcesAggregates = self.resourcesAggregates {
            try encodeContainer.encode(resourcesAggregates, forKey: .resourcesAggregates)
        }
        if let source = self.source {
            try encodeContainer.encode(source.rawValue, forKey: .source)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let typeDecoded = try containerValues.decodeIfPresent(TrustedAdvisorClientTypes.RecommendationType.self, forKey: .type)
        type = typeDecoded
        let checkArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .checkArn)
        checkArn = checkArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(TrustedAdvisorClientTypes.RecommendationStatus.self, forKey: .status)
        status = statusDecoded
        let lifecycleStageDecoded = try containerValues.decodeIfPresent(TrustedAdvisorClientTypes.RecommendationLifecycleStage.self, forKey: .lifecycleStage)
        lifecycleStage = lifecycleStageDecoded
        let pillarsContainer = try containerValues.decodeIfPresent([TrustedAdvisorClientTypes.RecommendationPillar?].self, forKey: .pillars)
        var pillarsDecoded0:[TrustedAdvisorClientTypes.RecommendationPillar]? = nil
        if let pillarsContainer = pillarsContainer {
            pillarsDecoded0 = [TrustedAdvisorClientTypes.RecommendationPillar]()
            for enum0 in pillarsContainer {
                if let enum0 = enum0 {
                    pillarsDecoded0?.append(enum0)
                }
            }
        }
        pillars = pillarsDecoded0
        let sourceDecoded = try containerValues.decodeIfPresent(TrustedAdvisorClientTypes.RecommendationSource.self, forKey: .source)
        source = sourceDecoded
        let awsServicesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .awsServices)
        var awsServicesDecoded0:[Swift.String]? = nil
        if let awsServicesContainer = awsServicesContainer {
            awsServicesDecoded0 = [Swift.String]()
            for string0 in awsServicesContainer {
                if let string0 = string0 {
                    awsServicesDecoded0?.append(string0)
                }
            }
        }
        awsServices = awsServicesDecoded0
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let resourcesAggregatesDecoded = try containerValues.decodeIfPresent(TrustedAdvisorClientTypes.RecommendationResourcesAggregates.self, forKey: .resourcesAggregates)
        resourcesAggregates = resourcesAggregatesDecoded
        let pillarSpecificAggregatesDecoded = try containerValues.decodeIfPresent(TrustedAdvisorClientTypes.RecommendationPillarSpecificAggregates.self, forKey: .pillarSpecificAggregates)
        pillarSpecificAggregates = pillarSpecificAggregatesDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension TrustedAdvisorClientTypes {
    /// Summary of recommendation for accounts within an Organization
    public struct OrganizationRecommendationSummary: Swift.Equatable {
        /// The ARN of the Recommendation
        /// This member is required.
        public var arn: Swift.String?
        /// The AWS Services that the Recommendation applies to
        public var awsServices: [Swift.String]?
        /// The AWS Trusted Advisor Check ARN that relates to the Recommendation
        public var checkArn: Swift.String?
        /// When the Recommendation was created, if created by AWS Trusted Advisor Priority
        public var createdAt: ClientRuntime.Date?
        /// The ID which identifies where the Recommendation was produced
        /// This member is required.
        public var id: Swift.String?
        /// When the Recommendation was last updated
        public var lastUpdatedAt: ClientRuntime.Date?
        /// The lifecycle stage from AWS Trusted Advisor Priority
        public var lifecycleStage: TrustedAdvisorClientTypes.RecommendationLifecycleStage?
        /// The name of the AWS Trusted Advisor Recommendation
        /// This member is required.
        public var name: Swift.String?
        /// The pillar aggregations for cost savings
        public var pillarSpecificAggregates: TrustedAdvisorClientTypes.RecommendationPillarSpecificAggregates?
        /// The Pillars that the Recommendation is optimizing
        /// This member is required.
        public var pillars: [TrustedAdvisorClientTypes.RecommendationPillar]?
        /// An aggregation of all resources
        /// This member is required.
        public var resourcesAggregates: TrustedAdvisorClientTypes.RecommendationResourcesAggregates?
        /// The source of the Recommendation
        /// This member is required.
        public var source: TrustedAdvisorClientTypes.RecommendationSource?
        /// The status of the Recommendation
        /// This member is required.
        public var status: TrustedAdvisorClientTypes.RecommendationStatus?
        /// Whether the Recommendation was automated or generated by AWS Trusted Advisor Priority
        /// This member is required.
        public var type: TrustedAdvisorClientTypes.RecommendationType?

        public init(
            arn: Swift.String? = nil,
            awsServices: [Swift.String]? = nil,
            checkArn: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            id: Swift.String? = nil,
            lastUpdatedAt: ClientRuntime.Date? = nil,
            lifecycleStage: TrustedAdvisorClientTypes.RecommendationLifecycleStage? = nil,
            name: Swift.String? = nil,
            pillarSpecificAggregates: TrustedAdvisorClientTypes.RecommendationPillarSpecificAggregates? = nil,
            pillars: [TrustedAdvisorClientTypes.RecommendationPillar]? = nil,
            resourcesAggregates: TrustedAdvisorClientTypes.RecommendationResourcesAggregates? = nil,
            source: TrustedAdvisorClientTypes.RecommendationSource? = nil,
            status: TrustedAdvisorClientTypes.RecommendationStatus? = nil,
            type: TrustedAdvisorClientTypes.RecommendationType? = nil
        )
        {
            self.arn = arn
            self.awsServices = awsServices
            self.checkArn = checkArn
            self.createdAt = createdAt
            self.id = id
            self.lastUpdatedAt = lastUpdatedAt
            self.lifecycleStage = lifecycleStage
            self.name = name
            self.pillarSpecificAggregates = pillarSpecificAggregates
            self.pillars = pillars
            self.resourcesAggregates = resourcesAggregates
            self.source = source
            self.status = status
            self.type = type
        }
    }

}

extension TrustedAdvisorClientTypes.Recommendation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case awsServices
        case checkArn
        case createdAt
        case createdBy
        case description
        case id
        case lastUpdatedAt
        case lifecycleStage
        case name
        case pillarSpecificAggregates
        case pillars
        case resolvedAt
        case resourcesAggregates
        case source
        case status
        case type
        case updateReason
        case updateReasonCode
        case updatedOnBehalfOf
        case updatedOnBehalfOfJobTitle
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let awsServices = awsServices {
            var awsServicesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .awsServices)
            for recommendationawsservice0 in awsServices {
                try awsServicesContainer.encode(recommendationawsservice0)
            }
        }
        if let checkArn = self.checkArn {
            try encodeContainer.encode(checkArn, forKey: .checkArn)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .dateTime, forKey: .createdAt)
        }
        if let createdBy = self.createdBy {
            try encodeContainer.encode(createdBy, forKey: .createdBy)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let lastUpdatedAt = self.lastUpdatedAt {
            try encodeContainer.encodeTimestamp(lastUpdatedAt, format: .dateTime, forKey: .lastUpdatedAt)
        }
        if let lifecycleStage = self.lifecycleStage {
            try encodeContainer.encode(lifecycleStage.rawValue, forKey: .lifecycleStage)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let pillarSpecificAggregates = self.pillarSpecificAggregates {
            try encodeContainer.encode(pillarSpecificAggregates, forKey: .pillarSpecificAggregates)
        }
        if let pillars = pillars {
            var pillarsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .pillars)
            for recommendationpillar0 in pillars {
                try pillarsContainer.encode(recommendationpillar0.rawValue)
            }
        }
        if let resolvedAt = self.resolvedAt {
            try encodeContainer.encodeTimestamp(resolvedAt, format: .dateTime, forKey: .resolvedAt)
        }
        if let resourcesAggregates = self.resourcesAggregates {
            try encodeContainer.encode(resourcesAggregates, forKey: .resourcesAggregates)
        }
        if let source = self.source {
            try encodeContainer.encode(source.rawValue, forKey: .source)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
        if let updateReason = self.updateReason {
            try encodeContainer.encode(updateReason, forKey: .updateReason)
        }
        if let updateReasonCode = self.updateReasonCode {
            try encodeContainer.encode(updateReasonCode.rawValue, forKey: .updateReasonCode)
        }
        if let updatedOnBehalfOf = self.updatedOnBehalfOf {
            try encodeContainer.encode(updatedOnBehalfOf, forKey: .updatedOnBehalfOf)
        }
        if let updatedOnBehalfOfJobTitle = self.updatedOnBehalfOfJobTitle {
            try encodeContainer.encode(updatedOnBehalfOfJobTitle, forKey: .updatedOnBehalfOfJobTitle)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let typeDecoded = try containerValues.decodeIfPresent(TrustedAdvisorClientTypes.RecommendationType.self, forKey: .type)
        type = typeDecoded
        let checkArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .checkArn)
        checkArn = checkArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(TrustedAdvisorClientTypes.RecommendationStatus.self, forKey: .status)
        status = statusDecoded
        let lifecycleStageDecoded = try containerValues.decodeIfPresent(TrustedAdvisorClientTypes.RecommendationLifecycleStage.self, forKey: .lifecycleStage)
        lifecycleStage = lifecycleStageDecoded
        let pillarsContainer = try containerValues.decodeIfPresent([TrustedAdvisorClientTypes.RecommendationPillar?].self, forKey: .pillars)
        var pillarsDecoded0:[TrustedAdvisorClientTypes.RecommendationPillar]? = nil
        if let pillarsContainer = pillarsContainer {
            pillarsDecoded0 = [TrustedAdvisorClientTypes.RecommendationPillar]()
            for enum0 in pillarsContainer {
                if let enum0 = enum0 {
                    pillarsDecoded0?.append(enum0)
                }
            }
        }
        pillars = pillarsDecoded0
        let sourceDecoded = try containerValues.decodeIfPresent(TrustedAdvisorClientTypes.RecommendationSource.self, forKey: .source)
        source = sourceDecoded
        let awsServicesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .awsServices)
        var awsServicesDecoded0:[Swift.String]? = nil
        if let awsServicesContainer = awsServicesContainer {
            awsServicesDecoded0 = [Swift.String]()
            for string0 in awsServicesContainer {
                if let string0 = string0 {
                    awsServicesDecoded0?.append(string0)
                }
            }
        }
        awsServices = awsServicesDecoded0
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let resourcesAggregatesDecoded = try containerValues.decodeIfPresent(TrustedAdvisorClientTypes.RecommendationResourcesAggregates.self, forKey: .resourcesAggregates)
        resourcesAggregates = resourcesAggregatesDecoded
        let pillarSpecificAggregatesDecoded = try containerValues.decodeIfPresent(TrustedAdvisorClientTypes.RecommendationPillarSpecificAggregates.self, forKey: .pillarSpecificAggregates)
        pillarSpecificAggregates = pillarSpecificAggregatesDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let createdByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdBy)
        createdBy = createdByDecoded
        let updatedOnBehalfOfDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .updatedOnBehalfOf)
        updatedOnBehalfOf = updatedOnBehalfOfDecoded
        let updatedOnBehalfOfJobTitleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .updatedOnBehalfOfJobTitle)
        updatedOnBehalfOfJobTitle = updatedOnBehalfOfJobTitleDecoded
        let updateReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .updateReason)
        updateReason = updateReasonDecoded
        let updateReasonCodeDecoded = try containerValues.decodeIfPresent(TrustedAdvisorClientTypes.UpdateRecommendationLifecycleStageReasonCode.self, forKey: .updateReasonCode)
        updateReasonCode = updateReasonCodeDecoded
        let resolvedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .resolvedAt)
        resolvedAt = resolvedAtDecoded
    }
}

extension TrustedAdvisorClientTypes.Recommendation: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Recommendation(arn: \(Swift.String(describing: arn)), awsServices: \(Swift.String(describing: awsServices)), checkArn: \(Swift.String(describing: checkArn)), createdAt: \(Swift.String(describing: createdAt)), createdBy: \(Swift.String(describing: createdBy)), description: \(Swift.String(describing: description)), id: \(Swift.String(describing: id)), lastUpdatedAt: \(Swift.String(describing: lastUpdatedAt)), lifecycleStage: \(Swift.String(describing: lifecycleStage)), name: \(Swift.String(describing: name)), pillarSpecificAggregates: \(Swift.String(describing: pillarSpecificAggregates)), pillars: \(Swift.String(describing: pillars)), resolvedAt: \(Swift.String(describing: resolvedAt)), resourcesAggregates: \(Swift.String(describing: resourcesAggregates)), source: \(Swift.String(describing: source)), status: \(Swift.String(describing: status)), type: \(Swift.String(describing: type)), updateReasonCode: \(Swift.String(describing: updateReasonCode)), updatedOnBehalfOf: \(Swift.String(describing: updatedOnBehalfOf)), updatedOnBehalfOfJobTitle: \(Swift.String(describing: updatedOnBehalfOfJobTitle)), updateReason: \"CONTENT_REDACTED\")"}
}

extension TrustedAdvisorClientTypes {
    /// A Recommendation for an Account
    public struct Recommendation: Swift.Equatable {
        /// The ARN of the Recommendation
        /// This member is required.
        public var arn: Swift.String?
        /// The AWS Services that the Recommendation applies to
        public var awsServices: [Swift.String]?
        /// The AWS Trusted Advisor Check ARN that relates to the Recommendation
        public var checkArn: Swift.String?
        /// When the Recommendation was created, if created by AWS Trusted Advisor Priority
        public var createdAt: ClientRuntime.Date?
        /// The creator, if created by AWS Trusted Advisor Priority
        public var createdBy: Swift.String?
        /// A description for AWS Trusted Advisor recommendations
        /// This member is required.
        public var description: Swift.String?
        /// The ID which identifies where the Recommendation was produced
        /// This member is required.
        public var id: Swift.String?
        /// When the Recommendation was last updated
        public var lastUpdatedAt: ClientRuntime.Date?
        /// The lifecycle stage from AWS Trusted Advisor Priority
        public var lifecycleStage: TrustedAdvisorClientTypes.RecommendationLifecycleStage?
        /// The name of the AWS Trusted Advisor Recommendation
        /// This member is required.
        public var name: Swift.String?
        /// The pillar aggregations for cost savings
        public var pillarSpecificAggregates: TrustedAdvisorClientTypes.RecommendationPillarSpecificAggregates?
        /// The Pillars that the Recommendation is optimizing
        /// This member is required.
        public var pillars: [TrustedAdvisorClientTypes.RecommendationPillar]?
        /// When the Recommendation was resolved
        public var resolvedAt: ClientRuntime.Date?
        /// An aggregation of all resources
        /// This member is required.
        public var resourcesAggregates: TrustedAdvisorClientTypes.RecommendationResourcesAggregates?
        /// The source of the Recommendation
        /// This member is required.
        public var source: TrustedAdvisorClientTypes.RecommendationSource?
        /// The status of the Recommendation
        /// This member is required.
        public var status: TrustedAdvisorClientTypes.RecommendationStatus?
        /// Whether the Recommendation was automated or generated by AWS Trusted Advisor Priority
        /// This member is required.
        public var type: TrustedAdvisorClientTypes.RecommendationType?
        /// Reason for the lifecycle stage change
        public var updateReason: Swift.String?
        /// Reason code for the lifecycle state change
        public var updateReasonCode: TrustedAdvisorClientTypes.UpdateRecommendationLifecycleStageReasonCode?
        /// The person on whose behalf a Technical Account Manager (TAM) updated the recommendation. This information is only available when a Technical Account Manager takes an action on a recommendation managed by AWS Trusted Advisor Priority
        public var updatedOnBehalfOf: Swift.String?
        /// The job title of the person on whose behalf a Technical Account Manager (TAM) updated the recommendation. This information is only available when a Technical Account Manager takes an action on a recommendation managed by AWS Trusted Advisor Priority
        public var updatedOnBehalfOfJobTitle: Swift.String?

        public init(
            arn: Swift.String? = nil,
            awsServices: [Swift.String]? = nil,
            checkArn: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            createdBy: Swift.String? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            lastUpdatedAt: ClientRuntime.Date? = nil,
            lifecycleStage: TrustedAdvisorClientTypes.RecommendationLifecycleStage? = nil,
            name: Swift.String? = nil,
            pillarSpecificAggregates: TrustedAdvisorClientTypes.RecommendationPillarSpecificAggregates? = nil,
            pillars: [TrustedAdvisorClientTypes.RecommendationPillar]? = nil,
            resolvedAt: ClientRuntime.Date? = nil,
            resourcesAggregates: TrustedAdvisorClientTypes.RecommendationResourcesAggregates? = nil,
            source: TrustedAdvisorClientTypes.RecommendationSource? = nil,
            status: TrustedAdvisorClientTypes.RecommendationStatus? = nil,
            type: TrustedAdvisorClientTypes.RecommendationType? = nil,
            updateReason: Swift.String? = nil,
            updateReasonCode: TrustedAdvisorClientTypes.UpdateRecommendationLifecycleStageReasonCode? = nil,
            updatedOnBehalfOf: Swift.String? = nil,
            updatedOnBehalfOfJobTitle: Swift.String? = nil
        )
        {
            self.arn = arn
            self.awsServices = awsServices
            self.checkArn = checkArn
            self.createdAt = createdAt
            self.createdBy = createdBy
            self.description = description
            self.id = id
            self.lastUpdatedAt = lastUpdatedAt
            self.lifecycleStage = lifecycleStage
            self.name = name
            self.pillarSpecificAggregates = pillarSpecificAggregates
            self.pillars = pillars
            self.resolvedAt = resolvedAt
            self.resourcesAggregates = resourcesAggregates
            self.source = source
            self.status = status
            self.type = type
            self.updateReason = updateReason
            self.updateReasonCode = updateReasonCode
            self.updatedOnBehalfOf = updatedOnBehalfOf
            self.updatedOnBehalfOfJobTitle = updatedOnBehalfOfJobTitle
        }
    }

}

extension TrustedAdvisorClientTypes.RecommendationCostOptimizingAggregates: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case estimatedMonthlySavings
        case estimatedPercentMonthlySavings
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let estimatedMonthlySavings = self.estimatedMonthlySavings {
            try encodeContainer.encode(estimatedMonthlySavings, forKey: .estimatedMonthlySavings)
        }
        if let estimatedPercentMonthlySavings = self.estimatedPercentMonthlySavings {
            try encodeContainer.encode(estimatedPercentMonthlySavings, forKey: .estimatedPercentMonthlySavings)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let estimatedMonthlySavingsDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .estimatedMonthlySavings)
        estimatedMonthlySavings = estimatedMonthlySavingsDecoded
        let estimatedPercentMonthlySavingsDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .estimatedPercentMonthlySavings)
        estimatedPercentMonthlySavings = estimatedPercentMonthlySavingsDecoded
    }
}

extension TrustedAdvisorClientTypes {
    /// Cost optimizing aggregates for a Recommendation
    public struct RecommendationCostOptimizingAggregates: Swift.Equatable {
        /// The estimated monthly savings
        /// This member is required.
        public var estimatedMonthlySavings: Swift.Double?
        /// The estimated percently monthly savings
        /// This member is required.
        public var estimatedPercentMonthlySavings: Swift.Double?

        public init(
            estimatedMonthlySavings: Swift.Double? = nil,
            estimatedPercentMonthlySavings: Swift.Double? = nil
        )
        {
            self.estimatedMonthlySavings = estimatedMonthlySavings
            self.estimatedPercentMonthlySavings = estimatedPercentMonthlySavings
        }
    }

}

extension TrustedAdvisorClientTypes {
    public enum RecommendationLanguage: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case bahasaIndonesia
        case brazilianPortuguese
        case chinese
        case english
        case french
        case german
        case italian
        case japanese
        case korean
        case spanish
        case traditionalChinese
        case sdkUnknown(Swift.String)

        public static var allCases: [RecommendationLanguage] {
            return [
                .bahasaIndonesia,
                .brazilianPortuguese,
                .chinese,
                .english,
                .french,
                .german,
                .italian,
                .japanese,
                .korean,
                .spanish,
                .traditionalChinese,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .bahasaIndonesia: return "id"
            case .brazilianPortuguese: return "pt_BR"
            case .chinese: return "zh"
            case .english: return "en"
            case .french: return "fr"
            case .german: return "de"
            case .italian: return "it"
            case .japanese: return "ja"
            case .korean: return "ko"
            case .spanish: return "es"
            case .traditionalChinese: return "zh_TW"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RecommendationLanguage(rawValue: rawValue) ?? RecommendationLanguage.sdkUnknown(rawValue)
        }
    }
}

extension TrustedAdvisorClientTypes {
    public enum RecommendationLifecycleStage: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case dismissed
        case inProgress
        case pendingResponse
        case resolved
        case sdkUnknown(Swift.String)

        public static var allCases: [RecommendationLifecycleStage] {
            return [
                .dismissed,
                .inProgress,
                .pendingResponse,
                .resolved,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .dismissed: return "dismissed"
            case .inProgress: return "in_progress"
            case .pendingResponse: return "pending_response"
            case .resolved: return "resolved"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RecommendationLifecycleStage(rawValue: rawValue) ?? RecommendationLifecycleStage.sdkUnknown(rawValue)
        }
    }
}

extension TrustedAdvisorClientTypes {
    public enum RecommendationPillar: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case costOptimizing
        case faultTolerance
        case operationalExcellence
        case performance
        case security
        case serviceLimits
        case sdkUnknown(Swift.String)

        public static var allCases: [RecommendationPillar] {
            return [
                .costOptimizing,
                .faultTolerance,
                .operationalExcellence,
                .performance,
                .security,
                .serviceLimits,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .costOptimizing: return "cost_optimizing"
            case .faultTolerance: return "fault_tolerance"
            case .operationalExcellence: return "operational_excellence"
            case .performance: return "performance"
            case .security: return "security"
            case .serviceLimits: return "service_limits"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RecommendationPillar(rawValue: rawValue) ?? RecommendationPillar.sdkUnknown(rawValue)
        }
    }
}

extension TrustedAdvisorClientTypes.RecommendationPillarSpecificAggregates: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case costOptimizing
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let costOptimizing = self.costOptimizing {
            try encodeContainer.encode(costOptimizing, forKey: .costOptimizing)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let costOptimizingDecoded = try containerValues.decodeIfPresent(TrustedAdvisorClientTypes.RecommendationCostOptimizingAggregates.self, forKey: .costOptimizing)
        costOptimizing = costOptimizingDecoded
    }
}

extension TrustedAdvisorClientTypes {
    /// Recommendation pillar aggregates
    public struct RecommendationPillarSpecificAggregates: Swift.Equatable {
        /// Cost optimizing aggregates
        public var costOptimizing: TrustedAdvisorClientTypes.RecommendationCostOptimizingAggregates?

        public init(
            costOptimizing: TrustedAdvisorClientTypes.RecommendationCostOptimizingAggregates? = nil
        )
        {
            self.costOptimizing = costOptimizing
        }
    }

}

extension TrustedAdvisorClientTypes.RecommendationResourceSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case awsResourceId
        case id
        case lastUpdatedAt
        case metadata
        case recommendationArn
        case regionCode
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let awsResourceId = self.awsResourceId {
            try encodeContainer.encode(awsResourceId, forKey: .awsResourceId)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let lastUpdatedAt = self.lastUpdatedAt {
            try encodeContainer.encodeTimestamp(lastUpdatedAt, format: .dateTime, forKey: .lastUpdatedAt)
        }
        if let metadata = metadata {
            var metadataContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .metadata)
            for (dictKey0, stringMap0) in metadata {
                try metadataContainer.encode(stringMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let recommendationArn = self.recommendationArn {
            try encodeContainer.encode(recommendationArn, forKey: .recommendationArn)
        }
        if let regionCode = self.regionCode {
            try encodeContainer.encode(regionCode, forKey: .regionCode)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let awsResourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsResourceId)
        awsResourceId = awsResourceIdDecoded
        let regionCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .regionCode)
        regionCode = regionCodeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(TrustedAdvisorClientTypes.ResourceStatus.self, forKey: .status)
        status = statusDecoded
        let metadataContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .metadata)
        var metadataDecoded0: [Swift.String:Swift.String]? = nil
        if let metadataContainer = metadataContainer {
            metadataDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in metadataContainer {
                if let string0 = string0 {
                    metadataDecoded0?[key0] = string0
                }
            }
        }
        metadata = metadataDecoded0
        let lastUpdatedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
        let recommendationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recommendationArn)
        recommendationArn = recommendationArnDecoded
    }
}

extension TrustedAdvisorClientTypes {
    /// Summary of a Recommendation Resource
    public struct RecommendationResourceSummary: Swift.Equatable {
        /// The ARN of the Recommendation Resource
        /// This member is required.
        public var arn: Swift.String?
        /// The AWS resource identifier
        /// This member is required.
        public var awsResourceId: Swift.String?
        /// The ID of the Recommendation Resource
        /// This member is required.
        public var id: Swift.String?
        /// When the Recommendation Resource was last updated
        /// This member is required.
        public var lastUpdatedAt: ClientRuntime.Date?
        /// Metadata associated with the Recommendation Resource
        /// This member is required.
        public var metadata: [Swift.String:Swift.String]?
        /// The Recommendation ARN
        /// This member is required.
        public var recommendationArn: Swift.String?
        /// The AWS Region code that the Recommendation Resource is in
        /// This member is required.
        public var regionCode: Swift.String?
        /// The current status of the Recommendation Resource
        /// This member is required.
        public var status: TrustedAdvisorClientTypes.ResourceStatus?

        public init(
            arn: Swift.String? = nil,
            awsResourceId: Swift.String? = nil,
            id: Swift.String? = nil,
            lastUpdatedAt: ClientRuntime.Date? = nil,
            metadata: [Swift.String:Swift.String]? = nil,
            recommendationArn: Swift.String? = nil,
            regionCode: Swift.String? = nil,
            status: TrustedAdvisorClientTypes.ResourceStatus? = nil
        )
        {
            self.arn = arn
            self.awsResourceId = awsResourceId
            self.id = id
            self.lastUpdatedAt = lastUpdatedAt
            self.metadata = metadata
            self.recommendationArn = recommendationArn
            self.regionCode = regionCode
            self.status = status
        }
    }

}

extension TrustedAdvisorClientTypes.RecommendationResourcesAggregates: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case errorCount
        case okCount
        case warningCount
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let errorCount = self.errorCount {
            try encodeContainer.encode(errorCount, forKey: .errorCount)
        }
        if let okCount = self.okCount {
            try encodeContainer.encode(okCount, forKey: .okCount)
        }
        if let warningCount = self.warningCount {
            try encodeContainer.encode(warningCount, forKey: .warningCount)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let okCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .okCount)
        okCount = okCountDecoded
        let warningCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .warningCount)
        warningCount = warningCountDecoded
        let errorCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .errorCount)
        errorCount = errorCountDecoded
    }
}

extension TrustedAdvisorClientTypes {
    /// Aggregation of Recommendation Resources
    public struct RecommendationResourcesAggregates: Swift.Equatable {
        /// The number of AWS resources that were flagged to have errors according to the Trusted Advisor check
        /// This member is required.
        public var errorCount: Swift.Int?
        /// The number of AWS resources that were flagged to be OK according to the Trusted Advisor check
        /// This member is required.
        public var okCount: Swift.Int?
        /// The number of AWS resources that were flagged to have warning according to the Trusted Advisor check
        /// This member is required.
        public var warningCount: Swift.Int?

        public init(
            errorCount: Swift.Int? = nil,
            okCount: Swift.Int? = nil,
            warningCount: Swift.Int? = nil
        )
        {
            self.errorCount = errorCount
            self.okCount = okCount
            self.warningCount = warningCount
        }
    }

}

extension TrustedAdvisorClientTypes {
    public enum RecommendationSource: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case awsConfig
        case computeOptimizer
        case costExplorer
        case lse
        case manual
        case pse
        case rds
        case resilience
        case resilienceHub
        case securityHub
        case stir
        case taCheck
        case wellArchitected
        case sdkUnknown(Swift.String)

        public static var allCases: [RecommendationSource] {
            return [
                .awsConfig,
                .computeOptimizer,
                .costExplorer,
                .lse,
                .manual,
                .pse,
                .rds,
                .resilience,
                .resilienceHub,
                .securityHub,
                .stir,
                .taCheck,
                .wellArchitected,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .awsConfig: return "aws_config"
            case .computeOptimizer: return "compute_optimizer"
            case .costExplorer: return "cost_explorer"
            case .lse: return "lse"
            case .manual: return "manual"
            case .pse: return "pse"
            case .rds: return "rds"
            case .resilience: return "resilience"
            case .resilienceHub: return "resilience_hub"
            case .securityHub: return "security_hub"
            case .stir: return "stir"
            case .taCheck: return "ta_check"
            case .wellArchitected: return "well_architected"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RecommendationSource(rawValue: rawValue) ?? RecommendationSource.sdkUnknown(rawValue)
        }
    }
}

extension TrustedAdvisorClientTypes {
    public enum RecommendationStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case error
        case ok
        case warning
        case sdkUnknown(Swift.String)

        public static var allCases: [RecommendationStatus] {
            return [
                .error,
                .ok,
                .warning,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .error: return "error"
            case .ok: return "ok"
            case .warning: return "warning"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RecommendationStatus(rawValue: rawValue) ?? RecommendationStatus.sdkUnknown(rawValue)
        }
    }
}

extension TrustedAdvisorClientTypes.RecommendationSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case awsServices
        case checkArn
        case createdAt
        case id
        case lastUpdatedAt
        case lifecycleStage
        case name
        case pillarSpecificAggregates
        case pillars
        case resourcesAggregates
        case source
        case status
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let awsServices = awsServices {
            var awsServicesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .awsServices)
            for recommendationawsservice0 in awsServices {
                try awsServicesContainer.encode(recommendationawsservice0)
            }
        }
        if let checkArn = self.checkArn {
            try encodeContainer.encode(checkArn, forKey: .checkArn)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .dateTime, forKey: .createdAt)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let lastUpdatedAt = self.lastUpdatedAt {
            try encodeContainer.encodeTimestamp(lastUpdatedAt, format: .dateTime, forKey: .lastUpdatedAt)
        }
        if let lifecycleStage = self.lifecycleStage {
            try encodeContainer.encode(lifecycleStage.rawValue, forKey: .lifecycleStage)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let pillarSpecificAggregates = self.pillarSpecificAggregates {
            try encodeContainer.encode(pillarSpecificAggregates, forKey: .pillarSpecificAggregates)
        }
        if let pillars = pillars {
            var pillarsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .pillars)
            for recommendationpillar0 in pillars {
                try pillarsContainer.encode(recommendationpillar0.rawValue)
            }
        }
        if let resourcesAggregates = self.resourcesAggregates {
            try encodeContainer.encode(resourcesAggregates, forKey: .resourcesAggregates)
        }
        if let source = self.source {
            try encodeContainer.encode(source.rawValue, forKey: .source)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let typeDecoded = try containerValues.decodeIfPresent(TrustedAdvisorClientTypes.RecommendationType.self, forKey: .type)
        type = typeDecoded
        let checkArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .checkArn)
        checkArn = checkArnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(TrustedAdvisorClientTypes.RecommendationStatus.self, forKey: .status)
        status = statusDecoded
        let lifecycleStageDecoded = try containerValues.decodeIfPresent(TrustedAdvisorClientTypes.RecommendationLifecycleStage.self, forKey: .lifecycleStage)
        lifecycleStage = lifecycleStageDecoded
        let pillarsContainer = try containerValues.decodeIfPresent([TrustedAdvisorClientTypes.RecommendationPillar?].self, forKey: .pillars)
        var pillarsDecoded0:[TrustedAdvisorClientTypes.RecommendationPillar]? = nil
        if let pillarsContainer = pillarsContainer {
            pillarsDecoded0 = [TrustedAdvisorClientTypes.RecommendationPillar]()
            for enum0 in pillarsContainer {
                if let enum0 = enum0 {
                    pillarsDecoded0?.append(enum0)
                }
            }
        }
        pillars = pillarsDecoded0
        let sourceDecoded = try containerValues.decodeIfPresent(TrustedAdvisorClientTypes.RecommendationSource.self, forKey: .source)
        source = sourceDecoded
        let awsServicesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .awsServices)
        var awsServicesDecoded0:[Swift.String]? = nil
        if let awsServicesContainer = awsServicesContainer {
            awsServicesDecoded0 = [Swift.String]()
            for string0 in awsServicesContainer {
                if let string0 = string0 {
                    awsServicesDecoded0?.append(string0)
                }
            }
        }
        awsServices = awsServicesDecoded0
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let resourcesAggregatesDecoded = try containerValues.decodeIfPresent(TrustedAdvisorClientTypes.RecommendationResourcesAggregates.self, forKey: .resourcesAggregates)
        resourcesAggregates = resourcesAggregatesDecoded
        let pillarSpecificAggregatesDecoded = try containerValues.decodeIfPresent(TrustedAdvisorClientTypes.RecommendationPillarSpecificAggregates.self, forKey: .pillarSpecificAggregates)
        pillarSpecificAggregates = pillarSpecificAggregatesDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .createdAt)
        createdAt = createdAtDecoded
        let lastUpdatedAtDecoded = try containerValues.decodeTimestampIfPresent(.dateTime, forKey: .lastUpdatedAt)
        lastUpdatedAt = lastUpdatedAtDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension TrustedAdvisorClientTypes {
    /// Summary of Recommendation for an Account
    public struct RecommendationSummary: Swift.Equatable {
        /// The ARN of the Recommendation
        /// This member is required.
        public var arn: Swift.String?
        /// The AWS Services that the Recommendation applies to
        public var awsServices: [Swift.String]?
        /// The AWS Trusted Advisor Check ARN that relates to the Recommendation
        public var checkArn: Swift.String?
        /// When the Recommendation was created, if created by AWS Trusted Advisor Priority
        public var createdAt: ClientRuntime.Date?
        /// The ID which identifies where the Recommendation was produced
        /// This member is required.
        public var id: Swift.String?
        /// When the Recommendation was last updated
        public var lastUpdatedAt: ClientRuntime.Date?
        /// The lifecycle stage from AWS Trusted Advisor Priority
        public var lifecycleStage: TrustedAdvisorClientTypes.RecommendationLifecycleStage?
        /// The name of the AWS Trusted Advisor Recommendation
        /// This member is required.
        public var name: Swift.String?
        /// The pillar aggregations for cost savings
        public var pillarSpecificAggregates: TrustedAdvisorClientTypes.RecommendationPillarSpecificAggregates?
        /// The Pillars that the Recommendation is optimizing
        /// This member is required.
        public var pillars: [TrustedAdvisorClientTypes.RecommendationPillar]?
        /// An aggregation of all resources
        /// This member is required.
        public var resourcesAggregates: TrustedAdvisorClientTypes.RecommendationResourcesAggregates?
        /// The source of the Recommendation
        /// This member is required.
        public var source: TrustedAdvisorClientTypes.RecommendationSource?
        /// The status of the Recommendation
        /// This member is required.
        public var status: TrustedAdvisorClientTypes.RecommendationStatus?
        /// Whether the Recommendation was automated or generated by AWS Trusted Advisor Priority
        /// This member is required.
        public var type: TrustedAdvisorClientTypes.RecommendationType?

        public init(
            arn: Swift.String? = nil,
            awsServices: [Swift.String]? = nil,
            checkArn: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            id: Swift.String? = nil,
            lastUpdatedAt: ClientRuntime.Date? = nil,
            lifecycleStage: TrustedAdvisorClientTypes.RecommendationLifecycleStage? = nil,
            name: Swift.String? = nil,
            pillarSpecificAggregates: TrustedAdvisorClientTypes.RecommendationPillarSpecificAggregates? = nil,
            pillars: [TrustedAdvisorClientTypes.RecommendationPillar]? = nil,
            resourcesAggregates: TrustedAdvisorClientTypes.RecommendationResourcesAggregates? = nil,
            source: TrustedAdvisorClientTypes.RecommendationSource? = nil,
            status: TrustedAdvisorClientTypes.RecommendationStatus? = nil,
            type: TrustedAdvisorClientTypes.RecommendationType? = nil
        )
        {
            self.arn = arn
            self.awsServices = awsServices
            self.checkArn = checkArn
            self.createdAt = createdAt
            self.id = id
            self.lastUpdatedAt = lastUpdatedAt
            self.lifecycleStage = lifecycleStage
            self.name = name
            self.pillarSpecificAggregates = pillarSpecificAggregates
            self.pillars = pillars
            self.resourcesAggregates = resourcesAggregates
            self.source = source
            self.status = status
            self.type = type
        }
    }

}

extension TrustedAdvisorClientTypes {
    public enum RecommendationType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case priority
        case standard
        case sdkUnknown(Swift.String)

        public static var allCases: [RecommendationType] {
            return [
                .priority,
                .standard,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .priority: return "priority"
            case .standard: return "standard"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RecommendationType(rawValue: rawValue) ?? RecommendationType.sdkUnknown(rawValue)
        }
    }
}

extension ResourceNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Exception that the requested resource has not been found
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension TrustedAdvisorClientTypes {
    public enum ResourceStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case error
        case ok
        case warning
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceStatus] {
            return [
                .error,
                .ok,
                .warning,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .error: return "error"
            case .ok: return "ok"
            case .warning: return "warning"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResourceStatus(rawValue: rawValue) ?? ResourceStatus.sdkUnknown(rawValue)
        }
    }
}

extension ThrottlingException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Exception to notify that requests are being throttled
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { true }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UpdateOrganizationRecommendationLifecycleInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateOrganizationRecommendationLifecycleInput(lifecycleStage: \(Swift.String(describing: lifecycleStage)), organizationRecommendationIdentifier: \(Swift.String(describing: organizationRecommendationIdentifier)), updateReasonCode: \(Swift.String(describing: updateReasonCode)), updateReason: \"CONTENT_REDACTED\")"}
}

extension UpdateOrganizationRecommendationLifecycleInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lifecycleStage
        case updateReason
        case updateReasonCode
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lifecycleStage = self.lifecycleStage {
            try encodeContainer.encode(lifecycleStage.rawValue, forKey: .lifecycleStage)
        }
        if let updateReason = self.updateReason {
            try encodeContainer.encode(updateReason, forKey: .updateReason)
        }
        if let updateReasonCode = self.updateReasonCode {
            try encodeContainer.encode(updateReasonCode.rawValue, forKey: .updateReasonCode)
        }
    }
}

extension UpdateOrganizationRecommendationLifecycleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let organizationRecommendationIdentifier = organizationRecommendationIdentifier else {
            return nil
        }
        return "/v1/organization-recommendations/\(organizationRecommendationIdentifier.urlPercentEncoding())/lifecycle"
    }
}

public struct UpdateOrganizationRecommendationLifecycleInput: Swift.Equatable {
    /// The new lifecycle stage
    /// This member is required.
    public var lifecycleStage: TrustedAdvisorClientTypes.UpdateRecommendationLifecycleStage?
    /// The Recommendation identifier for AWS Trusted Advisor Priority recommendations
    /// This member is required.
    public var organizationRecommendationIdentifier: Swift.String?
    /// Reason for the lifecycle stage change
    public var updateReason: Swift.String?
    /// Reason code for the lifecycle state change
    public var updateReasonCode: TrustedAdvisorClientTypes.UpdateRecommendationLifecycleStageReasonCode?

    public init(
        lifecycleStage: TrustedAdvisorClientTypes.UpdateRecommendationLifecycleStage? = nil,
        organizationRecommendationIdentifier: Swift.String? = nil,
        updateReason: Swift.String? = nil,
        updateReasonCode: TrustedAdvisorClientTypes.UpdateRecommendationLifecycleStageReasonCode? = nil
    )
    {
        self.lifecycleStage = lifecycleStage
        self.organizationRecommendationIdentifier = organizationRecommendationIdentifier
        self.updateReason = updateReason
        self.updateReasonCode = updateReasonCode
    }
}

struct UpdateOrganizationRecommendationLifecycleInputBody: Swift.Equatable {
    let lifecycleStage: TrustedAdvisorClientTypes.UpdateRecommendationLifecycleStage?
    let updateReason: Swift.String?
    let updateReasonCode: TrustedAdvisorClientTypes.UpdateRecommendationLifecycleStageReasonCode?
}

extension UpdateOrganizationRecommendationLifecycleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lifecycleStage
        case updateReason
        case updateReasonCode
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lifecycleStageDecoded = try containerValues.decodeIfPresent(TrustedAdvisorClientTypes.UpdateRecommendationLifecycleStage.self, forKey: .lifecycleStage)
        lifecycleStage = lifecycleStageDecoded
        let updateReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .updateReason)
        updateReason = updateReasonDecoded
        let updateReasonCodeDecoded = try containerValues.decodeIfPresent(TrustedAdvisorClientTypes.UpdateRecommendationLifecycleStageReasonCode.self, forKey: .updateReasonCode)
        updateReasonCode = updateReasonCodeDecoded
    }
}

extension UpdateOrganizationRecommendationLifecycleOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateOrganizationRecommendationLifecycleOutput: Swift.Equatable {

    public init() { }
}

enum UpdateOrganizationRecommendationLifecycleOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateRecommendationLifecycleInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateRecommendationLifecycleInput(lifecycleStage: \(Swift.String(describing: lifecycleStage)), recommendationIdentifier: \(Swift.String(describing: recommendationIdentifier)), updateReasonCode: \(Swift.String(describing: updateReasonCode)), updateReason: \"CONTENT_REDACTED\")"}
}

extension UpdateRecommendationLifecycleInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lifecycleStage
        case updateReason
        case updateReasonCode
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lifecycleStage = self.lifecycleStage {
            try encodeContainer.encode(lifecycleStage.rawValue, forKey: .lifecycleStage)
        }
        if let updateReason = self.updateReason {
            try encodeContainer.encode(updateReason, forKey: .updateReason)
        }
        if let updateReasonCode = self.updateReasonCode {
            try encodeContainer.encode(updateReasonCode.rawValue, forKey: .updateReasonCode)
        }
    }
}

extension UpdateRecommendationLifecycleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let recommendationIdentifier = recommendationIdentifier else {
            return nil
        }
        return "/v1/recommendations/\(recommendationIdentifier.urlPercentEncoding())/lifecycle"
    }
}

public struct UpdateRecommendationLifecycleInput: Swift.Equatable {
    /// The new lifecycle stage
    /// This member is required.
    public var lifecycleStage: TrustedAdvisorClientTypes.UpdateRecommendationLifecycleStage?
    /// The Recommendation identifier for AWS Trusted Advisor Priority recommendations
    /// This member is required.
    public var recommendationIdentifier: Swift.String?
    /// Reason for the lifecycle stage change
    public var updateReason: Swift.String?
    /// Reason code for the lifecycle state change
    public var updateReasonCode: TrustedAdvisorClientTypes.UpdateRecommendationLifecycleStageReasonCode?

    public init(
        lifecycleStage: TrustedAdvisorClientTypes.UpdateRecommendationLifecycleStage? = nil,
        recommendationIdentifier: Swift.String? = nil,
        updateReason: Swift.String? = nil,
        updateReasonCode: TrustedAdvisorClientTypes.UpdateRecommendationLifecycleStageReasonCode? = nil
    )
    {
        self.lifecycleStage = lifecycleStage
        self.recommendationIdentifier = recommendationIdentifier
        self.updateReason = updateReason
        self.updateReasonCode = updateReasonCode
    }
}

struct UpdateRecommendationLifecycleInputBody: Swift.Equatable {
    let lifecycleStage: TrustedAdvisorClientTypes.UpdateRecommendationLifecycleStage?
    let updateReason: Swift.String?
    let updateReasonCode: TrustedAdvisorClientTypes.UpdateRecommendationLifecycleStageReasonCode?
}

extension UpdateRecommendationLifecycleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lifecycleStage
        case updateReason
        case updateReasonCode
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let lifecycleStageDecoded = try containerValues.decodeIfPresent(TrustedAdvisorClientTypes.UpdateRecommendationLifecycleStage.self, forKey: .lifecycleStage)
        lifecycleStage = lifecycleStageDecoded
        let updateReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .updateReason)
        updateReason = updateReasonDecoded
        let updateReasonCodeDecoded = try containerValues.decodeIfPresent(TrustedAdvisorClientTypes.UpdateRecommendationLifecycleStageReasonCode.self, forKey: .updateReasonCode)
        updateReasonCode = updateReasonCodeDecoded
    }
}

extension UpdateRecommendationLifecycleOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateRecommendationLifecycleOutput: Swift.Equatable {

    public init() { }
}

enum UpdateRecommendationLifecycleOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension TrustedAdvisorClientTypes {
    public enum UpdateRecommendationLifecycleStage: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case dismissed
        case inProgress
        case pendingResponse
        case resolved
        case sdkUnknown(Swift.String)

        public static var allCases: [UpdateRecommendationLifecycleStage] {
            return [
                .dismissed,
                .inProgress,
                .pendingResponse,
                .resolved,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .dismissed: return "dismissed"
            case .inProgress: return "in_progress"
            case .pendingResponse: return "pending_response"
            case .resolved: return "resolved"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = UpdateRecommendationLifecycleStage(rawValue: rawValue) ?? UpdateRecommendationLifecycleStage.sdkUnknown(rawValue)
        }
    }
}

extension TrustedAdvisorClientTypes {
    public enum UpdateRecommendationLifecycleStageReasonCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case lowPriority
        case nonCriticalAccount
        case notApplicable
        case other
        case otherMethodsAvailable
        case temporaryAccount
        case validBusinessCase
        case sdkUnknown(Swift.String)

        public static var allCases: [UpdateRecommendationLifecycleStageReasonCode] {
            return [
                .lowPriority,
                .nonCriticalAccount,
                .notApplicable,
                .other,
                .otherMethodsAvailable,
                .temporaryAccount,
                .validBusinessCase,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .lowPriority: return "low_priority"
            case .nonCriticalAccount: return "non_critical_account"
            case .notApplicable: return "not_applicable"
            case .other: return "other"
            case .otherMethodsAvailable: return "other_methods_available"
            case .temporaryAccount: return "temporary_account"
            case .validBusinessCase: return "valid_business_case"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = UpdateRecommendationLifecycleStageReasonCode(rawValue: rawValue) ?? UpdateRecommendationLifecycleStageReasonCode.sdkUnknown(rawValue)
        }
    }
}

extension ValidationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Exception that the request failed to satisfy service constraints
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}
