// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// You do not have sufficient access to perform this action.
public struct AccessDeniedException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ConnectParticipantClientTypes {
    public enum ArtifactStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case approved
        case inProgress
        case rejected
        case sdkUnknown(Swift.String)

        public static var allCases: [ArtifactStatus] {
            return [
                .approved,
                .inProgress,
                .rejected,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .approved: return "APPROVED"
            case .inProgress: return "IN_PROGRESS"
            case .rejected: return "REJECTED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ArtifactStatus(rawValue: rawValue) ?? ArtifactStatus.sdkUnknown(rawValue)
        }
    }
}

extension ConnectParticipantClientTypes.AttachmentItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attachmentId = "AttachmentId"
        case attachmentName = "AttachmentName"
        case contentType = "ContentType"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attachmentId = self.attachmentId {
            try encodeContainer.encode(attachmentId, forKey: .attachmentId)
        }
        if let attachmentName = self.attachmentName {
            try encodeContainer.encode(attachmentName, forKey: .attachmentName)
        }
        if let contentType = self.contentType {
            try encodeContainer.encode(contentType, forKey: .contentType)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contentType)
        contentType = contentTypeDecoded
        let attachmentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .attachmentId)
        attachmentId = attachmentIdDecoded
        let attachmentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .attachmentName)
        attachmentName = attachmentNameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ConnectParticipantClientTypes.ArtifactStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension ConnectParticipantClientTypes {
    /// The case-insensitive input to indicate standard MIME type that describes the format of the file that will be uploaded.
    public struct AttachmentItem: Swift.Equatable {
        /// A unique identifier for the attachment.
        public var attachmentId: Swift.String?
        /// A case-sensitive name of the attachment being uploaded.
        public var attachmentName: Swift.String?
        /// Describes the MIME file type of the attachment. For a list of supported file types, see [Feature specifications](https://docs.aws.amazon.com/connect/latest/adminguide/feature-limits.html) in the Amazon Connect Administrator Guide.
        public var contentType: Swift.String?
        /// Status of the attachment.
        public var status: ConnectParticipantClientTypes.ArtifactStatus?

        public init (
            attachmentId: Swift.String? = nil,
            attachmentName: Swift.String? = nil,
            contentType: Swift.String? = nil,
            status: ConnectParticipantClientTypes.ArtifactStatus? = nil
        )
        {
            self.attachmentId = attachmentId
            self.attachmentName = attachmentName
            self.contentType = contentType
            self.status = status
        }
    }

}

extension ConnectParticipantClientTypes {
    public enum ChatItemType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case attachment
        case chatEnded
        case connectionAck
        case event
        case message
        case messageDelivered
        case messageRead
        case participantJoined
        case participantLeft
        case transferFailed
        case transferSucceeded
        case typing
        case sdkUnknown(Swift.String)

        public static var allCases: [ChatItemType] {
            return [
                .attachment,
                .chatEnded,
                .connectionAck,
                .event,
                .message,
                .messageDelivered,
                .messageRead,
                .participantJoined,
                .participantLeft,
                .transferFailed,
                .transferSucceeded,
                .typing,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .attachment: return "ATTACHMENT"
            case .chatEnded: return "CHAT_ENDED"
            case .connectionAck: return "CONNECTION_ACK"
            case .event: return "EVENT"
            case .message: return "MESSAGE"
            case .messageDelivered: return "MESSAGE_DELIVERED"
            case .messageRead: return "MESSAGE_READ"
            case .participantJoined: return "PARTICIPANT_JOINED"
            case .participantLeft: return "PARTICIPANT_LEFT"
            case .transferFailed: return "TRANSFER_FAILED"
            case .transferSucceeded: return "TRANSFER_SUCCEEDED"
            case .typing: return "TYPING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ChatItemType(rawValue: rawValue) ?? ChatItemType.sdkUnknown(rawValue)
        }
    }
}

extension CompleteAttachmentUploadInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attachmentIds = "AttachmentIds"
        case clientToken = "ClientToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attachmentIds = attachmentIds {
            var attachmentIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attachmentIds)
            for artifactid0 in attachmentIds {
                try attachmentIdsContainer.encode(artifactid0)
            }
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
    }
}

extension CompleteAttachmentUploadInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let connectionToken = connectionToken {
            items.add(Header(name: "X-Amz-Bearer", value: Swift.String(connectionToken)))
        }
        return items
    }
}

extension CompleteAttachmentUploadInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/participant/complete-attachment-upload"
    }
}

public struct CompleteAttachmentUploadInput: Swift.Equatable {
    /// A list of unique identifiers for the attachments.
    /// This member is required.
    public var attachmentIds: [Swift.String]?
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see [Making retries safe with idempotent APIs](https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/).
    /// This member is required.
    public var clientToken: Swift.String?
    /// The authentication token associated with the participant's connection.
    /// This member is required.
    public var connectionToken: Swift.String?

    public init (
        attachmentIds: [Swift.String]? = nil,
        clientToken: Swift.String? = nil,
        connectionToken: Swift.String? = nil
    )
    {
        self.attachmentIds = attachmentIds
        self.clientToken = clientToken
        self.connectionToken = connectionToken
    }
}

struct CompleteAttachmentUploadInputBody: Swift.Equatable {
    let attachmentIds: [Swift.String]?
    let clientToken: Swift.String?
}

extension CompleteAttachmentUploadInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attachmentIds = "AttachmentIds"
        case clientToken = "ClientToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attachmentIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .attachmentIds)
        var attachmentIdsDecoded0:[Swift.String]? = nil
        if let attachmentIdsContainer = attachmentIdsContainer {
            attachmentIdsDecoded0 = [Swift.String]()
            for string0 in attachmentIdsContainer {
                if let string0 = string0 {
                    attachmentIdsDecoded0?.append(string0)
                }
            }
        }
        attachmentIds = attachmentIdsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CompleteAttachmentUploadOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CompleteAttachmentUploadOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ConflictException" : self = .conflictException(try ConflictException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CompleteAttachmentUploadOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case conflictException(ConflictException)
    case internalServerException(InternalServerException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CompleteAttachmentUploadOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct CompleteAttachmentUploadOutputResponse: Swift.Equatable {

    public init () { }
}

extension ConflictException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// An attachment with that identifier is already being uploaded.
public struct ConflictException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ConnectParticipantClientTypes.ConnectionCredentials: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectionToken = "ConnectionToken"
        case expiry = "Expiry"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectionToken = self.connectionToken {
            try encodeContainer.encode(connectionToken, forKey: .connectionToken)
        }
        if let expiry = self.expiry {
            try encodeContainer.encode(expiry, forKey: .expiry)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectionTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectionToken)
        connectionToken = connectionTokenDecoded
        let expiryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .expiry)
        expiry = expiryDecoded
    }
}

extension ConnectParticipantClientTypes {
    /// Connection credentials.
    public struct ConnectionCredentials: Swift.Equatable {
        /// The connection token.
        public var connectionToken: Swift.String?
        /// The expiration of the token. It's specified in ISO 8601 format: yyyy-MM-ddThh:mm:ss.SSSZ. For example, 2019-11-08T02:41:28.172Z.
        public var expiry: Swift.String?

        public init (
            connectionToken: Swift.String? = nil,
            expiry: Swift.String? = nil
        )
        {
            self.connectionToken = connectionToken
            self.expiry = expiry
        }
    }

}

extension ConnectParticipantClientTypes {
    public enum ConnectionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case connectionCredentials
        case websocket
        case sdkUnknown(Swift.String)

        public static var allCases: [ConnectionType] {
            return [
                .connectionCredentials,
                .websocket,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .connectionCredentials: return "CONNECTION_CREDENTIALS"
            case .websocket: return "WEBSOCKET"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ConnectionType(rawValue: rawValue) ?? ConnectionType.sdkUnknown(rawValue)
        }
    }
}

extension CreateParticipantConnectionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectParticipant = "ConnectParticipant"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectParticipant = self.connectParticipant {
            try encodeContainer.encode(connectParticipant, forKey: .connectParticipant)
        }
        if let type = type {
            var typeContainer = encodeContainer.nestedUnkeyedContainer(forKey: .type)
            for connectiontype0 in type {
                try typeContainer.encode(connectiontype0.rawValue)
            }
        }
    }
}

extension CreateParticipantConnectionInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let participantToken = participantToken {
            items.add(Header(name: "X-Amz-Bearer", value: Swift.String(participantToken)))
        }
        return items
    }
}

extension CreateParticipantConnectionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/participant/connection"
    }
}

public struct CreateParticipantConnectionInput: Swift.Equatable {
    /// Amazon Connect Participant is used to mark the participant as connected for message streaming.
    public var connectParticipant: Swift.Bool?
    /// This is a header parameter. The ParticipantToken as obtained from [StartChatContact](https://docs.aws.amazon.com/connect/latest/APIReference/API_StartChatContact.html) API response.
    /// This member is required.
    public var participantToken: Swift.String?
    /// Type of connection information required. This can be omitted if ConnectParticipant is true.
    public var type: [ConnectParticipantClientTypes.ConnectionType]?

    public init (
        connectParticipant: Swift.Bool? = nil,
        participantToken: Swift.String? = nil,
        type: [ConnectParticipantClientTypes.ConnectionType]? = nil
    )
    {
        self.connectParticipant = connectParticipant
        self.participantToken = participantToken
        self.type = type
    }
}

struct CreateParticipantConnectionInputBody: Swift.Equatable {
    let type: [ConnectParticipantClientTypes.ConnectionType]?
    let connectParticipant: Swift.Bool?
}

extension CreateParticipantConnectionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectParticipant = "ConnectParticipant"
        case type = "Type"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeContainer = try containerValues.decodeIfPresent([ConnectParticipantClientTypes.ConnectionType?].self, forKey: .type)
        var typeDecoded0:[ConnectParticipantClientTypes.ConnectionType]? = nil
        if let typeContainer = typeContainer {
            typeDecoded0 = [ConnectParticipantClientTypes.ConnectionType]()
            for enum0 in typeContainer {
                if let enum0 = enum0 {
                    typeDecoded0?.append(enum0)
                }
            }
        }
        type = typeDecoded0
        let connectParticipantDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .connectParticipant)
        connectParticipant = connectParticipantDecoded
    }
}

extension CreateParticipantConnectionOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateParticipantConnectionOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateParticipantConnectionOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateParticipantConnectionOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateParticipantConnectionOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.connectionCredentials = output.connectionCredentials
            self.websocket = output.websocket
        } else {
            self.connectionCredentials = nil
            self.websocket = nil
        }
    }
}

public struct CreateParticipantConnectionOutputResponse: Swift.Equatable {
    /// Creates the participant's connection credentials. The authentication token associated with the participant's connection.
    public var connectionCredentials: ConnectParticipantClientTypes.ConnectionCredentials?
    /// Creates the participant's websocket connection.
    public var websocket: ConnectParticipantClientTypes.Websocket?

    public init (
        connectionCredentials: ConnectParticipantClientTypes.ConnectionCredentials? = nil,
        websocket: ConnectParticipantClientTypes.Websocket? = nil
    )
    {
        self.connectionCredentials = connectionCredentials
        self.websocket = websocket
    }
}

struct CreateParticipantConnectionOutputResponseBody: Swift.Equatable {
    let websocket: ConnectParticipantClientTypes.Websocket?
    let connectionCredentials: ConnectParticipantClientTypes.ConnectionCredentials?
}

extension CreateParticipantConnectionOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectionCredentials = "ConnectionCredentials"
        case websocket = "Websocket"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let websocketDecoded = try containerValues.decodeIfPresent(ConnectParticipantClientTypes.Websocket.self, forKey: .websocket)
        websocket = websocketDecoded
        let connectionCredentialsDecoded = try containerValues.decodeIfPresent(ConnectParticipantClientTypes.ConnectionCredentials.self, forKey: .connectionCredentials)
        connectionCredentials = connectionCredentialsDecoded
    }
}

extension DisconnectParticipantInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
    }
}

extension DisconnectParticipantInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let connectionToken = connectionToken {
            items.add(Header(name: "X-Amz-Bearer", value: Swift.String(connectionToken)))
        }
        return items
    }
}

extension DisconnectParticipantInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/participant/disconnect"
    }
}

public struct DisconnectParticipantInput: Swift.Equatable {
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see [Making retries safe with idempotent APIs](https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/).
    public var clientToken: Swift.String?
    /// The authentication token associated with the participant's connection.
    /// This member is required.
    public var connectionToken: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        connectionToken: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.connectionToken = connectionToken
    }
}

struct DisconnectParticipantInputBody: Swift.Equatable {
    let clientToken: Swift.String?
}

extension DisconnectParticipantInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension DisconnectParticipantOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisconnectParticipantOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DisconnectParticipantOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisconnectParticipantOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DisconnectParticipantOutputResponse: Swift.Equatable {

    public init () { }
}

extension GetAttachmentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attachmentId = "AttachmentId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attachmentId = self.attachmentId {
            try encodeContainer.encode(attachmentId, forKey: .attachmentId)
        }
    }
}

extension GetAttachmentInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let connectionToken = connectionToken {
            items.add(Header(name: "X-Amz-Bearer", value: Swift.String(connectionToken)))
        }
        return items
    }
}

extension GetAttachmentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/participant/attachment"
    }
}

public struct GetAttachmentInput: Swift.Equatable {
    /// A unique identifier for the attachment.
    /// This member is required.
    public var attachmentId: Swift.String?
    /// The authentication token associated with the participant's connection.
    /// This member is required.
    public var connectionToken: Swift.String?

    public init (
        attachmentId: Swift.String? = nil,
        connectionToken: Swift.String? = nil
    )
    {
        self.attachmentId = attachmentId
        self.connectionToken = connectionToken
    }
}

struct GetAttachmentInputBody: Swift.Equatable {
    let attachmentId: Swift.String?
}

extension GetAttachmentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attachmentId = "AttachmentId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attachmentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .attachmentId)
        attachmentId = attachmentIdDecoded
    }
}

extension GetAttachmentOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetAttachmentOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetAttachmentOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetAttachmentOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetAttachmentOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.url = output.url
            self.urlExpiry = output.urlExpiry
        } else {
            self.url = nil
            self.urlExpiry = nil
        }
    }
}

public struct GetAttachmentOutputResponse: Swift.Equatable {
    /// This is the pre-signed URL that can be used for uploading the file to Amazon S3 when used in response to [StartAttachmentUpload](https://docs.aws.amazon.com/connect-participant/latest/APIReference/API_StartAttachmentUpload.html).
    public var url: Swift.String?
    /// The expiration time of the URL in ISO timestamp. It's specified in ISO 8601 format: yyyy-MM-ddThh:mm:ss.SSSZ. For example, 2019-11-08T02:41:28.172Z.
    public var urlExpiry: Swift.String?

    public init (
        url: Swift.String? = nil,
        urlExpiry: Swift.String? = nil
    )
    {
        self.url = url
        self.urlExpiry = urlExpiry
    }
}

struct GetAttachmentOutputResponseBody: Swift.Equatable {
    let url: Swift.String?
    let urlExpiry: Swift.String?
}

extension GetAttachmentOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case url = "Url"
        case urlExpiry = "UrlExpiry"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let urlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .url)
        url = urlDecoded
        let urlExpiryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .urlExpiry)
        urlExpiry = urlExpiryDecoded
    }
}

extension GetTranscriptInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactId = "ContactId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case scanDirection = "ScanDirection"
        case sortOrder = "SortOrder"
        case startPosition = "StartPosition"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contactId = self.contactId {
            try encodeContainer.encode(contactId, forKey: .contactId)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let scanDirection = self.scanDirection {
            try encodeContainer.encode(scanDirection.rawValue, forKey: .scanDirection)
        }
        if let sortOrder = self.sortOrder {
            try encodeContainer.encode(sortOrder.rawValue, forKey: .sortOrder)
        }
        if let startPosition = self.startPosition {
            try encodeContainer.encode(startPosition, forKey: .startPosition)
        }
    }
}

extension GetTranscriptInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let connectionToken = connectionToken {
            items.add(Header(name: "X-Amz-Bearer", value: Swift.String(connectionToken)))
        }
        return items
    }
}

extension GetTranscriptInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/participant/transcript"
    }
}

public struct GetTranscriptInput: Swift.Equatable {
    /// The authentication token associated with the participant's connection.
    /// This member is required.
    public var connectionToken: Swift.String?
    /// The contactId from the current contact chain for which transcript is needed.
    public var contactId: Swift.String?
    /// The maximum number of results to return in the page. Default: 10.
    public var maxResults: Swift.Int?
    /// The pagination token. Use the value returned previously in the next subsequent request to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The direction from StartPosition from which to retrieve message. Default: BACKWARD when no StartPosition is provided, FORWARD with StartPosition.
    public var scanDirection: ConnectParticipantClientTypes.ScanDirection?
    /// The sort order for the records. Default: DESCENDING.
    public var sortOrder: ConnectParticipantClientTypes.SortKey?
    /// A filtering option for where to start.
    public var startPosition: ConnectParticipantClientTypes.StartPosition?

    public init (
        connectionToken: Swift.String? = nil,
        contactId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        scanDirection: ConnectParticipantClientTypes.ScanDirection? = nil,
        sortOrder: ConnectParticipantClientTypes.SortKey? = nil,
        startPosition: ConnectParticipantClientTypes.StartPosition? = nil
    )
    {
        self.connectionToken = connectionToken
        self.contactId = contactId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.scanDirection = scanDirection
        self.sortOrder = sortOrder
        self.startPosition = startPosition
    }
}

struct GetTranscriptInputBody: Swift.Equatable {
    let contactId: Swift.String?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
    let scanDirection: ConnectParticipantClientTypes.ScanDirection?
    let sortOrder: ConnectParticipantClientTypes.SortKey?
    let startPosition: ConnectParticipantClientTypes.StartPosition?
}

extension GetTranscriptInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactId = "ContactId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case scanDirection = "ScanDirection"
        case sortOrder = "SortOrder"
        case startPosition = "StartPosition"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactId)
        contactId = contactIdDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let scanDirectionDecoded = try containerValues.decodeIfPresent(ConnectParticipantClientTypes.ScanDirection.self, forKey: .scanDirection)
        scanDirection = scanDirectionDecoded
        let sortOrderDecoded = try containerValues.decodeIfPresent(ConnectParticipantClientTypes.SortKey.self, forKey: .sortOrder)
        sortOrder = sortOrderDecoded
        let startPositionDecoded = try containerValues.decodeIfPresent(ConnectParticipantClientTypes.StartPosition.self, forKey: .startPosition)
        startPosition = startPositionDecoded
    }
}

extension GetTranscriptOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetTranscriptOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetTranscriptOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetTranscriptOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetTranscriptOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.initialContactId = output.initialContactId
            self.nextToken = output.nextToken
            self.transcript = output.transcript
        } else {
            self.initialContactId = nil
            self.nextToken = nil
            self.transcript = nil
        }
    }
}

public struct GetTranscriptOutputResponse: Swift.Equatable {
    /// The initial contact ID for the contact.
    public var initialContactId: Swift.String?
    /// The pagination token. Use the value returned previously in the next subsequent request to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The list of messages in the session.
    public var transcript: [ConnectParticipantClientTypes.Item]?

    public init (
        initialContactId: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        transcript: [ConnectParticipantClientTypes.Item]? = nil
    )
    {
        self.initialContactId = initialContactId
        self.nextToken = nextToken
        self.transcript = transcript
    }
}

struct GetTranscriptOutputResponseBody: Swift.Equatable {
    let initialContactId: Swift.String?
    let transcript: [ConnectParticipantClientTypes.Item]?
    let nextToken: Swift.String?
}

extension GetTranscriptOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case initialContactId = "InitialContactId"
        case nextToken = "NextToken"
        case transcript = "Transcript"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let initialContactIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .initialContactId)
        initialContactId = initialContactIdDecoded
        let transcriptContainer = try containerValues.decodeIfPresent([ConnectParticipantClientTypes.Item?].self, forKey: .transcript)
        var transcriptDecoded0:[ConnectParticipantClientTypes.Item]? = nil
        if let transcriptContainer = transcriptContainer {
            transcriptDecoded0 = [ConnectParticipantClientTypes.Item]()
            for structure0 in transcriptContainer {
                if let structure0 = structure0 {
                    transcriptDecoded0?.append(structure0)
                }
            }
        }
        transcript = transcriptDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension InternalServerException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// This exception occurs when there is an internal failure in the Amazon Connect service.
public struct InternalServerException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ConnectParticipantClientTypes.Item: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case absoluteTime = "AbsoluteTime"
        case attachments = "Attachments"
        case content = "Content"
        case contentType = "ContentType"
        case displayName = "DisplayName"
        case id = "Id"
        case messageMetadata = "MessageMetadata"
        case participantId = "ParticipantId"
        case participantRole = "ParticipantRole"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let absoluteTime = self.absoluteTime {
            try encodeContainer.encode(absoluteTime, forKey: .absoluteTime)
        }
        if let attachments = attachments {
            var attachmentsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attachments)
            for attachmentitem0 in attachments {
                try attachmentsContainer.encode(attachmentitem0)
            }
        }
        if let content = self.content {
            try encodeContainer.encode(content, forKey: .content)
        }
        if let contentType = self.contentType {
            try encodeContainer.encode(contentType, forKey: .contentType)
        }
        if let displayName = self.displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let messageMetadata = self.messageMetadata {
            try encodeContainer.encode(messageMetadata, forKey: .messageMetadata)
        }
        if let participantId = self.participantId {
            try encodeContainer.encode(participantId, forKey: .participantId)
        }
        if let participantRole = self.participantRole {
            try encodeContainer.encode(participantRole.rawValue, forKey: .participantRole)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let absoluteTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .absoluteTime)
        absoluteTime = absoluteTimeDecoded
        let contentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .content)
        content = contentDecoded
        let contentTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contentType)
        contentType = contentTypeDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ConnectParticipantClientTypes.ChatItemType.self, forKey: .type)
        type = typeDecoded
        let participantIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .participantId)
        participantId = participantIdDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let participantRoleDecoded = try containerValues.decodeIfPresent(ConnectParticipantClientTypes.ParticipantRole.self, forKey: .participantRole)
        participantRole = participantRoleDecoded
        let attachmentsContainer = try containerValues.decodeIfPresent([ConnectParticipantClientTypes.AttachmentItem?].self, forKey: .attachments)
        var attachmentsDecoded0:[ConnectParticipantClientTypes.AttachmentItem]? = nil
        if let attachmentsContainer = attachmentsContainer {
            attachmentsDecoded0 = [ConnectParticipantClientTypes.AttachmentItem]()
            for structure0 in attachmentsContainer {
                if let structure0 = structure0 {
                    attachmentsDecoded0?.append(structure0)
                }
            }
        }
        attachments = attachmentsDecoded0
        let messageMetadataDecoded = try containerValues.decodeIfPresent(ConnectParticipantClientTypes.MessageMetadata.self, forKey: .messageMetadata)
        messageMetadata = messageMetadataDecoded
    }
}

extension ConnectParticipantClientTypes {
    /// An item - message or event - that has been sent.
    public struct Item: Swift.Equatable {
        /// The time when the message or event was sent. It's specified in ISO 8601 format: yyyy-MM-ddThh:mm:ss.SSSZ. For example, 2019-11-08T02:41:28.172Z.
        public var absoluteTime: Swift.String?
        /// Provides information about the attachments.
        public var attachments: [ConnectParticipantClientTypes.AttachmentItem]?
        /// The content of the message or event.
        public var content: Swift.String?
        /// The type of content of the item.
        public var contentType: Swift.String?
        /// The chat display name of the sender.
        public var displayName: Swift.String?
        /// The ID of the item.
        public var id: Swift.String?
        /// The metadata related to the message. Currently this supports only information related to message receipts.
        public var messageMetadata: ConnectParticipantClientTypes.MessageMetadata?
        /// The ID of the sender in the session.
        public var participantId: Swift.String?
        /// The role of the sender. For example, is it a customer, agent, or system.
        public var participantRole: ConnectParticipantClientTypes.ParticipantRole?
        /// Type of the item: message or event.
        public var type: ConnectParticipantClientTypes.ChatItemType?

        public init (
            absoluteTime: Swift.String? = nil,
            attachments: [ConnectParticipantClientTypes.AttachmentItem]? = nil,
            content: Swift.String? = nil,
            contentType: Swift.String? = nil,
            displayName: Swift.String? = nil,
            id: Swift.String? = nil,
            messageMetadata: ConnectParticipantClientTypes.MessageMetadata? = nil,
            participantId: Swift.String? = nil,
            participantRole: ConnectParticipantClientTypes.ParticipantRole? = nil,
            type: ConnectParticipantClientTypes.ChatItemType? = nil
        )
        {
            self.absoluteTime = absoluteTime
            self.attachments = attachments
            self.content = content
            self.contentType = contentType
            self.displayName = displayName
            self.id = id
            self.messageMetadata = messageMetadata
            self.participantId = participantId
            self.participantRole = participantRole
            self.type = type
        }
    }

}

extension ConnectParticipantClientTypes.MessageMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case messageId = "MessageId"
        case receipts = "Receipts"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let messageId = self.messageId {
            try encodeContainer.encode(messageId, forKey: .messageId)
        }
        if let receipts = receipts {
            var receiptsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .receipts)
            for receipt0 in receipts {
                try receiptsContainer.encode(receipt0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .messageId)
        messageId = messageIdDecoded
        let receiptsContainer = try containerValues.decodeIfPresent([ConnectParticipantClientTypes.Receipt?].self, forKey: .receipts)
        var receiptsDecoded0:[ConnectParticipantClientTypes.Receipt]? = nil
        if let receiptsContainer = receiptsContainer {
            receiptsDecoded0 = [ConnectParticipantClientTypes.Receipt]()
            for structure0 in receiptsContainer {
                if let structure0 = structure0 {
                    receiptsDecoded0?.append(structure0)
                }
            }
        }
        receipts = receiptsDecoded0
    }
}

extension ConnectParticipantClientTypes {
    /// Contains metadata related to a message.
    public struct MessageMetadata: Swift.Equatable {
        /// The identifier of the message that contains the metadata information.
        public var messageId: Swift.String?
        /// The list of receipt information for a message for different recipients.
        public var receipts: [ConnectParticipantClientTypes.Receipt]?

        public init (
            messageId: Swift.String? = nil,
            receipts: [ConnectParticipantClientTypes.Receipt]? = nil
        )
        {
            self.messageId = messageId
            self.receipts = receipts
        }
    }

}

extension ConnectParticipantClientTypes {
    public enum ParticipantRole: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case agent
        case customer
        case system
        case sdkUnknown(Swift.String)

        public static var allCases: [ParticipantRole] {
            return [
                .agent,
                .customer,
                .system,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .agent: return "AGENT"
            case .customer: return "CUSTOMER"
            case .system: return "SYSTEM"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ParticipantRole(rawValue: rawValue) ?? ParticipantRole.sdkUnknown(rawValue)
        }
    }
}

extension ConnectParticipantClientTypes.Receipt: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deliveredTimestamp = "DeliveredTimestamp"
        case readTimestamp = "ReadTimestamp"
        case recipientParticipantId = "RecipientParticipantId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deliveredTimestamp = self.deliveredTimestamp {
            try encodeContainer.encode(deliveredTimestamp, forKey: .deliveredTimestamp)
        }
        if let readTimestamp = self.readTimestamp {
            try encodeContainer.encode(readTimestamp, forKey: .readTimestamp)
        }
        if let recipientParticipantId = self.recipientParticipantId {
            try encodeContainer.encode(recipientParticipantId, forKey: .recipientParticipantId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deliveredTimestampDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deliveredTimestamp)
        deliveredTimestamp = deliveredTimestampDecoded
        let readTimestampDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .readTimestamp)
        readTimestamp = readTimestampDecoded
        let recipientParticipantIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recipientParticipantId)
        recipientParticipantId = recipientParticipantIdDecoded
    }
}

extension ConnectParticipantClientTypes {
    /// The receipt for the message delivered to the recipient.
    public struct Receipt: Swift.Equatable {
        /// The time when the message was delivered to the recipient.
        public var deliveredTimestamp: Swift.String?
        /// The time when the message was read by the recipient.
        public var readTimestamp: Swift.String?
        /// The identifier of the recipient of the message.
        public var recipientParticipantId: Swift.String?

        public init (
            deliveredTimestamp: Swift.String? = nil,
            readTimestamp: Swift.String? = nil,
            recipientParticipantId: Swift.String? = nil
        )
        {
            self.deliveredTimestamp = deliveredTimestamp
            self.readTimestamp = readTimestamp
            self.recipientParticipantId = recipientParticipantId
        }
    }

}

extension ConnectParticipantClientTypes {
    public enum ScanDirection: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case backward
        case forward
        case sdkUnknown(Swift.String)

        public static var allCases: [ScanDirection] {
            return [
                .backward,
                .forward,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .backward: return "BACKWARD"
            case .forward: return "FORWARD"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ScanDirection(rawValue: rawValue) ?? ScanDirection.sdkUnknown(rawValue)
        }
    }
}

extension SendEventInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case content = "Content"
        case contentType = "ContentType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let content = self.content {
            try encodeContainer.encode(content, forKey: .content)
        }
        if let contentType = self.contentType {
            try encodeContainer.encode(contentType, forKey: .contentType)
        }
    }
}

extension SendEventInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let connectionToken = connectionToken {
            items.add(Header(name: "X-Amz-Bearer", value: Swift.String(connectionToken)))
        }
        return items
    }
}

extension SendEventInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/participant/event"
    }
}

public struct SendEventInput: Swift.Equatable {
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see [Making retries safe with idempotent APIs](https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/).
    public var clientToken: Swift.String?
    /// The authentication token associated with the participant's connection.
    /// This member is required.
    public var connectionToken: Swift.String?
    /// The content of the event to be sent (for example, message text). For content related to message receipts, this is supported in the form of a JSON string. Sample Content: "{\"messageId\":\"11111111-aaaa-bbbb-cccc-EXAMPLE01234\"}"
    public var content: Swift.String?
    /// The content type of the request. Supported types are:
    ///
    /// * application/vnd.amazonaws.connect.event.typing
    ///
    /// * application/vnd.amazonaws.connect.event.connection.acknowledged
    ///
    /// * application/vnd.amazonaws.connect.event.message.delivered
    ///
    /// * application/vnd.amazonaws.connect.event.message.read
    /// This member is required.
    public var contentType: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        connectionToken: Swift.String? = nil,
        content: Swift.String? = nil,
        contentType: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.connectionToken = connectionToken
        self.content = content
        self.contentType = contentType
    }
}

struct SendEventInputBody: Swift.Equatable {
    let contentType: Swift.String?
    let content: Swift.String?
    let clientToken: Swift.String?
}

extension SendEventInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case content = "Content"
        case contentType = "ContentType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contentType)
        contentType = contentTypeDecoded
        let contentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .content)
        content = contentDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension SendEventOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SendEventOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum SendEventOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SendEventOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: SendEventOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.absoluteTime = output.absoluteTime
            self.id = output.id
        } else {
            self.absoluteTime = nil
            self.id = nil
        }
    }
}

public struct SendEventOutputResponse: Swift.Equatable {
    /// The time when the event was sent. It's specified in ISO 8601 format: yyyy-MM-ddThh:mm:ss.SSSZ. For example, 2019-11-08T02:41:28.172Z.
    public var absoluteTime: Swift.String?
    /// The ID of the response.
    public var id: Swift.String?

    public init (
        absoluteTime: Swift.String? = nil,
        id: Swift.String? = nil
    )
    {
        self.absoluteTime = absoluteTime
        self.id = id
    }
}

struct SendEventOutputResponseBody: Swift.Equatable {
    let id: Swift.String?
    let absoluteTime: Swift.String?
}

extension SendEventOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case absoluteTime = "AbsoluteTime"
        case id = "Id"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let absoluteTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .absoluteTime)
        absoluteTime = absoluteTimeDecoded
    }
}

extension SendMessageInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case content = "Content"
        case contentType = "ContentType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let content = self.content {
            try encodeContainer.encode(content, forKey: .content)
        }
        if let contentType = self.contentType {
            try encodeContainer.encode(contentType, forKey: .contentType)
        }
    }
}

extension SendMessageInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let connectionToken = connectionToken {
            items.add(Header(name: "X-Amz-Bearer", value: Swift.String(connectionToken)))
        }
        return items
    }
}

extension SendMessageInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/participant/message"
    }
}

public struct SendMessageInput: Swift.Equatable {
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see [Making retries safe with idempotent APIs](https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/).
    public var clientToken: Swift.String?
    /// The authentication token associated with the connection.
    /// This member is required.
    public var connectionToken: Swift.String?
    /// The content of the message.
    ///
    /// * For text/plain and text/markdown, the Length Constraints are Minimum of 1, Maximum of 1024.
    ///
    /// * For application/json, the Length Constraints are Minimum of 1, Maximum of 12000.
    /// This member is required.
    public var content: Swift.String?
    /// The type of the content. Supported types are text/plain, text/markdown, and application/json.
    /// This member is required.
    public var contentType: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        connectionToken: Swift.String? = nil,
        content: Swift.String? = nil,
        contentType: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.connectionToken = connectionToken
        self.content = content
        self.contentType = contentType
    }
}

struct SendMessageInputBody: Swift.Equatable {
    let contentType: Swift.String?
    let content: Swift.String?
    let clientToken: Swift.String?
}

extension SendMessageInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case content = "Content"
        case contentType = "ContentType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contentType)
        contentType = contentTypeDecoded
        let contentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .content)
        content = contentDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension SendMessageOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension SendMessageOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum SendMessageOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension SendMessageOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: SendMessageOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.absoluteTime = output.absoluteTime
            self.id = output.id
        } else {
            self.absoluteTime = nil
            self.id = nil
        }
    }
}

public struct SendMessageOutputResponse: Swift.Equatable {
    /// The time when the message was sent. It's specified in ISO 8601 format: yyyy-MM-ddThh:mm:ss.SSSZ. For example, 2019-11-08T02:41:28.172Z.
    public var absoluteTime: Swift.String?
    /// The ID of the message.
    public var id: Swift.String?

    public init (
        absoluteTime: Swift.String? = nil,
        id: Swift.String? = nil
    )
    {
        self.absoluteTime = absoluteTime
        self.id = id
    }
}

struct SendMessageOutputResponseBody: Swift.Equatable {
    let id: Swift.String?
    let absoluteTime: Swift.String?
}

extension SendMessageOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case absoluteTime = "AbsoluteTime"
        case id = "Id"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let absoluteTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .absoluteTime)
        absoluteTime = absoluteTimeDecoded
    }
}

extension ServiceQuotaExceededException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The number of attachments per contact exceeds the quota.
public struct ServiceQuotaExceededException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ConnectParticipantClientTypes {
    public enum SortKey: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ascending
        case descending
        case sdkUnknown(Swift.String)

        public static var allCases: [SortKey] {
            return [
                .ascending,
                .descending,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ascending: return "ASCENDING"
            case .descending: return "DESCENDING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SortKey(rawValue: rawValue) ?? SortKey.sdkUnknown(rawValue)
        }
    }
}

extension StartAttachmentUploadInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attachmentName = "AttachmentName"
        case attachmentSizeInBytes = "AttachmentSizeInBytes"
        case clientToken = "ClientToken"
        case contentType = "ContentType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attachmentName = self.attachmentName {
            try encodeContainer.encode(attachmentName, forKey: .attachmentName)
        }
        if attachmentSizeInBytes != 0 {
            try encodeContainer.encode(attachmentSizeInBytes, forKey: .attachmentSizeInBytes)
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let contentType = self.contentType {
            try encodeContainer.encode(contentType, forKey: .contentType)
        }
    }
}

extension StartAttachmentUploadInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let connectionToken = connectionToken {
            items.add(Header(name: "X-Amz-Bearer", value: Swift.String(connectionToken)))
        }
        return items
    }
}

extension StartAttachmentUploadInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/participant/start-attachment-upload"
    }
}

public struct StartAttachmentUploadInput: Swift.Equatable {
    /// A case-sensitive name of the attachment being uploaded.
    /// This member is required.
    public var attachmentName: Swift.String?
    /// The size of the attachment in bytes.
    /// This member is required.
    public var attachmentSizeInBytes: Swift.Int
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see [Making retries safe with idempotent APIs](https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/).
    /// This member is required.
    public var clientToken: Swift.String?
    /// The authentication token associated with the participant's connection.
    /// This member is required.
    public var connectionToken: Swift.String?
    /// Describes the MIME file type of the attachment. For a list of supported file types, see [Feature specifications](https://docs.aws.amazon.com/connect/latest/adminguide/feature-limits.html) in the Amazon Connect Administrator Guide.
    /// This member is required.
    public var contentType: Swift.String?

    public init (
        attachmentName: Swift.String? = nil,
        attachmentSizeInBytes: Swift.Int = 0,
        clientToken: Swift.String? = nil,
        connectionToken: Swift.String? = nil,
        contentType: Swift.String? = nil
    )
    {
        self.attachmentName = attachmentName
        self.attachmentSizeInBytes = attachmentSizeInBytes
        self.clientToken = clientToken
        self.connectionToken = connectionToken
        self.contentType = contentType
    }
}

struct StartAttachmentUploadInputBody: Swift.Equatable {
    let contentType: Swift.String?
    let attachmentSizeInBytes: Swift.Int
    let attachmentName: Swift.String?
    let clientToken: Swift.String?
}

extension StartAttachmentUploadInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attachmentName = "AttachmentName"
        case attachmentSizeInBytes = "AttachmentSizeInBytes"
        case clientToken = "ClientToken"
        case contentType = "ContentType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contentType)
        contentType = contentTypeDecoded
        let attachmentSizeInBytesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .attachmentSizeInBytes) ?? 0
        attachmentSizeInBytes = attachmentSizeInBytesDecoded
        let attachmentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .attachmentName)
        attachmentName = attachmentNameDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension StartAttachmentUploadOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartAttachmentUploadOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "AccessDeniedException" : self = .accessDeniedException(try AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerException" : self = .internalServerException(try InternalServerException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ServiceQuotaExceededException" : self = .serviceQuotaExceededException(try ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ThrottlingException" : self = .throttlingException(try ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "ValidationException" : self = .validationException(try ValidationException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum StartAttachmentUploadOutputError: Swift.Error, Swift.Equatable {
    case accessDeniedException(AccessDeniedException)
    case internalServerException(InternalServerException)
    case serviceQuotaExceededException(ServiceQuotaExceededException)
    case throttlingException(ThrottlingException)
    case validationException(ValidationException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartAttachmentUploadOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: StartAttachmentUploadOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.attachmentId = output.attachmentId
            self.uploadMetadata = output.uploadMetadata
        } else {
            self.attachmentId = nil
            self.uploadMetadata = nil
        }
    }
}

public struct StartAttachmentUploadOutputResponse: Swift.Equatable {
    /// A unique identifier for the attachment.
    public var attachmentId: Swift.String?
    /// Fields to be used while uploading the attachment.
    public var uploadMetadata: ConnectParticipantClientTypes.UploadMetadata?

    public init (
        attachmentId: Swift.String? = nil,
        uploadMetadata: ConnectParticipantClientTypes.UploadMetadata? = nil
    )
    {
        self.attachmentId = attachmentId
        self.uploadMetadata = uploadMetadata
    }
}

struct StartAttachmentUploadOutputResponseBody: Swift.Equatable {
    let attachmentId: Swift.String?
    let uploadMetadata: ConnectParticipantClientTypes.UploadMetadata?
}

extension StartAttachmentUploadOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attachmentId = "AttachmentId"
        case uploadMetadata = "UploadMetadata"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attachmentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .attachmentId)
        attachmentId = attachmentIdDecoded
        let uploadMetadataDecoded = try containerValues.decodeIfPresent(ConnectParticipantClientTypes.UploadMetadata.self, forKey: .uploadMetadata)
        uploadMetadata = uploadMetadataDecoded
    }
}

extension ConnectParticipantClientTypes.StartPosition: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case absoluteTime = "AbsoluteTime"
        case id = "Id"
        case mostRecent = "MostRecent"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let absoluteTime = self.absoluteTime {
            try encodeContainer.encode(absoluteTime, forKey: .absoluteTime)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if mostRecent != 0 {
            try encodeContainer.encode(mostRecent, forKey: .mostRecent)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let absoluteTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .absoluteTime)
        absoluteTime = absoluteTimeDecoded
        let mostRecentDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .mostRecent) ?? 0
        mostRecent = mostRecentDecoded
    }
}

extension ConnectParticipantClientTypes {
    /// A filtering option for where to start. For example, if you sent 100 messages, start with message 50.
    public struct StartPosition: Swift.Equatable {
        /// The time in ISO format where to start. It's specified in ISO 8601 format: yyyy-MM-ddThh:mm:ss.SSSZ. For example, 2019-11-08T02:41:28.172Z.
        public var absoluteTime: Swift.String?
        /// The ID of the message or event where to start.
        public var id: Swift.String?
        /// The start position of the most recent message where you want to start.
        public var mostRecent: Swift.Int

        public init (
            absoluteTime: Swift.String? = nil,
            id: Swift.String? = nil,
            mostRecent: Swift.Int = 0
        )
        {
            self.absoluteTime = absoluteTime
            self.id = id
            self.mostRecent = mostRecent
        }
    }

}

extension ThrottlingException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The request was denied due to request throttling.
public struct ThrottlingException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ConnectParticipantClientTypes.UploadMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case headersToInclude = "HeadersToInclude"
        case url = "Url"
        case urlExpiry = "UrlExpiry"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let headersToInclude = headersToInclude {
            var headersToIncludeContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .headersToInclude)
            for (dictKey0, uploadMetadataSignedHeaders0) in headersToInclude {
                try headersToIncludeContainer.encode(uploadMetadataSignedHeaders0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let url = self.url {
            try encodeContainer.encode(url, forKey: .url)
        }
        if let urlExpiry = self.urlExpiry {
            try encodeContainer.encode(urlExpiry, forKey: .urlExpiry)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let urlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .url)
        url = urlDecoded
        let urlExpiryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .urlExpiry)
        urlExpiry = urlExpiryDecoded
        let headersToIncludeContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .headersToInclude)
        var headersToIncludeDecoded0: [Swift.String:Swift.String]? = nil
        if let headersToIncludeContainer = headersToIncludeContainer {
            headersToIncludeDecoded0 = [Swift.String:Swift.String]()
            for (key0, uploadmetadatasignedheadersvalue0) in headersToIncludeContainer {
                if let uploadmetadatasignedheadersvalue0 = uploadmetadatasignedheadersvalue0 {
                    headersToIncludeDecoded0?[key0] = uploadmetadatasignedheadersvalue0
                }
            }
        }
        headersToInclude = headersToIncludeDecoded0
    }
}

extension ConnectParticipantClientTypes {
    /// Fields to be used while uploading the attachment.
    public struct UploadMetadata: Swift.Equatable {
        /// The headers to be provided while uploading the file to the URL.
        public var headersToInclude: [Swift.String:Swift.String]?
        /// This is the pre-signed URL that can be used for uploading the file to Amazon S3 when used in response to [StartAttachmentUpload](https://docs.aws.amazon.com/connect-participant/latest/APIReference/API_StartAttachmentUpload.html).
        public var url: Swift.String?
        /// The expiration time of the URL in ISO timestamp. It's specified in ISO 8601 format: yyyy-MM-ddThh:mm:ss.SSSZ. For example, 2019-11-08T02:41:28.172Z.
        public var urlExpiry: Swift.String?

        public init (
            headersToInclude: [Swift.String:Swift.String]? = nil,
            url: Swift.String? = nil,
            urlExpiry: Swift.String? = nil
        )
        {
            self.headersToInclude = headersToInclude
            self.url = url
            self.urlExpiry = urlExpiry
        }
    }

}

extension ValidationException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
        } else {
            self.message = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// The input fails to satisfy the constraints specified by Amazon Connect.
public struct ValidationException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// This member is required.
    public var message: Swift.String?

    public init (
        message: Swift.String? = nil
    )
    {
        self.message = message
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ConnectParticipantClientTypes.Websocket: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectionExpiry = "ConnectionExpiry"
        case url = "Url"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectionExpiry = self.connectionExpiry {
            try encodeContainer.encode(connectionExpiry, forKey: .connectionExpiry)
        }
        if let url = self.url {
            try encodeContainer.encode(url, forKey: .url)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let urlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .url)
        url = urlDecoded
        let connectionExpiryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectionExpiry)
        connectionExpiry = connectionExpiryDecoded
    }
}

extension ConnectParticipantClientTypes {
    /// The websocket for the participant's connection.
    public struct Websocket: Swift.Equatable {
        /// The URL expiration timestamp in ISO date format. It's specified in ISO 8601 format: yyyy-MM-ddThh:mm:ss.SSSZ. For example, 2019-11-08T02:41:28.172Z.
        public var connectionExpiry: Swift.String?
        /// The URL of the websocket.
        public var url: Swift.String?

        public init (
            connectionExpiry: Swift.String? = nil,
            url: Swift.String? = nil
        )
        {
            self.connectionExpiry = connectionExpiry
            self.url = url
        }
    }

}
