// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// You do not have sufficient access to perform this action.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ConnectParticipantClientTypes {
    public enum ArtifactStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case approved
        case inProgress
        case rejected
        case sdkUnknown(Swift.String)

        public static var allCases: [ArtifactStatus] {
            return [
                .approved,
                .inProgress,
                .rejected,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .approved: return "APPROVED"
            case .inProgress: return "IN_PROGRESS"
            case .rejected: return "REJECTED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ArtifactStatus(rawValue: rawValue) ?? ArtifactStatus.sdkUnknown(rawValue)
        }
    }
}

extension ConnectParticipantClientTypes.AttachmentItem: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attachmentId = "AttachmentId"
        case attachmentName = "AttachmentName"
        case contentType = "ContentType"
        case status = "Status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attachmentId = self.attachmentId {
            try encodeContainer.encode(attachmentId, forKey: .attachmentId)
        }
        if let attachmentName = self.attachmentName {
            try encodeContainer.encode(attachmentName, forKey: .attachmentName)
        }
        if let contentType = self.contentType {
            try encodeContainer.encode(contentType, forKey: .contentType)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contentType)
        contentType = contentTypeDecoded
        let attachmentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .attachmentId)
        attachmentId = attachmentIdDecoded
        let attachmentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .attachmentName)
        attachmentName = attachmentNameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ConnectParticipantClientTypes.ArtifactStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension ConnectParticipantClientTypes {
    /// The case-insensitive input to indicate standard MIME type that describes the format of the file that will be uploaded.
    public struct AttachmentItem: Swift.Equatable {
        /// A unique identifier for the attachment.
        public var attachmentId: Swift.String?
        /// A case-sensitive name of the attachment being uploaded.
        public var attachmentName: Swift.String?
        /// Describes the MIME file type of the attachment. For a list of supported file types, see [Feature specifications](https://docs.aws.amazon.com/connect/latest/adminguide/feature-limits.html) in the Amazon Connect Administrator Guide.
        public var contentType: Swift.String?
        /// Status of the attachment.
        public var status: ConnectParticipantClientTypes.ArtifactStatus?

        public init(
            attachmentId: Swift.String? = nil,
            attachmentName: Swift.String? = nil,
            contentType: Swift.String? = nil,
            status: ConnectParticipantClientTypes.ArtifactStatus? = nil
        )
        {
            self.attachmentId = attachmentId
            self.attachmentName = attachmentName
            self.contentType = contentType
            self.status = status
        }
    }

}

extension ConnectParticipantClientTypes {
    public enum ChatItemType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case attachment
        case chatEnded
        case connectionAck
        case event
        case message
        case messageDelivered
        case messageRead
        case participantJoined
        case participantLeft
        case transferFailed
        case transferSucceeded
        case typing
        case sdkUnknown(Swift.String)

        public static var allCases: [ChatItemType] {
            return [
                .attachment,
                .chatEnded,
                .connectionAck,
                .event,
                .message,
                .messageDelivered,
                .messageRead,
                .participantJoined,
                .participantLeft,
                .transferFailed,
                .transferSucceeded,
                .typing,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .attachment: return "ATTACHMENT"
            case .chatEnded: return "CHAT_ENDED"
            case .connectionAck: return "CONNECTION_ACK"
            case .event: return "EVENT"
            case .message: return "MESSAGE"
            case .messageDelivered: return "MESSAGE_DELIVERED"
            case .messageRead: return "MESSAGE_READ"
            case .participantJoined: return "PARTICIPANT_JOINED"
            case .participantLeft: return "PARTICIPANT_LEFT"
            case .transferFailed: return "TRANSFER_FAILED"
            case .transferSucceeded: return "TRANSFER_SUCCEEDED"
            case .typing: return "TYPING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ChatItemType(rawValue: rawValue) ?? ChatItemType.sdkUnknown(rawValue)
        }
    }
}

extension CompleteAttachmentUploadInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attachmentIds = "AttachmentIds"
        case clientToken = "ClientToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attachmentIds = attachmentIds {
            var attachmentIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attachmentIds)
            for artifactid0 in attachmentIds {
                try attachmentIdsContainer.encode(artifactid0)
            }
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
    }
}

extension CompleteAttachmentUploadInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let connectionToken = connectionToken {
            items.add(Header(name: "X-Amz-Bearer", value: Swift.String(connectionToken)))
        }
        return items
    }
}

extension CompleteAttachmentUploadInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/participant/complete-attachment-upload"
    }
}

public struct CompleteAttachmentUploadInput: Swift.Equatable {
    /// A list of unique identifiers for the attachments.
    /// This member is required.
    public var attachmentIds: [Swift.String]?
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see [Making retries safe with idempotent APIs](https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/).
    /// This member is required.
    public var clientToken: Swift.String?
    /// The authentication token associated with the participant's connection.
    /// This member is required.
    public var connectionToken: Swift.String?

    public init(
        attachmentIds: [Swift.String]? = nil,
        clientToken: Swift.String? = nil,
        connectionToken: Swift.String? = nil
    )
    {
        self.attachmentIds = attachmentIds
        self.clientToken = clientToken
        self.connectionToken = connectionToken
    }
}

struct CompleteAttachmentUploadInputBody: Swift.Equatable {
    let attachmentIds: [Swift.String]?
    let clientToken: Swift.String?
}

extension CompleteAttachmentUploadInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attachmentIds = "AttachmentIds"
        case clientToken = "ClientToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attachmentIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .attachmentIds)
        var attachmentIdsDecoded0:[Swift.String]? = nil
        if let attachmentIdsContainer = attachmentIdsContainer {
            attachmentIdsDecoded0 = [Swift.String]()
            for string0 in attachmentIdsContainer {
                if let string0 = string0 {
                    attachmentIdsDecoded0?.append(string0)
                }
            }
        }
        attachmentIds = attachmentIdsDecoded0
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CompleteAttachmentUploadOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct CompleteAttachmentUploadOutput: Swift.Equatable {

    public init() { }
}

enum CompleteAttachmentUploadOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ConflictException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// An attachment with that identifier is already being uploaded.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ConnectParticipantClientTypes.ConnectionCredentials: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectionToken = "ConnectionToken"
        case expiry = "Expiry"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectionToken = self.connectionToken {
            try encodeContainer.encode(connectionToken, forKey: .connectionToken)
        }
        if let expiry = self.expiry {
            try encodeContainer.encode(expiry, forKey: .expiry)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let connectionTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectionToken)
        connectionToken = connectionTokenDecoded
        let expiryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .expiry)
        expiry = expiryDecoded
    }
}

extension ConnectParticipantClientTypes {
    /// Connection credentials.
    public struct ConnectionCredentials: Swift.Equatable {
        /// The connection token.
        public var connectionToken: Swift.String?
        /// The expiration of the token. It's specified in ISO 8601 format: yyyy-MM-ddThh:mm:ss.SSSZ. For example, 2019-11-08T02:41:28.172Z.
        public var expiry: Swift.String?

        public init(
            connectionToken: Swift.String? = nil,
            expiry: Swift.String? = nil
        )
        {
            self.connectionToken = connectionToken
            self.expiry = expiry
        }
    }

}

extension ConnectParticipantClientTypes {
    public enum ConnectionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case connectionCredentials
        case websocket
        case sdkUnknown(Swift.String)

        public static var allCases: [ConnectionType] {
            return [
                .connectionCredentials,
                .websocket,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .connectionCredentials: return "CONNECTION_CREDENTIALS"
            case .websocket: return "WEBSOCKET"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ConnectionType(rawValue: rawValue) ?? ConnectionType.sdkUnknown(rawValue)
        }
    }
}

extension CreateParticipantConnectionInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectParticipant = "ConnectParticipant"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectParticipant = self.connectParticipant {
            try encodeContainer.encode(connectParticipant, forKey: .connectParticipant)
        }
        if let type = type {
            var typeContainer = encodeContainer.nestedUnkeyedContainer(forKey: .type)
            for connectiontype0 in type {
                try typeContainer.encode(connectiontype0.rawValue)
            }
        }
    }
}

extension CreateParticipantConnectionInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let participantToken = participantToken {
            items.add(Header(name: "X-Amz-Bearer", value: Swift.String(participantToken)))
        }
        return items
    }
}

extension CreateParticipantConnectionInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/participant/connection"
    }
}

public struct CreateParticipantConnectionInput: Swift.Equatable {
    /// Amazon Connect Participant is used to mark the participant as connected for customer participant in message streaming, as well as for agent or manager participant in non-streaming chats.
    public var connectParticipant: Swift.Bool?
    /// This is a header parameter. The ParticipantToken as obtained from [StartChatContact](https://docs.aws.amazon.com/connect/latest/APIReference/API_StartChatContact.html) API response.
    /// This member is required.
    public var participantToken: Swift.String?
    /// Type of connection information required. If you need CONNECTION_CREDENTIALS along with marking participant as connected, pass CONNECTION_CREDENTIALS in Type.
    public var type: [ConnectParticipantClientTypes.ConnectionType]?

    public init(
        connectParticipant: Swift.Bool? = nil,
        participantToken: Swift.String? = nil,
        type: [ConnectParticipantClientTypes.ConnectionType]? = nil
    )
    {
        self.connectParticipant = connectParticipant
        self.participantToken = participantToken
        self.type = type
    }
}

struct CreateParticipantConnectionInputBody: Swift.Equatable {
    let type: [ConnectParticipantClientTypes.ConnectionType]?
    let connectParticipant: Swift.Bool?
}

extension CreateParticipantConnectionInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectParticipant = "ConnectParticipant"
        case type = "Type"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeContainer = try containerValues.decodeIfPresent([ConnectParticipantClientTypes.ConnectionType?].self, forKey: .type)
        var typeDecoded0:[ConnectParticipantClientTypes.ConnectionType]? = nil
        if let typeContainer = typeContainer {
            typeDecoded0 = [ConnectParticipantClientTypes.ConnectionType]()
            for enum0 in typeContainer {
                if let enum0 = enum0 {
                    typeDecoded0?.append(enum0)
                }
            }
        }
        type = typeDecoded0
        let connectParticipantDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .connectParticipant)
        connectParticipant = connectParticipantDecoded
    }
}

extension CreateParticipantConnectionOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateParticipantConnectionOutputBody = try responseDecoder.decode(responseBody: data)
            self.connectionCredentials = output.connectionCredentials
            self.websocket = output.websocket
        } else {
            self.connectionCredentials = nil
            self.websocket = nil
        }
    }
}

public struct CreateParticipantConnectionOutput: Swift.Equatable {
    /// Creates the participant's connection credentials. The authentication token associated with the participant's connection.
    public var connectionCredentials: ConnectParticipantClientTypes.ConnectionCredentials?
    /// Creates the participant's websocket connection.
    public var websocket: ConnectParticipantClientTypes.Websocket?

    public init(
        connectionCredentials: ConnectParticipantClientTypes.ConnectionCredentials? = nil,
        websocket: ConnectParticipantClientTypes.Websocket? = nil
    )
    {
        self.connectionCredentials = connectionCredentials
        self.websocket = websocket
    }
}

struct CreateParticipantConnectionOutputBody: Swift.Equatable {
    let websocket: ConnectParticipantClientTypes.Websocket?
    let connectionCredentials: ConnectParticipantClientTypes.ConnectionCredentials?
}

extension CreateParticipantConnectionOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectionCredentials = "ConnectionCredentials"
        case websocket = "Websocket"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let websocketDecoded = try containerValues.decodeIfPresent(ConnectParticipantClientTypes.Websocket.self, forKey: .websocket)
        websocket = websocketDecoded
        let connectionCredentialsDecoded = try containerValues.decodeIfPresent(ConnectParticipantClientTypes.ConnectionCredentials.self, forKey: .connectionCredentials)
        connectionCredentials = connectionCredentialsDecoded
    }
}

enum CreateParticipantConnectionOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeViewInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let connectionToken = connectionToken {
            items.add(Header(name: "X-Amz-Bearer", value: Swift.String(connectionToken)))
        }
        return items
    }
}

extension DescribeViewInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let viewToken = viewToken else {
            return nil
        }
        return "/participant/views/\(viewToken.urlPercentEncoding())"
    }
}

public struct DescribeViewInput: Swift.Equatable {
    /// The connection token.
    /// This member is required.
    public var connectionToken: Swift.String?
    /// An encrypted token originating from the interactive message of a ShowView block operation. Represents the desired view.
    /// This member is required.
    public var viewToken: Swift.String?

    public init(
        connectionToken: Swift.String? = nil,
        viewToken: Swift.String? = nil
    )
    {
        self.connectionToken = connectionToken
        self.viewToken = viewToken
    }
}

struct DescribeViewInputBody: Swift.Equatable {
}

extension DescribeViewInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeViewOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeViewOutputBody = try responseDecoder.decode(responseBody: data)
            self.view = output.view
        } else {
            self.view = nil
        }
    }
}

public struct DescribeViewOutput: Swift.Equatable {
    /// A view resource object. Contains metadata and content necessary to render the view.
    public var view: ConnectParticipantClientTypes.View?

    public init(
        view: ConnectParticipantClientTypes.View? = nil
    )
    {
        self.view = view
    }
}

struct DescribeViewOutputBody: Swift.Equatable {
    let view: ConnectParticipantClientTypes.View?
}

extension DescribeViewOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case view = "View"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let viewDecoded = try containerValues.decodeIfPresent(ConnectParticipantClientTypes.View.self, forKey: .view)
        view = viewDecoded
    }
}

enum DescribeViewOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DisconnectParticipantInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
    }
}

extension DisconnectParticipantInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let connectionToken = connectionToken {
            items.add(Header(name: "X-Amz-Bearer", value: Swift.String(connectionToken)))
        }
        return items
    }
}

extension DisconnectParticipantInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/participant/disconnect"
    }
}

public struct DisconnectParticipantInput: Swift.Equatable {
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see [Making retries safe with idempotent APIs](https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/).
    public var clientToken: Swift.String?
    /// The authentication token associated with the participant's connection.
    /// This member is required.
    public var connectionToken: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        connectionToken: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.connectionToken = connectionToken
    }
}

struct DisconnectParticipantInputBody: Swift.Equatable {
    let clientToken: Swift.String?
}

extension DisconnectParticipantInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension DisconnectParticipantOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DisconnectParticipantOutput: Swift.Equatable {

    public init() { }
}

enum DisconnectParticipantOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetAttachmentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attachmentId = "AttachmentId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attachmentId = self.attachmentId {
            try encodeContainer.encode(attachmentId, forKey: .attachmentId)
        }
    }
}

extension GetAttachmentInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let connectionToken = connectionToken {
            items.add(Header(name: "X-Amz-Bearer", value: Swift.String(connectionToken)))
        }
        return items
    }
}

extension GetAttachmentInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/participant/attachment"
    }
}

public struct GetAttachmentInput: Swift.Equatable {
    /// A unique identifier for the attachment.
    /// This member is required.
    public var attachmentId: Swift.String?
    /// The authentication token associated with the participant's connection.
    /// This member is required.
    public var connectionToken: Swift.String?

    public init(
        attachmentId: Swift.String? = nil,
        connectionToken: Swift.String? = nil
    )
    {
        self.attachmentId = attachmentId
        self.connectionToken = connectionToken
    }
}

struct GetAttachmentInputBody: Swift.Equatable {
    let attachmentId: Swift.String?
}

extension GetAttachmentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attachmentId = "AttachmentId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attachmentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .attachmentId)
        attachmentId = attachmentIdDecoded
    }
}

extension GetAttachmentOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetAttachmentOutputBody = try responseDecoder.decode(responseBody: data)
            self.url = output.url
            self.urlExpiry = output.urlExpiry
        } else {
            self.url = nil
            self.urlExpiry = nil
        }
    }
}

public struct GetAttachmentOutput: Swift.Equatable {
    /// This is the pre-signed URL that can be used for uploading the file to Amazon S3 when used in response to [StartAttachmentUpload](https://docs.aws.amazon.com/connect-participant/latest/APIReference/API_StartAttachmentUpload.html).
    public var url: Swift.String?
    /// The expiration time of the URL in ISO timestamp. It's specified in ISO 8601 format: yyyy-MM-ddThh:mm:ss.SSSZ. For example, 2019-11-08T02:41:28.172Z.
    public var urlExpiry: Swift.String?

    public init(
        url: Swift.String? = nil,
        urlExpiry: Swift.String? = nil
    )
    {
        self.url = url
        self.urlExpiry = urlExpiry
    }
}

struct GetAttachmentOutputBody: Swift.Equatable {
    let url: Swift.String?
    let urlExpiry: Swift.String?
}

extension GetAttachmentOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case url = "Url"
        case urlExpiry = "UrlExpiry"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let urlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .url)
        url = urlDecoded
        let urlExpiryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .urlExpiry)
        urlExpiry = urlExpiryDecoded
    }
}

enum GetAttachmentOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetTranscriptInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactId = "ContactId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case scanDirection = "ScanDirection"
        case sortOrder = "SortOrder"
        case startPosition = "StartPosition"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let contactId = self.contactId {
            try encodeContainer.encode(contactId, forKey: .contactId)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let scanDirection = self.scanDirection {
            try encodeContainer.encode(scanDirection.rawValue, forKey: .scanDirection)
        }
        if let sortOrder = self.sortOrder {
            try encodeContainer.encode(sortOrder.rawValue, forKey: .sortOrder)
        }
        if let startPosition = self.startPosition {
            try encodeContainer.encode(startPosition, forKey: .startPosition)
        }
    }
}

extension GetTranscriptInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let connectionToken = connectionToken {
            items.add(Header(name: "X-Amz-Bearer", value: Swift.String(connectionToken)))
        }
        return items
    }
}

extension GetTranscriptInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/participant/transcript"
    }
}

public struct GetTranscriptInput: Swift.Equatable {
    /// The authentication token associated with the participant's connection.
    /// This member is required.
    public var connectionToken: Swift.String?
    /// The contactId from the current contact chain for which transcript is needed.
    public var contactId: Swift.String?
    /// The maximum number of results to return in the page. Default: 10.
    public var maxResults: Swift.Int?
    /// The pagination token. Use the value returned previously in the next subsequent request to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The direction from StartPosition from which to retrieve message. Default: BACKWARD when no StartPosition is provided, FORWARD with StartPosition.
    public var scanDirection: ConnectParticipantClientTypes.ScanDirection?
    /// The sort order for the records. Default: DESCENDING.
    public var sortOrder: ConnectParticipantClientTypes.SortKey?
    /// A filtering option for where to start.
    public var startPosition: ConnectParticipantClientTypes.StartPosition?

    public init(
        connectionToken: Swift.String? = nil,
        contactId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        scanDirection: ConnectParticipantClientTypes.ScanDirection? = nil,
        sortOrder: ConnectParticipantClientTypes.SortKey? = nil,
        startPosition: ConnectParticipantClientTypes.StartPosition? = nil
    )
    {
        self.connectionToken = connectionToken
        self.contactId = contactId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.scanDirection = scanDirection
        self.sortOrder = sortOrder
        self.startPosition = startPosition
    }
}

struct GetTranscriptInputBody: Swift.Equatable {
    let contactId: Swift.String?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
    let scanDirection: ConnectParticipantClientTypes.ScanDirection?
    let sortOrder: ConnectParticipantClientTypes.SortKey?
    let startPosition: ConnectParticipantClientTypes.StartPosition?
}

extension GetTranscriptInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case contactId = "ContactId"
        case maxResults = "MaxResults"
        case nextToken = "NextToken"
        case scanDirection = "ScanDirection"
        case sortOrder = "SortOrder"
        case startPosition = "StartPosition"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contactIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactId)
        contactId = contactIdDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let scanDirectionDecoded = try containerValues.decodeIfPresent(ConnectParticipantClientTypes.ScanDirection.self, forKey: .scanDirection)
        scanDirection = scanDirectionDecoded
        let sortOrderDecoded = try containerValues.decodeIfPresent(ConnectParticipantClientTypes.SortKey.self, forKey: .sortOrder)
        sortOrder = sortOrderDecoded
        let startPositionDecoded = try containerValues.decodeIfPresent(ConnectParticipantClientTypes.StartPosition.self, forKey: .startPosition)
        startPosition = startPositionDecoded
    }
}

extension GetTranscriptOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetTranscriptOutputBody = try responseDecoder.decode(responseBody: data)
            self.initialContactId = output.initialContactId
            self.nextToken = output.nextToken
            self.transcript = output.transcript
        } else {
            self.initialContactId = nil
            self.nextToken = nil
            self.transcript = nil
        }
    }
}

public struct GetTranscriptOutput: Swift.Equatable {
    /// The initial contact ID for the contact.
    public var initialContactId: Swift.String?
    /// The pagination token. Use the value returned previously in the next subsequent request to retrieve the next set of results.
    public var nextToken: Swift.String?
    /// The list of messages in the session.
    public var transcript: [ConnectParticipantClientTypes.Item]?

    public init(
        initialContactId: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        transcript: [ConnectParticipantClientTypes.Item]? = nil
    )
    {
        self.initialContactId = initialContactId
        self.nextToken = nextToken
        self.transcript = transcript
    }
}

struct GetTranscriptOutputBody: Swift.Equatable {
    let initialContactId: Swift.String?
    let transcript: [ConnectParticipantClientTypes.Item]?
    let nextToken: Swift.String?
}

extension GetTranscriptOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case initialContactId = "InitialContactId"
        case nextToken = "NextToken"
        case transcript = "Transcript"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let initialContactIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .initialContactId)
        initialContactId = initialContactIdDecoded
        let transcriptContainer = try containerValues.decodeIfPresent([ConnectParticipantClientTypes.Item?].self, forKey: .transcript)
        var transcriptDecoded0:[ConnectParticipantClientTypes.Item]? = nil
        if let transcriptContainer = transcriptContainer {
            transcriptDecoded0 = [ConnectParticipantClientTypes.Item]()
            for structure0 in transcriptContainer {
                if let structure0 = structure0 {
                    transcriptDecoded0?.append(structure0)
                }
            }
        }
        transcript = transcriptDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum GetTranscriptOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension InternalServerException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// This exception occurs when there is an internal failure in the Amazon Connect service.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ConnectParticipantClientTypes.Item: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case absoluteTime = "AbsoluteTime"
        case attachments = "Attachments"
        case contactId = "ContactId"
        case content = "Content"
        case contentType = "ContentType"
        case displayName = "DisplayName"
        case id = "Id"
        case messageMetadata = "MessageMetadata"
        case participantId = "ParticipantId"
        case participantRole = "ParticipantRole"
        case relatedContactId = "RelatedContactId"
        case type = "Type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let absoluteTime = self.absoluteTime {
            try encodeContainer.encode(absoluteTime, forKey: .absoluteTime)
        }
        if let attachments = attachments {
            var attachmentsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attachments)
            for attachmentitem0 in attachments {
                try attachmentsContainer.encode(attachmentitem0)
            }
        }
        if let contactId = self.contactId {
            try encodeContainer.encode(contactId, forKey: .contactId)
        }
        if let content = self.content {
            try encodeContainer.encode(content, forKey: .content)
        }
        if let contentType = self.contentType {
            try encodeContainer.encode(contentType, forKey: .contentType)
        }
        if let displayName = self.displayName {
            try encodeContainer.encode(displayName, forKey: .displayName)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let messageMetadata = self.messageMetadata {
            try encodeContainer.encode(messageMetadata, forKey: .messageMetadata)
        }
        if let participantId = self.participantId {
            try encodeContainer.encode(participantId, forKey: .participantId)
        }
        if let participantRole = self.participantRole {
            try encodeContainer.encode(participantRole.rawValue, forKey: .participantRole)
        }
        if let relatedContactId = self.relatedContactId {
            try encodeContainer.encode(relatedContactId, forKey: .relatedContactId)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let absoluteTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .absoluteTime)
        absoluteTime = absoluteTimeDecoded
        let contentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .content)
        content = contentDecoded
        let contentTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contentType)
        contentType = contentTypeDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let typeDecoded = try containerValues.decodeIfPresent(ConnectParticipantClientTypes.ChatItemType.self, forKey: .type)
        type = typeDecoded
        let participantIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .participantId)
        participantId = participantIdDecoded
        let displayNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .displayName)
        displayName = displayNameDecoded
        let participantRoleDecoded = try containerValues.decodeIfPresent(ConnectParticipantClientTypes.ParticipantRole.self, forKey: .participantRole)
        participantRole = participantRoleDecoded
        let attachmentsContainer = try containerValues.decodeIfPresent([ConnectParticipantClientTypes.AttachmentItem?].self, forKey: .attachments)
        var attachmentsDecoded0:[ConnectParticipantClientTypes.AttachmentItem]? = nil
        if let attachmentsContainer = attachmentsContainer {
            attachmentsDecoded0 = [ConnectParticipantClientTypes.AttachmentItem]()
            for structure0 in attachmentsContainer {
                if let structure0 = structure0 {
                    attachmentsDecoded0?.append(structure0)
                }
            }
        }
        attachments = attachmentsDecoded0
        let messageMetadataDecoded = try containerValues.decodeIfPresent(ConnectParticipantClientTypes.MessageMetadata.self, forKey: .messageMetadata)
        messageMetadata = messageMetadataDecoded
        let relatedContactIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .relatedContactId)
        relatedContactId = relatedContactIdDecoded
        let contactIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contactId)
        contactId = contactIdDecoded
    }
}

extension ConnectParticipantClientTypes {
    /// An item - message or event - that has been sent.
    public struct Item: Swift.Equatable {
        /// The time when the message or event was sent. It's specified in ISO 8601 format: yyyy-MM-ddThh:mm:ss.SSSZ. For example, 2019-11-08T02:41:28.172Z.
        public var absoluteTime: Swift.String?
        /// Provides information about the attachments.
        public var attachments: [ConnectParticipantClientTypes.AttachmentItem]?
        /// The contactId on which the transcript item was originally sent. This field is populated only when the transcript item is from the current chat session.
        public var contactId: Swift.String?
        /// The content of the message or event.
        public var content: Swift.String?
        /// The type of content of the item.
        public var contentType: Swift.String?
        /// The chat display name of the sender.
        public var displayName: Swift.String?
        /// The ID of the item.
        public var id: Swift.String?
        /// The metadata related to the message. Currently this supports only information related to message receipts.
        public var messageMetadata: ConnectParticipantClientTypes.MessageMetadata?
        /// The ID of the sender in the session.
        public var participantId: Swift.String?
        /// The role of the sender. For example, is it a customer, agent, or system.
        public var participantRole: ConnectParticipantClientTypes.ParticipantRole?
        /// The contactId on which the transcript item was originally sent. This field is only populated for persistent chats when the transcript item is from the past chat session. For more information, see [Enable persistent chat](https://docs.aws.amazon.com/connect/latest/adminguide/chat-persistence.html).
        public var relatedContactId: Swift.String?
        /// Type of the item: message or event.
        public var type: ConnectParticipantClientTypes.ChatItemType?

        public init(
            absoluteTime: Swift.String? = nil,
            attachments: [ConnectParticipantClientTypes.AttachmentItem]? = nil,
            contactId: Swift.String? = nil,
            content: Swift.String? = nil,
            contentType: Swift.String? = nil,
            displayName: Swift.String? = nil,
            id: Swift.String? = nil,
            messageMetadata: ConnectParticipantClientTypes.MessageMetadata? = nil,
            participantId: Swift.String? = nil,
            participantRole: ConnectParticipantClientTypes.ParticipantRole? = nil,
            relatedContactId: Swift.String? = nil,
            type: ConnectParticipantClientTypes.ChatItemType? = nil
        )
        {
            self.absoluteTime = absoluteTime
            self.attachments = attachments
            self.contactId = contactId
            self.content = content
            self.contentType = contentType
            self.displayName = displayName
            self.id = id
            self.messageMetadata = messageMetadata
            self.participantId = participantId
            self.participantRole = participantRole
            self.relatedContactId = relatedContactId
            self.type = type
        }
    }

}

extension ConnectParticipantClientTypes.MessageMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case messageId = "MessageId"
        case receipts = "Receipts"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let messageId = self.messageId {
            try encodeContainer.encode(messageId, forKey: .messageId)
        }
        if let receipts = receipts {
            var receiptsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .receipts)
            for receipt0 in receipts {
                try receiptsContainer.encode(receipt0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .messageId)
        messageId = messageIdDecoded
        let receiptsContainer = try containerValues.decodeIfPresent([ConnectParticipantClientTypes.Receipt?].self, forKey: .receipts)
        var receiptsDecoded0:[ConnectParticipantClientTypes.Receipt]? = nil
        if let receiptsContainer = receiptsContainer {
            receiptsDecoded0 = [ConnectParticipantClientTypes.Receipt]()
            for structure0 in receiptsContainer {
                if let structure0 = structure0 {
                    receiptsDecoded0?.append(structure0)
                }
            }
        }
        receipts = receiptsDecoded0
    }
}

extension ConnectParticipantClientTypes {
    /// Contains metadata related to a message.
    public struct MessageMetadata: Swift.Equatable {
        /// The identifier of the message that contains the metadata information.
        public var messageId: Swift.String?
        /// The list of receipt information for a message for different recipients.
        public var receipts: [ConnectParticipantClientTypes.Receipt]?

        public init(
            messageId: Swift.String? = nil,
            receipts: [ConnectParticipantClientTypes.Receipt]? = nil
        )
        {
            self.messageId = messageId
            self.receipts = receipts
        }
    }

}

extension ConnectParticipantClientTypes {
    public enum ParticipantRole: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case agent
        case customer
        case customBot
        case system
        case sdkUnknown(Swift.String)

        public static var allCases: [ParticipantRole] {
            return [
                .agent,
                .customer,
                .customBot,
                .system,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .agent: return "AGENT"
            case .customer: return "CUSTOMER"
            case .customBot: return "CUSTOM_BOT"
            case .system: return "SYSTEM"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ParticipantRole(rawValue: rawValue) ?? ParticipantRole.sdkUnknown(rawValue)
        }
    }
}

extension ConnectParticipantClientTypes.Receipt: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deliveredTimestamp = "DeliveredTimestamp"
        case readTimestamp = "ReadTimestamp"
        case recipientParticipantId = "RecipientParticipantId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deliveredTimestamp = self.deliveredTimestamp {
            try encodeContainer.encode(deliveredTimestamp, forKey: .deliveredTimestamp)
        }
        if let readTimestamp = self.readTimestamp {
            try encodeContainer.encode(readTimestamp, forKey: .readTimestamp)
        }
        if let recipientParticipantId = self.recipientParticipantId {
            try encodeContainer.encode(recipientParticipantId, forKey: .recipientParticipantId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deliveredTimestampDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deliveredTimestamp)
        deliveredTimestamp = deliveredTimestampDecoded
        let readTimestampDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .readTimestamp)
        readTimestamp = readTimestampDecoded
        let recipientParticipantIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .recipientParticipantId)
        recipientParticipantId = recipientParticipantIdDecoded
    }
}

extension ConnectParticipantClientTypes {
    /// The receipt for the message delivered to the recipient.
    public struct Receipt: Swift.Equatable {
        /// The time when the message was delivered to the recipient.
        public var deliveredTimestamp: Swift.String?
        /// The time when the message was read by the recipient.
        public var readTimestamp: Swift.String?
        /// The identifier of the recipient of the message.
        public var recipientParticipantId: Swift.String?

        public init(
            deliveredTimestamp: Swift.String? = nil,
            readTimestamp: Swift.String? = nil,
            recipientParticipantId: Swift.String? = nil
        )
        {
            self.deliveredTimestamp = deliveredTimestamp
            self.readTimestamp = readTimestamp
            self.recipientParticipantId = recipientParticipantId
        }
    }

}

extension ResourceNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.resourceId = output.resourceId
            self.properties.resourceType = output.resourceType
        } else {
            self.properties.message = nil
            self.properties.resourceId = nil
            self.properties.resourceType = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The resource was not found.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        /// The identifier of the resource.
        public internal(set) var resourceId: Swift.String? = nil
        /// The type of Amazon Connect resource.
        public internal(set) var resourceType: ConnectParticipantClientTypes.ResourceType? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: ConnectParticipantClientTypes.ResourceType? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceId: Swift.String?
    let resourceType: ConnectParticipantClientTypes.ResourceType?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
        case resourceId = "ResourceId"
        case resourceType = "ResourceType"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(ConnectParticipantClientTypes.ResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension ConnectParticipantClientTypes {
    public enum ResourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case contact
        case contactFlow
        case hierarchyGroup
        case hierarchyLevel
        case instance
        case participant
        case user
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceType] {
            return [
                .contact,
                .contactFlow,
                .hierarchyGroup,
                .hierarchyLevel,
                .instance,
                .participant,
                .user,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .contact: return "CONTACT"
            case .contactFlow: return "CONTACT_FLOW"
            case .hierarchyGroup: return "HIERARCHY_GROUP"
            case .hierarchyLevel: return "HIERARCHY_LEVEL"
            case .instance: return "INSTANCE"
            case .participant: return "PARTICIPANT"
            case .user: return "USER"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResourceType(rawValue: rawValue) ?? ResourceType.sdkUnknown(rawValue)
        }
    }
}

extension ConnectParticipantClientTypes {
    public enum ScanDirection: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case backward
        case forward
        case sdkUnknown(Swift.String)

        public static var allCases: [ScanDirection] {
            return [
                .backward,
                .forward,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .backward: return "BACKWARD"
            case .forward: return "FORWARD"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ScanDirection(rawValue: rawValue) ?? ScanDirection.sdkUnknown(rawValue)
        }
    }
}

extension SendEventInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case content = "Content"
        case contentType = "ContentType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let content = self.content {
            try encodeContainer.encode(content, forKey: .content)
        }
        if let contentType = self.contentType {
            try encodeContainer.encode(contentType, forKey: .contentType)
        }
    }
}

extension SendEventInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let connectionToken = connectionToken {
            items.add(Header(name: "X-Amz-Bearer", value: Swift.String(connectionToken)))
        }
        return items
    }
}

extension SendEventInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/participant/event"
    }
}

public struct SendEventInput: Swift.Equatable {
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see [Making retries safe with idempotent APIs](https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/).
    public var clientToken: Swift.String?
    /// The authentication token associated with the participant's connection.
    /// This member is required.
    public var connectionToken: Swift.String?
    /// The content of the event to be sent (for example, message text). For content related to message receipts, this is supported in the form of a JSON string. Sample Content: "{\"messageId\":\"11111111-aaaa-bbbb-cccc-EXAMPLE01234\"}"
    public var content: Swift.String?
    /// The content type of the request. Supported types are:
    ///
    /// * application/vnd.amazonaws.connect.event.typing
    ///
    /// * application/vnd.amazonaws.connect.event.connection.acknowledged
    ///
    /// * application/vnd.amazonaws.connect.event.message.delivered
    ///
    /// * application/vnd.amazonaws.connect.event.message.read
    /// This member is required.
    public var contentType: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        connectionToken: Swift.String? = nil,
        content: Swift.String? = nil,
        contentType: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.connectionToken = connectionToken
        self.content = content
        self.contentType = contentType
    }
}

struct SendEventInputBody: Swift.Equatable {
    let contentType: Swift.String?
    let content: Swift.String?
    let clientToken: Swift.String?
}

extension SendEventInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case content = "Content"
        case contentType = "ContentType"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contentType)
        contentType = contentTypeDecoded
        let contentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .content)
        content = contentDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension SendEventOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: SendEventOutputBody = try responseDecoder.decode(responseBody: data)
            self.absoluteTime = output.absoluteTime
            self.id = output.id
        } else {
            self.absoluteTime = nil
            self.id = nil
        }
    }
}

public struct SendEventOutput: Swift.Equatable {
    /// The time when the event was sent. It's specified in ISO 8601 format: yyyy-MM-ddThh:mm:ss.SSSZ. For example, 2019-11-08T02:41:28.172Z.
    public var absoluteTime: Swift.String?
    /// The ID of the response.
    public var id: Swift.String?

    public init(
        absoluteTime: Swift.String? = nil,
        id: Swift.String? = nil
    )
    {
        self.absoluteTime = absoluteTime
        self.id = id
    }
}

struct SendEventOutputBody: Swift.Equatable {
    let id: Swift.String?
    let absoluteTime: Swift.String?
}

extension SendEventOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case absoluteTime = "AbsoluteTime"
        case id = "Id"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let absoluteTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .absoluteTime)
        absoluteTime = absoluteTimeDecoded
    }
}

enum SendEventOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension SendMessageInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case content = "Content"
        case contentType = "ContentType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let content = self.content {
            try encodeContainer.encode(content, forKey: .content)
        }
        if let contentType = self.contentType {
            try encodeContainer.encode(contentType, forKey: .contentType)
        }
    }
}

extension SendMessageInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let connectionToken = connectionToken {
            items.add(Header(name: "X-Amz-Bearer", value: Swift.String(connectionToken)))
        }
        return items
    }
}

extension SendMessageInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/participant/message"
    }
}

public struct SendMessageInput: Swift.Equatable {
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see [Making retries safe with idempotent APIs](https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/).
    public var clientToken: Swift.String?
    /// The authentication token associated with the connection.
    /// This member is required.
    public var connectionToken: Swift.String?
    /// The content of the message.
    ///
    /// * For text/plain and text/markdown, the Length Constraints are Minimum of 1, Maximum of 1024.
    ///
    /// * For application/json, the Length Constraints are Minimum of 1, Maximum of 12000.
    ///
    /// * For application/vnd.amazonaws.connect.message.interactive.response, the Length Constraints are Minimum of 1, Maximum of 12288.
    /// This member is required.
    public var content: Swift.String?
    /// The type of the content. Supported types are text/plain, text/markdown, application/json, and application/vnd.amazonaws.connect.message.interactive.response.
    /// This member is required.
    public var contentType: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        connectionToken: Swift.String? = nil,
        content: Swift.String? = nil,
        contentType: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.connectionToken = connectionToken
        self.content = content
        self.contentType = contentType
    }
}

struct SendMessageInputBody: Swift.Equatable {
    let contentType: Swift.String?
    let content: Swift.String?
    let clientToken: Swift.String?
}

extension SendMessageInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "ClientToken"
        case content = "Content"
        case contentType = "ContentType"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contentType)
        contentType = contentTypeDecoded
        let contentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .content)
        content = contentDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension SendMessageOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: SendMessageOutputBody = try responseDecoder.decode(responseBody: data)
            self.absoluteTime = output.absoluteTime
            self.id = output.id
        } else {
            self.absoluteTime = nil
            self.id = nil
        }
    }
}

public struct SendMessageOutput: Swift.Equatable {
    /// The time when the message was sent. It's specified in ISO 8601 format: yyyy-MM-ddThh:mm:ss.SSSZ. For example, 2019-11-08T02:41:28.172Z.
    public var absoluteTime: Swift.String?
    /// The ID of the message.
    public var id: Swift.String?

    public init(
        absoluteTime: Swift.String? = nil,
        id: Swift.String? = nil
    )
    {
        self.absoluteTime = absoluteTime
        self.id = id
    }
}

struct SendMessageOutputBody: Swift.Equatable {
    let id: Swift.String?
    let absoluteTime: Swift.String?
}

extension SendMessageOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case absoluteTime = "AbsoluteTime"
        case id = "Id"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let absoluteTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .absoluteTime)
        absoluteTime = absoluteTimeDecoded
    }
}

enum SendMessageOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ServiceQuotaExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The number of attachments per contact exceeds the quota.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ConnectParticipantClientTypes {
    public enum SortKey: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ascending
        case descending
        case sdkUnknown(Swift.String)

        public static var allCases: [SortKey] {
            return [
                .ascending,
                .descending,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ascending: return "ASCENDING"
            case .descending: return "DESCENDING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SortKey(rawValue: rawValue) ?? SortKey.sdkUnknown(rawValue)
        }
    }
}

extension StartAttachmentUploadInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attachmentName = "AttachmentName"
        case attachmentSizeInBytes = "AttachmentSizeInBytes"
        case clientToken = "ClientToken"
        case contentType = "ContentType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attachmentName = self.attachmentName {
            try encodeContainer.encode(attachmentName, forKey: .attachmentName)
        }
        if let attachmentSizeInBytes = self.attachmentSizeInBytes {
            try encodeContainer.encode(attachmentSizeInBytes, forKey: .attachmentSizeInBytes)
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let contentType = self.contentType {
            try encodeContainer.encode(contentType, forKey: .contentType)
        }
    }
}

extension StartAttachmentUploadInput: ClientRuntime.HeaderProvider {
    public var headers: ClientRuntime.Headers {
        var items = ClientRuntime.Headers()
        if let connectionToken = connectionToken {
            items.add(Header(name: "X-Amz-Bearer", value: Swift.String(connectionToken)))
        }
        return items
    }
}

extension StartAttachmentUploadInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/participant/start-attachment-upload"
    }
}

public struct StartAttachmentUploadInput: Swift.Equatable {
    /// A case-sensitive name of the attachment being uploaded.
    /// This member is required.
    public var attachmentName: Swift.String?
    /// The size of the attachment in bytes.
    /// This member is required.
    public var attachmentSizeInBytes: Swift.Int?
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. If not provided, the Amazon Web Services SDK populates this field. For more information about idempotency, see [Making retries safe with idempotent APIs](https://aws.amazon.com/builders-library/making-retries-safe-with-idempotent-APIs/).
    /// This member is required.
    public var clientToken: Swift.String?
    /// The authentication token associated with the participant's connection.
    /// This member is required.
    public var connectionToken: Swift.String?
    /// Describes the MIME file type of the attachment. For a list of supported file types, see [Feature specifications](https://docs.aws.amazon.com/connect/latest/adminguide/feature-limits.html) in the Amazon Connect Administrator Guide.
    /// This member is required.
    public var contentType: Swift.String?

    public init(
        attachmentName: Swift.String? = nil,
        attachmentSizeInBytes: Swift.Int? = nil,
        clientToken: Swift.String? = nil,
        connectionToken: Swift.String? = nil,
        contentType: Swift.String? = nil
    )
    {
        self.attachmentName = attachmentName
        self.attachmentSizeInBytes = attachmentSizeInBytes
        self.clientToken = clientToken
        self.connectionToken = connectionToken
        self.contentType = contentType
    }
}

struct StartAttachmentUploadInputBody: Swift.Equatable {
    let contentType: Swift.String?
    let attachmentSizeInBytes: Swift.Int?
    let attachmentName: Swift.String?
    let clientToken: Swift.String?
}

extension StartAttachmentUploadInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attachmentName = "AttachmentName"
        case attachmentSizeInBytes = "AttachmentSizeInBytes"
        case clientToken = "ClientToken"
        case contentType = "ContentType"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let contentTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .contentType)
        contentType = contentTypeDecoded
        let attachmentSizeInBytesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .attachmentSizeInBytes)
        attachmentSizeInBytes = attachmentSizeInBytesDecoded
        let attachmentNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .attachmentName)
        attachmentName = attachmentNameDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension StartAttachmentUploadOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StartAttachmentUploadOutputBody = try responseDecoder.decode(responseBody: data)
            self.attachmentId = output.attachmentId
            self.uploadMetadata = output.uploadMetadata
        } else {
            self.attachmentId = nil
            self.uploadMetadata = nil
        }
    }
}

public struct StartAttachmentUploadOutput: Swift.Equatable {
    /// A unique identifier for the attachment.
    public var attachmentId: Swift.String?
    /// Fields to be used while uploading the attachment.
    public var uploadMetadata: ConnectParticipantClientTypes.UploadMetadata?

    public init(
        attachmentId: Swift.String? = nil,
        uploadMetadata: ConnectParticipantClientTypes.UploadMetadata? = nil
    )
    {
        self.attachmentId = attachmentId
        self.uploadMetadata = uploadMetadata
    }
}

struct StartAttachmentUploadOutputBody: Swift.Equatable {
    let attachmentId: Swift.String?
    let uploadMetadata: ConnectParticipantClientTypes.UploadMetadata?
}

extension StartAttachmentUploadOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attachmentId = "AttachmentId"
        case uploadMetadata = "UploadMetadata"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attachmentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .attachmentId)
        attachmentId = attachmentIdDecoded
        let uploadMetadataDecoded = try containerValues.decodeIfPresent(ConnectParticipantClientTypes.UploadMetadata.self, forKey: .uploadMetadata)
        uploadMetadata = uploadMetadataDecoded
    }
}

enum StartAttachmentUploadOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ConnectParticipantClientTypes.StartPosition: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case absoluteTime = "AbsoluteTime"
        case id = "Id"
        case mostRecent = "MostRecent"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let absoluteTime = self.absoluteTime {
            try encodeContainer.encode(absoluteTime, forKey: .absoluteTime)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if mostRecent != 0 {
            try encodeContainer.encode(mostRecent, forKey: .mostRecent)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let absoluteTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .absoluteTime)
        absoluteTime = absoluteTimeDecoded
        let mostRecentDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .mostRecent) ?? 0
        mostRecent = mostRecentDecoded
    }
}

extension ConnectParticipantClientTypes {
    /// A filtering option for where to start. For example, if you sent 100 messages, start with message 50.
    public struct StartPosition: Swift.Equatable {
        /// The time in ISO format where to start. It's specified in ISO 8601 format: yyyy-MM-ddThh:mm:ss.SSSZ. For example, 2019-11-08T02:41:28.172Z.
        public var absoluteTime: Swift.String?
        /// The ID of the message or event where to start.
        public var id: Swift.String?
        /// The start position of the most recent message where you want to start.
        public var mostRecent: Swift.Int

        public init(
            absoluteTime: Swift.String? = nil,
            id: Swift.String? = nil,
            mostRecent: Swift.Int = 0
        )
        {
            self.absoluteTime = absoluteTime
            self.id = id
            self.mostRecent = mostRecent
        }
    }

}

extension ThrottlingException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request was denied due to request throttling.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ConnectParticipantClientTypes.UploadMetadata: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case headersToInclude = "HeadersToInclude"
        case url = "Url"
        case urlExpiry = "UrlExpiry"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let headersToInclude = headersToInclude {
            var headersToIncludeContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .headersToInclude)
            for (dictKey0, uploadMetadataSignedHeaders0) in headersToInclude {
                try headersToIncludeContainer.encode(uploadMetadataSignedHeaders0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let url = self.url {
            try encodeContainer.encode(url, forKey: .url)
        }
        if let urlExpiry = self.urlExpiry {
            try encodeContainer.encode(urlExpiry, forKey: .urlExpiry)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let urlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .url)
        url = urlDecoded
        let urlExpiryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .urlExpiry)
        urlExpiry = urlExpiryDecoded
        let headersToIncludeContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .headersToInclude)
        var headersToIncludeDecoded0: [Swift.String:Swift.String]? = nil
        if let headersToIncludeContainer = headersToIncludeContainer {
            headersToIncludeDecoded0 = [Swift.String:Swift.String]()
            for (key0, uploadmetadatasignedheadersvalue0) in headersToIncludeContainer {
                if let uploadmetadatasignedheadersvalue0 = uploadmetadatasignedheadersvalue0 {
                    headersToIncludeDecoded0?[key0] = uploadmetadatasignedheadersvalue0
                }
            }
        }
        headersToInclude = headersToIncludeDecoded0
    }
}

extension ConnectParticipantClientTypes {
    /// Fields to be used while uploading the attachment.
    public struct UploadMetadata: Swift.Equatable {
        /// The headers to be provided while uploading the file to the URL.
        public var headersToInclude: [Swift.String:Swift.String]?
        /// This is the pre-signed URL that can be used for uploading the file to Amazon S3 when used in response to [StartAttachmentUpload](https://docs.aws.amazon.com/connect-participant/latest/APIReference/API_StartAttachmentUpload.html).
        public var url: Swift.String?
        /// The expiration time of the URL in ISO timestamp. It's specified in ISO 8601 format: yyyy-MM-ddThh:mm:ss.SSSZ. For example, 2019-11-08T02:41:28.172Z.
        public var urlExpiry: Swift.String?

        public init(
            headersToInclude: [Swift.String:Swift.String]? = nil,
            url: Swift.String? = nil,
            urlExpiry: Swift.String? = nil
        )
        {
            self.headersToInclude = headersToInclude
            self.url = url
            self.urlExpiry = urlExpiry
        }
    }

}

extension ValidationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The input fails to satisfy the constraints specified by Amazon Connect.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "Message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ConnectParticipantClientTypes.View: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "Arn"
        case content = "Content"
        case id = "Id"
        case name = "Name"
        case version = "Version"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let content = self.content {
            try encodeContainer.encode(content, forKey: .content)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let version = self.version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .version)
        version = versionDecoded
        let contentDecoded = try containerValues.decodeIfPresent(ConnectParticipantClientTypes.ViewContent.self, forKey: .content)
        content = contentDecoded
    }
}

extension ConnectParticipantClientTypes.View: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "View(arn: \(Swift.String(describing: arn)), content: \(Swift.String(describing: content)), id: \(Swift.String(describing: id)), version: \(Swift.String(describing: version)), name: \"CONTENT_REDACTED\")"}
}

extension ConnectParticipantClientTypes {
    /// A view resource object. Contains metadata and content necessary to render the view.
    public struct View: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the view.
        public var arn: Swift.String?
        /// View content containing all content necessary to render a view except for runtime input data.
        public var content: ConnectParticipantClientTypes.ViewContent?
        /// The identifier of the view.
        public var id: Swift.String?
        /// The name of the view.
        public var name: Swift.String?
        /// The current version of the view.
        public var version: Swift.Int?

        public init(
            arn: Swift.String? = nil,
            content: ConnectParticipantClientTypes.ViewContent? = nil,
            id: Swift.String? = nil,
            name: Swift.String? = nil,
            version: Swift.Int? = nil
        )
        {
            self.arn = arn
            self.content = content
            self.id = id
            self.name = name
            self.version = version
        }
    }

}

extension ConnectParticipantClientTypes.ViewContent: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actions = "Actions"
        case inputSchema = "InputSchema"
        case template = "Template"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actions = actions {
            var actionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .actions)
            for viewaction0 in actions {
                try actionsContainer.encode(viewaction0)
            }
        }
        if let inputSchema = self.inputSchema {
            try encodeContainer.encode(inputSchema, forKey: .inputSchema)
        }
        if let template = self.template {
            try encodeContainer.encode(template, forKey: .template)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let inputSchemaDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .inputSchema)
        inputSchema = inputSchemaDecoded
        let templateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .template)
        template = templateDecoded
        let actionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .actions)
        var actionsDecoded0:[Swift.String]? = nil
        if let actionsContainer = actionsContainer {
            actionsDecoded0 = [Swift.String]()
            for string0 in actionsContainer {
                if let string0 = string0 {
                    actionsDecoded0?.append(string0)
                }
            }
        }
        actions = actionsDecoded0
    }
}

extension ConnectParticipantClientTypes.ViewContent: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ViewContent(actions: \(Swift.String(describing: actions)), inputSchema: \"CONTENT_REDACTED\", template: \"CONTENT_REDACTED\")"}
}

extension ConnectParticipantClientTypes {
    /// View content containing all content necessary to render a view except for runtime input data.
    public struct ViewContent: Swift.Equatable {
        /// A list of actions possible from the view
        public var actions: [Swift.String]?
        /// The schema representing the input data that the view template must be supplied to render.
        public var inputSchema: Swift.String?
        /// The view template representing the structure of the view.
        public var template: Swift.String?

        public init(
            actions: [Swift.String]? = nil,
            inputSchema: Swift.String? = nil,
            template: Swift.String? = nil
        )
        {
            self.actions = actions
            self.inputSchema = inputSchema
            self.template = template
        }
    }

}

extension ConnectParticipantClientTypes.Websocket: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case connectionExpiry = "ConnectionExpiry"
        case url = "Url"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let connectionExpiry = self.connectionExpiry {
            try encodeContainer.encode(connectionExpiry, forKey: .connectionExpiry)
        }
        if let url = self.url {
            try encodeContainer.encode(url, forKey: .url)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let urlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .url)
        url = urlDecoded
        let connectionExpiryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectionExpiry)
        connectionExpiry = connectionExpiryDecoded
    }
}

extension ConnectParticipantClientTypes {
    /// The websocket for the participant's connection.
    public struct Websocket: Swift.Equatable {
        /// The URL expiration timestamp in ISO date format. It's specified in ISO 8601 format: yyyy-MM-ddThh:mm:ss.SSSZ. For example, 2019-11-08T02:41:28.172Z.
        public var connectionExpiry: Swift.String?
        /// The URL of the websocket.
        public var url: Swift.String?

        public init(
            connectionExpiry: Swift.String? = nil,
            url: Swift.String? = nil
        )
        {
            self.connectionExpiry = connectionExpiry
            self.url = url
        }
    }

}
