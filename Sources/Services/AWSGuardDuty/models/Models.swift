// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AcceptAdministratorInvitationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case administratorId = "administratorId"
        case invitationId = "invitationId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let administratorId = self.administratorId {
            try encodeContainer.encode(administratorId, forKey: .administratorId)
        }
        if let invitationId = self.invitationId {
            try encodeContainer.encode(invitationId, forKey: .invitationId)
        }
    }
}

extension AcceptAdministratorInvitationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let detectorId = detectorId else {
            return nil
        }
        return "/detector/\(detectorId.urlPercentEncoding())/administrator"
    }
}

public struct AcceptAdministratorInvitationInput: Swift.Equatable {
    /// The account ID of the GuardDuty administrator account whose invitation you're accepting.
    /// This member is required.
    public var administratorId: Swift.String?
    /// The unique ID of the detector of the GuardDuty member account.
    /// This member is required.
    public var detectorId: Swift.String?
    /// The value that is used to validate the administrator account to the member account.
    /// This member is required.
    public var invitationId: Swift.String?

    public init(
        administratorId: Swift.String? = nil,
        detectorId: Swift.String? = nil,
        invitationId: Swift.String? = nil
    )
    {
        self.administratorId = administratorId
        self.detectorId = detectorId
        self.invitationId = invitationId
    }
}

struct AcceptAdministratorInvitationInputBody: Swift.Equatable {
    let administratorId: Swift.String?
    let invitationId: Swift.String?
}

extension AcceptAdministratorInvitationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case administratorId = "administratorId"
        case invitationId = "invitationId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let administratorIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .administratorId)
        administratorId = administratorIdDecoded
        let invitationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .invitationId)
        invitationId = invitationIdDecoded
    }
}

extension AcceptAdministratorInvitationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct AcceptAdministratorInvitationOutput: Swift.Equatable {

    public init() { }
}

enum AcceptAdministratorInvitationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension AcceptInvitationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case invitationId = "invitationId"
        case masterId = "masterId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let invitationId = self.invitationId {
            try encodeContainer.encode(invitationId, forKey: .invitationId)
        }
        if let masterId = self.masterId {
            try encodeContainer.encode(masterId, forKey: .masterId)
        }
    }
}

extension AcceptInvitationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let detectorId = detectorId else {
            return nil
        }
        return "/detector/\(detectorId.urlPercentEncoding())/master"
    }
}

@available(*, deprecated, message: "This input is deprecated, use AcceptAdministratorInvitationRequest instead")
public struct AcceptInvitationInput: Swift.Equatable {
    /// The unique ID of the detector of the GuardDuty member account.
    /// This member is required.
    public var detectorId: Swift.String?
    /// The value that is used to validate the administrator account to the member account.
    /// This member is required.
    public var invitationId: Swift.String?
    /// The account ID of the GuardDuty administrator account whose invitation you're accepting.
    /// This member is required.
    public var masterId: Swift.String?

    public init(
        detectorId: Swift.String? = nil,
        invitationId: Swift.String? = nil,
        masterId: Swift.String? = nil
    )
    {
        self.detectorId = detectorId
        self.invitationId = invitationId
        self.masterId = masterId
    }
}

struct AcceptInvitationInputBody: Swift.Equatable {
    let masterId: Swift.String?
    let invitationId: Swift.String?
}

extension AcceptInvitationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case invitationId = "invitationId"
        case masterId = "masterId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let masterIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .masterId)
        masterId = masterIdDecoded
        let invitationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .invitationId)
        invitationId = invitationIdDecoded
    }
}

extension AcceptInvitationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

@available(*, deprecated, message: "This output is deprecated, use AcceptAdministratorInvitationResponse instead")
public struct AcceptInvitationOutput: Swift.Equatable {

    public init() { }
}

enum AcceptInvitationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GuardDutyClientTypes.AccessControlList: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowsPublicReadAccess = "allowsPublicReadAccess"
        case allowsPublicWriteAccess = "allowsPublicWriteAccess"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if allowsPublicReadAccess != false {
            try encodeContainer.encode(allowsPublicReadAccess, forKey: .allowsPublicReadAccess)
        }
        if allowsPublicWriteAccess != false {
            try encodeContainer.encode(allowsPublicWriteAccess, forKey: .allowsPublicWriteAccess)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let allowsPublicReadAccessDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .allowsPublicReadAccess) ?? false
        allowsPublicReadAccess = allowsPublicReadAccessDecoded
        let allowsPublicWriteAccessDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .allowsPublicWriteAccess) ?? false
        allowsPublicWriteAccess = allowsPublicWriteAccessDecoded
    }
}

extension GuardDutyClientTypes {
    /// Contains information on the current access control policies for the bucket.
    public struct AccessControlList: Swift.Equatable {
        /// A value that indicates whether public read access for the bucket is enabled through an Access Control List (ACL).
        public var allowsPublicReadAccess: Swift.Bool
        /// A value that indicates whether public write access for the bucket is enabled through an Access Control List (ACL).
        public var allowsPublicWriteAccess: Swift.Bool

        public init(
            allowsPublicReadAccess: Swift.Bool = false,
            allowsPublicWriteAccess: Swift.Bool = false
        )
        {
            self.allowsPublicReadAccess = allowsPublicReadAccess
            self.allowsPublicWriteAccess = allowsPublicWriteAccess
        }
    }

}

extension AccessDeniedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.type = output.type
        } else {
            self.properties.message = nil
            self.properties.type = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// An access denied exception object.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The error message.
        public internal(set) var message: Swift.String? = nil
        /// The error type.
        public internal(set) var type: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.type = type
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let type: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "message"
        case type = "__type"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
    }
}

extension GuardDutyClientTypes.AccessKeyDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessKeyId = "accessKeyId"
        case principalId = "principalId"
        case userName = "userName"
        case userType = "userType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessKeyId = self.accessKeyId {
            try encodeContainer.encode(accessKeyId, forKey: .accessKeyId)
        }
        if let principalId = self.principalId {
            try encodeContainer.encode(principalId, forKey: .principalId)
        }
        if let userName = self.userName {
            try encodeContainer.encode(userName, forKey: .userName)
        }
        if let userType = self.userType {
            try encodeContainer.encode(userType, forKey: .userType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accessKeyId)
        accessKeyId = accessKeyIdDecoded
        let principalIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .principalId)
        principalId = principalIdDecoded
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
        let userTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userType)
        userType = userTypeDecoded
    }
}

extension GuardDutyClientTypes {
    /// Contains information about the access keys.
    public struct AccessKeyDetails: Swift.Equatable {
        /// The access key ID of the user.
        public var accessKeyId: Swift.String?
        /// The principal ID of the user.
        public var principalId: Swift.String?
        /// The name of the user.
        public var userName: Swift.String?
        /// The type of the user.
        public var userType: Swift.String?

        public init(
            accessKeyId: Swift.String? = nil,
            principalId: Swift.String? = nil,
            userName: Swift.String? = nil,
            userType: Swift.String? = nil
        )
        {
            self.accessKeyId = accessKeyId
            self.principalId = principalId
            self.userName = userName
            self.userType = userType
        }
    }

}

extension GuardDutyClientTypes.AccountDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "accountId"
        case email = "email"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let email = self.email {
            try encodeContainer.encode(email, forKey: .email)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let emailDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .email)
        email = emailDecoded
    }
}

extension GuardDutyClientTypes {
    /// Contains information about the account.
    public struct AccountDetail: Swift.Equatable {
        /// The member account ID.
        /// This member is required.
        public var accountId: Swift.String?
        /// The email address of the member account.
        /// This member is required.
        public var email: Swift.String?

        public init(
            accountId: Swift.String? = nil,
            email: Swift.String? = nil
        )
        {
            self.accountId = accountId
            self.email = email
        }
    }

}

extension GuardDutyClientTypes.AccountFreeTrialInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "accountId"
        case dataSources = "dataSources"
        case features = "features"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let dataSources = self.dataSources {
            try encodeContainer.encode(dataSources, forKey: .dataSources)
        }
        if let features = features {
            var featuresContainer = encodeContainer.nestedUnkeyedContainer(forKey: .features)
            for freetrialfeatureconfigurationresult0 in features {
                try featuresContainer.encode(freetrialfeatureconfigurationresult0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let dataSourcesDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.DataSourcesFreeTrial.self, forKey: .dataSources)
        dataSources = dataSourcesDecoded
        let featuresContainer = try containerValues.decodeIfPresent([GuardDutyClientTypes.FreeTrialFeatureConfigurationResult?].self, forKey: .features)
        var featuresDecoded0:[GuardDutyClientTypes.FreeTrialFeatureConfigurationResult]? = nil
        if let featuresContainer = featuresContainer {
            featuresDecoded0 = [GuardDutyClientTypes.FreeTrialFeatureConfigurationResult]()
            for structure0 in featuresContainer {
                if let structure0 = structure0 {
                    featuresDecoded0?.append(structure0)
                }
            }
        }
        features = featuresDecoded0
    }
}

extension GuardDutyClientTypes {
    /// Provides details of the GuardDuty member account that uses a free trial service.
    public struct AccountFreeTrialInfo: Swift.Equatable {
        /// The account identifier of the GuardDuty member account.
        public var accountId: Swift.String?
        /// Describes the data source enabled for the GuardDuty member account.
        @available(*, deprecated, message: "This parameter is deprecated, use Features instead")
        public var dataSources: GuardDutyClientTypes.DataSourcesFreeTrial?
        /// A list of features enabled for the GuardDuty account.
        public var features: [GuardDutyClientTypes.FreeTrialFeatureConfigurationResult]?

        public init(
            accountId: Swift.String? = nil,
            dataSources: GuardDutyClientTypes.DataSourcesFreeTrial? = nil,
            features: [GuardDutyClientTypes.FreeTrialFeatureConfigurationResult]? = nil
        )
        {
            self.accountId = accountId
            self.dataSources = dataSources
            self.features = features
        }
    }

}

extension GuardDutyClientTypes.AccountLevelPermissions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case blockPublicAccess = "blockPublicAccess"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let blockPublicAccess = self.blockPublicAccess {
            try encodeContainer.encode(blockPublicAccess, forKey: .blockPublicAccess)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let blockPublicAccessDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.BlockPublicAccess.self, forKey: .blockPublicAccess)
        blockPublicAccess = blockPublicAccessDecoded
    }
}

extension GuardDutyClientTypes {
    /// Contains information about the account level permissions on the S3 bucket.
    public struct AccountLevelPermissions: Swift.Equatable {
        /// Describes the S3 Block Public Access settings of the bucket's parent account.
        public var blockPublicAccess: GuardDutyClientTypes.BlockPublicAccess?

        public init(
            blockPublicAccess: GuardDutyClientTypes.BlockPublicAccess? = nil
        )
        {
            self.blockPublicAccess = blockPublicAccess
        }
    }

}

extension GuardDutyClientTypes.Action: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actionType = "actionType"
        case awsApiCallAction = "awsApiCallAction"
        case dnsRequestAction = "dnsRequestAction"
        case kubernetesApiCallAction = "kubernetesApiCallAction"
        case networkConnectionAction = "networkConnectionAction"
        case portProbeAction = "portProbeAction"
        case rdsLoginAttemptAction = "rdsLoginAttemptAction"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actionType = self.actionType {
            try encodeContainer.encode(actionType, forKey: .actionType)
        }
        if let awsApiCallAction = self.awsApiCallAction {
            try encodeContainer.encode(awsApiCallAction, forKey: .awsApiCallAction)
        }
        if let dnsRequestAction = self.dnsRequestAction {
            try encodeContainer.encode(dnsRequestAction, forKey: .dnsRequestAction)
        }
        if let kubernetesApiCallAction = self.kubernetesApiCallAction {
            try encodeContainer.encode(kubernetesApiCallAction, forKey: .kubernetesApiCallAction)
        }
        if let networkConnectionAction = self.networkConnectionAction {
            try encodeContainer.encode(networkConnectionAction, forKey: .networkConnectionAction)
        }
        if let portProbeAction = self.portProbeAction {
            try encodeContainer.encode(portProbeAction, forKey: .portProbeAction)
        }
        if let rdsLoginAttemptAction = self.rdsLoginAttemptAction {
            try encodeContainer.encode(rdsLoginAttemptAction, forKey: .rdsLoginAttemptAction)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .actionType)
        actionType = actionTypeDecoded
        let awsApiCallActionDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.AwsApiCallAction.self, forKey: .awsApiCallAction)
        awsApiCallAction = awsApiCallActionDecoded
        let dnsRequestActionDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.DnsRequestAction.self, forKey: .dnsRequestAction)
        dnsRequestAction = dnsRequestActionDecoded
        let networkConnectionActionDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.NetworkConnectionAction.self, forKey: .networkConnectionAction)
        networkConnectionAction = networkConnectionActionDecoded
        let portProbeActionDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.PortProbeAction.self, forKey: .portProbeAction)
        portProbeAction = portProbeActionDecoded
        let kubernetesApiCallActionDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.KubernetesApiCallAction.self, forKey: .kubernetesApiCallAction)
        kubernetesApiCallAction = kubernetesApiCallActionDecoded
        let rdsLoginAttemptActionDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.RdsLoginAttemptAction.self, forKey: .rdsLoginAttemptAction)
        rdsLoginAttemptAction = rdsLoginAttemptActionDecoded
    }
}

extension GuardDutyClientTypes {
    /// Contains information about actions.
    public struct Action: Swift.Equatable {
        /// The GuardDuty finding activity type.
        public var actionType: Swift.String?
        /// Information about the AWS_API_CALL action described in this finding.
        public var awsApiCallAction: GuardDutyClientTypes.AwsApiCallAction?
        /// Information about the DNS_REQUEST action described in this finding.
        public var dnsRequestAction: GuardDutyClientTypes.DnsRequestAction?
        /// Information about the Kubernetes API call action described in this finding.
        public var kubernetesApiCallAction: GuardDutyClientTypes.KubernetesApiCallAction?
        /// Information about the NETWORK_CONNECTION action described in this finding.
        public var networkConnectionAction: GuardDutyClientTypes.NetworkConnectionAction?
        /// Information about the PORT_PROBE action described in this finding.
        public var portProbeAction: GuardDutyClientTypes.PortProbeAction?
        /// Information about RDS_LOGIN_ATTEMPT action described in this finding.
        public var rdsLoginAttemptAction: GuardDutyClientTypes.RdsLoginAttemptAction?

        public init(
            actionType: Swift.String? = nil,
            awsApiCallAction: GuardDutyClientTypes.AwsApiCallAction? = nil,
            dnsRequestAction: GuardDutyClientTypes.DnsRequestAction? = nil,
            kubernetesApiCallAction: GuardDutyClientTypes.KubernetesApiCallAction? = nil,
            networkConnectionAction: GuardDutyClientTypes.NetworkConnectionAction? = nil,
            portProbeAction: GuardDutyClientTypes.PortProbeAction? = nil,
            rdsLoginAttemptAction: GuardDutyClientTypes.RdsLoginAttemptAction? = nil
        )
        {
            self.actionType = actionType
            self.awsApiCallAction = awsApiCallAction
            self.dnsRequestAction = dnsRequestAction
            self.kubernetesApiCallAction = kubernetesApiCallAction
            self.networkConnectionAction = networkConnectionAction
            self.portProbeAction = portProbeAction
            self.rdsLoginAttemptAction = rdsLoginAttemptAction
        }
    }

}

extension GuardDutyClientTypes.AddonDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addonStatus = "addonStatus"
        case addonVersion = "addonVersion"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let addonStatus = self.addonStatus {
            try encodeContainer.encode(addonStatus, forKey: .addonStatus)
        }
        if let addonVersion = self.addonVersion {
            try encodeContainer.encode(addonVersion, forKey: .addonVersion)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let addonVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .addonVersion)
        addonVersion = addonVersionDecoded
        let addonStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .addonStatus)
        addonStatus = addonStatusDecoded
    }
}

extension GuardDutyClientTypes {
    /// Information about the installed EKS add-on (GuardDuty security agent).
    public struct AddonDetails: Swift.Equatable {
        /// Status of the installed EKS add-on.
        public var addonStatus: Swift.String?
        /// Version of the installed EKS add-on.
        public var addonVersion: Swift.String?

        public init(
            addonStatus: Swift.String? = nil,
            addonVersion: Swift.String? = nil
        )
        {
            self.addonStatus = addonStatus
            self.addonVersion = addonVersion
        }
    }

}

extension GuardDutyClientTypes.AdminAccount: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case adminAccountId = "adminAccountId"
        case adminStatus = "adminStatus"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let adminAccountId = self.adminAccountId {
            try encodeContainer.encode(adminAccountId, forKey: .adminAccountId)
        }
        if let adminStatus = self.adminStatus {
            try encodeContainer.encode(adminStatus.rawValue, forKey: .adminStatus)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let adminAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .adminAccountId)
        adminAccountId = adminAccountIdDecoded
        let adminStatusDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.AdminStatus.self, forKey: .adminStatus)
        adminStatus = adminStatusDecoded
    }
}

extension GuardDutyClientTypes {
    /// The account within the organization specified as the GuardDuty delegated administrator.
    public struct AdminAccount: Swift.Equatable {
        /// The Amazon Web Services account ID for the account.
        public var adminAccountId: Swift.String?
        /// Indicates whether the account is enabled as the delegated administrator.
        public var adminStatus: GuardDutyClientTypes.AdminStatus?

        public init(
            adminAccountId: Swift.String? = nil,
            adminStatus: GuardDutyClientTypes.AdminStatus? = nil
        )
        {
            self.adminAccountId = adminAccountId
            self.adminStatus = adminStatus
        }
    }

}

extension GuardDutyClientTypes {
    public enum AdminStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disableInProgress
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [AdminStatus] {
            return [
                .disableInProgress,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disableInProgress: return "DISABLE_IN_PROGRESS"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AdminStatus(rawValue: rawValue) ?? AdminStatus.sdkUnknown(rawValue)
        }
    }
}

extension GuardDutyClientTypes.Administrator: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "accountId"
        case invitationId = "invitationId"
        case invitedAt = "invitedAt"
        case relationshipStatus = "relationshipStatus"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let invitationId = self.invitationId {
            try encodeContainer.encode(invitationId, forKey: .invitationId)
        }
        if let invitedAt = self.invitedAt {
            try encodeContainer.encode(invitedAt, forKey: .invitedAt)
        }
        if let relationshipStatus = self.relationshipStatus {
            try encodeContainer.encode(relationshipStatus, forKey: .relationshipStatus)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let invitationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .invitationId)
        invitationId = invitationIdDecoded
        let relationshipStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .relationshipStatus)
        relationshipStatus = relationshipStatusDecoded
        let invitedAtDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .invitedAt)
        invitedAt = invitedAtDecoded
    }
}

extension GuardDutyClientTypes {
    /// Contains information about the administrator account and invitation.
    public struct Administrator: Swift.Equatable {
        /// The ID of the account used as the administrator account.
        public var accountId: Swift.String?
        /// The value that is used to validate the administrator account to the member account.
        public var invitationId: Swift.String?
        /// The timestamp when the invitation was sent.
        public var invitedAt: Swift.String?
        /// The status of the relationship between the administrator and member accounts.
        public var relationshipStatus: Swift.String?

        public init(
            accountId: Swift.String? = nil,
            invitationId: Swift.String? = nil,
            invitedAt: Swift.String? = nil,
            relationshipStatus: Swift.String? = nil
        )
        {
            self.accountId = accountId
            self.invitationId = invitationId
            self.invitedAt = invitedAt
            self.relationshipStatus = relationshipStatus
        }
    }

}

extension ArchiveFindingsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case findingIds = "findingIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let findingIds = findingIds {
            var findingIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .findingIds)
            for findingid0 in findingIds {
                try findingIdsContainer.encode(findingid0)
            }
        }
    }
}

extension ArchiveFindingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let detectorId = detectorId else {
            return nil
        }
        return "/detector/\(detectorId.urlPercentEncoding())/findings/archive"
    }
}

public struct ArchiveFindingsInput: Swift.Equatable {
    /// The ID of the detector that specifies the GuardDuty service whose findings you want to archive.
    /// This member is required.
    public var detectorId: Swift.String?
    /// The IDs of the findings that you want to archive.
    /// This member is required.
    public var findingIds: [Swift.String]?

    public init(
        detectorId: Swift.String? = nil,
        findingIds: [Swift.String]? = nil
    )
    {
        self.detectorId = detectorId
        self.findingIds = findingIds
    }
}

struct ArchiveFindingsInputBody: Swift.Equatable {
    let findingIds: [Swift.String]?
}

extension ArchiveFindingsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case findingIds = "findingIds"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let findingIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .findingIds)
        var findingIdsDecoded0:[Swift.String]? = nil
        if let findingIdsContainer = findingIdsContainer {
            findingIdsDecoded0 = [Swift.String]()
            for string0 in findingIdsContainer {
                if let string0 = string0 {
                    findingIdsDecoded0?.append(string0)
                }
            }
        }
        findingIds = findingIdsDecoded0
    }
}

extension ArchiveFindingsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct ArchiveFindingsOutput: Swift.Equatable {

    public init() { }
}

enum ArchiveFindingsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GuardDutyClientTypes {
    public enum AutoEnableMembers: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case all
        case new
        case `none`
        case sdkUnknown(Swift.String)

        public static var allCases: [AutoEnableMembers] {
            return [
                .all,
                .new,
                .none,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .all: return "ALL"
            case .new: return "NEW"
            case .none: return "NONE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AutoEnableMembers(rawValue: rawValue) ?? AutoEnableMembers.sdkUnknown(rawValue)
        }
    }
}

extension GuardDutyClientTypes.AwsApiCallAction: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case affectedResources = "affectedResources"
        case api = "api"
        case callerType = "callerType"
        case domainDetails = "domainDetails"
        case errorCode = "errorCode"
        case remoteAccountDetails = "remoteAccountDetails"
        case remoteIpDetails = "remoteIpDetails"
        case serviceName = "serviceName"
        case userAgent = "userAgent"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let affectedResources = affectedResources {
            var affectedResourcesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .affectedResources)
            for (dictKey0, affectedResources0) in affectedResources {
                try affectedResourcesContainer.encode(affectedResources0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let api = self.api {
            try encodeContainer.encode(api, forKey: .api)
        }
        if let callerType = self.callerType {
            try encodeContainer.encode(callerType, forKey: .callerType)
        }
        if let domainDetails = self.domainDetails {
            try encodeContainer.encode(domainDetails, forKey: .domainDetails)
        }
        if let errorCode = self.errorCode {
            try encodeContainer.encode(errorCode, forKey: .errorCode)
        }
        if let remoteAccountDetails = self.remoteAccountDetails {
            try encodeContainer.encode(remoteAccountDetails, forKey: .remoteAccountDetails)
        }
        if let remoteIpDetails = self.remoteIpDetails {
            try encodeContainer.encode(remoteIpDetails, forKey: .remoteIpDetails)
        }
        if let serviceName = self.serviceName {
            try encodeContainer.encode(serviceName, forKey: .serviceName)
        }
        if let userAgent = self.userAgent {
            try encodeContainer.encode(userAgent, forKey: .userAgent)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .api)
        api = apiDecoded
        let callerTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .callerType)
        callerType = callerTypeDecoded
        let domainDetailsDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.DomainDetails.self, forKey: .domainDetails)
        domainDetails = domainDetailsDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let userAgentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userAgent)
        userAgent = userAgentDecoded
        let remoteIpDetailsDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.RemoteIpDetails.self, forKey: .remoteIpDetails)
        remoteIpDetails = remoteIpDetailsDecoded
        let serviceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceName)
        serviceName = serviceNameDecoded
        let remoteAccountDetailsDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.RemoteAccountDetails.self, forKey: .remoteAccountDetails)
        remoteAccountDetails = remoteAccountDetailsDecoded
        let affectedResourcesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .affectedResources)
        var affectedResourcesDecoded0: [Swift.String:Swift.String]? = nil
        if let affectedResourcesContainer = affectedResourcesContainer {
            affectedResourcesDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in affectedResourcesContainer {
                if let string0 = string0 {
                    affectedResourcesDecoded0?[key0] = string0
                }
            }
        }
        affectedResources = affectedResourcesDecoded0
    }
}

extension GuardDutyClientTypes {
    /// Contains information about the API action.
    public struct AwsApiCallAction: Swift.Equatable {
        /// The details of the Amazon Web Services account that made the API call. This field identifies the resources that were affected by this API call.
        public var affectedResources: [Swift.String:Swift.String]?
        /// The Amazon Web Services API name.
        public var api: Swift.String?
        /// The Amazon Web Services API caller type.
        public var callerType: Swift.String?
        /// The domain information for the Amazon Web Services API call.
        public var domainDetails: GuardDutyClientTypes.DomainDetails?
        /// The error code of the failed Amazon Web Services API action.
        public var errorCode: Swift.String?
        /// The details of the Amazon Web Services account that made the API call. This field appears if the call was made from outside your account.
        public var remoteAccountDetails: GuardDutyClientTypes.RemoteAccountDetails?
        /// The remote IP information of the connection that initiated the Amazon Web Services API call.
        public var remoteIpDetails: GuardDutyClientTypes.RemoteIpDetails?
        /// The Amazon Web Services service name whose API was invoked.
        public var serviceName: Swift.String?
        /// The agent through which the API request was made.
        public var userAgent: Swift.String?

        public init(
            affectedResources: [Swift.String:Swift.String]? = nil,
            api: Swift.String? = nil,
            callerType: Swift.String? = nil,
            domainDetails: GuardDutyClientTypes.DomainDetails? = nil,
            errorCode: Swift.String? = nil,
            remoteAccountDetails: GuardDutyClientTypes.RemoteAccountDetails? = nil,
            remoteIpDetails: GuardDutyClientTypes.RemoteIpDetails? = nil,
            serviceName: Swift.String? = nil,
            userAgent: Swift.String? = nil
        )
        {
            self.affectedResources = affectedResources
            self.api = api
            self.callerType = callerType
            self.domainDetails = domainDetails
            self.errorCode = errorCode
            self.remoteAccountDetails = remoteAccountDetails
            self.remoteIpDetails = remoteIpDetails
            self.serviceName = serviceName
            self.userAgent = userAgent
        }
    }

}

extension BadRequestException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: BadRequestExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.type = output.type
        } else {
            self.properties.message = nil
            self.properties.type = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// A bad request exception object.
public struct BadRequestException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The error message.
        public internal(set) var message: Swift.String? = nil
        /// The error type.
        public internal(set) var type: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "BadRequestException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.type = type
    }
}

struct BadRequestExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let type: Swift.String?
}

extension BadRequestExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "message"
        case type = "__type"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
    }
}

extension GuardDutyClientTypes.BlockPublicAccess: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case blockPublicAcls = "blockPublicAcls"
        case blockPublicPolicy = "blockPublicPolicy"
        case ignorePublicAcls = "ignorePublicAcls"
        case restrictPublicBuckets = "restrictPublicBuckets"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if blockPublicAcls != false {
            try encodeContainer.encode(blockPublicAcls, forKey: .blockPublicAcls)
        }
        if blockPublicPolicy != false {
            try encodeContainer.encode(blockPublicPolicy, forKey: .blockPublicPolicy)
        }
        if ignorePublicAcls != false {
            try encodeContainer.encode(ignorePublicAcls, forKey: .ignorePublicAcls)
        }
        if restrictPublicBuckets != false {
            try encodeContainer.encode(restrictPublicBuckets, forKey: .restrictPublicBuckets)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ignorePublicAclsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .ignorePublicAcls) ?? false
        ignorePublicAcls = ignorePublicAclsDecoded
        let restrictPublicBucketsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .restrictPublicBuckets) ?? false
        restrictPublicBuckets = restrictPublicBucketsDecoded
        let blockPublicAclsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .blockPublicAcls) ?? false
        blockPublicAcls = blockPublicAclsDecoded
        let blockPublicPolicyDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .blockPublicPolicy) ?? false
        blockPublicPolicy = blockPublicPolicyDecoded
    }
}

extension GuardDutyClientTypes {
    /// Contains information on how the bucker owner's S3 Block Public Access settings are being applied to the S3 bucket. See [S3 Block Public Access](https://docs.aws.amazon.com/AmazonS3/latest/dev/access-control-block-public-access.html) for more information.
    public struct BlockPublicAccess: Swift.Equatable {
        /// Indicates if S3 Block Public Access is set to BlockPublicAcls.
        public var blockPublicAcls: Swift.Bool
        /// Indicates if S3 Block Public Access is set to BlockPublicPolicy.
        public var blockPublicPolicy: Swift.Bool
        /// Indicates if S3 Block Public Access is set to IgnorePublicAcls.
        public var ignorePublicAcls: Swift.Bool
        /// Indicates if S3 Block Public Access is set to RestrictPublicBuckets.
        public var restrictPublicBuckets: Swift.Bool

        public init(
            blockPublicAcls: Swift.Bool = false,
            blockPublicPolicy: Swift.Bool = false,
            ignorePublicAcls: Swift.Bool = false,
            restrictPublicBuckets: Swift.Bool = false
        )
        {
            self.blockPublicAcls = blockPublicAcls
            self.blockPublicPolicy = blockPublicPolicy
            self.ignorePublicAcls = ignorePublicAcls
            self.restrictPublicBuckets = restrictPublicBuckets
        }
    }

}

extension GuardDutyClientTypes.BucketLevelPermissions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessControlList = "accessControlList"
        case blockPublicAccess = "blockPublicAccess"
        case bucketPolicy = "bucketPolicy"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessControlList = self.accessControlList {
            try encodeContainer.encode(accessControlList, forKey: .accessControlList)
        }
        if let blockPublicAccess = self.blockPublicAccess {
            try encodeContainer.encode(blockPublicAccess, forKey: .blockPublicAccess)
        }
        if let bucketPolicy = self.bucketPolicy {
            try encodeContainer.encode(bucketPolicy, forKey: .bucketPolicy)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessControlListDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.AccessControlList.self, forKey: .accessControlList)
        accessControlList = accessControlListDecoded
        let bucketPolicyDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.BucketPolicy.self, forKey: .bucketPolicy)
        bucketPolicy = bucketPolicyDecoded
        let blockPublicAccessDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.BlockPublicAccess.self, forKey: .blockPublicAccess)
        blockPublicAccess = blockPublicAccessDecoded
    }
}

extension GuardDutyClientTypes {
    /// Contains information about the bucket level permissions for the S3 bucket.
    public struct BucketLevelPermissions: Swift.Equatable {
        /// Contains information on how Access Control Policies are applied to the bucket.
        public var accessControlList: GuardDutyClientTypes.AccessControlList?
        /// Contains information on which account level S3 Block Public Access settings are applied to the S3 bucket.
        public var blockPublicAccess: GuardDutyClientTypes.BlockPublicAccess?
        /// Contains information on the bucket policies for the S3 bucket.
        public var bucketPolicy: GuardDutyClientTypes.BucketPolicy?

        public init(
            accessControlList: GuardDutyClientTypes.AccessControlList? = nil,
            blockPublicAccess: GuardDutyClientTypes.BlockPublicAccess? = nil,
            bucketPolicy: GuardDutyClientTypes.BucketPolicy? = nil
        )
        {
            self.accessControlList = accessControlList
            self.blockPublicAccess = blockPublicAccess
            self.bucketPolicy = bucketPolicy
        }
    }

}

extension GuardDutyClientTypes.BucketPolicy: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowsPublicReadAccess = "allowsPublicReadAccess"
        case allowsPublicWriteAccess = "allowsPublicWriteAccess"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if allowsPublicReadAccess != false {
            try encodeContainer.encode(allowsPublicReadAccess, forKey: .allowsPublicReadAccess)
        }
        if allowsPublicWriteAccess != false {
            try encodeContainer.encode(allowsPublicWriteAccess, forKey: .allowsPublicWriteAccess)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let allowsPublicReadAccessDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .allowsPublicReadAccess) ?? false
        allowsPublicReadAccess = allowsPublicReadAccessDecoded
        let allowsPublicWriteAccessDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .allowsPublicWriteAccess) ?? false
        allowsPublicWriteAccess = allowsPublicWriteAccessDecoded
    }
}

extension GuardDutyClientTypes {
    /// Contains information on the current bucket policies for the S3 bucket.
    public struct BucketPolicy: Swift.Equatable {
        /// A value that indicates whether public read access for the bucket is enabled through a bucket policy.
        public var allowsPublicReadAccess: Swift.Bool
        /// A value that indicates whether public write access for the bucket is enabled through a bucket policy.
        public var allowsPublicWriteAccess: Swift.Bool

        public init(
            allowsPublicReadAccess: Swift.Bool = false,
            allowsPublicWriteAccess: Swift.Bool = false
        )
        {
            self.allowsPublicReadAccess = allowsPublicReadAccess
            self.allowsPublicWriteAccess = allowsPublicWriteAccess
        }
    }

}

extension GuardDutyClientTypes.City: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cityName = "cityName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cityName = self.cityName {
            try encodeContainer.encode(cityName, forKey: .cityName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cityNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cityName)
        cityName = cityNameDecoded
    }
}

extension GuardDutyClientTypes {
    /// Contains information about the city associated with the IP address.
    public struct City: Swift.Equatable {
        /// The city name of the remote IP address.
        public var cityName: Swift.String?

        public init(
            cityName: Swift.String? = nil
        )
        {
            self.cityName = cityName
        }
    }

}

extension GuardDutyClientTypes.CloudTrailConfigurationResult: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status = "status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.DataSourceStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension GuardDutyClientTypes {
    /// Contains information on the status of CloudTrail as a data source for the detector.
    public struct CloudTrailConfigurationResult: Swift.Equatable {
        /// Describes whether CloudTrail is enabled as a data source for the detector.
        /// This member is required.
        public var status: GuardDutyClientTypes.DataSourceStatus?

        public init(
            status: GuardDutyClientTypes.DataSourceStatus? = nil
        )
        {
            self.status = status
        }
    }

}

extension GuardDutyClientTypes.Condition: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eq = "eq"
        case equals = "equals"
        case greaterThan = "greaterThan"
        case greaterThanOrEqual = "greaterThanOrEqual"
        case gt = "gt"
        case gte = "gte"
        case lessThan = "lessThan"
        case lessThanOrEqual = "lessThanOrEqual"
        case lt = "lt"
        case lte = "lte"
        case neq = "neq"
        case notEquals = "notEquals"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eq = eq {
            var eqContainer = encodeContainer.nestedUnkeyedContainer(forKey: .eq)
            for string0 in eq {
                try eqContainer.encode(string0)
            }
        }
        if let equals = equals {
            var equalsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .equals)
            for string0 in equals {
                try equalsContainer.encode(string0)
            }
        }
        if greaterThan != 0 {
            try encodeContainer.encode(greaterThan, forKey: .greaterThan)
        }
        if greaterThanOrEqual != 0 {
            try encodeContainer.encode(greaterThanOrEqual, forKey: .greaterThanOrEqual)
        }
        if gt != 0 {
            try encodeContainer.encode(gt, forKey: .gt)
        }
        if gte != 0 {
            try encodeContainer.encode(gte, forKey: .gte)
        }
        if lessThan != 0 {
            try encodeContainer.encode(lessThan, forKey: .lessThan)
        }
        if lessThanOrEqual != 0 {
            try encodeContainer.encode(lessThanOrEqual, forKey: .lessThanOrEqual)
        }
        if lt != 0 {
            try encodeContainer.encode(lt, forKey: .lt)
        }
        if lte != 0 {
            try encodeContainer.encode(lte, forKey: .lte)
        }
        if let neq = neq {
            var neqContainer = encodeContainer.nestedUnkeyedContainer(forKey: .neq)
            for string0 in neq {
                try neqContainer.encode(string0)
            }
        }
        if let notEquals = notEquals {
            var notEqualsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .notEquals)
            for string0 in notEquals {
                try notEqualsContainer.encode(string0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eqContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .eq)
        var eqDecoded0:[Swift.String]? = nil
        if let eqContainer = eqContainer {
            eqDecoded0 = [Swift.String]()
            for string0 in eqContainer {
                if let string0 = string0 {
                    eqDecoded0?.append(string0)
                }
            }
        }
        eq = eqDecoded0
        let neqContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .neq)
        var neqDecoded0:[Swift.String]? = nil
        if let neqContainer = neqContainer {
            neqDecoded0 = [Swift.String]()
            for string0 in neqContainer {
                if let string0 = string0 {
                    neqDecoded0?.append(string0)
                }
            }
        }
        neq = neqDecoded0
        let gtDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .gt) ?? 0
        gt = gtDecoded
        let gteDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .gte) ?? 0
        gte = gteDecoded
        let ltDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .lt) ?? 0
        lt = ltDecoded
        let lteDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .lte) ?? 0
        lte = lteDecoded
        let equalsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .equals)
        var equalsDecoded0:[Swift.String]? = nil
        if let equalsContainer = equalsContainer {
            equalsDecoded0 = [Swift.String]()
            for string0 in equalsContainer {
                if let string0 = string0 {
                    equalsDecoded0?.append(string0)
                }
            }
        }
        equals = equalsDecoded0
        let notEqualsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .notEquals)
        var notEqualsDecoded0:[Swift.String]? = nil
        if let notEqualsContainer = notEqualsContainer {
            notEqualsDecoded0 = [Swift.String]()
            for string0 in notEqualsContainer {
                if let string0 = string0 {
                    notEqualsDecoded0?.append(string0)
                }
            }
        }
        notEquals = notEqualsDecoded0
        let greaterThanDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .greaterThan) ?? 0
        greaterThan = greaterThanDecoded
        let greaterThanOrEqualDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .greaterThanOrEqual) ?? 0
        greaterThanOrEqual = greaterThanOrEqualDecoded
        let lessThanDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .lessThan) ?? 0
        lessThan = lessThanDecoded
        let lessThanOrEqualDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .lessThanOrEqual) ?? 0
        lessThanOrEqual = lessThanOrEqualDecoded
    }
}

extension GuardDutyClientTypes {
    /// Contains information about the condition.
    public struct Condition: Swift.Equatable {
        /// Represents the equal condition to be applied to a single field when querying for findings.
        @available(*, deprecated)
        public var eq: [Swift.String]?
        /// Represents an equal condition to be applied to a single field when querying for findings.
        public var equals: [Swift.String]?
        /// Represents a greater than condition to be applied to a single field when querying for findings.
        public var greaterThan: Swift.Int
        /// Represents a greater than or equal condition to be applied to a single field when querying for findings.
        public var greaterThanOrEqual: Swift.Int
        /// Represents a greater than condition to be applied to a single field when querying for findings.
        @available(*, deprecated)
        public var gt: Swift.Int
        /// Represents a greater than or equal condition to be applied to a single field when querying for findings.
        @available(*, deprecated)
        public var gte: Swift.Int
        /// Represents a less than condition to be applied to a single field when querying for findings.
        public var lessThan: Swift.Int
        /// Represents a less than or equal condition to be applied to a single field when querying for findings.
        public var lessThanOrEqual: Swift.Int
        /// Represents a less than condition to be applied to a single field when querying for findings.
        @available(*, deprecated)
        public var lt: Swift.Int
        /// Represents a less than or equal condition to be applied to a single field when querying for findings.
        @available(*, deprecated)
        public var lte: Swift.Int
        /// Represents the not equal condition to be applied to a single field when querying for findings.
        @available(*, deprecated)
        public var neq: [Swift.String]?
        /// Represents a not equal condition to be applied to a single field when querying for findings.
        public var notEquals: [Swift.String]?

        public init(
            eq: [Swift.String]? = nil,
            equals: [Swift.String]? = nil,
            greaterThan: Swift.Int = 0,
            greaterThanOrEqual: Swift.Int = 0,
            gt: Swift.Int = 0,
            gte: Swift.Int = 0,
            lessThan: Swift.Int = 0,
            lessThanOrEqual: Swift.Int = 0,
            lt: Swift.Int = 0,
            lte: Swift.Int = 0,
            neq: [Swift.String]? = nil,
            notEquals: [Swift.String]? = nil
        )
        {
            self.eq = eq
            self.equals = equals
            self.greaterThan = greaterThan
            self.greaterThanOrEqual = greaterThanOrEqual
            self.gt = gt
            self.gte = gte
            self.lessThan = lessThan
            self.lessThanOrEqual = lessThanOrEqual
            self.lt = lt
            self.lte = lte
            self.neq = neq
            self.notEquals = notEquals
        }
    }

}

extension ConflictException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.type = output.type
        } else {
            self.properties.message = nil
            self.properties.type = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// A request conflict exception object.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The error message.
        public internal(set) var message: Swift.String? = nil
        /// The error type.
        public internal(set) var type: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.type = type
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let type: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "message"
        case type = "__type"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
    }
}

extension GuardDutyClientTypes.Container: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case containerRuntime = "containerRuntime"
        case id = "id"
        case image = "image"
        case imagePrefix = "imagePrefix"
        case name = "name"
        case securityContext = "securityContext"
        case volumeMounts = "volumeMounts"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let containerRuntime = self.containerRuntime {
            try encodeContainer.encode(containerRuntime, forKey: .containerRuntime)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let image = self.image {
            try encodeContainer.encode(image, forKey: .image)
        }
        if let imagePrefix = self.imagePrefix {
            try encodeContainer.encode(imagePrefix, forKey: .imagePrefix)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let securityContext = self.securityContext {
            try encodeContainer.encode(securityContext, forKey: .securityContext)
        }
        if let volumeMounts = volumeMounts {
            var volumeMountsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .volumeMounts)
            for volumemount0 in volumeMounts {
                try volumeMountsContainer.encode(volumemount0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let containerRuntimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .containerRuntime)
        containerRuntime = containerRuntimeDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let imageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .image)
        image = imageDecoded
        let imagePrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imagePrefix)
        imagePrefix = imagePrefixDecoded
        let volumeMountsContainer = try containerValues.decodeIfPresent([GuardDutyClientTypes.VolumeMount?].self, forKey: .volumeMounts)
        var volumeMountsDecoded0:[GuardDutyClientTypes.VolumeMount]? = nil
        if let volumeMountsContainer = volumeMountsContainer {
            volumeMountsDecoded0 = [GuardDutyClientTypes.VolumeMount]()
            for structure0 in volumeMountsContainer {
                if let structure0 = structure0 {
                    volumeMountsDecoded0?.append(structure0)
                }
            }
        }
        volumeMounts = volumeMountsDecoded0
        let securityContextDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.SecurityContext.self, forKey: .securityContext)
        securityContext = securityContextDecoded
    }
}

extension GuardDutyClientTypes {
    /// Details of a container.
    public struct Container: Swift.Equatable {
        /// The container runtime (such as, Docker or containerd) used to run the container.
        public var containerRuntime: Swift.String?
        /// Container ID.
        public var id: Swift.String?
        /// Container image.
        public var image: Swift.String?
        /// Part of the image name before the last slash. For example, imagePrefix for public.ecr.aws/amazonlinux/amazonlinux:latest would be public.ecr.aws/amazonlinux. If the image name is relative and does not have a slash, this field is empty.
        public var imagePrefix: Swift.String?
        /// Container name.
        public var name: Swift.String?
        /// Container security context.
        public var securityContext: GuardDutyClientTypes.SecurityContext?
        /// Container volume mounts.
        public var volumeMounts: [GuardDutyClientTypes.VolumeMount]?

        public init(
            containerRuntime: Swift.String? = nil,
            id: Swift.String? = nil,
            image: Swift.String? = nil,
            imagePrefix: Swift.String? = nil,
            name: Swift.String? = nil,
            securityContext: GuardDutyClientTypes.SecurityContext? = nil,
            volumeMounts: [GuardDutyClientTypes.VolumeMount]? = nil
        )
        {
            self.containerRuntime = containerRuntime
            self.id = id
            self.image = image
            self.imagePrefix = imagePrefix
            self.name = name
            self.securityContext = securityContext
            self.volumeMounts = volumeMounts
        }
    }

}

extension GuardDutyClientTypes.Country: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case countryCode = "countryCode"
        case countryName = "countryName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let countryCode = self.countryCode {
            try encodeContainer.encode(countryCode, forKey: .countryCode)
        }
        if let countryName = self.countryName {
            try encodeContainer.encode(countryName, forKey: .countryName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let countryCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .countryCode)
        countryCode = countryCodeDecoded
        let countryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .countryName)
        countryName = countryNameDecoded
    }
}

extension GuardDutyClientTypes {
    /// Contains information about the country where the remote IP address is located.
    public struct Country: Swift.Equatable {
        /// The country code of the remote IP address.
        public var countryCode: Swift.String?
        /// The country name of the remote IP address.
        public var countryName: Swift.String?

        public init(
            countryCode: Swift.String? = nil,
            countryName: Swift.String? = nil
        )
        {
            self.countryCode = countryCode
            self.countryName = countryName
        }
    }

}

extension GuardDutyClientTypes.CoverageEksClusterDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addonDetails = "addonDetails"
        case clusterName = "clusterName"
        case compatibleNodes = "compatibleNodes"
        case coveredNodes = "coveredNodes"
        case managementType = "managementType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let addonDetails = self.addonDetails {
            try encodeContainer.encode(addonDetails, forKey: .addonDetails)
        }
        if let clusterName = self.clusterName {
            try encodeContainer.encode(clusterName, forKey: .clusterName)
        }
        if compatibleNodes != 0 {
            try encodeContainer.encode(compatibleNodes, forKey: .compatibleNodes)
        }
        if coveredNodes != 0 {
            try encodeContainer.encode(coveredNodes, forKey: .coveredNodes)
        }
        if let managementType = self.managementType {
            try encodeContainer.encode(managementType.rawValue, forKey: .managementType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let clusterNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clusterName)
        clusterName = clusterNameDecoded
        let coveredNodesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .coveredNodes) ?? 0
        coveredNodes = coveredNodesDecoded
        let compatibleNodesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .compatibleNodes) ?? 0
        compatibleNodes = compatibleNodesDecoded
        let addonDetailsDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.AddonDetails.self, forKey: .addonDetails)
        addonDetails = addonDetailsDecoded
        let managementTypeDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.ManagementType.self, forKey: .managementType)
        managementType = managementTypeDecoded
    }
}

extension GuardDutyClientTypes {
    /// Information about the EKS cluster that has a coverage status.
    public struct CoverageEksClusterDetails: Swift.Equatable {
        /// Information about the installed EKS add-on.
        public var addonDetails: GuardDutyClientTypes.AddonDetails?
        /// Name of the EKS cluster.
        public var clusterName: Swift.String?
        /// Represents all the nodes within the EKS cluster in your account.
        public var compatibleNodes: Swift.Int
        /// Represents the nodes within the EKS cluster that have a HEALTHY coverage status.
        public var coveredNodes: Swift.Int
        /// Indicates how the Amazon EKS add-on GuardDuty agent is managed for this EKS cluster. AUTO_MANAGED indicates GuardDuty deploys and manages updates for this resource. MANUAL indicates that you are responsible to deploy, update, and manage the Amazon EKS add-on GuardDuty agent for this resource.
        public var managementType: GuardDutyClientTypes.ManagementType?

        public init(
            addonDetails: GuardDutyClientTypes.AddonDetails? = nil,
            clusterName: Swift.String? = nil,
            compatibleNodes: Swift.Int = 0,
            coveredNodes: Swift.Int = 0,
            managementType: GuardDutyClientTypes.ManagementType? = nil
        )
        {
            self.addonDetails = addonDetails
            self.clusterName = clusterName
            self.compatibleNodes = compatibleNodes
            self.coveredNodes = coveredNodes
            self.managementType = managementType
        }
    }

}

extension GuardDutyClientTypes.CoverageFilterCondition: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case equals = "equals"
        case notEquals = "notEquals"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let equals = equals {
            var equalsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .equals)
            for string0 in equals {
                try equalsContainer.encode(string0)
            }
        }
        if let notEquals = notEquals {
            var notEqualsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .notEquals)
            for string0 in notEquals {
                try notEqualsContainer.encode(string0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let equalsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .equals)
        var equalsDecoded0:[Swift.String]? = nil
        if let equalsContainer = equalsContainer {
            equalsDecoded0 = [Swift.String]()
            for string0 in equalsContainer {
                if let string0 = string0 {
                    equalsDecoded0?.append(string0)
                }
            }
        }
        equals = equalsDecoded0
        let notEqualsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .notEquals)
        var notEqualsDecoded0:[Swift.String]? = nil
        if let notEqualsContainer = notEqualsContainer {
            notEqualsDecoded0 = [Swift.String]()
            for string0 in notEqualsContainer {
                if let string0 = string0 {
                    notEqualsDecoded0?.append(string0)
                }
            }
        }
        notEquals = notEqualsDecoded0
    }
}

extension GuardDutyClientTypes {
    /// Represents a condition that when matched will be added to the response of the operation.
    public struct CoverageFilterCondition: Swift.Equatable {
        /// Represents an equal condition that is applied to a single field while retrieving the coverage details.
        public var equals: [Swift.String]?
        /// Represents a not equal condition that is applied to a single field while retrieving the coverage details.
        public var notEquals: [Swift.String]?

        public init(
            equals: [Swift.String]? = nil,
            notEquals: [Swift.String]? = nil
        )
        {
            self.equals = equals
            self.notEquals = notEquals
        }
    }

}

extension GuardDutyClientTypes.CoverageFilterCriteria: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filterCriterion = "filterCriterion"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filterCriterion = filterCriterion {
            var filterCriterionContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filterCriterion)
            for coveragefiltercriterion0 in filterCriterion {
                try filterCriterionContainer.encode(coveragefiltercriterion0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filterCriterionContainer = try containerValues.decodeIfPresent([GuardDutyClientTypes.CoverageFilterCriterion?].self, forKey: .filterCriterion)
        var filterCriterionDecoded0:[GuardDutyClientTypes.CoverageFilterCriterion]? = nil
        if let filterCriterionContainer = filterCriterionContainer {
            filterCriterionDecoded0 = [GuardDutyClientTypes.CoverageFilterCriterion]()
            for structure0 in filterCriterionContainer {
                if let structure0 = structure0 {
                    filterCriterionDecoded0?.append(structure0)
                }
            }
        }
        filterCriterion = filterCriterionDecoded0
    }
}

extension GuardDutyClientTypes {
    /// Represents the criteria used in the filter.
    public struct CoverageFilterCriteria: Swift.Equatable {
        /// Represents a condition that when matched will be added to the response of the operation.
        public var filterCriterion: [GuardDutyClientTypes.CoverageFilterCriterion]?

        public init(
            filterCriterion: [GuardDutyClientTypes.CoverageFilterCriterion]? = nil
        )
        {
            self.filterCriterion = filterCriterion
        }
    }

}

extension GuardDutyClientTypes.CoverageFilterCriterion: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case criterionKey = "criterionKey"
        case filterCondition = "filterCondition"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let criterionKey = self.criterionKey {
            try encodeContainer.encode(criterionKey.rawValue, forKey: .criterionKey)
        }
        if let filterCondition = self.filterCondition {
            try encodeContainer.encode(filterCondition, forKey: .filterCondition)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let criterionKeyDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.CoverageFilterCriterionKey.self, forKey: .criterionKey)
        criterionKey = criterionKeyDecoded
        let filterConditionDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.CoverageFilterCondition.self, forKey: .filterCondition)
        filterCondition = filterConditionDecoded
    }
}

extension GuardDutyClientTypes {
    /// Represents a condition that when matched will be added to the response of the operation.
    public struct CoverageFilterCriterion: Swift.Equatable {
        /// An enum value representing possible filter fields. Replace the enum value CLUSTER_NAME with EKS_CLUSTER_NAME. CLUSTER_NAME has been deprecated.
        public var criterionKey: GuardDutyClientTypes.CoverageFilterCriterionKey?
        /// Contains information about the condition.
        public var filterCondition: GuardDutyClientTypes.CoverageFilterCondition?

        public init(
            criterionKey: GuardDutyClientTypes.CoverageFilterCriterionKey? = nil,
            filterCondition: GuardDutyClientTypes.CoverageFilterCondition? = nil
        )
        {
            self.criterionKey = criterionKey
            self.filterCondition = filterCondition
        }
    }

}

extension GuardDutyClientTypes {
    public enum CoverageFilterCriterionKey: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case accountId
        case addonVersion
        case clusterName
        case coverageStatus
        case eksClusterName
        case managementType
        case resourceType
        case sdkUnknown(Swift.String)

        public static var allCases: [CoverageFilterCriterionKey] {
            return [
                .accountId,
                .addonVersion,
                .clusterName,
                .coverageStatus,
                .eksClusterName,
                .managementType,
                .resourceType,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .accountId: return "ACCOUNT_ID"
            case .addonVersion: return "ADDON_VERSION"
            case .clusterName: return "CLUSTER_NAME"
            case .coverageStatus: return "COVERAGE_STATUS"
            case .eksClusterName: return "EKS_CLUSTER_NAME"
            case .managementType: return "MANAGEMENT_TYPE"
            case .resourceType: return "RESOURCE_TYPE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CoverageFilterCriterionKey(rawValue: rawValue) ?? CoverageFilterCriterionKey.sdkUnknown(rawValue)
        }
    }
}

extension GuardDutyClientTypes.CoverageResource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "accountId"
        case coverageStatus = "coverageStatus"
        case detectorId = "detectorId"
        case issue = "issue"
        case resourceDetails = "resourceDetails"
        case resourceId = "resourceId"
        case updatedAt = "updatedAt"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let coverageStatus = self.coverageStatus {
            try encodeContainer.encode(coverageStatus.rawValue, forKey: .coverageStatus)
        }
        if let detectorId = self.detectorId {
            try encodeContainer.encode(detectorId, forKey: .detectorId)
        }
        if let issue = self.issue {
            try encodeContainer.encode(issue, forKey: .issue)
        }
        if let resourceDetails = self.resourceDetails {
            try encodeContainer.encode(resourceDetails, forKey: .resourceDetails)
        }
        if let resourceId = self.resourceId {
            try encodeContainer.encode(resourceId, forKey: .resourceId)
        }
        if let updatedAt = self.updatedAt {
            try encodeContainer.encodeTimestamp(updatedAt, format: .epochSeconds, forKey: .updatedAt)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let detectorIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detectorId)
        detectorId = detectorIdDecoded
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let resourceDetailsDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.CoverageResourceDetails.self, forKey: .resourceDetails)
        resourceDetails = resourceDetailsDecoded
        let coverageStatusDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.CoverageStatus.self, forKey: .coverageStatus)
        coverageStatus = coverageStatusDecoded
        let issueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .issue)
        issue = issueDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
    }
}

extension GuardDutyClientTypes {
    /// Information about the resource of the GuardDuty account.
    public struct CoverageResource: Swift.Equatable {
        /// The unique ID of the Amazon Web Services account.
        public var accountId: Swift.String?
        /// Represents the status of the EKS cluster coverage.
        public var coverageStatus: GuardDutyClientTypes.CoverageStatus?
        /// The unique ID of the GuardDuty detector associated with the resource.
        public var detectorId: Swift.String?
        /// Represents the reason why a coverage status was UNHEALTHY for the EKS cluster.
        public var issue: Swift.String?
        /// Information about the resource for which the coverage statistics are retrieved.
        public var resourceDetails: GuardDutyClientTypes.CoverageResourceDetails?
        /// The unique ID of the resource.
        public var resourceId: Swift.String?
        /// The timestamp at which the coverage details for the resource were last updated. This is in UTC format.
        public var updatedAt: ClientRuntime.Date?

        public init(
            accountId: Swift.String? = nil,
            coverageStatus: GuardDutyClientTypes.CoverageStatus? = nil,
            detectorId: Swift.String? = nil,
            issue: Swift.String? = nil,
            resourceDetails: GuardDutyClientTypes.CoverageResourceDetails? = nil,
            resourceId: Swift.String? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.accountId = accountId
            self.coverageStatus = coverageStatus
            self.detectorId = detectorId
            self.issue = issue
            self.resourceDetails = resourceDetails
            self.resourceId = resourceId
            self.updatedAt = updatedAt
        }
    }

}

extension GuardDutyClientTypes.CoverageResourceDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eksClusterDetails = "eksClusterDetails"
        case resourceType = "resourceType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eksClusterDetails = self.eksClusterDetails {
            try encodeContainer.encode(eksClusterDetails, forKey: .eksClusterDetails)
        }
        if let resourceType = self.resourceType {
            try encodeContainer.encode(resourceType.rawValue, forKey: .resourceType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eksClusterDetailsDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.CoverageEksClusterDetails.self, forKey: .eksClusterDetails)
        eksClusterDetails = eksClusterDetailsDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.ResourceType.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension GuardDutyClientTypes {
    /// Information about the resource for each individual EKS cluster.
    public struct CoverageResourceDetails: Swift.Equatable {
        /// EKS cluster details involved in the coverage statistics.
        public var eksClusterDetails: GuardDutyClientTypes.CoverageEksClusterDetails?
        /// The type of Amazon Web Services resource.
        public var resourceType: GuardDutyClientTypes.ResourceType?

        public init(
            eksClusterDetails: GuardDutyClientTypes.CoverageEksClusterDetails? = nil,
            resourceType: GuardDutyClientTypes.ResourceType? = nil
        )
        {
            self.eksClusterDetails = eksClusterDetails
            self.resourceType = resourceType
        }
    }

}

extension GuardDutyClientTypes.CoverageSortCriteria: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributeName = "attributeName"
        case orderBy = "orderBy"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributeName = self.attributeName {
            try encodeContainer.encode(attributeName.rawValue, forKey: .attributeName)
        }
        if let orderBy = self.orderBy {
            try encodeContainer.encode(orderBy.rawValue, forKey: .orderBy)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributeNameDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.CoverageSortKey.self, forKey: .attributeName)
        attributeName = attributeNameDecoded
        let orderByDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.OrderBy.self, forKey: .orderBy)
        orderBy = orderByDecoded
    }
}

extension GuardDutyClientTypes {
    /// Information about the sorting criteria used in the coverage statistics.
    public struct CoverageSortCriteria: Swift.Equatable {
        /// Represents the field name used to sort the coverage details. Replace the enum value CLUSTER_NAME with EKS_CLUSTER_NAME. CLUSTER_NAME has been deprecated.
        public var attributeName: GuardDutyClientTypes.CoverageSortKey?
        /// The order in which the sorted findings are to be displayed.
        public var orderBy: GuardDutyClientTypes.OrderBy?

        public init(
            attributeName: GuardDutyClientTypes.CoverageSortKey? = nil,
            orderBy: GuardDutyClientTypes.OrderBy? = nil
        )
        {
            self.attributeName = attributeName
            self.orderBy = orderBy
        }
    }

}

extension GuardDutyClientTypes {
    public enum CoverageSortKey: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case accountId
        case addonVersion
        case clusterName
        case coverageStatus
        case eksClusterName
        case issue
        case updatedAt
        case sdkUnknown(Swift.String)

        public static var allCases: [CoverageSortKey] {
            return [
                .accountId,
                .addonVersion,
                .clusterName,
                .coverageStatus,
                .eksClusterName,
                .issue,
                .updatedAt,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .accountId: return "ACCOUNT_ID"
            case .addonVersion: return "ADDON_VERSION"
            case .clusterName: return "CLUSTER_NAME"
            case .coverageStatus: return "COVERAGE_STATUS"
            case .eksClusterName: return "EKS_CLUSTER_NAME"
            case .issue: return "ISSUE"
            case .updatedAt: return "UPDATED_AT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CoverageSortKey(rawValue: rawValue) ?? CoverageSortKey.sdkUnknown(rawValue)
        }
    }
}

extension GuardDutyClientTypes.CoverageStatistics: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case countByCoverageStatus = "countByCoverageStatus"
        case countByResourceType = "countByResourceType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let countByCoverageStatus = countByCoverageStatus {
            var countByCoverageStatusContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .countByCoverageStatus)
            for (dictKey0, countByCoverageStatus0) in countByCoverageStatus {
                try countByCoverageStatusContainer.encode(countByCoverageStatus0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let countByResourceType = countByResourceType {
            var countByResourceTypeContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .countByResourceType)
            for (dictKey0, countByResourceType0) in countByResourceType {
                try countByResourceTypeContainer.encode(countByResourceType0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let countByResourceTypeContainer = try containerValues.decodeIfPresent([Swift.String: Swift.Int?].self, forKey: .countByResourceType)
        var countByResourceTypeDecoded0: [Swift.String:Swift.Int]? = nil
        if let countByResourceTypeContainer = countByResourceTypeContainer {
            countByResourceTypeDecoded0 = [Swift.String:Swift.Int]()
            for (key0, long0) in countByResourceTypeContainer {
                if let long0 = long0 {
                    countByResourceTypeDecoded0?[key0] = long0
                }
            }
        }
        countByResourceType = countByResourceTypeDecoded0
        let countByCoverageStatusContainer = try containerValues.decodeIfPresent([Swift.String: Swift.Int?].self, forKey: .countByCoverageStatus)
        var countByCoverageStatusDecoded0: [Swift.String:Swift.Int]? = nil
        if let countByCoverageStatusContainer = countByCoverageStatusContainer {
            countByCoverageStatusDecoded0 = [Swift.String:Swift.Int]()
            for (key0, long0) in countByCoverageStatusContainer {
                if let long0 = long0 {
                    countByCoverageStatusDecoded0?[key0] = long0
                }
            }
        }
        countByCoverageStatus = countByCoverageStatusDecoded0
    }
}

extension GuardDutyClientTypes {
    /// Information about the coverage statistics for a resource.
    public struct CoverageStatistics: Swift.Equatable {
        /// Represents coverage statistics for EKS clusters aggregated by coverage status.
        public var countByCoverageStatus: [Swift.String:Swift.Int]?
        /// Represents coverage statistics for EKS clusters aggregated by resource type.
        public var countByResourceType: [Swift.String:Swift.Int]?

        public init(
            countByCoverageStatus: [Swift.String:Swift.Int]? = nil,
            countByResourceType: [Swift.String:Swift.Int]? = nil
        )
        {
            self.countByCoverageStatus = countByCoverageStatus
            self.countByResourceType = countByResourceType
        }
    }

}

extension GuardDutyClientTypes {
    public enum CoverageStatisticsType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case countByCoverageStatus
        case countByResourceType
        case sdkUnknown(Swift.String)

        public static var allCases: [CoverageStatisticsType] {
            return [
                .countByCoverageStatus,
                .countByResourceType,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .countByCoverageStatus: return "COUNT_BY_COVERAGE_STATUS"
            case .countByResourceType: return "COUNT_BY_RESOURCE_TYPE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CoverageStatisticsType(rawValue: rawValue) ?? CoverageStatisticsType.sdkUnknown(rawValue)
        }
    }
}

extension GuardDutyClientTypes {
    public enum CoverageStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case healthy
        case unhealthy
        case sdkUnknown(Swift.String)

        public static var allCases: [CoverageStatus] {
            return [
                .healthy,
                .unhealthy,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .healthy: return "HEALTHY"
            case .unhealthy: return "UNHEALTHY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CoverageStatus(rawValue: rawValue) ?? CoverageStatus.sdkUnknown(rawValue)
        }
    }
}

extension CreateDetectorInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "clientToken"
        case dataSources = "dataSources"
        case enable = "enable"
        case features = "features"
        case findingPublishingFrequency = "findingPublishingFrequency"
        case tags = "tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let dataSources = self.dataSources {
            try encodeContainer.encode(dataSources, forKey: .dataSources)
        }
        if let enable = self.enable {
            try encodeContainer.encode(enable, forKey: .enable)
        }
        if let features = features {
            var featuresContainer = encodeContainer.nestedUnkeyedContainer(forKey: .features)
            for detectorfeatureconfiguration0 in features {
                try featuresContainer.encode(detectorfeatureconfiguration0)
            }
        }
        if let findingPublishingFrequency = self.findingPublishingFrequency {
            try encodeContainer.encode(findingPublishingFrequency.rawValue, forKey: .findingPublishingFrequency)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateDetectorInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/detector"
    }
}

public struct CreateDetectorInput: Swift.Equatable {
    /// The idempotency token for the create request.
    public var clientToken: Swift.String?
    /// Describes which data sources will be enabled for the detector. There might be regional differences because some data sources might not be available in all the Amazon Web Services Regions where GuardDuty is presently supported. For more information, see [Regions and endpoints](https://docs.aws.amazon.com/guardduty/latest/ug/guardduty_regions.html).
    @available(*, deprecated, message: "This parameter is deprecated, use Features instead")
    public var dataSources: GuardDutyClientTypes.DataSourceConfigurations?
    /// A Boolean value that specifies whether the detector is to be enabled.
    /// This member is required.
    public var enable: Swift.Bool?
    /// A list of features that will be configured for the detector.
    public var features: [GuardDutyClientTypes.DetectorFeatureConfiguration]?
    /// A value that specifies how frequently updated findings are exported.
    public var findingPublishingFrequency: GuardDutyClientTypes.FindingPublishingFrequency?
    /// The tags to be added to a new detector resource.
    public var tags: [Swift.String:Swift.String]?

    public init(
        clientToken: Swift.String? = nil,
        dataSources: GuardDutyClientTypes.DataSourceConfigurations? = nil,
        enable: Swift.Bool? = nil,
        features: [GuardDutyClientTypes.DetectorFeatureConfiguration]? = nil,
        findingPublishingFrequency: GuardDutyClientTypes.FindingPublishingFrequency? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.clientToken = clientToken
        self.dataSources = dataSources
        self.enable = enable
        self.features = features
        self.findingPublishingFrequency = findingPublishingFrequency
        self.tags = tags
    }
}

struct CreateDetectorInputBody: Swift.Equatable {
    let enable: Swift.Bool?
    let clientToken: Swift.String?
    let findingPublishingFrequency: GuardDutyClientTypes.FindingPublishingFrequency?
    let dataSources: GuardDutyClientTypes.DataSourceConfigurations?
    let tags: [Swift.String:Swift.String]?
    let features: [GuardDutyClientTypes.DetectorFeatureConfiguration]?
}

extension CreateDetectorInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "clientToken"
        case dataSources = "dataSources"
        case enable = "enable"
        case features = "features"
        case findingPublishingFrequency = "findingPublishingFrequency"
        case tags = "tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enableDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enable)
        enable = enableDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let findingPublishingFrequencyDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.FindingPublishingFrequency.self, forKey: .findingPublishingFrequency)
        findingPublishingFrequency = findingPublishingFrequencyDecoded
        let dataSourcesDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.DataSourceConfigurations.self, forKey: .dataSources)
        dataSources = dataSourcesDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let featuresContainer = try containerValues.decodeIfPresent([GuardDutyClientTypes.DetectorFeatureConfiguration?].self, forKey: .features)
        var featuresDecoded0:[GuardDutyClientTypes.DetectorFeatureConfiguration]? = nil
        if let featuresContainer = featuresContainer {
            featuresDecoded0 = [GuardDutyClientTypes.DetectorFeatureConfiguration]()
            for structure0 in featuresContainer {
                if let structure0 = structure0 {
                    featuresDecoded0?.append(structure0)
                }
            }
        }
        features = featuresDecoded0
    }
}

extension CreateDetectorOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateDetectorOutputBody = try responseDecoder.decode(responseBody: data)
            self.detectorId = output.detectorId
            self.unprocessedDataSources = output.unprocessedDataSources
        } else {
            self.detectorId = nil
            self.unprocessedDataSources = nil
        }
    }
}

public struct CreateDetectorOutput: Swift.Equatable {
    /// The unique ID of the created detector.
    public var detectorId: Swift.String?
    /// Specifies the data sources that couldn't be enabled when GuardDuty was enabled for the first time.
    public var unprocessedDataSources: GuardDutyClientTypes.UnprocessedDataSourcesResult?

    public init(
        detectorId: Swift.String? = nil,
        unprocessedDataSources: GuardDutyClientTypes.UnprocessedDataSourcesResult? = nil
    )
    {
        self.detectorId = detectorId
        self.unprocessedDataSources = unprocessedDataSources
    }
}

struct CreateDetectorOutputBody: Swift.Equatable {
    let detectorId: Swift.String?
    let unprocessedDataSources: GuardDutyClientTypes.UnprocessedDataSourcesResult?
}

extension CreateDetectorOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case detectorId = "detectorId"
        case unprocessedDataSources = "unprocessedDataSources"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detectorIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detectorId)
        detectorId = detectorIdDecoded
        let unprocessedDataSourcesDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.UnprocessedDataSourcesResult.self, forKey: .unprocessedDataSources)
        unprocessedDataSources = unprocessedDataSourcesDecoded
    }
}

enum CreateDetectorOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateFilterInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action = "action"
        case clientToken = "clientToken"
        case description = "description"
        case findingCriteria = "findingCriteria"
        case name = "name"
        case rank = "rank"
        case tags = "tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = self.action {
            try encodeContainer.encode(action.rawValue, forKey: .action)
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let findingCriteria = self.findingCriteria {
            try encodeContainer.encode(findingCriteria, forKey: .findingCriteria)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let rank = self.rank {
            try encodeContainer.encode(rank, forKey: .rank)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateFilterInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let detectorId = detectorId else {
            return nil
        }
        return "/detector/\(detectorId.urlPercentEncoding())/filter"
    }
}

public struct CreateFilterInput: Swift.Equatable {
    /// Specifies the action that is to be applied to the findings that match the filter.
    public var action: GuardDutyClientTypes.FilterAction?
    /// The idempotency token for the create request.
    public var clientToken: Swift.String?
    /// The description of the filter. Valid characters include alphanumeric characters, and special characters such as hyphen, period, colon, underscore, parentheses ({ }, [ ], and ( )), forward slash, horizontal tab, vertical tab, newline, form feed, return, and whitespace.
    public var description: Swift.String?
    /// The ID of the detector belonging to the GuardDuty account that you want to create a filter for.
    /// This member is required.
    public var detectorId: Swift.String?
    /// Represents the criteria to be used in the filter for querying findings. You can only use the following attributes to query findings:
    ///
    /// * accountId
    ///
    /// * id
    ///
    /// * region
    ///
    /// * severity To filter on the basis of severity, the API and CLI use the following input list for the [FindingCriteria](https://docs.aws.amazon.com/guardduty/latest/APIReference/API_FindingCriteria.html) condition:
    ///
    /// * Low: ["1", "2", "3"]
    ///
    /// * Medium: ["4", "5", "6"]
    ///
    /// * High: ["7", "8", "9"]
    ///
    ///
    /// For more information, see [Severity levels for GuardDuty findings](https://docs.aws.amazon.com/guardduty/latest/ug/guardduty_findings.html#guardduty_findings-severity).
    ///
    /// * type
    ///
    /// * updatedAt Type: ISO 8601 string format: YYYY-MM-DDTHH:MM:SS.SSSZ or YYYY-MM-DDTHH:MM:SSZ depending on whether the value contains milliseconds.
    ///
    /// * resource.accessKeyDetails.accessKeyId
    ///
    /// * resource.accessKeyDetails.principalId
    ///
    /// * resource.accessKeyDetails.userName
    ///
    /// * resource.accessKeyDetails.userType
    ///
    /// * resource.instanceDetails.iamInstanceProfile.id
    ///
    /// * resource.instanceDetails.imageId
    ///
    /// * resource.instanceDetails.instanceId
    ///
    /// * resource.instanceDetails.tags.key
    ///
    /// * resource.instanceDetails.tags.value
    ///
    /// * resource.instanceDetails.networkInterfaces.ipv6Addresses
    ///
    /// * resource.instanceDetails.networkInterfaces.privateIpAddresses.privateIpAddress
    ///
    /// * resource.instanceDetails.networkInterfaces.publicDnsName
    ///
    /// * resource.instanceDetails.networkInterfaces.publicIp
    ///
    /// * resource.instanceDetails.networkInterfaces.securityGroups.groupId
    ///
    /// * resource.instanceDetails.networkInterfaces.securityGroups.groupName
    ///
    /// * resource.instanceDetails.networkInterfaces.subnetId
    ///
    /// * resource.instanceDetails.networkInterfaces.vpcId
    ///
    /// * resource.instanceDetails.outpostArn
    ///
    /// * resource.resourceType
    ///
    /// * resource.s3BucketDetails.publicAccess.effectivePermissions
    ///
    /// * resource.s3BucketDetails.name
    ///
    /// * resource.s3BucketDetails.tags.key
    ///
    /// * resource.s3BucketDetails.tags.value
    ///
    /// * resource.s3BucketDetails.type
    ///
    /// * service.action.actionType
    ///
    /// * service.action.awsApiCallAction.api
    ///
    /// * service.action.awsApiCallAction.callerType
    ///
    /// * service.action.awsApiCallAction.errorCode
    ///
    /// * service.action.awsApiCallAction.remoteIpDetails.city.cityName
    ///
    /// * service.action.awsApiCallAction.remoteIpDetails.country.countryName
    ///
    /// * service.action.awsApiCallAction.remoteIpDetails.ipAddressV4
    ///
    /// * service.action.awsApiCallAction.remoteIpDetails.organization.asn
    ///
    /// * service.action.awsApiCallAction.remoteIpDetails.organization.asnOrg
    ///
    /// * service.action.awsApiCallAction.serviceName
    ///
    /// * service.action.dnsRequestAction.domain
    ///
    /// * service.action.networkConnectionAction.blocked
    ///
    /// * service.action.networkConnectionAction.connectionDirection
    ///
    /// * service.action.networkConnectionAction.localPortDetails.port
    ///
    /// * service.action.networkConnectionAction.protocol
    ///
    /// * service.action.networkConnectionAction.remoteIpDetails.city.cityName
    ///
    /// * service.action.networkConnectionAction.remoteIpDetails.country.countryName
    ///
    /// * service.action.networkConnectionAction.remoteIpDetails.ipAddressV4
    ///
    /// * service.action.networkConnectionAction.remoteIpDetails.organization.asn
    ///
    /// * service.action.networkConnectionAction.remoteIpDetails.organization.asnOrg
    ///
    /// * service.action.networkConnectionAction.remotePortDetails.port
    ///
    /// * service.action.awsApiCallAction.remoteAccountDetails.affiliated
    ///
    /// * service.action.kubernetesApiCallAction.remoteIpDetails.ipAddressV4
    ///
    /// * service.action.kubernetesApiCallAction.requestUri
    ///
    /// * service.action.networkConnectionAction.localIpDetails.ipAddressV4
    ///
    /// * service.action.networkConnectionAction.protocol
    ///
    /// * service.action.awsApiCallAction.serviceName
    ///
    /// * service.action.awsApiCallAction.remoteAccountDetails.accountId
    ///
    /// * service.additionalInfo.threatListName
    ///
    /// * service.resourceRole
    ///
    /// * resource.eksClusterDetails.name
    ///
    /// * resource.kubernetesDetails.kubernetesWorkloadDetails.name
    ///
    /// * resource.kubernetesDetails.kubernetesWorkloadDetails.namespace
    ///
    /// * resource.kubernetesDetails.kubernetesUserDetails.username
    ///
    /// * resource.kubernetesDetails.kubernetesWorkloadDetails.containers.image
    ///
    /// * resource.kubernetesDetails.kubernetesWorkloadDetails.containers.imagePrefix
    ///
    /// * service.ebsVolumeScanDetails.scanId
    ///
    /// * service.ebsVolumeScanDetails.scanDetections.threatDetectedByName.threatNames.name
    ///
    /// * service.ebsVolumeScanDetails.scanDetections.threatDetectedByName.threatNames.severity
    ///
    /// * service.ebsVolumeScanDetails.scanDetections.threatDetectedByName.threatNames.filePaths.hash
    ///
    /// * resource.ecsClusterDetails.name
    ///
    /// * resource.ecsClusterDetails.taskDetails.containers.image
    ///
    /// * resource.ecsClusterDetails.taskDetails.definitionArn
    ///
    /// * resource.containerDetails.image
    ///
    /// * resource.rdsDbInstanceDetails.dbInstanceIdentifier
    ///
    /// * resource.rdsDbInstanceDetails.dbClusterIdentifier
    ///
    /// * resource.rdsDbInstanceDetails.engine
    ///
    /// * resource.rdsDbUserDetails.user
    ///
    /// * resource.rdsDbInstanceDetails.tags.key
    ///
    /// * resource.rdsDbInstanceDetails.tags.value
    ///
    /// * service.runtimeDetails.process.executableSha256
    ///
    /// * service.runtimeDetails.process.name
    ///
    /// * service.runtimeDetails.process.name
    ///
    /// * resource.lambdaDetails.functionName
    ///
    /// * resource.lambdaDetails.functionArn
    ///
    /// * resource.lambdaDetails.tags.key
    ///
    /// * resource.lambdaDetails.tags.value
    /// This member is required.
    public var findingCriteria: GuardDutyClientTypes.FindingCriteria?
    /// The name of the filter. Valid characters include period (.), underscore (_), dash (-), and alphanumeric characters. A whitespace is considered to be an invalid character.
    /// This member is required.
    public var name: Swift.String?
    /// Specifies the position of the filter in the list of current filters. Also specifies the order in which this filter is applied to the findings.
    public var rank: Swift.Int?
    /// The tags to be added to a new filter resource.
    public var tags: [Swift.String:Swift.String]?

    public init(
        action: GuardDutyClientTypes.FilterAction? = nil,
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        detectorId: Swift.String? = nil,
        findingCriteria: GuardDutyClientTypes.FindingCriteria? = nil,
        name: Swift.String? = nil,
        rank: Swift.Int? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.action = action
        self.clientToken = clientToken
        self.description = description
        self.detectorId = detectorId
        self.findingCriteria = findingCriteria
        self.name = name
        self.rank = rank
        self.tags = tags
    }
}

struct CreateFilterInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let action: GuardDutyClientTypes.FilterAction?
    let rank: Swift.Int?
    let findingCriteria: GuardDutyClientTypes.FindingCriteria?
    let clientToken: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateFilterInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action = "action"
        case clientToken = "clientToken"
        case description = "description"
        case findingCriteria = "findingCriteria"
        case name = "name"
        case rank = "rank"
        case tags = "tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let actionDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.FilterAction.self, forKey: .action)
        action = actionDecoded
        let rankDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .rank)
        rank = rankDecoded
        let findingCriteriaDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.FindingCriteria.self, forKey: .findingCriteria)
        findingCriteria = findingCriteriaDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateFilterOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateFilterOutputBody = try responseDecoder.decode(responseBody: data)
            self.name = output.name
        } else {
            self.name = nil
        }
    }
}

public struct CreateFilterOutput: Swift.Equatable {
    /// The name of the successfully created filter.
    /// This member is required.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct CreateFilterOutputBody: Swift.Equatable {
    let name: Swift.String?
}

extension CreateFilterOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "name"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

enum CreateFilterOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateIPSetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case activate = "activate"
        case clientToken = "clientToken"
        case format = "format"
        case location = "location"
        case name = "name"
        case tags = "tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let activate = self.activate {
            try encodeContainer.encode(activate, forKey: .activate)
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let format = self.format {
            try encodeContainer.encode(format.rawValue, forKey: .format)
        }
        if let location = self.location {
            try encodeContainer.encode(location, forKey: .location)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateIPSetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let detectorId = detectorId else {
            return nil
        }
        return "/detector/\(detectorId.urlPercentEncoding())/ipset"
    }
}

public struct CreateIPSetInput: Swift.Equatable {
    /// A Boolean value that indicates whether GuardDuty is to start using the uploaded IPSet.
    /// This member is required.
    public var activate: Swift.Bool?
    /// The idempotency token for the create request.
    public var clientToken: Swift.String?
    /// The unique ID of the detector of the GuardDuty account that you want to create an IPSet for.
    /// This member is required.
    public var detectorId: Swift.String?
    /// The format of the file that contains the IPSet.
    /// This member is required.
    public var format: GuardDutyClientTypes.IpSetFormat?
    /// The URI of the file that contains the IPSet.
    /// This member is required.
    public var location: Swift.String?
    /// The user-friendly name to identify the IPSet. Allowed characters are alphanumeric, whitespace, dash (-), and underscores (_).
    /// This member is required.
    public var name: Swift.String?
    /// The tags to be added to a new IP set resource.
    public var tags: [Swift.String:Swift.String]?

    public init(
        activate: Swift.Bool? = nil,
        clientToken: Swift.String? = nil,
        detectorId: Swift.String? = nil,
        format: GuardDutyClientTypes.IpSetFormat? = nil,
        location: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.activate = activate
        self.clientToken = clientToken
        self.detectorId = detectorId
        self.format = format
        self.location = location
        self.name = name
        self.tags = tags
    }
}

struct CreateIPSetInputBody: Swift.Equatable {
    let name: Swift.String?
    let format: GuardDutyClientTypes.IpSetFormat?
    let location: Swift.String?
    let activate: Swift.Bool?
    let clientToken: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateIPSetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case activate = "activate"
        case clientToken = "clientToken"
        case format = "format"
        case location = "location"
        case name = "name"
        case tags = "tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let formatDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.IpSetFormat.self, forKey: .format)
        format = formatDecoded
        let locationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .location)
        location = locationDecoded
        let activateDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .activate)
        activate = activateDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateIPSetOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateIPSetOutputBody = try responseDecoder.decode(responseBody: data)
            self.ipSetId = output.ipSetId
        } else {
            self.ipSetId = nil
        }
    }
}

public struct CreateIPSetOutput: Swift.Equatable {
    /// The ID of the IPSet resource.
    /// This member is required.
    public var ipSetId: Swift.String?

    public init(
        ipSetId: Swift.String? = nil
    )
    {
        self.ipSetId = ipSetId
    }
}

struct CreateIPSetOutputBody: Swift.Equatable {
    let ipSetId: Swift.String?
}

extension CreateIPSetOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ipSetId = "ipSetId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ipSetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ipSetId)
        ipSetId = ipSetIdDecoded
    }
}

enum CreateIPSetOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateMembersInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountDetails = "accountDetails"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountDetails = accountDetails {
            var accountDetailsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accountDetails)
            for accountdetail0 in accountDetails {
                try accountDetailsContainer.encode(accountdetail0)
            }
        }
    }
}

extension CreateMembersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let detectorId = detectorId else {
            return nil
        }
        return "/detector/\(detectorId.urlPercentEncoding())/member"
    }
}

public struct CreateMembersInput: Swift.Equatable {
    /// A list of account ID and email address pairs of the accounts that you want to associate with the GuardDuty administrator account.
    /// This member is required.
    public var accountDetails: [GuardDutyClientTypes.AccountDetail]?
    /// The unique ID of the detector of the GuardDuty account that you want to associate member accounts with.
    /// This member is required.
    public var detectorId: Swift.String?

    public init(
        accountDetails: [GuardDutyClientTypes.AccountDetail]? = nil,
        detectorId: Swift.String? = nil
    )
    {
        self.accountDetails = accountDetails
        self.detectorId = detectorId
    }
}

struct CreateMembersInputBody: Swift.Equatable {
    let accountDetails: [GuardDutyClientTypes.AccountDetail]?
}

extension CreateMembersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountDetails = "accountDetails"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountDetailsContainer = try containerValues.decodeIfPresent([GuardDutyClientTypes.AccountDetail?].self, forKey: .accountDetails)
        var accountDetailsDecoded0:[GuardDutyClientTypes.AccountDetail]? = nil
        if let accountDetailsContainer = accountDetailsContainer {
            accountDetailsDecoded0 = [GuardDutyClientTypes.AccountDetail]()
            for structure0 in accountDetailsContainer {
                if let structure0 = structure0 {
                    accountDetailsDecoded0?.append(structure0)
                }
            }
        }
        accountDetails = accountDetailsDecoded0
    }
}

extension CreateMembersOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateMembersOutputBody = try responseDecoder.decode(responseBody: data)
            self.unprocessedAccounts = output.unprocessedAccounts
        } else {
            self.unprocessedAccounts = nil
        }
    }
}

public struct CreateMembersOutput: Swift.Equatable {
    /// A list of objects that include the accountIds of the unprocessed accounts and a result string that explains why each was unprocessed.
    /// This member is required.
    public var unprocessedAccounts: [GuardDutyClientTypes.UnprocessedAccount]?

    public init(
        unprocessedAccounts: [GuardDutyClientTypes.UnprocessedAccount]? = nil
    )
    {
        self.unprocessedAccounts = unprocessedAccounts
    }
}

struct CreateMembersOutputBody: Swift.Equatable {
    let unprocessedAccounts: [GuardDutyClientTypes.UnprocessedAccount]?
}

extension CreateMembersOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case unprocessedAccounts = "unprocessedAccounts"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let unprocessedAccountsContainer = try containerValues.decodeIfPresent([GuardDutyClientTypes.UnprocessedAccount?].self, forKey: .unprocessedAccounts)
        var unprocessedAccountsDecoded0:[GuardDutyClientTypes.UnprocessedAccount]? = nil
        if let unprocessedAccountsContainer = unprocessedAccountsContainer {
            unprocessedAccountsDecoded0 = [GuardDutyClientTypes.UnprocessedAccount]()
            for structure0 in unprocessedAccountsContainer {
                if let structure0 = structure0 {
                    unprocessedAccountsDecoded0?.append(structure0)
                }
            }
        }
        unprocessedAccounts = unprocessedAccountsDecoded0
    }
}

enum CreateMembersOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreatePublishingDestinationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "clientToken"
        case destinationProperties = "destinationProperties"
        case destinationType = "destinationType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let destinationProperties = self.destinationProperties {
            try encodeContainer.encode(destinationProperties, forKey: .destinationProperties)
        }
        if let destinationType = self.destinationType {
            try encodeContainer.encode(destinationType.rawValue, forKey: .destinationType)
        }
    }
}

extension CreatePublishingDestinationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let detectorId = detectorId else {
            return nil
        }
        return "/detector/\(detectorId.urlPercentEncoding())/publishingDestination"
    }
}

public struct CreatePublishingDestinationInput: Swift.Equatable {
    /// The idempotency token for the request.
    public var clientToken: Swift.String?
    /// The properties of the publishing destination, including the ARNs for the destination and the KMS key used for encryption.
    /// This member is required.
    public var destinationProperties: GuardDutyClientTypes.DestinationProperties?
    /// The type of resource for the publishing destination. Currently only Amazon S3 buckets are supported.
    /// This member is required.
    public var destinationType: GuardDutyClientTypes.DestinationType?
    /// The ID of the GuardDuty detector associated with the publishing destination.
    /// This member is required.
    public var detectorId: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        destinationProperties: GuardDutyClientTypes.DestinationProperties? = nil,
        destinationType: GuardDutyClientTypes.DestinationType? = nil,
        detectorId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.destinationProperties = destinationProperties
        self.destinationType = destinationType
        self.detectorId = detectorId
    }
}

struct CreatePublishingDestinationInputBody: Swift.Equatable {
    let destinationType: GuardDutyClientTypes.DestinationType?
    let destinationProperties: GuardDutyClientTypes.DestinationProperties?
    let clientToken: Swift.String?
}

extension CreatePublishingDestinationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "clientToken"
        case destinationProperties = "destinationProperties"
        case destinationType = "destinationType"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let destinationTypeDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.DestinationType.self, forKey: .destinationType)
        destinationType = destinationTypeDecoded
        let destinationPropertiesDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.DestinationProperties.self, forKey: .destinationProperties)
        destinationProperties = destinationPropertiesDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CreatePublishingDestinationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreatePublishingDestinationOutputBody = try responseDecoder.decode(responseBody: data)
            self.destinationId = output.destinationId
        } else {
            self.destinationId = nil
        }
    }
}

public struct CreatePublishingDestinationOutput: Swift.Equatable {
    /// The ID of the publishing destination that is created.
    /// This member is required.
    public var destinationId: Swift.String?

    public init(
        destinationId: Swift.String? = nil
    )
    {
        self.destinationId = destinationId
    }
}

struct CreatePublishingDestinationOutputBody: Swift.Equatable {
    let destinationId: Swift.String?
}

extension CreatePublishingDestinationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationId = "destinationId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let destinationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationId)
        destinationId = destinationIdDecoded
    }
}

enum CreatePublishingDestinationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateSampleFindingsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case findingTypes = "findingTypes"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let findingTypes = findingTypes {
            var findingTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .findingTypes)
            for findingtype0 in findingTypes {
                try findingTypesContainer.encode(findingtype0)
            }
        }
    }
}

extension CreateSampleFindingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let detectorId = detectorId else {
            return nil
        }
        return "/detector/\(detectorId.urlPercentEncoding())/findings/create"
    }
}

public struct CreateSampleFindingsInput: Swift.Equatable {
    /// The ID of the detector to create sample findings for.
    /// This member is required.
    public var detectorId: Swift.String?
    /// The types of sample findings to generate.
    public var findingTypes: [Swift.String]?

    public init(
        detectorId: Swift.String? = nil,
        findingTypes: [Swift.String]? = nil
    )
    {
        self.detectorId = detectorId
        self.findingTypes = findingTypes
    }
}

struct CreateSampleFindingsInputBody: Swift.Equatable {
    let findingTypes: [Swift.String]?
}

extension CreateSampleFindingsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case findingTypes = "findingTypes"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let findingTypesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .findingTypes)
        var findingTypesDecoded0:[Swift.String]? = nil
        if let findingTypesContainer = findingTypesContainer {
            findingTypesDecoded0 = [Swift.String]()
            for string0 in findingTypesContainer {
                if let string0 = string0 {
                    findingTypesDecoded0?.append(string0)
                }
            }
        }
        findingTypes = findingTypesDecoded0
    }
}

extension CreateSampleFindingsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct CreateSampleFindingsOutput: Swift.Equatable {

    public init() { }
}

enum CreateSampleFindingsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateThreatIntelSetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case activate = "activate"
        case clientToken = "clientToken"
        case format = "format"
        case location = "location"
        case name = "name"
        case tags = "tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let activate = self.activate {
            try encodeContainer.encode(activate, forKey: .activate)
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let format = self.format {
            try encodeContainer.encode(format.rawValue, forKey: .format)
        }
        if let location = self.location {
            try encodeContainer.encode(location, forKey: .location)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateThreatIntelSetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let detectorId = detectorId else {
            return nil
        }
        return "/detector/\(detectorId.urlPercentEncoding())/threatintelset"
    }
}

public struct CreateThreatIntelSetInput: Swift.Equatable {
    /// A Boolean value that indicates whether GuardDuty is to start using the uploaded ThreatIntelSet.
    /// This member is required.
    public var activate: Swift.Bool?
    /// The idempotency token for the create request.
    public var clientToken: Swift.String?
    /// The unique ID of the detector of the GuardDuty account that you want to create a threatIntelSet for.
    /// This member is required.
    public var detectorId: Swift.String?
    /// The format of the file that contains the ThreatIntelSet.
    /// This member is required.
    public var format: GuardDutyClientTypes.ThreatIntelSetFormat?
    /// The URI of the file that contains the ThreatIntelSet.
    /// This member is required.
    public var location: Swift.String?
    /// A user-friendly ThreatIntelSet name displayed in all findings that are generated by activity that involves IP addresses included in this ThreatIntelSet.
    /// This member is required.
    public var name: Swift.String?
    /// The tags to be added to a new threat list resource.
    public var tags: [Swift.String:Swift.String]?

    public init(
        activate: Swift.Bool? = nil,
        clientToken: Swift.String? = nil,
        detectorId: Swift.String? = nil,
        format: GuardDutyClientTypes.ThreatIntelSetFormat? = nil,
        location: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.activate = activate
        self.clientToken = clientToken
        self.detectorId = detectorId
        self.format = format
        self.location = location
        self.name = name
        self.tags = tags
    }
}

struct CreateThreatIntelSetInputBody: Swift.Equatable {
    let name: Swift.String?
    let format: GuardDutyClientTypes.ThreatIntelSetFormat?
    let location: Swift.String?
    let activate: Swift.Bool?
    let clientToken: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateThreatIntelSetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case activate = "activate"
        case clientToken = "clientToken"
        case format = "format"
        case location = "location"
        case name = "name"
        case tags = "tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let formatDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.ThreatIntelSetFormat.self, forKey: .format)
        format = formatDecoded
        let locationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .location)
        location = locationDecoded
        let activateDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .activate)
        activate = activateDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateThreatIntelSetOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateThreatIntelSetOutputBody = try responseDecoder.decode(responseBody: data)
            self.threatIntelSetId = output.threatIntelSetId
        } else {
            self.threatIntelSetId = nil
        }
    }
}

public struct CreateThreatIntelSetOutput: Swift.Equatable {
    /// The ID of the ThreatIntelSet resource.
    /// This member is required.
    public var threatIntelSetId: Swift.String?

    public init(
        threatIntelSetId: Swift.String? = nil
    )
    {
        self.threatIntelSetId = threatIntelSetId
    }
}

struct CreateThreatIntelSetOutputBody: Swift.Equatable {
    let threatIntelSetId: Swift.String?
}

extension CreateThreatIntelSetOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case threatIntelSetId = "threatIntelSetId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let threatIntelSetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .threatIntelSetId)
        threatIntelSetId = threatIntelSetIdDecoded
    }
}

enum CreateThreatIntelSetOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GuardDutyClientTypes {
    public enum CriterionKey: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case accountId
        case ec2InstanceArn
        case guarddutyFindingId
        case scanId
        case scanStartTime
        case scanStatus
        case scanType
        case sdkUnknown(Swift.String)

        public static var allCases: [CriterionKey] {
            return [
                .accountId,
                .ec2InstanceArn,
                .guarddutyFindingId,
                .scanId,
                .scanStartTime,
                .scanStatus,
                .scanType,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .accountId: return "ACCOUNT_ID"
            case .ec2InstanceArn: return "EC2_INSTANCE_ARN"
            case .guarddutyFindingId: return "GUARDDUTY_FINDING_ID"
            case .scanId: return "SCAN_ID"
            case .scanStartTime: return "SCAN_START_TIME"
            case .scanStatus: return "SCAN_STATUS"
            case .scanType: return "SCAN_TYPE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CriterionKey(rawValue: rawValue) ?? CriterionKey.sdkUnknown(rawValue)
        }
    }
}

extension GuardDutyClientTypes.DNSLogsConfigurationResult: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status = "status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.DataSourceStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension GuardDutyClientTypes {
    /// Contains information on the status of DNS logs as a data source.
    public struct DNSLogsConfigurationResult: Swift.Equatable {
        /// Denotes whether DNS logs is enabled as a data source.
        /// This member is required.
        public var status: GuardDutyClientTypes.DataSourceStatus?

        public init(
            status: GuardDutyClientTypes.DataSourceStatus? = nil
        )
        {
            self.status = status
        }
    }

}

extension GuardDutyClientTypes {
    public enum DataSource: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cloudTrail
        case dnsLogs
        case ec2MalwareScan
        case flowLogs
        case kubernetesAuditLogs
        case s3Logs
        case sdkUnknown(Swift.String)

        public static var allCases: [DataSource] {
            return [
                .cloudTrail,
                .dnsLogs,
                .ec2MalwareScan,
                .flowLogs,
                .kubernetesAuditLogs,
                .s3Logs,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cloudTrail: return "CLOUD_TRAIL"
            case .dnsLogs: return "DNS_LOGS"
            case .ec2MalwareScan: return "EC2_MALWARE_SCAN"
            case .flowLogs: return "FLOW_LOGS"
            case .kubernetesAuditLogs: return "KUBERNETES_AUDIT_LOGS"
            case .s3Logs: return "S3_LOGS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DataSource(rawValue: rawValue) ?? DataSource.sdkUnknown(rawValue)
        }
    }
}

extension GuardDutyClientTypes.DataSourceConfigurations: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case kubernetes = "kubernetes"
        case malwareProtection = "malwareProtection"
        case s3Logs = "s3Logs"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let kubernetes = self.kubernetes {
            try encodeContainer.encode(kubernetes, forKey: .kubernetes)
        }
        if let malwareProtection = self.malwareProtection {
            try encodeContainer.encode(malwareProtection, forKey: .malwareProtection)
        }
        if let s3Logs = self.s3Logs {
            try encodeContainer.encode(s3Logs, forKey: .s3Logs)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3LogsDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.S3LogsConfiguration.self, forKey: .s3Logs)
        s3Logs = s3LogsDecoded
        let kubernetesDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.KubernetesConfiguration.self, forKey: .kubernetes)
        kubernetes = kubernetesDecoded
        let malwareProtectionDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.MalwareProtectionConfiguration.self, forKey: .malwareProtection)
        malwareProtection = malwareProtectionDecoded
    }
}

extension GuardDutyClientTypes {
    /// Contains information about which data sources are enabled.
    public struct DataSourceConfigurations: Swift.Equatable {
        /// Describes whether any Kubernetes logs are enabled as data sources.
        public var kubernetes: GuardDutyClientTypes.KubernetesConfiguration?
        /// Describes whether Malware Protection is enabled as a data source.
        public var malwareProtection: GuardDutyClientTypes.MalwareProtectionConfiguration?
        /// Describes whether S3 data event logs are enabled as a data source.
        public var s3Logs: GuardDutyClientTypes.S3LogsConfiguration?

        public init(
            kubernetes: GuardDutyClientTypes.KubernetesConfiguration? = nil,
            malwareProtection: GuardDutyClientTypes.MalwareProtectionConfiguration? = nil,
            s3Logs: GuardDutyClientTypes.S3LogsConfiguration? = nil
        )
        {
            self.kubernetes = kubernetes
            self.malwareProtection = malwareProtection
            self.s3Logs = s3Logs
        }
    }

}

extension GuardDutyClientTypes.DataSourceConfigurationsResult: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cloudTrail = "cloudTrail"
        case dnsLogs = "dnsLogs"
        case flowLogs = "flowLogs"
        case kubernetes = "kubernetes"
        case malwareProtection = "malwareProtection"
        case s3Logs = "s3Logs"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cloudTrail = self.cloudTrail {
            try encodeContainer.encode(cloudTrail, forKey: .cloudTrail)
        }
        if let dnsLogs = self.dnsLogs {
            try encodeContainer.encode(dnsLogs, forKey: .dnsLogs)
        }
        if let flowLogs = self.flowLogs {
            try encodeContainer.encode(flowLogs, forKey: .flowLogs)
        }
        if let kubernetes = self.kubernetes {
            try encodeContainer.encode(kubernetes, forKey: .kubernetes)
        }
        if let malwareProtection = self.malwareProtection {
            try encodeContainer.encode(malwareProtection, forKey: .malwareProtection)
        }
        if let s3Logs = self.s3Logs {
            try encodeContainer.encode(s3Logs, forKey: .s3Logs)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cloudTrailDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.CloudTrailConfigurationResult.self, forKey: .cloudTrail)
        cloudTrail = cloudTrailDecoded
        let dnsLogsDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.DNSLogsConfigurationResult.self, forKey: .dnsLogs)
        dnsLogs = dnsLogsDecoded
        let flowLogsDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.FlowLogsConfigurationResult.self, forKey: .flowLogs)
        flowLogs = flowLogsDecoded
        let s3LogsDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.S3LogsConfigurationResult.self, forKey: .s3Logs)
        s3Logs = s3LogsDecoded
        let kubernetesDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.KubernetesConfigurationResult.self, forKey: .kubernetes)
        kubernetes = kubernetesDecoded
        let malwareProtectionDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.MalwareProtectionConfigurationResult.self, forKey: .malwareProtection)
        malwareProtection = malwareProtectionDecoded
    }
}

extension GuardDutyClientTypes {
    /// Contains information on the status of data sources for the detector.
    public struct DataSourceConfigurationsResult: Swift.Equatable {
        /// An object that contains information on the status of CloudTrail as a data source.
        /// This member is required.
        public var cloudTrail: GuardDutyClientTypes.CloudTrailConfigurationResult?
        /// An object that contains information on the status of DNS logs as a data source.
        /// This member is required.
        public var dnsLogs: GuardDutyClientTypes.DNSLogsConfigurationResult?
        /// An object that contains information on the status of VPC flow logs as a data source.
        /// This member is required.
        public var flowLogs: GuardDutyClientTypes.FlowLogsConfigurationResult?
        /// An object that contains information on the status of all Kubernetes data sources.
        public var kubernetes: GuardDutyClientTypes.KubernetesConfigurationResult?
        /// Describes the configuration of Malware Protection data sources.
        public var malwareProtection: GuardDutyClientTypes.MalwareProtectionConfigurationResult?
        /// An object that contains information on the status of S3 Data event logs as a data source.
        /// This member is required.
        public var s3Logs: GuardDutyClientTypes.S3LogsConfigurationResult?

        public init(
            cloudTrail: GuardDutyClientTypes.CloudTrailConfigurationResult? = nil,
            dnsLogs: GuardDutyClientTypes.DNSLogsConfigurationResult? = nil,
            flowLogs: GuardDutyClientTypes.FlowLogsConfigurationResult? = nil,
            kubernetes: GuardDutyClientTypes.KubernetesConfigurationResult? = nil,
            malwareProtection: GuardDutyClientTypes.MalwareProtectionConfigurationResult? = nil,
            s3Logs: GuardDutyClientTypes.S3LogsConfigurationResult? = nil
        )
        {
            self.cloudTrail = cloudTrail
            self.dnsLogs = dnsLogs
            self.flowLogs = flowLogs
            self.kubernetes = kubernetes
            self.malwareProtection = malwareProtection
            self.s3Logs = s3Logs
        }
    }

}

extension GuardDutyClientTypes.DataSourceFreeTrial: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case freeTrialDaysRemaining = "freeTrialDaysRemaining"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if freeTrialDaysRemaining != 0 {
            try encodeContainer.encode(freeTrialDaysRemaining, forKey: .freeTrialDaysRemaining)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let freeTrialDaysRemainingDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .freeTrialDaysRemaining) ?? 0
        freeTrialDaysRemaining = freeTrialDaysRemainingDecoded
    }
}

extension GuardDutyClientTypes {
    /// Contains information about which data sources are enabled for the GuardDuty member account.
    public struct DataSourceFreeTrial: Swift.Equatable {
        /// A value that specifies the number of days left to use each enabled data source.
        public var freeTrialDaysRemaining: Swift.Int

        public init(
            freeTrialDaysRemaining: Swift.Int = 0
        )
        {
            self.freeTrialDaysRemaining = freeTrialDaysRemaining
        }
    }

}

extension GuardDutyClientTypes {
    public enum DataSourceStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [DataSourceStatus] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DataSourceStatus(rawValue: rawValue) ?? DataSourceStatus.sdkUnknown(rawValue)
        }
    }
}

extension GuardDutyClientTypes.DataSourcesFreeTrial: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cloudTrail = "cloudTrail"
        case dnsLogs = "dnsLogs"
        case flowLogs = "flowLogs"
        case kubernetes = "kubernetes"
        case malwareProtection = "malwareProtection"
        case s3Logs = "s3Logs"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cloudTrail = self.cloudTrail {
            try encodeContainer.encode(cloudTrail, forKey: .cloudTrail)
        }
        if let dnsLogs = self.dnsLogs {
            try encodeContainer.encode(dnsLogs, forKey: .dnsLogs)
        }
        if let flowLogs = self.flowLogs {
            try encodeContainer.encode(flowLogs, forKey: .flowLogs)
        }
        if let kubernetes = self.kubernetes {
            try encodeContainer.encode(kubernetes, forKey: .kubernetes)
        }
        if let malwareProtection = self.malwareProtection {
            try encodeContainer.encode(malwareProtection, forKey: .malwareProtection)
        }
        if let s3Logs = self.s3Logs {
            try encodeContainer.encode(s3Logs, forKey: .s3Logs)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cloudTrailDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.DataSourceFreeTrial.self, forKey: .cloudTrail)
        cloudTrail = cloudTrailDecoded
        let dnsLogsDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.DataSourceFreeTrial.self, forKey: .dnsLogs)
        dnsLogs = dnsLogsDecoded
        let flowLogsDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.DataSourceFreeTrial.self, forKey: .flowLogs)
        flowLogs = flowLogsDecoded
        let s3LogsDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.DataSourceFreeTrial.self, forKey: .s3Logs)
        s3Logs = s3LogsDecoded
        let kubernetesDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.KubernetesDataSourceFreeTrial.self, forKey: .kubernetes)
        kubernetes = kubernetesDecoded
        let malwareProtectionDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.MalwareProtectionDataSourceFreeTrial.self, forKey: .malwareProtection)
        malwareProtection = malwareProtectionDecoded
    }
}

extension GuardDutyClientTypes {
    /// Contains information about which data sources are enabled for the GuardDuty member account.
    public struct DataSourcesFreeTrial: Swift.Equatable {
        /// Describes whether any Amazon Web Services CloudTrail management event logs are enabled as data sources.
        public var cloudTrail: GuardDutyClientTypes.DataSourceFreeTrial?
        /// Describes whether any DNS logs are enabled as data sources.
        public var dnsLogs: GuardDutyClientTypes.DataSourceFreeTrial?
        /// Describes whether any VPC Flow logs are enabled as data sources.
        public var flowLogs: GuardDutyClientTypes.DataSourceFreeTrial?
        /// Describes whether any Kubernetes logs are enabled as data sources.
        public var kubernetes: GuardDutyClientTypes.KubernetesDataSourceFreeTrial?
        /// Describes whether Malware Protection is enabled as a data source.
        public var malwareProtection: GuardDutyClientTypes.MalwareProtectionDataSourceFreeTrial?
        /// Describes whether any S3 data event logs are enabled as data sources.
        public var s3Logs: GuardDutyClientTypes.DataSourceFreeTrial?

        public init(
            cloudTrail: GuardDutyClientTypes.DataSourceFreeTrial? = nil,
            dnsLogs: GuardDutyClientTypes.DataSourceFreeTrial? = nil,
            flowLogs: GuardDutyClientTypes.DataSourceFreeTrial? = nil,
            kubernetes: GuardDutyClientTypes.KubernetesDataSourceFreeTrial? = nil,
            malwareProtection: GuardDutyClientTypes.MalwareProtectionDataSourceFreeTrial? = nil,
            s3Logs: GuardDutyClientTypes.DataSourceFreeTrial? = nil
        )
        {
            self.cloudTrail = cloudTrail
            self.dnsLogs = dnsLogs
            self.flowLogs = flowLogs
            self.kubernetes = kubernetes
            self.malwareProtection = malwareProtection
            self.s3Logs = s3Logs
        }
    }

}

extension DeclineInvitationsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountIds = "accountIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountIds = accountIds {
            var accountIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accountIds)
            for accountid0 in accountIds {
                try accountIdsContainer.encode(accountid0)
            }
        }
    }
}

extension DeclineInvitationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/invitation/decline"
    }
}

public struct DeclineInvitationsInput: Swift.Equatable {
    /// A list of account IDs of the Amazon Web Services accounts that sent invitations to the current member account that you want to decline invitations from.
    /// This member is required.
    public var accountIds: [Swift.String]?

    public init(
        accountIds: [Swift.String]? = nil
    )
    {
        self.accountIds = accountIds
    }
}

struct DeclineInvitationsInputBody: Swift.Equatable {
    let accountIds: [Swift.String]?
}

extension DeclineInvitationsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountIds = "accountIds"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .accountIds)
        var accountIdsDecoded0:[Swift.String]? = nil
        if let accountIdsContainer = accountIdsContainer {
            accountIdsDecoded0 = [Swift.String]()
            for string0 in accountIdsContainer {
                if let string0 = string0 {
                    accountIdsDecoded0?.append(string0)
                }
            }
        }
        accountIds = accountIdsDecoded0
    }
}

extension DeclineInvitationsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeclineInvitationsOutputBody = try responseDecoder.decode(responseBody: data)
            self.unprocessedAccounts = output.unprocessedAccounts
        } else {
            self.unprocessedAccounts = nil
        }
    }
}

public struct DeclineInvitationsOutput: Swift.Equatable {
    /// A list of objects that contain the unprocessed account and a result string that explains why it was unprocessed.
    /// This member is required.
    public var unprocessedAccounts: [GuardDutyClientTypes.UnprocessedAccount]?

    public init(
        unprocessedAccounts: [GuardDutyClientTypes.UnprocessedAccount]? = nil
    )
    {
        self.unprocessedAccounts = unprocessedAccounts
    }
}

struct DeclineInvitationsOutputBody: Swift.Equatable {
    let unprocessedAccounts: [GuardDutyClientTypes.UnprocessedAccount]?
}

extension DeclineInvitationsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case unprocessedAccounts = "unprocessedAccounts"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let unprocessedAccountsContainer = try containerValues.decodeIfPresent([GuardDutyClientTypes.UnprocessedAccount?].self, forKey: .unprocessedAccounts)
        var unprocessedAccountsDecoded0:[GuardDutyClientTypes.UnprocessedAccount]? = nil
        if let unprocessedAccountsContainer = unprocessedAccountsContainer {
            unprocessedAccountsDecoded0 = [GuardDutyClientTypes.UnprocessedAccount]()
            for structure0 in unprocessedAccountsContainer {
                if let structure0 = structure0 {
                    unprocessedAccountsDecoded0?.append(structure0)
                }
            }
        }
        unprocessedAccounts = unprocessedAccountsDecoded0
    }
}

enum DeclineInvitationsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GuardDutyClientTypes.DefaultServerSideEncryption: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case encryptionType = "encryptionType"
        case kmsMasterKeyArn = "kmsMasterKeyArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let encryptionType = self.encryptionType {
            try encodeContainer.encode(encryptionType, forKey: .encryptionType)
        }
        if let kmsMasterKeyArn = self.kmsMasterKeyArn {
            try encodeContainer.encode(kmsMasterKeyArn, forKey: .kmsMasterKeyArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let encryptionTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .encryptionType)
        encryptionType = encryptionTypeDecoded
        let kmsMasterKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsMasterKeyArn)
        kmsMasterKeyArn = kmsMasterKeyArnDecoded
    }
}

extension GuardDutyClientTypes {
    /// Contains information on the server side encryption method used in the S3 bucket. See [S3 Server-Side Encryption](https://docs.aws.amazon.com/AmazonS3/latest/dev/serv-side-encryption.html) for more information.
    public struct DefaultServerSideEncryption: Swift.Equatable {
        /// The type of encryption used for objects within the S3 bucket.
        public var encryptionType: Swift.String?
        /// The Amazon Resource Name (ARN) of the KMS encryption key. Only available if the bucket EncryptionType is aws:kms.
        public var kmsMasterKeyArn: Swift.String?

        public init(
            encryptionType: Swift.String? = nil,
            kmsMasterKeyArn: Swift.String? = nil
        )
        {
            self.encryptionType = encryptionType
            self.kmsMasterKeyArn = kmsMasterKeyArn
        }
    }

}

extension DeleteDetectorInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let detectorId = detectorId else {
            return nil
        }
        return "/detector/\(detectorId.urlPercentEncoding())"
    }
}

public struct DeleteDetectorInput: Swift.Equatable {
    /// The unique ID of the detector that you want to delete.
    /// This member is required.
    public var detectorId: Swift.String?

    public init(
        detectorId: Swift.String? = nil
    )
    {
        self.detectorId = detectorId
    }
}

struct DeleteDetectorInputBody: Swift.Equatable {
}

extension DeleteDetectorInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteDetectorOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteDetectorOutput: Swift.Equatable {

    public init() { }
}

enum DeleteDetectorOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteFilterInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let detectorId = detectorId else {
            return nil
        }
        guard let filterName = filterName else {
            return nil
        }
        return "/detector/\(detectorId.urlPercentEncoding())/filter/\(filterName.urlPercentEncoding())"
    }
}

public struct DeleteFilterInput: Swift.Equatable {
    /// The unique ID of the detector that the filter is associated with.
    /// This member is required.
    public var detectorId: Swift.String?
    /// The name of the filter that you want to delete.
    /// This member is required.
    public var filterName: Swift.String?

    public init(
        detectorId: Swift.String? = nil,
        filterName: Swift.String? = nil
    )
    {
        self.detectorId = detectorId
        self.filterName = filterName
    }
}

struct DeleteFilterInputBody: Swift.Equatable {
}

extension DeleteFilterInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteFilterOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteFilterOutput: Swift.Equatable {

    public init() { }
}

enum DeleteFilterOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteIPSetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let detectorId = detectorId else {
            return nil
        }
        guard let ipSetId = ipSetId else {
            return nil
        }
        return "/detector/\(detectorId.urlPercentEncoding())/ipset/\(ipSetId.urlPercentEncoding())"
    }
}

public struct DeleteIPSetInput: Swift.Equatable {
    /// The unique ID of the detector associated with the IPSet.
    /// This member is required.
    public var detectorId: Swift.String?
    /// The unique ID of the IPSet to delete.
    /// This member is required.
    public var ipSetId: Swift.String?

    public init(
        detectorId: Swift.String? = nil,
        ipSetId: Swift.String? = nil
    )
    {
        self.detectorId = detectorId
        self.ipSetId = ipSetId
    }
}

struct DeleteIPSetInputBody: Swift.Equatable {
}

extension DeleteIPSetInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteIPSetOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteIPSetOutput: Swift.Equatable {

    public init() { }
}

enum DeleteIPSetOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteInvitationsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountIds = "accountIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountIds = accountIds {
            var accountIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accountIds)
            for accountid0 in accountIds {
                try accountIdsContainer.encode(accountid0)
            }
        }
    }
}

extension DeleteInvitationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/invitation/delete"
    }
}

public struct DeleteInvitationsInput: Swift.Equatable {
    /// A list of account IDs of the Amazon Web Services accounts that sent invitations to the current member account that you want to delete invitations from.
    /// This member is required.
    public var accountIds: [Swift.String]?

    public init(
        accountIds: [Swift.String]? = nil
    )
    {
        self.accountIds = accountIds
    }
}

struct DeleteInvitationsInputBody: Swift.Equatable {
    let accountIds: [Swift.String]?
}

extension DeleteInvitationsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountIds = "accountIds"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .accountIds)
        var accountIdsDecoded0:[Swift.String]? = nil
        if let accountIdsContainer = accountIdsContainer {
            accountIdsDecoded0 = [Swift.String]()
            for string0 in accountIdsContainer {
                if let string0 = string0 {
                    accountIdsDecoded0?.append(string0)
                }
            }
        }
        accountIds = accountIdsDecoded0
    }
}

extension DeleteInvitationsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteInvitationsOutputBody = try responseDecoder.decode(responseBody: data)
            self.unprocessedAccounts = output.unprocessedAccounts
        } else {
            self.unprocessedAccounts = nil
        }
    }
}

public struct DeleteInvitationsOutput: Swift.Equatable {
    /// A list of objects that contain the unprocessed account and a result string that explains why it was unprocessed.
    /// This member is required.
    public var unprocessedAccounts: [GuardDutyClientTypes.UnprocessedAccount]?

    public init(
        unprocessedAccounts: [GuardDutyClientTypes.UnprocessedAccount]? = nil
    )
    {
        self.unprocessedAccounts = unprocessedAccounts
    }
}

struct DeleteInvitationsOutputBody: Swift.Equatable {
    let unprocessedAccounts: [GuardDutyClientTypes.UnprocessedAccount]?
}

extension DeleteInvitationsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case unprocessedAccounts = "unprocessedAccounts"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let unprocessedAccountsContainer = try containerValues.decodeIfPresent([GuardDutyClientTypes.UnprocessedAccount?].self, forKey: .unprocessedAccounts)
        var unprocessedAccountsDecoded0:[GuardDutyClientTypes.UnprocessedAccount]? = nil
        if let unprocessedAccountsContainer = unprocessedAccountsContainer {
            unprocessedAccountsDecoded0 = [GuardDutyClientTypes.UnprocessedAccount]()
            for structure0 in unprocessedAccountsContainer {
                if let structure0 = structure0 {
                    unprocessedAccountsDecoded0?.append(structure0)
                }
            }
        }
        unprocessedAccounts = unprocessedAccountsDecoded0
    }
}

enum DeleteInvitationsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteMembersInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountIds = "accountIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountIds = accountIds {
            var accountIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accountIds)
            for accountid0 in accountIds {
                try accountIdsContainer.encode(accountid0)
            }
        }
    }
}

extension DeleteMembersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let detectorId = detectorId else {
            return nil
        }
        return "/detector/\(detectorId.urlPercentEncoding())/member/delete"
    }
}

public struct DeleteMembersInput: Swift.Equatable {
    /// A list of account IDs of the GuardDuty member accounts that you want to delete.
    /// This member is required.
    public var accountIds: [Swift.String]?
    /// The unique ID of the detector of the GuardDuty account whose members you want to delete.
    /// This member is required.
    public var detectorId: Swift.String?

    public init(
        accountIds: [Swift.String]? = nil,
        detectorId: Swift.String? = nil
    )
    {
        self.accountIds = accountIds
        self.detectorId = detectorId
    }
}

struct DeleteMembersInputBody: Swift.Equatable {
    let accountIds: [Swift.String]?
}

extension DeleteMembersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountIds = "accountIds"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .accountIds)
        var accountIdsDecoded0:[Swift.String]? = nil
        if let accountIdsContainer = accountIdsContainer {
            accountIdsDecoded0 = [Swift.String]()
            for string0 in accountIdsContainer {
                if let string0 = string0 {
                    accountIdsDecoded0?.append(string0)
                }
            }
        }
        accountIds = accountIdsDecoded0
    }
}

extension DeleteMembersOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteMembersOutputBody = try responseDecoder.decode(responseBody: data)
            self.unprocessedAccounts = output.unprocessedAccounts
        } else {
            self.unprocessedAccounts = nil
        }
    }
}

public struct DeleteMembersOutput: Swift.Equatable {
    /// The accounts that could not be processed.
    /// This member is required.
    public var unprocessedAccounts: [GuardDutyClientTypes.UnprocessedAccount]?

    public init(
        unprocessedAccounts: [GuardDutyClientTypes.UnprocessedAccount]? = nil
    )
    {
        self.unprocessedAccounts = unprocessedAccounts
    }
}

struct DeleteMembersOutputBody: Swift.Equatable {
    let unprocessedAccounts: [GuardDutyClientTypes.UnprocessedAccount]?
}

extension DeleteMembersOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case unprocessedAccounts = "unprocessedAccounts"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let unprocessedAccountsContainer = try containerValues.decodeIfPresent([GuardDutyClientTypes.UnprocessedAccount?].self, forKey: .unprocessedAccounts)
        var unprocessedAccountsDecoded0:[GuardDutyClientTypes.UnprocessedAccount]? = nil
        if let unprocessedAccountsContainer = unprocessedAccountsContainer {
            unprocessedAccountsDecoded0 = [GuardDutyClientTypes.UnprocessedAccount]()
            for structure0 in unprocessedAccountsContainer {
                if let structure0 = structure0 {
                    unprocessedAccountsDecoded0?.append(structure0)
                }
            }
        }
        unprocessedAccounts = unprocessedAccountsDecoded0
    }
}

enum DeleteMembersOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeletePublishingDestinationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let detectorId = detectorId else {
            return nil
        }
        guard let destinationId = destinationId else {
            return nil
        }
        return "/detector/\(detectorId.urlPercentEncoding())/publishingDestination/\(destinationId.urlPercentEncoding())"
    }
}

public struct DeletePublishingDestinationInput: Swift.Equatable {
    /// The ID of the publishing destination to delete.
    /// This member is required.
    public var destinationId: Swift.String?
    /// The unique ID of the detector associated with the publishing destination to delete.
    /// This member is required.
    public var detectorId: Swift.String?

    public init(
        destinationId: Swift.String? = nil,
        detectorId: Swift.String? = nil
    )
    {
        self.destinationId = destinationId
        self.detectorId = detectorId
    }
}

struct DeletePublishingDestinationInputBody: Swift.Equatable {
}

extension DeletePublishingDestinationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeletePublishingDestinationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeletePublishingDestinationOutput: Swift.Equatable {

    public init() { }
}

enum DeletePublishingDestinationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteThreatIntelSetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let detectorId = detectorId else {
            return nil
        }
        guard let threatIntelSetId = threatIntelSetId else {
            return nil
        }
        return "/detector/\(detectorId.urlPercentEncoding())/threatintelset/\(threatIntelSetId.urlPercentEncoding())"
    }
}

public struct DeleteThreatIntelSetInput: Swift.Equatable {
    /// The unique ID of the detector that the threatIntelSet is associated with.
    /// This member is required.
    public var detectorId: Swift.String?
    /// The unique ID of the threatIntelSet that you want to delete.
    /// This member is required.
    public var threatIntelSetId: Swift.String?

    public init(
        detectorId: Swift.String? = nil,
        threatIntelSetId: Swift.String? = nil
    )
    {
        self.detectorId = detectorId
        self.threatIntelSetId = threatIntelSetId
    }
}

struct DeleteThreatIntelSetInputBody: Swift.Equatable {
}

extension DeleteThreatIntelSetInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteThreatIntelSetOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteThreatIntelSetOutput: Swift.Equatable {

    public init() { }
}

enum DeleteThreatIntelSetOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeMalwareScansInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filterCriteria = "filterCriteria"
        case maxResults = "maxResults"
        case nextToken = "nextToken"
        case sortCriteria = "sortCriteria"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filterCriteria = self.filterCriteria {
            try encodeContainer.encode(filterCriteria, forKey: .filterCriteria)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let sortCriteria = self.sortCriteria {
            try encodeContainer.encode(sortCriteria, forKey: .sortCriteria)
        }
    }
}

extension DescribeMalwareScansInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let detectorId = detectorId else {
            return nil
        }
        return "/detector/\(detectorId.urlPercentEncoding())/malware-scans"
    }
}

public struct DescribeMalwareScansInput: Swift.Equatable {
    /// The unique ID of the detector that the request is associated with.
    /// This member is required.
    public var detectorId: Swift.String?
    /// Represents the criteria to be used in the filter for describing scan entries.
    public var filterCriteria: GuardDutyClientTypes.FilterCriteria?
    /// You can use this parameter to indicate the maximum number of items that you want in the response. The default value is 50. The maximum value is 50.
    public var maxResults: Swift.Int?
    /// You can use this parameter when paginating results. Set the value of this parameter to null on your first call to the list action. For subsequent calls to the action, fill nextToken in the request with the value of NextToken from the previous response to continue listing data.
    public var nextToken: Swift.String?
    /// Represents the criteria used for sorting scan entries. The [attributeName](https://docs.aws.amazon.com/guardduty/latest/APIReference/API_SortCriteria.html#guardduty-Type-SortCriteria-attributeName) is required and it must be scanStartTime.
    public var sortCriteria: GuardDutyClientTypes.SortCriteria?

    public init(
        detectorId: Swift.String? = nil,
        filterCriteria: GuardDutyClientTypes.FilterCriteria? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        sortCriteria: GuardDutyClientTypes.SortCriteria? = nil
    )
    {
        self.detectorId = detectorId
        self.filterCriteria = filterCriteria
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sortCriteria = sortCriteria
    }
}

struct DescribeMalwareScansInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
    let filterCriteria: GuardDutyClientTypes.FilterCriteria?
    let sortCriteria: GuardDutyClientTypes.SortCriteria?
}

extension DescribeMalwareScansInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filterCriteria = "filterCriteria"
        case maxResults = "maxResults"
        case nextToken = "nextToken"
        case sortCriteria = "sortCriteria"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let filterCriteriaDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.FilterCriteria.self, forKey: .filterCriteria)
        filterCriteria = filterCriteriaDecoded
        let sortCriteriaDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.SortCriteria.self, forKey: .sortCriteria)
        sortCriteria = sortCriteriaDecoded
    }
}

extension DescribeMalwareScansOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeMalwareScansOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.scans = output.scans
        } else {
            self.nextToken = nil
            self.scans = nil
        }
    }
}

public struct DescribeMalwareScansOutput: Swift.Equatable {
    /// The pagination parameter to be used on the next list operation to retrieve more items.
    public var nextToken: Swift.String?
    /// Contains information about malware scans.
    /// This member is required.
    public var scans: [GuardDutyClientTypes.Scan]?

    public init(
        nextToken: Swift.String? = nil,
        scans: [GuardDutyClientTypes.Scan]? = nil
    )
    {
        self.nextToken = nextToken
        self.scans = scans
    }
}

struct DescribeMalwareScansOutputBody: Swift.Equatable {
    let scans: [GuardDutyClientTypes.Scan]?
    let nextToken: Swift.String?
}

extension DescribeMalwareScansOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "nextToken"
        case scans = "scans"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scansContainer = try containerValues.decodeIfPresent([GuardDutyClientTypes.Scan?].self, forKey: .scans)
        var scansDecoded0:[GuardDutyClientTypes.Scan]? = nil
        if let scansContainer = scansContainer {
            scansDecoded0 = [GuardDutyClientTypes.Scan]()
            for structure0 in scansContainer {
                if let structure0 = structure0 {
                    scansDecoded0?.append(structure0)
                }
            }
        }
        scans = scansDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum DescribeMalwareScansOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeOrganizationConfigurationInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension DescribeOrganizationConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let detectorId = detectorId else {
            return nil
        }
        return "/detector/\(detectorId.urlPercentEncoding())/admin"
    }
}

public struct DescribeOrganizationConfigurationInput: Swift.Equatable {
    /// The ID of the detector to retrieve information about the delegated administrator from.
    /// This member is required.
    public var detectorId: Swift.String?
    /// You can use this parameter to indicate the maximum number of items that you want in the response.
    public var maxResults: Swift.Int?
    /// You can use this parameter when paginating results. Set the value of this parameter to null on your first call to the list action. For subsequent calls to the action, fill nextToken in the request with the value of NextToken from the previous response to continue listing data.
    public var nextToken: Swift.String?

    public init(
        detectorId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.detectorId = detectorId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct DescribeOrganizationConfigurationInputBody: Swift.Equatable {
}

extension DescribeOrganizationConfigurationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeOrganizationConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeOrganizationConfigurationOutputBody = try responseDecoder.decode(responseBody: data)
            self.autoEnable = output.autoEnable
            self.autoEnableOrganizationMembers = output.autoEnableOrganizationMembers
            self.dataSources = output.dataSources
            self.features = output.features
            self.memberAccountLimitReached = output.memberAccountLimitReached
            self.nextToken = output.nextToken
        } else {
            self.autoEnable = false
            self.autoEnableOrganizationMembers = nil
            self.dataSources = nil
            self.features = nil
            self.memberAccountLimitReached = false
            self.nextToken = nil
        }
    }
}

public struct DescribeOrganizationConfigurationOutput: Swift.Equatable {
    /// Indicates whether GuardDuty is automatically enabled for accounts added to the organization. Even though this is still supported, we recommend using AutoEnableOrganizationMembers to achieve the similar results.
    @available(*, deprecated, message: "This field is deprecated, use AutoEnableOrganizationMembers instead")
    public var autoEnable: Swift.Bool
    /// Indicates the auto-enablement configuration of GuardDuty for the member accounts in the organization.
    ///
    /// * NEW: Indicates that when a new account joins the organization, they will have GuardDuty enabled automatically.
    ///
    /// * ALL: Indicates that all accounts in the organization have GuardDuty enabled automatically. This includes NEW accounts that join the organization and accounts that may have been suspended or removed from the organization in GuardDuty.
    ///
    /// * NONE: Indicates that GuardDuty will not be automatically enabled for any account in the organization. The administrator must manage GuardDuty for each account in the organization individually.
    public var autoEnableOrganizationMembers: GuardDutyClientTypes.AutoEnableMembers?
    /// Describes which data sources are enabled automatically for member accounts.
    @available(*, deprecated, message: "This parameter is deprecated, use Features instead")
    public var dataSources: GuardDutyClientTypes.OrganizationDataSourceConfigurationsResult?
    /// A list of features that are configured for this organization.
    public var features: [GuardDutyClientTypes.OrganizationFeatureConfigurationResult]?
    /// Indicates whether the maximum number of allowed member accounts are already associated with the delegated administrator account for your organization.
    /// This member is required.
    public var memberAccountLimitReached: Swift.Bool
    /// The pagination parameter to be used on the next list operation to retrieve more items.
    public var nextToken: Swift.String?

    public init(
        autoEnable: Swift.Bool = false,
        autoEnableOrganizationMembers: GuardDutyClientTypes.AutoEnableMembers? = nil,
        dataSources: GuardDutyClientTypes.OrganizationDataSourceConfigurationsResult? = nil,
        features: [GuardDutyClientTypes.OrganizationFeatureConfigurationResult]? = nil,
        memberAccountLimitReached: Swift.Bool = false,
        nextToken: Swift.String? = nil
    )
    {
        self.autoEnable = autoEnable
        self.autoEnableOrganizationMembers = autoEnableOrganizationMembers
        self.dataSources = dataSources
        self.features = features
        self.memberAccountLimitReached = memberAccountLimitReached
        self.nextToken = nextToken
    }
}

struct DescribeOrganizationConfigurationOutputBody: Swift.Equatable {
    let autoEnable: Swift.Bool
    let memberAccountLimitReached: Swift.Bool
    let dataSources: GuardDutyClientTypes.OrganizationDataSourceConfigurationsResult?
    let features: [GuardDutyClientTypes.OrganizationFeatureConfigurationResult]?
    let nextToken: Swift.String?
    let autoEnableOrganizationMembers: GuardDutyClientTypes.AutoEnableMembers?
}

extension DescribeOrganizationConfigurationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoEnable = "autoEnable"
        case autoEnableOrganizationMembers = "autoEnableOrganizationMembers"
        case dataSources = "dataSources"
        case features = "features"
        case memberAccountLimitReached = "memberAccountLimitReached"
        case nextToken = "nextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let autoEnableDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .autoEnable) ?? false
        autoEnable = autoEnableDecoded
        let memberAccountLimitReachedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .memberAccountLimitReached) ?? false
        memberAccountLimitReached = memberAccountLimitReachedDecoded
        let dataSourcesDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.OrganizationDataSourceConfigurationsResult.self, forKey: .dataSources)
        dataSources = dataSourcesDecoded
        let featuresContainer = try containerValues.decodeIfPresent([GuardDutyClientTypes.OrganizationFeatureConfigurationResult?].self, forKey: .features)
        var featuresDecoded0:[GuardDutyClientTypes.OrganizationFeatureConfigurationResult]? = nil
        if let featuresContainer = featuresContainer {
            featuresDecoded0 = [GuardDutyClientTypes.OrganizationFeatureConfigurationResult]()
            for structure0 in featuresContainer {
                if let structure0 = structure0 {
                    featuresDecoded0?.append(structure0)
                }
            }
        }
        features = featuresDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let autoEnableOrganizationMembersDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.AutoEnableMembers.self, forKey: .autoEnableOrganizationMembers)
        autoEnableOrganizationMembers = autoEnableOrganizationMembersDecoded
    }
}

enum DescribeOrganizationConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribePublishingDestinationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let detectorId = detectorId else {
            return nil
        }
        guard let destinationId = destinationId else {
            return nil
        }
        return "/detector/\(detectorId.urlPercentEncoding())/publishingDestination/\(destinationId.urlPercentEncoding())"
    }
}

public struct DescribePublishingDestinationInput: Swift.Equatable {
    /// The ID of the publishing destination to retrieve.
    /// This member is required.
    public var destinationId: Swift.String?
    /// The unique ID of the detector associated with the publishing destination to retrieve.
    /// This member is required.
    public var detectorId: Swift.String?

    public init(
        destinationId: Swift.String? = nil,
        detectorId: Swift.String? = nil
    )
    {
        self.destinationId = destinationId
        self.detectorId = detectorId
    }
}

struct DescribePublishingDestinationInputBody: Swift.Equatable {
}

extension DescribePublishingDestinationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribePublishingDestinationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribePublishingDestinationOutputBody = try responseDecoder.decode(responseBody: data)
            self.destinationId = output.destinationId
            self.destinationProperties = output.destinationProperties
            self.destinationType = output.destinationType
            self.publishingFailureStartTimestamp = output.publishingFailureStartTimestamp
            self.status = output.status
        } else {
            self.destinationId = nil
            self.destinationProperties = nil
            self.destinationType = nil
            self.publishingFailureStartTimestamp = 0
            self.status = nil
        }
    }
}

public struct DescribePublishingDestinationOutput: Swift.Equatable {
    /// The ID of the publishing destination.
    /// This member is required.
    public var destinationId: Swift.String?
    /// A DestinationProperties object that includes the DestinationArn and KmsKeyArn of the publishing destination.
    /// This member is required.
    public var destinationProperties: GuardDutyClientTypes.DestinationProperties?
    /// The type of publishing destination. Currently, only Amazon S3 buckets are supported.
    /// This member is required.
    public var destinationType: GuardDutyClientTypes.DestinationType?
    /// The time, in epoch millisecond format, at which GuardDuty was first unable to publish findings to the destination.
    /// This member is required.
    public var publishingFailureStartTimestamp: Swift.Int
    /// The status of the publishing destination.
    /// This member is required.
    public var status: GuardDutyClientTypes.PublishingStatus?

    public init(
        destinationId: Swift.String? = nil,
        destinationProperties: GuardDutyClientTypes.DestinationProperties? = nil,
        destinationType: GuardDutyClientTypes.DestinationType? = nil,
        publishingFailureStartTimestamp: Swift.Int = 0,
        status: GuardDutyClientTypes.PublishingStatus? = nil
    )
    {
        self.destinationId = destinationId
        self.destinationProperties = destinationProperties
        self.destinationType = destinationType
        self.publishingFailureStartTimestamp = publishingFailureStartTimestamp
        self.status = status
    }
}

struct DescribePublishingDestinationOutputBody: Swift.Equatable {
    let destinationId: Swift.String?
    let destinationType: GuardDutyClientTypes.DestinationType?
    let status: GuardDutyClientTypes.PublishingStatus?
    let publishingFailureStartTimestamp: Swift.Int
    let destinationProperties: GuardDutyClientTypes.DestinationProperties?
}

extension DescribePublishingDestinationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationId = "destinationId"
        case destinationProperties = "destinationProperties"
        case destinationType = "destinationType"
        case publishingFailureStartTimestamp = "publishingFailureStartTimestamp"
        case status = "status"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let destinationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationId)
        destinationId = destinationIdDecoded
        let destinationTypeDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.DestinationType.self, forKey: .destinationType)
        destinationType = destinationTypeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.PublishingStatus.self, forKey: .status)
        status = statusDecoded
        let publishingFailureStartTimestampDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .publishingFailureStartTimestamp) ?? 0
        publishingFailureStartTimestamp = publishingFailureStartTimestampDecoded
        let destinationPropertiesDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.DestinationProperties.self, forKey: .destinationProperties)
        destinationProperties = destinationPropertiesDecoded
    }
}

enum DescribePublishingDestinationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GuardDutyClientTypes.Destination: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationId = "destinationId"
        case destinationType = "destinationType"
        case status = "status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destinationId = self.destinationId {
            try encodeContainer.encode(destinationId, forKey: .destinationId)
        }
        if let destinationType = self.destinationType {
            try encodeContainer.encode(destinationType.rawValue, forKey: .destinationType)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let destinationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationId)
        destinationId = destinationIdDecoded
        let destinationTypeDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.DestinationType.self, forKey: .destinationType)
        destinationType = destinationTypeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.PublishingStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension GuardDutyClientTypes {
    /// Contains information about the publishing destination, including the ID, type, and status.
    public struct Destination: Swift.Equatable {
        /// The unique ID of the publishing destination.
        /// This member is required.
        public var destinationId: Swift.String?
        /// The type of resource used for the publishing destination. Currently, only Amazon S3 buckets are supported.
        /// This member is required.
        public var destinationType: GuardDutyClientTypes.DestinationType?
        /// The status of the publishing destination.
        /// This member is required.
        public var status: GuardDutyClientTypes.PublishingStatus?

        public init(
            destinationId: Swift.String? = nil,
            destinationType: GuardDutyClientTypes.DestinationType? = nil,
            status: GuardDutyClientTypes.PublishingStatus? = nil
        )
        {
            self.destinationId = destinationId
            self.destinationType = destinationType
            self.status = status
        }
    }

}

extension GuardDutyClientTypes.DestinationProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationArn = "destinationArn"
        case kmsKeyArn = "kmsKeyArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destinationArn = self.destinationArn {
            try encodeContainer.encode(destinationArn, forKey: .destinationArn)
        }
        if let kmsKeyArn = self.kmsKeyArn {
            try encodeContainer.encode(kmsKeyArn, forKey: .kmsKeyArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let destinationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationArn)
        destinationArn = destinationArnDecoded
        let kmsKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyArn)
        kmsKeyArn = kmsKeyArnDecoded
    }
}

extension GuardDutyClientTypes {
    /// Contains the Amazon Resource Name (ARN) of the resource to publish to, such as an S3 bucket, and the ARN of the KMS key to use to encrypt published findings.
    public struct DestinationProperties: Swift.Equatable {
        /// The ARN of the resource to publish to. To specify an S3 bucket folder use the following format: arn:aws:s3:::DOC-EXAMPLE-BUCKET/myFolder/
        public var destinationArn: Swift.String?
        /// The ARN of the KMS key to use for encryption.
        public var kmsKeyArn: Swift.String?

        public init(
            destinationArn: Swift.String? = nil,
            kmsKeyArn: Swift.String? = nil
        )
        {
            self.destinationArn = destinationArn
            self.kmsKeyArn = kmsKeyArn
        }
    }

}

extension GuardDutyClientTypes {
    public enum DestinationType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case s3
        case sdkUnknown(Swift.String)

        public static var allCases: [DestinationType] {
            return [
                .s3,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .s3: return "S3"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DestinationType(rawValue: rawValue) ?? DestinationType.sdkUnknown(rawValue)
        }
    }
}

extension GuardDutyClientTypes.DetectorAdditionalConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "name"
        case status = "status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.FeatureAdditionalConfiguration.self, forKey: .name)
        name = nameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.FeatureStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension GuardDutyClientTypes {
    /// Information about the additional configuration for a feature in your GuardDuty account.
    public struct DetectorAdditionalConfiguration: Swift.Equatable {
        /// Name of the additional configuration.
        public var name: GuardDutyClientTypes.FeatureAdditionalConfiguration?
        /// Status of the additional configuration.
        public var status: GuardDutyClientTypes.FeatureStatus?

        public init(
            name: GuardDutyClientTypes.FeatureAdditionalConfiguration? = nil,
            status: GuardDutyClientTypes.FeatureStatus? = nil
        )
        {
            self.name = name
            self.status = status
        }
    }

}

extension GuardDutyClientTypes.DetectorAdditionalConfigurationResult: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "name"
        case status = "status"
        case updatedAt = "updatedAt"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let updatedAt = self.updatedAt {
            try encodeContainer.encodeTimestamp(updatedAt, format: .epochSeconds, forKey: .updatedAt)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.FeatureAdditionalConfiguration.self, forKey: .name)
        name = nameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.FeatureStatus.self, forKey: .status)
        status = statusDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
    }
}

extension GuardDutyClientTypes {
    /// Information about the additional configuration.
    public struct DetectorAdditionalConfigurationResult: Swift.Equatable {
        /// Name of the additional configuration.
        public var name: GuardDutyClientTypes.FeatureAdditionalConfiguration?
        /// Status of the additional configuration.
        public var status: GuardDutyClientTypes.FeatureStatus?
        /// The timestamp at which the additional configuration was last updated. This is in UTC format.
        public var updatedAt: ClientRuntime.Date?

        public init(
            name: GuardDutyClientTypes.FeatureAdditionalConfiguration? = nil,
            status: GuardDutyClientTypes.FeatureStatus? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.name = name
            self.status = status
            self.updatedAt = updatedAt
        }
    }

}

extension GuardDutyClientTypes {
    public enum DetectorFeature: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ebsMalwareProtection
        case eksAuditLogs
        case eksRuntimeMonitoring
        case lambdaNetworkLogs
        case rdsLoginEvents
        case s3DataEvents
        case sdkUnknown(Swift.String)

        public static var allCases: [DetectorFeature] {
            return [
                .ebsMalwareProtection,
                .eksAuditLogs,
                .eksRuntimeMonitoring,
                .lambdaNetworkLogs,
                .rdsLoginEvents,
                .s3DataEvents,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ebsMalwareProtection: return "EBS_MALWARE_PROTECTION"
            case .eksAuditLogs: return "EKS_AUDIT_LOGS"
            case .eksRuntimeMonitoring: return "EKS_RUNTIME_MONITORING"
            case .lambdaNetworkLogs: return "LAMBDA_NETWORK_LOGS"
            case .rdsLoginEvents: return "RDS_LOGIN_EVENTS"
            case .s3DataEvents: return "S3_DATA_EVENTS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DetectorFeature(rawValue: rawValue) ?? DetectorFeature.sdkUnknown(rawValue)
        }
    }
}

extension GuardDutyClientTypes.DetectorFeatureConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case additionalConfiguration = "additionalConfiguration"
        case name = "name"
        case status = "status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let additionalConfiguration = additionalConfiguration {
            var additionalConfigurationContainer = encodeContainer.nestedUnkeyedContainer(forKey: .additionalConfiguration)
            for detectoradditionalconfiguration0 in additionalConfiguration {
                try additionalConfigurationContainer.encode(detectoradditionalconfiguration0)
            }
        }
        if let name = self.name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.DetectorFeature.self, forKey: .name)
        name = nameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.FeatureStatus.self, forKey: .status)
        status = statusDecoded
        let additionalConfigurationContainer = try containerValues.decodeIfPresent([GuardDutyClientTypes.DetectorAdditionalConfiguration?].self, forKey: .additionalConfiguration)
        var additionalConfigurationDecoded0:[GuardDutyClientTypes.DetectorAdditionalConfiguration]? = nil
        if let additionalConfigurationContainer = additionalConfigurationContainer {
            additionalConfigurationDecoded0 = [GuardDutyClientTypes.DetectorAdditionalConfiguration]()
            for structure0 in additionalConfigurationContainer {
                if let structure0 = structure0 {
                    additionalConfigurationDecoded0?.append(structure0)
                }
            }
        }
        additionalConfiguration = additionalConfigurationDecoded0
    }
}

extension GuardDutyClientTypes {
    /// Contains information about a GuardDuty feature.
    public struct DetectorFeatureConfiguration: Swift.Equatable {
        /// Additional configuration for a resource.
        public var additionalConfiguration: [GuardDutyClientTypes.DetectorAdditionalConfiguration]?
        /// The name of the feature.
        public var name: GuardDutyClientTypes.DetectorFeature?
        /// The status of the feature.
        public var status: GuardDutyClientTypes.FeatureStatus?

        public init(
            additionalConfiguration: [GuardDutyClientTypes.DetectorAdditionalConfiguration]? = nil,
            name: GuardDutyClientTypes.DetectorFeature? = nil,
            status: GuardDutyClientTypes.FeatureStatus? = nil
        )
        {
            self.additionalConfiguration = additionalConfiguration
            self.name = name
            self.status = status
        }
    }

}

extension GuardDutyClientTypes.DetectorFeatureConfigurationResult: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case additionalConfiguration = "additionalConfiguration"
        case name = "name"
        case status = "status"
        case updatedAt = "updatedAt"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let additionalConfiguration = additionalConfiguration {
            var additionalConfigurationContainer = encodeContainer.nestedUnkeyedContainer(forKey: .additionalConfiguration)
            for detectoradditionalconfigurationresult0 in additionalConfiguration {
                try additionalConfigurationContainer.encode(detectoradditionalconfigurationresult0)
            }
        }
        if let name = self.name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let updatedAt = self.updatedAt {
            try encodeContainer.encodeTimestamp(updatedAt, format: .epochSeconds, forKey: .updatedAt)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.DetectorFeatureResult.self, forKey: .name)
        name = nameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.FeatureStatus.self, forKey: .status)
        status = statusDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let additionalConfigurationContainer = try containerValues.decodeIfPresent([GuardDutyClientTypes.DetectorAdditionalConfigurationResult?].self, forKey: .additionalConfiguration)
        var additionalConfigurationDecoded0:[GuardDutyClientTypes.DetectorAdditionalConfigurationResult]? = nil
        if let additionalConfigurationContainer = additionalConfigurationContainer {
            additionalConfigurationDecoded0 = [GuardDutyClientTypes.DetectorAdditionalConfigurationResult]()
            for structure0 in additionalConfigurationContainer {
                if let structure0 = structure0 {
                    additionalConfigurationDecoded0?.append(structure0)
                }
            }
        }
        additionalConfiguration = additionalConfigurationDecoded0
    }
}

extension GuardDutyClientTypes {
    /// Contains information about a GuardDuty feature.
    public struct DetectorFeatureConfigurationResult: Swift.Equatable {
        /// Additional configuration for a resource.
        public var additionalConfiguration: [GuardDutyClientTypes.DetectorAdditionalConfigurationResult]?
        /// Indicates the name of the feature that can be enabled for the detector.
        public var name: GuardDutyClientTypes.DetectorFeatureResult?
        /// Indicates the status of the feature that is enabled for the detector.
        public var status: GuardDutyClientTypes.FeatureStatus?
        /// The timestamp at which the feature object was updated.
        public var updatedAt: ClientRuntime.Date?

        public init(
            additionalConfiguration: [GuardDutyClientTypes.DetectorAdditionalConfigurationResult]? = nil,
            name: GuardDutyClientTypes.DetectorFeatureResult? = nil,
            status: GuardDutyClientTypes.FeatureStatus? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.additionalConfiguration = additionalConfiguration
            self.name = name
            self.status = status
            self.updatedAt = updatedAt
        }
    }

}

extension GuardDutyClientTypes {
    public enum DetectorFeatureResult: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cloudTrail
        case dnsLogs
        case ebsMalwareProtection
        case eksAuditLogs
        case eksRuntimeMonitoring
        case flowLogs
        case lambdaNetworkLogs
        case rdsLoginEvents
        case s3DataEvents
        case sdkUnknown(Swift.String)

        public static var allCases: [DetectorFeatureResult] {
            return [
                .cloudTrail,
                .dnsLogs,
                .ebsMalwareProtection,
                .eksAuditLogs,
                .eksRuntimeMonitoring,
                .flowLogs,
                .lambdaNetworkLogs,
                .rdsLoginEvents,
                .s3DataEvents,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cloudTrail: return "CLOUD_TRAIL"
            case .dnsLogs: return "DNS_LOGS"
            case .ebsMalwareProtection: return "EBS_MALWARE_PROTECTION"
            case .eksAuditLogs: return "EKS_AUDIT_LOGS"
            case .eksRuntimeMonitoring: return "EKS_RUNTIME_MONITORING"
            case .flowLogs: return "FLOW_LOGS"
            case .lambdaNetworkLogs: return "LAMBDA_NETWORK_LOGS"
            case .rdsLoginEvents: return "RDS_LOGIN_EVENTS"
            case .s3DataEvents: return "S3_DATA_EVENTS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DetectorFeatureResult(rawValue: rawValue) ?? DetectorFeatureResult.sdkUnknown(rawValue)
        }
    }
}

extension GuardDutyClientTypes {
    public enum DetectorStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [DetectorStatus] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DetectorStatus(rawValue: rawValue) ?? DetectorStatus.sdkUnknown(rawValue)
        }
    }
}

extension DisableOrganizationAdminAccountInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case adminAccountId = "adminAccountId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let adminAccountId = self.adminAccountId {
            try encodeContainer.encode(adminAccountId, forKey: .adminAccountId)
        }
    }
}

extension DisableOrganizationAdminAccountInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/admin/disable"
    }
}

public struct DisableOrganizationAdminAccountInput: Swift.Equatable {
    /// The Amazon Web Services Account ID for the organizations account to be disabled as a GuardDuty delegated administrator.
    /// This member is required.
    public var adminAccountId: Swift.String?

    public init(
        adminAccountId: Swift.String? = nil
    )
    {
        self.adminAccountId = adminAccountId
    }
}

struct DisableOrganizationAdminAccountInputBody: Swift.Equatable {
    let adminAccountId: Swift.String?
}

extension DisableOrganizationAdminAccountInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case adminAccountId = "adminAccountId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let adminAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .adminAccountId)
        adminAccountId = adminAccountIdDecoded
    }
}

extension DisableOrganizationAdminAccountOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DisableOrganizationAdminAccountOutput: Swift.Equatable {

    public init() { }
}

enum DisableOrganizationAdminAccountOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DisassociateFromAdministratorAccountInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let detectorId = detectorId else {
            return nil
        }
        return "/detector/\(detectorId.urlPercentEncoding())/administrator/disassociate"
    }
}

public struct DisassociateFromAdministratorAccountInput: Swift.Equatable {
    /// The unique ID of the detector of the GuardDuty member account.
    /// This member is required.
    public var detectorId: Swift.String?

    public init(
        detectorId: Swift.String? = nil
    )
    {
        self.detectorId = detectorId
    }
}

struct DisassociateFromAdministratorAccountInputBody: Swift.Equatable {
}

extension DisassociateFromAdministratorAccountInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DisassociateFromAdministratorAccountOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DisassociateFromAdministratorAccountOutput: Swift.Equatable {

    public init() { }
}

enum DisassociateFromAdministratorAccountOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DisassociateFromMasterAccountInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let detectorId = detectorId else {
            return nil
        }
        return "/detector/\(detectorId.urlPercentEncoding())/master/disassociate"
    }
}

@available(*, deprecated, message: "This input is deprecated, use DisassociateFromAdministratorAccountRequest instead")
public struct DisassociateFromMasterAccountInput: Swift.Equatable {
    /// The unique ID of the detector of the GuardDuty member account.
    /// This member is required.
    public var detectorId: Swift.String?

    public init(
        detectorId: Swift.String? = nil
    )
    {
        self.detectorId = detectorId
    }
}

struct DisassociateFromMasterAccountInputBody: Swift.Equatable {
}

extension DisassociateFromMasterAccountInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DisassociateFromMasterAccountOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

@available(*, deprecated, message: "This output is deprecated, use DisassociateFromAdministratorAccountResponse instead")
public struct DisassociateFromMasterAccountOutput: Swift.Equatable {

    public init() { }
}

enum DisassociateFromMasterAccountOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DisassociateMembersInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountIds = "accountIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountIds = accountIds {
            var accountIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accountIds)
            for accountid0 in accountIds {
                try accountIdsContainer.encode(accountid0)
            }
        }
    }
}

extension DisassociateMembersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let detectorId = detectorId else {
            return nil
        }
        return "/detector/\(detectorId.urlPercentEncoding())/member/disassociate"
    }
}

public struct DisassociateMembersInput: Swift.Equatable {
    /// A list of account IDs of the GuardDuty member accounts that you want to disassociate from the administrator account.
    /// This member is required.
    public var accountIds: [Swift.String]?
    /// The unique ID of the detector of the GuardDuty account whose members you want to disassociate from the administrator account.
    /// This member is required.
    public var detectorId: Swift.String?

    public init(
        accountIds: [Swift.String]? = nil,
        detectorId: Swift.String? = nil
    )
    {
        self.accountIds = accountIds
        self.detectorId = detectorId
    }
}

struct DisassociateMembersInputBody: Swift.Equatable {
    let accountIds: [Swift.String]?
}

extension DisassociateMembersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountIds = "accountIds"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .accountIds)
        var accountIdsDecoded0:[Swift.String]? = nil
        if let accountIdsContainer = accountIdsContainer {
            accountIdsDecoded0 = [Swift.String]()
            for string0 in accountIdsContainer {
                if let string0 = string0 {
                    accountIdsDecoded0?.append(string0)
                }
            }
        }
        accountIds = accountIdsDecoded0
    }
}

extension DisassociateMembersOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DisassociateMembersOutputBody = try responseDecoder.decode(responseBody: data)
            self.unprocessedAccounts = output.unprocessedAccounts
        } else {
            self.unprocessedAccounts = nil
        }
    }
}

public struct DisassociateMembersOutput: Swift.Equatable {
    /// A list of objects that contain the unprocessed account and a result string that explains why it was unprocessed.
    /// This member is required.
    public var unprocessedAccounts: [GuardDutyClientTypes.UnprocessedAccount]?

    public init(
        unprocessedAccounts: [GuardDutyClientTypes.UnprocessedAccount]? = nil
    )
    {
        self.unprocessedAccounts = unprocessedAccounts
    }
}

struct DisassociateMembersOutputBody: Swift.Equatable {
    let unprocessedAccounts: [GuardDutyClientTypes.UnprocessedAccount]?
}

extension DisassociateMembersOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case unprocessedAccounts = "unprocessedAccounts"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let unprocessedAccountsContainer = try containerValues.decodeIfPresent([GuardDutyClientTypes.UnprocessedAccount?].self, forKey: .unprocessedAccounts)
        var unprocessedAccountsDecoded0:[GuardDutyClientTypes.UnprocessedAccount]? = nil
        if let unprocessedAccountsContainer = unprocessedAccountsContainer {
            unprocessedAccountsDecoded0 = [GuardDutyClientTypes.UnprocessedAccount]()
            for structure0 in unprocessedAccountsContainer {
                if let structure0 = structure0 {
                    unprocessedAccountsDecoded0?.append(structure0)
                }
            }
        }
        unprocessedAccounts = unprocessedAccountsDecoded0
    }
}

enum DisassociateMembersOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GuardDutyClientTypes.DnsRequestAction: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case blocked = "blocked"
        case domain = "domain"
        case `protocol` = "protocol"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if blocked != false {
            try encodeContainer.encode(blocked, forKey: .blocked)
        }
        if let domain = self.domain {
            try encodeContainer.encode(domain, forKey: .domain)
        }
        if let `protocol` = self.`protocol` {
            try encodeContainer.encode(`protocol`, forKey: .`protocol`)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domain)
        domain = domainDecoded
        let protocolDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .protocol)
        `protocol` = protocolDecoded
        let blockedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .blocked) ?? false
        blocked = blockedDecoded
    }
}

extension GuardDutyClientTypes {
    /// Contains information about the DNS_REQUEST action described in this finding.
    public struct DnsRequestAction: Swift.Equatable {
        /// Indicates whether the targeted port is blocked.
        public var blocked: Swift.Bool
        /// The domain information for the DNS query.
        public var domain: Swift.String?
        /// The network connection protocol observed in the activity that prompted GuardDuty to generate the finding.
        public var `protocol`: Swift.String?

        public init(
            blocked: Swift.Bool = false,
            domain: Swift.String? = nil,
            `protocol`: Swift.String? = nil
        )
        {
            self.blocked = blocked
            self.domain = domain
            self.`protocol` = `protocol`
        }
    }

}

extension GuardDutyClientTypes.DomainDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domain = "domain"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domain = self.domain {
            try encodeContainer.encode(domain, forKey: .domain)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domain)
        domain = domainDecoded
    }
}

extension GuardDutyClientTypes {
    /// Contains information about the domain.
    public struct DomainDetails: Swift.Equatable {
        /// The domain information for the Amazon Web Services API call.
        public var domain: Swift.String?

        public init(
            domain: Swift.String? = nil
        )
        {
            self.domain = domain
        }
    }

}

extension GuardDutyClientTypes {
    public enum EbsSnapshotPreservation: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case noRetention
        case retentionWithFinding
        case sdkUnknown(Swift.String)

        public static var allCases: [EbsSnapshotPreservation] {
            return [
                .noRetention,
                .retentionWithFinding,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .noRetention: return "NO_RETENTION"
            case .retentionWithFinding: return "RETENTION_WITH_FINDING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EbsSnapshotPreservation(rawValue: rawValue) ?? EbsSnapshotPreservation.sdkUnknown(rawValue)
        }
    }
}

extension GuardDutyClientTypes.EbsVolumeDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case scannedVolumeDetails = "scannedVolumeDetails"
        case skippedVolumeDetails = "skippedVolumeDetails"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let scannedVolumeDetails = scannedVolumeDetails {
            var scannedVolumeDetailsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .scannedVolumeDetails)
            for volumedetail0 in scannedVolumeDetails {
                try scannedVolumeDetailsContainer.encode(volumedetail0)
            }
        }
        if let skippedVolumeDetails = skippedVolumeDetails {
            var skippedVolumeDetailsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .skippedVolumeDetails)
            for volumedetail0 in skippedVolumeDetails {
                try skippedVolumeDetailsContainer.encode(volumedetail0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scannedVolumeDetailsContainer = try containerValues.decodeIfPresent([GuardDutyClientTypes.VolumeDetail?].self, forKey: .scannedVolumeDetails)
        var scannedVolumeDetailsDecoded0:[GuardDutyClientTypes.VolumeDetail]? = nil
        if let scannedVolumeDetailsContainer = scannedVolumeDetailsContainer {
            scannedVolumeDetailsDecoded0 = [GuardDutyClientTypes.VolumeDetail]()
            for structure0 in scannedVolumeDetailsContainer {
                if let structure0 = structure0 {
                    scannedVolumeDetailsDecoded0?.append(structure0)
                }
            }
        }
        scannedVolumeDetails = scannedVolumeDetailsDecoded0
        let skippedVolumeDetailsContainer = try containerValues.decodeIfPresent([GuardDutyClientTypes.VolumeDetail?].self, forKey: .skippedVolumeDetails)
        var skippedVolumeDetailsDecoded0:[GuardDutyClientTypes.VolumeDetail]? = nil
        if let skippedVolumeDetailsContainer = skippedVolumeDetailsContainer {
            skippedVolumeDetailsDecoded0 = [GuardDutyClientTypes.VolumeDetail]()
            for structure0 in skippedVolumeDetailsContainer {
                if let structure0 = structure0 {
                    skippedVolumeDetailsDecoded0?.append(structure0)
                }
            }
        }
        skippedVolumeDetails = skippedVolumeDetailsDecoded0
    }
}

extension GuardDutyClientTypes {
    /// Contains list of scanned and skipped EBS volumes with details.
    public struct EbsVolumeDetails: Swift.Equatable {
        /// List of EBS volumes that were scanned.
        public var scannedVolumeDetails: [GuardDutyClientTypes.VolumeDetail]?
        /// List of EBS volumes that were skipped from the malware scan.
        public var skippedVolumeDetails: [GuardDutyClientTypes.VolumeDetail]?

        public init(
            scannedVolumeDetails: [GuardDutyClientTypes.VolumeDetail]? = nil,
            skippedVolumeDetails: [GuardDutyClientTypes.VolumeDetail]? = nil
        )
        {
            self.scannedVolumeDetails = scannedVolumeDetails
            self.skippedVolumeDetails = skippedVolumeDetails
        }
    }

}

extension GuardDutyClientTypes.EbsVolumeScanDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case scanCompletedAt = "scanCompletedAt"
        case scanDetections = "scanDetections"
        case scanId = "scanId"
        case scanStartedAt = "scanStartedAt"
        case scanType = "scanType"
        case sources = "sources"
        case triggerFindingId = "triggerFindingId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let scanCompletedAt = self.scanCompletedAt {
            try encodeContainer.encodeTimestamp(scanCompletedAt, format: .epochSeconds, forKey: .scanCompletedAt)
        }
        if let scanDetections = self.scanDetections {
            try encodeContainer.encode(scanDetections, forKey: .scanDetections)
        }
        if let scanId = self.scanId {
            try encodeContainer.encode(scanId, forKey: .scanId)
        }
        if let scanStartedAt = self.scanStartedAt {
            try encodeContainer.encodeTimestamp(scanStartedAt, format: .epochSeconds, forKey: .scanStartedAt)
        }
        if let scanType = self.scanType {
            try encodeContainer.encode(scanType.rawValue, forKey: .scanType)
        }
        if let sources = sources {
            var sourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sources)
            for string0 in sources {
                try sourcesContainer.encode(string0)
            }
        }
        if let triggerFindingId = self.triggerFindingId {
            try encodeContainer.encode(triggerFindingId, forKey: .triggerFindingId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scanIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .scanId)
        scanId = scanIdDecoded
        let scanStartedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .scanStartedAt)
        scanStartedAt = scanStartedAtDecoded
        let scanCompletedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .scanCompletedAt)
        scanCompletedAt = scanCompletedAtDecoded
        let triggerFindingIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .triggerFindingId)
        triggerFindingId = triggerFindingIdDecoded
        let sourcesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .sources)
        var sourcesDecoded0:[Swift.String]? = nil
        if let sourcesContainer = sourcesContainer {
            sourcesDecoded0 = [Swift.String]()
            for string0 in sourcesContainer {
                if let string0 = string0 {
                    sourcesDecoded0?.append(string0)
                }
            }
        }
        sources = sourcesDecoded0
        let scanDetectionsDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.ScanDetections.self, forKey: .scanDetections)
        scanDetections = scanDetectionsDecoded
        let scanTypeDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.ScanType.self, forKey: .scanType)
        scanType = scanTypeDecoded
    }
}

extension GuardDutyClientTypes {
    /// Contains details from the malware scan that created a finding.
    public struct EbsVolumeScanDetails: Swift.Equatable {
        /// Returns the completion date and time of the malware scan.
        public var scanCompletedAt: ClientRuntime.Date?
        /// Contains a complete view providing malware scan result details.
        public var scanDetections: GuardDutyClientTypes.ScanDetections?
        /// Unique Id of the malware scan that generated the finding.
        public var scanId: Swift.String?
        /// Returns the start date and time of the malware scan.
        public var scanStartedAt: ClientRuntime.Date?
        /// Specifies the scan type that invoked the malware scan.
        public var scanType: GuardDutyClientTypes.ScanType?
        /// Contains list of threat intelligence sources used to detect threats.
        public var sources: [Swift.String]?
        /// GuardDuty finding ID that triggered a malware scan.
        public var triggerFindingId: Swift.String?

        public init(
            scanCompletedAt: ClientRuntime.Date? = nil,
            scanDetections: GuardDutyClientTypes.ScanDetections? = nil,
            scanId: Swift.String? = nil,
            scanStartedAt: ClientRuntime.Date? = nil,
            scanType: GuardDutyClientTypes.ScanType? = nil,
            sources: [Swift.String]? = nil,
            triggerFindingId: Swift.String? = nil
        )
        {
            self.scanCompletedAt = scanCompletedAt
            self.scanDetections = scanDetections
            self.scanId = scanId
            self.scanStartedAt = scanStartedAt
            self.scanType = scanType
            self.sources = sources
            self.triggerFindingId = triggerFindingId
        }
    }

}

extension GuardDutyClientTypes.EbsVolumesResult: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case reason = "reason"
        case status = "status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let reason = self.reason {
            try encodeContainer.encode(reason, forKey: .reason)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.DataSourceStatus.self, forKey: .status)
        status = statusDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reason)
        reason = reasonDecoded
    }
}

extension GuardDutyClientTypes {
    /// Describes the configuration of scanning EBS volumes as a data source.
    public struct EbsVolumesResult: Swift.Equatable {
        /// Specifies the reason why scanning EBS volumes (Malware Protection) was not enabled as a data source.
        public var reason: Swift.String?
        /// Describes whether scanning EBS volumes is enabled as a data source.
        public var status: GuardDutyClientTypes.DataSourceStatus?

        public init(
            reason: Swift.String? = nil,
            status: GuardDutyClientTypes.DataSourceStatus? = nil
        )
        {
            self.reason = reason
            self.status = status
        }
    }

}

extension GuardDutyClientTypes.EcsClusterDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case activeServicesCount = "activeServicesCount"
        case arn = "arn"
        case name = "name"
        case registeredContainerInstancesCount = "registeredContainerInstancesCount"
        case runningTasksCount = "runningTasksCount"
        case status = "status"
        case tags = "tags"
        case taskDetails = "taskDetails"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if activeServicesCount != 0 {
            try encodeContainer.encode(activeServicesCount, forKey: .activeServicesCount)
        }
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if registeredContainerInstancesCount != 0 {
            try encodeContainer.encode(registeredContainerInstancesCount, forKey: .registeredContainerInstancesCount)
        }
        if runningTasksCount != 0 {
            try encodeContainer.encode(runningTasksCount, forKey: .runningTasksCount)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let taskDetails = self.taskDetails {
            try encodeContainer.encode(taskDetails, forKey: .taskDetails)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let activeServicesCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .activeServicesCount) ?? 0
        activeServicesCount = activeServicesCountDecoded
        let registeredContainerInstancesCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .registeredContainerInstancesCount) ?? 0
        registeredContainerInstancesCount = registeredContainerInstancesCountDecoded
        let runningTasksCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .runningTasksCount) ?? 0
        runningTasksCount = runningTasksCountDecoded
        let tagsContainer = try containerValues.decodeIfPresent([GuardDutyClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[GuardDutyClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [GuardDutyClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let taskDetailsDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.EcsTaskDetails.self, forKey: .taskDetails)
        taskDetails = taskDetailsDecoded
    }
}

extension GuardDutyClientTypes {
    /// Contains information about the details of the ECS Cluster.
    public struct EcsClusterDetails: Swift.Equatable {
        /// The number of services that are running on the cluster in an ACTIVE state.
        public var activeServicesCount: Swift.Int
        /// The Amazon Resource Name (ARN) that identifies the cluster.
        public var arn: Swift.String?
        /// The name of the ECS Cluster.
        public var name: Swift.String?
        /// The number of container instances registered into the cluster.
        public var registeredContainerInstancesCount: Swift.Int
        /// The number of tasks in the cluster that are in the RUNNING state.
        public var runningTasksCount: Swift.Int
        /// The status of the ECS cluster.
        public var status: Swift.String?
        /// The tags of the ECS Cluster.
        public var tags: [GuardDutyClientTypes.Tag]?
        /// Contains information about the details of the ECS Task.
        public var taskDetails: GuardDutyClientTypes.EcsTaskDetails?

        public init(
            activeServicesCount: Swift.Int = 0,
            arn: Swift.String? = nil,
            name: Swift.String? = nil,
            registeredContainerInstancesCount: Swift.Int = 0,
            runningTasksCount: Swift.Int = 0,
            status: Swift.String? = nil,
            tags: [GuardDutyClientTypes.Tag]? = nil,
            taskDetails: GuardDutyClientTypes.EcsTaskDetails? = nil
        )
        {
            self.activeServicesCount = activeServicesCount
            self.arn = arn
            self.name = name
            self.registeredContainerInstancesCount = registeredContainerInstancesCount
            self.runningTasksCount = runningTasksCount
            self.status = status
            self.tags = tags
            self.taskDetails = taskDetails
        }
    }

}

extension GuardDutyClientTypes.EcsTaskDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "arn"
        case containers = "containers"
        case definitionArn = "definitionArn"
        case group = "group"
        case startedAt = "startedAt"
        case startedBy = "startedBy"
        case tags = "tags"
        case taskCreatedAt = "createdAt"
        case version = "version"
        case volumes = "volumes"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let containers = containers {
            var containersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .containers)
            for container0 in containers {
                try containersContainer.encode(container0)
            }
        }
        if let definitionArn = self.definitionArn {
            try encodeContainer.encode(definitionArn, forKey: .definitionArn)
        }
        if let group = self.group {
            try encodeContainer.encode(group, forKey: .group)
        }
        if let startedAt = self.startedAt {
            try encodeContainer.encodeTimestamp(startedAt, format: .epochSeconds, forKey: .startedAt)
        }
        if let startedBy = self.startedBy {
            try encodeContainer.encode(startedBy, forKey: .startedBy)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let taskCreatedAt = self.taskCreatedAt {
            try encodeContainer.encodeTimestamp(taskCreatedAt, format: .epochSeconds, forKey: .taskCreatedAt)
        }
        if let version = self.version {
            try encodeContainer.encode(version, forKey: .version)
        }
        if let volumes = volumes {
            var volumesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .volumes)
            for volume0 in volumes {
                try volumesContainer.encode(volume0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let definitionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .definitionArn)
        definitionArn = definitionArnDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let taskCreatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .taskCreatedAt)
        taskCreatedAt = taskCreatedAtDecoded
        let startedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startedAt)
        startedAt = startedAtDecoded
        let startedByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .startedBy)
        startedBy = startedByDecoded
        let tagsContainer = try containerValues.decodeIfPresent([GuardDutyClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[GuardDutyClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [GuardDutyClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let volumesContainer = try containerValues.decodeIfPresent([GuardDutyClientTypes.Volume?].self, forKey: .volumes)
        var volumesDecoded0:[GuardDutyClientTypes.Volume]? = nil
        if let volumesContainer = volumesContainer {
            volumesDecoded0 = [GuardDutyClientTypes.Volume]()
            for structure0 in volumesContainer {
                if let structure0 = structure0 {
                    volumesDecoded0?.append(structure0)
                }
            }
        }
        volumes = volumesDecoded0
        let containersContainer = try containerValues.decodeIfPresent([GuardDutyClientTypes.Container?].self, forKey: .containers)
        var containersDecoded0:[GuardDutyClientTypes.Container]? = nil
        if let containersContainer = containersContainer {
            containersDecoded0 = [GuardDutyClientTypes.Container]()
            for structure0 in containersContainer {
                if let structure0 = structure0 {
                    containersDecoded0?.append(structure0)
                }
            }
        }
        containers = containersDecoded0
        let groupDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .group)
        group = groupDecoded
    }
}

extension GuardDutyClientTypes {
    /// Contains information about the task in an ECS cluster.
    public struct EcsTaskDetails: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the task.
        public var arn: Swift.String?
        /// The containers that's associated with the task.
        public var containers: [GuardDutyClientTypes.Container]?
        /// The ARN of the task definition that creates the task.
        public var definitionArn: Swift.String?
        /// The name of the task group that's associated with the task.
        public var group: Swift.String?
        /// The Unix timestamp for the time when the task started.
        public var startedAt: ClientRuntime.Date?
        /// Contains the tag specified when a task is started.
        public var startedBy: Swift.String?
        /// The tags of the ECS Task.
        public var tags: [GuardDutyClientTypes.Tag]?
        /// The Unix timestamp for the time when the task was created.
        public var taskCreatedAt: ClientRuntime.Date?
        /// The version counter for the task.
        public var version: Swift.String?
        /// The list of data volume definitions for the task.
        public var volumes: [GuardDutyClientTypes.Volume]?

        public init(
            arn: Swift.String? = nil,
            containers: [GuardDutyClientTypes.Container]? = nil,
            definitionArn: Swift.String? = nil,
            group: Swift.String? = nil,
            startedAt: ClientRuntime.Date? = nil,
            startedBy: Swift.String? = nil,
            tags: [GuardDutyClientTypes.Tag]? = nil,
            taskCreatedAt: ClientRuntime.Date? = nil,
            version: Swift.String? = nil,
            volumes: [GuardDutyClientTypes.Volume]? = nil
        )
        {
            self.arn = arn
            self.containers = containers
            self.definitionArn = definitionArn
            self.group = group
            self.startedAt = startedAt
            self.startedBy = startedBy
            self.tags = tags
            self.taskCreatedAt = taskCreatedAt
            self.version = version
            self.volumes = volumes
        }
    }

}

extension GuardDutyClientTypes.EksClusterDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "arn"
        case createdAt = "createdAt"
        case name = "name"
        case status = "status"
        case tags = "tags"
        case vpcId = "vpcId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let vpcId = self.vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let tagsContainer = try containerValues.decodeIfPresent([GuardDutyClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[GuardDutyClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [GuardDutyClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
    }
}

extension GuardDutyClientTypes {
    /// Details about the EKS cluster involved in a Kubernetes finding.
    public struct EksClusterDetails: Swift.Equatable {
        /// EKS cluster ARN.
        public var arn: Swift.String?
        /// The timestamp when the EKS cluster was created.
        public var createdAt: ClientRuntime.Date?
        /// EKS cluster name.
        public var name: Swift.String?
        /// The EKS cluster status.
        public var status: Swift.String?
        /// The EKS cluster tags.
        public var tags: [GuardDutyClientTypes.Tag]?
        /// The VPC ID to which the EKS cluster is attached.
        public var vpcId: Swift.String?

        public init(
            arn: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            status: Swift.String? = nil,
            tags: [GuardDutyClientTypes.Tag]? = nil,
            vpcId: Swift.String? = nil
        )
        {
            self.arn = arn
            self.createdAt = createdAt
            self.name = name
            self.status = status
            self.tags = tags
            self.vpcId = vpcId
        }
    }

}

extension EnableOrganizationAdminAccountInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case adminAccountId = "adminAccountId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let adminAccountId = self.adminAccountId {
            try encodeContainer.encode(adminAccountId, forKey: .adminAccountId)
        }
    }
}

extension EnableOrganizationAdminAccountInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/admin/enable"
    }
}

public struct EnableOrganizationAdminAccountInput: Swift.Equatable {
    /// The Amazon Web Services account ID for the organization account to be enabled as a GuardDuty delegated administrator.
    /// This member is required.
    public var adminAccountId: Swift.String?

    public init(
        adminAccountId: Swift.String? = nil
    )
    {
        self.adminAccountId = adminAccountId
    }
}

struct EnableOrganizationAdminAccountInputBody: Swift.Equatable {
    let adminAccountId: Swift.String?
}

extension EnableOrganizationAdminAccountInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case adminAccountId = "adminAccountId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let adminAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .adminAccountId)
        adminAccountId = adminAccountIdDecoded
    }
}

extension EnableOrganizationAdminAccountOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct EnableOrganizationAdminAccountOutput: Swift.Equatable {

    public init() { }
}

enum EnableOrganizationAdminAccountOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GuardDutyClientTypes.Evidence: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case threatIntelligenceDetails = "threatIntelligenceDetails"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let threatIntelligenceDetails = threatIntelligenceDetails {
            var threatIntelligenceDetailsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .threatIntelligenceDetails)
            for threatintelligencedetail0 in threatIntelligenceDetails {
                try threatIntelligenceDetailsContainer.encode(threatintelligencedetail0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let threatIntelligenceDetailsContainer = try containerValues.decodeIfPresent([GuardDutyClientTypes.ThreatIntelligenceDetail?].self, forKey: .threatIntelligenceDetails)
        var threatIntelligenceDetailsDecoded0:[GuardDutyClientTypes.ThreatIntelligenceDetail]? = nil
        if let threatIntelligenceDetailsContainer = threatIntelligenceDetailsContainer {
            threatIntelligenceDetailsDecoded0 = [GuardDutyClientTypes.ThreatIntelligenceDetail]()
            for structure0 in threatIntelligenceDetailsContainer {
                if let structure0 = structure0 {
                    threatIntelligenceDetailsDecoded0?.append(structure0)
                }
            }
        }
        threatIntelligenceDetails = threatIntelligenceDetailsDecoded0
    }
}

extension GuardDutyClientTypes {
    /// Contains information about the reason that the finding was generated.
    public struct Evidence: Swift.Equatable {
        /// A list of threat intelligence details related to the evidence.
        public var threatIntelligenceDetails: [GuardDutyClientTypes.ThreatIntelligenceDetail]?

        public init(
            threatIntelligenceDetails: [GuardDutyClientTypes.ThreatIntelligenceDetail]? = nil
        )
        {
            self.threatIntelligenceDetails = threatIntelligenceDetails
        }
    }

}

extension GuardDutyClientTypes {
    public enum FeatureAdditionalConfiguration: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case eksAddonManagement
        case sdkUnknown(Swift.String)

        public static var allCases: [FeatureAdditionalConfiguration] {
            return [
                .eksAddonManagement,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .eksAddonManagement: return "EKS_ADDON_MANAGEMENT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FeatureAdditionalConfiguration(rawValue: rawValue) ?? FeatureAdditionalConfiguration.sdkUnknown(rawValue)
        }
    }
}

extension GuardDutyClientTypes {
    public enum FeatureStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [FeatureStatus] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FeatureStatus(rawValue: rawValue) ?? FeatureStatus.sdkUnknown(rawValue)
        }
    }
}

extension GuardDutyClientTypes {
    public enum Feedback: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case notUseful
        case useful
        case sdkUnknown(Swift.String)

        public static var allCases: [Feedback] {
            return [
                .notUseful,
                .useful,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .notUseful: return "NOT_USEFUL"
            case .useful: return "USEFUL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Feedback(rawValue: rawValue) ?? Feedback.sdkUnknown(rawValue)
        }
    }
}

extension GuardDutyClientTypes {
    public enum FilterAction: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case archive
        case noop
        case sdkUnknown(Swift.String)

        public static var allCases: [FilterAction] {
            return [
                .archive,
                .noop,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .archive: return "ARCHIVE"
            case .noop: return "NOOP"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FilterAction(rawValue: rawValue) ?? FilterAction.sdkUnknown(rawValue)
        }
    }
}

extension GuardDutyClientTypes.FilterCondition: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case equalsValue = "equalsValue"
        case greaterThan = "greaterThan"
        case lessThan = "lessThan"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let equalsValue = self.equalsValue {
            try encodeContainer.encode(equalsValue, forKey: .equalsValue)
        }
        if greaterThan != 0 {
            try encodeContainer.encode(greaterThan, forKey: .greaterThan)
        }
        if lessThan != 0 {
            try encodeContainer.encode(lessThan, forKey: .lessThan)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let equalsValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .equalsValue)
        equalsValue = equalsValueDecoded
        let greaterThanDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .greaterThan) ?? 0
        greaterThan = greaterThanDecoded
        let lessThanDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .lessThan) ?? 0
        lessThan = lessThanDecoded
    }
}

extension GuardDutyClientTypes {
    /// Contains information about the condition.
    public struct FilterCondition: Swift.Equatable {
        /// Represents an equal condition to be applied to a single field when querying for scan entries.
        public var equalsValue: Swift.String?
        /// Represents a greater than condition to be applied to a single field when querying for scan entries.
        public var greaterThan: Swift.Int
        /// Represents a less than condition to be applied to a single field when querying for scan entries.
        public var lessThan: Swift.Int

        public init(
            equalsValue: Swift.String? = nil,
            greaterThan: Swift.Int = 0,
            lessThan: Swift.Int = 0
        )
        {
            self.equalsValue = equalsValue
            self.greaterThan = greaterThan
            self.lessThan = lessThan
        }
    }

}

extension GuardDutyClientTypes.FilterCriteria: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filterCriterion = "filterCriterion"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filterCriterion = filterCriterion {
            var filterCriterionContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filterCriterion)
            for filtercriterion0 in filterCriterion {
                try filterCriterionContainer.encode(filtercriterion0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filterCriterionContainer = try containerValues.decodeIfPresent([GuardDutyClientTypes.FilterCriterion?].self, forKey: .filterCriterion)
        var filterCriterionDecoded0:[GuardDutyClientTypes.FilterCriterion]? = nil
        if let filterCriterionContainer = filterCriterionContainer {
            filterCriterionDecoded0 = [GuardDutyClientTypes.FilterCriterion]()
            for structure0 in filterCriterionContainer {
                if let structure0 = structure0 {
                    filterCriterionDecoded0?.append(structure0)
                }
            }
        }
        filterCriterion = filterCriterionDecoded0
    }
}

extension GuardDutyClientTypes {
    /// Represents the criteria to be used in the filter for describing scan entries.
    public struct FilterCriteria: Swift.Equatable {
        /// Represents a condition that when matched will be added to the response of the operation.
        public var filterCriterion: [GuardDutyClientTypes.FilterCriterion]?

        public init(
            filterCriterion: [GuardDutyClientTypes.FilterCriterion]? = nil
        )
        {
            self.filterCriterion = filterCriterion
        }
    }

}

extension GuardDutyClientTypes.FilterCriterion: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case criterionKey = "criterionKey"
        case filterCondition = "filterCondition"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let criterionKey = self.criterionKey {
            try encodeContainer.encode(criterionKey.rawValue, forKey: .criterionKey)
        }
        if let filterCondition = self.filterCondition {
            try encodeContainer.encode(filterCondition, forKey: .filterCondition)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let criterionKeyDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.CriterionKey.self, forKey: .criterionKey)
        criterionKey = criterionKeyDecoded
        let filterConditionDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.FilterCondition.self, forKey: .filterCondition)
        filterCondition = filterConditionDecoded
    }
}

extension GuardDutyClientTypes {
    /// Represents a condition that when matched will be added to the response of the operation. Irrespective of using any filter criteria, an administrator account can view the scan entries for all of its member accounts. However, each member account can view the scan entries only for their own account.
    public struct FilterCriterion: Swift.Equatable {
        /// An enum value representing possible scan properties to match with given scan entries. Replace the enum value CLUSTER_NAME with EKS_CLUSTER_NAME. CLUSTER_NAME has been deprecated.
        public var criterionKey: GuardDutyClientTypes.CriterionKey?
        /// Contains information about the condition.
        public var filterCondition: GuardDutyClientTypes.FilterCondition?

        public init(
            criterionKey: GuardDutyClientTypes.CriterionKey? = nil,
            filterCondition: GuardDutyClientTypes.FilterCondition? = nil
        )
        {
            self.criterionKey = criterionKey
            self.filterCondition = filterCondition
        }
    }

}

extension GuardDutyClientTypes.Finding: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "accountId"
        case arn = "arn"
        case confidence = "confidence"
        case createdAt = "createdAt"
        case description = "description"
        case id = "id"
        case partition = "partition"
        case region = "region"
        case resource = "resource"
        case schemaVersion = "schemaVersion"
        case service = "service"
        case severity = "severity"
        case title = "title"
        case type = "type"
        case updatedAt = "updatedAt"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if confidence != 0.0 {
            try encodeContainer.encode(confidence, forKey: .confidence)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encode(createdAt, forKey: .createdAt)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let partition = self.partition {
            try encodeContainer.encode(partition, forKey: .partition)
        }
        if let region = self.region {
            try encodeContainer.encode(region, forKey: .region)
        }
        if let resource = self.resource {
            try encodeContainer.encode(resource, forKey: .resource)
        }
        if let schemaVersion = self.schemaVersion {
            try encodeContainer.encode(schemaVersion, forKey: .schemaVersion)
        }
        if let service = self.service {
            try encodeContainer.encode(service, forKey: .service)
        }
        if severity != 0.0 {
            try encodeContainer.encode(severity, forKey: .severity)
        }
        if let title = self.title {
            try encodeContainer.encode(title, forKey: .title)
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
        if let updatedAt = self.updatedAt {
            try encodeContainer.encode(updatedAt, forKey: .updatedAt)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let confidenceDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .confidence) ?? 0.0
        confidence = confidenceDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let partitionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .partition)
        partition = partitionDecoded
        let regionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .region)
        region = regionDecoded
        let resourceDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.Resource.self, forKey: .resource)
        resource = resourceDecoded
        let schemaVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaVersion)
        schemaVersion = schemaVersionDecoded
        let serviceDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.Service.self, forKey: .service)
        service = serviceDecoded
        let severityDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .severity) ?? 0.0
        severity = severityDecoded
        let titleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .title)
        title = titleDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let updatedAtDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
    }
}

extension GuardDutyClientTypes {
    /// Contains information about the finding that is generated when abnormal or suspicious activity is detected.
    public struct Finding: Swift.Equatable {
        /// The ID of the account in which the finding was generated.
        /// This member is required.
        public var accountId: Swift.String?
        /// The ARN of the finding.
        /// This member is required.
        public var arn: Swift.String?
        /// The confidence score for the finding.
        public var confidence: Swift.Double
        /// The time and date when the finding was created.
        /// This member is required.
        public var createdAt: Swift.String?
        /// The description of the finding.
        public var description: Swift.String?
        /// The ID of the finding.
        /// This member is required.
        public var id: Swift.String?
        /// The partition associated with the finding.
        public var partition: Swift.String?
        /// The Region where the finding was generated.
        /// This member is required.
        public var region: Swift.String?
        /// Contains information about the Amazon Web Services resource associated with the activity that prompted GuardDuty to generate a finding.
        /// This member is required.
        public var resource: GuardDutyClientTypes.Resource?
        /// The version of the schema used for the finding.
        /// This member is required.
        public var schemaVersion: Swift.String?
        /// Contains additional information about the generated finding.
        public var service: GuardDutyClientTypes.Service?
        /// The severity of the finding.
        /// This member is required.
        public var severity: Swift.Double
        /// The title of the finding.
        public var title: Swift.String?
        /// The type of finding.
        /// This member is required.
        public var type: Swift.String?
        /// The time and date when the finding was last updated.
        /// This member is required.
        public var updatedAt: Swift.String?

        public init(
            accountId: Swift.String? = nil,
            arn: Swift.String? = nil,
            confidence: Swift.Double = 0.0,
            createdAt: Swift.String? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            partition: Swift.String? = nil,
            region: Swift.String? = nil,
            resource: GuardDutyClientTypes.Resource? = nil,
            schemaVersion: Swift.String? = nil,
            service: GuardDutyClientTypes.Service? = nil,
            severity: Swift.Double = 0.0,
            title: Swift.String? = nil,
            type: Swift.String? = nil,
            updatedAt: Swift.String? = nil
        )
        {
            self.accountId = accountId
            self.arn = arn
            self.confidence = confidence
            self.createdAt = createdAt
            self.description = description
            self.id = id
            self.partition = partition
            self.region = region
            self.resource = resource
            self.schemaVersion = schemaVersion
            self.service = service
            self.severity = severity
            self.title = title
            self.type = type
            self.updatedAt = updatedAt
        }
    }

}

extension GuardDutyClientTypes.FindingCriteria: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case criterion = "criterion"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let criterion = criterion {
            var criterionContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .criterion)
            for (dictKey0, criterion0) in criterion {
                try criterionContainer.encode(criterion0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let criterionContainer = try containerValues.decodeIfPresent([Swift.String: GuardDutyClientTypes.Condition?].self, forKey: .criterion)
        var criterionDecoded0: [Swift.String:GuardDutyClientTypes.Condition]? = nil
        if let criterionContainer = criterionContainer {
            criterionDecoded0 = [Swift.String:GuardDutyClientTypes.Condition]()
            for (key0, condition0) in criterionContainer {
                if let condition0 = condition0 {
                    criterionDecoded0?[key0] = condition0
                }
            }
        }
        criterion = criterionDecoded0
    }
}

extension GuardDutyClientTypes {
    /// Contains information about the criteria used for querying findings.
    public struct FindingCriteria: Swift.Equatable {
        /// Represents a map of finding properties that match specified conditions and values when querying findings.
        public var criterion: [Swift.String:GuardDutyClientTypes.Condition]?

        public init(
            criterion: [Swift.String:GuardDutyClientTypes.Condition]? = nil
        )
        {
            self.criterion = criterion
        }
    }

}

extension GuardDutyClientTypes {
    public enum FindingPublishingFrequency: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case fifteenMinutes
        case oneHour
        case sixHours
        case sdkUnknown(Swift.String)

        public static var allCases: [FindingPublishingFrequency] {
            return [
                .fifteenMinutes,
                .oneHour,
                .sixHours,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .fifteenMinutes: return "FIFTEEN_MINUTES"
            case .oneHour: return "ONE_HOUR"
            case .sixHours: return "SIX_HOURS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FindingPublishingFrequency(rawValue: rawValue) ?? FindingPublishingFrequency.sdkUnknown(rawValue)
        }
    }
}

extension GuardDutyClientTypes {
    public enum FindingStatisticType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case countBySeverity
        case sdkUnknown(Swift.String)

        public static var allCases: [FindingStatisticType] {
            return [
                .countBySeverity,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .countBySeverity: return "COUNT_BY_SEVERITY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FindingStatisticType(rawValue: rawValue) ?? FindingStatisticType.sdkUnknown(rawValue)
        }
    }
}

extension GuardDutyClientTypes.FindingStatistics: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case countBySeverity = "countBySeverity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let countBySeverity = countBySeverity {
            var countBySeverityContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .countBySeverity)
            for (dictKey0, countBySeverity0) in countBySeverity {
                try countBySeverityContainer.encode(countBySeverity0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let countBySeverityContainer = try containerValues.decodeIfPresent([Swift.String: Swift.Int?].self, forKey: .countBySeverity)
        var countBySeverityDecoded0: [Swift.String:Swift.Int]? = nil
        if let countBySeverityContainer = countBySeverityContainer {
            countBySeverityDecoded0 = [Swift.String:Swift.Int]()
            for (key0, integer0) in countBySeverityContainer {
                if let integer0 = integer0 {
                    countBySeverityDecoded0?[key0] = integer0
                }
            }
        }
        countBySeverity = countBySeverityDecoded0
    }
}

extension GuardDutyClientTypes {
    /// Contains information about finding statistics.
    public struct FindingStatistics: Swift.Equatable {
        /// Represents a map of severity to count statistics for a set of findings.
        public var countBySeverity: [Swift.String:Swift.Int]?

        public init(
            countBySeverity: [Swift.String:Swift.Int]? = nil
        )
        {
            self.countBySeverity = countBySeverity
        }
    }

}

extension GuardDutyClientTypes.FlowLogsConfigurationResult: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status = "status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.DataSourceStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension GuardDutyClientTypes {
    /// Contains information on the status of VPC flow logs as a data source.
    public struct FlowLogsConfigurationResult: Swift.Equatable {
        /// Denotes whether VPC flow logs is enabled as a data source.
        /// This member is required.
        public var status: GuardDutyClientTypes.DataSourceStatus?

        public init(
            status: GuardDutyClientTypes.DataSourceStatus? = nil
        )
        {
            self.status = status
        }
    }

}

extension GuardDutyClientTypes.FreeTrialFeatureConfigurationResult: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case freeTrialDaysRemaining = "freeTrialDaysRemaining"
        case name = "name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if freeTrialDaysRemaining != 0 {
            try encodeContainer.encode(freeTrialDaysRemaining, forKey: .freeTrialDaysRemaining)
        }
        if let name = self.name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.FreeTrialFeatureResult.self, forKey: .name)
        name = nameDecoded
        let freeTrialDaysRemainingDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .freeTrialDaysRemaining) ?? 0
        freeTrialDaysRemaining = freeTrialDaysRemainingDecoded
    }
}

extension GuardDutyClientTypes {
    /// Contains information about the free trial period for a feature.
    public struct FreeTrialFeatureConfigurationResult: Swift.Equatable {
        /// The number of the remaining free trial days for the feature.
        public var freeTrialDaysRemaining: Swift.Int
        /// The name of the feature for which the free trial is configured.
        public var name: GuardDutyClientTypes.FreeTrialFeatureResult?

        public init(
            freeTrialDaysRemaining: Swift.Int = 0,
            name: GuardDutyClientTypes.FreeTrialFeatureResult? = nil
        )
        {
            self.freeTrialDaysRemaining = freeTrialDaysRemaining
            self.name = name
        }
    }

}

extension GuardDutyClientTypes {
    public enum FreeTrialFeatureResult: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cloudTrail
        case dnsLogs
        case ebsMalwareProtection
        case eksAuditLogs
        case eksRuntimeMonitoring
        case flowLogs
        case lambdaNetworkLogs
        case rdsLoginEvents
        case s3DataEvents
        case sdkUnknown(Swift.String)

        public static var allCases: [FreeTrialFeatureResult] {
            return [
                .cloudTrail,
                .dnsLogs,
                .ebsMalwareProtection,
                .eksAuditLogs,
                .eksRuntimeMonitoring,
                .flowLogs,
                .lambdaNetworkLogs,
                .rdsLoginEvents,
                .s3DataEvents,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cloudTrail: return "CLOUD_TRAIL"
            case .dnsLogs: return "DNS_LOGS"
            case .ebsMalwareProtection: return "EBS_MALWARE_PROTECTION"
            case .eksAuditLogs: return "EKS_AUDIT_LOGS"
            case .eksRuntimeMonitoring: return "EKS_RUNTIME_MONITORING"
            case .flowLogs: return "FLOW_LOGS"
            case .lambdaNetworkLogs: return "LAMBDA_NETWORK_LOGS"
            case .rdsLoginEvents: return "RDS_LOGIN_EVENTS"
            case .s3DataEvents: return "S3_DATA_EVENTS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FreeTrialFeatureResult(rawValue: rawValue) ?? FreeTrialFeatureResult.sdkUnknown(rawValue)
        }
    }
}

extension GuardDutyClientTypes.GeoLocation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lat = "lat"
        case lon = "lon"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if lat != 0.0 {
            try encodeContainer.encode(lat, forKey: .lat)
        }
        if lon != 0.0 {
            try encodeContainer.encode(lon, forKey: .lon)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let latDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .lat) ?? 0.0
        lat = latDecoded
        let lonDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .lon) ?? 0.0
        lon = lonDecoded
    }
}

extension GuardDutyClientTypes {
    /// Contains information about the location of the remote IP address.
    public struct GeoLocation: Swift.Equatable {
        /// The latitude information of the remote IP address.
        public var lat: Swift.Double
        /// The longitude information of the remote IP address.
        public var lon: Swift.Double

        public init(
            lat: Swift.Double = 0.0,
            lon: Swift.Double = 0.0
        )
        {
            self.lat = lat
            self.lon = lon
        }
    }

}

extension GetAdministratorAccountInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let detectorId = detectorId else {
            return nil
        }
        return "/detector/\(detectorId.urlPercentEncoding())/administrator"
    }
}

public struct GetAdministratorAccountInput: Swift.Equatable {
    /// The unique ID of the detector of the GuardDuty member account.
    /// This member is required.
    public var detectorId: Swift.String?

    public init(
        detectorId: Swift.String? = nil
    )
    {
        self.detectorId = detectorId
    }
}

struct GetAdministratorAccountInputBody: Swift.Equatable {
}

extension GetAdministratorAccountInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetAdministratorAccountOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetAdministratorAccountOutputBody = try responseDecoder.decode(responseBody: data)
            self.administrator = output.administrator
        } else {
            self.administrator = nil
        }
    }
}

public struct GetAdministratorAccountOutput: Swift.Equatable {
    /// The administrator account details.
    /// This member is required.
    public var administrator: GuardDutyClientTypes.Administrator?

    public init(
        administrator: GuardDutyClientTypes.Administrator? = nil
    )
    {
        self.administrator = administrator
    }
}

struct GetAdministratorAccountOutputBody: Swift.Equatable {
    let administrator: GuardDutyClientTypes.Administrator?
}

extension GetAdministratorAccountOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case administrator = "administrator"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let administratorDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.Administrator.self, forKey: .administrator)
        administrator = administratorDecoded
    }
}

enum GetAdministratorAccountOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetCoverageStatisticsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filterCriteria = "filterCriteria"
        case statisticsType = "statisticsType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filterCriteria = self.filterCriteria {
            try encodeContainer.encode(filterCriteria, forKey: .filterCriteria)
        }
        if let statisticsType = statisticsType {
            var statisticsTypeContainer = encodeContainer.nestedUnkeyedContainer(forKey: .statisticsType)
            for coveragestatisticstype0 in statisticsType {
                try statisticsTypeContainer.encode(coveragestatisticstype0.rawValue)
            }
        }
    }
}

extension GetCoverageStatisticsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let detectorId = detectorId else {
            return nil
        }
        return "/detector/\(detectorId.urlPercentEncoding())/coverage/statistics"
    }
}

public struct GetCoverageStatisticsInput: Swift.Equatable {
    /// The unique ID of the GuardDuty detector associated to the coverage statistics.
    /// This member is required.
    public var detectorId: Swift.String?
    /// Represents the criteria used to filter the coverage statistics
    public var filterCriteria: GuardDutyClientTypes.CoverageFilterCriteria?
    /// Represents the statistics type used to aggregate the coverage details.
    /// This member is required.
    public var statisticsType: [GuardDutyClientTypes.CoverageStatisticsType]?

    public init(
        detectorId: Swift.String? = nil,
        filterCriteria: GuardDutyClientTypes.CoverageFilterCriteria? = nil,
        statisticsType: [GuardDutyClientTypes.CoverageStatisticsType]? = nil
    )
    {
        self.detectorId = detectorId
        self.filterCriteria = filterCriteria
        self.statisticsType = statisticsType
    }
}

struct GetCoverageStatisticsInputBody: Swift.Equatable {
    let filterCriteria: GuardDutyClientTypes.CoverageFilterCriteria?
    let statisticsType: [GuardDutyClientTypes.CoverageStatisticsType]?
}

extension GetCoverageStatisticsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filterCriteria = "filterCriteria"
        case statisticsType = "statisticsType"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filterCriteriaDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.CoverageFilterCriteria.self, forKey: .filterCriteria)
        filterCriteria = filterCriteriaDecoded
        let statisticsTypeContainer = try containerValues.decodeIfPresent([GuardDutyClientTypes.CoverageStatisticsType?].self, forKey: .statisticsType)
        var statisticsTypeDecoded0:[GuardDutyClientTypes.CoverageStatisticsType]? = nil
        if let statisticsTypeContainer = statisticsTypeContainer {
            statisticsTypeDecoded0 = [GuardDutyClientTypes.CoverageStatisticsType]()
            for enum0 in statisticsTypeContainer {
                if let enum0 = enum0 {
                    statisticsTypeDecoded0?.append(enum0)
                }
            }
        }
        statisticsType = statisticsTypeDecoded0
    }
}

extension GetCoverageStatisticsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetCoverageStatisticsOutputBody = try responseDecoder.decode(responseBody: data)
            self.coverageStatistics = output.coverageStatistics
        } else {
            self.coverageStatistics = nil
        }
    }
}

public struct GetCoverageStatisticsOutput: Swift.Equatable {
    /// Represents the count aggregated by the statusCode and resourceType.
    public var coverageStatistics: GuardDutyClientTypes.CoverageStatistics?

    public init(
        coverageStatistics: GuardDutyClientTypes.CoverageStatistics? = nil
    )
    {
        self.coverageStatistics = coverageStatistics
    }
}

struct GetCoverageStatisticsOutputBody: Swift.Equatable {
    let coverageStatistics: GuardDutyClientTypes.CoverageStatistics?
}

extension GetCoverageStatisticsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case coverageStatistics = "coverageStatistics"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let coverageStatisticsDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.CoverageStatistics.self, forKey: .coverageStatistics)
        coverageStatistics = coverageStatisticsDecoded
    }
}

enum GetCoverageStatisticsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetDetectorInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let detectorId = detectorId else {
            return nil
        }
        return "/detector/\(detectorId.urlPercentEncoding())"
    }
}

public struct GetDetectorInput: Swift.Equatable {
    /// The unique ID of the detector that you want to get.
    /// This member is required.
    public var detectorId: Swift.String?

    public init(
        detectorId: Swift.String? = nil
    )
    {
        self.detectorId = detectorId
    }
}

struct GetDetectorInputBody: Swift.Equatable {
}

extension GetDetectorInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetDetectorOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetDetectorOutputBody = try responseDecoder.decode(responseBody: data)
            self.createdAt = output.createdAt
            self.dataSources = output.dataSources
            self.features = output.features
            self.findingPublishingFrequency = output.findingPublishingFrequency
            self.serviceRole = output.serviceRole
            self.status = output.status
            self.tags = output.tags
            self.updatedAt = output.updatedAt
        } else {
            self.createdAt = nil
            self.dataSources = nil
            self.features = nil
            self.findingPublishingFrequency = nil
            self.serviceRole = nil
            self.status = nil
            self.tags = nil
            self.updatedAt = nil
        }
    }
}

public struct GetDetectorOutput: Swift.Equatable {
    /// The timestamp of when the detector was created.
    public var createdAt: Swift.String?
    /// Describes which data sources are enabled for the detector.
    @available(*, deprecated, message: "This parameter is deprecated, use Features instead")
    public var dataSources: GuardDutyClientTypes.DataSourceConfigurationsResult?
    /// Describes the features that have been enabled for the detector.
    public var features: [GuardDutyClientTypes.DetectorFeatureConfigurationResult]?
    /// The publishing frequency of the finding.
    public var findingPublishingFrequency: GuardDutyClientTypes.FindingPublishingFrequency?
    /// The GuardDuty service role.
    /// This member is required.
    public var serviceRole: Swift.String?
    /// The detector status.
    /// This member is required.
    public var status: GuardDutyClientTypes.DetectorStatus?
    /// The tags of the detector resource.
    public var tags: [Swift.String:Swift.String]?
    /// The last-updated timestamp for the detector.
    public var updatedAt: Swift.String?

    public init(
        createdAt: Swift.String? = nil,
        dataSources: GuardDutyClientTypes.DataSourceConfigurationsResult? = nil,
        features: [GuardDutyClientTypes.DetectorFeatureConfigurationResult]? = nil,
        findingPublishingFrequency: GuardDutyClientTypes.FindingPublishingFrequency? = nil,
        serviceRole: Swift.String? = nil,
        status: GuardDutyClientTypes.DetectorStatus? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        updatedAt: Swift.String? = nil
    )
    {
        self.createdAt = createdAt
        self.dataSources = dataSources
        self.features = features
        self.findingPublishingFrequency = findingPublishingFrequency
        self.serviceRole = serviceRole
        self.status = status
        self.tags = tags
        self.updatedAt = updatedAt
    }
}

struct GetDetectorOutputBody: Swift.Equatable {
    let createdAt: Swift.String?
    let findingPublishingFrequency: GuardDutyClientTypes.FindingPublishingFrequency?
    let serviceRole: Swift.String?
    let status: GuardDutyClientTypes.DetectorStatus?
    let updatedAt: Swift.String?
    let dataSources: GuardDutyClientTypes.DataSourceConfigurationsResult?
    let tags: [Swift.String:Swift.String]?
    let features: [GuardDutyClientTypes.DetectorFeatureConfigurationResult]?
}

extension GetDetectorOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt = "createdAt"
        case dataSources = "dataSources"
        case features = "features"
        case findingPublishingFrequency = "findingPublishingFrequency"
        case serviceRole = "serviceRole"
        case status = "status"
        case tags = "tags"
        case updatedAt = "updatedAt"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let createdAtDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let findingPublishingFrequencyDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.FindingPublishingFrequency.self, forKey: .findingPublishingFrequency)
        findingPublishingFrequency = findingPublishingFrequencyDecoded
        let serviceRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceRole)
        serviceRole = serviceRoleDecoded
        let statusDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.DetectorStatus.self, forKey: .status)
        status = statusDecoded
        let updatedAtDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let dataSourcesDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.DataSourceConfigurationsResult.self, forKey: .dataSources)
        dataSources = dataSourcesDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let featuresContainer = try containerValues.decodeIfPresent([GuardDutyClientTypes.DetectorFeatureConfigurationResult?].self, forKey: .features)
        var featuresDecoded0:[GuardDutyClientTypes.DetectorFeatureConfigurationResult]? = nil
        if let featuresContainer = featuresContainer {
            featuresDecoded0 = [GuardDutyClientTypes.DetectorFeatureConfigurationResult]()
            for structure0 in featuresContainer {
                if let structure0 = structure0 {
                    featuresDecoded0?.append(structure0)
                }
            }
        }
        features = featuresDecoded0
    }
}

enum GetDetectorOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetFilterInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let detectorId = detectorId else {
            return nil
        }
        guard let filterName = filterName else {
            return nil
        }
        return "/detector/\(detectorId.urlPercentEncoding())/filter/\(filterName.urlPercentEncoding())"
    }
}

public struct GetFilterInput: Swift.Equatable {
    /// The unique ID of the detector that the filter is associated with.
    /// This member is required.
    public var detectorId: Swift.String?
    /// The name of the filter you want to get.
    /// This member is required.
    public var filterName: Swift.String?

    public init(
        detectorId: Swift.String? = nil,
        filterName: Swift.String? = nil
    )
    {
        self.detectorId = detectorId
        self.filterName = filterName
    }
}

struct GetFilterInputBody: Swift.Equatable {
}

extension GetFilterInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetFilterOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetFilterOutputBody = try responseDecoder.decode(responseBody: data)
            self.action = output.action
            self.description = output.description
            self.findingCriteria = output.findingCriteria
            self.name = output.name
            self.rank = output.rank
            self.tags = output.tags
        } else {
            self.action = nil
            self.description = nil
            self.findingCriteria = nil
            self.name = nil
            self.rank = 0
            self.tags = nil
        }
    }
}

public struct GetFilterOutput: Swift.Equatable {
    /// Specifies the action that is to be applied to the findings that match the filter.
    /// This member is required.
    public var action: GuardDutyClientTypes.FilterAction?
    /// The description of the filter.
    public var description: Swift.String?
    /// Represents the criteria to be used in the filter for querying findings.
    /// This member is required.
    public var findingCriteria: GuardDutyClientTypes.FindingCriteria?
    /// The name of the filter.
    /// This member is required.
    public var name: Swift.String?
    /// Specifies the position of the filter in the list of current filters. Also specifies the order in which this filter is applied to the findings.
    public var rank: Swift.Int
    /// The tags of the filter resource.
    public var tags: [Swift.String:Swift.String]?

    public init(
        action: GuardDutyClientTypes.FilterAction? = nil,
        description: Swift.String? = nil,
        findingCriteria: GuardDutyClientTypes.FindingCriteria? = nil,
        name: Swift.String? = nil,
        rank: Swift.Int = 0,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.action = action
        self.description = description
        self.findingCriteria = findingCriteria
        self.name = name
        self.rank = rank
        self.tags = tags
    }
}

struct GetFilterOutputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let action: GuardDutyClientTypes.FilterAction?
    let rank: Swift.Int
    let findingCriteria: GuardDutyClientTypes.FindingCriteria?
    let tags: [Swift.String:Swift.String]?
}

extension GetFilterOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action = "action"
        case description = "description"
        case findingCriteria = "findingCriteria"
        case name = "name"
        case rank = "rank"
        case tags = "tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let actionDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.FilterAction.self, forKey: .action)
        action = actionDecoded
        let rankDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .rank) ?? 0
        rank = rankDecoded
        let findingCriteriaDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.FindingCriteria.self, forKey: .findingCriteria)
        findingCriteria = findingCriteriaDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum GetFilterOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetFindingsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case findingIds = "findingIds"
        case sortCriteria = "sortCriteria"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let findingIds = findingIds {
            var findingIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .findingIds)
            for findingid0 in findingIds {
                try findingIdsContainer.encode(findingid0)
            }
        }
        if let sortCriteria = self.sortCriteria {
            try encodeContainer.encode(sortCriteria, forKey: .sortCriteria)
        }
    }
}

extension GetFindingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let detectorId = detectorId else {
            return nil
        }
        return "/detector/\(detectorId.urlPercentEncoding())/findings/get"
    }
}

public struct GetFindingsInput: Swift.Equatable {
    /// The ID of the detector that specifies the GuardDuty service whose findings you want to retrieve.
    /// This member is required.
    public var detectorId: Swift.String?
    /// The IDs of the findings that you want to retrieve.
    /// This member is required.
    public var findingIds: [Swift.String]?
    /// Represents the criteria used for sorting findings.
    public var sortCriteria: GuardDutyClientTypes.SortCriteria?

    public init(
        detectorId: Swift.String? = nil,
        findingIds: [Swift.String]? = nil,
        sortCriteria: GuardDutyClientTypes.SortCriteria? = nil
    )
    {
        self.detectorId = detectorId
        self.findingIds = findingIds
        self.sortCriteria = sortCriteria
    }
}

struct GetFindingsInputBody: Swift.Equatable {
    let findingIds: [Swift.String]?
    let sortCriteria: GuardDutyClientTypes.SortCriteria?
}

extension GetFindingsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case findingIds = "findingIds"
        case sortCriteria = "sortCriteria"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let findingIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .findingIds)
        var findingIdsDecoded0:[Swift.String]? = nil
        if let findingIdsContainer = findingIdsContainer {
            findingIdsDecoded0 = [Swift.String]()
            for string0 in findingIdsContainer {
                if let string0 = string0 {
                    findingIdsDecoded0?.append(string0)
                }
            }
        }
        findingIds = findingIdsDecoded0
        let sortCriteriaDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.SortCriteria.self, forKey: .sortCriteria)
        sortCriteria = sortCriteriaDecoded
    }
}

extension GetFindingsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetFindingsOutputBody = try responseDecoder.decode(responseBody: data)
            self.findings = output.findings
        } else {
            self.findings = nil
        }
    }
}

public struct GetFindingsOutput: Swift.Equatable {
    /// A list of findings.
    /// This member is required.
    public var findings: [GuardDutyClientTypes.Finding]?

    public init(
        findings: [GuardDutyClientTypes.Finding]? = nil
    )
    {
        self.findings = findings
    }
}

struct GetFindingsOutputBody: Swift.Equatable {
    let findings: [GuardDutyClientTypes.Finding]?
}

extension GetFindingsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case findings = "findings"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let findingsContainer = try containerValues.decodeIfPresent([GuardDutyClientTypes.Finding?].self, forKey: .findings)
        var findingsDecoded0:[GuardDutyClientTypes.Finding]? = nil
        if let findingsContainer = findingsContainer {
            findingsDecoded0 = [GuardDutyClientTypes.Finding]()
            for structure0 in findingsContainer {
                if let structure0 = structure0 {
                    findingsDecoded0?.append(structure0)
                }
            }
        }
        findings = findingsDecoded0
    }
}

enum GetFindingsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetFindingsStatisticsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case findingCriteria = "findingCriteria"
        case findingStatisticTypes = "findingStatisticTypes"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let findingCriteria = self.findingCriteria {
            try encodeContainer.encode(findingCriteria, forKey: .findingCriteria)
        }
        if let findingStatisticTypes = findingStatisticTypes {
            var findingStatisticTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .findingStatisticTypes)
            for findingstatistictype0 in findingStatisticTypes {
                try findingStatisticTypesContainer.encode(findingstatistictype0.rawValue)
            }
        }
    }
}

extension GetFindingsStatisticsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let detectorId = detectorId else {
            return nil
        }
        return "/detector/\(detectorId.urlPercentEncoding())/findings/statistics"
    }
}

public struct GetFindingsStatisticsInput: Swift.Equatable {
    /// The ID of the detector that specifies the GuardDuty service whose findings' statistics you want to retrieve.
    /// This member is required.
    public var detectorId: Swift.String?
    /// Represents the criteria that is used for querying findings.
    public var findingCriteria: GuardDutyClientTypes.FindingCriteria?
    /// The types of finding statistics to retrieve.
    /// This member is required.
    public var findingStatisticTypes: [GuardDutyClientTypes.FindingStatisticType]?

    public init(
        detectorId: Swift.String? = nil,
        findingCriteria: GuardDutyClientTypes.FindingCriteria? = nil,
        findingStatisticTypes: [GuardDutyClientTypes.FindingStatisticType]? = nil
    )
    {
        self.detectorId = detectorId
        self.findingCriteria = findingCriteria
        self.findingStatisticTypes = findingStatisticTypes
    }
}

struct GetFindingsStatisticsInputBody: Swift.Equatable {
    let findingStatisticTypes: [GuardDutyClientTypes.FindingStatisticType]?
    let findingCriteria: GuardDutyClientTypes.FindingCriteria?
}

extension GetFindingsStatisticsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case findingCriteria = "findingCriteria"
        case findingStatisticTypes = "findingStatisticTypes"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let findingStatisticTypesContainer = try containerValues.decodeIfPresent([GuardDutyClientTypes.FindingStatisticType?].self, forKey: .findingStatisticTypes)
        var findingStatisticTypesDecoded0:[GuardDutyClientTypes.FindingStatisticType]? = nil
        if let findingStatisticTypesContainer = findingStatisticTypesContainer {
            findingStatisticTypesDecoded0 = [GuardDutyClientTypes.FindingStatisticType]()
            for enum0 in findingStatisticTypesContainer {
                if let enum0 = enum0 {
                    findingStatisticTypesDecoded0?.append(enum0)
                }
            }
        }
        findingStatisticTypes = findingStatisticTypesDecoded0
        let findingCriteriaDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.FindingCriteria.self, forKey: .findingCriteria)
        findingCriteria = findingCriteriaDecoded
    }
}

extension GetFindingsStatisticsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetFindingsStatisticsOutputBody = try responseDecoder.decode(responseBody: data)
            self.findingStatistics = output.findingStatistics
        } else {
            self.findingStatistics = nil
        }
    }
}

public struct GetFindingsStatisticsOutput: Swift.Equatable {
    /// The finding statistics object.
    /// This member is required.
    public var findingStatistics: GuardDutyClientTypes.FindingStatistics?

    public init(
        findingStatistics: GuardDutyClientTypes.FindingStatistics? = nil
    )
    {
        self.findingStatistics = findingStatistics
    }
}

struct GetFindingsStatisticsOutputBody: Swift.Equatable {
    let findingStatistics: GuardDutyClientTypes.FindingStatistics?
}

extension GetFindingsStatisticsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case findingStatistics = "findingStatistics"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let findingStatisticsDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.FindingStatistics.self, forKey: .findingStatistics)
        findingStatistics = findingStatisticsDecoded
    }
}

enum GetFindingsStatisticsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetIPSetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let detectorId = detectorId else {
            return nil
        }
        guard let ipSetId = ipSetId else {
            return nil
        }
        return "/detector/\(detectorId.urlPercentEncoding())/ipset/\(ipSetId.urlPercentEncoding())"
    }
}

public struct GetIPSetInput: Swift.Equatable {
    /// The unique ID of the detector that the IPSet is associated with.
    /// This member is required.
    public var detectorId: Swift.String?
    /// The unique ID of the IPSet to retrieve.
    /// This member is required.
    public var ipSetId: Swift.String?

    public init(
        detectorId: Swift.String? = nil,
        ipSetId: Swift.String? = nil
    )
    {
        self.detectorId = detectorId
        self.ipSetId = ipSetId
    }
}

struct GetIPSetInputBody: Swift.Equatable {
}

extension GetIPSetInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetIPSetOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetIPSetOutputBody = try responseDecoder.decode(responseBody: data)
            self.format = output.format
            self.location = output.location
            self.name = output.name
            self.status = output.status
            self.tags = output.tags
        } else {
            self.format = nil
            self.location = nil
            self.name = nil
            self.status = nil
            self.tags = nil
        }
    }
}

public struct GetIPSetOutput: Swift.Equatable {
    /// The format of the file that contains the IPSet.
    /// This member is required.
    public var format: GuardDutyClientTypes.IpSetFormat?
    /// The URI of the file that contains the IPSet.
    /// This member is required.
    public var location: Swift.String?
    /// The user-friendly name for the IPSet.
    /// This member is required.
    public var name: Swift.String?
    /// The status of IPSet file that was uploaded.
    /// This member is required.
    public var status: GuardDutyClientTypes.IpSetStatus?
    /// The tags of the IPSet resource.
    public var tags: [Swift.String:Swift.String]?

    public init(
        format: GuardDutyClientTypes.IpSetFormat? = nil,
        location: Swift.String? = nil,
        name: Swift.String? = nil,
        status: GuardDutyClientTypes.IpSetStatus? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.format = format
        self.location = location
        self.name = name
        self.status = status
        self.tags = tags
    }
}

struct GetIPSetOutputBody: Swift.Equatable {
    let name: Swift.String?
    let format: GuardDutyClientTypes.IpSetFormat?
    let location: Swift.String?
    let status: GuardDutyClientTypes.IpSetStatus?
    let tags: [Swift.String:Swift.String]?
}

extension GetIPSetOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case format = "format"
        case location = "location"
        case name = "name"
        case status = "status"
        case tags = "tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let formatDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.IpSetFormat.self, forKey: .format)
        format = formatDecoded
        let locationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .location)
        location = locationDecoded
        let statusDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.IpSetStatus.self, forKey: .status)
        status = statusDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum GetIPSetOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetInvitationsCountInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/invitation/count"
    }
}

public struct GetInvitationsCountInput: Swift.Equatable {

    public init() { }
}

struct GetInvitationsCountInputBody: Swift.Equatable {
}

extension GetInvitationsCountInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetInvitationsCountOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetInvitationsCountOutputBody = try responseDecoder.decode(responseBody: data)
            self.invitationsCount = output.invitationsCount
        } else {
            self.invitationsCount = 0
        }
    }
}

public struct GetInvitationsCountOutput: Swift.Equatable {
    /// The number of received invitations.
    public var invitationsCount: Swift.Int

    public init(
        invitationsCount: Swift.Int = 0
    )
    {
        self.invitationsCount = invitationsCount
    }
}

struct GetInvitationsCountOutputBody: Swift.Equatable {
    let invitationsCount: Swift.Int
}

extension GetInvitationsCountOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case invitationsCount = "invitationsCount"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let invitationsCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .invitationsCount) ?? 0
        invitationsCount = invitationsCountDecoded
    }
}

enum GetInvitationsCountOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetMalwareScanSettingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let detectorId = detectorId else {
            return nil
        }
        return "/detector/\(detectorId.urlPercentEncoding())/malware-scan-settings"
    }
}

public struct GetMalwareScanSettingsInput: Swift.Equatable {
    /// The unique ID of the detector that the scan setting is associated with.
    /// This member is required.
    public var detectorId: Swift.String?

    public init(
        detectorId: Swift.String? = nil
    )
    {
        self.detectorId = detectorId
    }
}

struct GetMalwareScanSettingsInputBody: Swift.Equatable {
}

extension GetMalwareScanSettingsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetMalwareScanSettingsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetMalwareScanSettingsOutputBody = try responseDecoder.decode(responseBody: data)
            self.ebsSnapshotPreservation = output.ebsSnapshotPreservation
            self.scanResourceCriteria = output.scanResourceCriteria
        } else {
            self.ebsSnapshotPreservation = nil
            self.scanResourceCriteria = nil
        }
    }
}

public struct GetMalwareScanSettingsOutput: Swift.Equatable {
    /// An enum value representing possible snapshot preservation settings.
    public var ebsSnapshotPreservation: GuardDutyClientTypes.EbsSnapshotPreservation?
    /// Represents the criteria to be used in the filter for scanning resources.
    public var scanResourceCriteria: GuardDutyClientTypes.ScanResourceCriteria?

    public init(
        ebsSnapshotPreservation: GuardDutyClientTypes.EbsSnapshotPreservation? = nil,
        scanResourceCriteria: GuardDutyClientTypes.ScanResourceCriteria? = nil
    )
    {
        self.ebsSnapshotPreservation = ebsSnapshotPreservation
        self.scanResourceCriteria = scanResourceCriteria
    }
}

struct GetMalwareScanSettingsOutputBody: Swift.Equatable {
    let scanResourceCriteria: GuardDutyClientTypes.ScanResourceCriteria?
    let ebsSnapshotPreservation: GuardDutyClientTypes.EbsSnapshotPreservation?
}

extension GetMalwareScanSettingsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ebsSnapshotPreservation = "ebsSnapshotPreservation"
        case scanResourceCriteria = "scanResourceCriteria"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scanResourceCriteriaDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.ScanResourceCriteria.self, forKey: .scanResourceCriteria)
        scanResourceCriteria = scanResourceCriteriaDecoded
        let ebsSnapshotPreservationDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.EbsSnapshotPreservation.self, forKey: .ebsSnapshotPreservation)
        ebsSnapshotPreservation = ebsSnapshotPreservationDecoded
    }
}

enum GetMalwareScanSettingsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetMasterAccountInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let detectorId = detectorId else {
            return nil
        }
        return "/detector/\(detectorId.urlPercentEncoding())/master"
    }
}

@available(*, deprecated, message: "This input is deprecated, use GetAdministratorAccountRequest instead")
public struct GetMasterAccountInput: Swift.Equatable {
    /// The unique ID of the detector of the GuardDuty member account.
    /// This member is required.
    public var detectorId: Swift.String?

    public init(
        detectorId: Swift.String? = nil
    )
    {
        self.detectorId = detectorId
    }
}

struct GetMasterAccountInputBody: Swift.Equatable {
}

extension GetMasterAccountInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetMasterAccountOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetMasterAccountOutputBody = try responseDecoder.decode(responseBody: data)
            self.master = output.master
        } else {
            self.master = nil
        }
    }
}

@available(*, deprecated, message: "This output is deprecated, use GetAdministratorAccountResponse instead")
public struct GetMasterAccountOutput: Swift.Equatable {
    /// The administrator account details.
    /// This member is required.
    public var master: GuardDutyClientTypes.Master?

    public init(
        master: GuardDutyClientTypes.Master? = nil
    )
    {
        self.master = master
    }
}

struct GetMasterAccountOutputBody: Swift.Equatable {
    let master: GuardDutyClientTypes.Master?
}

extension GetMasterAccountOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case master = "master"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let masterDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.Master.self, forKey: .master)
        master = masterDecoded
    }
}

enum GetMasterAccountOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetMemberDetectorsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountIds = "accountIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountIds = accountIds {
            var accountIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accountIds)
            for accountid0 in accountIds {
                try accountIdsContainer.encode(accountid0)
            }
        }
    }
}

extension GetMemberDetectorsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let detectorId = detectorId else {
            return nil
        }
        return "/detector/\(detectorId.urlPercentEncoding())/member/detector/get"
    }
}

public struct GetMemberDetectorsInput: Swift.Equatable {
    /// The account ID of the member account.
    /// This member is required.
    public var accountIds: [Swift.String]?
    /// The detector ID for the administrator account.
    /// This member is required.
    public var detectorId: Swift.String?

    public init(
        accountIds: [Swift.String]? = nil,
        detectorId: Swift.String? = nil
    )
    {
        self.accountIds = accountIds
        self.detectorId = detectorId
    }
}

struct GetMemberDetectorsInputBody: Swift.Equatable {
    let accountIds: [Swift.String]?
}

extension GetMemberDetectorsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountIds = "accountIds"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .accountIds)
        var accountIdsDecoded0:[Swift.String]? = nil
        if let accountIdsContainer = accountIdsContainer {
            accountIdsDecoded0 = [Swift.String]()
            for string0 in accountIdsContainer {
                if let string0 = string0 {
                    accountIdsDecoded0?.append(string0)
                }
            }
        }
        accountIds = accountIdsDecoded0
    }
}

extension GetMemberDetectorsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetMemberDetectorsOutputBody = try responseDecoder.decode(responseBody: data)
            self.memberDataSourceConfigurations = output.memberDataSourceConfigurations
            self.unprocessedAccounts = output.unprocessedAccounts
        } else {
            self.memberDataSourceConfigurations = nil
            self.unprocessedAccounts = nil
        }
    }
}

public struct GetMemberDetectorsOutput: Swift.Equatable {
    /// An object that describes which data sources are enabled for a member account.
    /// This member is required.
    public var memberDataSourceConfigurations: [GuardDutyClientTypes.MemberDataSourceConfiguration]?
    /// A list of member account IDs that were unable to be processed along with an explanation for why they were not processed.
    /// This member is required.
    public var unprocessedAccounts: [GuardDutyClientTypes.UnprocessedAccount]?

    public init(
        memberDataSourceConfigurations: [GuardDutyClientTypes.MemberDataSourceConfiguration]? = nil,
        unprocessedAccounts: [GuardDutyClientTypes.UnprocessedAccount]? = nil
    )
    {
        self.memberDataSourceConfigurations = memberDataSourceConfigurations
        self.unprocessedAccounts = unprocessedAccounts
    }
}

struct GetMemberDetectorsOutputBody: Swift.Equatable {
    let memberDataSourceConfigurations: [GuardDutyClientTypes.MemberDataSourceConfiguration]?
    let unprocessedAccounts: [GuardDutyClientTypes.UnprocessedAccount]?
}

extension GetMemberDetectorsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case memberDataSourceConfigurations = "members"
        case unprocessedAccounts = "unprocessedAccounts"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let memberDataSourceConfigurationsContainer = try containerValues.decodeIfPresent([GuardDutyClientTypes.MemberDataSourceConfiguration?].self, forKey: .memberDataSourceConfigurations)
        var memberDataSourceConfigurationsDecoded0:[GuardDutyClientTypes.MemberDataSourceConfiguration]? = nil
        if let memberDataSourceConfigurationsContainer = memberDataSourceConfigurationsContainer {
            memberDataSourceConfigurationsDecoded0 = [GuardDutyClientTypes.MemberDataSourceConfiguration]()
            for structure0 in memberDataSourceConfigurationsContainer {
                if let structure0 = structure0 {
                    memberDataSourceConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        memberDataSourceConfigurations = memberDataSourceConfigurationsDecoded0
        let unprocessedAccountsContainer = try containerValues.decodeIfPresent([GuardDutyClientTypes.UnprocessedAccount?].self, forKey: .unprocessedAccounts)
        var unprocessedAccountsDecoded0:[GuardDutyClientTypes.UnprocessedAccount]? = nil
        if let unprocessedAccountsContainer = unprocessedAccountsContainer {
            unprocessedAccountsDecoded0 = [GuardDutyClientTypes.UnprocessedAccount]()
            for structure0 in unprocessedAccountsContainer {
                if let structure0 = structure0 {
                    unprocessedAccountsDecoded0?.append(structure0)
                }
            }
        }
        unprocessedAccounts = unprocessedAccountsDecoded0
    }
}

enum GetMemberDetectorsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetMembersInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountIds = "accountIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountIds = accountIds {
            var accountIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accountIds)
            for accountid0 in accountIds {
                try accountIdsContainer.encode(accountid0)
            }
        }
    }
}

extension GetMembersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let detectorId = detectorId else {
            return nil
        }
        return "/detector/\(detectorId.urlPercentEncoding())/member/get"
    }
}

public struct GetMembersInput: Swift.Equatable {
    /// A list of account IDs of the GuardDuty member accounts that you want to describe.
    /// This member is required.
    public var accountIds: [Swift.String]?
    /// The unique ID of the detector of the GuardDuty account whose members you want to retrieve.
    /// This member is required.
    public var detectorId: Swift.String?

    public init(
        accountIds: [Swift.String]? = nil,
        detectorId: Swift.String? = nil
    )
    {
        self.accountIds = accountIds
        self.detectorId = detectorId
    }
}

struct GetMembersInputBody: Swift.Equatable {
    let accountIds: [Swift.String]?
}

extension GetMembersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountIds = "accountIds"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .accountIds)
        var accountIdsDecoded0:[Swift.String]? = nil
        if let accountIdsContainer = accountIdsContainer {
            accountIdsDecoded0 = [Swift.String]()
            for string0 in accountIdsContainer {
                if let string0 = string0 {
                    accountIdsDecoded0?.append(string0)
                }
            }
        }
        accountIds = accountIdsDecoded0
    }
}

extension GetMembersOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetMembersOutputBody = try responseDecoder.decode(responseBody: data)
            self.members = output.members
            self.unprocessedAccounts = output.unprocessedAccounts
        } else {
            self.members = nil
            self.unprocessedAccounts = nil
        }
    }
}

public struct GetMembersOutput: Swift.Equatable {
    /// A list of members.
    /// This member is required.
    public var members: [GuardDutyClientTypes.Member]?
    /// A list of objects that contain the unprocessed account and a result string that explains why it was unprocessed.
    /// This member is required.
    public var unprocessedAccounts: [GuardDutyClientTypes.UnprocessedAccount]?

    public init(
        members: [GuardDutyClientTypes.Member]? = nil,
        unprocessedAccounts: [GuardDutyClientTypes.UnprocessedAccount]? = nil
    )
    {
        self.members = members
        self.unprocessedAccounts = unprocessedAccounts
    }
}

struct GetMembersOutputBody: Swift.Equatable {
    let members: [GuardDutyClientTypes.Member]?
    let unprocessedAccounts: [GuardDutyClientTypes.UnprocessedAccount]?
}

extension GetMembersOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case members = "members"
        case unprocessedAccounts = "unprocessedAccounts"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let membersContainer = try containerValues.decodeIfPresent([GuardDutyClientTypes.Member?].self, forKey: .members)
        var membersDecoded0:[GuardDutyClientTypes.Member]? = nil
        if let membersContainer = membersContainer {
            membersDecoded0 = [GuardDutyClientTypes.Member]()
            for structure0 in membersContainer {
                if let structure0 = structure0 {
                    membersDecoded0?.append(structure0)
                }
            }
        }
        members = membersDecoded0
        let unprocessedAccountsContainer = try containerValues.decodeIfPresent([GuardDutyClientTypes.UnprocessedAccount?].self, forKey: .unprocessedAccounts)
        var unprocessedAccountsDecoded0:[GuardDutyClientTypes.UnprocessedAccount]? = nil
        if let unprocessedAccountsContainer = unprocessedAccountsContainer {
            unprocessedAccountsDecoded0 = [GuardDutyClientTypes.UnprocessedAccount]()
            for structure0 in unprocessedAccountsContainer {
                if let structure0 = structure0 {
                    unprocessedAccountsDecoded0?.append(structure0)
                }
            }
        }
        unprocessedAccounts = unprocessedAccountsDecoded0
    }
}

enum GetMembersOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetRemainingFreeTrialDaysInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountIds = "accountIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountIds = accountIds {
            var accountIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accountIds)
            for accountid0 in accountIds {
                try accountIdsContainer.encode(accountid0)
            }
        }
    }
}

extension GetRemainingFreeTrialDaysInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let detectorId = detectorId else {
            return nil
        }
        return "/detector/\(detectorId.urlPercentEncoding())/freeTrial/daysRemaining"
    }
}

public struct GetRemainingFreeTrialDaysInput: Swift.Equatable {
    /// A list of account identifiers of the GuardDuty member account.
    public var accountIds: [Swift.String]?
    /// The unique ID of the detector of the GuardDuty member account.
    /// This member is required.
    public var detectorId: Swift.String?

    public init(
        accountIds: [Swift.String]? = nil,
        detectorId: Swift.String? = nil
    )
    {
        self.accountIds = accountIds
        self.detectorId = detectorId
    }
}

struct GetRemainingFreeTrialDaysInputBody: Swift.Equatable {
    let accountIds: [Swift.String]?
}

extension GetRemainingFreeTrialDaysInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountIds = "accountIds"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .accountIds)
        var accountIdsDecoded0:[Swift.String]? = nil
        if let accountIdsContainer = accountIdsContainer {
            accountIdsDecoded0 = [Swift.String]()
            for string0 in accountIdsContainer {
                if let string0 = string0 {
                    accountIdsDecoded0?.append(string0)
                }
            }
        }
        accountIds = accountIdsDecoded0
    }
}

extension GetRemainingFreeTrialDaysOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetRemainingFreeTrialDaysOutputBody = try responseDecoder.decode(responseBody: data)
            self.accounts = output.accounts
            self.unprocessedAccounts = output.unprocessedAccounts
        } else {
            self.accounts = nil
            self.unprocessedAccounts = nil
        }
    }
}

public struct GetRemainingFreeTrialDaysOutput: Swift.Equatable {
    /// The member accounts which were included in a request and were processed successfully.
    public var accounts: [GuardDutyClientTypes.AccountFreeTrialInfo]?
    /// The member account that was included in a request but for which the request could not be processed.
    public var unprocessedAccounts: [GuardDutyClientTypes.UnprocessedAccount]?

    public init(
        accounts: [GuardDutyClientTypes.AccountFreeTrialInfo]? = nil,
        unprocessedAccounts: [GuardDutyClientTypes.UnprocessedAccount]? = nil
    )
    {
        self.accounts = accounts
        self.unprocessedAccounts = unprocessedAccounts
    }
}

struct GetRemainingFreeTrialDaysOutputBody: Swift.Equatable {
    let accounts: [GuardDutyClientTypes.AccountFreeTrialInfo]?
    let unprocessedAccounts: [GuardDutyClientTypes.UnprocessedAccount]?
}

extension GetRemainingFreeTrialDaysOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accounts = "accounts"
        case unprocessedAccounts = "unprocessedAccounts"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountsContainer = try containerValues.decodeIfPresent([GuardDutyClientTypes.AccountFreeTrialInfo?].self, forKey: .accounts)
        var accountsDecoded0:[GuardDutyClientTypes.AccountFreeTrialInfo]? = nil
        if let accountsContainer = accountsContainer {
            accountsDecoded0 = [GuardDutyClientTypes.AccountFreeTrialInfo]()
            for structure0 in accountsContainer {
                if let structure0 = structure0 {
                    accountsDecoded0?.append(structure0)
                }
            }
        }
        accounts = accountsDecoded0
        let unprocessedAccountsContainer = try containerValues.decodeIfPresent([GuardDutyClientTypes.UnprocessedAccount?].self, forKey: .unprocessedAccounts)
        var unprocessedAccountsDecoded0:[GuardDutyClientTypes.UnprocessedAccount]? = nil
        if let unprocessedAccountsContainer = unprocessedAccountsContainer {
            unprocessedAccountsDecoded0 = [GuardDutyClientTypes.UnprocessedAccount]()
            for structure0 in unprocessedAccountsContainer {
                if let structure0 = structure0 {
                    unprocessedAccountsDecoded0?.append(structure0)
                }
            }
        }
        unprocessedAccounts = unprocessedAccountsDecoded0
    }
}

enum GetRemainingFreeTrialDaysOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetThreatIntelSetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let detectorId = detectorId else {
            return nil
        }
        guard let threatIntelSetId = threatIntelSetId else {
            return nil
        }
        return "/detector/\(detectorId.urlPercentEncoding())/threatintelset/\(threatIntelSetId.urlPercentEncoding())"
    }
}

public struct GetThreatIntelSetInput: Swift.Equatable {
    /// The unique ID of the detector that the threatIntelSet is associated with.
    /// This member is required.
    public var detectorId: Swift.String?
    /// The unique ID of the threatIntelSet that you want to get.
    /// This member is required.
    public var threatIntelSetId: Swift.String?

    public init(
        detectorId: Swift.String? = nil,
        threatIntelSetId: Swift.String? = nil
    )
    {
        self.detectorId = detectorId
        self.threatIntelSetId = threatIntelSetId
    }
}

struct GetThreatIntelSetInputBody: Swift.Equatable {
}

extension GetThreatIntelSetInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetThreatIntelSetOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetThreatIntelSetOutputBody = try responseDecoder.decode(responseBody: data)
            self.format = output.format
            self.location = output.location
            self.name = output.name
            self.status = output.status
            self.tags = output.tags
        } else {
            self.format = nil
            self.location = nil
            self.name = nil
            self.status = nil
            self.tags = nil
        }
    }
}

public struct GetThreatIntelSetOutput: Swift.Equatable {
    /// The format of the threatIntelSet.
    /// This member is required.
    public var format: GuardDutyClientTypes.ThreatIntelSetFormat?
    /// The URI of the file that contains the ThreatIntelSet.
    /// This member is required.
    public var location: Swift.String?
    /// A user-friendly ThreatIntelSet name displayed in all findings that are generated by activity that involves IP addresses included in this ThreatIntelSet.
    /// This member is required.
    public var name: Swift.String?
    /// The status of threatIntelSet file uploaded.
    /// This member is required.
    public var status: GuardDutyClientTypes.ThreatIntelSetStatus?
    /// The tags of the threat list resource.
    public var tags: [Swift.String:Swift.String]?

    public init(
        format: GuardDutyClientTypes.ThreatIntelSetFormat? = nil,
        location: Swift.String? = nil,
        name: Swift.String? = nil,
        status: GuardDutyClientTypes.ThreatIntelSetStatus? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.format = format
        self.location = location
        self.name = name
        self.status = status
        self.tags = tags
    }
}

struct GetThreatIntelSetOutputBody: Swift.Equatable {
    let name: Swift.String?
    let format: GuardDutyClientTypes.ThreatIntelSetFormat?
    let location: Swift.String?
    let status: GuardDutyClientTypes.ThreatIntelSetStatus?
    let tags: [Swift.String:Swift.String]?
}

extension GetThreatIntelSetOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case format = "format"
        case location = "location"
        case name = "name"
        case status = "status"
        case tags = "tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let formatDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.ThreatIntelSetFormat.self, forKey: .format)
        format = formatDecoded
        let locationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .location)
        location = locationDecoded
        let statusDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.ThreatIntelSetStatus.self, forKey: .status)
        status = statusDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum GetThreatIntelSetOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetUsageStatisticsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "maxResults"
        case nextToken = "nextToken"
        case unit = "unit"
        case usageCriteria = "usageCriteria"
        case usageStatisticType = "usageStatisticsType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let unit = self.unit {
            try encodeContainer.encode(unit, forKey: .unit)
        }
        if let usageCriteria = self.usageCriteria {
            try encodeContainer.encode(usageCriteria, forKey: .usageCriteria)
        }
        if let usageStatisticType = self.usageStatisticType {
            try encodeContainer.encode(usageStatisticType.rawValue, forKey: .usageStatisticType)
        }
    }
}

extension GetUsageStatisticsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let detectorId = detectorId else {
            return nil
        }
        return "/detector/\(detectorId.urlPercentEncoding())/usage/statistics"
    }
}

public struct GetUsageStatisticsInput: Swift.Equatable {
    /// The ID of the detector that specifies the GuardDuty service whose usage statistics you want to retrieve.
    /// This member is required.
    public var detectorId: Swift.String?
    /// The maximum number of results to return in the response.
    public var maxResults: Swift.Int?
    /// A token to use for paginating results that are returned in the response. Set the value of this parameter to null for the first request to a list action. For subsequent calls, use the NextToken value returned from the previous request to continue listing results after the first page.
    public var nextToken: Swift.String?
    /// The currency unit you would like to view your usage statistics in. Current valid values are USD.
    public var unit: Swift.String?
    /// Represents the criteria used for querying usage.
    /// This member is required.
    public var usageCriteria: GuardDutyClientTypes.UsageCriteria?
    /// The type of usage statistics to retrieve.
    /// This member is required.
    public var usageStatisticType: GuardDutyClientTypes.UsageStatisticType?

    public init(
        detectorId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        unit: Swift.String? = nil,
        usageCriteria: GuardDutyClientTypes.UsageCriteria? = nil,
        usageStatisticType: GuardDutyClientTypes.UsageStatisticType? = nil
    )
    {
        self.detectorId = detectorId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.unit = unit
        self.usageCriteria = usageCriteria
        self.usageStatisticType = usageStatisticType
    }
}

struct GetUsageStatisticsInputBody: Swift.Equatable {
    let usageStatisticType: GuardDutyClientTypes.UsageStatisticType?
    let usageCriteria: GuardDutyClientTypes.UsageCriteria?
    let unit: Swift.String?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension GetUsageStatisticsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "maxResults"
        case nextToken = "nextToken"
        case unit = "unit"
        case usageCriteria = "usageCriteria"
        case usageStatisticType = "usageStatisticsType"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let usageStatisticTypeDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.UsageStatisticType.self, forKey: .usageStatisticType)
        usageStatisticType = usageStatisticTypeDecoded
        let usageCriteriaDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.UsageCriteria.self, forKey: .usageCriteria)
        usageCriteria = usageCriteriaDecoded
        let unitDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .unit)
        unit = unitDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetUsageStatisticsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetUsageStatisticsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.usageStatistics = output.usageStatistics
        } else {
            self.nextToken = nil
            self.usageStatistics = nil
        }
    }
}

public struct GetUsageStatisticsOutput: Swift.Equatable {
    /// The pagination parameter to be used on the next list operation to retrieve more items.
    public var nextToken: Swift.String?
    /// The usage statistics object. If a UsageStatisticType was provided, the objects representing other types will be null.
    public var usageStatistics: GuardDutyClientTypes.UsageStatistics?

    public init(
        nextToken: Swift.String? = nil,
        usageStatistics: GuardDutyClientTypes.UsageStatistics? = nil
    )
    {
        self.nextToken = nextToken
        self.usageStatistics = usageStatistics
    }
}

struct GetUsageStatisticsOutputBody: Swift.Equatable {
    let usageStatistics: GuardDutyClientTypes.UsageStatistics?
    let nextToken: Swift.String?
}

extension GetUsageStatisticsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "nextToken"
        case usageStatistics = "usageStatistics"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let usageStatisticsDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.UsageStatistics.self, forKey: .usageStatistics)
        usageStatistics = usageStatisticsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum GetUsageStatisticsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GuardDutyClientTypes.HighestSeverityThreatDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case count = "count"
        case severity = "severity"
        case threatName = "threatName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if count != 0 {
            try encodeContainer.encode(count, forKey: .count)
        }
        if let severity = self.severity {
            try encodeContainer.encode(severity, forKey: .severity)
        }
        if let threatName = self.threatName {
            try encodeContainer.encode(threatName, forKey: .threatName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let severityDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .severity)
        severity = severityDecoded
        let threatNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .threatName)
        threatName = threatNameDecoded
        let countDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .count) ?? 0
        count = countDecoded
    }
}

extension GuardDutyClientTypes {
    /// Contains details of the highest severity threat detected during scan and number of infected files.
    public struct HighestSeverityThreatDetails: Swift.Equatable {
        /// Total number of infected files with the highest severity threat detected.
        public var count: Swift.Int
        /// Severity level of the highest severity threat detected.
        public var severity: Swift.String?
        /// Threat name of the highest severity threat detected as part of the malware scan.
        public var threatName: Swift.String?

        public init(
            count: Swift.Int = 0,
            severity: Swift.String? = nil,
            threatName: Swift.String? = nil
        )
        {
            self.count = count
            self.severity = severity
            self.threatName = threatName
        }
    }

}

extension GuardDutyClientTypes.HostPath: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case path = "path"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let path = self.path {
            try encodeContainer.encode(path, forKey: .path)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .path)
        path = pathDecoded
    }
}

extension GuardDutyClientTypes {
    /// Represents a pre-existing file or directory on the host machine that the volume maps to.
    public struct HostPath: Swift.Equatable {
        /// Path of the file or directory on the host that the volume maps to.
        public var path: Swift.String?

        public init(
            path: Swift.String? = nil
        )
        {
            self.path = path
        }
    }

}

extension GuardDutyClientTypes.IamInstanceProfile: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "arn"
        case id = "id"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
    }
}

extension GuardDutyClientTypes {
    /// Contains information about the EC2 instance profile.
    public struct IamInstanceProfile: Swift.Equatable {
        /// The profile ARN of the EC2 instance.
        public var arn: Swift.String?
        /// The profile ID of the EC2 instance.
        public var id: Swift.String?

        public init(
            arn: Swift.String? = nil,
            id: Swift.String? = nil
        )
        {
            self.arn = arn
            self.id = id
        }
    }

}

extension GuardDutyClientTypes.InstanceDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case availabilityZone = "availabilityZone"
        case iamInstanceProfile = "iamInstanceProfile"
        case imageDescription = "imageDescription"
        case imageId = "imageId"
        case instanceId = "instanceId"
        case instanceState = "instanceState"
        case instanceType = "instanceType"
        case launchTime = "launchTime"
        case networkInterfaces = "networkInterfaces"
        case outpostArn = "outpostArn"
        case platform = "platform"
        case productCodes = "productCodes"
        case tags = "tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let availabilityZone = self.availabilityZone {
            try encodeContainer.encode(availabilityZone, forKey: .availabilityZone)
        }
        if let iamInstanceProfile = self.iamInstanceProfile {
            try encodeContainer.encode(iamInstanceProfile, forKey: .iamInstanceProfile)
        }
        if let imageDescription = self.imageDescription {
            try encodeContainer.encode(imageDescription, forKey: .imageDescription)
        }
        if let imageId = self.imageId {
            try encodeContainer.encode(imageId, forKey: .imageId)
        }
        if let instanceId = self.instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if let instanceState = self.instanceState {
            try encodeContainer.encode(instanceState, forKey: .instanceState)
        }
        if let instanceType = self.instanceType {
            try encodeContainer.encode(instanceType, forKey: .instanceType)
        }
        if let launchTime = self.launchTime {
            try encodeContainer.encode(launchTime, forKey: .launchTime)
        }
        if let networkInterfaces = networkInterfaces {
            var networkInterfacesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .networkInterfaces)
            for networkinterface0 in networkInterfaces {
                try networkInterfacesContainer.encode(networkinterface0)
            }
        }
        if let outpostArn = self.outpostArn {
            try encodeContainer.encode(outpostArn, forKey: .outpostArn)
        }
        if let platform = self.platform {
            try encodeContainer.encode(platform, forKey: .platform)
        }
        if let productCodes = productCodes {
            var productCodesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .productCodes)
            for productcode0 in productCodes {
                try productCodesContainer.encode(productcode0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let availabilityZoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .availabilityZone)
        availabilityZone = availabilityZoneDecoded
        let iamInstanceProfileDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.IamInstanceProfile.self, forKey: .iamInstanceProfile)
        iamInstanceProfile = iamInstanceProfileDecoded
        let imageDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageDescription)
        imageDescription = imageDescriptionDecoded
        let imageIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageId)
        imageId = imageIdDecoded
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let instanceStateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceState)
        instanceState = instanceStateDecoded
        let instanceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceType)
        instanceType = instanceTypeDecoded
        let outpostArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .outpostArn)
        outpostArn = outpostArnDecoded
        let launchTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .launchTime)
        launchTime = launchTimeDecoded
        let networkInterfacesContainer = try containerValues.decodeIfPresent([GuardDutyClientTypes.NetworkInterface?].self, forKey: .networkInterfaces)
        var networkInterfacesDecoded0:[GuardDutyClientTypes.NetworkInterface]? = nil
        if let networkInterfacesContainer = networkInterfacesContainer {
            networkInterfacesDecoded0 = [GuardDutyClientTypes.NetworkInterface]()
            for structure0 in networkInterfacesContainer {
                if let structure0 = structure0 {
                    networkInterfacesDecoded0?.append(structure0)
                }
            }
        }
        networkInterfaces = networkInterfacesDecoded0
        let platformDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .platform)
        platform = platformDecoded
        let productCodesContainer = try containerValues.decodeIfPresent([GuardDutyClientTypes.ProductCode?].self, forKey: .productCodes)
        var productCodesDecoded0:[GuardDutyClientTypes.ProductCode]? = nil
        if let productCodesContainer = productCodesContainer {
            productCodesDecoded0 = [GuardDutyClientTypes.ProductCode]()
            for structure0 in productCodesContainer {
                if let structure0 = structure0 {
                    productCodesDecoded0?.append(structure0)
                }
            }
        }
        productCodes = productCodesDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([GuardDutyClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[GuardDutyClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [GuardDutyClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension GuardDutyClientTypes {
    /// Contains information about the details of an instance.
    public struct InstanceDetails: Swift.Equatable {
        /// The Availability Zone of the EC2 instance.
        public var availabilityZone: Swift.String?
        /// The profile information of the EC2 instance.
        public var iamInstanceProfile: GuardDutyClientTypes.IamInstanceProfile?
        /// The image description of the EC2 instance.
        public var imageDescription: Swift.String?
        /// The image ID of the EC2 instance.
        public var imageId: Swift.String?
        /// The ID of the EC2 instance.
        public var instanceId: Swift.String?
        /// The state of the EC2 instance.
        public var instanceState: Swift.String?
        /// The type of the EC2 instance.
        public var instanceType: Swift.String?
        /// The launch time of the EC2 instance.
        public var launchTime: Swift.String?
        /// The elastic network interface information of the EC2 instance.
        public var networkInterfaces: [GuardDutyClientTypes.NetworkInterface]?
        /// The Amazon Resource Name (ARN) of the Amazon Web Services Outpost. Only applicable to Amazon Web Services Outposts instances.
        public var outpostArn: Swift.String?
        /// The platform of the EC2 instance.
        public var platform: Swift.String?
        /// The product code of the EC2 instance.
        public var productCodes: [GuardDutyClientTypes.ProductCode]?
        /// The tags of the EC2 instance.
        public var tags: [GuardDutyClientTypes.Tag]?

        public init(
            availabilityZone: Swift.String? = nil,
            iamInstanceProfile: GuardDutyClientTypes.IamInstanceProfile? = nil,
            imageDescription: Swift.String? = nil,
            imageId: Swift.String? = nil,
            instanceId: Swift.String? = nil,
            instanceState: Swift.String? = nil,
            instanceType: Swift.String? = nil,
            launchTime: Swift.String? = nil,
            networkInterfaces: [GuardDutyClientTypes.NetworkInterface]? = nil,
            outpostArn: Swift.String? = nil,
            platform: Swift.String? = nil,
            productCodes: [GuardDutyClientTypes.ProductCode]? = nil,
            tags: [GuardDutyClientTypes.Tag]? = nil
        )
        {
            self.availabilityZone = availabilityZone
            self.iamInstanceProfile = iamInstanceProfile
            self.imageDescription = imageDescription
            self.imageId = imageId
            self.instanceId = instanceId
            self.instanceState = instanceState
            self.instanceType = instanceType
            self.launchTime = launchTime
            self.networkInterfaces = networkInterfaces
            self.outpostArn = outpostArn
            self.platform = platform
            self.productCodes = productCodes
            self.tags = tags
        }
    }

}

extension InternalServerErrorException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InternalServerErrorExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.type = output.type
        } else {
            self.properties.message = nil
            self.properties.type = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// An internal server error exception object.
public struct InternalServerErrorException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The error message.
        public internal(set) var message: Swift.String? = nil
        /// The error type.
        public internal(set) var type: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerErrorException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.type = type
    }
}

struct InternalServerErrorExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let type: Swift.String?
}

extension InternalServerErrorExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "message"
        case type = "__type"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
    }
}

extension GuardDutyClientTypes.Invitation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "accountId"
        case invitationId = "invitationId"
        case invitedAt = "invitedAt"
        case relationshipStatus = "relationshipStatus"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let invitationId = self.invitationId {
            try encodeContainer.encode(invitationId, forKey: .invitationId)
        }
        if let invitedAt = self.invitedAt {
            try encodeContainer.encode(invitedAt, forKey: .invitedAt)
        }
        if let relationshipStatus = self.relationshipStatus {
            try encodeContainer.encode(relationshipStatus, forKey: .relationshipStatus)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let invitationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .invitationId)
        invitationId = invitationIdDecoded
        let relationshipStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .relationshipStatus)
        relationshipStatus = relationshipStatusDecoded
        let invitedAtDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .invitedAt)
        invitedAt = invitedAtDecoded
    }
}

extension GuardDutyClientTypes {
    /// Contains information about the invitation to become a member account.
    public struct Invitation: Swift.Equatable {
        /// The ID of the account that the invitation was sent from.
        public var accountId: Swift.String?
        /// The ID of the invitation. This value is used to validate the inviter account to the member account.
        public var invitationId: Swift.String?
        /// The timestamp when the invitation was sent.
        public var invitedAt: Swift.String?
        /// The status of the relationship between the inviter and invitee accounts.
        public var relationshipStatus: Swift.String?

        public init(
            accountId: Swift.String? = nil,
            invitationId: Swift.String? = nil,
            invitedAt: Swift.String? = nil,
            relationshipStatus: Swift.String? = nil
        )
        {
            self.accountId = accountId
            self.invitationId = invitationId
            self.invitedAt = invitedAt
            self.relationshipStatus = relationshipStatus
        }
    }

}

extension InviteMembersInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountIds = "accountIds"
        case disableEmailNotification = "disableEmailNotification"
        case message = "message"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountIds = accountIds {
            var accountIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accountIds)
            for accountid0 in accountIds {
                try accountIdsContainer.encode(accountid0)
            }
        }
        if let disableEmailNotification = self.disableEmailNotification {
            try encodeContainer.encode(disableEmailNotification, forKey: .disableEmailNotification)
        }
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }
}

extension InviteMembersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let detectorId = detectorId else {
            return nil
        }
        return "/detector/\(detectorId.urlPercentEncoding())/member/invite"
    }
}

public struct InviteMembersInput: Swift.Equatable {
    /// A list of account IDs of the accounts that you want to invite to GuardDuty as members.
    /// This member is required.
    public var accountIds: [Swift.String]?
    /// The unique ID of the detector of the GuardDuty account that you want to invite members with.
    /// This member is required.
    public var detectorId: Swift.String?
    /// A Boolean value that specifies whether you want to disable email notification to the accounts that you are inviting to GuardDuty as members.
    public var disableEmailNotification: Swift.Bool?
    /// The invitation message that you want to send to the accounts that you're inviting to GuardDuty as members.
    public var message: Swift.String?

    public init(
        accountIds: [Swift.String]? = nil,
        detectorId: Swift.String? = nil,
        disableEmailNotification: Swift.Bool? = nil,
        message: Swift.String? = nil
    )
    {
        self.accountIds = accountIds
        self.detectorId = detectorId
        self.disableEmailNotification = disableEmailNotification
        self.message = message
    }
}

struct InviteMembersInputBody: Swift.Equatable {
    let accountIds: [Swift.String]?
    let disableEmailNotification: Swift.Bool?
    let message: Swift.String?
}

extension InviteMembersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountIds = "accountIds"
        case disableEmailNotification = "disableEmailNotification"
        case message = "message"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .accountIds)
        var accountIdsDecoded0:[Swift.String]? = nil
        if let accountIdsContainer = accountIdsContainer {
            accountIdsDecoded0 = [Swift.String]()
            for string0 in accountIdsContainer {
                if let string0 = string0 {
                    accountIdsDecoded0?.append(string0)
                }
            }
        }
        accountIds = accountIdsDecoded0
        let disableEmailNotificationDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .disableEmailNotification)
        disableEmailNotification = disableEmailNotificationDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InviteMembersOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InviteMembersOutputBody = try responseDecoder.decode(responseBody: data)
            self.unprocessedAccounts = output.unprocessedAccounts
        } else {
            self.unprocessedAccounts = nil
        }
    }
}

public struct InviteMembersOutput: Swift.Equatable {
    /// A list of objects that contain the unprocessed account and a result string that explains why it was unprocessed.
    /// This member is required.
    public var unprocessedAccounts: [GuardDutyClientTypes.UnprocessedAccount]?

    public init(
        unprocessedAccounts: [GuardDutyClientTypes.UnprocessedAccount]? = nil
    )
    {
        self.unprocessedAccounts = unprocessedAccounts
    }
}

struct InviteMembersOutputBody: Swift.Equatable {
    let unprocessedAccounts: [GuardDutyClientTypes.UnprocessedAccount]?
}

extension InviteMembersOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case unprocessedAccounts = "unprocessedAccounts"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let unprocessedAccountsContainer = try containerValues.decodeIfPresent([GuardDutyClientTypes.UnprocessedAccount?].self, forKey: .unprocessedAccounts)
        var unprocessedAccountsDecoded0:[GuardDutyClientTypes.UnprocessedAccount]? = nil
        if let unprocessedAccountsContainer = unprocessedAccountsContainer {
            unprocessedAccountsDecoded0 = [GuardDutyClientTypes.UnprocessedAccount]()
            for structure0 in unprocessedAccountsContainer {
                if let structure0 = structure0 {
                    unprocessedAccountsDecoded0?.append(structure0)
                }
            }
        }
        unprocessedAccounts = unprocessedAccountsDecoded0
    }
}

enum InviteMembersOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GuardDutyClientTypes {
    public enum IpSetFormat: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case alienVault
        case fireEye
        case otxCsv
        case proofPoint
        case stix
        case txt
        case sdkUnknown(Swift.String)

        public static var allCases: [IpSetFormat] {
            return [
                .alienVault,
                .fireEye,
                .otxCsv,
                .proofPoint,
                .stix,
                .txt,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .alienVault: return "ALIEN_VAULT"
            case .fireEye: return "FIRE_EYE"
            case .otxCsv: return "OTX_CSV"
            case .proofPoint: return "PROOF_POINT"
            case .stix: return "STIX"
            case .txt: return "TXT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = IpSetFormat(rawValue: rawValue) ?? IpSetFormat.sdkUnknown(rawValue)
        }
    }
}

extension GuardDutyClientTypes {
    public enum IpSetStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case activating
        case active
        case deactivating
        case deleted
        case deletePending
        case error
        case inactive
        case sdkUnknown(Swift.String)

        public static var allCases: [IpSetStatus] {
            return [
                .activating,
                .active,
                .deactivating,
                .deleted,
                .deletePending,
                .error,
                .inactive,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .activating: return "ACTIVATING"
            case .active: return "ACTIVE"
            case .deactivating: return "DEACTIVATING"
            case .deleted: return "DELETED"
            case .deletePending: return "DELETE_PENDING"
            case .error: return "ERROR"
            case .inactive: return "INACTIVE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = IpSetStatus(rawValue: rawValue) ?? IpSetStatus.sdkUnknown(rawValue)
        }
    }
}

extension GuardDutyClientTypes.KubernetesApiCallAction: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case parameters = "parameters"
        case remoteIpDetails = "remoteIpDetails"
        case requestUri = "requestUri"
        case sourceIps = "sourceIps"
        case statusCode = "statusCode"
        case userAgent = "userAgent"
        case verb = "verb"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let parameters = self.parameters {
            try encodeContainer.encode(parameters, forKey: .parameters)
        }
        if let remoteIpDetails = self.remoteIpDetails {
            try encodeContainer.encode(remoteIpDetails, forKey: .remoteIpDetails)
        }
        if let requestUri = self.requestUri {
            try encodeContainer.encode(requestUri, forKey: .requestUri)
        }
        if let sourceIps = sourceIps {
            var sourceIpsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sourceIps)
            for string0 in sourceIps {
                try sourceIpsContainer.encode(string0)
            }
        }
        if statusCode != 0 {
            try encodeContainer.encode(statusCode, forKey: .statusCode)
        }
        if let userAgent = self.userAgent {
            try encodeContainer.encode(userAgent, forKey: .userAgent)
        }
        if let verb = self.verb {
            try encodeContainer.encode(verb, forKey: .verb)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestUriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestUri)
        requestUri = requestUriDecoded
        let verbDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .verb)
        verb = verbDecoded
        let sourceIpsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .sourceIps)
        var sourceIpsDecoded0:[Swift.String]? = nil
        if let sourceIpsContainer = sourceIpsContainer {
            sourceIpsDecoded0 = [Swift.String]()
            for string0 in sourceIpsContainer {
                if let string0 = string0 {
                    sourceIpsDecoded0?.append(string0)
                }
            }
        }
        sourceIps = sourceIpsDecoded0
        let userAgentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userAgent)
        userAgent = userAgentDecoded
        let remoteIpDetailsDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.RemoteIpDetails.self, forKey: .remoteIpDetails)
        remoteIpDetails = remoteIpDetailsDecoded
        let statusCodeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .statusCode) ?? 0
        statusCode = statusCodeDecoded
        let parametersDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parameters)
        parameters = parametersDecoded
    }
}

extension GuardDutyClientTypes {
    /// Information about the Kubernetes API call action described in this finding.
    public struct KubernetesApiCallAction: Swift.Equatable {
        /// Parameters related to the Kubernetes API call action.
        public var parameters: Swift.String?
        /// Contains information about the remote IP address of the connection.
        public var remoteIpDetails: GuardDutyClientTypes.RemoteIpDetails?
        /// The Kubernetes API request URI.
        public var requestUri: Swift.String?
        /// The IP of the Kubernetes API caller and the IPs of any proxies or load balancers between the caller and the API endpoint.
        public var sourceIps: [Swift.String]?
        /// The resulting HTTP response code of the Kubernetes API call action.
        public var statusCode: Swift.Int
        /// The user agent of the caller of the Kubernetes API.
        public var userAgent: Swift.String?
        /// The Kubernetes API request HTTP verb.
        public var verb: Swift.String?

        public init(
            parameters: Swift.String? = nil,
            remoteIpDetails: GuardDutyClientTypes.RemoteIpDetails? = nil,
            requestUri: Swift.String? = nil,
            sourceIps: [Swift.String]? = nil,
            statusCode: Swift.Int = 0,
            userAgent: Swift.String? = nil,
            verb: Swift.String? = nil
        )
        {
            self.parameters = parameters
            self.remoteIpDetails = remoteIpDetails
            self.requestUri = requestUri
            self.sourceIps = sourceIps
            self.statusCode = statusCode
            self.userAgent = userAgent
            self.verb = verb
        }
    }

}

extension GuardDutyClientTypes.KubernetesAuditLogsConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enable = "enable"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if enable != false {
            try encodeContainer.encode(enable, forKey: .enable)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enableDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enable) ?? false
        enable = enableDecoded
    }
}

extension GuardDutyClientTypes {
    /// Describes whether Kubernetes audit logs are enabled as a data source.
    public struct KubernetesAuditLogsConfiguration: Swift.Equatable {
        /// The status of Kubernetes audit logs as a data source.
        /// This member is required.
        public var enable: Swift.Bool

        public init(
            enable: Swift.Bool = false
        )
        {
            self.enable = enable
        }
    }

}

extension GuardDutyClientTypes.KubernetesAuditLogsConfigurationResult: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status = "status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.DataSourceStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension GuardDutyClientTypes {
    /// Describes whether Kubernetes audit logs are enabled as a data source.
    public struct KubernetesAuditLogsConfigurationResult: Swift.Equatable {
        /// A value that describes whether Kubernetes audit logs are enabled as a data source.
        /// This member is required.
        public var status: GuardDutyClientTypes.DataSourceStatus?

        public init(
            status: GuardDutyClientTypes.DataSourceStatus? = nil
        )
        {
            self.status = status
        }
    }

}

extension GuardDutyClientTypes.KubernetesConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case auditLogs = "auditLogs"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let auditLogs = self.auditLogs {
            try encodeContainer.encode(auditLogs, forKey: .auditLogs)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let auditLogsDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.KubernetesAuditLogsConfiguration.self, forKey: .auditLogs)
        auditLogs = auditLogsDecoded
    }
}

extension GuardDutyClientTypes {
    /// Describes whether any Kubernetes data sources are enabled.
    public struct KubernetesConfiguration: Swift.Equatable {
        /// The status of Kubernetes audit logs as a data source.
        /// This member is required.
        public var auditLogs: GuardDutyClientTypes.KubernetesAuditLogsConfiguration?

        public init(
            auditLogs: GuardDutyClientTypes.KubernetesAuditLogsConfiguration? = nil
        )
        {
            self.auditLogs = auditLogs
        }
    }

}

extension GuardDutyClientTypes.KubernetesConfigurationResult: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case auditLogs = "auditLogs"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let auditLogs = self.auditLogs {
            try encodeContainer.encode(auditLogs, forKey: .auditLogs)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let auditLogsDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.KubernetesAuditLogsConfigurationResult.self, forKey: .auditLogs)
        auditLogs = auditLogsDecoded
    }
}

extension GuardDutyClientTypes {
    /// Describes whether any Kubernetes logs will be enabled as a data source.
    public struct KubernetesConfigurationResult: Swift.Equatable {
        /// Describes whether Kubernetes audit logs are enabled as a data source.
        /// This member is required.
        public var auditLogs: GuardDutyClientTypes.KubernetesAuditLogsConfigurationResult?

        public init(
            auditLogs: GuardDutyClientTypes.KubernetesAuditLogsConfigurationResult? = nil
        )
        {
            self.auditLogs = auditLogs
        }
    }

}

extension GuardDutyClientTypes.KubernetesDataSourceFreeTrial: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case auditLogs = "auditLogs"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let auditLogs = self.auditLogs {
            try encodeContainer.encode(auditLogs, forKey: .auditLogs)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let auditLogsDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.DataSourceFreeTrial.self, forKey: .auditLogs)
        auditLogs = auditLogsDecoded
    }
}

extension GuardDutyClientTypes {
    /// Provides details about the Kubernetes resources when it is enabled as a data source.
    public struct KubernetesDataSourceFreeTrial: Swift.Equatable {
        /// Describes whether Kubernetes audit logs are enabled as a data source.
        public var auditLogs: GuardDutyClientTypes.DataSourceFreeTrial?

        public init(
            auditLogs: GuardDutyClientTypes.DataSourceFreeTrial? = nil
        )
        {
            self.auditLogs = auditLogs
        }
    }

}

extension GuardDutyClientTypes.KubernetesDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case kubernetesUserDetails = "kubernetesUserDetails"
        case kubernetesWorkloadDetails = "kubernetesWorkloadDetails"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let kubernetesUserDetails = self.kubernetesUserDetails {
            try encodeContainer.encode(kubernetesUserDetails, forKey: .kubernetesUserDetails)
        }
        if let kubernetesWorkloadDetails = self.kubernetesWorkloadDetails {
            try encodeContainer.encode(kubernetesWorkloadDetails, forKey: .kubernetesWorkloadDetails)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let kubernetesUserDetailsDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.KubernetesUserDetails.self, forKey: .kubernetesUserDetails)
        kubernetesUserDetails = kubernetesUserDetailsDecoded
        let kubernetesWorkloadDetailsDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.KubernetesWorkloadDetails.self, forKey: .kubernetesWorkloadDetails)
        kubernetesWorkloadDetails = kubernetesWorkloadDetailsDecoded
    }
}

extension GuardDutyClientTypes {
    /// Details about Kubernetes resources such as a Kubernetes user or workload resource involved in a Kubernetes finding.
    public struct KubernetesDetails: Swift.Equatable {
        /// Details about the Kubernetes user involved in a Kubernetes finding.
        public var kubernetesUserDetails: GuardDutyClientTypes.KubernetesUserDetails?
        /// Details about the Kubernetes workload involved in a Kubernetes finding.
        public var kubernetesWorkloadDetails: GuardDutyClientTypes.KubernetesWorkloadDetails?

        public init(
            kubernetesUserDetails: GuardDutyClientTypes.KubernetesUserDetails? = nil,
            kubernetesWorkloadDetails: GuardDutyClientTypes.KubernetesWorkloadDetails? = nil
        )
        {
            self.kubernetesUserDetails = kubernetesUserDetails
            self.kubernetesWorkloadDetails = kubernetesWorkloadDetails
        }
    }

}

extension GuardDutyClientTypes.KubernetesUserDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groups = "groups"
        case sessionName = "sessionName"
        case uid = "uid"
        case username = "username"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let groups = groups {
            var groupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .groups)
            for string0 in groups {
                try groupsContainer.encode(string0)
            }
        }
        if let sessionName = sessionName {
            var sessionNameContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sessionName)
            for string0 in sessionName {
                try sessionNameContainer.encode(string0)
            }
        }
        if let uid = self.uid {
            try encodeContainer.encode(uid, forKey: .uid)
        }
        if let username = self.username {
            try encodeContainer.encode(username, forKey: .username)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let usernameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .username)
        username = usernameDecoded
        let uidDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .uid)
        uid = uidDecoded
        let groupsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .groups)
        var groupsDecoded0:[Swift.String]? = nil
        if let groupsContainer = groupsContainer {
            groupsDecoded0 = [Swift.String]()
            for string0 in groupsContainer {
                if let string0 = string0 {
                    groupsDecoded0?.append(string0)
                }
            }
        }
        groups = groupsDecoded0
        let sessionNameContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .sessionName)
        var sessionNameDecoded0:[Swift.String]? = nil
        if let sessionNameContainer = sessionNameContainer {
            sessionNameDecoded0 = [Swift.String]()
            for string0 in sessionNameContainer {
                if let string0 = string0 {
                    sessionNameDecoded0?.append(string0)
                }
            }
        }
        sessionName = sessionNameDecoded0
    }
}

extension GuardDutyClientTypes {
    /// Details about the Kubernetes user involved in a Kubernetes finding.
    public struct KubernetesUserDetails: Swift.Equatable {
        /// The groups that include the user who called the Kubernetes API.
        public var groups: [Swift.String]?
        /// Entity that assumes the IAM role when Kubernetes RBAC permissions are assigned to that role.
        public var sessionName: [Swift.String]?
        /// The user ID of the user who called the Kubernetes API.
        public var uid: Swift.String?
        /// The username of the user who called the Kubernetes API.
        public var username: Swift.String?

        public init(
            groups: [Swift.String]? = nil,
            sessionName: [Swift.String]? = nil,
            uid: Swift.String? = nil,
            username: Swift.String? = nil
        )
        {
            self.groups = groups
            self.sessionName = sessionName
            self.uid = uid
            self.username = username
        }
    }

}

extension GuardDutyClientTypes.KubernetesWorkloadDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case containers = "containers"
        case hostNetwork = "hostNetwork"
        case name = "name"
        case namespace = "namespace"
        case type = "type"
        case uid = "uid"
        case volumes = "volumes"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let containers = containers {
            var containersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .containers)
            for container0 in containers {
                try containersContainer.encode(container0)
            }
        }
        if hostNetwork != false {
            try encodeContainer.encode(hostNetwork, forKey: .hostNetwork)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let namespace = self.namespace {
            try encodeContainer.encode(namespace, forKey: .namespace)
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
        if let uid = self.uid {
            try encodeContainer.encode(uid, forKey: .uid)
        }
        if let volumes = volumes {
            var volumesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .volumes)
            for volume0 in volumes {
                try volumesContainer.encode(volume0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let uidDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .uid)
        uid = uidDecoded
        let namespaceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namespace)
        namespace = namespaceDecoded
        let hostNetworkDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .hostNetwork) ?? false
        hostNetwork = hostNetworkDecoded
        let containersContainer = try containerValues.decodeIfPresent([GuardDutyClientTypes.Container?].self, forKey: .containers)
        var containersDecoded0:[GuardDutyClientTypes.Container]? = nil
        if let containersContainer = containersContainer {
            containersDecoded0 = [GuardDutyClientTypes.Container]()
            for structure0 in containersContainer {
                if let structure0 = structure0 {
                    containersDecoded0?.append(structure0)
                }
            }
        }
        containers = containersDecoded0
        let volumesContainer = try containerValues.decodeIfPresent([GuardDutyClientTypes.Volume?].self, forKey: .volumes)
        var volumesDecoded0:[GuardDutyClientTypes.Volume]? = nil
        if let volumesContainer = volumesContainer {
            volumesDecoded0 = [GuardDutyClientTypes.Volume]()
            for structure0 in volumesContainer {
                if let structure0 = structure0 {
                    volumesDecoded0?.append(structure0)
                }
            }
        }
        volumes = volumesDecoded0
    }
}

extension GuardDutyClientTypes {
    /// Details about the Kubernetes workload involved in a Kubernetes finding.
    public struct KubernetesWorkloadDetails: Swift.Equatable {
        /// Containers running as part of the Kubernetes workload.
        public var containers: [GuardDutyClientTypes.Container]?
        /// Whether the hostNetwork flag is enabled for the pods included in the workload.
        public var hostNetwork: Swift.Bool
        /// Kubernetes workload name.
        public var name: Swift.String?
        /// Kubernetes namespace that the workload is part of.
        public var namespace: Swift.String?
        /// Kubernetes workload type (e.g. Pod, Deployment, etc.).
        public var type: Swift.String?
        /// Kubernetes workload ID.
        public var uid: Swift.String?
        /// Volumes used by the Kubernetes workload.
        public var volumes: [GuardDutyClientTypes.Volume]?

        public init(
            containers: [GuardDutyClientTypes.Container]? = nil,
            hostNetwork: Swift.Bool = false,
            name: Swift.String? = nil,
            namespace: Swift.String? = nil,
            type: Swift.String? = nil,
            uid: Swift.String? = nil,
            volumes: [GuardDutyClientTypes.Volume]? = nil
        )
        {
            self.containers = containers
            self.hostNetwork = hostNetwork
            self.name = name
            self.namespace = namespace
            self.type = type
            self.uid = uid
            self.volumes = volumes
        }
    }

}

extension GuardDutyClientTypes.LambdaDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "description"
        case functionArn = "functionArn"
        case functionName = "functionName"
        case functionVersion = "functionVersion"
        case lastModifiedAt = "lastModifiedAt"
        case revisionId = "revisionId"
        case role = "role"
        case tags = "tags"
        case vpcConfig = "vpcConfig"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let functionArn = self.functionArn {
            try encodeContainer.encode(functionArn, forKey: .functionArn)
        }
        if let functionName = self.functionName {
            try encodeContainer.encode(functionName, forKey: .functionName)
        }
        if let functionVersion = self.functionVersion {
            try encodeContainer.encode(functionVersion, forKey: .functionVersion)
        }
        if let lastModifiedAt = self.lastModifiedAt {
            try encodeContainer.encodeTimestamp(lastModifiedAt, format: .epochSeconds, forKey: .lastModifiedAt)
        }
        if let revisionId = self.revisionId {
            try encodeContainer.encode(revisionId, forKey: .revisionId)
        }
        if let role = self.role {
            try encodeContainer.encode(role, forKey: .role)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let vpcConfig = self.vpcConfig {
            try encodeContainer.encode(vpcConfig, forKey: .vpcConfig)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let functionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .functionArn)
        functionArn = functionArnDecoded
        let functionNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .functionName)
        functionName = functionNameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let lastModifiedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastModifiedAt)
        lastModifiedAt = lastModifiedAtDecoded
        let revisionIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .revisionId)
        revisionId = revisionIdDecoded
        let functionVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .functionVersion)
        functionVersion = functionVersionDecoded
        let roleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .role)
        role = roleDecoded
        let vpcConfigDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.VpcConfig.self, forKey: .vpcConfig)
        vpcConfig = vpcConfigDecoded
        let tagsContainer = try containerValues.decodeIfPresent([GuardDutyClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[GuardDutyClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [GuardDutyClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension GuardDutyClientTypes {
    /// Information about the Lambda function involved in the finding.
    public struct LambdaDetails: Swift.Equatable {
        /// Description of the Lambda function.
        public var description: Swift.String?
        /// Amazon Resource Name (ARN) of the Lambda function.
        public var functionArn: Swift.String?
        /// Name of the Lambda function.
        public var functionName: Swift.String?
        /// The version of the Lambda function.
        public var functionVersion: Swift.String?
        /// The timestamp when the Lambda function was last modified. This field is in the UTC date string format (2023-03-22T19:37:20.168Z).
        public var lastModifiedAt: ClientRuntime.Date?
        /// The revision ID of the Lambda function version.
        public var revisionId: Swift.String?
        /// The execution role of the Lambda function.
        public var role: Swift.String?
        /// A list of tags attached to this resource, listed in the format of key:value pair.
        public var tags: [GuardDutyClientTypes.Tag]?
        /// Amazon Virtual Private Cloud configuration details associated with your Lambda function.
        public var vpcConfig: GuardDutyClientTypes.VpcConfig?

        public init(
            description: Swift.String? = nil,
            functionArn: Swift.String? = nil,
            functionName: Swift.String? = nil,
            functionVersion: Swift.String? = nil,
            lastModifiedAt: ClientRuntime.Date? = nil,
            revisionId: Swift.String? = nil,
            role: Swift.String? = nil,
            tags: [GuardDutyClientTypes.Tag]? = nil,
            vpcConfig: GuardDutyClientTypes.VpcConfig? = nil
        )
        {
            self.description = description
            self.functionArn = functionArn
            self.functionName = functionName
            self.functionVersion = functionVersion
            self.lastModifiedAt = lastModifiedAt
            self.revisionId = revisionId
            self.role = role
            self.tags = tags
            self.vpcConfig = vpcConfig
        }
    }

}

extension GuardDutyClientTypes.LineageObject: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case euid = "euid"
        case executablePath = "executablePath"
        case name = "name"
        case namespacePid = "namespacePid"
        case parentUuid = "parentUuid"
        case pid = "pid"
        case startTime = "startTime"
        case userId = "userId"
        case uuid = "uuid"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if euid != 0 {
            try encodeContainer.encode(euid, forKey: .euid)
        }
        if let executablePath = self.executablePath {
            try encodeContainer.encode(executablePath, forKey: .executablePath)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if namespacePid != 0 {
            try encodeContainer.encode(namespacePid, forKey: .namespacePid)
        }
        if let parentUuid = self.parentUuid {
            try encodeContainer.encode(parentUuid, forKey: .parentUuid)
        }
        if pid != 0 {
            try encodeContainer.encode(pid, forKey: .pid)
        }
        if let startTime = self.startTime {
            try encodeContainer.encodeTimestamp(startTime, format: .epochSeconds, forKey: .startTime)
        }
        if userId != 0 {
            try encodeContainer.encode(userId, forKey: .userId)
        }
        if let uuid = self.uuid {
            try encodeContainer.encode(uuid, forKey: .uuid)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startTime)
        startTime = startTimeDecoded
        let namespacePidDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .namespacePid) ?? 0
        namespacePid = namespacePidDecoded
        let userIdDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .userId) ?? 0
        userId = userIdDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let pidDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .pid) ?? 0
        pid = pidDecoded
        let uuidDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .uuid)
        uuid = uuidDecoded
        let executablePathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .executablePath)
        executablePath = executablePathDecoded
        let euidDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .euid) ?? 0
        euid = euidDecoded
        let parentUuidDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parentUuid)
        parentUuid = parentUuidDecoded
    }
}

extension GuardDutyClientTypes {
    /// Information about the runtime process details.
    public struct LineageObject: Swift.Equatable {
        /// The effective user ID that was used to execute the process.
        public var euid: Swift.Int
        /// The absolute path of the process executable file.
        public var executablePath: Swift.String?
        /// The name of the process.
        public var name: Swift.String?
        /// The process ID of the child process.
        public var namespacePid: Swift.Int
        /// The unique ID of the parent process. This ID is assigned to the parent process by GuardDuty.
        public var parentUuid: Swift.String?
        /// The ID of the process.
        public var pid: Swift.Int
        /// The time when the process started. This is in UTC format.
        public var startTime: ClientRuntime.Date?
        /// The user ID of the user that executed the process.
        public var userId: Swift.Int
        /// The unique ID assigned to the process by GuardDuty.
        public var uuid: Swift.String?

        public init(
            euid: Swift.Int = 0,
            executablePath: Swift.String? = nil,
            name: Swift.String? = nil,
            namespacePid: Swift.Int = 0,
            parentUuid: Swift.String? = nil,
            pid: Swift.Int = 0,
            startTime: ClientRuntime.Date? = nil,
            userId: Swift.Int = 0,
            uuid: Swift.String? = nil
        )
        {
            self.euid = euid
            self.executablePath = executablePath
            self.name = name
            self.namespacePid = namespacePid
            self.parentUuid = parentUuid
            self.pid = pid
            self.startTime = startTime
            self.userId = userId
            self.uuid = uuid
        }
    }

}

extension ListCoverageInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filterCriteria = "filterCriteria"
        case maxResults = "maxResults"
        case nextToken = "nextToken"
        case sortCriteria = "sortCriteria"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filterCriteria = self.filterCriteria {
            try encodeContainer.encode(filterCriteria, forKey: .filterCriteria)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let sortCriteria = self.sortCriteria {
            try encodeContainer.encode(sortCriteria, forKey: .sortCriteria)
        }
    }
}

extension ListCoverageInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let detectorId = detectorId else {
            return nil
        }
        return "/detector/\(detectorId.urlPercentEncoding())/coverage"
    }
}

public struct ListCoverageInput: Swift.Equatable {
    /// The unique ID of the detector whose coverage details you want to retrieve.
    /// This member is required.
    public var detectorId: Swift.String?
    /// Represents the criteria used to filter the coverage details.
    public var filterCriteria: GuardDutyClientTypes.CoverageFilterCriteria?
    /// The maximum number of results to return in the response.
    public var maxResults: Swift.Int?
    /// A token to use for paginating results that are returned in the response. Set the value of this parameter to null for the first request to a list action. For subsequent calls, use the NextToken value returned from the previous request to continue listing results after the first page.
    public var nextToken: Swift.String?
    /// Represents the criteria used to sort the coverage details.
    public var sortCriteria: GuardDutyClientTypes.CoverageSortCriteria?

    public init(
        detectorId: Swift.String? = nil,
        filterCriteria: GuardDutyClientTypes.CoverageFilterCriteria? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        sortCriteria: GuardDutyClientTypes.CoverageSortCriteria? = nil
    )
    {
        self.detectorId = detectorId
        self.filterCriteria = filterCriteria
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sortCriteria = sortCriteria
    }
}

struct ListCoverageInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
    let filterCriteria: GuardDutyClientTypes.CoverageFilterCriteria?
    let sortCriteria: GuardDutyClientTypes.CoverageSortCriteria?
}

extension ListCoverageInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filterCriteria = "filterCriteria"
        case maxResults = "maxResults"
        case nextToken = "nextToken"
        case sortCriteria = "sortCriteria"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let filterCriteriaDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.CoverageFilterCriteria.self, forKey: .filterCriteria)
        filterCriteria = filterCriteriaDecoded
        let sortCriteriaDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.CoverageSortCriteria.self, forKey: .sortCriteria)
        sortCriteria = sortCriteriaDecoded
    }
}

extension ListCoverageOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListCoverageOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.resources = output.resources
        } else {
            self.nextToken = nil
            self.resources = nil
        }
    }
}

public struct ListCoverageOutput: Swift.Equatable {
    /// The pagination parameter to be used on the next list operation to retrieve more items.
    public var nextToken: Swift.String?
    /// A list of resources and their attributes providing cluster details.
    /// This member is required.
    public var resources: [GuardDutyClientTypes.CoverageResource]?

    public init(
        nextToken: Swift.String? = nil,
        resources: [GuardDutyClientTypes.CoverageResource]? = nil
    )
    {
        self.nextToken = nextToken
        self.resources = resources
    }
}

struct ListCoverageOutputBody: Swift.Equatable {
    let resources: [GuardDutyClientTypes.CoverageResource]?
    let nextToken: Swift.String?
}

extension ListCoverageOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "nextToken"
        case resources = "resources"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourcesContainer = try containerValues.decodeIfPresent([GuardDutyClientTypes.CoverageResource?].self, forKey: .resources)
        var resourcesDecoded0:[GuardDutyClientTypes.CoverageResource]? = nil
        if let resourcesContainer = resourcesContainer {
            resourcesDecoded0 = [GuardDutyClientTypes.CoverageResource]()
            for structure0 in resourcesContainer {
                if let structure0 = structure0 {
                    resourcesDecoded0?.append(structure0)
                }
            }
        }
        resources = resourcesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListCoverageOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListDetectorsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListDetectorsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/detector"
    }
}

public struct ListDetectorsInput: Swift.Equatable {
    /// You can use this parameter to indicate the maximum number of items that you want in the response. The default value is 50. The maximum value is 50.
    public var maxResults: Swift.Int?
    /// You can use this parameter when paginating results. Set the value of this parameter to null on your first call to the list action. For subsequent calls to the action, fill nextToken in the request with the value of NextToken from the previous response to continue listing data.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListDetectorsInputBody: Swift.Equatable {
}

extension ListDetectorsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListDetectorsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListDetectorsOutputBody = try responseDecoder.decode(responseBody: data)
            self.detectorIds = output.detectorIds
            self.nextToken = output.nextToken
        } else {
            self.detectorIds = nil
            self.nextToken = nil
        }
    }
}

public struct ListDetectorsOutput: Swift.Equatable {
    /// A list of detector IDs.
    /// This member is required.
    public var detectorIds: [Swift.String]?
    /// The pagination parameter to be used on the next list operation to retrieve more items.
    public var nextToken: Swift.String?

    public init(
        detectorIds: [Swift.String]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.detectorIds = detectorIds
        self.nextToken = nextToken
    }
}

struct ListDetectorsOutputBody: Swift.Equatable {
    let detectorIds: [Swift.String]?
    let nextToken: Swift.String?
}

extension ListDetectorsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case detectorIds = "detectorIds"
        case nextToken = "nextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detectorIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .detectorIds)
        var detectorIdsDecoded0:[Swift.String]? = nil
        if let detectorIdsContainer = detectorIdsContainer {
            detectorIdsDecoded0 = [Swift.String]()
            for string0 in detectorIdsContainer {
                if let string0 = string0 {
                    detectorIdsDecoded0?.append(string0)
                }
            }
        }
        detectorIds = detectorIdsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListDetectorsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListFiltersInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListFiltersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let detectorId = detectorId else {
            return nil
        }
        return "/detector/\(detectorId.urlPercentEncoding())/filter"
    }
}

public struct ListFiltersInput: Swift.Equatable {
    /// The unique ID of the detector that the filter is associated with.
    /// This member is required.
    public var detectorId: Swift.String?
    /// You can use this parameter to indicate the maximum number of items that you want in the response. The default value is 50. The maximum value is 50.
    public var maxResults: Swift.Int?
    /// You can use this parameter when paginating results. Set the value of this parameter to null on your first call to the list action. For subsequent calls to the action, fill nextToken in the request with the value of NextToken from the previous response to continue listing data.
    public var nextToken: Swift.String?

    public init(
        detectorId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.detectorId = detectorId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListFiltersInputBody: Swift.Equatable {
}

extension ListFiltersInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListFiltersOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListFiltersOutputBody = try responseDecoder.decode(responseBody: data)
            self.filterNames = output.filterNames
            self.nextToken = output.nextToken
        } else {
            self.filterNames = nil
            self.nextToken = nil
        }
    }
}

public struct ListFiltersOutput: Swift.Equatable {
    /// A list of filter names.
    /// This member is required.
    public var filterNames: [Swift.String]?
    /// The pagination parameter to be used on the next list operation to retrieve more items.
    public var nextToken: Swift.String?

    public init(
        filterNames: [Swift.String]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filterNames = filterNames
        self.nextToken = nextToken
    }
}

struct ListFiltersOutputBody: Swift.Equatable {
    let filterNames: [Swift.String]?
    let nextToken: Swift.String?
}

extension ListFiltersOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filterNames = "filterNames"
        case nextToken = "nextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filterNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .filterNames)
        var filterNamesDecoded0:[Swift.String]? = nil
        if let filterNamesContainer = filterNamesContainer {
            filterNamesDecoded0 = [Swift.String]()
            for string0 in filterNamesContainer {
                if let string0 = string0 {
                    filterNamesDecoded0?.append(string0)
                }
            }
        }
        filterNames = filterNamesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListFiltersOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListFindingsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case findingCriteria = "findingCriteria"
        case maxResults = "maxResults"
        case nextToken = "nextToken"
        case sortCriteria = "sortCriteria"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let findingCriteria = self.findingCriteria {
            try encodeContainer.encode(findingCriteria, forKey: .findingCriteria)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let sortCriteria = self.sortCriteria {
            try encodeContainer.encode(sortCriteria, forKey: .sortCriteria)
        }
    }
}

extension ListFindingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let detectorId = detectorId else {
            return nil
        }
        return "/detector/\(detectorId.urlPercentEncoding())/findings"
    }
}

public struct ListFindingsInput: Swift.Equatable {
    /// The ID of the detector that specifies the GuardDuty service whose findings you want to list.
    /// This member is required.
    public var detectorId: Swift.String?
    /// Represents the criteria used for querying findings. Valid values include:
    ///
    /// * JSON field name
    ///
    /// * accountId
    ///
    /// * region
    ///
    /// * confidence
    ///
    /// * id
    ///
    /// * resource.accessKeyDetails.accessKeyId
    ///
    /// * resource.accessKeyDetails.principalId
    ///
    /// * resource.accessKeyDetails.userName
    ///
    /// * resource.accessKeyDetails.userType
    ///
    /// * resource.instanceDetails.iamInstanceProfile.id
    ///
    /// * resource.instanceDetails.imageId
    ///
    /// * resource.instanceDetails.instanceId
    ///
    /// * resource.instanceDetails.networkInterfaces.ipv6Addresses
    ///
    /// * resource.instanceDetails.networkInterfaces.privateIpAddresses.privateIpAddress
    ///
    /// * resource.instanceDetails.networkInterfaces.publicDnsName
    ///
    /// * resource.instanceDetails.networkInterfaces.publicIp
    ///
    /// * resource.instanceDetails.networkInterfaces.securityGroups.groupId
    ///
    /// * resource.instanceDetails.networkInterfaces.securityGroups.groupName
    ///
    /// * resource.instanceDetails.networkInterfaces.subnetId
    ///
    /// * resource.instanceDetails.networkInterfaces.vpcId
    ///
    /// * resource.instanceDetails.tags.key
    ///
    /// * resource.instanceDetails.tags.value
    ///
    /// * resource.resourceType
    ///
    /// * service.action.actionType
    ///
    /// * service.action.awsApiCallAction.api
    ///
    /// * service.action.awsApiCallAction.callerType
    ///
    /// * service.action.awsApiCallAction.remoteIpDetails.city.cityName
    ///
    /// * service.action.awsApiCallAction.remoteIpDetails.country.countryName
    ///
    /// * service.action.awsApiCallAction.remoteIpDetails.ipAddressV4
    ///
    /// * service.action.awsApiCallAction.remoteIpDetails.organization.asn
    ///
    /// * service.action.awsApiCallAction.remoteIpDetails.organization.asnOrg
    ///
    /// * service.action.awsApiCallAction.serviceName
    ///
    /// * service.action.dnsRequestAction.domain
    ///
    /// * service.action.networkConnectionAction.blocked
    ///
    /// * service.action.networkConnectionAction.connectionDirection
    ///
    /// * service.action.networkConnectionAction.localPortDetails.port
    ///
    /// * service.action.networkConnectionAction.protocol
    ///
    /// * service.action.networkConnectionAction.remoteIpDetails.country.countryName
    ///
    /// * service.action.networkConnectionAction.remoteIpDetails.ipAddressV4
    ///
    /// * service.action.networkConnectionAction.remoteIpDetails.organization.asn
    ///
    /// * service.action.networkConnectionAction.remoteIpDetails.organization.asnOrg
    ///
    /// * service.action.networkConnectionAction.remotePortDetails.port
    ///
    /// * service.additionalInfo.threatListName
    ///
    /// * service.archived When this attribute is set to 'true', only archived findings are listed. When it's set to 'false', only unarchived findings are listed. When this attribute is not set, all existing findings are listed.
    ///
    /// * service.resourceRole
    ///
    /// * severity
    ///
    /// * type
    ///
    /// * updatedAt Type: Timestamp in Unix Epoch millisecond format: 1486685375000
    public var findingCriteria: GuardDutyClientTypes.FindingCriteria?
    /// You can use this parameter to indicate the maximum number of items you want in the response. The default value is 50. The maximum value is 50.
    public var maxResults: Swift.Int?
    /// You can use this parameter when paginating results. Set the value of this parameter to null on your first call to the list action. For subsequent calls to the action, fill nextToken in the request with the value of NextToken from the previous response to continue listing data.
    public var nextToken: Swift.String?
    /// Represents the criteria used for sorting findings.
    public var sortCriteria: GuardDutyClientTypes.SortCriteria?

    public init(
        detectorId: Swift.String? = nil,
        findingCriteria: GuardDutyClientTypes.FindingCriteria? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        sortCriteria: GuardDutyClientTypes.SortCriteria? = nil
    )
    {
        self.detectorId = detectorId
        self.findingCriteria = findingCriteria
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sortCriteria = sortCriteria
    }
}

struct ListFindingsInputBody: Swift.Equatable {
    let findingCriteria: GuardDutyClientTypes.FindingCriteria?
    let sortCriteria: GuardDutyClientTypes.SortCriteria?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListFindingsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case findingCriteria = "findingCriteria"
        case maxResults = "maxResults"
        case nextToken = "nextToken"
        case sortCriteria = "sortCriteria"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let findingCriteriaDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.FindingCriteria.self, forKey: .findingCriteria)
        findingCriteria = findingCriteriaDecoded
        let sortCriteriaDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.SortCriteria.self, forKey: .sortCriteria)
        sortCriteria = sortCriteriaDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListFindingsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListFindingsOutputBody = try responseDecoder.decode(responseBody: data)
            self.findingIds = output.findingIds
            self.nextToken = output.nextToken
        } else {
            self.findingIds = nil
            self.nextToken = nil
        }
    }
}

public struct ListFindingsOutput: Swift.Equatable {
    /// The IDs of the findings that you're listing.
    /// This member is required.
    public var findingIds: [Swift.String]?
    /// The pagination parameter to be used on the next list operation to retrieve more items.
    public var nextToken: Swift.String?

    public init(
        findingIds: [Swift.String]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.findingIds = findingIds
        self.nextToken = nextToken
    }
}

struct ListFindingsOutputBody: Swift.Equatable {
    let findingIds: [Swift.String]?
    let nextToken: Swift.String?
}

extension ListFindingsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case findingIds = "findingIds"
        case nextToken = "nextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let findingIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .findingIds)
        var findingIdsDecoded0:[Swift.String]? = nil
        if let findingIdsContainer = findingIdsContainer {
            findingIdsDecoded0 = [Swift.String]()
            for string0 in findingIdsContainer {
                if let string0 = string0 {
                    findingIdsDecoded0?.append(string0)
                }
            }
        }
        findingIds = findingIdsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListFindingsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListIPSetsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListIPSetsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let detectorId = detectorId else {
            return nil
        }
        return "/detector/\(detectorId.urlPercentEncoding())/ipset"
    }
}

public struct ListIPSetsInput: Swift.Equatable {
    /// The unique ID of the detector that the IPSet is associated with.
    /// This member is required.
    public var detectorId: Swift.String?
    /// You can use this parameter to indicate the maximum number of items you want in the response. The default value is 50. The maximum value is 50.
    public var maxResults: Swift.Int?
    /// You can use this parameter when paginating results. Set the value of this parameter to null on your first call to the list action. For subsequent calls to the action, fill nextToken in the request with the value of NextToken from the previous response to continue listing data.
    public var nextToken: Swift.String?

    public init(
        detectorId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.detectorId = detectorId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListIPSetsInputBody: Swift.Equatable {
}

extension ListIPSetsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListIPSetsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListIPSetsOutputBody = try responseDecoder.decode(responseBody: data)
            self.ipSetIds = output.ipSetIds
            self.nextToken = output.nextToken
        } else {
            self.ipSetIds = nil
            self.nextToken = nil
        }
    }
}

public struct ListIPSetsOutput: Swift.Equatable {
    /// The IDs of the IPSet resources.
    /// This member is required.
    public var ipSetIds: [Swift.String]?
    /// The pagination parameter to be used on the next list operation to retrieve more items.
    public var nextToken: Swift.String?

    public init(
        ipSetIds: [Swift.String]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.ipSetIds = ipSetIds
        self.nextToken = nextToken
    }
}

struct ListIPSetsOutputBody: Swift.Equatable {
    let ipSetIds: [Swift.String]?
    let nextToken: Swift.String?
}

extension ListIPSetsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ipSetIds = "ipSetIds"
        case nextToken = "nextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ipSetIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .ipSetIds)
        var ipSetIdsDecoded0:[Swift.String]? = nil
        if let ipSetIdsContainer = ipSetIdsContainer {
            ipSetIdsDecoded0 = [Swift.String]()
            for string0 in ipSetIdsContainer {
                if let string0 = string0 {
                    ipSetIdsDecoded0?.append(string0)
                }
            }
        }
        ipSetIds = ipSetIdsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListIPSetsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListInvitationsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListInvitationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/invitation"
    }
}

public struct ListInvitationsInput: Swift.Equatable {
    /// You can use this parameter to indicate the maximum number of items that you want in the response. The default value is 50. The maximum value is 50.
    public var maxResults: Swift.Int?
    /// You can use this parameter when paginating results. Set the value of this parameter to null on your first call to the list action. For subsequent calls to the action, fill nextToken in the request with the value of NextToken from the previous response to continue listing data.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListInvitationsInputBody: Swift.Equatable {
}

extension ListInvitationsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListInvitationsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListInvitationsOutputBody = try responseDecoder.decode(responseBody: data)
            self.invitations = output.invitations
            self.nextToken = output.nextToken
        } else {
            self.invitations = nil
            self.nextToken = nil
        }
    }
}

public struct ListInvitationsOutput: Swift.Equatable {
    /// A list of invitation descriptions.
    public var invitations: [GuardDutyClientTypes.Invitation]?
    /// The pagination parameter to be used on the next list operation to retrieve more items.
    public var nextToken: Swift.String?

    public init(
        invitations: [GuardDutyClientTypes.Invitation]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.invitations = invitations
        self.nextToken = nextToken
    }
}

struct ListInvitationsOutputBody: Swift.Equatable {
    let invitations: [GuardDutyClientTypes.Invitation]?
    let nextToken: Swift.String?
}

extension ListInvitationsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case invitations = "invitations"
        case nextToken = "nextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let invitationsContainer = try containerValues.decodeIfPresent([GuardDutyClientTypes.Invitation?].self, forKey: .invitations)
        var invitationsDecoded0:[GuardDutyClientTypes.Invitation]? = nil
        if let invitationsContainer = invitationsContainer {
            invitationsDecoded0 = [GuardDutyClientTypes.Invitation]()
            for structure0 in invitationsContainer {
                if let structure0 = structure0 {
                    invitationsDecoded0?.append(structure0)
                }
            }
        }
        invitations = invitationsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListInvitationsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListMembersInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let onlyAssociated = onlyAssociated {
                let onlyAssociatedQueryItem = ClientRuntime.URLQueryItem(name: "onlyAssociated".urlPercentEncoding(), value: Swift.String(onlyAssociated).urlPercentEncoding())
                items.append(onlyAssociatedQueryItem)
            }
            return items
        }
    }
}

extension ListMembersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let detectorId = detectorId else {
            return nil
        }
        return "/detector/\(detectorId.urlPercentEncoding())/member"
    }
}

public struct ListMembersInput: Swift.Equatable {
    /// The unique ID of the detector the member is associated with.
    /// This member is required.
    public var detectorId: Swift.String?
    /// You can use this parameter to indicate the maximum number of items you want in the response. The default value is 50. The maximum value is 50.
    public var maxResults: Swift.Int?
    /// You can use this parameter when paginating results. Set the value of this parameter to null on your first call to the list action. For subsequent calls to the action, fill nextToken in the request with the value of NextToken from the previous response to continue listing data.
    public var nextToken: Swift.String?
    /// Specifies whether to only return associated members or to return all members (including members who haven't been invited yet or have been disassociated). Member accounts must have been previously associated with the GuardDuty administrator account using [Create Members](https://docs.aws.amazon.com/guardduty/latest/APIReference/API_CreateMembers.html).
    public var onlyAssociated: Swift.String?

    public init(
        detectorId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        onlyAssociated: Swift.String? = nil
    )
    {
        self.detectorId = detectorId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.onlyAssociated = onlyAssociated
    }
}

struct ListMembersInputBody: Swift.Equatable {
}

extension ListMembersInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListMembersOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListMembersOutputBody = try responseDecoder.decode(responseBody: data)
            self.members = output.members
            self.nextToken = output.nextToken
        } else {
            self.members = nil
            self.nextToken = nil
        }
    }
}

public struct ListMembersOutput: Swift.Equatable {
    /// A list of members.
    public var members: [GuardDutyClientTypes.Member]?
    /// The pagination parameter to be used on the next list operation to retrieve more items.
    public var nextToken: Swift.String?

    public init(
        members: [GuardDutyClientTypes.Member]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.members = members
        self.nextToken = nextToken
    }
}

struct ListMembersOutputBody: Swift.Equatable {
    let members: [GuardDutyClientTypes.Member]?
    let nextToken: Swift.String?
}

extension ListMembersOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case members = "members"
        case nextToken = "nextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let membersContainer = try containerValues.decodeIfPresent([GuardDutyClientTypes.Member?].self, forKey: .members)
        var membersDecoded0:[GuardDutyClientTypes.Member]? = nil
        if let membersContainer = membersContainer {
            membersDecoded0 = [GuardDutyClientTypes.Member]()
            for structure0 in membersContainer {
                if let structure0 = structure0 {
                    membersDecoded0?.append(structure0)
                }
            }
        }
        members = membersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListMembersOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListOrganizationAdminAccountsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListOrganizationAdminAccountsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/admin"
    }
}

public struct ListOrganizationAdminAccountsInput: Swift.Equatable {
    /// The maximum number of results to return in the response.
    public var maxResults: Swift.Int?
    /// A token to use for paginating results that are returned in the response. Set the value of this parameter to null for the first request to a list action. For subsequent calls, use the NextToken value returned from the previous request to continue listing results after the first page.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListOrganizationAdminAccountsInputBody: Swift.Equatable {
}

extension ListOrganizationAdminAccountsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListOrganizationAdminAccountsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListOrganizationAdminAccountsOutputBody = try responseDecoder.decode(responseBody: data)
            self.adminAccounts = output.adminAccounts
            self.nextToken = output.nextToken
        } else {
            self.adminAccounts = nil
            self.nextToken = nil
        }
    }
}

public struct ListOrganizationAdminAccountsOutput: Swift.Equatable {
    /// A list of accounts configured as GuardDuty delegated administrators.
    public var adminAccounts: [GuardDutyClientTypes.AdminAccount]?
    /// The pagination parameter to be used on the next list operation to retrieve more items.
    public var nextToken: Swift.String?

    public init(
        adminAccounts: [GuardDutyClientTypes.AdminAccount]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.adminAccounts = adminAccounts
        self.nextToken = nextToken
    }
}

struct ListOrganizationAdminAccountsOutputBody: Swift.Equatable {
    let adminAccounts: [GuardDutyClientTypes.AdminAccount]?
    let nextToken: Swift.String?
}

extension ListOrganizationAdminAccountsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case adminAccounts = "adminAccounts"
        case nextToken = "nextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let adminAccountsContainer = try containerValues.decodeIfPresent([GuardDutyClientTypes.AdminAccount?].self, forKey: .adminAccounts)
        var adminAccountsDecoded0:[GuardDutyClientTypes.AdminAccount]? = nil
        if let adminAccountsContainer = adminAccountsContainer {
            adminAccountsDecoded0 = [GuardDutyClientTypes.AdminAccount]()
            for structure0 in adminAccountsContainer {
                if let structure0 = structure0 {
                    adminAccountsDecoded0?.append(structure0)
                }
            }
        }
        adminAccounts = adminAccountsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListOrganizationAdminAccountsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListPublishingDestinationsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListPublishingDestinationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let detectorId = detectorId else {
            return nil
        }
        return "/detector/\(detectorId.urlPercentEncoding())/publishingDestination"
    }
}

public struct ListPublishingDestinationsInput: Swift.Equatable {
    /// The ID of the detector to retrieve publishing destinations for.
    /// This member is required.
    public var detectorId: Swift.String?
    /// The maximum number of results to return in the response.
    public var maxResults: Swift.Int?
    /// A token to use for paginating results that are returned in the response. Set the value of this parameter to null for the first request to a list action. For subsequent calls, use the NextToken value returned from the previous request to continue listing results after the first page.
    public var nextToken: Swift.String?

    public init(
        detectorId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.detectorId = detectorId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListPublishingDestinationsInputBody: Swift.Equatable {
}

extension ListPublishingDestinationsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListPublishingDestinationsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListPublishingDestinationsOutputBody = try responseDecoder.decode(responseBody: data)
            self.destinations = output.destinations
            self.nextToken = output.nextToken
        } else {
            self.destinations = nil
            self.nextToken = nil
        }
    }
}

public struct ListPublishingDestinationsOutput: Swift.Equatable {
    /// A Destinations object that includes information about each publishing destination returned.
    /// This member is required.
    public var destinations: [GuardDutyClientTypes.Destination]?
    /// A token to use for paginating results that are returned in the response. Set the value of this parameter to null for the first request to a list action. For subsequent calls, use the NextToken value returned from the previous request to continue listing results after the first page.
    public var nextToken: Swift.String?

    public init(
        destinations: [GuardDutyClientTypes.Destination]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.destinations = destinations
        self.nextToken = nextToken
    }
}

struct ListPublishingDestinationsOutputBody: Swift.Equatable {
    let destinations: [GuardDutyClientTypes.Destination]?
    let nextToken: Swift.String?
}

extension ListPublishingDestinationsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinations = "destinations"
        case nextToken = "nextToken"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let destinationsContainer = try containerValues.decodeIfPresent([GuardDutyClientTypes.Destination?].self, forKey: .destinations)
        var destinationsDecoded0:[GuardDutyClientTypes.Destination]? = nil
        if let destinationsContainer = destinationsContainer {
            destinationsDecoded0 = [GuardDutyClientTypes.Destination]()
            for structure0 in destinationsContainer {
                if let structure0 = structure0 {
                    destinationsDecoded0?.append(structure0)
                }
            }
        }
        destinations = destinationsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListPublishingDestinationsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) for the given GuardDuty resource.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutput: Swift.Equatable {
    /// The tags associated with the resource.
    public var tags: [Swift.String:Swift.String]?

    public init(
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension ListTagsForResourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum ListTagsForResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListThreatIntelSetsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListThreatIntelSetsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let detectorId = detectorId else {
            return nil
        }
        return "/detector/\(detectorId.urlPercentEncoding())/threatintelset"
    }
}

public struct ListThreatIntelSetsInput: Swift.Equatable {
    /// The unique ID of the detector that the threatIntelSet is associated with.
    /// This member is required.
    public var detectorId: Swift.String?
    /// You can use this parameter to indicate the maximum number of items that you want in the response. The default value is 50. The maximum value is 50.
    public var maxResults: Swift.Int?
    /// You can use this parameter to paginate results in the response. Set the value of this parameter to null on your first call to the list action. For subsequent calls to the action, fill nextToken in the request with the value of NextToken from the previous response to continue listing data.
    public var nextToken: Swift.String?

    public init(
        detectorId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.detectorId = detectorId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListThreatIntelSetsInputBody: Swift.Equatable {
}

extension ListThreatIntelSetsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListThreatIntelSetsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListThreatIntelSetsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.threatIntelSetIds = output.threatIntelSetIds
        } else {
            self.nextToken = nil
            self.threatIntelSetIds = nil
        }
    }
}

public struct ListThreatIntelSetsOutput: Swift.Equatable {
    /// The pagination parameter to be used on the next list operation to retrieve more items.
    public var nextToken: Swift.String?
    /// The IDs of the ThreatIntelSet resources.
    /// This member is required.
    public var threatIntelSetIds: [Swift.String]?

    public init(
        nextToken: Swift.String? = nil,
        threatIntelSetIds: [Swift.String]? = nil
    )
    {
        self.nextToken = nextToken
        self.threatIntelSetIds = threatIntelSetIds
    }
}

struct ListThreatIntelSetsOutputBody: Swift.Equatable {
    let threatIntelSetIds: [Swift.String]?
    let nextToken: Swift.String?
}

extension ListThreatIntelSetsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "nextToken"
        case threatIntelSetIds = "threatIntelSetIds"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let threatIntelSetIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .threatIntelSetIds)
        var threatIntelSetIdsDecoded0:[Swift.String]? = nil
        if let threatIntelSetIdsContainer = threatIntelSetIdsContainer {
            threatIntelSetIdsDecoded0 = [Swift.String]()
            for string0 in threatIntelSetIdsContainer {
                if let string0 = string0 {
                    threatIntelSetIdsDecoded0?.append(string0)
                }
            }
        }
        threatIntelSetIds = threatIntelSetIdsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListThreatIntelSetsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GuardDutyClientTypes.LocalIpDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ipAddressV4 = "ipAddressV4"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ipAddressV4 = self.ipAddressV4 {
            try encodeContainer.encode(ipAddressV4, forKey: .ipAddressV4)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ipAddressV4Decoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ipAddressV4)
        ipAddressV4 = ipAddressV4Decoded
    }
}

extension GuardDutyClientTypes {
    /// Contains information about the local IP address of the connection.
    public struct LocalIpDetails: Swift.Equatable {
        /// The IPv4 local address of the connection.
        public var ipAddressV4: Swift.String?

        public init(
            ipAddressV4: Swift.String? = nil
        )
        {
            self.ipAddressV4 = ipAddressV4
        }
    }

}

extension GuardDutyClientTypes.LocalPortDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case port = "port"
        case portName = "portName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if port != 0 {
            try encodeContainer.encode(port, forKey: .port)
        }
        if let portName = self.portName {
            try encodeContainer.encode(portName, forKey: .portName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let portDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .port) ?? 0
        port = portDecoded
        let portNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .portName)
        portName = portNameDecoded
    }
}

extension GuardDutyClientTypes {
    /// Contains information about the port for the local connection.
    public struct LocalPortDetails: Swift.Equatable {
        /// The port number of the local connection.
        public var port: Swift.Int
        /// The port name of the local connection.
        public var portName: Swift.String?

        public init(
            port: Swift.Int = 0,
            portName: Swift.String? = nil
        )
        {
            self.port = port
            self.portName = portName
        }
    }

}

extension GuardDutyClientTypes.LoginAttribute: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case application = "application"
        case failedLoginAttempts = "failedLoginAttempts"
        case successfulLoginAttempts = "successfulLoginAttempts"
        case user = "user"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let application = self.application {
            try encodeContainer.encode(application, forKey: .application)
        }
        if failedLoginAttempts != 0 {
            try encodeContainer.encode(failedLoginAttempts, forKey: .failedLoginAttempts)
        }
        if successfulLoginAttempts != 0 {
            try encodeContainer.encode(successfulLoginAttempts, forKey: .successfulLoginAttempts)
        }
        if let user = self.user {
            try encodeContainer.encode(user, forKey: .user)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .user)
        user = userDecoded
        let applicationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .application)
        application = applicationDecoded
        let failedLoginAttemptsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .failedLoginAttempts) ?? 0
        failedLoginAttempts = failedLoginAttemptsDecoded
        let successfulLoginAttemptsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .successfulLoginAttempts) ?? 0
        successfulLoginAttempts = successfulLoginAttemptsDecoded
    }
}

extension GuardDutyClientTypes {
    /// Information about the login attempts.
    public struct LoginAttribute: Swift.Equatable {
        /// Indicates the application name used to attempt log in.
        public var application: Swift.String?
        /// Represents the sum of failed (unsuccessful) login attempts made to establish a connection to the database instance.
        public var failedLoginAttempts: Swift.Int
        /// Represents the sum of successful connections (a correct combination of login attributes) made to the database instance by the actor.
        public var successfulLoginAttempts: Swift.Int
        /// Indicates the user name which attempted to log in.
        public var user: Swift.String?

        public init(
            application: Swift.String? = nil,
            failedLoginAttempts: Swift.Int = 0,
            successfulLoginAttempts: Swift.Int = 0,
            user: Swift.String? = nil
        )
        {
            self.application = application
            self.failedLoginAttempts = failedLoginAttempts
            self.successfulLoginAttempts = successfulLoginAttempts
            self.user = user
        }
    }

}

extension GuardDutyClientTypes.MalwareProtectionConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case scanEc2InstanceWithFindings = "scanEc2InstanceWithFindings"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let scanEc2InstanceWithFindings = self.scanEc2InstanceWithFindings {
            try encodeContainer.encode(scanEc2InstanceWithFindings, forKey: .scanEc2InstanceWithFindings)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scanEc2InstanceWithFindingsDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.ScanEc2InstanceWithFindings.self, forKey: .scanEc2InstanceWithFindings)
        scanEc2InstanceWithFindings = scanEc2InstanceWithFindingsDecoded
    }
}

extension GuardDutyClientTypes {
    /// Describes whether Malware Protection will be enabled as a data source.
    public struct MalwareProtectionConfiguration: Swift.Equatable {
        /// Describes the configuration of Malware Protection for EC2 instances with findings.
        public var scanEc2InstanceWithFindings: GuardDutyClientTypes.ScanEc2InstanceWithFindings?

        public init(
            scanEc2InstanceWithFindings: GuardDutyClientTypes.ScanEc2InstanceWithFindings? = nil
        )
        {
            self.scanEc2InstanceWithFindings = scanEc2InstanceWithFindings
        }
    }

}

extension GuardDutyClientTypes.MalwareProtectionConfigurationResult: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case scanEc2InstanceWithFindings = "scanEc2InstanceWithFindings"
        case serviceRole = "serviceRole"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let scanEc2InstanceWithFindings = self.scanEc2InstanceWithFindings {
            try encodeContainer.encode(scanEc2InstanceWithFindings, forKey: .scanEc2InstanceWithFindings)
        }
        if let serviceRole = self.serviceRole {
            try encodeContainer.encode(serviceRole, forKey: .serviceRole)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scanEc2InstanceWithFindingsDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.ScanEc2InstanceWithFindingsResult.self, forKey: .scanEc2InstanceWithFindings)
        scanEc2InstanceWithFindings = scanEc2InstanceWithFindingsDecoded
        let serviceRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceRole)
        serviceRole = serviceRoleDecoded
    }
}

extension GuardDutyClientTypes {
    /// An object that contains information on the status of all Malware Protection data sources.
    public struct MalwareProtectionConfigurationResult: Swift.Equatable {
        /// Describes the configuration of Malware Protection for EC2 instances with findings.
        public var scanEc2InstanceWithFindings: GuardDutyClientTypes.ScanEc2InstanceWithFindingsResult?
        /// The GuardDuty Malware Protection service role.
        public var serviceRole: Swift.String?

        public init(
            scanEc2InstanceWithFindings: GuardDutyClientTypes.ScanEc2InstanceWithFindingsResult? = nil,
            serviceRole: Swift.String? = nil
        )
        {
            self.scanEc2InstanceWithFindings = scanEc2InstanceWithFindings
            self.serviceRole = serviceRole
        }
    }

}

extension GuardDutyClientTypes.MalwareProtectionDataSourceFreeTrial: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case scanEc2InstanceWithFindings = "scanEc2InstanceWithFindings"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let scanEc2InstanceWithFindings = self.scanEc2InstanceWithFindings {
            try encodeContainer.encode(scanEc2InstanceWithFindings, forKey: .scanEc2InstanceWithFindings)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scanEc2InstanceWithFindingsDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.DataSourceFreeTrial.self, forKey: .scanEc2InstanceWithFindings)
        scanEc2InstanceWithFindings = scanEc2InstanceWithFindingsDecoded
    }
}

extension GuardDutyClientTypes {
    /// Provides details about Malware Protection when it is enabled as a data source.
    public struct MalwareProtectionDataSourceFreeTrial: Swift.Equatable {
        /// Describes whether Malware Protection for EC2 instances with findings is enabled as a data source.
        public var scanEc2InstanceWithFindings: GuardDutyClientTypes.DataSourceFreeTrial?

        public init(
            scanEc2InstanceWithFindings: GuardDutyClientTypes.DataSourceFreeTrial? = nil
        )
        {
            self.scanEc2InstanceWithFindings = scanEc2InstanceWithFindings
        }
    }

}

extension GuardDutyClientTypes {
    public enum ManagementType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case autoManaged
        case manual
        case sdkUnknown(Swift.String)

        public static var allCases: [ManagementType] {
            return [
                .autoManaged,
                .manual,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .autoManaged: return "AUTO_MANAGED"
            case .manual: return "MANUAL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ManagementType(rawValue: rawValue) ?? ManagementType.sdkUnknown(rawValue)
        }
    }
}

extension GuardDutyClientTypes.Master: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "accountId"
        case invitationId = "invitationId"
        case invitedAt = "invitedAt"
        case relationshipStatus = "relationshipStatus"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let invitationId = self.invitationId {
            try encodeContainer.encode(invitationId, forKey: .invitationId)
        }
        if let invitedAt = self.invitedAt {
            try encodeContainer.encode(invitedAt, forKey: .invitedAt)
        }
        if let relationshipStatus = self.relationshipStatus {
            try encodeContainer.encode(relationshipStatus, forKey: .relationshipStatus)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let invitationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .invitationId)
        invitationId = invitationIdDecoded
        let relationshipStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .relationshipStatus)
        relationshipStatus = relationshipStatusDecoded
        let invitedAtDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .invitedAt)
        invitedAt = invitedAtDecoded
    }
}

extension GuardDutyClientTypes {
    /// Contains information about the administrator account and invitation.
    public struct Master: Swift.Equatable {
        /// The ID of the account used as the administrator account.
        public var accountId: Swift.String?
        /// The value used to validate the administrator account to the member account.
        public var invitationId: Swift.String?
        /// The timestamp when the invitation was sent.
        public var invitedAt: Swift.String?
        /// The status of the relationship between the administrator and member accounts.
        public var relationshipStatus: Swift.String?

        public init(
            accountId: Swift.String? = nil,
            invitationId: Swift.String? = nil,
            invitedAt: Swift.String? = nil,
            relationshipStatus: Swift.String? = nil
        )
        {
            self.accountId = accountId
            self.invitationId = invitationId
            self.invitedAt = invitedAt
            self.relationshipStatus = relationshipStatus
        }
    }

}

extension GuardDutyClientTypes.Member: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "accountId"
        case administratorId = "administratorId"
        case detectorId = "detectorId"
        case email = "email"
        case invitedAt = "invitedAt"
        case masterId = "masterId"
        case relationshipStatus = "relationshipStatus"
        case updatedAt = "updatedAt"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let administratorId = self.administratorId {
            try encodeContainer.encode(administratorId, forKey: .administratorId)
        }
        if let detectorId = self.detectorId {
            try encodeContainer.encode(detectorId, forKey: .detectorId)
        }
        if let email = self.email {
            try encodeContainer.encode(email, forKey: .email)
        }
        if let invitedAt = self.invitedAt {
            try encodeContainer.encode(invitedAt, forKey: .invitedAt)
        }
        if let masterId = self.masterId {
            try encodeContainer.encode(masterId, forKey: .masterId)
        }
        if let relationshipStatus = self.relationshipStatus {
            try encodeContainer.encode(relationshipStatus, forKey: .relationshipStatus)
        }
        if let updatedAt = self.updatedAt {
            try encodeContainer.encode(updatedAt, forKey: .updatedAt)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let detectorIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detectorId)
        detectorId = detectorIdDecoded
        let masterIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .masterId)
        masterId = masterIdDecoded
        let emailDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .email)
        email = emailDecoded
        let relationshipStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .relationshipStatus)
        relationshipStatus = relationshipStatusDecoded
        let invitedAtDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .invitedAt)
        invitedAt = invitedAtDecoded
        let updatedAtDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let administratorIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .administratorId)
        administratorId = administratorIdDecoded
    }
}

extension GuardDutyClientTypes {
    /// Contains information about the member account.
    public struct Member: Swift.Equatable {
        /// The ID of the member account.
        /// This member is required.
        public var accountId: Swift.String?
        /// The administrator account ID.
        public var administratorId: Swift.String?
        /// The detector ID of the member account.
        public var detectorId: Swift.String?
        /// The email address of the member account.
        /// This member is required.
        public var email: Swift.String?
        /// The timestamp when the invitation was sent.
        public var invitedAt: Swift.String?
        /// The administrator account ID.
        /// This member is required.
        public var masterId: Swift.String?
        /// The status of the relationship between the member and the administrator.
        /// This member is required.
        public var relationshipStatus: Swift.String?
        /// The last-updated timestamp of the member.
        /// This member is required.
        public var updatedAt: Swift.String?

        public init(
            accountId: Swift.String? = nil,
            administratorId: Swift.String? = nil,
            detectorId: Swift.String? = nil,
            email: Swift.String? = nil,
            invitedAt: Swift.String? = nil,
            masterId: Swift.String? = nil,
            relationshipStatus: Swift.String? = nil,
            updatedAt: Swift.String? = nil
        )
        {
            self.accountId = accountId
            self.administratorId = administratorId
            self.detectorId = detectorId
            self.email = email
            self.invitedAt = invitedAt
            self.masterId = masterId
            self.relationshipStatus = relationshipStatus
            self.updatedAt = updatedAt
        }
    }

}

extension GuardDutyClientTypes.MemberAdditionalConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "name"
        case status = "status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.OrgFeatureAdditionalConfiguration.self, forKey: .name)
        name = nameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.FeatureStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension GuardDutyClientTypes {
    /// Information about the additional configuration for the member account.
    public struct MemberAdditionalConfiguration: Swift.Equatable {
        /// Name of the additional configuration.
        public var name: GuardDutyClientTypes.OrgFeatureAdditionalConfiguration?
        /// Status of the additional configuration.
        public var status: GuardDutyClientTypes.FeatureStatus?

        public init(
            name: GuardDutyClientTypes.OrgFeatureAdditionalConfiguration? = nil,
            status: GuardDutyClientTypes.FeatureStatus? = nil
        )
        {
            self.name = name
            self.status = status
        }
    }

}

extension GuardDutyClientTypes.MemberAdditionalConfigurationResult: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "name"
        case status = "status"
        case updatedAt = "updatedAt"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let updatedAt = self.updatedAt {
            try encodeContainer.encodeTimestamp(updatedAt, format: .epochSeconds, forKey: .updatedAt)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.OrgFeatureAdditionalConfiguration.self, forKey: .name)
        name = nameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.FeatureStatus.self, forKey: .status)
        status = statusDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
    }
}

extension GuardDutyClientTypes {
    /// Information about the additional configuration for the member account.
    public struct MemberAdditionalConfigurationResult: Swift.Equatable {
        /// Indicates the name of the additional configuration that is set for the member account.
        public var name: GuardDutyClientTypes.OrgFeatureAdditionalConfiguration?
        /// Indicates the status of the additional configuration that is set for the member account.
        public var status: GuardDutyClientTypes.FeatureStatus?
        /// The timestamp at which the additional configuration was set for the member account. This is in UTC format.
        public var updatedAt: ClientRuntime.Date?

        public init(
            name: GuardDutyClientTypes.OrgFeatureAdditionalConfiguration? = nil,
            status: GuardDutyClientTypes.FeatureStatus? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.name = name
            self.status = status
            self.updatedAt = updatedAt
        }
    }

}

extension GuardDutyClientTypes.MemberDataSourceConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "accountId"
        case dataSources = "dataSources"
        case features = "features"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let dataSources = self.dataSources {
            try encodeContainer.encode(dataSources, forKey: .dataSources)
        }
        if let features = features {
            var featuresContainer = encodeContainer.nestedUnkeyedContainer(forKey: .features)
            for memberfeaturesconfigurationresult0 in features {
                try featuresContainer.encode(memberfeaturesconfigurationresult0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let dataSourcesDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.DataSourceConfigurationsResult.self, forKey: .dataSources)
        dataSources = dataSourcesDecoded
        let featuresContainer = try containerValues.decodeIfPresent([GuardDutyClientTypes.MemberFeaturesConfigurationResult?].self, forKey: .features)
        var featuresDecoded0:[GuardDutyClientTypes.MemberFeaturesConfigurationResult]? = nil
        if let featuresContainer = featuresContainer {
            featuresDecoded0 = [GuardDutyClientTypes.MemberFeaturesConfigurationResult]()
            for structure0 in featuresContainer {
                if let structure0 = structure0 {
                    featuresDecoded0?.append(structure0)
                }
            }
        }
        features = featuresDecoded0
    }
}

extension GuardDutyClientTypes {
    /// Contains information on which data sources are enabled for a member account.
    public struct MemberDataSourceConfiguration: Swift.Equatable {
        /// The account ID for the member account.
        /// This member is required.
        public var accountId: Swift.String?
        /// Contains information on the status of data sources for the account.
        @available(*, deprecated, message: "This parameter is deprecated, use Features instead")
        public var dataSources: GuardDutyClientTypes.DataSourceConfigurationsResult?
        /// Contains information about the status of the features for the member account.
        public var features: [GuardDutyClientTypes.MemberFeaturesConfigurationResult]?

        public init(
            accountId: Swift.String? = nil,
            dataSources: GuardDutyClientTypes.DataSourceConfigurationsResult? = nil,
            features: [GuardDutyClientTypes.MemberFeaturesConfigurationResult]? = nil
        )
        {
            self.accountId = accountId
            self.dataSources = dataSources
            self.features = features
        }
    }

}

extension GuardDutyClientTypes.MemberFeaturesConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case additionalConfiguration = "additionalConfiguration"
        case name = "name"
        case status = "status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let additionalConfiguration = additionalConfiguration {
            var additionalConfigurationContainer = encodeContainer.nestedUnkeyedContainer(forKey: .additionalConfiguration)
            for memberadditionalconfiguration0 in additionalConfiguration {
                try additionalConfigurationContainer.encode(memberadditionalconfiguration0)
            }
        }
        if let name = self.name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.OrgFeature.self, forKey: .name)
        name = nameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.FeatureStatus.self, forKey: .status)
        status = statusDecoded
        let additionalConfigurationContainer = try containerValues.decodeIfPresent([GuardDutyClientTypes.MemberAdditionalConfiguration?].self, forKey: .additionalConfiguration)
        var additionalConfigurationDecoded0:[GuardDutyClientTypes.MemberAdditionalConfiguration]? = nil
        if let additionalConfigurationContainer = additionalConfigurationContainer {
            additionalConfigurationDecoded0 = [GuardDutyClientTypes.MemberAdditionalConfiguration]()
            for structure0 in additionalConfigurationContainer {
                if let structure0 = structure0 {
                    additionalConfigurationDecoded0?.append(structure0)
                }
            }
        }
        additionalConfiguration = additionalConfigurationDecoded0
    }
}

extension GuardDutyClientTypes {
    /// Contains information about the features for the member account.
    public struct MemberFeaturesConfiguration: Swift.Equatable {
        /// Additional configuration of the feature for the member account.
        public var additionalConfiguration: [GuardDutyClientTypes.MemberAdditionalConfiguration]?
        /// The name of the feature.
        public var name: GuardDutyClientTypes.OrgFeature?
        /// The status of the feature.
        public var status: GuardDutyClientTypes.FeatureStatus?

        public init(
            additionalConfiguration: [GuardDutyClientTypes.MemberAdditionalConfiguration]? = nil,
            name: GuardDutyClientTypes.OrgFeature? = nil,
            status: GuardDutyClientTypes.FeatureStatus? = nil
        )
        {
            self.additionalConfiguration = additionalConfiguration
            self.name = name
            self.status = status
        }
    }

}

extension GuardDutyClientTypes.MemberFeaturesConfigurationResult: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case additionalConfiguration = "additionalConfiguration"
        case name = "name"
        case status = "status"
        case updatedAt = "updatedAt"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let additionalConfiguration = additionalConfiguration {
            var additionalConfigurationContainer = encodeContainer.nestedUnkeyedContainer(forKey: .additionalConfiguration)
            for memberadditionalconfigurationresult0 in additionalConfiguration {
                try additionalConfigurationContainer.encode(memberadditionalconfigurationresult0)
            }
        }
        if let name = self.name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let updatedAt = self.updatedAt {
            try encodeContainer.encodeTimestamp(updatedAt, format: .epochSeconds, forKey: .updatedAt)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.OrgFeature.self, forKey: .name)
        name = nameDecoded
        let statusDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.FeatureStatus.self, forKey: .status)
        status = statusDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let additionalConfigurationContainer = try containerValues.decodeIfPresent([GuardDutyClientTypes.MemberAdditionalConfigurationResult?].self, forKey: .additionalConfiguration)
        var additionalConfigurationDecoded0:[GuardDutyClientTypes.MemberAdditionalConfigurationResult]? = nil
        if let additionalConfigurationContainer = additionalConfigurationContainer {
            additionalConfigurationDecoded0 = [GuardDutyClientTypes.MemberAdditionalConfigurationResult]()
            for structure0 in additionalConfigurationContainer {
                if let structure0 = structure0 {
                    additionalConfigurationDecoded0?.append(structure0)
                }
            }
        }
        additionalConfiguration = additionalConfigurationDecoded0
    }
}

extension GuardDutyClientTypes {
    /// Contains information about the features for the member account.
    public struct MemberFeaturesConfigurationResult: Swift.Equatable {
        /// Indicates the additional configuration of the feature that is configured for the member account.
        public var additionalConfiguration: [GuardDutyClientTypes.MemberAdditionalConfigurationResult]?
        /// Indicates the name of the feature that is enabled for the detector.
        public var name: GuardDutyClientTypes.OrgFeature?
        /// Indicates the status of the feature that is enabled for the detector.
        public var status: GuardDutyClientTypes.FeatureStatus?
        /// The timestamp at which the feature object was updated.
        public var updatedAt: ClientRuntime.Date?

        public init(
            additionalConfiguration: [GuardDutyClientTypes.MemberAdditionalConfigurationResult]? = nil,
            name: GuardDutyClientTypes.OrgFeature? = nil,
            status: GuardDutyClientTypes.FeatureStatus? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.additionalConfiguration = additionalConfiguration
            self.name = name
            self.status = status
            self.updatedAt = updatedAt
        }
    }

}

extension GuardDutyClientTypes.NetworkConnectionAction: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case blocked = "blocked"
        case connectionDirection = "connectionDirection"
        case localIpDetails = "localIpDetails"
        case localPortDetails = "localPortDetails"
        case `protocol` = "protocol"
        case remoteIpDetails = "remoteIpDetails"
        case remotePortDetails = "remotePortDetails"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if blocked != false {
            try encodeContainer.encode(blocked, forKey: .blocked)
        }
        if let connectionDirection = self.connectionDirection {
            try encodeContainer.encode(connectionDirection, forKey: .connectionDirection)
        }
        if let localIpDetails = self.localIpDetails {
            try encodeContainer.encode(localIpDetails, forKey: .localIpDetails)
        }
        if let localPortDetails = self.localPortDetails {
            try encodeContainer.encode(localPortDetails, forKey: .localPortDetails)
        }
        if let `protocol` = self.`protocol` {
            try encodeContainer.encode(`protocol`, forKey: .`protocol`)
        }
        if let remoteIpDetails = self.remoteIpDetails {
            try encodeContainer.encode(remoteIpDetails, forKey: .remoteIpDetails)
        }
        if let remotePortDetails = self.remotePortDetails {
            try encodeContainer.encode(remotePortDetails, forKey: .remotePortDetails)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let blockedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .blocked) ?? false
        blocked = blockedDecoded
        let connectionDirectionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectionDirection)
        connectionDirection = connectionDirectionDecoded
        let localPortDetailsDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.LocalPortDetails.self, forKey: .localPortDetails)
        localPortDetails = localPortDetailsDecoded
        let protocolDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .protocol)
        `protocol` = protocolDecoded
        let localIpDetailsDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.LocalIpDetails.self, forKey: .localIpDetails)
        localIpDetails = localIpDetailsDecoded
        let remoteIpDetailsDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.RemoteIpDetails.self, forKey: .remoteIpDetails)
        remoteIpDetails = remoteIpDetailsDecoded
        let remotePortDetailsDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.RemotePortDetails.self, forKey: .remotePortDetails)
        remotePortDetails = remotePortDetailsDecoded
    }
}

extension GuardDutyClientTypes {
    /// Contains information about the NETWORK_CONNECTION action described in the finding.
    public struct NetworkConnectionAction: Swift.Equatable {
        /// Indicates whether EC2 blocked the network connection to your instance.
        public var blocked: Swift.Bool
        /// The network connection direction.
        public var connectionDirection: Swift.String?
        /// The local IP information of the connection.
        public var localIpDetails: GuardDutyClientTypes.LocalIpDetails?
        /// The local port information of the connection.
        public var localPortDetails: GuardDutyClientTypes.LocalPortDetails?
        /// The network connection protocol.
        public var `protocol`: Swift.String?
        /// The remote IP information of the connection.
        public var remoteIpDetails: GuardDutyClientTypes.RemoteIpDetails?
        /// The remote port information of the connection.
        public var remotePortDetails: GuardDutyClientTypes.RemotePortDetails?

        public init(
            blocked: Swift.Bool = false,
            connectionDirection: Swift.String? = nil,
            localIpDetails: GuardDutyClientTypes.LocalIpDetails? = nil,
            localPortDetails: GuardDutyClientTypes.LocalPortDetails? = nil,
            `protocol`: Swift.String? = nil,
            remoteIpDetails: GuardDutyClientTypes.RemoteIpDetails? = nil,
            remotePortDetails: GuardDutyClientTypes.RemotePortDetails? = nil
        )
        {
            self.blocked = blocked
            self.connectionDirection = connectionDirection
            self.localIpDetails = localIpDetails
            self.localPortDetails = localPortDetails
            self.`protocol` = `protocol`
            self.remoteIpDetails = remoteIpDetails
            self.remotePortDetails = remotePortDetails
        }
    }

}

extension GuardDutyClientTypes.NetworkInterface: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ipv6Addresses = "ipv6Addresses"
        case networkInterfaceId = "networkInterfaceId"
        case privateDnsName = "privateDnsName"
        case privateIpAddress = "privateIpAddress"
        case privateIpAddresses = "privateIpAddresses"
        case publicDnsName = "publicDnsName"
        case publicIp = "publicIp"
        case securityGroups = "securityGroups"
        case subnetId = "subnetId"
        case vpcId = "vpcId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ipv6Addresses = ipv6Addresses {
            var ipv6AddressesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ipv6Addresses)
            for string0 in ipv6Addresses {
                try ipv6AddressesContainer.encode(string0)
            }
        }
        if let networkInterfaceId = self.networkInterfaceId {
            try encodeContainer.encode(networkInterfaceId, forKey: .networkInterfaceId)
        }
        if let privateDnsName = self.privateDnsName {
            try encodeContainer.encode(privateDnsName, forKey: .privateDnsName)
        }
        if let privateIpAddress = self.privateIpAddress {
            try encodeContainer.encode(privateIpAddress, forKey: .privateIpAddress)
        }
        if let privateIpAddresses = privateIpAddresses {
            var privateIpAddressesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .privateIpAddresses)
            for privateipaddressdetails0 in privateIpAddresses {
                try privateIpAddressesContainer.encode(privateipaddressdetails0)
            }
        }
        if let publicDnsName = self.publicDnsName {
            try encodeContainer.encode(publicDnsName, forKey: .publicDnsName)
        }
        if let publicIp = self.publicIp {
            try encodeContainer.encode(publicIp, forKey: .publicIp)
        }
        if let securityGroups = securityGroups {
            var securityGroupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroups)
            for securitygroup0 in securityGroups {
                try securityGroupsContainer.encode(securitygroup0)
            }
        }
        if let subnetId = self.subnetId {
            try encodeContainer.encode(subnetId, forKey: .subnetId)
        }
        if let vpcId = self.vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ipv6AddressesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .ipv6Addresses)
        var ipv6AddressesDecoded0:[Swift.String]? = nil
        if let ipv6AddressesContainer = ipv6AddressesContainer {
            ipv6AddressesDecoded0 = [Swift.String]()
            for string0 in ipv6AddressesContainer {
                if let string0 = string0 {
                    ipv6AddressesDecoded0?.append(string0)
                }
            }
        }
        ipv6Addresses = ipv6AddressesDecoded0
        let networkInterfaceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .networkInterfaceId)
        networkInterfaceId = networkInterfaceIdDecoded
        let privateDnsNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .privateDnsName)
        privateDnsName = privateDnsNameDecoded
        let privateIpAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .privateIpAddress)
        privateIpAddress = privateIpAddressDecoded
        let privateIpAddressesContainer = try containerValues.decodeIfPresent([GuardDutyClientTypes.PrivateIpAddressDetails?].self, forKey: .privateIpAddresses)
        var privateIpAddressesDecoded0:[GuardDutyClientTypes.PrivateIpAddressDetails]? = nil
        if let privateIpAddressesContainer = privateIpAddressesContainer {
            privateIpAddressesDecoded0 = [GuardDutyClientTypes.PrivateIpAddressDetails]()
            for structure0 in privateIpAddressesContainer {
                if let structure0 = structure0 {
                    privateIpAddressesDecoded0?.append(structure0)
                }
            }
        }
        privateIpAddresses = privateIpAddressesDecoded0
        let publicDnsNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .publicDnsName)
        publicDnsName = publicDnsNameDecoded
        let publicIpDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .publicIp)
        publicIp = publicIpDecoded
        let securityGroupsContainer = try containerValues.decodeIfPresent([GuardDutyClientTypes.SecurityGroup?].self, forKey: .securityGroups)
        var securityGroupsDecoded0:[GuardDutyClientTypes.SecurityGroup]? = nil
        if let securityGroupsContainer = securityGroupsContainer {
            securityGroupsDecoded0 = [GuardDutyClientTypes.SecurityGroup]()
            for structure0 in securityGroupsContainer {
                if let structure0 = structure0 {
                    securityGroupsDecoded0?.append(structure0)
                }
            }
        }
        securityGroups = securityGroupsDecoded0
        let subnetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subnetId)
        subnetId = subnetIdDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
    }
}

extension GuardDutyClientTypes {
    /// Contains information about the elastic network interface of the EC2 instance.
    public struct NetworkInterface: Swift.Equatable {
        /// A list of IPv6 addresses for the EC2 instance.
        public var ipv6Addresses: [Swift.String]?
        /// The ID of the network interface.
        public var networkInterfaceId: Swift.String?
        /// The private DNS name of the EC2 instance.
        public var privateDnsName: Swift.String?
        /// The private IP address of the EC2 instance.
        public var privateIpAddress: Swift.String?
        /// Other private IP address information of the EC2 instance.
        public var privateIpAddresses: [GuardDutyClientTypes.PrivateIpAddressDetails]?
        /// The public DNS name of the EC2 instance.
        public var publicDnsName: Swift.String?
        /// The public IP address of the EC2 instance.
        public var publicIp: Swift.String?
        /// The security groups associated with the EC2 instance.
        public var securityGroups: [GuardDutyClientTypes.SecurityGroup]?
        /// The subnet ID of the EC2 instance.
        public var subnetId: Swift.String?
        /// The VPC ID of the EC2 instance.
        public var vpcId: Swift.String?

        public init(
            ipv6Addresses: [Swift.String]? = nil,
            networkInterfaceId: Swift.String? = nil,
            privateDnsName: Swift.String? = nil,
            privateIpAddress: Swift.String? = nil,
            privateIpAddresses: [GuardDutyClientTypes.PrivateIpAddressDetails]? = nil,
            publicDnsName: Swift.String? = nil,
            publicIp: Swift.String? = nil,
            securityGroups: [GuardDutyClientTypes.SecurityGroup]? = nil,
            subnetId: Swift.String? = nil,
            vpcId: Swift.String? = nil
        )
        {
            self.ipv6Addresses = ipv6Addresses
            self.networkInterfaceId = networkInterfaceId
            self.privateDnsName = privateDnsName
            self.privateIpAddress = privateIpAddress
            self.privateIpAddresses = privateIpAddresses
            self.publicDnsName = publicDnsName
            self.publicIp = publicIp
            self.securityGroups = securityGroups
            self.subnetId = subnetId
            self.vpcId = vpcId
        }
    }

}

extension GuardDutyClientTypes {
    public enum OrderBy: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case asc
        case desc
        case sdkUnknown(Swift.String)

        public static var allCases: [OrderBy] {
            return [
                .asc,
                .desc,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .asc: return "ASC"
            case .desc: return "DESC"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OrderBy(rawValue: rawValue) ?? OrderBy.sdkUnknown(rawValue)
        }
    }
}

extension GuardDutyClientTypes {
    public enum OrgFeature: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ebsMalwareProtection
        case eksAuditLogs
        case eksRuntimeMonitoring
        case lambdaNetworkLogs
        case rdsLoginEvents
        case s3DataEvents
        case sdkUnknown(Swift.String)

        public static var allCases: [OrgFeature] {
            return [
                .ebsMalwareProtection,
                .eksAuditLogs,
                .eksRuntimeMonitoring,
                .lambdaNetworkLogs,
                .rdsLoginEvents,
                .s3DataEvents,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ebsMalwareProtection: return "EBS_MALWARE_PROTECTION"
            case .eksAuditLogs: return "EKS_AUDIT_LOGS"
            case .eksRuntimeMonitoring: return "EKS_RUNTIME_MONITORING"
            case .lambdaNetworkLogs: return "LAMBDA_NETWORK_LOGS"
            case .rdsLoginEvents: return "RDS_LOGIN_EVENTS"
            case .s3DataEvents: return "S3_DATA_EVENTS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OrgFeature(rawValue: rawValue) ?? OrgFeature.sdkUnknown(rawValue)
        }
    }
}

extension GuardDutyClientTypes {
    public enum OrgFeatureAdditionalConfiguration: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case eksAddonManagement
        case sdkUnknown(Swift.String)

        public static var allCases: [OrgFeatureAdditionalConfiguration] {
            return [
                .eksAddonManagement,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .eksAddonManagement: return "EKS_ADDON_MANAGEMENT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OrgFeatureAdditionalConfiguration(rawValue: rawValue) ?? OrgFeatureAdditionalConfiguration.sdkUnknown(rawValue)
        }
    }
}

extension GuardDutyClientTypes {
    public enum OrgFeatureStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case all
        case new
        case `none`
        case sdkUnknown(Swift.String)

        public static var allCases: [OrgFeatureStatus] {
            return [
                .all,
                .new,
                .none,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .all: return "ALL"
            case .new: return "NEW"
            case .none: return "NONE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OrgFeatureStatus(rawValue: rawValue) ?? OrgFeatureStatus.sdkUnknown(rawValue)
        }
    }
}

extension GuardDutyClientTypes.Organization: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case asn = "asn"
        case asnOrg = "asnOrg"
        case isp = "isp"
        case org = "org"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let asn = self.asn {
            try encodeContainer.encode(asn, forKey: .asn)
        }
        if let asnOrg = self.asnOrg {
            try encodeContainer.encode(asnOrg, forKey: .asnOrg)
        }
        if let isp = self.isp {
            try encodeContainer.encode(isp, forKey: .isp)
        }
        if let org = self.org {
            try encodeContainer.encode(org, forKey: .org)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let asnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .asn)
        asn = asnDecoded
        let asnOrgDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .asnOrg)
        asnOrg = asnOrgDecoded
        let ispDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .isp)
        isp = ispDecoded
        let orgDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .org)
        org = orgDecoded
    }
}

extension GuardDutyClientTypes {
    /// Contains information about the ISP organization of the remote IP address.
    public struct Organization: Swift.Equatable {
        /// The Autonomous System Number (ASN) of the internet provider of the remote IP address.
        public var asn: Swift.String?
        /// The organization that registered this ASN.
        public var asnOrg: Swift.String?
        /// The ISP information for the internet provider.
        public var isp: Swift.String?
        /// The name of the internet provider.
        public var org: Swift.String?

        public init(
            asn: Swift.String? = nil,
            asnOrg: Swift.String? = nil,
            isp: Swift.String? = nil,
            org: Swift.String? = nil
        )
        {
            self.asn = asn
            self.asnOrg = asnOrg
            self.isp = isp
            self.org = org
        }
    }

}

extension GuardDutyClientTypes.OrganizationAdditionalConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoEnable = "autoEnable"
        case name = "name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let autoEnable = self.autoEnable {
            try encodeContainer.encode(autoEnable.rawValue, forKey: .autoEnable)
        }
        if let name = self.name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.OrgFeatureAdditionalConfiguration.self, forKey: .name)
        name = nameDecoded
        let autoEnableDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.OrgFeatureStatus.self, forKey: .autoEnable)
        autoEnable = autoEnableDecoded
    }
}

extension GuardDutyClientTypes {
    /// A list of additional configurations which will be configured for the organization.
    public struct OrganizationAdditionalConfiguration: Swift.Equatable {
        /// The status of the additional configuration that will be configured for the organization. Use one of the following values to configure the feature status for the entire organization:
        ///
        /// * NEW: Indicates that when a new account joins the organization, they will have the additional configuration enabled automatically.
        ///
        /// * ALL: Indicates that all accounts in the organization have the additional configuration enabled automatically. This includes NEW accounts that join the organization and accounts that may have been suspended or removed from the organization in GuardDuty. It may take up to 24 hours to update the configuration for all the member accounts.
        ///
        /// * NONE: Indicates that the additional configuration will not be automatically enabled for any account in the organization. The administrator must manage the additional configuration for each account individually.
        public var autoEnable: GuardDutyClientTypes.OrgFeatureStatus?
        /// The name of the additional configuration that will be configured for the organization.
        public var name: GuardDutyClientTypes.OrgFeatureAdditionalConfiguration?

        public init(
            autoEnable: GuardDutyClientTypes.OrgFeatureStatus? = nil,
            name: GuardDutyClientTypes.OrgFeatureAdditionalConfiguration? = nil
        )
        {
            self.autoEnable = autoEnable
            self.name = name
        }
    }

}

extension GuardDutyClientTypes.OrganizationAdditionalConfigurationResult: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoEnable = "autoEnable"
        case name = "name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let autoEnable = self.autoEnable {
            try encodeContainer.encode(autoEnable.rawValue, forKey: .autoEnable)
        }
        if let name = self.name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.OrgFeatureAdditionalConfiguration.self, forKey: .name)
        name = nameDecoded
        let autoEnableDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.OrgFeatureStatus.self, forKey: .autoEnable)
        autoEnable = autoEnableDecoded
    }
}

extension GuardDutyClientTypes {
    /// A list of additional configuration which will be configured for the organization.
    public struct OrganizationAdditionalConfigurationResult: Swift.Equatable {
        /// Describes the status of the additional configuration that is configured for the member accounts within the organization. One of the following values is the status for the entire organization:
        ///
        /// * NEW: Indicates that when a new account joins the organization, they will have the additional configuration enabled automatically.
        ///
        /// * ALL: Indicates that all accounts in the organization have the additional configuration enabled automatically. This includes NEW accounts that join the organization and accounts that may have been suspended or removed from the organization in GuardDuty. It may take up to 24 hours to update the configuration for all the member accounts.
        ///
        /// * NONE: Indicates that the additional configuration will not be automatically enabled for any account in the organization. The administrator must manage the additional configuration for each account individually.
        public var autoEnable: GuardDutyClientTypes.OrgFeatureStatus?
        /// The name of the additional configuration that is configured for the member accounts within the organization.
        public var name: GuardDutyClientTypes.OrgFeatureAdditionalConfiguration?

        public init(
            autoEnable: GuardDutyClientTypes.OrgFeatureStatus? = nil,
            name: GuardDutyClientTypes.OrgFeatureAdditionalConfiguration? = nil
        )
        {
            self.autoEnable = autoEnable
            self.name = name
        }
    }

}

extension GuardDutyClientTypes.OrganizationDataSourceConfigurations: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case kubernetes = "kubernetes"
        case malwareProtection = "malwareProtection"
        case s3Logs = "s3Logs"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let kubernetes = self.kubernetes {
            try encodeContainer.encode(kubernetes, forKey: .kubernetes)
        }
        if let malwareProtection = self.malwareProtection {
            try encodeContainer.encode(malwareProtection, forKey: .malwareProtection)
        }
        if let s3Logs = self.s3Logs {
            try encodeContainer.encode(s3Logs, forKey: .s3Logs)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3LogsDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.OrganizationS3LogsConfiguration.self, forKey: .s3Logs)
        s3Logs = s3LogsDecoded
        let kubernetesDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.OrganizationKubernetesConfiguration.self, forKey: .kubernetes)
        kubernetes = kubernetesDecoded
        let malwareProtectionDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.OrganizationMalwareProtectionConfiguration.self, forKey: .malwareProtection)
        malwareProtection = malwareProtectionDecoded
    }
}

extension GuardDutyClientTypes {
    /// An object that contains information on which data sources will be configured to be automatically enabled for new members within the organization.
    public struct OrganizationDataSourceConfigurations: Swift.Equatable {
        /// Describes the configuration of Kubernetes data sources for new members of the organization.
        public var kubernetes: GuardDutyClientTypes.OrganizationKubernetesConfiguration?
        /// Describes the configuration of Malware Protection for new members of the organization.
        public var malwareProtection: GuardDutyClientTypes.OrganizationMalwareProtectionConfiguration?
        /// Describes whether S3 data event logs are enabled for new members of the organization.
        public var s3Logs: GuardDutyClientTypes.OrganizationS3LogsConfiguration?

        public init(
            kubernetes: GuardDutyClientTypes.OrganizationKubernetesConfiguration? = nil,
            malwareProtection: GuardDutyClientTypes.OrganizationMalwareProtectionConfiguration? = nil,
            s3Logs: GuardDutyClientTypes.OrganizationS3LogsConfiguration? = nil
        )
        {
            self.kubernetes = kubernetes
            self.malwareProtection = malwareProtection
            self.s3Logs = s3Logs
        }
    }

}

extension GuardDutyClientTypes.OrganizationDataSourceConfigurationsResult: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case kubernetes = "kubernetes"
        case malwareProtection = "malwareProtection"
        case s3Logs = "s3Logs"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let kubernetes = self.kubernetes {
            try encodeContainer.encode(kubernetes, forKey: .kubernetes)
        }
        if let malwareProtection = self.malwareProtection {
            try encodeContainer.encode(malwareProtection, forKey: .malwareProtection)
        }
        if let s3Logs = self.s3Logs {
            try encodeContainer.encode(s3Logs, forKey: .s3Logs)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3LogsDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.OrganizationS3LogsConfigurationResult.self, forKey: .s3Logs)
        s3Logs = s3LogsDecoded
        let kubernetesDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.OrganizationKubernetesConfigurationResult.self, forKey: .kubernetes)
        kubernetes = kubernetesDecoded
        let malwareProtectionDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.OrganizationMalwareProtectionConfigurationResult.self, forKey: .malwareProtection)
        malwareProtection = malwareProtectionDecoded
    }
}

extension GuardDutyClientTypes {
    /// An object that contains information on which data sources are automatically enabled for new members within the organization.
    public struct OrganizationDataSourceConfigurationsResult: Swift.Equatable {
        /// Describes the configuration of Kubernetes data sources.
        public var kubernetes: GuardDutyClientTypes.OrganizationKubernetesConfigurationResult?
        /// Describes the configuration of Malware Protection data source for an organization.
        public var malwareProtection: GuardDutyClientTypes.OrganizationMalwareProtectionConfigurationResult?
        /// Describes whether S3 data event logs are enabled as a data source.
        /// This member is required.
        public var s3Logs: GuardDutyClientTypes.OrganizationS3LogsConfigurationResult?

        public init(
            kubernetes: GuardDutyClientTypes.OrganizationKubernetesConfigurationResult? = nil,
            malwareProtection: GuardDutyClientTypes.OrganizationMalwareProtectionConfigurationResult? = nil,
            s3Logs: GuardDutyClientTypes.OrganizationS3LogsConfigurationResult? = nil
        )
        {
            self.kubernetes = kubernetes
            self.malwareProtection = malwareProtection
            self.s3Logs = s3Logs
        }
    }

}

extension GuardDutyClientTypes.OrganizationEbsVolumes: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoEnable = "autoEnable"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if autoEnable != false {
            try encodeContainer.encode(autoEnable, forKey: .autoEnable)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let autoEnableDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .autoEnable) ?? false
        autoEnable = autoEnableDecoded
    }
}

extension GuardDutyClientTypes {
    /// Organization-wide EBS volumes scan configuration.
    public struct OrganizationEbsVolumes: Swift.Equatable {
        /// Whether scanning EBS volumes should be auto-enabled for new members joining the organization.
        public var autoEnable: Swift.Bool

        public init(
            autoEnable: Swift.Bool = false
        )
        {
            self.autoEnable = autoEnable
        }
    }

}

extension GuardDutyClientTypes.OrganizationEbsVolumesResult: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoEnable = "autoEnable"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if autoEnable != false {
            try encodeContainer.encode(autoEnable, forKey: .autoEnable)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let autoEnableDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .autoEnable) ?? false
        autoEnable = autoEnableDecoded
    }
}

extension GuardDutyClientTypes {
    /// An object that contains information on the status of whether EBS volumes scanning will be enabled as a data source for an organization.
    public struct OrganizationEbsVolumesResult: Swift.Equatable {
        /// An object that contains the status of whether scanning EBS volumes should be auto-enabled for new members joining the organization.
        public var autoEnable: Swift.Bool

        public init(
            autoEnable: Swift.Bool = false
        )
        {
            self.autoEnable = autoEnable
        }
    }

}

extension GuardDutyClientTypes.OrganizationFeatureConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case additionalConfiguration = "additionalConfiguration"
        case autoEnable = "autoEnable"
        case name = "name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let additionalConfiguration = additionalConfiguration {
            var additionalConfigurationContainer = encodeContainer.nestedUnkeyedContainer(forKey: .additionalConfiguration)
            for organizationadditionalconfiguration0 in additionalConfiguration {
                try additionalConfigurationContainer.encode(organizationadditionalconfiguration0)
            }
        }
        if let autoEnable = self.autoEnable {
            try encodeContainer.encode(autoEnable.rawValue, forKey: .autoEnable)
        }
        if let name = self.name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.OrgFeature.self, forKey: .name)
        name = nameDecoded
        let autoEnableDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.OrgFeatureStatus.self, forKey: .autoEnable)
        autoEnable = autoEnableDecoded
        let additionalConfigurationContainer = try containerValues.decodeIfPresent([GuardDutyClientTypes.OrganizationAdditionalConfiguration?].self, forKey: .additionalConfiguration)
        var additionalConfigurationDecoded0:[GuardDutyClientTypes.OrganizationAdditionalConfiguration]? = nil
        if let additionalConfigurationContainer = additionalConfigurationContainer {
            additionalConfigurationDecoded0 = [GuardDutyClientTypes.OrganizationAdditionalConfiguration]()
            for structure0 in additionalConfigurationContainer {
                if let structure0 = structure0 {
                    additionalConfigurationDecoded0?.append(structure0)
                }
            }
        }
        additionalConfiguration = additionalConfigurationDecoded0
    }
}

extension GuardDutyClientTypes {
    /// A list of features which will be configured for the organization.
    public struct OrganizationFeatureConfiguration: Swift.Equatable {
        /// The additional information that will be configured for the organization.
        public var additionalConfiguration: [GuardDutyClientTypes.OrganizationAdditionalConfiguration]?
        /// Describes the status of the feature that is configured for the member accounts within the organization. One of the following values is the status for the entire organization:
        ///
        /// * NEW: Indicates that when a new account joins the organization, they will have the feature enabled automatically.
        ///
        /// * ALL: Indicates that all accounts in the organization have the feature enabled automatically. This includes NEW accounts that join the organization and accounts that may have been suspended or removed from the organization in GuardDuty. It may take up to 24 hours to update the configuration for all the member accounts.
        ///
        /// * NONE: Indicates that the feature will not be automatically enabled for any account in the organization. The administrator must manage the feature for each account individually.
        public var autoEnable: GuardDutyClientTypes.OrgFeatureStatus?
        /// The name of the feature that will be configured for the organization.
        public var name: GuardDutyClientTypes.OrgFeature?

        public init(
            additionalConfiguration: [GuardDutyClientTypes.OrganizationAdditionalConfiguration]? = nil,
            autoEnable: GuardDutyClientTypes.OrgFeatureStatus? = nil,
            name: GuardDutyClientTypes.OrgFeature? = nil
        )
        {
            self.additionalConfiguration = additionalConfiguration
            self.autoEnable = autoEnable
            self.name = name
        }
    }

}

extension GuardDutyClientTypes.OrganizationFeatureConfigurationResult: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case additionalConfiguration = "additionalConfiguration"
        case autoEnable = "autoEnable"
        case name = "name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let additionalConfiguration = additionalConfiguration {
            var additionalConfigurationContainer = encodeContainer.nestedUnkeyedContainer(forKey: .additionalConfiguration)
            for organizationadditionalconfigurationresult0 in additionalConfiguration {
                try additionalConfigurationContainer.encode(organizationadditionalconfigurationresult0)
            }
        }
        if let autoEnable = self.autoEnable {
            try encodeContainer.encode(autoEnable.rawValue, forKey: .autoEnable)
        }
        if let name = self.name {
            try encodeContainer.encode(name.rawValue, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.OrgFeature.self, forKey: .name)
        name = nameDecoded
        let autoEnableDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.OrgFeatureStatus.self, forKey: .autoEnable)
        autoEnable = autoEnableDecoded
        let additionalConfigurationContainer = try containerValues.decodeIfPresent([GuardDutyClientTypes.OrganizationAdditionalConfigurationResult?].self, forKey: .additionalConfiguration)
        var additionalConfigurationDecoded0:[GuardDutyClientTypes.OrganizationAdditionalConfigurationResult]? = nil
        if let additionalConfigurationContainer = additionalConfigurationContainer {
            additionalConfigurationDecoded0 = [GuardDutyClientTypes.OrganizationAdditionalConfigurationResult]()
            for structure0 in additionalConfigurationContainer {
                if let structure0 = structure0 {
                    additionalConfigurationDecoded0?.append(structure0)
                }
            }
        }
        additionalConfiguration = additionalConfigurationDecoded0
    }
}

extension GuardDutyClientTypes {
    /// A list of features which will be configured for the organization.
    public struct OrganizationFeatureConfigurationResult: Swift.Equatable {
        /// The additional configuration that is configured for the member accounts within the organization.
        public var additionalConfiguration: [GuardDutyClientTypes.OrganizationAdditionalConfigurationResult]?
        /// Describes the status of the feature that is configured for the member accounts within the organization.
        ///
        /// * NEW: Indicates that when a new account joins the organization, they will have the feature enabled automatically.
        ///
        /// * ALL: Indicates that all accounts in the organization have the feature enabled automatically. This includes NEW accounts that join the organization and accounts that may have been suspended or removed from the organization in GuardDuty.
        ///
        /// * NONE: Indicates that the feature will not be automatically enabled for any account in the organization. In this case, each account will be managed individually by the administrator.
        public var autoEnable: GuardDutyClientTypes.OrgFeatureStatus?
        /// The name of the feature that is configured for the member accounts within the organization.
        public var name: GuardDutyClientTypes.OrgFeature?

        public init(
            additionalConfiguration: [GuardDutyClientTypes.OrganizationAdditionalConfigurationResult]? = nil,
            autoEnable: GuardDutyClientTypes.OrgFeatureStatus? = nil,
            name: GuardDutyClientTypes.OrgFeature? = nil
        )
        {
            self.additionalConfiguration = additionalConfiguration
            self.autoEnable = autoEnable
            self.name = name
        }
    }

}

extension GuardDutyClientTypes.OrganizationKubernetesAuditLogsConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoEnable = "autoEnable"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if autoEnable != false {
            try encodeContainer.encode(autoEnable, forKey: .autoEnable)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let autoEnableDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .autoEnable) ?? false
        autoEnable = autoEnableDecoded
    }
}

extension GuardDutyClientTypes {
    /// Organization-wide Kubernetes audit logs configuration.
    public struct OrganizationKubernetesAuditLogsConfiguration: Swift.Equatable {
        /// A value that contains information on whether Kubernetes audit logs should be enabled automatically as a data source for the organization.
        /// This member is required.
        public var autoEnable: Swift.Bool

        public init(
            autoEnable: Swift.Bool = false
        )
        {
            self.autoEnable = autoEnable
        }
    }

}

extension GuardDutyClientTypes.OrganizationKubernetesAuditLogsConfigurationResult: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoEnable = "autoEnable"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if autoEnable != false {
            try encodeContainer.encode(autoEnable, forKey: .autoEnable)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let autoEnableDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .autoEnable) ?? false
        autoEnable = autoEnableDecoded
    }
}

extension GuardDutyClientTypes {
    /// The current configuration of Kubernetes audit logs as a data source for the organization.
    public struct OrganizationKubernetesAuditLogsConfigurationResult: Swift.Equatable {
        /// Whether Kubernetes audit logs data source should be auto-enabled for new members joining the organization.
        /// This member is required.
        public var autoEnable: Swift.Bool

        public init(
            autoEnable: Swift.Bool = false
        )
        {
            self.autoEnable = autoEnable
        }
    }

}

extension GuardDutyClientTypes.OrganizationKubernetesConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case auditLogs = "auditLogs"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let auditLogs = self.auditLogs {
            try encodeContainer.encode(auditLogs, forKey: .auditLogs)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let auditLogsDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.OrganizationKubernetesAuditLogsConfiguration.self, forKey: .auditLogs)
        auditLogs = auditLogsDecoded
    }
}

extension GuardDutyClientTypes {
    /// Organization-wide Kubernetes data sources configurations.
    public struct OrganizationKubernetesConfiguration: Swift.Equatable {
        /// Whether Kubernetes audit logs data source should be auto-enabled for new members joining the organization.
        /// This member is required.
        public var auditLogs: GuardDutyClientTypes.OrganizationKubernetesAuditLogsConfiguration?

        public init(
            auditLogs: GuardDutyClientTypes.OrganizationKubernetesAuditLogsConfiguration? = nil
        )
        {
            self.auditLogs = auditLogs
        }
    }

}

extension GuardDutyClientTypes.OrganizationKubernetesConfigurationResult: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case auditLogs = "auditLogs"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let auditLogs = self.auditLogs {
            try encodeContainer.encode(auditLogs, forKey: .auditLogs)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let auditLogsDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.OrganizationKubernetesAuditLogsConfigurationResult.self, forKey: .auditLogs)
        auditLogs = auditLogsDecoded
    }
}

extension GuardDutyClientTypes {
    /// The current configuration of all Kubernetes data sources for the organization.
    public struct OrganizationKubernetesConfigurationResult: Swift.Equatable {
        /// The current configuration of Kubernetes audit logs as a data source for the organization.
        /// This member is required.
        public var auditLogs: GuardDutyClientTypes.OrganizationKubernetesAuditLogsConfigurationResult?

        public init(
            auditLogs: GuardDutyClientTypes.OrganizationKubernetesAuditLogsConfigurationResult? = nil
        )
        {
            self.auditLogs = auditLogs
        }
    }

}

extension GuardDutyClientTypes.OrganizationMalwareProtectionConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case scanEc2InstanceWithFindings = "scanEc2InstanceWithFindings"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let scanEc2InstanceWithFindings = self.scanEc2InstanceWithFindings {
            try encodeContainer.encode(scanEc2InstanceWithFindings, forKey: .scanEc2InstanceWithFindings)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scanEc2InstanceWithFindingsDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.OrganizationScanEc2InstanceWithFindings.self, forKey: .scanEc2InstanceWithFindings)
        scanEc2InstanceWithFindings = scanEc2InstanceWithFindingsDecoded
    }
}

extension GuardDutyClientTypes {
    /// Organization-wide Malware Protection configurations.
    public struct OrganizationMalwareProtectionConfiguration: Swift.Equatable {
        /// Whether Malware Protection for EC2 instances with findings should be auto-enabled for new members joining the organization.
        public var scanEc2InstanceWithFindings: GuardDutyClientTypes.OrganizationScanEc2InstanceWithFindings?

        public init(
            scanEc2InstanceWithFindings: GuardDutyClientTypes.OrganizationScanEc2InstanceWithFindings? = nil
        )
        {
            self.scanEc2InstanceWithFindings = scanEc2InstanceWithFindings
        }
    }

}

extension GuardDutyClientTypes.OrganizationMalwareProtectionConfigurationResult: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case scanEc2InstanceWithFindings = "scanEc2InstanceWithFindings"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let scanEc2InstanceWithFindings = self.scanEc2InstanceWithFindings {
            try encodeContainer.encode(scanEc2InstanceWithFindings, forKey: .scanEc2InstanceWithFindings)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scanEc2InstanceWithFindingsDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.OrganizationScanEc2InstanceWithFindingsResult.self, forKey: .scanEc2InstanceWithFindings)
        scanEc2InstanceWithFindings = scanEc2InstanceWithFindingsDecoded
    }
}

extension GuardDutyClientTypes {
    /// An object that contains information on the status of all Malware Protection data source for an organization.
    public struct OrganizationMalwareProtectionConfigurationResult: Swift.Equatable {
        /// Describes the configuration for scanning EC2 instances with findings for an organization.
        public var scanEc2InstanceWithFindings: GuardDutyClientTypes.OrganizationScanEc2InstanceWithFindingsResult?

        public init(
            scanEc2InstanceWithFindings: GuardDutyClientTypes.OrganizationScanEc2InstanceWithFindingsResult? = nil
        )
        {
            self.scanEc2InstanceWithFindings = scanEc2InstanceWithFindings
        }
    }

}

extension GuardDutyClientTypes.OrganizationS3LogsConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoEnable = "autoEnable"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if autoEnable != false {
            try encodeContainer.encode(autoEnable, forKey: .autoEnable)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let autoEnableDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .autoEnable) ?? false
        autoEnable = autoEnableDecoded
    }
}

extension GuardDutyClientTypes {
    /// Describes whether S3 data event logs will be automatically enabled for new members of the organization.
    public struct OrganizationS3LogsConfiguration: Swift.Equatable {
        /// A value that contains information on whether S3 data event logs will be enabled automatically as a data source for the organization.
        /// This member is required.
        public var autoEnable: Swift.Bool

        public init(
            autoEnable: Swift.Bool = false
        )
        {
            self.autoEnable = autoEnable
        }
    }

}

extension GuardDutyClientTypes.OrganizationS3LogsConfigurationResult: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoEnable = "autoEnable"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if autoEnable != false {
            try encodeContainer.encode(autoEnable, forKey: .autoEnable)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let autoEnableDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .autoEnable) ?? false
        autoEnable = autoEnableDecoded
    }
}

extension GuardDutyClientTypes {
    /// The current configuration of S3 data event logs as a data source for the organization.
    public struct OrganizationS3LogsConfigurationResult: Swift.Equatable {
        /// A value that describes whether S3 data event logs are automatically enabled for new members of the organization.
        /// This member is required.
        public var autoEnable: Swift.Bool

        public init(
            autoEnable: Swift.Bool = false
        )
        {
            self.autoEnable = autoEnable
        }
    }

}

extension GuardDutyClientTypes.OrganizationScanEc2InstanceWithFindings: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ebsVolumes = "ebsVolumes"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ebsVolumes = self.ebsVolumes {
            try encodeContainer.encode(ebsVolumes, forKey: .ebsVolumes)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ebsVolumesDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.OrganizationEbsVolumes.self, forKey: .ebsVolumes)
        ebsVolumes = ebsVolumesDecoded
    }
}

extension GuardDutyClientTypes {
    /// Organization-wide EC2 instances with findings scan configuration.
    public struct OrganizationScanEc2InstanceWithFindings: Swift.Equatable {
        /// Whether scanning EBS volumes should be auto-enabled for new members joining the organization.
        public var ebsVolumes: GuardDutyClientTypes.OrganizationEbsVolumes?

        public init(
            ebsVolumes: GuardDutyClientTypes.OrganizationEbsVolumes? = nil
        )
        {
            self.ebsVolumes = ebsVolumes
        }
    }

}

extension GuardDutyClientTypes.OrganizationScanEc2InstanceWithFindingsResult: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ebsVolumes = "ebsVolumes"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ebsVolumes = self.ebsVolumes {
            try encodeContainer.encode(ebsVolumes, forKey: .ebsVolumes)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ebsVolumesDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.OrganizationEbsVolumesResult.self, forKey: .ebsVolumes)
        ebsVolumes = ebsVolumesDecoded
    }
}

extension GuardDutyClientTypes {
    /// An object that contains information on the status of scanning EC2 instances with findings for an organization.
    public struct OrganizationScanEc2InstanceWithFindingsResult: Swift.Equatable {
        /// Describes the configuration for scanning EBS volumes for an organization.
        public var ebsVolumes: GuardDutyClientTypes.OrganizationEbsVolumesResult?

        public init(
            ebsVolumes: GuardDutyClientTypes.OrganizationEbsVolumesResult? = nil
        )
        {
            self.ebsVolumes = ebsVolumes
        }
    }

}

extension GuardDutyClientTypes.Owner: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id = "id"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
    }
}

extension GuardDutyClientTypes {
    /// Contains information on the owner of the bucket.
    public struct Owner: Swift.Equatable {
        /// The canonical user ID of the bucket owner. For information about locating your canonical user ID see [Finding Your Account Canonical User ID.](https://docs.aws.amazon.com/general/latest/gr/acct-identifiers.html#FindingCanonicalId)
        public var id: Swift.String?

        public init(
            id: Swift.String? = nil
        )
        {
            self.id = id
        }
    }

}

extension GuardDutyClientTypes.PermissionConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountLevelPermissions = "accountLevelPermissions"
        case bucketLevelPermissions = "bucketLevelPermissions"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountLevelPermissions = self.accountLevelPermissions {
            try encodeContainer.encode(accountLevelPermissions, forKey: .accountLevelPermissions)
        }
        if let bucketLevelPermissions = self.bucketLevelPermissions {
            try encodeContainer.encode(bucketLevelPermissions, forKey: .bucketLevelPermissions)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketLevelPermissionsDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.BucketLevelPermissions.self, forKey: .bucketLevelPermissions)
        bucketLevelPermissions = bucketLevelPermissionsDecoded
        let accountLevelPermissionsDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.AccountLevelPermissions.self, forKey: .accountLevelPermissions)
        accountLevelPermissions = accountLevelPermissionsDecoded
    }
}

extension GuardDutyClientTypes {
    /// Contains information about how permissions are configured for the S3 bucket.
    public struct PermissionConfiguration: Swift.Equatable {
        /// Contains information about the account level permissions on the S3 bucket.
        public var accountLevelPermissions: GuardDutyClientTypes.AccountLevelPermissions?
        /// Contains information about the bucket level permissions for the S3 bucket.
        public var bucketLevelPermissions: GuardDutyClientTypes.BucketLevelPermissions?

        public init(
            accountLevelPermissions: GuardDutyClientTypes.AccountLevelPermissions? = nil,
            bucketLevelPermissions: GuardDutyClientTypes.BucketLevelPermissions? = nil
        )
        {
            self.accountLevelPermissions = accountLevelPermissions
            self.bucketLevelPermissions = bucketLevelPermissions
        }
    }

}

extension GuardDutyClientTypes.PortProbeAction: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case blocked = "blocked"
        case portProbeDetails = "portProbeDetails"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if blocked != false {
            try encodeContainer.encode(blocked, forKey: .blocked)
        }
        if let portProbeDetails = portProbeDetails {
            var portProbeDetailsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .portProbeDetails)
            for portprobedetail0 in portProbeDetails {
                try portProbeDetailsContainer.encode(portprobedetail0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let blockedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .blocked) ?? false
        blocked = blockedDecoded
        let portProbeDetailsContainer = try containerValues.decodeIfPresent([GuardDutyClientTypes.PortProbeDetail?].self, forKey: .portProbeDetails)
        var portProbeDetailsDecoded0:[GuardDutyClientTypes.PortProbeDetail]? = nil
        if let portProbeDetailsContainer = portProbeDetailsContainer {
            portProbeDetailsDecoded0 = [GuardDutyClientTypes.PortProbeDetail]()
            for structure0 in portProbeDetailsContainer {
                if let structure0 = structure0 {
                    portProbeDetailsDecoded0?.append(structure0)
                }
            }
        }
        portProbeDetails = portProbeDetailsDecoded0
    }
}

extension GuardDutyClientTypes {
    /// Contains information about the PORT_PROBE action described in the finding.
    public struct PortProbeAction: Swift.Equatable {
        /// Indicates whether EC2 blocked the port probe to the instance, such as with an ACL.
        public var blocked: Swift.Bool
        /// A list of objects related to port probe details.
        public var portProbeDetails: [GuardDutyClientTypes.PortProbeDetail]?

        public init(
            blocked: Swift.Bool = false,
            portProbeDetails: [GuardDutyClientTypes.PortProbeDetail]? = nil
        )
        {
            self.blocked = blocked
            self.portProbeDetails = portProbeDetails
        }
    }

}

extension GuardDutyClientTypes.PortProbeDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case localIpDetails = "localIpDetails"
        case localPortDetails = "localPortDetails"
        case remoteIpDetails = "remoteIpDetails"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let localIpDetails = self.localIpDetails {
            try encodeContainer.encode(localIpDetails, forKey: .localIpDetails)
        }
        if let localPortDetails = self.localPortDetails {
            try encodeContainer.encode(localPortDetails, forKey: .localPortDetails)
        }
        if let remoteIpDetails = self.remoteIpDetails {
            try encodeContainer.encode(remoteIpDetails, forKey: .remoteIpDetails)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let localPortDetailsDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.LocalPortDetails.self, forKey: .localPortDetails)
        localPortDetails = localPortDetailsDecoded
        let localIpDetailsDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.LocalIpDetails.self, forKey: .localIpDetails)
        localIpDetails = localIpDetailsDecoded
        let remoteIpDetailsDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.RemoteIpDetails.self, forKey: .remoteIpDetails)
        remoteIpDetails = remoteIpDetailsDecoded
    }
}

extension GuardDutyClientTypes {
    /// Contains information about the port probe details.
    public struct PortProbeDetail: Swift.Equatable {
        /// The local IP information of the connection.
        public var localIpDetails: GuardDutyClientTypes.LocalIpDetails?
        /// The local port information of the connection.
        public var localPortDetails: GuardDutyClientTypes.LocalPortDetails?
        /// The remote IP information of the connection.
        public var remoteIpDetails: GuardDutyClientTypes.RemoteIpDetails?

        public init(
            localIpDetails: GuardDutyClientTypes.LocalIpDetails? = nil,
            localPortDetails: GuardDutyClientTypes.LocalPortDetails? = nil,
            remoteIpDetails: GuardDutyClientTypes.RemoteIpDetails? = nil
        )
        {
            self.localIpDetails = localIpDetails
            self.localPortDetails = localPortDetails
            self.remoteIpDetails = remoteIpDetails
        }
    }

}

extension GuardDutyClientTypes.PrivateIpAddressDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case privateDnsName = "privateDnsName"
        case privateIpAddress = "privateIpAddress"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let privateDnsName = self.privateDnsName {
            try encodeContainer.encode(privateDnsName, forKey: .privateDnsName)
        }
        if let privateIpAddress = self.privateIpAddress {
            try encodeContainer.encode(privateIpAddress, forKey: .privateIpAddress)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let privateDnsNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .privateDnsName)
        privateDnsName = privateDnsNameDecoded
        let privateIpAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .privateIpAddress)
        privateIpAddress = privateIpAddressDecoded
    }
}

extension GuardDutyClientTypes {
    /// Contains other private IP address information of the EC2 instance.
    public struct PrivateIpAddressDetails: Swift.Equatable {
        /// The private DNS name of the EC2 instance.
        public var privateDnsName: Swift.String?
        /// The private IP address of the EC2 instance.
        public var privateIpAddress: Swift.String?

        public init(
            privateDnsName: Swift.String? = nil,
            privateIpAddress: Swift.String? = nil
        )
        {
            self.privateDnsName = privateDnsName
            self.privateIpAddress = privateIpAddress
        }
    }

}

extension GuardDutyClientTypes.ProcessDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case euid = "euid"
        case executablePath = "executablePath"
        case executableSha256 = "executableSha256"
        case lineage = "lineage"
        case name = "name"
        case namespacePid = "namespacePid"
        case parentUuid = "parentUuid"
        case pid = "pid"
        case pwd = "pwd"
        case startTime = "startTime"
        case user = "user"
        case userId = "userId"
        case uuid = "uuid"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if euid != 0 {
            try encodeContainer.encode(euid, forKey: .euid)
        }
        if let executablePath = self.executablePath {
            try encodeContainer.encode(executablePath, forKey: .executablePath)
        }
        if let executableSha256 = self.executableSha256 {
            try encodeContainer.encode(executableSha256, forKey: .executableSha256)
        }
        if let lineage = lineage {
            var lineageContainer = encodeContainer.nestedUnkeyedContainer(forKey: .lineage)
            for lineageobject0 in lineage {
                try lineageContainer.encode(lineageobject0)
            }
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if namespacePid != 0 {
            try encodeContainer.encode(namespacePid, forKey: .namespacePid)
        }
        if let parentUuid = self.parentUuid {
            try encodeContainer.encode(parentUuid, forKey: .parentUuid)
        }
        if pid != 0 {
            try encodeContainer.encode(pid, forKey: .pid)
        }
        if let pwd = self.pwd {
            try encodeContainer.encode(pwd, forKey: .pwd)
        }
        if let startTime = self.startTime {
            try encodeContainer.encodeTimestamp(startTime, format: .epochSeconds, forKey: .startTime)
        }
        if let user = self.user {
            try encodeContainer.encode(user, forKey: .user)
        }
        if userId != 0 {
            try encodeContainer.encode(userId, forKey: .userId)
        }
        if let uuid = self.uuid {
            try encodeContainer.encode(uuid, forKey: .uuid)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let executablePathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .executablePath)
        executablePath = executablePathDecoded
        let executableSha256Decoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .executableSha256)
        executableSha256 = executableSha256Decoded
        let namespacePidDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .namespacePid) ?? 0
        namespacePid = namespacePidDecoded
        let pwdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pwd)
        pwd = pwdDecoded
        let pidDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .pid) ?? 0
        pid = pidDecoded
        let startTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startTime)
        startTime = startTimeDecoded
        let uuidDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .uuid)
        uuid = uuidDecoded
        let parentUuidDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parentUuid)
        parentUuid = parentUuidDecoded
        let userDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .user)
        user = userDecoded
        let userIdDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .userId) ?? 0
        userId = userIdDecoded
        let euidDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .euid) ?? 0
        euid = euidDecoded
        let lineageContainer = try containerValues.decodeIfPresent([GuardDutyClientTypes.LineageObject?].self, forKey: .lineage)
        var lineageDecoded0:[GuardDutyClientTypes.LineageObject]? = nil
        if let lineageContainer = lineageContainer {
            lineageDecoded0 = [GuardDutyClientTypes.LineageObject]()
            for structure0 in lineageContainer {
                if let structure0 = structure0 {
                    lineageDecoded0?.append(structure0)
                }
            }
        }
        lineage = lineageDecoded0
    }
}

extension GuardDutyClientTypes {
    /// Information about the observed process.
    public struct ProcessDetails: Swift.Equatable {
        /// The effective user ID of the user that executed the process.
        public var euid: Swift.Int
        /// The absolute path of the process executable file.
        public var executablePath: Swift.String?
        /// The SHA256 hash of the process executable.
        public var executableSha256: Swift.String?
        /// Information about the process's lineage.
        public var lineage: [GuardDutyClientTypes.LineageObject]?
        /// The name of the process.
        public var name: Swift.String?
        /// The ID of the child process.
        public var namespacePid: Swift.Int
        /// The unique ID of the parent process. This ID is assigned to the parent process by GuardDuty.
        public var parentUuid: Swift.String?
        /// The ID of the process.
        public var pid: Swift.Int
        /// The present working directory of the process.
        public var pwd: Swift.String?
        /// The time when the process started. This is in UTC format.
        public var startTime: ClientRuntime.Date?
        /// The user that executed the process.
        public var user: Swift.String?
        /// The unique ID of the user that executed the process.
        public var userId: Swift.Int
        /// The unique ID assigned to the process by GuardDuty.
        public var uuid: Swift.String?

        public init(
            euid: Swift.Int = 0,
            executablePath: Swift.String? = nil,
            executableSha256: Swift.String? = nil,
            lineage: [GuardDutyClientTypes.LineageObject]? = nil,
            name: Swift.String? = nil,
            namespacePid: Swift.Int = 0,
            parentUuid: Swift.String? = nil,
            pid: Swift.Int = 0,
            pwd: Swift.String? = nil,
            startTime: ClientRuntime.Date? = nil,
            user: Swift.String? = nil,
            userId: Swift.Int = 0,
            uuid: Swift.String? = nil
        )
        {
            self.euid = euid
            self.executablePath = executablePath
            self.executableSha256 = executableSha256
            self.lineage = lineage
            self.name = name
            self.namespacePid = namespacePid
            self.parentUuid = parentUuid
            self.pid = pid
            self.pwd = pwd
            self.startTime = startTime
            self.user = user
            self.userId = userId
            self.uuid = uuid
        }
    }

}

extension GuardDutyClientTypes.ProductCode: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "productCodeId"
        case productType = "productCodeType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let code = self.code {
            try encodeContainer.encode(code, forKey: .code)
        }
        if let productType = self.productType {
            try encodeContainer.encode(productType, forKey: .productType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let productTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .productType)
        productType = productTypeDecoded
    }
}

extension GuardDutyClientTypes {
    /// Contains information about the product code for the EC2 instance.
    public struct ProductCode: Swift.Equatable {
        /// The product code information.
        public var code: Swift.String?
        /// The product code type.
        public var productType: Swift.String?

        public init(
            code: Swift.String? = nil,
            productType: Swift.String? = nil
        )
        {
            self.code = code
            self.productType = productType
        }
    }

}

extension GuardDutyClientTypes.PublicAccess: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case effectivePermission = "effectivePermission"
        case permissionConfiguration = "permissionConfiguration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let effectivePermission = self.effectivePermission {
            try encodeContainer.encode(effectivePermission, forKey: .effectivePermission)
        }
        if let permissionConfiguration = self.permissionConfiguration {
            try encodeContainer.encode(permissionConfiguration, forKey: .permissionConfiguration)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let permissionConfigurationDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.PermissionConfiguration.self, forKey: .permissionConfiguration)
        permissionConfiguration = permissionConfigurationDecoded
        let effectivePermissionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .effectivePermission)
        effectivePermission = effectivePermissionDecoded
    }
}

extension GuardDutyClientTypes {
    /// Describes the public access policies that apply to the S3 bucket.
    public struct PublicAccess: Swift.Equatable {
        /// Describes the effective permission on this bucket after factoring all attached policies.
        public var effectivePermission: Swift.String?
        /// Contains information about how permissions are configured for the S3 bucket.
        public var permissionConfiguration: GuardDutyClientTypes.PermissionConfiguration?

        public init(
            effectivePermission: Swift.String? = nil,
            permissionConfiguration: GuardDutyClientTypes.PermissionConfiguration? = nil
        )
        {
            self.effectivePermission = effectivePermission
            self.permissionConfiguration = permissionConfiguration
        }
    }

}

extension GuardDutyClientTypes {
    public enum PublishingStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case pendingVerification
        case publishing
        case stopped
        case unableToPublishFixDestinationProperty
        case sdkUnknown(Swift.String)

        public static var allCases: [PublishingStatus] {
            return [
                .pendingVerification,
                .publishing,
                .stopped,
                .unableToPublishFixDestinationProperty,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .pendingVerification: return "PENDING_VERIFICATION"
            case .publishing: return "PUBLISHING"
            case .stopped: return "STOPPED"
            case .unableToPublishFixDestinationProperty: return "UNABLE_TO_PUBLISH_FIX_DESTINATION_PROPERTY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PublishingStatus(rawValue: rawValue) ?? PublishingStatus.sdkUnknown(rawValue)
        }
    }
}

extension GuardDutyClientTypes.RdsDbInstanceDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dbClusterIdentifier = "dbClusterIdentifier"
        case dbInstanceArn = "dbInstanceArn"
        case dbInstanceIdentifier = "dbInstanceIdentifier"
        case engine = "engine"
        case engineVersion = "engineVersion"
        case tags = "tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dbClusterIdentifier = self.dbClusterIdentifier {
            try encodeContainer.encode(dbClusterIdentifier, forKey: .dbClusterIdentifier)
        }
        if let dbInstanceArn = self.dbInstanceArn {
            try encodeContainer.encode(dbInstanceArn, forKey: .dbInstanceArn)
        }
        if let dbInstanceIdentifier = self.dbInstanceIdentifier {
            try encodeContainer.encode(dbInstanceIdentifier, forKey: .dbInstanceIdentifier)
        }
        if let engine = self.engine {
            try encodeContainer.encode(engine, forKey: .engine)
        }
        if let engineVersion = self.engineVersion {
            try encodeContainer.encode(engineVersion, forKey: .engineVersion)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dbInstanceIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dbInstanceIdentifier)
        dbInstanceIdentifier = dbInstanceIdentifierDecoded
        let engineDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engine)
        engine = engineDecoded
        let engineVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .engineVersion)
        engineVersion = engineVersionDecoded
        let dbClusterIdentifierDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dbClusterIdentifier)
        dbClusterIdentifier = dbClusterIdentifierDecoded
        let dbInstanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .dbInstanceArn)
        dbInstanceArn = dbInstanceArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([GuardDutyClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[GuardDutyClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [GuardDutyClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension GuardDutyClientTypes {
    /// Contains information about the resource type RDSDBInstance involved in a GuardDuty finding.
    public struct RdsDbInstanceDetails: Swift.Equatable {
        /// The identifier of the database cluster that contains the database instance ID involved in the finding.
        public var dbClusterIdentifier: Swift.String?
        /// The Amazon Resource Name (ARN) that identifies the database instance involved in the finding.
        public var dbInstanceArn: Swift.String?
        /// The identifier associated to the database instance that was involved in the finding.
        public var dbInstanceIdentifier: Swift.String?
        /// The database engine of the database instance involved in the finding.
        public var engine: Swift.String?
        /// The version of the database engine that was involved in the finding.
        public var engineVersion: Swift.String?
        /// Instance tag key-value pairs associated with the database instance ID.
        public var tags: [GuardDutyClientTypes.Tag]?

        public init(
            dbClusterIdentifier: Swift.String? = nil,
            dbInstanceArn: Swift.String? = nil,
            dbInstanceIdentifier: Swift.String? = nil,
            engine: Swift.String? = nil,
            engineVersion: Swift.String? = nil,
            tags: [GuardDutyClientTypes.Tag]? = nil
        )
        {
            self.dbClusterIdentifier = dbClusterIdentifier
            self.dbInstanceArn = dbInstanceArn
            self.dbInstanceIdentifier = dbInstanceIdentifier
            self.engine = engine
            self.engineVersion = engineVersion
            self.tags = tags
        }
    }

}

extension GuardDutyClientTypes.RdsDbUserDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case application = "application"
        case authMethod = "authMethod"
        case database = "database"
        case ssl = "ssl"
        case user = "user"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let application = self.application {
            try encodeContainer.encode(application, forKey: .application)
        }
        if let authMethod = self.authMethod {
            try encodeContainer.encode(authMethod, forKey: .authMethod)
        }
        if let database = self.database {
            try encodeContainer.encode(database, forKey: .database)
        }
        if let ssl = self.ssl {
            try encodeContainer.encode(ssl, forKey: .ssl)
        }
        if let user = self.user {
            try encodeContainer.encode(user, forKey: .user)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let userDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .user)
        user = userDecoded
        let applicationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .application)
        application = applicationDecoded
        let databaseDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .database)
        database = databaseDecoded
        let sslDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ssl)
        ssl = sslDecoded
        let authMethodDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authMethod)
        authMethod = authMethodDecoded
    }
}

extension GuardDutyClientTypes {
    /// Contains information about the user and authentication details for a database instance involved in the finding.
    public struct RdsDbUserDetails: Swift.Equatable {
        /// The application name used in the anomalous login attempt.
        public var application: Swift.String?
        /// The authentication method used by the user involved in the finding.
        public var authMethod: Swift.String?
        /// The name of the database instance involved in the anomalous login attempt.
        public var database: Swift.String?
        /// The version of the Secure Socket Layer (SSL) used for the network.
        public var ssl: Swift.String?
        /// The user name used in the anomalous login attempt.
        public var user: Swift.String?

        public init(
            application: Swift.String? = nil,
            authMethod: Swift.String? = nil,
            database: Swift.String? = nil,
            ssl: Swift.String? = nil,
            user: Swift.String? = nil
        )
        {
            self.application = application
            self.authMethod = authMethod
            self.database = database
            self.ssl = ssl
            self.user = user
        }
    }

}

extension GuardDutyClientTypes.RdsLoginAttemptAction: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case loginAttributes = "LoginAttributes"
        case remoteIpDetails = "remoteIpDetails"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let loginAttributes = loginAttributes {
            var loginAttributesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .loginAttributes)
            for loginattribute0 in loginAttributes {
                try loginAttributesContainer.encode(loginattribute0)
            }
        }
        if let remoteIpDetails = self.remoteIpDetails {
            try encodeContainer.encode(remoteIpDetails, forKey: .remoteIpDetails)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let remoteIpDetailsDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.RemoteIpDetails.self, forKey: .remoteIpDetails)
        remoteIpDetails = remoteIpDetailsDecoded
        let loginAttributesContainer = try containerValues.decodeIfPresent([GuardDutyClientTypes.LoginAttribute?].self, forKey: .loginAttributes)
        var loginAttributesDecoded0:[GuardDutyClientTypes.LoginAttribute]? = nil
        if let loginAttributesContainer = loginAttributesContainer {
            loginAttributesDecoded0 = [GuardDutyClientTypes.LoginAttribute]()
            for structure0 in loginAttributesContainer {
                if let structure0 = structure0 {
                    loginAttributesDecoded0?.append(structure0)
                }
            }
        }
        loginAttributes = loginAttributesDecoded0
    }
}

extension GuardDutyClientTypes {
    /// Indicates that a login attempt was made to the potentially compromised database from a remote IP address.
    public struct RdsLoginAttemptAction: Swift.Equatable {
        /// Indicates the login attributes used in the login attempt.
        public var loginAttributes: [GuardDutyClientTypes.LoginAttribute]?
        /// Contains information about the remote IP address of the connection.
        public var remoteIpDetails: GuardDutyClientTypes.RemoteIpDetails?

        public init(
            loginAttributes: [GuardDutyClientTypes.LoginAttribute]? = nil,
            remoteIpDetails: GuardDutyClientTypes.RemoteIpDetails? = nil
        )
        {
            self.loginAttributes = loginAttributes
            self.remoteIpDetails = remoteIpDetails
        }
    }

}

extension GuardDutyClientTypes.RemoteAccountDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "accountId"
        case affiliated = "affiliated"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if affiliated != false {
            try encodeContainer.encode(affiliated, forKey: .affiliated)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let affiliatedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .affiliated) ?? false
        affiliated = affiliatedDecoded
    }
}

extension GuardDutyClientTypes {
    /// Contains details about the remote Amazon Web Services account that made the API call.
    public struct RemoteAccountDetails: Swift.Equatable {
        /// The Amazon Web Services account ID of the remote API caller.
        public var accountId: Swift.String?
        /// Details on whether the Amazon Web Services account of the remote API caller is related to your GuardDuty environment. If this value is True the API caller is affiliated to your account in some way. If it is False the API caller is from outside your environment.
        public var affiliated: Swift.Bool

        public init(
            accountId: Swift.String? = nil,
            affiliated: Swift.Bool = false
        )
        {
            self.accountId = accountId
            self.affiliated = affiliated
        }
    }

}

extension GuardDutyClientTypes.RemoteIpDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case city = "city"
        case country = "country"
        case geoLocation = "geoLocation"
        case ipAddressV4 = "ipAddressV4"
        case organization = "organization"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let city = self.city {
            try encodeContainer.encode(city, forKey: .city)
        }
        if let country = self.country {
            try encodeContainer.encode(country, forKey: .country)
        }
        if let geoLocation = self.geoLocation {
            try encodeContainer.encode(geoLocation, forKey: .geoLocation)
        }
        if let ipAddressV4 = self.ipAddressV4 {
            try encodeContainer.encode(ipAddressV4, forKey: .ipAddressV4)
        }
        if let organization = self.organization {
            try encodeContainer.encode(organization, forKey: .organization)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cityDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.City.self, forKey: .city)
        city = cityDecoded
        let countryDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.Country.self, forKey: .country)
        country = countryDecoded
        let geoLocationDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.GeoLocation.self, forKey: .geoLocation)
        geoLocation = geoLocationDecoded
        let ipAddressV4Decoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ipAddressV4)
        ipAddressV4 = ipAddressV4Decoded
        let organizationDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.Organization.self, forKey: .organization)
        organization = organizationDecoded
    }
}

extension GuardDutyClientTypes {
    /// Contains information about the remote IP address of the connection.
    public struct RemoteIpDetails: Swift.Equatable {
        /// The city information of the remote IP address.
        public var city: GuardDutyClientTypes.City?
        /// The country code of the remote IP address.
        public var country: GuardDutyClientTypes.Country?
        /// The location information of the remote IP address.
        public var geoLocation: GuardDutyClientTypes.GeoLocation?
        /// The IPv4 remote address of the connection.
        public var ipAddressV4: Swift.String?
        /// The ISP organization information of the remote IP address.
        public var organization: GuardDutyClientTypes.Organization?

        public init(
            city: GuardDutyClientTypes.City? = nil,
            country: GuardDutyClientTypes.Country? = nil,
            geoLocation: GuardDutyClientTypes.GeoLocation? = nil,
            ipAddressV4: Swift.String? = nil,
            organization: GuardDutyClientTypes.Organization? = nil
        )
        {
            self.city = city
            self.country = country
            self.geoLocation = geoLocation
            self.ipAddressV4 = ipAddressV4
            self.organization = organization
        }
    }

}

extension GuardDutyClientTypes.RemotePortDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case port = "port"
        case portName = "portName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if port != 0 {
            try encodeContainer.encode(port, forKey: .port)
        }
        if let portName = self.portName {
            try encodeContainer.encode(portName, forKey: .portName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let portDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .port) ?? 0
        port = portDecoded
        let portNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .portName)
        portName = portNameDecoded
    }
}

extension GuardDutyClientTypes {
    /// Contains information about the remote port.
    public struct RemotePortDetails: Swift.Equatable {
        /// The port number of the remote connection.
        public var port: Swift.Int
        /// The port name of the remote connection.
        public var portName: Swift.String?

        public init(
            port: Swift.Int = 0,
            portName: Swift.String? = nil
        )
        {
            self.port = port
            self.portName = portName
        }
    }

}

extension GuardDutyClientTypes.Resource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessKeyDetails = "accessKeyDetails"
        case containerDetails = "containerDetails"
        case ebsVolumeDetails = "ebsVolumeDetails"
        case ecsClusterDetails = "ecsClusterDetails"
        case eksClusterDetails = "eksClusterDetails"
        case instanceDetails = "instanceDetails"
        case kubernetesDetails = "kubernetesDetails"
        case lambdaDetails = "lambdaDetails"
        case rdsDbInstanceDetails = "rdsDbInstanceDetails"
        case rdsDbUserDetails = "rdsDbUserDetails"
        case resourceType = "resourceType"
        case s3BucketDetails = "s3BucketDetails"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessKeyDetails = self.accessKeyDetails {
            try encodeContainer.encode(accessKeyDetails, forKey: .accessKeyDetails)
        }
        if let containerDetails = self.containerDetails {
            try encodeContainer.encode(containerDetails, forKey: .containerDetails)
        }
        if let ebsVolumeDetails = self.ebsVolumeDetails {
            try encodeContainer.encode(ebsVolumeDetails, forKey: .ebsVolumeDetails)
        }
        if let ecsClusterDetails = self.ecsClusterDetails {
            try encodeContainer.encode(ecsClusterDetails, forKey: .ecsClusterDetails)
        }
        if let eksClusterDetails = self.eksClusterDetails {
            try encodeContainer.encode(eksClusterDetails, forKey: .eksClusterDetails)
        }
        if let instanceDetails = self.instanceDetails {
            try encodeContainer.encode(instanceDetails, forKey: .instanceDetails)
        }
        if let kubernetesDetails = self.kubernetesDetails {
            try encodeContainer.encode(kubernetesDetails, forKey: .kubernetesDetails)
        }
        if let lambdaDetails = self.lambdaDetails {
            try encodeContainer.encode(lambdaDetails, forKey: .lambdaDetails)
        }
        if let rdsDbInstanceDetails = self.rdsDbInstanceDetails {
            try encodeContainer.encode(rdsDbInstanceDetails, forKey: .rdsDbInstanceDetails)
        }
        if let rdsDbUserDetails = self.rdsDbUserDetails {
            try encodeContainer.encode(rdsDbUserDetails, forKey: .rdsDbUserDetails)
        }
        if let resourceType = self.resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
        if let s3BucketDetails = s3BucketDetails {
            var s3BucketDetailsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .s3BucketDetails)
            for s3bucketdetail0 in s3BucketDetails {
                try s3BucketDetailsContainer.encode(s3bucketdetail0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessKeyDetailsDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.AccessKeyDetails.self, forKey: .accessKeyDetails)
        accessKeyDetails = accessKeyDetailsDecoded
        let s3BucketDetailsContainer = try containerValues.decodeIfPresent([GuardDutyClientTypes.S3BucketDetail?].self, forKey: .s3BucketDetails)
        var s3BucketDetailsDecoded0:[GuardDutyClientTypes.S3BucketDetail]? = nil
        if let s3BucketDetailsContainer = s3BucketDetailsContainer {
            s3BucketDetailsDecoded0 = [GuardDutyClientTypes.S3BucketDetail]()
            for structure0 in s3BucketDetailsContainer {
                if let structure0 = structure0 {
                    s3BucketDetailsDecoded0?.append(structure0)
                }
            }
        }
        s3BucketDetails = s3BucketDetailsDecoded0
        let instanceDetailsDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.InstanceDetails.self, forKey: .instanceDetails)
        instanceDetails = instanceDetailsDecoded
        let eksClusterDetailsDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.EksClusterDetails.self, forKey: .eksClusterDetails)
        eksClusterDetails = eksClusterDetailsDecoded
        let kubernetesDetailsDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.KubernetesDetails.self, forKey: .kubernetesDetails)
        kubernetesDetails = kubernetesDetailsDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let ebsVolumeDetailsDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.EbsVolumeDetails.self, forKey: .ebsVolumeDetails)
        ebsVolumeDetails = ebsVolumeDetailsDecoded
        let ecsClusterDetailsDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.EcsClusterDetails.self, forKey: .ecsClusterDetails)
        ecsClusterDetails = ecsClusterDetailsDecoded
        let containerDetailsDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.Container.self, forKey: .containerDetails)
        containerDetails = containerDetailsDecoded
        let rdsDbInstanceDetailsDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.RdsDbInstanceDetails.self, forKey: .rdsDbInstanceDetails)
        rdsDbInstanceDetails = rdsDbInstanceDetailsDecoded
        let rdsDbUserDetailsDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.RdsDbUserDetails.self, forKey: .rdsDbUserDetails)
        rdsDbUserDetails = rdsDbUserDetailsDecoded
        let lambdaDetailsDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.LambdaDetails.self, forKey: .lambdaDetails)
        lambdaDetails = lambdaDetailsDecoded
    }
}

extension GuardDutyClientTypes {
    /// Contains information about the Amazon Web Services resource associated with the activity that prompted GuardDuty to generate a finding.
    public struct Resource: Swift.Equatable {
        /// The IAM access key details (user information) of a user that engaged in the activity that prompted GuardDuty to generate a finding.
        public var accessKeyDetails: GuardDutyClientTypes.AccessKeyDetails?
        /// Details of a container.
        public var containerDetails: GuardDutyClientTypes.Container?
        /// Contains list of scanned and skipped EBS volumes with details.
        public var ebsVolumeDetails: GuardDutyClientTypes.EbsVolumeDetails?
        /// Contains information about the details of the ECS Cluster.
        public var ecsClusterDetails: GuardDutyClientTypes.EcsClusterDetails?
        /// Details about the EKS cluster involved in a Kubernetes finding.
        public var eksClusterDetails: GuardDutyClientTypes.EksClusterDetails?
        /// The information about the EC2 instance associated with the activity that prompted GuardDuty to generate a finding.
        public var instanceDetails: GuardDutyClientTypes.InstanceDetails?
        /// Details about the Kubernetes user and workload involved in a Kubernetes finding.
        public var kubernetesDetails: GuardDutyClientTypes.KubernetesDetails?
        /// Contains information about the Lambda function that was involved in a finding.
        public var lambdaDetails: GuardDutyClientTypes.LambdaDetails?
        /// Contains information about the database instance to which an anomalous login attempt was made.
        public var rdsDbInstanceDetails: GuardDutyClientTypes.RdsDbInstanceDetails?
        /// Contains information about the user details through which anomalous login attempt was made.
        public var rdsDbUserDetails: GuardDutyClientTypes.RdsDbUserDetails?
        /// The type of Amazon Web Services resource.
        public var resourceType: Swift.String?
        /// Contains information on the S3 bucket.
        public var s3BucketDetails: [GuardDutyClientTypes.S3BucketDetail]?

        public init(
            accessKeyDetails: GuardDutyClientTypes.AccessKeyDetails? = nil,
            containerDetails: GuardDutyClientTypes.Container? = nil,
            ebsVolumeDetails: GuardDutyClientTypes.EbsVolumeDetails? = nil,
            ecsClusterDetails: GuardDutyClientTypes.EcsClusterDetails? = nil,
            eksClusterDetails: GuardDutyClientTypes.EksClusterDetails? = nil,
            instanceDetails: GuardDutyClientTypes.InstanceDetails? = nil,
            kubernetesDetails: GuardDutyClientTypes.KubernetesDetails? = nil,
            lambdaDetails: GuardDutyClientTypes.LambdaDetails? = nil,
            rdsDbInstanceDetails: GuardDutyClientTypes.RdsDbInstanceDetails? = nil,
            rdsDbUserDetails: GuardDutyClientTypes.RdsDbUserDetails? = nil,
            resourceType: Swift.String? = nil,
            s3BucketDetails: [GuardDutyClientTypes.S3BucketDetail]? = nil
        )
        {
            self.accessKeyDetails = accessKeyDetails
            self.containerDetails = containerDetails
            self.ebsVolumeDetails = ebsVolumeDetails
            self.ecsClusterDetails = ecsClusterDetails
            self.eksClusterDetails = eksClusterDetails
            self.instanceDetails = instanceDetails
            self.kubernetesDetails = kubernetesDetails
            self.lambdaDetails = lambdaDetails
            self.rdsDbInstanceDetails = rdsDbInstanceDetails
            self.rdsDbUserDetails = rdsDbUserDetails
            self.resourceType = resourceType
            self.s3BucketDetails = s3BucketDetails
        }
    }

}

extension GuardDutyClientTypes.ResourceDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceArn = "instanceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceArn = self.instanceArn {
            try encodeContainer.encode(instanceArn, forKey: .instanceArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceArn)
        instanceArn = instanceArnDecoded
    }
}

extension GuardDutyClientTypes {
    /// Represents the resources that were scanned in the scan entry.
    public struct ResourceDetails: Swift.Equatable {
        /// InstanceArn that was scanned in the scan entry.
        public var instanceArn: Swift.String?

        public init(
            instanceArn: Swift.String? = nil
        )
        {
            self.instanceArn = instanceArn
        }
    }

}

extension GuardDutyClientTypes {
    public enum ResourceType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case eks
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceType] {
            return [
                .eks,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .eks: return "EKS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ResourceType(rawValue: rawValue) ?? ResourceType.sdkUnknown(rawValue)
        }
    }
}

extension GuardDutyClientTypes.RuntimeContext: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case addressFamily = "addressFamily"
        case fileSystemType = "fileSystemType"
        case flags = "flags"
        case ianaProtocolNumber = "ianaProtocolNumber"
        case ldPreloadValue = "ldPreloadValue"
        case libraryPath = "libraryPath"
        case memoryRegions = "memoryRegions"
        case modifiedAt = "modifiedAt"
        case modifyingProcess = "modifyingProcess"
        case moduleFilePath = "moduleFilePath"
        case moduleName = "moduleName"
        case moduleSha256 = "moduleSha256"
        case mountSource = "mountSource"
        case mountTarget = "mountTarget"
        case releaseAgentPath = "releaseAgentPath"
        case runcBinaryPath = "runcBinaryPath"
        case scriptPath = "scriptPath"
        case shellHistoryFilePath = "shellHistoryFilePath"
        case socketPath = "socketPath"
        case targetProcess = "targetProcess"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let addressFamily = self.addressFamily {
            try encodeContainer.encode(addressFamily, forKey: .addressFamily)
        }
        if let fileSystemType = self.fileSystemType {
            try encodeContainer.encode(fileSystemType, forKey: .fileSystemType)
        }
        if let flags = flags {
            var flagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .flags)
            for string0 in flags {
                try flagsContainer.encode(string0)
            }
        }
        if ianaProtocolNumber != 0 {
            try encodeContainer.encode(ianaProtocolNumber, forKey: .ianaProtocolNumber)
        }
        if let ldPreloadValue = self.ldPreloadValue {
            try encodeContainer.encode(ldPreloadValue, forKey: .ldPreloadValue)
        }
        if let libraryPath = self.libraryPath {
            try encodeContainer.encode(libraryPath, forKey: .libraryPath)
        }
        if let memoryRegions = memoryRegions {
            var memoryRegionsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .memoryRegions)
            for string0 in memoryRegions {
                try memoryRegionsContainer.encode(string0)
            }
        }
        if let modifiedAt = self.modifiedAt {
            try encodeContainer.encodeTimestamp(modifiedAt, format: .epochSeconds, forKey: .modifiedAt)
        }
        if let modifyingProcess = self.modifyingProcess {
            try encodeContainer.encode(modifyingProcess, forKey: .modifyingProcess)
        }
        if let moduleFilePath = self.moduleFilePath {
            try encodeContainer.encode(moduleFilePath, forKey: .moduleFilePath)
        }
        if let moduleName = self.moduleName {
            try encodeContainer.encode(moduleName, forKey: .moduleName)
        }
        if let moduleSha256 = self.moduleSha256 {
            try encodeContainer.encode(moduleSha256, forKey: .moduleSha256)
        }
        if let mountSource = self.mountSource {
            try encodeContainer.encode(mountSource, forKey: .mountSource)
        }
        if let mountTarget = self.mountTarget {
            try encodeContainer.encode(mountTarget, forKey: .mountTarget)
        }
        if let releaseAgentPath = self.releaseAgentPath {
            try encodeContainer.encode(releaseAgentPath, forKey: .releaseAgentPath)
        }
        if let runcBinaryPath = self.runcBinaryPath {
            try encodeContainer.encode(runcBinaryPath, forKey: .runcBinaryPath)
        }
        if let scriptPath = self.scriptPath {
            try encodeContainer.encode(scriptPath, forKey: .scriptPath)
        }
        if let shellHistoryFilePath = self.shellHistoryFilePath {
            try encodeContainer.encode(shellHistoryFilePath, forKey: .shellHistoryFilePath)
        }
        if let socketPath = self.socketPath {
            try encodeContainer.encode(socketPath, forKey: .socketPath)
        }
        if let targetProcess = self.targetProcess {
            try encodeContainer.encode(targetProcess, forKey: .targetProcess)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let modifyingProcessDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.ProcessDetails.self, forKey: .modifyingProcess)
        modifyingProcess = modifyingProcessDecoded
        let modifiedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .modifiedAt)
        modifiedAt = modifiedAtDecoded
        let scriptPathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .scriptPath)
        scriptPath = scriptPathDecoded
        let libraryPathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .libraryPath)
        libraryPath = libraryPathDecoded
        let ldPreloadValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ldPreloadValue)
        ldPreloadValue = ldPreloadValueDecoded
        let socketPathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .socketPath)
        socketPath = socketPathDecoded
        let runcBinaryPathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .runcBinaryPath)
        runcBinaryPath = runcBinaryPathDecoded
        let releaseAgentPathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .releaseAgentPath)
        releaseAgentPath = releaseAgentPathDecoded
        let mountSourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mountSource)
        mountSource = mountSourceDecoded
        let mountTargetDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mountTarget)
        mountTarget = mountTargetDecoded
        let fileSystemTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fileSystemType)
        fileSystemType = fileSystemTypeDecoded
        let flagsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .flags)
        var flagsDecoded0:[Swift.String]? = nil
        if let flagsContainer = flagsContainer {
            flagsDecoded0 = [Swift.String]()
            for string0 in flagsContainer {
                if let string0 = string0 {
                    flagsDecoded0?.append(string0)
                }
            }
        }
        flags = flagsDecoded0
        let moduleNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .moduleName)
        moduleName = moduleNameDecoded
        let moduleFilePathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .moduleFilePath)
        moduleFilePath = moduleFilePathDecoded
        let moduleSha256Decoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .moduleSha256)
        moduleSha256 = moduleSha256Decoded
        let shellHistoryFilePathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .shellHistoryFilePath)
        shellHistoryFilePath = shellHistoryFilePathDecoded
        let targetProcessDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.ProcessDetails.self, forKey: .targetProcess)
        targetProcess = targetProcessDecoded
        let addressFamilyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .addressFamily)
        addressFamily = addressFamilyDecoded
        let ianaProtocolNumberDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .ianaProtocolNumber) ?? 0
        ianaProtocolNumber = ianaProtocolNumberDecoded
        let memoryRegionsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .memoryRegions)
        var memoryRegionsDecoded0:[Swift.String]? = nil
        if let memoryRegionsContainer = memoryRegionsContainer {
            memoryRegionsDecoded0 = [Swift.String]()
            for string0 in memoryRegionsContainer {
                if let string0 = string0 {
                    memoryRegionsDecoded0?.append(string0)
                }
            }
        }
        memoryRegions = memoryRegionsDecoded0
    }
}

extension GuardDutyClientTypes {
    /// Additional information about the suspicious activity.
    public struct RuntimeContext: Swift.Equatable {
        /// Represents the communication protocol associated with the address. For example, the address family AF_INET is used for IP version of 4 protocol.
        public var addressFamily: Swift.String?
        /// Represents the type of mounted fileSystem.
        public var fileSystemType: Swift.String?
        /// Represents options that control the behavior of a runtime operation or action. For example, a filesystem mount operation may contain a read-only flag.
        public var flags: [Swift.String]?
        /// Specifies a particular protocol within the address family. Usually there is a single protocol in address families. For example, the address family AF_INET only has the IP protocol.
        public var ianaProtocolNumber: Swift.Int
        /// The value of the LD_PRELOAD environment variable.
        public var ldPreloadValue: Swift.String?
        /// The path to the new library that was loaded.
        public var libraryPath: Swift.String?
        /// Specifies the Region of a process's address space such as stack and heap.
        public var memoryRegions: [Swift.String]?
        /// The timestamp at which the process modified the current process. The timestamp is in UTC date string format.
        public var modifiedAt: ClientRuntime.Date?
        /// Information about the process that modified the current process. This is available for multiple finding types.
        public var modifyingProcess: GuardDutyClientTypes.ProcessDetails?
        /// The path to the module loaded into the kernel.
        public var moduleFilePath: Swift.String?
        /// The name of the module loaded into the kernel.
        public var moduleName: Swift.String?
        /// The SHA256 hash of the module.
        public var moduleSha256: Swift.String?
        /// The path on the host that is mounted by the container.
        public var mountSource: Swift.String?
        /// The path in the container that is mapped to the host directory.
        public var mountTarget: Swift.String?
        /// The path in the container that modified the release agent file.
        public var releaseAgentPath: Swift.String?
        /// The path to the leveraged runc implementation.
        public var runcBinaryPath: Swift.String?
        /// The path to the script that was executed.
        public var scriptPath: Swift.String?
        /// The path to the modified shell history file.
        public var shellHistoryFilePath: Swift.String?
        /// The path to the docket socket that was accessed.
        public var socketPath: Swift.String?
        /// Information about the process that had its memory overwritten by the current process.
        public var targetProcess: GuardDutyClientTypes.ProcessDetails?

        public init(
            addressFamily: Swift.String? = nil,
            fileSystemType: Swift.String? = nil,
            flags: [Swift.String]? = nil,
            ianaProtocolNumber: Swift.Int = 0,
            ldPreloadValue: Swift.String? = nil,
            libraryPath: Swift.String? = nil,
            memoryRegions: [Swift.String]? = nil,
            modifiedAt: ClientRuntime.Date? = nil,
            modifyingProcess: GuardDutyClientTypes.ProcessDetails? = nil,
            moduleFilePath: Swift.String? = nil,
            moduleName: Swift.String? = nil,
            moduleSha256: Swift.String? = nil,
            mountSource: Swift.String? = nil,
            mountTarget: Swift.String? = nil,
            releaseAgentPath: Swift.String? = nil,
            runcBinaryPath: Swift.String? = nil,
            scriptPath: Swift.String? = nil,
            shellHistoryFilePath: Swift.String? = nil,
            socketPath: Swift.String? = nil,
            targetProcess: GuardDutyClientTypes.ProcessDetails? = nil
        )
        {
            self.addressFamily = addressFamily
            self.fileSystemType = fileSystemType
            self.flags = flags
            self.ianaProtocolNumber = ianaProtocolNumber
            self.ldPreloadValue = ldPreloadValue
            self.libraryPath = libraryPath
            self.memoryRegions = memoryRegions
            self.modifiedAt = modifiedAt
            self.modifyingProcess = modifyingProcess
            self.moduleFilePath = moduleFilePath
            self.moduleName = moduleName
            self.moduleSha256 = moduleSha256
            self.mountSource = mountSource
            self.mountTarget = mountTarget
            self.releaseAgentPath = releaseAgentPath
            self.runcBinaryPath = runcBinaryPath
            self.scriptPath = scriptPath
            self.shellHistoryFilePath = shellHistoryFilePath
            self.socketPath = socketPath
            self.targetProcess = targetProcess
        }
    }

}

extension GuardDutyClientTypes.RuntimeDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case context = "context"
        case process = "process"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let context = self.context {
            try encodeContainer.encode(context, forKey: .context)
        }
        if let process = self.process {
            try encodeContainer.encode(process, forKey: .process)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let processDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.ProcessDetails.self, forKey: .process)
        process = processDecoded
        let contextDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.RuntimeContext.self, forKey: .context)
        context = contextDecoded
    }
}

extension GuardDutyClientTypes {
    /// Information about the process and any required context values for a specific finding.
    public struct RuntimeDetails: Swift.Equatable {
        /// Additional information about the suspicious activity.
        public var context: GuardDutyClientTypes.RuntimeContext?
        /// Information about the observed process.
        public var process: GuardDutyClientTypes.ProcessDetails?

        public init(
            context: GuardDutyClientTypes.RuntimeContext? = nil,
            process: GuardDutyClientTypes.ProcessDetails? = nil
        )
        {
            self.context = context
            self.process = process
        }
    }

}

extension GuardDutyClientTypes.S3BucketDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "arn"
        case createdAt = "createdAt"
        case defaultServerSideEncryption = "defaultServerSideEncryption"
        case name = "name"
        case owner = "owner"
        case publicAccess = "publicAccess"
        case tags = "tags"
        case type = "type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let defaultServerSideEncryption = self.defaultServerSideEncryption {
            try encodeContainer.encode(defaultServerSideEncryption, forKey: .defaultServerSideEncryption)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let owner = self.owner {
            try encodeContainer.encode(owner, forKey: .owner)
        }
        if let publicAccess = self.publicAccess {
            try encodeContainer.encode(publicAccess, forKey: .publicAccess)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let ownerDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.Owner.self, forKey: .owner)
        owner = ownerDecoded
        let tagsContainer = try containerValues.decodeIfPresent([GuardDutyClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[GuardDutyClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [GuardDutyClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let defaultServerSideEncryptionDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.DefaultServerSideEncryption.self, forKey: .defaultServerSideEncryption)
        defaultServerSideEncryption = defaultServerSideEncryptionDecoded
        let publicAccessDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.PublicAccess.self, forKey: .publicAccess)
        publicAccess = publicAccessDecoded
    }
}

extension GuardDutyClientTypes {
    /// Contains information on the S3 bucket.
    public struct S3BucketDetail: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the S3 bucket.
        public var arn: Swift.String?
        /// The date and time the bucket was created at.
        public var createdAt: ClientRuntime.Date?
        /// Describes the server side encryption method used in the S3 bucket.
        public var defaultServerSideEncryption: GuardDutyClientTypes.DefaultServerSideEncryption?
        /// The name of the S3 bucket.
        public var name: Swift.String?
        /// The owner of the S3 bucket.
        public var owner: GuardDutyClientTypes.Owner?
        /// Describes the public access policies that apply to the S3 bucket.
        public var publicAccess: GuardDutyClientTypes.PublicAccess?
        /// All tags attached to the S3 bucket
        public var tags: [GuardDutyClientTypes.Tag]?
        /// Describes whether the bucket is a source or destination bucket.
        public var type: Swift.String?

        public init(
            arn: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            defaultServerSideEncryption: GuardDutyClientTypes.DefaultServerSideEncryption? = nil,
            name: Swift.String? = nil,
            owner: GuardDutyClientTypes.Owner? = nil,
            publicAccess: GuardDutyClientTypes.PublicAccess? = nil,
            tags: [GuardDutyClientTypes.Tag]? = nil,
            type: Swift.String? = nil
        )
        {
            self.arn = arn
            self.createdAt = createdAt
            self.defaultServerSideEncryption = defaultServerSideEncryption
            self.name = name
            self.owner = owner
            self.publicAccess = publicAccess
            self.tags = tags
            self.type = type
        }
    }

}

extension GuardDutyClientTypes.S3LogsConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enable = "enable"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if enable != false {
            try encodeContainer.encode(enable, forKey: .enable)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enableDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enable) ?? false
        enable = enableDecoded
    }
}

extension GuardDutyClientTypes {
    /// Describes whether S3 data event logs will be enabled as a data source.
    public struct S3LogsConfiguration: Swift.Equatable {
        /// The status of S3 data event logs as a data source.
        /// This member is required.
        public var enable: Swift.Bool

        public init(
            enable: Swift.Bool = false
        )
        {
            self.enable = enable
        }
    }

}

extension GuardDutyClientTypes.S3LogsConfigurationResult: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status = "status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.DataSourceStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension GuardDutyClientTypes {
    /// Describes whether S3 data event logs will be enabled as a data source.
    public struct S3LogsConfigurationResult: Swift.Equatable {
        /// A value that describes whether S3 data event logs are automatically enabled for new members of the organization.
        /// This member is required.
        public var status: GuardDutyClientTypes.DataSourceStatus?

        public init(
            status: GuardDutyClientTypes.DataSourceStatus? = nil
        )
        {
            self.status = status
        }
    }

}

extension GuardDutyClientTypes.Scan: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "accountId"
        case adminDetectorId = "adminDetectorId"
        case attachedVolumes = "attachedVolumes"
        case detectorId = "detectorId"
        case failureReason = "failureReason"
        case fileCount = "fileCount"
        case resourceDetails = "resourceDetails"
        case scanEndTime = "scanEndTime"
        case scanId = "scanId"
        case scanResultDetails = "scanResultDetails"
        case scanStartTime = "scanStartTime"
        case scanStatus = "scanStatus"
        case scanType = "scanType"
        case totalBytes = "totalBytes"
        case triggerDetails = "triggerDetails"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let adminDetectorId = self.adminDetectorId {
            try encodeContainer.encode(adminDetectorId, forKey: .adminDetectorId)
        }
        if let attachedVolumes = attachedVolumes {
            var attachedVolumesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attachedVolumes)
            for volumedetail0 in attachedVolumes {
                try attachedVolumesContainer.encode(volumedetail0)
            }
        }
        if let detectorId = self.detectorId {
            try encodeContainer.encode(detectorId, forKey: .detectorId)
        }
        if let failureReason = self.failureReason {
            try encodeContainer.encode(failureReason, forKey: .failureReason)
        }
        if fileCount != 0 {
            try encodeContainer.encode(fileCount, forKey: .fileCount)
        }
        if let resourceDetails = self.resourceDetails {
            try encodeContainer.encode(resourceDetails, forKey: .resourceDetails)
        }
        if let scanEndTime = self.scanEndTime {
            try encodeContainer.encodeTimestamp(scanEndTime, format: .epochSeconds, forKey: .scanEndTime)
        }
        if let scanId = self.scanId {
            try encodeContainer.encode(scanId, forKey: .scanId)
        }
        if let scanResultDetails = self.scanResultDetails {
            try encodeContainer.encode(scanResultDetails, forKey: .scanResultDetails)
        }
        if let scanStartTime = self.scanStartTime {
            try encodeContainer.encodeTimestamp(scanStartTime, format: .epochSeconds, forKey: .scanStartTime)
        }
        if let scanStatus = self.scanStatus {
            try encodeContainer.encode(scanStatus.rawValue, forKey: .scanStatus)
        }
        if let scanType = self.scanType {
            try encodeContainer.encode(scanType.rawValue, forKey: .scanType)
        }
        if totalBytes != 0 {
            try encodeContainer.encode(totalBytes, forKey: .totalBytes)
        }
        if let triggerDetails = self.triggerDetails {
            try encodeContainer.encode(triggerDetails, forKey: .triggerDetails)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detectorIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detectorId)
        detectorId = detectorIdDecoded
        let adminDetectorIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .adminDetectorId)
        adminDetectorId = adminDetectorIdDecoded
        let scanIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .scanId)
        scanId = scanIdDecoded
        let scanStatusDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.ScanStatus.self, forKey: .scanStatus)
        scanStatus = scanStatusDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
        let scanStartTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .scanStartTime)
        scanStartTime = scanStartTimeDecoded
        let scanEndTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .scanEndTime)
        scanEndTime = scanEndTimeDecoded
        let triggerDetailsDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.TriggerDetails.self, forKey: .triggerDetails)
        triggerDetails = triggerDetailsDecoded
        let resourceDetailsDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.ResourceDetails.self, forKey: .resourceDetails)
        resourceDetails = resourceDetailsDecoded
        let scanResultDetailsDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.ScanResultDetails.self, forKey: .scanResultDetails)
        scanResultDetails = scanResultDetailsDecoded
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let totalBytesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalBytes) ?? 0
        totalBytes = totalBytesDecoded
        let fileCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .fileCount) ?? 0
        fileCount = fileCountDecoded
        let attachedVolumesContainer = try containerValues.decodeIfPresent([GuardDutyClientTypes.VolumeDetail?].self, forKey: .attachedVolumes)
        var attachedVolumesDecoded0:[GuardDutyClientTypes.VolumeDetail]? = nil
        if let attachedVolumesContainer = attachedVolumesContainer {
            attachedVolumesDecoded0 = [GuardDutyClientTypes.VolumeDetail]()
            for structure0 in attachedVolumesContainer {
                if let structure0 = structure0 {
                    attachedVolumesDecoded0?.append(structure0)
                }
            }
        }
        attachedVolumes = attachedVolumesDecoded0
        let scanTypeDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.ScanType.self, forKey: .scanType)
        scanType = scanTypeDecoded
    }
}

extension GuardDutyClientTypes {
    /// Contains information about a malware scan.
    public struct Scan: Swift.Equatable {
        /// The ID for the account that belongs to the scan.
        public var accountId: Swift.String?
        /// The unique detector ID of the administrator account that the request is associated with. Note that this value will be the same as the one used for DetectorId if the account is an administrator.
        public var adminDetectorId: Swift.String?
        /// List of volumes that were attached to the original instance to be scanned.
        public var attachedVolumes: [GuardDutyClientTypes.VolumeDetail]?
        /// The unique ID of the detector that the request is associated with.
        public var detectorId: Swift.String?
        /// Represents the reason for FAILED scan status.
        public var failureReason: Swift.String?
        /// Represents the number of files that were scanned.
        public var fileCount: Swift.Int
        /// Represents the resources that were scanned in the scan entry.
        public var resourceDetails: GuardDutyClientTypes.ResourceDetails?
        /// The timestamp of when the scan was finished.
        public var scanEndTime: ClientRuntime.Date?
        /// The unique scan ID associated with a scan entry.
        public var scanId: Swift.String?
        /// Represents the result of the scan.
        public var scanResultDetails: GuardDutyClientTypes.ScanResultDetails?
        /// The timestamp of when the scan was triggered.
        public var scanStartTime: ClientRuntime.Date?
        /// An enum value representing possible scan statuses.
        public var scanStatus: GuardDutyClientTypes.ScanStatus?
        /// Specifies the scan type that invoked the malware scan.
        public var scanType: GuardDutyClientTypes.ScanType?
        /// Represents total bytes that were scanned.
        public var totalBytes: Swift.Int
        /// Specifies the reason why the scan was initiated.
        public var triggerDetails: GuardDutyClientTypes.TriggerDetails?

        public init(
            accountId: Swift.String? = nil,
            adminDetectorId: Swift.String? = nil,
            attachedVolumes: [GuardDutyClientTypes.VolumeDetail]? = nil,
            detectorId: Swift.String? = nil,
            failureReason: Swift.String? = nil,
            fileCount: Swift.Int = 0,
            resourceDetails: GuardDutyClientTypes.ResourceDetails? = nil,
            scanEndTime: ClientRuntime.Date? = nil,
            scanId: Swift.String? = nil,
            scanResultDetails: GuardDutyClientTypes.ScanResultDetails? = nil,
            scanStartTime: ClientRuntime.Date? = nil,
            scanStatus: GuardDutyClientTypes.ScanStatus? = nil,
            scanType: GuardDutyClientTypes.ScanType? = nil,
            totalBytes: Swift.Int = 0,
            triggerDetails: GuardDutyClientTypes.TriggerDetails? = nil
        )
        {
            self.accountId = accountId
            self.adminDetectorId = adminDetectorId
            self.attachedVolumes = attachedVolumes
            self.detectorId = detectorId
            self.failureReason = failureReason
            self.fileCount = fileCount
            self.resourceDetails = resourceDetails
            self.scanEndTime = scanEndTime
            self.scanId = scanId
            self.scanResultDetails = scanResultDetails
            self.scanStartTime = scanStartTime
            self.scanStatus = scanStatus
            self.scanType = scanType
            self.totalBytes = totalBytes
            self.triggerDetails = triggerDetails
        }
    }

}

extension GuardDutyClientTypes.ScanCondition: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case mapEquals = "mapEquals"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let mapEquals = mapEquals {
            var mapEqualsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .mapEquals)
            for scanconditionpair0 in mapEquals {
                try mapEqualsContainer.encode(scanconditionpair0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let mapEqualsContainer = try containerValues.decodeIfPresent([GuardDutyClientTypes.ScanConditionPair?].self, forKey: .mapEquals)
        var mapEqualsDecoded0:[GuardDutyClientTypes.ScanConditionPair]? = nil
        if let mapEqualsContainer = mapEqualsContainer {
            mapEqualsDecoded0 = [GuardDutyClientTypes.ScanConditionPair]()
            for structure0 in mapEqualsContainer {
                if let structure0 = structure0 {
                    mapEqualsDecoded0?.append(structure0)
                }
            }
        }
        mapEquals = mapEqualsDecoded0
    }
}

extension GuardDutyClientTypes {
    /// Contains information about the condition.
    public struct ScanCondition: Swift.Equatable {
        /// Represents an mapEqual condition to be applied to a single field when triggering for malware scan.
        /// This member is required.
        public var mapEquals: [GuardDutyClientTypes.ScanConditionPair]?

        public init(
            mapEquals: [GuardDutyClientTypes.ScanConditionPair]? = nil
        )
        {
            self.mapEquals = mapEquals
        }
    }

}

extension GuardDutyClientTypes.ScanConditionPair: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "key"
        case value = "value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension GuardDutyClientTypes {
    /// Represents the key:value pair to be matched against given resource property.
    public struct ScanConditionPair: Swift.Equatable {
        /// Represents the key in the map condition.
        /// This member is required.
        public var key: Swift.String?
        /// Represents optional value in the map condition. If not specified, only the key will be matched.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension GuardDutyClientTypes {
    /// An enum value representing possible resource properties to match with given scan condition.
    public enum ScanCriterionKey: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ec2InstanceTag
        case sdkUnknown(Swift.String)

        public static var allCases: [ScanCriterionKey] {
            return [
                .ec2InstanceTag,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ec2InstanceTag: return "EC2_INSTANCE_TAG"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ScanCriterionKey(rawValue: rawValue) ?? ScanCriterionKey.sdkUnknown(rawValue)
        }
    }
}

extension GuardDutyClientTypes.ScanDetections: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case highestSeverityThreatDetails = "highestSeverityThreatDetails"
        case scannedItemCount = "scannedItemCount"
        case threatDetectedByName = "threatDetectedByName"
        case threatsDetectedItemCount = "threatsDetectedItemCount"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let highestSeverityThreatDetails = self.highestSeverityThreatDetails {
            try encodeContainer.encode(highestSeverityThreatDetails, forKey: .highestSeverityThreatDetails)
        }
        if let scannedItemCount = self.scannedItemCount {
            try encodeContainer.encode(scannedItemCount, forKey: .scannedItemCount)
        }
        if let threatDetectedByName = self.threatDetectedByName {
            try encodeContainer.encode(threatDetectedByName, forKey: .threatDetectedByName)
        }
        if let threatsDetectedItemCount = self.threatsDetectedItemCount {
            try encodeContainer.encode(threatsDetectedItemCount, forKey: .threatsDetectedItemCount)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scannedItemCountDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.ScannedItemCount.self, forKey: .scannedItemCount)
        scannedItemCount = scannedItemCountDecoded
        let threatsDetectedItemCountDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.ThreatsDetectedItemCount.self, forKey: .threatsDetectedItemCount)
        threatsDetectedItemCount = threatsDetectedItemCountDecoded
        let highestSeverityThreatDetailsDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.HighestSeverityThreatDetails.self, forKey: .highestSeverityThreatDetails)
        highestSeverityThreatDetails = highestSeverityThreatDetailsDecoded
        let threatDetectedByNameDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.ThreatDetectedByName.self, forKey: .threatDetectedByName)
        threatDetectedByName = threatDetectedByNameDecoded
    }
}

extension GuardDutyClientTypes {
    /// Contains a complete view providing malware scan result details.
    public struct ScanDetections: Swift.Equatable {
        /// Details of the highest severity threat detected during malware scan and number of infected files.
        public var highestSeverityThreatDetails: GuardDutyClientTypes.HighestSeverityThreatDetails?
        /// Total number of scanned files.
        public var scannedItemCount: GuardDutyClientTypes.ScannedItemCount?
        /// Contains details about identified threats organized by threat name.
        public var threatDetectedByName: GuardDutyClientTypes.ThreatDetectedByName?
        /// Total number of infected files.
        public var threatsDetectedItemCount: GuardDutyClientTypes.ThreatsDetectedItemCount?

        public init(
            highestSeverityThreatDetails: GuardDutyClientTypes.HighestSeverityThreatDetails? = nil,
            scannedItemCount: GuardDutyClientTypes.ScannedItemCount? = nil,
            threatDetectedByName: GuardDutyClientTypes.ThreatDetectedByName? = nil,
            threatsDetectedItemCount: GuardDutyClientTypes.ThreatsDetectedItemCount? = nil
        )
        {
            self.highestSeverityThreatDetails = highestSeverityThreatDetails
            self.scannedItemCount = scannedItemCount
            self.threatDetectedByName = threatDetectedByName
            self.threatsDetectedItemCount = threatsDetectedItemCount
        }
    }

}

extension GuardDutyClientTypes.ScanEc2InstanceWithFindings: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ebsVolumes = "ebsVolumes"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if ebsVolumes != false {
            try encodeContainer.encode(ebsVolumes, forKey: .ebsVolumes)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ebsVolumesDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .ebsVolumes) ?? false
        ebsVolumes = ebsVolumesDecoded
    }
}

extension GuardDutyClientTypes {
    /// Describes whether Malware Protection for EC2 instances with findings will be enabled as a data source.
    public struct ScanEc2InstanceWithFindings: Swift.Equatable {
        /// Describes the configuration for scanning EBS volumes as data source.
        public var ebsVolumes: Swift.Bool

        public init(
            ebsVolumes: Swift.Bool = false
        )
        {
            self.ebsVolumes = ebsVolumes
        }
    }

}

extension GuardDutyClientTypes.ScanEc2InstanceWithFindingsResult: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ebsVolumes = "ebsVolumes"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ebsVolumes = self.ebsVolumes {
            try encodeContainer.encode(ebsVolumes, forKey: .ebsVolumes)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ebsVolumesDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.EbsVolumesResult.self, forKey: .ebsVolumes)
        ebsVolumes = ebsVolumesDecoded
    }
}

extension GuardDutyClientTypes {
    /// An object that contains information on the status of whether Malware Protection for EC2 instances with findings will be enabled as a data source.
    public struct ScanEc2InstanceWithFindingsResult: Swift.Equatable {
        /// Describes the configuration of scanning EBS volumes as a data source.
        public var ebsVolumes: GuardDutyClientTypes.EbsVolumesResult?

        public init(
            ebsVolumes: GuardDutyClientTypes.EbsVolumesResult? = nil
        )
        {
            self.ebsVolumes = ebsVolumes
        }
    }

}

extension GuardDutyClientTypes.ScanFilePath: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fileName = "fileName"
        case filePath = "filePath"
        case hash = "hash"
        case volumeArn = "volumeArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fileName = self.fileName {
            try encodeContainer.encode(fileName, forKey: .fileName)
        }
        if let filePath = self.filePath {
            try encodeContainer.encode(filePath, forKey: .filePath)
        }
        if let hash = self.hash {
            try encodeContainer.encode(hash, forKey: .hash)
        }
        if let volumeArn = self.volumeArn {
            try encodeContainer.encode(volumeArn, forKey: .volumeArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filePathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .filePath)
        filePath = filePathDecoded
        let volumeArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .volumeArn)
        volumeArn = volumeArnDecoded
        let hashDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hash)
        hash = hashDecoded
        let fileNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fileName)
        fileName = fileNameDecoded
    }
}

extension GuardDutyClientTypes {
    /// Contains details of infected file including name, file path and hash.
    public struct ScanFilePath: Swift.Equatable {
        /// File name of the infected file.
        public var fileName: Swift.String?
        /// The file path of the infected file.
        public var filePath: Swift.String?
        /// The hash value of the infected file.
        public var hash: Swift.String?
        /// EBS volume Arn details of the infected file.
        public var volumeArn: Swift.String?

        public init(
            fileName: Swift.String? = nil,
            filePath: Swift.String? = nil,
            hash: Swift.String? = nil,
            volumeArn: Swift.String? = nil
        )
        {
            self.fileName = fileName
            self.filePath = filePath
            self.hash = hash
            self.volumeArn = volumeArn
        }
    }

}

extension GuardDutyClientTypes.ScanResourceCriteria: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case exclude = "exclude"
        case include = "include"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let exclude = exclude {
            var excludeContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .exclude)
            for (dictKey0, scanCriterion0) in exclude {
                try excludeContainer.encode(scanCriterion0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let include = include {
            var includeContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .include)
            for (dictKey0, scanCriterion0) in include {
                try includeContainer.encode(scanCriterion0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let includeContainer = try containerValues.decodeIfPresent([Swift.String: GuardDutyClientTypes.ScanCondition?].self, forKey: .include)
        var includeDecoded0: [Swift.String:GuardDutyClientTypes.ScanCondition]? = nil
        if let includeContainer = includeContainer {
            includeDecoded0 = [Swift.String:GuardDutyClientTypes.ScanCondition]()
            for (key0, scancondition0) in includeContainer {
                if let scancondition0 = scancondition0 {
                    includeDecoded0?[key0] = scancondition0
                }
            }
        }
        include = includeDecoded0
        let excludeContainer = try containerValues.decodeIfPresent([Swift.String: GuardDutyClientTypes.ScanCondition?].self, forKey: .exclude)
        var excludeDecoded0: [Swift.String:GuardDutyClientTypes.ScanCondition]? = nil
        if let excludeContainer = excludeContainer {
            excludeDecoded0 = [Swift.String:GuardDutyClientTypes.ScanCondition]()
            for (key0, scancondition0) in excludeContainer {
                if let scancondition0 = scancondition0 {
                    excludeDecoded0?[key0] = scancondition0
                }
            }
        }
        exclude = excludeDecoded0
    }
}

extension GuardDutyClientTypes {
    /// Contains information about criteria used to filter resources before triggering malware scan.
    public struct ScanResourceCriteria: Swift.Equatable {
        /// Represents condition that when matched will prevent a malware scan for a certain resource.
        public var exclude: [Swift.String:GuardDutyClientTypes.ScanCondition]?
        /// Represents condition that when matched will allow a malware scan for a certain resource.
        public var include: [Swift.String:GuardDutyClientTypes.ScanCondition]?

        public init(
            exclude: [Swift.String:GuardDutyClientTypes.ScanCondition]? = nil,
            include: [Swift.String:GuardDutyClientTypes.ScanCondition]? = nil
        )
        {
            self.exclude = exclude
            self.include = include
        }
    }

}

extension GuardDutyClientTypes {
    public enum ScanResult: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case clean
        case infected
        case sdkUnknown(Swift.String)

        public static var allCases: [ScanResult] {
            return [
                .clean,
                .infected,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .clean: return "CLEAN"
            case .infected: return "INFECTED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ScanResult(rawValue: rawValue) ?? ScanResult.sdkUnknown(rawValue)
        }
    }
}

extension GuardDutyClientTypes.ScanResultDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case scanResult = "scanResult"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let scanResult = self.scanResult {
            try encodeContainer.encode(scanResult.rawValue, forKey: .scanResult)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scanResultDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.ScanResult.self, forKey: .scanResult)
        scanResult = scanResultDecoded
    }
}

extension GuardDutyClientTypes {
    /// Represents the result of the scan.
    public struct ScanResultDetails: Swift.Equatable {
        /// An enum value representing possible scan results.
        public var scanResult: GuardDutyClientTypes.ScanResult?

        public init(
            scanResult: GuardDutyClientTypes.ScanResult? = nil
        )
        {
            self.scanResult = scanResult
        }
    }

}

extension GuardDutyClientTypes {
    public enum ScanStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case completed
        case failed
        case running
        case skipped
        case sdkUnknown(Swift.String)

        public static var allCases: [ScanStatus] {
            return [
                .completed,
                .failed,
                .running,
                .skipped,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .completed: return "COMPLETED"
            case .failed: return "FAILED"
            case .running: return "RUNNING"
            case .skipped: return "SKIPPED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ScanStatus(rawValue: rawValue) ?? ScanStatus.sdkUnknown(rawValue)
        }
    }
}

extension GuardDutyClientTypes.ScanThreatName: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filePaths = "filePaths"
        case itemCount = "itemCount"
        case name = "name"
        case severity = "severity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filePaths = filePaths {
            var filePathsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filePaths)
            for scanfilepath0 in filePaths {
                try filePathsContainer.encode(scanfilepath0)
            }
        }
        if itemCount != 0 {
            try encodeContainer.encode(itemCount, forKey: .itemCount)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let severity = self.severity {
            try encodeContainer.encode(severity, forKey: .severity)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let severityDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .severity)
        severity = severityDecoded
        let itemCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .itemCount) ?? 0
        itemCount = itemCountDecoded
        let filePathsContainer = try containerValues.decodeIfPresent([GuardDutyClientTypes.ScanFilePath?].self, forKey: .filePaths)
        var filePathsDecoded0:[GuardDutyClientTypes.ScanFilePath]? = nil
        if let filePathsContainer = filePathsContainer {
            filePathsDecoded0 = [GuardDutyClientTypes.ScanFilePath]()
            for structure0 in filePathsContainer {
                if let structure0 = structure0 {
                    filePathsDecoded0?.append(structure0)
                }
            }
        }
        filePaths = filePathsDecoded0
    }
}

extension GuardDutyClientTypes {
    /// Contains files infected with the given threat providing details of malware name and severity.
    public struct ScanThreatName: Swift.Equatable {
        /// List of infected files in EBS volume with details.
        public var filePaths: [GuardDutyClientTypes.ScanFilePath]?
        /// Total number of files infected with given threat.
        public var itemCount: Swift.Int
        /// The name of the identified threat.
        public var name: Swift.String?
        /// Severity of threat identified as part of the malware scan.
        public var severity: Swift.String?

        public init(
            filePaths: [GuardDutyClientTypes.ScanFilePath]? = nil,
            itemCount: Swift.Int = 0,
            name: Swift.String? = nil,
            severity: Swift.String? = nil
        )
        {
            self.filePaths = filePaths
            self.itemCount = itemCount
            self.name = name
            self.severity = severity
        }
    }

}

extension GuardDutyClientTypes {
    public enum ScanType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case guarddutyInitiated
        case onDemand
        case sdkUnknown(Swift.String)

        public static var allCases: [ScanType] {
            return [
                .guarddutyInitiated,
                .onDemand,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .guarddutyInitiated: return "GUARDDUTY_INITIATED"
            case .onDemand: return "ON_DEMAND"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ScanType(rawValue: rawValue) ?? ScanType.sdkUnknown(rawValue)
        }
    }
}

extension GuardDutyClientTypes.ScannedItemCount: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case files = "files"
        case totalGb = "totalGb"
        case volumes = "volumes"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if files != 0 {
            try encodeContainer.encode(files, forKey: .files)
        }
        if totalGb != 0 {
            try encodeContainer.encode(totalGb, forKey: .totalGb)
        }
        if volumes != 0 {
            try encodeContainer.encode(volumes, forKey: .volumes)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let totalGbDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalGb) ?? 0
        totalGb = totalGbDecoded
        let filesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .files) ?? 0
        files = filesDecoded
        let volumesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .volumes) ?? 0
        volumes = volumesDecoded
    }
}

extension GuardDutyClientTypes {
    /// Total number of scanned files.
    public struct ScannedItemCount: Swift.Equatable {
        /// Number of files scanned.
        public var files: Swift.Int
        /// Total GB of files scanned for malware.
        public var totalGb: Swift.Int
        /// Total number of scanned volumes.
        public var volumes: Swift.Int

        public init(
            files: Swift.Int = 0,
            totalGb: Swift.Int = 0,
            volumes: Swift.Int = 0
        )
        {
            self.files = files
            self.totalGb = totalGb
            self.volumes = volumes
        }
    }

}

extension GuardDutyClientTypes.SecurityContext: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case privileged = "privileged"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if privileged != false {
            try encodeContainer.encode(privileged, forKey: .privileged)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let privilegedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .privileged) ?? false
        privileged = privilegedDecoded
    }
}

extension GuardDutyClientTypes {
    /// Container security context.
    public struct SecurityContext: Swift.Equatable {
        /// Whether the container is privileged.
        public var privileged: Swift.Bool

        public init(
            privileged: Swift.Bool = false
        )
        {
            self.privileged = privileged
        }
    }

}

extension GuardDutyClientTypes.SecurityGroup: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupId = "groupId"
        case groupName = "groupName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let groupId = self.groupId {
            try encodeContainer.encode(groupId, forKey: .groupId)
        }
        if let groupName = self.groupName {
            try encodeContainer.encode(groupName, forKey: .groupName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupId)
        groupId = groupIdDecoded
        let groupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupName)
        groupName = groupNameDecoded
    }
}

extension GuardDutyClientTypes {
    /// Contains information about the security groups associated with the EC2 instance.
    public struct SecurityGroup: Swift.Equatable {
        /// The security group ID of the EC2 instance.
        public var groupId: Swift.String?
        /// The security group name of the EC2 instance.
        public var groupName: Swift.String?

        public init(
            groupId: Swift.String? = nil,
            groupName: Swift.String? = nil
        )
        {
            self.groupId = groupId
            self.groupName = groupName
        }
    }

}

extension GuardDutyClientTypes.Service: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action = "action"
        case additionalInfo = "additionalInfo"
        case archived = "archived"
        case count = "count"
        case detectorId = "detectorId"
        case ebsVolumeScanDetails = "ebsVolumeScanDetails"
        case eventFirstSeen = "eventFirstSeen"
        case eventLastSeen = "eventLastSeen"
        case evidence = "evidence"
        case featureName = "featureName"
        case resourceRole = "resourceRole"
        case runtimeDetails = "runtimeDetails"
        case serviceName = "serviceName"
        case userFeedback = "userFeedback"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = self.action {
            try encodeContainer.encode(action, forKey: .action)
        }
        if let additionalInfo = self.additionalInfo {
            try encodeContainer.encode(additionalInfo, forKey: .additionalInfo)
        }
        if archived != false {
            try encodeContainer.encode(archived, forKey: .archived)
        }
        if count != 0 {
            try encodeContainer.encode(count, forKey: .count)
        }
        if let detectorId = self.detectorId {
            try encodeContainer.encode(detectorId, forKey: .detectorId)
        }
        if let ebsVolumeScanDetails = self.ebsVolumeScanDetails {
            try encodeContainer.encode(ebsVolumeScanDetails, forKey: .ebsVolumeScanDetails)
        }
        if let eventFirstSeen = self.eventFirstSeen {
            try encodeContainer.encode(eventFirstSeen, forKey: .eventFirstSeen)
        }
        if let eventLastSeen = self.eventLastSeen {
            try encodeContainer.encode(eventLastSeen, forKey: .eventLastSeen)
        }
        if let evidence = self.evidence {
            try encodeContainer.encode(evidence, forKey: .evidence)
        }
        if let featureName = self.featureName {
            try encodeContainer.encode(featureName, forKey: .featureName)
        }
        if let resourceRole = self.resourceRole {
            try encodeContainer.encode(resourceRole, forKey: .resourceRole)
        }
        if let runtimeDetails = self.runtimeDetails {
            try encodeContainer.encode(runtimeDetails, forKey: .runtimeDetails)
        }
        if let serviceName = self.serviceName {
            try encodeContainer.encode(serviceName, forKey: .serviceName)
        }
        if let userFeedback = self.userFeedback {
            try encodeContainer.encode(userFeedback, forKey: .userFeedback)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.Action.self, forKey: .action)
        action = actionDecoded
        let evidenceDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.Evidence.self, forKey: .evidence)
        evidence = evidenceDecoded
        let archivedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .archived) ?? false
        archived = archivedDecoded
        let countDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .count) ?? 0
        count = countDecoded
        let detectorIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detectorId)
        detectorId = detectorIdDecoded
        let eventFirstSeenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventFirstSeen)
        eventFirstSeen = eventFirstSeenDecoded
        let eventLastSeenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventLastSeen)
        eventLastSeen = eventLastSeenDecoded
        let resourceRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceRole)
        resourceRole = resourceRoleDecoded
        let serviceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceName)
        serviceName = serviceNameDecoded
        let userFeedbackDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userFeedback)
        userFeedback = userFeedbackDecoded
        let additionalInfoDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.ServiceAdditionalInfo.self, forKey: .additionalInfo)
        additionalInfo = additionalInfoDecoded
        let featureNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .featureName)
        featureName = featureNameDecoded
        let ebsVolumeScanDetailsDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.EbsVolumeScanDetails.self, forKey: .ebsVolumeScanDetails)
        ebsVolumeScanDetails = ebsVolumeScanDetailsDecoded
        let runtimeDetailsDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.RuntimeDetails.self, forKey: .runtimeDetails)
        runtimeDetails = runtimeDetailsDecoded
    }
}

extension GuardDutyClientTypes {
    /// Contains additional information about the generated finding.
    public struct Service: Swift.Equatable {
        /// Information about the activity that is described in a finding.
        public var action: GuardDutyClientTypes.Action?
        /// Contains additional information about the generated finding.
        public var additionalInfo: GuardDutyClientTypes.ServiceAdditionalInfo?
        /// Indicates whether this finding is archived.
        public var archived: Swift.Bool
        /// The total count of the occurrences of this finding type.
        public var count: Swift.Int
        /// The detector ID for the GuardDuty service.
        public var detectorId: Swift.String?
        /// Returns details from the malware scan that created a finding.
        public var ebsVolumeScanDetails: GuardDutyClientTypes.EbsVolumeScanDetails?
        /// The first-seen timestamp of the activity that prompted GuardDuty to generate this finding.
        public var eventFirstSeen: Swift.String?
        /// The last-seen timestamp of the activity that prompted GuardDuty to generate this finding.
        public var eventLastSeen: Swift.String?
        /// An evidence object associated with the service.
        public var evidence: GuardDutyClientTypes.Evidence?
        /// The name of the feature that generated a finding.
        public var featureName: Swift.String?
        /// The resource role information for this finding.
        public var resourceRole: Swift.String?
        /// Information about the process and any required context values for a specific finding
        public var runtimeDetails: GuardDutyClientTypes.RuntimeDetails?
        /// The name of the Amazon Web Services service (GuardDuty) that generated a finding.
        public var serviceName: Swift.String?
        /// Feedback that was submitted about the finding.
        public var userFeedback: Swift.String?

        public init(
            action: GuardDutyClientTypes.Action? = nil,
            additionalInfo: GuardDutyClientTypes.ServiceAdditionalInfo? = nil,
            archived: Swift.Bool = false,
            count: Swift.Int = 0,
            detectorId: Swift.String? = nil,
            ebsVolumeScanDetails: GuardDutyClientTypes.EbsVolumeScanDetails? = nil,
            eventFirstSeen: Swift.String? = nil,
            eventLastSeen: Swift.String? = nil,
            evidence: GuardDutyClientTypes.Evidence? = nil,
            featureName: Swift.String? = nil,
            resourceRole: Swift.String? = nil,
            runtimeDetails: GuardDutyClientTypes.RuntimeDetails? = nil,
            serviceName: Swift.String? = nil,
            userFeedback: Swift.String? = nil
        )
        {
            self.action = action
            self.additionalInfo = additionalInfo
            self.archived = archived
            self.count = count
            self.detectorId = detectorId
            self.ebsVolumeScanDetails = ebsVolumeScanDetails
            self.eventFirstSeen = eventFirstSeen
            self.eventLastSeen = eventLastSeen
            self.evidence = evidence
            self.featureName = featureName
            self.resourceRole = resourceRole
            self.runtimeDetails = runtimeDetails
            self.serviceName = serviceName
            self.userFeedback = userFeedback
        }
    }

}

extension GuardDutyClientTypes.ServiceAdditionalInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case type = "type"
        case value = "value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
    }
}

extension GuardDutyClientTypes {
    /// Additional information about the generated finding.
    public struct ServiceAdditionalInfo: Swift.Equatable {
        /// Describes the type of the additional information.
        public var type: Swift.String?
        /// This field specifies the value of the additional information.
        public var value: Swift.String?

        public init(
            type: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.type = type
            self.value = value
        }
    }

}

extension GuardDutyClientTypes.SortCriteria: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributeName = "attributeName"
        case orderBy = "orderBy"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributeName = self.attributeName {
            try encodeContainer.encode(attributeName, forKey: .attributeName)
        }
        if let orderBy = self.orderBy {
            try encodeContainer.encode(orderBy.rawValue, forKey: .orderBy)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .attributeName)
        attributeName = attributeNameDecoded
        let orderByDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.OrderBy.self, forKey: .orderBy)
        orderBy = orderByDecoded
    }
}

extension GuardDutyClientTypes {
    /// Contains information about the criteria used for sorting findings.
    public struct SortCriteria: Swift.Equatable {
        /// Represents the finding attribute, such as accountId, that sorts the findings.
        public var attributeName: Swift.String?
        /// The order by which the sorted findings are to be displayed.
        public var orderBy: GuardDutyClientTypes.OrderBy?

        public init(
            attributeName: Swift.String? = nil,
            orderBy: GuardDutyClientTypes.OrderBy? = nil
        )
        {
            self.attributeName = attributeName
            self.orderBy = orderBy
        }
    }

}

extension StartMalwareScanInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "resourceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }
}

extension StartMalwareScanInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/malware-scan/start"
    }
}

public struct StartMalwareScanInput: Swift.Equatable {
    /// Amazon Resource Name (ARN) of the resource for which you invoked the API.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct StartMalwareScanInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
}

extension StartMalwareScanInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn = "resourceArn"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
    }
}

extension StartMalwareScanOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StartMalwareScanOutputBody = try responseDecoder.decode(responseBody: data)
            self.scanId = output.scanId
        } else {
            self.scanId = nil
        }
    }
}

public struct StartMalwareScanOutput: Swift.Equatable {
    /// A unique identifier that gets generated when you invoke the API without any error. Each malware scan has a corresponding scan ID. Using this scan ID, you can monitor the status of your malware scan.
    public var scanId: Swift.String?

    public init(
        scanId: Swift.String? = nil
    )
    {
        self.scanId = scanId
    }
}

struct StartMalwareScanOutputBody: Swift.Equatable {
    let scanId: Swift.String?
}

extension StartMalwareScanOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case scanId = "scanId"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scanIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .scanId)
        scanId = scanIdDecoded
    }
}

enum StartMalwareScanOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension StartMonitoringMembersInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountIds = "accountIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountIds = accountIds {
            var accountIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accountIds)
            for accountid0 in accountIds {
                try accountIdsContainer.encode(accountid0)
            }
        }
    }
}

extension StartMonitoringMembersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let detectorId = detectorId else {
            return nil
        }
        return "/detector/\(detectorId.urlPercentEncoding())/member/start"
    }
}

public struct StartMonitoringMembersInput: Swift.Equatable {
    /// A list of account IDs of the GuardDuty member accounts to start monitoring.
    /// This member is required.
    public var accountIds: [Swift.String]?
    /// The unique ID of the detector of the GuardDuty administrator account associated with the member accounts to monitor.
    /// This member is required.
    public var detectorId: Swift.String?

    public init(
        accountIds: [Swift.String]? = nil,
        detectorId: Swift.String? = nil
    )
    {
        self.accountIds = accountIds
        self.detectorId = detectorId
    }
}

struct StartMonitoringMembersInputBody: Swift.Equatable {
    let accountIds: [Swift.String]?
}

extension StartMonitoringMembersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountIds = "accountIds"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .accountIds)
        var accountIdsDecoded0:[Swift.String]? = nil
        if let accountIdsContainer = accountIdsContainer {
            accountIdsDecoded0 = [Swift.String]()
            for string0 in accountIdsContainer {
                if let string0 = string0 {
                    accountIdsDecoded0?.append(string0)
                }
            }
        }
        accountIds = accountIdsDecoded0
    }
}

extension StartMonitoringMembersOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StartMonitoringMembersOutputBody = try responseDecoder.decode(responseBody: data)
            self.unprocessedAccounts = output.unprocessedAccounts
        } else {
            self.unprocessedAccounts = nil
        }
    }
}

public struct StartMonitoringMembersOutput: Swift.Equatable {
    /// A list of objects that contain the unprocessed account and a result string that explains why it was unprocessed.
    /// This member is required.
    public var unprocessedAccounts: [GuardDutyClientTypes.UnprocessedAccount]?

    public init(
        unprocessedAccounts: [GuardDutyClientTypes.UnprocessedAccount]? = nil
    )
    {
        self.unprocessedAccounts = unprocessedAccounts
    }
}

struct StartMonitoringMembersOutputBody: Swift.Equatable {
    let unprocessedAccounts: [GuardDutyClientTypes.UnprocessedAccount]?
}

extension StartMonitoringMembersOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case unprocessedAccounts = "unprocessedAccounts"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let unprocessedAccountsContainer = try containerValues.decodeIfPresent([GuardDutyClientTypes.UnprocessedAccount?].self, forKey: .unprocessedAccounts)
        var unprocessedAccountsDecoded0:[GuardDutyClientTypes.UnprocessedAccount]? = nil
        if let unprocessedAccountsContainer = unprocessedAccountsContainer {
            unprocessedAccountsDecoded0 = [GuardDutyClientTypes.UnprocessedAccount]()
            for structure0 in unprocessedAccountsContainer {
                if let structure0 = structure0 {
                    unprocessedAccountsDecoded0?.append(structure0)
                }
            }
        }
        unprocessedAccounts = unprocessedAccountsDecoded0
    }
}

enum StartMonitoringMembersOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension StopMonitoringMembersInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountIds = "accountIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountIds = accountIds {
            var accountIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accountIds)
            for accountid0 in accountIds {
                try accountIdsContainer.encode(accountid0)
            }
        }
    }
}

extension StopMonitoringMembersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let detectorId = detectorId else {
            return nil
        }
        return "/detector/\(detectorId.urlPercentEncoding())/member/stop"
    }
}

public struct StopMonitoringMembersInput: Swift.Equatable {
    /// A list of account IDs for the member accounts to stop monitoring.
    /// This member is required.
    public var accountIds: [Swift.String]?
    /// The unique ID of the detector associated with the GuardDuty administrator account that is monitoring member accounts.
    /// This member is required.
    public var detectorId: Swift.String?

    public init(
        accountIds: [Swift.String]? = nil,
        detectorId: Swift.String? = nil
    )
    {
        self.accountIds = accountIds
        self.detectorId = detectorId
    }
}

struct StopMonitoringMembersInputBody: Swift.Equatable {
    let accountIds: [Swift.String]?
}

extension StopMonitoringMembersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountIds = "accountIds"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .accountIds)
        var accountIdsDecoded0:[Swift.String]? = nil
        if let accountIdsContainer = accountIdsContainer {
            accountIdsDecoded0 = [Swift.String]()
            for string0 in accountIdsContainer {
                if let string0 = string0 {
                    accountIdsDecoded0?.append(string0)
                }
            }
        }
        accountIds = accountIdsDecoded0
    }
}

extension StopMonitoringMembersOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StopMonitoringMembersOutputBody = try responseDecoder.decode(responseBody: data)
            self.unprocessedAccounts = output.unprocessedAccounts
        } else {
            self.unprocessedAccounts = nil
        }
    }
}

public struct StopMonitoringMembersOutput: Swift.Equatable {
    /// A list of objects that contain an accountId for each account that could not be processed, and a result string that indicates why the account was not processed.
    /// This member is required.
    public var unprocessedAccounts: [GuardDutyClientTypes.UnprocessedAccount]?

    public init(
        unprocessedAccounts: [GuardDutyClientTypes.UnprocessedAccount]? = nil
    )
    {
        self.unprocessedAccounts = unprocessedAccounts
    }
}

struct StopMonitoringMembersOutputBody: Swift.Equatable {
    let unprocessedAccounts: [GuardDutyClientTypes.UnprocessedAccount]?
}

extension StopMonitoringMembersOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case unprocessedAccounts = "unprocessedAccounts"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let unprocessedAccountsContainer = try containerValues.decodeIfPresent([GuardDutyClientTypes.UnprocessedAccount?].self, forKey: .unprocessedAccounts)
        var unprocessedAccountsDecoded0:[GuardDutyClientTypes.UnprocessedAccount]? = nil
        if let unprocessedAccountsContainer = unprocessedAccountsContainer {
            unprocessedAccountsDecoded0 = [GuardDutyClientTypes.UnprocessedAccount]()
            for structure0 in unprocessedAccountsContainer {
                if let structure0 = structure0 {
                    unprocessedAccountsDecoded0?.append(structure0)
                }
            }
        }
        unprocessedAccounts = unprocessedAccountsDecoded0
    }
}

enum StopMonitoringMembersOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GuardDutyClientTypes.Tag: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "key"
        case value = "value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension GuardDutyClientTypes {
    /// Contains information about a tag associated with the EC2 instance.
    public struct Tag: Swift.Equatable {
        /// The EC2 instance tag key.
        public var key: Swift.String?
        /// The EC2 instance tag value.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) for the GuardDuty resource to apply a tag to.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tags to be added to a resource.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "tags"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct TagResourceOutput: Swift.Equatable {

    public init() { }
}

enum TagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GuardDutyClientTypes.ThreatDetectedByName: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case itemCount = "itemCount"
        case shortened = "shortened"
        case threatNames = "threatNames"
        case uniqueThreatNameCount = "uniqueThreatNameCount"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if itemCount != 0 {
            try encodeContainer.encode(itemCount, forKey: .itemCount)
        }
        if shortened != false {
            try encodeContainer.encode(shortened, forKey: .shortened)
        }
        if let threatNames = threatNames {
            var threatNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .threatNames)
            for scanthreatname0 in threatNames {
                try threatNamesContainer.encode(scanthreatname0)
            }
        }
        if uniqueThreatNameCount != 0 {
            try encodeContainer.encode(uniqueThreatNameCount, forKey: .uniqueThreatNameCount)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .itemCount) ?? 0
        itemCount = itemCountDecoded
        let uniqueThreatNameCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .uniqueThreatNameCount) ?? 0
        uniqueThreatNameCount = uniqueThreatNameCountDecoded
        let shortenedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .shortened) ?? false
        shortened = shortenedDecoded
        let threatNamesContainer = try containerValues.decodeIfPresent([GuardDutyClientTypes.ScanThreatName?].self, forKey: .threatNames)
        var threatNamesDecoded0:[GuardDutyClientTypes.ScanThreatName]? = nil
        if let threatNamesContainer = threatNamesContainer {
            threatNamesDecoded0 = [GuardDutyClientTypes.ScanThreatName]()
            for structure0 in threatNamesContainer {
                if let structure0 = structure0 {
                    threatNamesDecoded0?.append(structure0)
                }
            }
        }
        threatNames = threatNamesDecoded0
    }
}

extension GuardDutyClientTypes {
    /// Contains details about identified threats organized by threat name.
    public struct ThreatDetectedByName: Swift.Equatable {
        /// Total number of infected files identified.
        public var itemCount: Swift.Int
        /// Flag to determine if the finding contains every single infected file-path and/or every threat.
        public var shortened: Swift.Bool
        /// List of identified threats with details, organized by threat name.
        public var threatNames: [GuardDutyClientTypes.ScanThreatName]?
        /// Total number of unique threats by name identified, as part of the malware scan.
        public var uniqueThreatNameCount: Swift.Int

        public init(
            itemCount: Swift.Int = 0,
            shortened: Swift.Bool = false,
            threatNames: [GuardDutyClientTypes.ScanThreatName]? = nil,
            uniqueThreatNameCount: Swift.Int = 0
        )
        {
            self.itemCount = itemCount
            self.shortened = shortened
            self.threatNames = threatNames
            self.uniqueThreatNameCount = uniqueThreatNameCount
        }
    }

}

extension GuardDutyClientTypes {
    public enum ThreatIntelSetFormat: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case alienVault
        case fireEye
        case otxCsv
        case proofPoint
        case stix
        case txt
        case sdkUnknown(Swift.String)

        public static var allCases: [ThreatIntelSetFormat] {
            return [
                .alienVault,
                .fireEye,
                .otxCsv,
                .proofPoint,
                .stix,
                .txt,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .alienVault: return "ALIEN_VAULT"
            case .fireEye: return "FIRE_EYE"
            case .otxCsv: return "OTX_CSV"
            case .proofPoint: return "PROOF_POINT"
            case .stix: return "STIX"
            case .txt: return "TXT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ThreatIntelSetFormat(rawValue: rawValue) ?? ThreatIntelSetFormat.sdkUnknown(rawValue)
        }
    }
}

extension GuardDutyClientTypes {
    public enum ThreatIntelSetStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case activating
        case active
        case deactivating
        case deleted
        case deletePending
        case error
        case inactive
        case sdkUnknown(Swift.String)

        public static var allCases: [ThreatIntelSetStatus] {
            return [
                .activating,
                .active,
                .deactivating,
                .deleted,
                .deletePending,
                .error,
                .inactive,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .activating: return "ACTIVATING"
            case .active: return "ACTIVE"
            case .deactivating: return "DEACTIVATING"
            case .deleted: return "DELETED"
            case .deletePending: return "DELETE_PENDING"
            case .error: return "ERROR"
            case .inactive: return "INACTIVE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ThreatIntelSetStatus(rawValue: rawValue) ?? ThreatIntelSetStatus.sdkUnknown(rawValue)
        }
    }
}

extension GuardDutyClientTypes.ThreatIntelligenceDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case threatListName = "threatListName"
        case threatNames = "threatNames"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let threatListName = self.threatListName {
            try encodeContainer.encode(threatListName, forKey: .threatListName)
        }
        if let threatNames = threatNames {
            var threatNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .threatNames)
            for string0 in threatNames {
                try threatNamesContainer.encode(string0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let threatListNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .threatListName)
        threatListName = threatListNameDecoded
        let threatNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .threatNames)
        var threatNamesDecoded0:[Swift.String]? = nil
        if let threatNamesContainer = threatNamesContainer {
            threatNamesDecoded0 = [Swift.String]()
            for string0 in threatNamesContainer {
                if let string0 = string0 {
                    threatNamesDecoded0?.append(string0)
                }
            }
        }
        threatNames = threatNamesDecoded0
    }
}

extension GuardDutyClientTypes {
    /// An instance of a threat intelligence detail that constitutes evidence for the finding.
    public struct ThreatIntelligenceDetail: Swift.Equatable {
        /// The name of the threat intelligence list that triggered the finding.
        public var threatListName: Swift.String?
        /// A list of names of the threats in the threat intelligence list that triggered the finding.
        public var threatNames: [Swift.String]?

        public init(
            threatListName: Swift.String? = nil,
            threatNames: [Swift.String]? = nil
        )
        {
            self.threatListName = threatListName
            self.threatNames = threatNames
        }
    }

}

extension GuardDutyClientTypes.ThreatsDetectedItemCount: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case files = "files"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if files != 0 {
            try encodeContainer.encode(files, forKey: .files)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .files) ?? 0
        files = filesDecoded
    }
}

extension GuardDutyClientTypes {
    /// Contains total number of infected files.
    public struct ThreatsDetectedItemCount: Swift.Equatable {
        /// Total number of infected files.
        public var files: Swift.Int

        public init(
            files: Swift.Int = 0
        )
        {
            self.files = files
        }
    }

}

extension GuardDutyClientTypes.Total: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case amount = "amount"
        case unit = "unit"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let amount = self.amount {
            try encodeContainer.encode(amount, forKey: .amount)
        }
        if let unit = self.unit {
            try encodeContainer.encode(unit, forKey: .unit)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let amountDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .amount)
        amount = amountDecoded
        let unitDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .unit)
        unit = unitDecoded
    }
}

extension GuardDutyClientTypes {
    /// Contains the total usage with the corresponding currency unit for that value.
    public struct Total: Swift.Equatable {
        /// The total usage.
        public var amount: Swift.String?
        /// The currency unit that the amount is given in.
        public var unit: Swift.String?

        public init(
            amount: Swift.String? = nil,
            unit: Swift.String? = nil
        )
        {
            self.amount = amount
            self.unit = unit
        }
    }

}

extension GuardDutyClientTypes.TriggerDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "description"
        case guardDutyFindingId = "guardDutyFindingId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let guardDutyFindingId = self.guardDutyFindingId {
            try encodeContainer.encode(guardDutyFindingId, forKey: .guardDutyFindingId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let guardDutyFindingIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .guardDutyFindingId)
        guardDutyFindingId = guardDutyFindingIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension GuardDutyClientTypes {
    /// Represents the reason the scan was triggered.
    public struct TriggerDetails: Swift.Equatable {
        /// The description of the scan trigger.
        public var description: Swift.String?
        /// The ID of the GuardDuty finding that triggered the malware scan.
        public var guardDutyFindingId: Swift.String?

        public init(
            description: Swift.String? = nil,
            guardDutyFindingId: Swift.String? = nil
        )
        {
            self.description = description
            self.guardDutyFindingId = guardDutyFindingId
        }
    }

}

extension UnarchiveFindingsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case findingIds = "findingIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let findingIds = findingIds {
            var findingIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .findingIds)
            for findingid0 in findingIds {
                try findingIdsContainer.encode(findingid0)
            }
        }
    }
}

extension UnarchiveFindingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let detectorId = detectorId else {
            return nil
        }
        return "/detector/\(detectorId.urlPercentEncoding())/findings/unarchive"
    }
}

public struct UnarchiveFindingsInput: Swift.Equatable {
    /// The ID of the detector associated with the findings to unarchive.
    /// This member is required.
    public var detectorId: Swift.String?
    /// The IDs of the findings to unarchive.
    /// This member is required.
    public var findingIds: [Swift.String]?

    public init(
        detectorId: Swift.String? = nil,
        findingIds: [Swift.String]? = nil
    )
    {
        self.detectorId = detectorId
        self.findingIds = findingIds
    }
}

struct UnarchiveFindingsInputBody: Swift.Equatable {
    let findingIds: [Swift.String]?
}

extension UnarchiveFindingsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case findingIds = "findingIds"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let findingIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .findingIds)
        var findingIdsDecoded0:[Swift.String]? = nil
        if let findingIdsContainer = findingIdsContainer {
            findingIdsDecoded0 = [Swift.String]()
            for string0 in findingIdsContainer {
                if let string0 = string0 {
                    findingIdsDecoded0?.append(string0)
                }
            }
        }
        findingIds = findingIdsDecoded0
    }
}

extension UnarchiveFindingsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UnarchiveFindingsOutput: Swift.Equatable {

    public init() { }
}

enum UnarchiveFindingsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GuardDutyClientTypes.UnprocessedAccount: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "accountId"
        case result = "result"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let result = self.result {
            try encodeContainer.encode(result, forKey: .result)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let resultDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .result)
        result = resultDecoded
    }
}

extension GuardDutyClientTypes {
    /// Contains information about the accounts that weren't processed.
    public struct UnprocessedAccount: Swift.Equatable {
        /// The Amazon Web Services account ID.
        /// This member is required.
        public var accountId: Swift.String?
        /// A reason why the account hasn't been processed.
        /// This member is required.
        public var result: Swift.String?

        public init(
            accountId: Swift.String? = nil,
            result: Swift.String? = nil
        )
        {
            self.accountId = accountId
            self.result = result
        }
    }

}

extension GuardDutyClientTypes.UnprocessedDataSourcesResult: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case malwareProtection = "malwareProtection"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let malwareProtection = self.malwareProtection {
            try encodeContainer.encode(malwareProtection, forKey: .malwareProtection)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let malwareProtectionDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.MalwareProtectionConfigurationResult.self, forKey: .malwareProtection)
        malwareProtection = malwareProtectionDecoded
    }
}

extension GuardDutyClientTypes {
    /// Specifies the names of the data sources that couldn't be enabled.
    public struct UnprocessedDataSourcesResult: Swift.Equatable {
        /// An object that contains information on the status of all Malware Protection data sources.
        public var malwareProtection: GuardDutyClientTypes.MalwareProtectionConfigurationResult?

        public init(
            malwareProtection: GuardDutyClientTypes.MalwareProtectionConfigurationResult? = nil
        )
        {
            self.malwareProtection = malwareProtection
        }
    }

}

extension UntagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let tagKeys = tagKeys else {
                let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
                throw ClientRuntime.ClientError.unknownError(message)
            }
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
            return items
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) for the resource to remove tags from.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tag keys to remove from the resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UntagResourceOutput: Swift.Equatable {

    public init() { }
}

enum UntagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateDetectorInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataSources = "dataSources"
        case enable = "enable"
        case features = "features"
        case findingPublishingFrequency = "findingPublishingFrequency"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataSources = self.dataSources {
            try encodeContainer.encode(dataSources, forKey: .dataSources)
        }
        if let enable = self.enable {
            try encodeContainer.encode(enable, forKey: .enable)
        }
        if let features = features {
            var featuresContainer = encodeContainer.nestedUnkeyedContainer(forKey: .features)
            for detectorfeatureconfiguration0 in features {
                try featuresContainer.encode(detectorfeatureconfiguration0)
            }
        }
        if let findingPublishingFrequency = self.findingPublishingFrequency {
            try encodeContainer.encode(findingPublishingFrequency.rawValue, forKey: .findingPublishingFrequency)
        }
    }
}

extension UpdateDetectorInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let detectorId = detectorId else {
            return nil
        }
        return "/detector/\(detectorId.urlPercentEncoding())"
    }
}

public struct UpdateDetectorInput: Swift.Equatable {
    /// Describes which data sources will be updated. There might be regional differences because some data sources might not be available in all the Amazon Web Services Regions where GuardDuty is presently supported. For more information, see [Regions and endpoints](https://docs.aws.amazon.com/guardduty/latest/ug/guardduty_regions.html).
    @available(*, deprecated, message: "This parameter is deprecated, use Features instead")
    public var dataSources: GuardDutyClientTypes.DataSourceConfigurations?
    /// The unique ID of the detector to update.
    /// This member is required.
    public var detectorId: Swift.String?
    /// Specifies whether the detector is enabled or not enabled.
    public var enable: Swift.Bool?
    /// Provides the features that will be updated for the detector.
    public var features: [GuardDutyClientTypes.DetectorFeatureConfiguration]?
    /// An enum value that specifies how frequently findings are exported, such as to CloudWatch Events.
    public var findingPublishingFrequency: GuardDutyClientTypes.FindingPublishingFrequency?

    public init(
        dataSources: GuardDutyClientTypes.DataSourceConfigurations? = nil,
        detectorId: Swift.String? = nil,
        enable: Swift.Bool? = nil,
        features: [GuardDutyClientTypes.DetectorFeatureConfiguration]? = nil,
        findingPublishingFrequency: GuardDutyClientTypes.FindingPublishingFrequency? = nil
    )
    {
        self.dataSources = dataSources
        self.detectorId = detectorId
        self.enable = enable
        self.features = features
        self.findingPublishingFrequency = findingPublishingFrequency
    }
}

struct UpdateDetectorInputBody: Swift.Equatable {
    let enable: Swift.Bool?
    let findingPublishingFrequency: GuardDutyClientTypes.FindingPublishingFrequency?
    let dataSources: GuardDutyClientTypes.DataSourceConfigurations?
    let features: [GuardDutyClientTypes.DetectorFeatureConfiguration]?
}

extension UpdateDetectorInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataSources = "dataSources"
        case enable = "enable"
        case features = "features"
        case findingPublishingFrequency = "findingPublishingFrequency"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enableDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enable)
        enable = enableDecoded
        let findingPublishingFrequencyDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.FindingPublishingFrequency.self, forKey: .findingPublishingFrequency)
        findingPublishingFrequency = findingPublishingFrequencyDecoded
        let dataSourcesDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.DataSourceConfigurations.self, forKey: .dataSources)
        dataSources = dataSourcesDecoded
        let featuresContainer = try containerValues.decodeIfPresent([GuardDutyClientTypes.DetectorFeatureConfiguration?].self, forKey: .features)
        var featuresDecoded0:[GuardDutyClientTypes.DetectorFeatureConfiguration]? = nil
        if let featuresContainer = featuresContainer {
            featuresDecoded0 = [GuardDutyClientTypes.DetectorFeatureConfiguration]()
            for structure0 in featuresContainer {
                if let structure0 = structure0 {
                    featuresDecoded0?.append(structure0)
                }
            }
        }
        features = featuresDecoded0
    }
}

extension UpdateDetectorOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateDetectorOutput: Swift.Equatable {

    public init() { }
}

enum UpdateDetectorOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateFilterInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action = "action"
        case description = "description"
        case findingCriteria = "findingCriteria"
        case rank = "rank"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = self.action {
            try encodeContainer.encode(action.rawValue, forKey: .action)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let findingCriteria = self.findingCriteria {
            try encodeContainer.encode(findingCriteria, forKey: .findingCriteria)
        }
        if let rank = self.rank {
            try encodeContainer.encode(rank, forKey: .rank)
        }
    }
}

extension UpdateFilterInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let detectorId = detectorId else {
            return nil
        }
        guard let filterName = filterName else {
            return nil
        }
        return "/detector/\(detectorId.urlPercentEncoding())/filter/\(filterName.urlPercentEncoding())"
    }
}

public struct UpdateFilterInput: Swift.Equatable {
    /// Specifies the action that is to be applied to the findings that match the filter.
    public var action: GuardDutyClientTypes.FilterAction?
    /// The description of the filter. Valid characters include alphanumeric characters, and special characters such as hyphen, period, colon, underscore, parentheses ({ }, [ ], and ( )), forward slash, horizontal tab, vertical tab, newline, form feed, return, and whitespace.
    public var description: Swift.String?
    /// The unique ID of the detector that specifies the GuardDuty service where you want to update a filter.
    /// This member is required.
    public var detectorId: Swift.String?
    /// The name of the filter.
    /// This member is required.
    public var filterName: Swift.String?
    /// Represents the criteria to be used in the filter for querying findings.
    public var findingCriteria: GuardDutyClientTypes.FindingCriteria?
    /// Specifies the position of the filter in the list of current filters. Also specifies the order in which this filter is applied to the findings.
    public var rank: Swift.Int?

    public init(
        action: GuardDutyClientTypes.FilterAction? = nil,
        description: Swift.String? = nil,
        detectorId: Swift.String? = nil,
        filterName: Swift.String? = nil,
        findingCriteria: GuardDutyClientTypes.FindingCriteria? = nil,
        rank: Swift.Int? = nil
    )
    {
        self.action = action
        self.description = description
        self.detectorId = detectorId
        self.filterName = filterName
        self.findingCriteria = findingCriteria
        self.rank = rank
    }
}

struct UpdateFilterInputBody: Swift.Equatable {
    let description: Swift.String?
    let action: GuardDutyClientTypes.FilterAction?
    let rank: Swift.Int?
    let findingCriteria: GuardDutyClientTypes.FindingCriteria?
}

extension UpdateFilterInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action = "action"
        case description = "description"
        case findingCriteria = "findingCriteria"
        case rank = "rank"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let actionDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.FilterAction.self, forKey: .action)
        action = actionDecoded
        let rankDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .rank)
        rank = rankDecoded
        let findingCriteriaDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.FindingCriteria.self, forKey: .findingCriteria)
        findingCriteria = findingCriteriaDecoded
    }
}

extension UpdateFilterOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateFilterOutputBody = try responseDecoder.decode(responseBody: data)
            self.name = output.name
        } else {
            self.name = nil
        }
    }
}

public struct UpdateFilterOutput: Swift.Equatable {
    /// The name of the filter.
    /// This member is required.
    public var name: Swift.String?

    public init(
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct UpdateFilterOutputBody: Swift.Equatable {
    let name: Swift.String?
}

extension UpdateFilterOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "name"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

enum UpdateFilterOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateFindingsFeedbackInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case comments = "comments"
        case feedback = "feedback"
        case findingIds = "findingIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let comments = self.comments {
            try encodeContainer.encode(comments, forKey: .comments)
        }
        if let feedback = self.feedback {
            try encodeContainer.encode(feedback.rawValue, forKey: .feedback)
        }
        if let findingIds = findingIds {
            var findingIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .findingIds)
            for findingid0 in findingIds {
                try findingIdsContainer.encode(findingid0)
            }
        }
    }
}

extension UpdateFindingsFeedbackInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let detectorId = detectorId else {
            return nil
        }
        return "/detector/\(detectorId.urlPercentEncoding())/findings/feedback"
    }
}

public struct UpdateFindingsFeedbackInput: Swift.Equatable {
    /// Additional feedback about the GuardDuty findings.
    public var comments: Swift.String?
    /// The ID of the detector associated with the findings to update feedback for.
    /// This member is required.
    public var detectorId: Swift.String?
    /// The feedback for the finding.
    /// This member is required.
    public var feedback: GuardDutyClientTypes.Feedback?
    /// The IDs of the findings that you want to mark as useful or not useful.
    /// This member is required.
    public var findingIds: [Swift.String]?

    public init(
        comments: Swift.String? = nil,
        detectorId: Swift.String? = nil,
        feedback: GuardDutyClientTypes.Feedback? = nil,
        findingIds: [Swift.String]? = nil
    )
    {
        self.comments = comments
        self.detectorId = detectorId
        self.feedback = feedback
        self.findingIds = findingIds
    }
}

struct UpdateFindingsFeedbackInputBody: Swift.Equatable {
    let findingIds: [Swift.String]?
    let feedback: GuardDutyClientTypes.Feedback?
    let comments: Swift.String?
}

extension UpdateFindingsFeedbackInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case comments = "comments"
        case feedback = "feedback"
        case findingIds = "findingIds"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let findingIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .findingIds)
        var findingIdsDecoded0:[Swift.String]? = nil
        if let findingIdsContainer = findingIdsContainer {
            findingIdsDecoded0 = [Swift.String]()
            for string0 in findingIdsContainer {
                if let string0 = string0 {
                    findingIdsDecoded0?.append(string0)
                }
            }
        }
        findingIds = findingIdsDecoded0
        let feedbackDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.Feedback.self, forKey: .feedback)
        feedback = feedbackDecoded
        let commentsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .comments)
        comments = commentsDecoded
    }
}

extension UpdateFindingsFeedbackOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateFindingsFeedbackOutput: Swift.Equatable {

    public init() { }
}

enum UpdateFindingsFeedbackOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateIPSetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case activate = "activate"
        case location = "location"
        case name = "name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let activate = self.activate {
            try encodeContainer.encode(activate, forKey: .activate)
        }
        if let location = self.location {
            try encodeContainer.encode(location, forKey: .location)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension UpdateIPSetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let detectorId = detectorId else {
            return nil
        }
        guard let ipSetId = ipSetId else {
            return nil
        }
        return "/detector/\(detectorId.urlPercentEncoding())/ipset/\(ipSetId.urlPercentEncoding())"
    }
}

public struct UpdateIPSetInput: Swift.Equatable {
    /// The updated Boolean value that specifies whether the IPSet is active or not.
    public var activate: Swift.Bool?
    /// The detectorID that specifies the GuardDuty service whose IPSet you want to update.
    /// This member is required.
    public var detectorId: Swift.String?
    /// The unique ID that specifies the IPSet that you want to update.
    /// This member is required.
    public var ipSetId: Swift.String?
    /// The updated URI of the file that contains the IPSet.
    public var location: Swift.String?
    /// The unique ID that specifies the IPSet that you want to update.
    public var name: Swift.String?

    public init(
        activate: Swift.Bool? = nil,
        detectorId: Swift.String? = nil,
        ipSetId: Swift.String? = nil,
        location: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.activate = activate
        self.detectorId = detectorId
        self.ipSetId = ipSetId
        self.location = location
        self.name = name
    }
}

struct UpdateIPSetInputBody: Swift.Equatable {
    let name: Swift.String?
    let location: Swift.String?
    let activate: Swift.Bool?
}

extension UpdateIPSetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case activate = "activate"
        case location = "location"
        case name = "name"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let locationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .location)
        location = locationDecoded
        let activateDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .activate)
        activate = activateDecoded
    }
}

extension UpdateIPSetOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateIPSetOutput: Swift.Equatable {

    public init() { }
}

enum UpdateIPSetOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateMalwareScanSettingsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ebsSnapshotPreservation = "ebsSnapshotPreservation"
        case scanResourceCriteria = "scanResourceCriteria"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ebsSnapshotPreservation = self.ebsSnapshotPreservation {
            try encodeContainer.encode(ebsSnapshotPreservation.rawValue, forKey: .ebsSnapshotPreservation)
        }
        if let scanResourceCriteria = self.scanResourceCriteria {
            try encodeContainer.encode(scanResourceCriteria, forKey: .scanResourceCriteria)
        }
    }
}

extension UpdateMalwareScanSettingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let detectorId = detectorId else {
            return nil
        }
        return "/detector/\(detectorId.urlPercentEncoding())/malware-scan-settings"
    }
}

public struct UpdateMalwareScanSettingsInput: Swift.Equatable {
    /// The unique ID of the detector that specifies the GuardDuty service where you want to update scan settings.
    /// This member is required.
    public var detectorId: Swift.String?
    /// An enum value representing possible snapshot preservation settings.
    public var ebsSnapshotPreservation: GuardDutyClientTypes.EbsSnapshotPreservation?
    /// Represents the criteria to be used in the filter for selecting resources to scan.
    public var scanResourceCriteria: GuardDutyClientTypes.ScanResourceCriteria?

    public init(
        detectorId: Swift.String? = nil,
        ebsSnapshotPreservation: GuardDutyClientTypes.EbsSnapshotPreservation? = nil,
        scanResourceCriteria: GuardDutyClientTypes.ScanResourceCriteria? = nil
    )
    {
        self.detectorId = detectorId
        self.ebsSnapshotPreservation = ebsSnapshotPreservation
        self.scanResourceCriteria = scanResourceCriteria
    }
}

struct UpdateMalwareScanSettingsInputBody: Swift.Equatable {
    let scanResourceCriteria: GuardDutyClientTypes.ScanResourceCriteria?
    let ebsSnapshotPreservation: GuardDutyClientTypes.EbsSnapshotPreservation?
}

extension UpdateMalwareScanSettingsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ebsSnapshotPreservation = "ebsSnapshotPreservation"
        case scanResourceCriteria = "scanResourceCriteria"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scanResourceCriteriaDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.ScanResourceCriteria.self, forKey: .scanResourceCriteria)
        scanResourceCriteria = scanResourceCriteriaDecoded
        let ebsSnapshotPreservationDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.EbsSnapshotPreservation.self, forKey: .ebsSnapshotPreservation)
        ebsSnapshotPreservation = ebsSnapshotPreservationDecoded
    }
}

extension UpdateMalwareScanSettingsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateMalwareScanSettingsOutput: Swift.Equatable {

    public init() { }
}

enum UpdateMalwareScanSettingsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateMemberDetectorsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountIds = "accountIds"
        case dataSources = "dataSources"
        case features = "features"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountIds = accountIds {
            var accountIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accountIds)
            for accountid0 in accountIds {
                try accountIdsContainer.encode(accountid0)
            }
        }
        if let dataSources = self.dataSources {
            try encodeContainer.encode(dataSources, forKey: .dataSources)
        }
        if let features = features {
            var featuresContainer = encodeContainer.nestedUnkeyedContainer(forKey: .features)
            for memberfeaturesconfiguration0 in features {
                try featuresContainer.encode(memberfeaturesconfiguration0)
            }
        }
    }
}

extension UpdateMemberDetectorsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let detectorId = detectorId else {
            return nil
        }
        return "/detector/\(detectorId.urlPercentEncoding())/member/detector/update"
    }
}

public struct UpdateMemberDetectorsInput: Swift.Equatable {
    /// A list of member account IDs to be updated.
    /// This member is required.
    public var accountIds: [Swift.String]?
    /// Describes which data sources will be updated.
    @available(*, deprecated, message: "This parameter is deprecated, use Features instead")
    public var dataSources: GuardDutyClientTypes.DataSourceConfigurations?
    /// The detector ID of the administrator account.
    /// This member is required.
    public var detectorId: Swift.String?
    /// A list of features that will be updated for the specified member accounts.
    public var features: [GuardDutyClientTypes.MemberFeaturesConfiguration]?

    public init(
        accountIds: [Swift.String]? = nil,
        dataSources: GuardDutyClientTypes.DataSourceConfigurations? = nil,
        detectorId: Swift.String? = nil,
        features: [GuardDutyClientTypes.MemberFeaturesConfiguration]? = nil
    )
    {
        self.accountIds = accountIds
        self.dataSources = dataSources
        self.detectorId = detectorId
        self.features = features
    }
}

struct UpdateMemberDetectorsInputBody: Swift.Equatable {
    let accountIds: [Swift.String]?
    let dataSources: GuardDutyClientTypes.DataSourceConfigurations?
    let features: [GuardDutyClientTypes.MemberFeaturesConfiguration]?
}

extension UpdateMemberDetectorsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountIds = "accountIds"
        case dataSources = "dataSources"
        case features = "features"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .accountIds)
        var accountIdsDecoded0:[Swift.String]? = nil
        if let accountIdsContainer = accountIdsContainer {
            accountIdsDecoded0 = [Swift.String]()
            for string0 in accountIdsContainer {
                if let string0 = string0 {
                    accountIdsDecoded0?.append(string0)
                }
            }
        }
        accountIds = accountIdsDecoded0
        let dataSourcesDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.DataSourceConfigurations.self, forKey: .dataSources)
        dataSources = dataSourcesDecoded
        let featuresContainer = try containerValues.decodeIfPresent([GuardDutyClientTypes.MemberFeaturesConfiguration?].self, forKey: .features)
        var featuresDecoded0:[GuardDutyClientTypes.MemberFeaturesConfiguration]? = nil
        if let featuresContainer = featuresContainer {
            featuresDecoded0 = [GuardDutyClientTypes.MemberFeaturesConfiguration]()
            for structure0 in featuresContainer {
                if let structure0 = structure0 {
                    featuresDecoded0?.append(structure0)
                }
            }
        }
        features = featuresDecoded0
    }
}

extension UpdateMemberDetectorsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateMemberDetectorsOutputBody = try responseDecoder.decode(responseBody: data)
            self.unprocessedAccounts = output.unprocessedAccounts
        } else {
            self.unprocessedAccounts = nil
        }
    }
}

public struct UpdateMemberDetectorsOutput: Swift.Equatable {
    /// A list of member account IDs that were unable to be processed along with an explanation for why they were not processed.
    /// This member is required.
    public var unprocessedAccounts: [GuardDutyClientTypes.UnprocessedAccount]?

    public init(
        unprocessedAccounts: [GuardDutyClientTypes.UnprocessedAccount]? = nil
    )
    {
        self.unprocessedAccounts = unprocessedAccounts
    }
}

struct UpdateMemberDetectorsOutputBody: Swift.Equatable {
    let unprocessedAccounts: [GuardDutyClientTypes.UnprocessedAccount]?
}

extension UpdateMemberDetectorsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case unprocessedAccounts = "unprocessedAccounts"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let unprocessedAccountsContainer = try containerValues.decodeIfPresent([GuardDutyClientTypes.UnprocessedAccount?].self, forKey: .unprocessedAccounts)
        var unprocessedAccountsDecoded0:[GuardDutyClientTypes.UnprocessedAccount]? = nil
        if let unprocessedAccountsContainer = unprocessedAccountsContainer {
            unprocessedAccountsDecoded0 = [GuardDutyClientTypes.UnprocessedAccount]()
            for structure0 in unprocessedAccountsContainer {
                if let structure0 = structure0 {
                    unprocessedAccountsDecoded0?.append(structure0)
                }
            }
        }
        unprocessedAccounts = unprocessedAccountsDecoded0
    }
}

enum UpdateMemberDetectorsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateOrganizationConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoEnable = "autoEnable"
        case autoEnableOrganizationMembers = "autoEnableOrganizationMembers"
        case dataSources = "dataSources"
        case features = "features"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let autoEnable = self.autoEnable {
            try encodeContainer.encode(autoEnable, forKey: .autoEnable)
        }
        if let autoEnableOrganizationMembers = self.autoEnableOrganizationMembers {
            try encodeContainer.encode(autoEnableOrganizationMembers.rawValue, forKey: .autoEnableOrganizationMembers)
        }
        if let dataSources = self.dataSources {
            try encodeContainer.encode(dataSources, forKey: .dataSources)
        }
        if let features = features {
            var featuresContainer = encodeContainer.nestedUnkeyedContainer(forKey: .features)
            for organizationfeatureconfiguration0 in features {
                try featuresContainer.encode(organizationfeatureconfiguration0)
            }
        }
    }
}

extension UpdateOrganizationConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let detectorId = detectorId else {
            return nil
        }
        return "/detector/\(detectorId.urlPercentEncoding())/admin"
    }
}

public struct UpdateOrganizationConfigurationInput: Swift.Equatable {
    /// Represents whether or not to automatically enable member accounts in the organization. Even though this is still supported, we recommend using AutoEnableOrganizationMembers to achieve the similar results. You must provide a value for either autoEnableOrganizationMembers or autoEnable.
    @available(*, deprecated, message: "This field is deprecated, use AutoEnableOrganizationMembers instead")
    public var autoEnable: Swift.Bool?
    /// Indicates the auto-enablement configuration of GuardDuty for the member accounts in the organization. You must provide a value for either autoEnableOrganizationMembers or autoEnable. Use one of the following configuration values for autoEnableOrganizationMembers:
    ///
    /// * NEW: Indicates that when a new account joins the organization, they will have GuardDuty enabled automatically.
    ///
    /// * ALL: Indicates that all accounts in the organization have GuardDuty enabled automatically. This includes NEW accounts that join the organization and accounts that may have been suspended or removed from the organization in GuardDuty. It may take up to 24 hours to update the configuration for all the member accounts.
    ///
    /// * NONE: Indicates that GuardDuty will not be automatically enabled for any account in the organization. The administrator must manage GuardDuty for each account in the organization individually.
    public var autoEnableOrganizationMembers: GuardDutyClientTypes.AutoEnableMembers?
    /// Describes which data sources will be updated.
    @available(*, deprecated, message: "This parameter is deprecated, use Features instead")
    public var dataSources: GuardDutyClientTypes.OrganizationDataSourceConfigurations?
    /// The ID of the detector that configures the delegated administrator.
    /// This member is required.
    public var detectorId: Swift.String?
    /// A list of features that will be configured for the organization.
    public var features: [GuardDutyClientTypes.OrganizationFeatureConfiguration]?

    public init(
        autoEnable: Swift.Bool? = nil,
        autoEnableOrganizationMembers: GuardDutyClientTypes.AutoEnableMembers? = nil,
        dataSources: GuardDutyClientTypes.OrganizationDataSourceConfigurations? = nil,
        detectorId: Swift.String? = nil,
        features: [GuardDutyClientTypes.OrganizationFeatureConfiguration]? = nil
    )
    {
        self.autoEnable = autoEnable
        self.autoEnableOrganizationMembers = autoEnableOrganizationMembers
        self.dataSources = dataSources
        self.detectorId = detectorId
        self.features = features
    }
}

struct UpdateOrganizationConfigurationInputBody: Swift.Equatable {
    let autoEnable: Swift.Bool?
    let dataSources: GuardDutyClientTypes.OrganizationDataSourceConfigurations?
    let features: [GuardDutyClientTypes.OrganizationFeatureConfiguration]?
    let autoEnableOrganizationMembers: GuardDutyClientTypes.AutoEnableMembers?
}

extension UpdateOrganizationConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoEnable = "autoEnable"
        case autoEnableOrganizationMembers = "autoEnableOrganizationMembers"
        case dataSources = "dataSources"
        case features = "features"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let autoEnableDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .autoEnable)
        autoEnable = autoEnableDecoded
        let dataSourcesDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.OrganizationDataSourceConfigurations.self, forKey: .dataSources)
        dataSources = dataSourcesDecoded
        let featuresContainer = try containerValues.decodeIfPresent([GuardDutyClientTypes.OrganizationFeatureConfiguration?].self, forKey: .features)
        var featuresDecoded0:[GuardDutyClientTypes.OrganizationFeatureConfiguration]? = nil
        if let featuresContainer = featuresContainer {
            featuresDecoded0 = [GuardDutyClientTypes.OrganizationFeatureConfiguration]()
            for structure0 in featuresContainer {
                if let structure0 = structure0 {
                    featuresDecoded0?.append(structure0)
                }
            }
        }
        features = featuresDecoded0
        let autoEnableOrganizationMembersDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.AutoEnableMembers.self, forKey: .autoEnableOrganizationMembers)
        autoEnableOrganizationMembers = autoEnableOrganizationMembersDecoded
    }
}

extension UpdateOrganizationConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateOrganizationConfigurationOutput: Swift.Equatable {

    public init() { }
}

enum UpdateOrganizationConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdatePublishingDestinationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationProperties = "destinationProperties"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destinationProperties = self.destinationProperties {
            try encodeContainer.encode(destinationProperties, forKey: .destinationProperties)
        }
    }
}

extension UpdatePublishingDestinationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let detectorId = detectorId else {
            return nil
        }
        guard let destinationId = destinationId else {
            return nil
        }
        return "/detector/\(detectorId.urlPercentEncoding())/publishingDestination/\(destinationId.urlPercentEncoding())"
    }
}

public struct UpdatePublishingDestinationInput: Swift.Equatable {
    /// The ID of the publishing destination to update.
    /// This member is required.
    public var destinationId: Swift.String?
    /// A DestinationProperties object that includes the DestinationArn and KmsKeyArn of the publishing destination.
    public var destinationProperties: GuardDutyClientTypes.DestinationProperties?
    /// The ID of the detector associated with the publishing destinations to update.
    /// This member is required.
    public var detectorId: Swift.String?

    public init(
        destinationId: Swift.String? = nil,
        destinationProperties: GuardDutyClientTypes.DestinationProperties? = nil,
        detectorId: Swift.String? = nil
    )
    {
        self.destinationId = destinationId
        self.destinationProperties = destinationProperties
        self.detectorId = detectorId
    }
}

struct UpdatePublishingDestinationInputBody: Swift.Equatable {
    let destinationProperties: GuardDutyClientTypes.DestinationProperties?
}

extension UpdatePublishingDestinationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationProperties = "destinationProperties"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let destinationPropertiesDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.DestinationProperties.self, forKey: .destinationProperties)
        destinationProperties = destinationPropertiesDecoded
    }
}

extension UpdatePublishingDestinationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdatePublishingDestinationOutput: Swift.Equatable {

    public init() { }
}

enum UpdatePublishingDestinationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateThreatIntelSetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case activate = "activate"
        case location = "location"
        case name = "name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let activate = self.activate {
            try encodeContainer.encode(activate, forKey: .activate)
        }
        if let location = self.location {
            try encodeContainer.encode(location, forKey: .location)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension UpdateThreatIntelSetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let detectorId = detectorId else {
            return nil
        }
        guard let threatIntelSetId = threatIntelSetId else {
            return nil
        }
        return "/detector/\(detectorId.urlPercentEncoding())/threatintelset/\(threatIntelSetId.urlPercentEncoding())"
    }
}

public struct UpdateThreatIntelSetInput: Swift.Equatable {
    /// The updated Boolean value that specifies whether the ThreateIntelSet is active or not.
    public var activate: Swift.Bool?
    /// The detectorID that specifies the GuardDuty service whose ThreatIntelSet you want to update.
    /// This member is required.
    public var detectorId: Swift.String?
    /// The updated URI of the file that contains the ThreateIntelSet.
    public var location: Swift.String?
    /// The unique ID that specifies the ThreatIntelSet that you want to update.
    public var name: Swift.String?
    /// The unique ID that specifies the ThreatIntelSet that you want to update.
    /// This member is required.
    public var threatIntelSetId: Swift.String?

    public init(
        activate: Swift.Bool? = nil,
        detectorId: Swift.String? = nil,
        location: Swift.String? = nil,
        name: Swift.String? = nil,
        threatIntelSetId: Swift.String? = nil
    )
    {
        self.activate = activate
        self.detectorId = detectorId
        self.location = location
        self.name = name
        self.threatIntelSetId = threatIntelSetId
    }
}

struct UpdateThreatIntelSetInputBody: Swift.Equatable {
    let name: Swift.String?
    let location: Swift.String?
    let activate: Swift.Bool?
}

extension UpdateThreatIntelSetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case activate = "activate"
        case location = "location"
        case name = "name"
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let locationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .location)
        location = locationDecoded
        let activateDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .activate)
        activate = activateDecoded
    }
}

extension UpdateThreatIntelSetOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateThreatIntelSetOutput: Swift.Equatable {

    public init() { }
}

enum UpdateThreatIntelSetOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "BadRequestException": return try await BadRequestException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerErrorException": return try await InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GuardDutyClientTypes.UsageAccountResult: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "accountId"
        case total = "total"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let total = self.total {
            try encodeContainer.encode(total, forKey: .total)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let totalDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.Total.self, forKey: .total)
        total = totalDecoded
    }
}

extension GuardDutyClientTypes {
    /// Contains information on the total of usage based on account IDs.
    public struct UsageAccountResult: Swift.Equatable {
        /// The Account ID that generated usage.
        public var accountId: Swift.String?
        /// Represents the total of usage for the Account ID.
        public var total: GuardDutyClientTypes.Total?

        public init(
            accountId: Swift.String? = nil,
            total: GuardDutyClientTypes.Total? = nil
        )
        {
            self.accountId = accountId
            self.total = total
        }
    }

}

extension GuardDutyClientTypes.UsageCriteria: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountIds = "accountIds"
        case dataSources = "dataSources"
        case features = "features"
        case resources = "resources"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountIds = accountIds {
            var accountIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accountIds)
            for accountid0 in accountIds {
                try accountIdsContainer.encode(accountid0)
            }
        }
        if let dataSources = dataSources {
            var dataSourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dataSources)
            for datasource0 in dataSources {
                try dataSourcesContainer.encode(datasource0.rawValue)
            }
        }
        if let features = features {
            var featuresContainer = encodeContainer.nestedUnkeyedContainer(forKey: .features)
            for usagefeature0 in features {
                try featuresContainer.encode(usagefeature0.rawValue)
            }
        }
        if let resources = resources {
            var resourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resources)
            for string0 in resources {
                try resourcesContainer.encode(string0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .accountIds)
        var accountIdsDecoded0:[Swift.String]? = nil
        if let accountIdsContainer = accountIdsContainer {
            accountIdsDecoded0 = [Swift.String]()
            for string0 in accountIdsContainer {
                if let string0 = string0 {
                    accountIdsDecoded0?.append(string0)
                }
            }
        }
        accountIds = accountIdsDecoded0
        let dataSourcesContainer = try containerValues.decodeIfPresent([GuardDutyClientTypes.DataSource?].self, forKey: .dataSources)
        var dataSourcesDecoded0:[GuardDutyClientTypes.DataSource]? = nil
        if let dataSourcesContainer = dataSourcesContainer {
            dataSourcesDecoded0 = [GuardDutyClientTypes.DataSource]()
            for enum0 in dataSourcesContainer {
                if let enum0 = enum0 {
                    dataSourcesDecoded0?.append(enum0)
                }
            }
        }
        dataSources = dataSourcesDecoded0
        let resourcesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .resources)
        var resourcesDecoded0:[Swift.String]? = nil
        if let resourcesContainer = resourcesContainer {
            resourcesDecoded0 = [Swift.String]()
            for string0 in resourcesContainer {
                if let string0 = string0 {
                    resourcesDecoded0?.append(string0)
                }
            }
        }
        resources = resourcesDecoded0
        let featuresContainer = try containerValues.decodeIfPresent([GuardDutyClientTypes.UsageFeature?].self, forKey: .features)
        var featuresDecoded0:[GuardDutyClientTypes.UsageFeature]? = nil
        if let featuresContainer = featuresContainer {
            featuresDecoded0 = [GuardDutyClientTypes.UsageFeature]()
            for enum0 in featuresContainer {
                if let enum0 = enum0 {
                    featuresDecoded0?.append(enum0)
                }
            }
        }
        features = featuresDecoded0
    }
}

extension GuardDutyClientTypes {
    /// Contains information about the criteria used to query usage statistics.
    public struct UsageCriteria: Swift.Equatable {
        /// The account IDs to aggregate usage statistics from.
        public var accountIds: [Swift.String]?
        /// The data sources to aggregate usage statistics from.
        @available(*, deprecated, message: "This parameter is deprecated, use Features instead")
        public var dataSources: [GuardDutyClientTypes.DataSource]?
        /// The features to aggregate usage statistics from.
        public var features: [GuardDutyClientTypes.UsageFeature]?
        /// The resources to aggregate usage statistics from. Only accepts exact resource names.
        public var resources: [Swift.String]?

        public init(
            accountIds: [Swift.String]? = nil,
            dataSources: [GuardDutyClientTypes.DataSource]? = nil,
            features: [GuardDutyClientTypes.UsageFeature]? = nil,
            resources: [Swift.String]? = nil
        )
        {
            self.accountIds = accountIds
            self.dataSources = dataSources
            self.features = features
            self.resources = resources
        }
    }

}

extension GuardDutyClientTypes.UsageDataSourceResult: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataSource = "dataSource"
        case total = "total"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataSource = self.dataSource {
            try encodeContainer.encode(dataSource.rawValue, forKey: .dataSource)
        }
        if let total = self.total {
            try encodeContainer.encode(total, forKey: .total)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataSourceDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.DataSource.self, forKey: .dataSource)
        dataSource = dataSourceDecoded
        let totalDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.Total.self, forKey: .total)
        total = totalDecoded
    }
}

extension GuardDutyClientTypes {
    /// Contains information on the result of usage based on data source type.
    public struct UsageDataSourceResult: Swift.Equatable {
        /// The data source type that generated usage.
        public var dataSource: GuardDutyClientTypes.DataSource?
        /// Represents the total of usage for the specified data source.
        public var total: GuardDutyClientTypes.Total?

        public init(
            dataSource: GuardDutyClientTypes.DataSource? = nil,
            total: GuardDutyClientTypes.Total? = nil
        )
        {
            self.dataSource = dataSource
            self.total = total
        }
    }

}

extension GuardDutyClientTypes {
    public enum UsageFeature: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cloudTrail
        case dnsLogs
        case ebsMalwareProtection
        case eksAuditLogs
        case eksRuntimeMonitoring
        case flowLogs
        case lambdaNetworkLogs
        case rdsLoginEvents
        case s3DataEvents
        case sdkUnknown(Swift.String)

        public static var allCases: [UsageFeature] {
            return [
                .cloudTrail,
                .dnsLogs,
                .ebsMalwareProtection,
                .eksAuditLogs,
                .eksRuntimeMonitoring,
                .flowLogs,
                .lambdaNetworkLogs,
                .rdsLoginEvents,
                .s3DataEvents,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cloudTrail: return "CLOUD_TRAIL"
            case .dnsLogs: return "DNS_LOGS"
            case .ebsMalwareProtection: return "EBS_MALWARE_PROTECTION"
            case .eksAuditLogs: return "EKS_AUDIT_LOGS"
            case .eksRuntimeMonitoring: return "EKS_RUNTIME_MONITORING"
            case .flowLogs: return "FLOW_LOGS"
            case .lambdaNetworkLogs: return "LAMBDA_NETWORK_LOGS"
            case .rdsLoginEvents: return "RDS_LOGIN_EVENTS"
            case .s3DataEvents: return "S3_DATA_EVENTS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = UsageFeature(rawValue: rawValue) ?? UsageFeature.sdkUnknown(rawValue)
        }
    }
}

extension GuardDutyClientTypes.UsageFeatureResult: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case feature = "feature"
        case total = "total"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let feature = self.feature {
            try encodeContainer.encode(feature.rawValue, forKey: .feature)
        }
        if let total = self.total {
            try encodeContainer.encode(total, forKey: .total)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let featureDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.UsageFeature.self, forKey: .feature)
        feature = featureDecoded
        let totalDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.Total.self, forKey: .total)
        total = totalDecoded
    }
}

extension GuardDutyClientTypes {
    /// Contains information about the result of the total usage based on the feature.
    public struct UsageFeatureResult: Swift.Equatable {
        /// The feature that generated the usage cost.
        public var feature: GuardDutyClientTypes.UsageFeature?
        /// Contains the total usage with the corresponding currency unit for that value.
        public var total: GuardDutyClientTypes.Total?

        public init(
            feature: GuardDutyClientTypes.UsageFeature? = nil,
            total: GuardDutyClientTypes.Total? = nil
        )
        {
            self.feature = feature
            self.total = total
        }
    }

}

extension GuardDutyClientTypes.UsageResourceResult: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resource = "resource"
        case total = "total"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resource = self.resource {
            try encodeContainer.encode(resource, forKey: .resource)
        }
        if let total = self.total {
            try encodeContainer.encode(total, forKey: .total)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resource)
        resource = resourceDecoded
        let totalDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.Total.self, forKey: .total)
        total = totalDecoded
    }
}

extension GuardDutyClientTypes {
    /// Contains information on the sum of usage based on an Amazon Web Services resource.
    public struct UsageResourceResult: Swift.Equatable {
        /// The Amazon Web Services resource that generated usage.
        public var resource: Swift.String?
        /// Represents the sum total of usage for the specified resource type.
        public var total: GuardDutyClientTypes.Total?

        public init(
            resource: Swift.String? = nil,
            total: GuardDutyClientTypes.Total? = nil
        )
        {
            self.resource = resource
            self.total = total
        }
    }

}

extension GuardDutyClientTypes {
    public enum UsageStatisticType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case sumByAccount
        case sumByDataSource
        case sumByFeatures
        case sumByResource
        case topResources
        case sdkUnknown(Swift.String)

        public static var allCases: [UsageStatisticType] {
            return [
                .sumByAccount,
                .sumByDataSource,
                .sumByFeatures,
                .sumByResource,
                .topResources,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .sumByAccount: return "SUM_BY_ACCOUNT"
            case .sumByDataSource: return "SUM_BY_DATA_SOURCE"
            case .sumByFeatures: return "SUM_BY_FEATURES"
            case .sumByResource: return "SUM_BY_RESOURCE"
            case .topResources: return "TOP_RESOURCES"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = UsageStatisticType(rawValue: rawValue) ?? UsageStatisticType.sdkUnknown(rawValue)
        }
    }
}

extension GuardDutyClientTypes.UsageStatistics: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sumByAccount = "sumByAccount"
        case sumByDataSource = "sumByDataSource"
        case sumByFeature = "sumByFeature"
        case sumByResource = "sumByResource"
        case topResources = "topResources"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sumByAccount = sumByAccount {
            var sumByAccountContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sumByAccount)
            for usageaccountresult0 in sumByAccount {
                try sumByAccountContainer.encode(usageaccountresult0)
            }
        }
        if let sumByDataSource = sumByDataSource {
            var sumByDataSourceContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sumByDataSource)
            for usagedatasourceresult0 in sumByDataSource {
                try sumByDataSourceContainer.encode(usagedatasourceresult0)
            }
        }
        if let sumByFeature = sumByFeature {
            var sumByFeatureContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sumByFeature)
            for usagefeatureresult0 in sumByFeature {
                try sumByFeatureContainer.encode(usagefeatureresult0)
            }
        }
        if let sumByResource = sumByResource {
            var sumByResourceContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sumByResource)
            for usageresourceresult0 in sumByResource {
                try sumByResourceContainer.encode(usageresourceresult0)
            }
        }
        if let topResources = topResources {
            var topResourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .topResources)
            for usageresourceresult0 in topResources {
                try topResourcesContainer.encode(usageresourceresult0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sumByAccountContainer = try containerValues.decodeIfPresent([GuardDutyClientTypes.UsageAccountResult?].self, forKey: .sumByAccount)
        var sumByAccountDecoded0:[GuardDutyClientTypes.UsageAccountResult]? = nil
        if let sumByAccountContainer = sumByAccountContainer {
            sumByAccountDecoded0 = [GuardDutyClientTypes.UsageAccountResult]()
            for structure0 in sumByAccountContainer {
                if let structure0 = structure0 {
                    sumByAccountDecoded0?.append(structure0)
                }
            }
        }
        sumByAccount = sumByAccountDecoded0
        let sumByDataSourceContainer = try containerValues.decodeIfPresent([GuardDutyClientTypes.UsageDataSourceResult?].self, forKey: .sumByDataSource)
        var sumByDataSourceDecoded0:[GuardDutyClientTypes.UsageDataSourceResult]? = nil
        if let sumByDataSourceContainer = sumByDataSourceContainer {
            sumByDataSourceDecoded0 = [GuardDutyClientTypes.UsageDataSourceResult]()
            for structure0 in sumByDataSourceContainer {
                if let structure0 = structure0 {
                    sumByDataSourceDecoded0?.append(structure0)
                }
            }
        }
        sumByDataSource = sumByDataSourceDecoded0
        let sumByResourceContainer = try containerValues.decodeIfPresent([GuardDutyClientTypes.UsageResourceResult?].self, forKey: .sumByResource)
        var sumByResourceDecoded0:[GuardDutyClientTypes.UsageResourceResult]? = nil
        if let sumByResourceContainer = sumByResourceContainer {
            sumByResourceDecoded0 = [GuardDutyClientTypes.UsageResourceResult]()
            for structure0 in sumByResourceContainer {
                if let structure0 = structure0 {
                    sumByResourceDecoded0?.append(structure0)
                }
            }
        }
        sumByResource = sumByResourceDecoded0
        let topResourcesContainer = try containerValues.decodeIfPresent([GuardDutyClientTypes.UsageResourceResult?].self, forKey: .topResources)
        var topResourcesDecoded0:[GuardDutyClientTypes.UsageResourceResult]? = nil
        if let topResourcesContainer = topResourcesContainer {
            topResourcesDecoded0 = [GuardDutyClientTypes.UsageResourceResult]()
            for structure0 in topResourcesContainer {
                if let structure0 = structure0 {
                    topResourcesDecoded0?.append(structure0)
                }
            }
        }
        topResources = topResourcesDecoded0
        let sumByFeatureContainer = try containerValues.decodeIfPresent([GuardDutyClientTypes.UsageFeatureResult?].self, forKey: .sumByFeature)
        var sumByFeatureDecoded0:[GuardDutyClientTypes.UsageFeatureResult]? = nil
        if let sumByFeatureContainer = sumByFeatureContainer {
            sumByFeatureDecoded0 = [GuardDutyClientTypes.UsageFeatureResult]()
            for structure0 in sumByFeatureContainer {
                if let structure0 = structure0 {
                    sumByFeatureDecoded0?.append(structure0)
                }
            }
        }
        sumByFeature = sumByFeatureDecoded0
    }
}

extension GuardDutyClientTypes {
    /// Contains the result of GuardDuty usage. If a UsageStatisticType is provided the result for other types will be null.
    public struct UsageStatistics: Swift.Equatable {
        /// The usage statistic sum organized by account ID.
        public var sumByAccount: [GuardDutyClientTypes.UsageAccountResult]?
        /// The usage statistic sum organized by on data source.
        public var sumByDataSource: [GuardDutyClientTypes.UsageDataSourceResult]?
        /// The usage statistic sum organized by feature.
        public var sumByFeature: [GuardDutyClientTypes.UsageFeatureResult]?
        /// The usage statistic sum organized by resource.
        public var sumByResource: [GuardDutyClientTypes.UsageResourceResult]?
        /// Lists the top 50 resources that have generated the most GuardDuty usage, in order from most to least expensive.
        public var topResources: [GuardDutyClientTypes.UsageResourceResult]?

        public init(
            sumByAccount: [GuardDutyClientTypes.UsageAccountResult]? = nil,
            sumByDataSource: [GuardDutyClientTypes.UsageDataSourceResult]? = nil,
            sumByFeature: [GuardDutyClientTypes.UsageFeatureResult]? = nil,
            sumByResource: [GuardDutyClientTypes.UsageResourceResult]? = nil,
            topResources: [GuardDutyClientTypes.UsageResourceResult]? = nil
        )
        {
            self.sumByAccount = sumByAccount
            self.sumByDataSource = sumByDataSource
            self.sumByFeature = sumByFeature
            self.sumByResource = sumByResource
            self.topResources = topResources
        }
    }

}

extension GuardDutyClientTypes.Volume: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hostPath = "hostPath"
        case name = "name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let hostPath = self.hostPath {
            try encodeContainer.encode(hostPath, forKey: .hostPath)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let hostPathDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.HostPath.self, forKey: .hostPath)
        hostPath = hostPathDecoded
    }
}

extension GuardDutyClientTypes {
    /// Volume used by the Kubernetes workload.
    public struct Volume: Swift.Equatable {
        /// Represents a pre-existing file or directory on the host machine that the volume maps to.
        public var hostPath: GuardDutyClientTypes.HostPath?
        /// Volume name.
        public var name: Swift.String?

        public init(
            hostPath: GuardDutyClientTypes.HostPath? = nil,
            name: Swift.String? = nil
        )
        {
            self.hostPath = hostPath
            self.name = name
        }
    }

}

extension GuardDutyClientTypes.VolumeDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceName = "deviceName"
        case encryptionType = "encryptionType"
        case kmsKeyArn = "kmsKeyArn"
        case snapshotArn = "snapshotArn"
        case volumeArn = "volumeArn"
        case volumeSizeInGB = "volumeSizeInGB"
        case volumeType = "volumeType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deviceName = self.deviceName {
            try encodeContainer.encode(deviceName, forKey: .deviceName)
        }
        if let encryptionType = self.encryptionType {
            try encodeContainer.encode(encryptionType, forKey: .encryptionType)
        }
        if let kmsKeyArn = self.kmsKeyArn {
            try encodeContainer.encode(kmsKeyArn, forKey: .kmsKeyArn)
        }
        if let snapshotArn = self.snapshotArn {
            try encodeContainer.encode(snapshotArn, forKey: .snapshotArn)
        }
        if let volumeArn = self.volumeArn {
            try encodeContainer.encode(volumeArn, forKey: .volumeArn)
        }
        if volumeSizeInGB != 0 {
            try encodeContainer.encode(volumeSizeInGB, forKey: .volumeSizeInGB)
        }
        if let volumeType = self.volumeType {
            try encodeContainer.encode(volumeType, forKey: .volumeType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let volumeArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .volumeArn)
        volumeArn = volumeArnDecoded
        let volumeTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .volumeType)
        volumeType = volumeTypeDecoded
        let deviceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceName)
        deviceName = deviceNameDecoded
        let volumeSizeInGBDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .volumeSizeInGB) ?? 0
        volumeSizeInGB = volumeSizeInGBDecoded
        let encryptionTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .encryptionType)
        encryptionType = encryptionTypeDecoded
        let snapshotArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snapshotArn)
        snapshotArn = snapshotArnDecoded
        let kmsKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyArn)
        kmsKeyArn = kmsKeyArnDecoded
    }
}

extension GuardDutyClientTypes {
    /// Contains EBS volume details.
    public struct VolumeDetail: Swift.Equatable {
        /// The device name for the EBS volume.
        public var deviceName: Swift.String?
        /// EBS volume encryption type.
        public var encryptionType: Swift.String?
        /// KMS key Arn used to encrypt the EBS volume.
        public var kmsKeyArn: Swift.String?
        /// Snapshot Arn of the EBS volume.
        public var snapshotArn: Swift.String?
        /// EBS volume Arn information.
        public var volumeArn: Swift.String?
        /// EBS volume size in GB.
        public var volumeSizeInGB: Swift.Int
        /// The EBS volume type.
        public var volumeType: Swift.String?

        public init(
            deviceName: Swift.String? = nil,
            encryptionType: Swift.String? = nil,
            kmsKeyArn: Swift.String? = nil,
            snapshotArn: Swift.String? = nil,
            volumeArn: Swift.String? = nil,
            volumeSizeInGB: Swift.Int = 0,
            volumeType: Swift.String? = nil
        )
        {
            self.deviceName = deviceName
            self.encryptionType = encryptionType
            self.kmsKeyArn = kmsKeyArn
            self.snapshotArn = snapshotArn
            self.volumeArn = volumeArn
            self.volumeSizeInGB = volumeSizeInGB
            self.volumeType = volumeType
        }
    }

}

extension GuardDutyClientTypes.VolumeMount: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case mountPath = "mountPath"
        case name = "name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let mountPath = self.mountPath {
            try encodeContainer.encode(mountPath, forKey: .mountPath)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let mountPathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mountPath)
        mountPath = mountPathDecoded
    }
}

extension GuardDutyClientTypes {
    /// Container volume mount.
    public struct VolumeMount: Swift.Equatable {
        /// Volume mount path.
        public var mountPath: Swift.String?
        /// Volume mount name.
        public var name: Swift.String?

        public init(
            mountPath: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.mountPath = mountPath
            self.name = name
        }
    }

}

extension GuardDutyClientTypes.VpcConfig: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case securityGroups = "securityGroups"
        case subnetIds = "subnetIds"
        case vpcId = "vpcId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let securityGroups = securityGroups {
            var securityGroupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroups)
            for securitygroup0 in securityGroups {
                try securityGroupsContainer.encode(securitygroup0)
            }
        }
        if let subnetIds = subnetIds {
            var subnetIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .subnetIds)
            for string0 in subnetIds {
                try subnetIdsContainer.encode(string0)
            }
        }
        if let vpcId = self.vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let subnetIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .subnetIds)
        var subnetIdsDecoded0:[Swift.String]? = nil
        if let subnetIdsContainer = subnetIdsContainer {
            subnetIdsDecoded0 = [Swift.String]()
            for string0 in subnetIdsContainer {
                if let string0 = string0 {
                    subnetIdsDecoded0?.append(string0)
                }
            }
        }
        subnetIds = subnetIdsDecoded0
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let securityGroupsContainer = try containerValues.decodeIfPresent([GuardDutyClientTypes.SecurityGroup?].self, forKey: .securityGroups)
        var securityGroupsDecoded0:[GuardDutyClientTypes.SecurityGroup]? = nil
        if let securityGroupsContainer = securityGroupsContainer {
            securityGroupsDecoded0 = [GuardDutyClientTypes.SecurityGroup]()
            for structure0 in securityGroupsContainer {
                if let structure0 = structure0 {
                    securityGroupsDecoded0?.append(structure0)
                }
            }
        }
        securityGroups = securityGroupsDecoded0
    }
}

extension GuardDutyClientTypes {
    /// Amazon Virtual Private Cloud configuration details associated with your Lambda function.
    public struct VpcConfig: Swift.Equatable {
        /// The identifier of the security group attached to the Lambda function.
        public var securityGroups: [GuardDutyClientTypes.SecurityGroup]?
        /// The identifiers of the subnets that are associated with your Lambda function.
        public var subnetIds: [Swift.String]?
        /// The identifier of the Amazon Virtual Private Cloud.
        public var vpcId: Swift.String?

        public init(
            securityGroups: [GuardDutyClientTypes.SecurityGroup]? = nil,
            subnetIds: [Swift.String]? = nil,
            vpcId: Swift.String? = nil
        )
        {
            self.securityGroups = securityGroups
            self.subnetIds = subnetIds
            self.vpcId = vpcId
        }
    }

}
