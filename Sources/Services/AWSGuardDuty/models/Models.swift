// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AcceptAdministratorInvitationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case administratorId = "administratorId"
        case invitationId = "invitationId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let administratorId = self.administratorId {
            try encodeContainer.encode(administratorId, forKey: .administratorId)
        }
        if let invitationId = self.invitationId {
            try encodeContainer.encode(invitationId, forKey: .invitationId)
        }
    }
}

extension AcceptAdministratorInvitationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let detectorId = detectorId else {
            return nil
        }
        return "/detector/\(detectorId.urlPercentEncoding())/administrator"
    }
}

public struct AcceptAdministratorInvitationInput: Swift.Equatable {
    /// The account ID of the GuardDuty administrator account whose invitation you're accepting.
    /// This member is required.
    public var administratorId: Swift.String?
    /// The unique ID of the detector of the GuardDuty member account.
    /// This member is required.
    public var detectorId: Swift.String?
    /// The value that is used to validate the administrator account to the member account.
    /// This member is required.
    public var invitationId: Swift.String?

    public init (
        administratorId: Swift.String? = nil,
        detectorId: Swift.String? = nil,
        invitationId: Swift.String? = nil
    )
    {
        self.administratorId = administratorId
        self.detectorId = detectorId
        self.invitationId = invitationId
    }
}

struct AcceptAdministratorInvitationInputBody: Swift.Equatable {
    let administratorId: Swift.String?
    let invitationId: Swift.String?
}

extension AcceptAdministratorInvitationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case administratorId = "administratorId"
        case invitationId = "invitationId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let administratorIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .administratorId)
        administratorId = administratorIdDecoded
        let invitationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .invitationId)
        invitationId = invitationIdDecoded
    }
}

extension AcceptAdministratorInvitationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AcceptAdministratorInvitationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum AcceptAdministratorInvitationOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AcceptAdministratorInvitationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct AcceptAdministratorInvitationOutputResponse: Swift.Equatable {

    public init () { }
}

extension AcceptInvitationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case invitationId = "invitationId"
        case masterId = "masterId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let invitationId = self.invitationId {
            try encodeContainer.encode(invitationId, forKey: .invitationId)
        }
        if let masterId = self.masterId {
            try encodeContainer.encode(masterId, forKey: .masterId)
        }
    }
}

extension AcceptInvitationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let detectorId = detectorId else {
            return nil
        }
        return "/detector/\(detectorId.urlPercentEncoding())/master"
    }
}

@available(*, deprecated, message: "This input is deprecated, use AcceptAdministratorInvitationRequest instead")
public struct AcceptInvitationInput: Swift.Equatable {
    /// The unique ID of the detector of the GuardDuty member account.
    /// This member is required.
    public var detectorId: Swift.String?
    /// The value that is used to validate the administrator account to the member account.
    /// This member is required.
    public var invitationId: Swift.String?
    /// The account ID of the GuardDuty administrator account whose invitation you're accepting.
    /// This member is required.
    public var masterId: Swift.String?

    public init (
        detectorId: Swift.String? = nil,
        invitationId: Swift.String? = nil,
        masterId: Swift.String? = nil
    )
    {
        self.detectorId = detectorId
        self.invitationId = invitationId
        self.masterId = masterId
    }
}

struct AcceptInvitationInputBody: Swift.Equatable {
    let masterId: Swift.String?
    let invitationId: Swift.String?
}

extension AcceptInvitationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case invitationId = "invitationId"
        case masterId = "masterId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let masterIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .masterId)
        masterId = masterIdDecoded
        let invitationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .invitationId)
        invitationId = invitationIdDecoded
    }
}

extension AcceptInvitationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension AcceptInvitationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum AcceptInvitationOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension AcceptInvitationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

@available(*, deprecated, message: "This output is deprecated, use AcceptAdministratorInvitationResponse instead")
public struct AcceptInvitationOutputResponse: Swift.Equatable {

    public init () { }
}

extension GuardDutyClientTypes.AccessControlList: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowsPublicReadAccess = "allowsPublicReadAccess"
        case allowsPublicWriteAccess = "allowsPublicWriteAccess"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if allowsPublicReadAccess != false {
            try encodeContainer.encode(allowsPublicReadAccess, forKey: .allowsPublicReadAccess)
        }
        if allowsPublicWriteAccess != false {
            try encodeContainer.encode(allowsPublicWriteAccess, forKey: .allowsPublicWriteAccess)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let allowsPublicReadAccessDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .allowsPublicReadAccess) ?? false
        allowsPublicReadAccess = allowsPublicReadAccessDecoded
        let allowsPublicWriteAccessDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .allowsPublicWriteAccess) ?? false
        allowsPublicWriteAccess = allowsPublicWriteAccessDecoded
    }
}

extension GuardDutyClientTypes {
    /// Contains information on the current access control policies for the bucket.
    public struct AccessControlList: Swift.Equatable {
        /// A value that indicates whether public read access for the bucket is enabled through an Access Control List (ACL).
        public var allowsPublicReadAccess: Swift.Bool
        /// A value that indicates whether public write access for the bucket is enabled through an Access Control List (ACL).
        public var allowsPublicWriteAccess: Swift.Bool

        public init (
            allowsPublicReadAccess: Swift.Bool = false,
            allowsPublicWriteAccess: Swift.Bool = false
        )
        {
            self.allowsPublicReadAccess = allowsPublicReadAccess
            self.allowsPublicWriteAccess = allowsPublicWriteAccess
        }
    }

}

extension GuardDutyClientTypes.AccessKeyDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessKeyId = "accessKeyId"
        case principalId = "principalId"
        case userName = "userName"
        case userType = "userType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessKeyId = self.accessKeyId {
            try encodeContainer.encode(accessKeyId, forKey: .accessKeyId)
        }
        if let principalId = self.principalId {
            try encodeContainer.encode(principalId, forKey: .principalId)
        }
        if let userName = self.userName {
            try encodeContainer.encode(userName, forKey: .userName)
        }
        if let userType = self.userType {
            try encodeContainer.encode(userType, forKey: .userType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessKeyIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accessKeyId)
        accessKeyId = accessKeyIdDecoded
        let principalIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .principalId)
        principalId = principalIdDecoded
        let userNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userName)
        userName = userNameDecoded
        let userTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userType)
        userType = userTypeDecoded
    }
}

extension GuardDutyClientTypes {
    /// Contains information about the access keys.
    public struct AccessKeyDetails: Swift.Equatable {
        /// The access key ID of the user.
        public var accessKeyId: Swift.String?
        /// The principal ID of the user.
        public var principalId: Swift.String?
        /// The name of the user.
        public var userName: Swift.String?
        /// The type of the user.
        public var userType: Swift.String?

        public init (
            accessKeyId: Swift.String? = nil,
            principalId: Swift.String? = nil,
            userName: Swift.String? = nil,
            userType: Swift.String? = nil
        )
        {
            self.accessKeyId = accessKeyId
            self.principalId = principalId
            self.userName = userName
            self.userType = userType
        }
    }

}

extension GuardDutyClientTypes.AccountDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "accountId"
        case email = "email"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let email = self.email {
            try encodeContainer.encode(email, forKey: .email)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let emailDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .email)
        email = emailDecoded
    }
}

extension GuardDutyClientTypes {
    /// Contains information about the account.
    public struct AccountDetail: Swift.Equatable {
        /// The member account ID.
        /// This member is required.
        public var accountId: Swift.String?
        /// The email address of the member account.
        /// This member is required.
        public var email: Swift.String?

        public init (
            accountId: Swift.String? = nil,
            email: Swift.String? = nil
        )
        {
            self.accountId = accountId
            self.email = email
        }
    }

}

extension GuardDutyClientTypes.AccountFreeTrialInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "accountId"
        case dataSources = "dataSources"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let dataSources = self.dataSources {
            try encodeContainer.encode(dataSources, forKey: .dataSources)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let dataSourcesDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.DataSourcesFreeTrial.self, forKey: .dataSources)
        dataSources = dataSourcesDecoded
    }
}

extension GuardDutyClientTypes {
    /// Provides details of the GuardDuty member account that uses a free trial service.
    public struct AccountFreeTrialInfo: Swift.Equatable {
        /// The account identifier of the GuardDuty member account.
        public var accountId: Swift.String?
        /// Describes the data source enabled for the GuardDuty member account.
        public var dataSources: GuardDutyClientTypes.DataSourcesFreeTrial?

        public init (
            accountId: Swift.String? = nil,
            dataSources: GuardDutyClientTypes.DataSourcesFreeTrial? = nil
        )
        {
            self.accountId = accountId
            self.dataSources = dataSources
        }
    }

}

extension GuardDutyClientTypes.AccountLevelPermissions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case blockPublicAccess = "blockPublicAccess"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let blockPublicAccess = self.blockPublicAccess {
            try encodeContainer.encode(blockPublicAccess, forKey: .blockPublicAccess)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let blockPublicAccessDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.BlockPublicAccess.self, forKey: .blockPublicAccess)
        blockPublicAccess = blockPublicAccessDecoded
    }
}

extension GuardDutyClientTypes {
    /// Contains information about the account level permissions on the S3 bucket.
    public struct AccountLevelPermissions: Swift.Equatable {
        /// Describes the S3 Block Public Access settings of the bucket's parent account.
        public var blockPublicAccess: GuardDutyClientTypes.BlockPublicAccess?

        public init (
            blockPublicAccess: GuardDutyClientTypes.BlockPublicAccess? = nil
        )
        {
            self.blockPublicAccess = blockPublicAccess
        }
    }

}

extension GuardDutyClientTypes.Action: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case actionType = "actionType"
        case awsApiCallAction = "awsApiCallAction"
        case dnsRequestAction = "dnsRequestAction"
        case kubernetesApiCallAction = "kubernetesApiCallAction"
        case networkConnectionAction = "networkConnectionAction"
        case portProbeAction = "portProbeAction"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let actionType = self.actionType {
            try encodeContainer.encode(actionType, forKey: .actionType)
        }
        if let awsApiCallAction = self.awsApiCallAction {
            try encodeContainer.encode(awsApiCallAction, forKey: .awsApiCallAction)
        }
        if let dnsRequestAction = self.dnsRequestAction {
            try encodeContainer.encode(dnsRequestAction, forKey: .dnsRequestAction)
        }
        if let kubernetesApiCallAction = self.kubernetesApiCallAction {
            try encodeContainer.encode(kubernetesApiCallAction, forKey: .kubernetesApiCallAction)
        }
        if let networkConnectionAction = self.networkConnectionAction {
            try encodeContainer.encode(networkConnectionAction, forKey: .networkConnectionAction)
        }
        if let portProbeAction = self.portProbeAction {
            try encodeContainer.encode(portProbeAction, forKey: .portProbeAction)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .actionType)
        actionType = actionTypeDecoded
        let awsApiCallActionDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.AwsApiCallAction.self, forKey: .awsApiCallAction)
        awsApiCallAction = awsApiCallActionDecoded
        let dnsRequestActionDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.DnsRequestAction.self, forKey: .dnsRequestAction)
        dnsRequestAction = dnsRequestActionDecoded
        let networkConnectionActionDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.NetworkConnectionAction.self, forKey: .networkConnectionAction)
        networkConnectionAction = networkConnectionActionDecoded
        let portProbeActionDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.PortProbeAction.self, forKey: .portProbeAction)
        portProbeAction = portProbeActionDecoded
        let kubernetesApiCallActionDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.KubernetesApiCallAction.self, forKey: .kubernetesApiCallAction)
        kubernetesApiCallAction = kubernetesApiCallActionDecoded
    }
}

extension GuardDutyClientTypes {
    /// Contains information about actions.
    public struct Action: Swift.Equatable {
        /// The GuardDuty finding activity type.
        public var actionType: Swift.String?
        /// Information about the AWS_API_CALL action described in this finding.
        public var awsApiCallAction: GuardDutyClientTypes.AwsApiCallAction?
        /// Information about the DNS_REQUEST action described in this finding.
        public var dnsRequestAction: GuardDutyClientTypes.DnsRequestAction?
        /// Information about the Kubernetes API call action described in this finding.
        public var kubernetesApiCallAction: GuardDutyClientTypes.KubernetesApiCallAction?
        /// Information about the NETWORK_CONNECTION action described in this finding.
        public var networkConnectionAction: GuardDutyClientTypes.NetworkConnectionAction?
        /// Information about the PORT_PROBE action described in this finding.
        public var portProbeAction: GuardDutyClientTypes.PortProbeAction?

        public init (
            actionType: Swift.String? = nil,
            awsApiCallAction: GuardDutyClientTypes.AwsApiCallAction? = nil,
            dnsRequestAction: GuardDutyClientTypes.DnsRequestAction? = nil,
            kubernetesApiCallAction: GuardDutyClientTypes.KubernetesApiCallAction? = nil,
            networkConnectionAction: GuardDutyClientTypes.NetworkConnectionAction? = nil,
            portProbeAction: GuardDutyClientTypes.PortProbeAction? = nil
        )
        {
            self.actionType = actionType
            self.awsApiCallAction = awsApiCallAction
            self.dnsRequestAction = dnsRequestAction
            self.kubernetesApiCallAction = kubernetesApiCallAction
            self.networkConnectionAction = networkConnectionAction
            self.portProbeAction = portProbeAction
        }
    }

}

extension GuardDutyClientTypes.AdminAccount: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case adminAccountId = "adminAccountId"
        case adminStatus = "adminStatus"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let adminAccountId = self.adminAccountId {
            try encodeContainer.encode(adminAccountId, forKey: .adminAccountId)
        }
        if let adminStatus = self.adminStatus {
            try encodeContainer.encode(adminStatus.rawValue, forKey: .adminStatus)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let adminAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .adminAccountId)
        adminAccountId = adminAccountIdDecoded
        let adminStatusDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.AdminStatus.self, forKey: .adminStatus)
        adminStatus = adminStatusDecoded
    }
}

extension GuardDutyClientTypes {
    /// The account within the organization specified as the GuardDuty delegated administrator.
    public struct AdminAccount: Swift.Equatable {
        /// The Amazon Web Services account ID for the account.
        public var adminAccountId: Swift.String?
        /// Indicates whether the account is enabled as the delegated administrator.
        public var adminStatus: GuardDutyClientTypes.AdminStatus?

        public init (
            adminAccountId: Swift.String? = nil,
            adminStatus: GuardDutyClientTypes.AdminStatus? = nil
        )
        {
            self.adminAccountId = adminAccountId
            self.adminStatus = adminStatus
        }
    }

}

extension GuardDutyClientTypes {
    public enum AdminStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disableInProgress
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [AdminStatus] {
            return [
                .disableInProgress,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disableInProgress: return "DISABLE_IN_PROGRESS"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = AdminStatus(rawValue: rawValue) ?? AdminStatus.sdkUnknown(rawValue)
        }
    }
}

extension GuardDutyClientTypes.Administrator: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "accountId"
        case invitationId = "invitationId"
        case invitedAt = "invitedAt"
        case relationshipStatus = "relationshipStatus"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let invitationId = self.invitationId {
            try encodeContainer.encode(invitationId, forKey: .invitationId)
        }
        if let invitedAt = self.invitedAt {
            try encodeContainer.encode(invitedAt, forKey: .invitedAt)
        }
        if let relationshipStatus = self.relationshipStatus {
            try encodeContainer.encode(relationshipStatus, forKey: .relationshipStatus)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let invitationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .invitationId)
        invitationId = invitationIdDecoded
        let relationshipStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .relationshipStatus)
        relationshipStatus = relationshipStatusDecoded
        let invitedAtDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .invitedAt)
        invitedAt = invitedAtDecoded
    }
}

extension GuardDutyClientTypes {
    /// Contains information about the administrator account and invitation.
    public struct Administrator: Swift.Equatable {
        /// The ID of the account used as the administrator account.
        public var accountId: Swift.String?
        /// The value that is used to validate the administrator account to the member account.
        public var invitationId: Swift.String?
        /// The timestamp when the invitation was sent.
        public var invitedAt: Swift.String?
        /// The status of the relationship between the administrator and member accounts.
        public var relationshipStatus: Swift.String?

        public init (
            accountId: Swift.String? = nil,
            invitationId: Swift.String? = nil,
            invitedAt: Swift.String? = nil,
            relationshipStatus: Swift.String? = nil
        )
        {
            self.accountId = accountId
            self.invitationId = invitationId
            self.invitedAt = invitedAt
            self.relationshipStatus = relationshipStatus
        }
    }

}

extension ArchiveFindingsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case findingIds = "findingIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let findingIds = findingIds {
            var findingIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .findingIds)
            for findingid0 in findingIds {
                try findingIdsContainer.encode(findingid0)
            }
        }
    }
}

extension ArchiveFindingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let detectorId = detectorId else {
            return nil
        }
        return "/detector/\(detectorId.urlPercentEncoding())/findings/archive"
    }
}

public struct ArchiveFindingsInput: Swift.Equatable {
    /// The ID of the detector that specifies the GuardDuty service whose findings you want to archive.
    /// This member is required.
    public var detectorId: Swift.String?
    /// The IDs of the findings that you want to archive.
    /// This member is required.
    public var findingIds: [Swift.String]?

    public init (
        detectorId: Swift.String? = nil,
        findingIds: [Swift.String]? = nil
    )
    {
        self.detectorId = detectorId
        self.findingIds = findingIds
    }
}

struct ArchiveFindingsInputBody: Swift.Equatable {
    let findingIds: [Swift.String]?
}

extension ArchiveFindingsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case findingIds = "findingIds"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let findingIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .findingIds)
        var findingIdsDecoded0:[Swift.String]? = nil
        if let findingIdsContainer = findingIdsContainer {
            findingIdsDecoded0 = [Swift.String]()
            for string0 in findingIdsContainer {
                if let string0 = string0 {
                    findingIdsDecoded0?.append(string0)
                }
            }
        }
        findingIds = findingIdsDecoded0
    }
}

extension ArchiveFindingsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ArchiveFindingsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ArchiveFindingsOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ArchiveFindingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct ArchiveFindingsOutputResponse: Swift.Equatable {

    public init () { }
}

extension GuardDutyClientTypes.AwsApiCallAction: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case affectedResources = "affectedResources"
        case api = "api"
        case callerType = "callerType"
        case domainDetails = "domainDetails"
        case errorCode = "errorCode"
        case remoteAccountDetails = "remoteAccountDetails"
        case remoteIpDetails = "remoteIpDetails"
        case serviceName = "serviceName"
        case userAgent = "userAgent"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let affectedResources = affectedResources {
            var affectedResourcesContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .affectedResources)
            for (dictKey0, affectedResources0) in affectedResources {
                try affectedResourcesContainer.encode(affectedResources0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let api = self.api {
            try encodeContainer.encode(api, forKey: .api)
        }
        if let callerType = self.callerType {
            try encodeContainer.encode(callerType, forKey: .callerType)
        }
        if let domainDetails = self.domainDetails {
            try encodeContainer.encode(domainDetails, forKey: .domainDetails)
        }
        if let errorCode = self.errorCode {
            try encodeContainer.encode(errorCode, forKey: .errorCode)
        }
        if let remoteAccountDetails = self.remoteAccountDetails {
            try encodeContainer.encode(remoteAccountDetails, forKey: .remoteAccountDetails)
        }
        if let remoteIpDetails = self.remoteIpDetails {
            try encodeContainer.encode(remoteIpDetails, forKey: .remoteIpDetails)
        }
        if let serviceName = self.serviceName {
            try encodeContainer.encode(serviceName, forKey: .serviceName)
        }
        if let userAgent = self.userAgent {
            try encodeContainer.encode(userAgent, forKey: .userAgent)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let apiDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .api)
        api = apiDecoded
        let callerTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .callerType)
        callerType = callerTypeDecoded
        let domainDetailsDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.DomainDetails.self, forKey: .domainDetails)
        domainDetails = domainDetailsDecoded
        let errorCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .errorCode)
        errorCode = errorCodeDecoded
        let userAgentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userAgent)
        userAgent = userAgentDecoded
        let remoteIpDetailsDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.RemoteIpDetails.self, forKey: .remoteIpDetails)
        remoteIpDetails = remoteIpDetailsDecoded
        let serviceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceName)
        serviceName = serviceNameDecoded
        let remoteAccountDetailsDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.RemoteAccountDetails.self, forKey: .remoteAccountDetails)
        remoteAccountDetails = remoteAccountDetailsDecoded
        let affectedResourcesContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .affectedResources)
        var affectedResourcesDecoded0: [Swift.String:Swift.String]? = nil
        if let affectedResourcesContainer = affectedResourcesContainer {
            affectedResourcesDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in affectedResourcesContainer {
                if let string0 = string0 {
                    affectedResourcesDecoded0?[key0] = string0
                }
            }
        }
        affectedResources = affectedResourcesDecoded0
    }
}

extension GuardDutyClientTypes {
    /// Contains information about the API action.
    public struct AwsApiCallAction: Swift.Equatable {
        /// The details of the Amazon Web Services account that made the API call. This field identifies the resources that were affected by this API call.
        public var affectedResources: [Swift.String:Swift.String]?
        /// The Amazon Web Services API name.
        public var api: Swift.String?
        /// The Amazon Web Services API caller type.
        public var callerType: Swift.String?
        /// The domain information for the Amazon Web Services API call.
        public var domainDetails: GuardDutyClientTypes.DomainDetails?
        /// The error code of the failed Amazon Web Services API action.
        public var errorCode: Swift.String?
        /// The details of the Amazon Web Services account that made the API call. This field appears if the call was made from outside your account.
        public var remoteAccountDetails: GuardDutyClientTypes.RemoteAccountDetails?
        /// The remote IP information of the connection that initiated the Amazon Web Services API call.
        public var remoteIpDetails: GuardDutyClientTypes.RemoteIpDetails?
        /// The Amazon Web Services service name whose API was invoked.
        public var serviceName: Swift.String?
        /// The agent through which the API request was made.
        public var userAgent: Swift.String?

        public init (
            affectedResources: [Swift.String:Swift.String]? = nil,
            api: Swift.String? = nil,
            callerType: Swift.String? = nil,
            domainDetails: GuardDutyClientTypes.DomainDetails? = nil,
            errorCode: Swift.String? = nil,
            remoteAccountDetails: GuardDutyClientTypes.RemoteAccountDetails? = nil,
            remoteIpDetails: GuardDutyClientTypes.RemoteIpDetails? = nil,
            serviceName: Swift.String? = nil,
            userAgent: Swift.String? = nil
        )
        {
            self.affectedResources = affectedResources
            self.api = api
            self.callerType = callerType
            self.domainDetails = domainDetails
            self.errorCode = errorCode
            self.remoteAccountDetails = remoteAccountDetails
            self.remoteIpDetails = remoteIpDetails
            self.serviceName = serviceName
            self.userAgent = userAgent
        }
    }

}

extension BadRequestException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: BadRequestExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.type = output.type
        } else {
            self.message = nil
            self.type = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// A bad request exception object.
public struct BadRequestException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .client
    /// The error message.
    public var message: Swift.String?
    /// The error type.
    public var type: Swift.String?

    public init (
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.message = message
        self.type = type
    }
}

struct BadRequestExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let type: Swift.String?
}

extension BadRequestExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "message"
        case type = "__type"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
    }
}

extension GuardDutyClientTypes.BlockPublicAccess: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case blockPublicAcls = "blockPublicAcls"
        case blockPublicPolicy = "blockPublicPolicy"
        case ignorePublicAcls = "ignorePublicAcls"
        case restrictPublicBuckets = "restrictPublicBuckets"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if blockPublicAcls != false {
            try encodeContainer.encode(blockPublicAcls, forKey: .blockPublicAcls)
        }
        if blockPublicPolicy != false {
            try encodeContainer.encode(blockPublicPolicy, forKey: .blockPublicPolicy)
        }
        if ignorePublicAcls != false {
            try encodeContainer.encode(ignorePublicAcls, forKey: .ignorePublicAcls)
        }
        if restrictPublicBuckets != false {
            try encodeContainer.encode(restrictPublicBuckets, forKey: .restrictPublicBuckets)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ignorePublicAclsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .ignorePublicAcls) ?? false
        ignorePublicAcls = ignorePublicAclsDecoded
        let restrictPublicBucketsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .restrictPublicBuckets) ?? false
        restrictPublicBuckets = restrictPublicBucketsDecoded
        let blockPublicAclsDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .blockPublicAcls) ?? false
        blockPublicAcls = blockPublicAclsDecoded
        let blockPublicPolicyDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .blockPublicPolicy) ?? false
        blockPublicPolicy = blockPublicPolicyDecoded
    }
}

extension GuardDutyClientTypes {
    /// Contains information on how the bucker owner's S3 Block Public Access settings are being applied to the S3 bucket. See [S3 Block Public Access](https://docs.aws.amazon.com/AmazonS3/latest/dev/access-control-block-public-access.html) for more information.
    public struct BlockPublicAccess: Swift.Equatable {
        /// Indicates if S3 Block Public Access is set to BlockPublicAcls.
        public var blockPublicAcls: Swift.Bool
        /// Indicates if S3 Block Public Access is set to BlockPublicPolicy.
        public var blockPublicPolicy: Swift.Bool
        /// Indicates if S3 Block Public Access is set to IgnorePublicAcls.
        public var ignorePublicAcls: Swift.Bool
        /// Indicates if S3 Block Public Access is set to RestrictPublicBuckets.
        public var restrictPublicBuckets: Swift.Bool

        public init (
            blockPublicAcls: Swift.Bool = false,
            blockPublicPolicy: Swift.Bool = false,
            ignorePublicAcls: Swift.Bool = false,
            restrictPublicBuckets: Swift.Bool = false
        )
        {
            self.blockPublicAcls = blockPublicAcls
            self.blockPublicPolicy = blockPublicPolicy
            self.ignorePublicAcls = ignorePublicAcls
            self.restrictPublicBuckets = restrictPublicBuckets
        }
    }

}

extension GuardDutyClientTypes.BucketLevelPermissions: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessControlList = "accessControlList"
        case blockPublicAccess = "blockPublicAccess"
        case bucketPolicy = "bucketPolicy"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessControlList = self.accessControlList {
            try encodeContainer.encode(accessControlList, forKey: .accessControlList)
        }
        if let blockPublicAccess = self.blockPublicAccess {
            try encodeContainer.encode(blockPublicAccess, forKey: .blockPublicAccess)
        }
        if let bucketPolicy = self.bucketPolicy {
            try encodeContainer.encode(bucketPolicy, forKey: .bucketPolicy)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessControlListDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.AccessControlList.self, forKey: .accessControlList)
        accessControlList = accessControlListDecoded
        let bucketPolicyDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.BucketPolicy.self, forKey: .bucketPolicy)
        bucketPolicy = bucketPolicyDecoded
        let blockPublicAccessDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.BlockPublicAccess.self, forKey: .blockPublicAccess)
        blockPublicAccess = blockPublicAccessDecoded
    }
}

extension GuardDutyClientTypes {
    /// Contains information about the bucket level permissions for the S3 bucket.
    public struct BucketLevelPermissions: Swift.Equatable {
        /// Contains information on how Access Control Policies are applied to the bucket.
        public var accessControlList: GuardDutyClientTypes.AccessControlList?
        /// Contains information on which account level S3 Block Public Access settings are applied to the S3 bucket.
        public var blockPublicAccess: GuardDutyClientTypes.BlockPublicAccess?
        /// Contains information on the bucket policies for the S3 bucket.
        public var bucketPolicy: GuardDutyClientTypes.BucketPolicy?

        public init (
            accessControlList: GuardDutyClientTypes.AccessControlList? = nil,
            blockPublicAccess: GuardDutyClientTypes.BlockPublicAccess? = nil,
            bucketPolicy: GuardDutyClientTypes.BucketPolicy? = nil
        )
        {
            self.accessControlList = accessControlList
            self.blockPublicAccess = blockPublicAccess
            self.bucketPolicy = bucketPolicy
        }
    }

}

extension GuardDutyClientTypes.BucketPolicy: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case allowsPublicReadAccess = "allowsPublicReadAccess"
        case allowsPublicWriteAccess = "allowsPublicWriteAccess"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if allowsPublicReadAccess != false {
            try encodeContainer.encode(allowsPublicReadAccess, forKey: .allowsPublicReadAccess)
        }
        if allowsPublicWriteAccess != false {
            try encodeContainer.encode(allowsPublicWriteAccess, forKey: .allowsPublicWriteAccess)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let allowsPublicReadAccessDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .allowsPublicReadAccess) ?? false
        allowsPublicReadAccess = allowsPublicReadAccessDecoded
        let allowsPublicWriteAccessDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .allowsPublicWriteAccess) ?? false
        allowsPublicWriteAccess = allowsPublicWriteAccessDecoded
    }
}

extension GuardDutyClientTypes {
    /// Contains information on the current bucket policies for the S3 bucket.
    public struct BucketPolicy: Swift.Equatable {
        /// A value that indicates whether public read access for the bucket is enabled through a bucket policy.
        public var allowsPublicReadAccess: Swift.Bool
        /// A value that indicates whether public write access for the bucket is enabled through a bucket policy.
        public var allowsPublicWriteAccess: Swift.Bool

        public init (
            allowsPublicReadAccess: Swift.Bool = false,
            allowsPublicWriteAccess: Swift.Bool = false
        )
        {
            self.allowsPublicReadAccess = allowsPublicReadAccess
            self.allowsPublicWriteAccess = allowsPublicWriteAccess
        }
    }

}

extension GuardDutyClientTypes.City: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cityName = "cityName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cityName = self.cityName {
            try encodeContainer.encode(cityName, forKey: .cityName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cityNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .cityName)
        cityName = cityNameDecoded
    }
}

extension GuardDutyClientTypes {
    /// Contains information about the city associated with the IP address.
    public struct City: Swift.Equatable {
        /// The city name of the remote IP address.
        public var cityName: Swift.String?

        public init (
            cityName: Swift.String? = nil
        )
        {
            self.cityName = cityName
        }
    }

}

extension GuardDutyClientTypes.CloudTrailConfigurationResult: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status = "status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.DataSourceStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension GuardDutyClientTypes {
    /// Contains information on the status of CloudTrail as a data source for the detector.
    public struct CloudTrailConfigurationResult: Swift.Equatable {
        /// Describes whether CloudTrail is enabled as a data source for the detector.
        /// This member is required.
        public var status: GuardDutyClientTypes.DataSourceStatus?

        public init (
            status: GuardDutyClientTypes.DataSourceStatus? = nil
        )
        {
            self.status = status
        }
    }

}

extension GuardDutyClientTypes.Condition: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case eq = "eq"
        case equals = "equals"
        case greaterThan = "greaterThan"
        case greaterThanOrEqual = "greaterThanOrEqual"
        case gt = "gt"
        case gte = "gte"
        case lessThan = "lessThan"
        case lessThanOrEqual = "lessThanOrEqual"
        case lt = "lt"
        case lte = "lte"
        case neq = "neq"
        case notEquals = "notEquals"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let eq = eq {
            var eqContainer = encodeContainer.nestedUnkeyedContainer(forKey: .eq)
            for string0 in eq {
                try eqContainer.encode(string0)
            }
        }
        if let equals = equals {
            var equalsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .equals)
            for string0 in equals {
                try equalsContainer.encode(string0)
            }
        }
        if greaterThan != 0 {
            try encodeContainer.encode(greaterThan, forKey: .greaterThan)
        }
        if greaterThanOrEqual != 0 {
            try encodeContainer.encode(greaterThanOrEqual, forKey: .greaterThanOrEqual)
        }
        if gt != 0 {
            try encodeContainer.encode(gt, forKey: .gt)
        }
        if gte != 0 {
            try encodeContainer.encode(gte, forKey: .gte)
        }
        if lessThan != 0 {
            try encodeContainer.encode(lessThan, forKey: .lessThan)
        }
        if lessThanOrEqual != 0 {
            try encodeContainer.encode(lessThanOrEqual, forKey: .lessThanOrEqual)
        }
        if lt != 0 {
            try encodeContainer.encode(lt, forKey: .lt)
        }
        if lte != 0 {
            try encodeContainer.encode(lte, forKey: .lte)
        }
        if let neq = neq {
            var neqContainer = encodeContainer.nestedUnkeyedContainer(forKey: .neq)
            for string0 in neq {
                try neqContainer.encode(string0)
            }
        }
        if let notEquals = notEquals {
            var notEqualsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .notEquals)
            for string0 in notEquals {
                try notEqualsContainer.encode(string0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let eqContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .eq)
        var eqDecoded0:[Swift.String]? = nil
        if let eqContainer = eqContainer {
            eqDecoded0 = [Swift.String]()
            for string0 in eqContainer {
                if let string0 = string0 {
                    eqDecoded0?.append(string0)
                }
            }
        }
        eq = eqDecoded0
        let neqContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .neq)
        var neqDecoded0:[Swift.String]? = nil
        if let neqContainer = neqContainer {
            neqDecoded0 = [Swift.String]()
            for string0 in neqContainer {
                if let string0 = string0 {
                    neqDecoded0?.append(string0)
                }
            }
        }
        neq = neqDecoded0
        let gtDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .gt) ?? 0
        gt = gtDecoded
        let gteDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .gte) ?? 0
        gte = gteDecoded
        let ltDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .lt) ?? 0
        lt = ltDecoded
        let lteDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .lte) ?? 0
        lte = lteDecoded
        let equalsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .equals)
        var equalsDecoded0:[Swift.String]? = nil
        if let equalsContainer = equalsContainer {
            equalsDecoded0 = [Swift.String]()
            for string0 in equalsContainer {
                if let string0 = string0 {
                    equalsDecoded0?.append(string0)
                }
            }
        }
        equals = equalsDecoded0
        let notEqualsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .notEquals)
        var notEqualsDecoded0:[Swift.String]? = nil
        if let notEqualsContainer = notEqualsContainer {
            notEqualsDecoded0 = [Swift.String]()
            for string0 in notEqualsContainer {
                if let string0 = string0 {
                    notEqualsDecoded0?.append(string0)
                }
            }
        }
        notEquals = notEqualsDecoded0
        let greaterThanDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .greaterThan) ?? 0
        greaterThan = greaterThanDecoded
        let greaterThanOrEqualDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .greaterThanOrEqual) ?? 0
        greaterThanOrEqual = greaterThanOrEqualDecoded
        let lessThanDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .lessThan) ?? 0
        lessThan = lessThanDecoded
        let lessThanOrEqualDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .lessThanOrEqual) ?? 0
        lessThanOrEqual = lessThanOrEqualDecoded
    }
}

extension GuardDutyClientTypes {
    /// Contains information about the condition.
    public struct Condition: Swift.Equatable {
        /// Represents the equal condition to be applied to a single field when querying for findings.
        @available(*, deprecated)
        public var eq: [Swift.String]?
        /// Represents an equal condition to be applied to a single field when querying for findings.
        public var equals: [Swift.String]?
        /// Represents a greater than condition to be applied to a single field when querying for findings.
        public var greaterThan: Swift.Int
        /// Represents a greater than or equal condition to be applied to a single field when querying for findings.
        public var greaterThanOrEqual: Swift.Int
        /// Represents a greater than condition to be applied to a single field when querying for findings.
        @available(*, deprecated)
        public var gt: Swift.Int
        /// Represents a greater than or equal condition to be applied to a single field when querying for findings.
        @available(*, deprecated)
        public var gte: Swift.Int
        /// Represents a less than condition to be applied to a single field when querying for findings.
        public var lessThan: Swift.Int
        /// Represents a less than or equal condition to be applied to a single field when querying for findings.
        public var lessThanOrEqual: Swift.Int
        /// Represents a less than condition to be applied to a single field when querying for findings.
        @available(*, deprecated)
        public var lt: Swift.Int
        /// Represents a less than or equal condition to be applied to a single field when querying for findings.
        @available(*, deprecated)
        public var lte: Swift.Int
        /// Represents the not equal condition to be applied to a single field when querying for findings.
        @available(*, deprecated)
        public var neq: [Swift.String]?
        /// Represents a not equal condition to be applied to a single field when querying for findings.
        public var notEquals: [Swift.String]?

        public init (
            eq: [Swift.String]? = nil,
            equals: [Swift.String]? = nil,
            greaterThan: Swift.Int = 0,
            greaterThanOrEqual: Swift.Int = 0,
            gt: Swift.Int = 0,
            gte: Swift.Int = 0,
            lessThan: Swift.Int = 0,
            lessThanOrEqual: Swift.Int = 0,
            lt: Swift.Int = 0,
            lte: Swift.Int = 0,
            neq: [Swift.String]? = nil,
            notEquals: [Swift.String]? = nil
        )
        {
            self.eq = eq
            self.equals = equals
            self.greaterThan = greaterThan
            self.greaterThanOrEqual = greaterThanOrEqual
            self.gt = gt
            self.gte = gte
            self.lessThan = lessThan
            self.lessThanOrEqual = lessThanOrEqual
            self.lt = lt
            self.lte = lte
            self.neq = neq
            self.notEquals = notEquals
        }
    }

}

extension GuardDutyClientTypes.Container: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case containerRuntime = "containerRuntime"
        case id = "id"
        case image = "image"
        case imagePrefix = "imagePrefix"
        case name = "name"
        case securityContext = "securityContext"
        case volumeMounts = "volumeMounts"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let containerRuntime = self.containerRuntime {
            try encodeContainer.encode(containerRuntime, forKey: .containerRuntime)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let image = self.image {
            try encodeContainer.encode(image, forKey: .image)
        }
        if let imagePrefix = self.imagePrefix {
            try encodeContainer.encode(imagePrefix, forKey: .imagePrefix)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let securityContext = self.securityContext {
            try encodeContainer.encode(securityContext, forKey: .securityContext)
        }
        if let volumeMounts = volumeMounts {
            var volumeMountsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .volumeMounts)
            for volumemount0 in volumeMounts {
                try volumeMountsContainer.encode(volumemount0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let containerRuntimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .containerRuntime)
        containerRuntime = containerRuntimeDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let imageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .image)
        image = imageDecoded
        let imagePrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imagePrefix)
        imagePrefix = imagePrefixDecoded
        let volumeMountsContainer = try containerValues.decodeIfPresent([GuardDutyClientTypes.VolumeMount?].self, forKey: .volumeMounts)
        var volumeMountsDecoded0:[GuardDutyClientTypes.VolumeMount]? = nil
        if let volumeMountsContainer = volumeMountsContainer {
            volumeMountsDecoded0 = [GuardDutyClientTypes.VolumeMount]()
            for structure0 in volumeMountsContainer {
                if let structure0 = structure0 {
                    volumeMountsDecoded0?.append(structure0)
                }
            }
        }
        volumeMounts = volumeMountsDecoded0
        let securityContextDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.SecurityContext.self, forKey: .securityContext)
        securityContext = securityContextDecoded
    }
}

extension GuardDutyClientTypes {
    /// Details of a container.
    public struct Container: Swift.Equatable {
        /// The container runtime (such as, Docker or containerd) used to run the container.
        public var containerRuntime: Swift.String?
        /// Container ID.
        public var id: Swift.String?
        /// Container image.
        public var image: Swift.String?
        /// Part of the image name before the last slash. For example, imagePrefix for public.ecr.aws/amazonlinux/amazonlinux:latest would be public.ecr.aws/amazonlinux. If the image name is relative and does not have a slash, this field is empty.
        public var imagePrefix: Swift.String?
        /// Container name.
        public var name: Swift.String?
        /// Container security context.
        public var securityContext: GuardDutyClientTypes.SecurityContext?
        /// Container volume mounts.
        public var volumeMounts: [GuardDutyClientTypes.VolumeMount]?

        public init (
            containerRuntime: Swift.String? = nil,
            id: Swift.String? = nil,
            image: Swift.String? = nil,
            imagePrefix: Swift.String? = nil,
            name: Swift.String? = nil,
            securityContext: GuardDutyClientTypes.SecurityContext? = nil,
            volumeMounts: [GuardDutyClientTypes.VolumeMount]? = nil
        )
        {
            self.containerRuntime = containerRuntime
            self.id = id
            self.image = image
            self.imagePrefix = imagePrefix
            self.name = name
            self.securityContext = securityContext
            self.volumeMounts = volumeMounts
        }
    }

}

extension GuardDutyClientTypes.Country: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case countryCode = "countryCode"
        case countryName = "countryName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let countryCode = self.countryCode {
            try encodeContainer.encode(countryCode, forKey: .countryCode)
        }
        if let countryName = self.countryName {
            try encodeContainer.encode(countryName, forKey: .countryName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let countryCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .countryCode)
        countryCode = countryCodeDecoded
        let countryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .countryName)
        countryName = countryNameDecoded
    }
}

extension GuardDutyClientTypes {
    /// Contains information about the country where the remote IP address is located.
    public struct Country: Swift.Equatable {
        /// The country code of the remote IP address.
        public var countryCode: Swift.String?
        /// The country name of the remote IP address.
        public var countryName: Swift.String?

        public init (
            countryCode: Swift.String? = nil,
            countryName: Swift.String? = nil
        )
        {
            self.countryCode = countryCode
            self.countryName = countryName
        }
    }

}

extension CreateDetectorInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "clientToken"
        case dataSources = "dataSources"
        case enable = "enable"
        case findingPublishingFrequency = "findingPublishingFrequency"
        case tags = "tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let dataSources = self.dataSources {
            try encodeContainer.encode(dataSources, forKey: .dataSources)
        }
        if let enable = self.enable {
            try encodeContainer.encode(enable, forKey: .enable)
        }
        if let findingPublishingFrequency = self.findingPublishingFrequency {
            try encodeContainer.encode(findingPublishingFrequency.rawValue, forKey: .findingPublishingFrequency)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateDetectorInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/detector"
    }
}

public struct CreateDetectorInput: Swift.Equatable {
    /// The idempotency token for the create request.
    public var clientToken: Swift.String?
    /// Describes which data sources will be enabled for the detector. There might be regional differences because some data sources might not be available in all the Amazon Web Services Regions where GuardDuty is presently supported. For more information, see [Regions and endpoints](https://docs.aws.amazon.com/guardduty/latest/ug/guardduty_regions.html).
    public var dataSources: GuardDutyClientTypes.DataSourceConfigurations?
    /// A Boolean value that specifies whether the detector is to be enabled.
    /// This member is required.
    public var enable: Swift.Bool?
    /// A value that specifies how frequently updated findings are exported.
    public var findingPublishingFrequency: GuardDutyClientTypes.FindingPublishingFrequency?
    /// The tags to be added to a new detector resource.
    public var tags: [Swift.String:Swift.String]?

    public init (
        clientToken: Swift.String? = nil,
        dataSources: GuardDutyClientTypes.DataSourceConfigurations? = nil,
        enable: Swift.Bool? = nil,
        findingPublishingFrequency: GuardDutyClientTypes.FindingPublishingFrequency? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.clientToken = clientToken
        self.dataSources = dataSources
        self.enable = enable
        self.findingPublishingFrequency = findingPublishingFrequency
        self.tags = tags
    }
}

struct CreateDetectorInputBody: Swift.Equatable {
    let enable: Swift.Bool?
    let clientToken: Swift.String?
    let findingPublishingFrequency: GuardDutyClientTypes.FindingPublishingFrequency?
    let dataSources: GuardDutyClientTypes.DataSourceConfigurations?
    let tags: [Swift.String:Swift.String]?
}

extension CreateDetectorInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "clientToken"
        case dataSources = "dataSources"
        case enable = "enable"
        case findingPublishingFrequency = "findingPublishingFrequency"
        case tags = "tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enableDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enable)
        enable = enableDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let findingPublishingFrequencyDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.FindingPublishingFrequency.self, forKey: .findingPublishingFrequency)
        findingPublishingFrequency = findingPublishingFrequencyDecoded
        let dataSourcesDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.DataSourceConfigurations.self, forKey: .dataSources)
        dataSources = dataSourcesDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateDetectorOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateDetectorOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateDetectorOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateDetectorOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateDetectorOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.detectorId = output.detectorId
            self.unprocessedDataSources = output.unprocessedDataSources
        } else {
            self.detectorId = nil
            self.unprocessedDataSources = nil
        }
    }
}

public struct CreateDetectorOutputResponse: Swift.Equatable {
    /// The unique ID of the created detector.
    public var detectorId: Swift.String?
    /// Specifies the data sources that couldn't be enabled when GuardDuty was enabled for the first time.
    public var unprocessedDataSources: GuardDutyClientTypes.UnprocessedDataSourcesResult?

    public init (
        detectorId: Swift.String? = nil,
        unprocessedDataSources: GuardDutyClientTypes.UnprocessedDataSourcesResult? = nil
    )
    {
        self.detectorId = detectorId
        self.unprocessedDataSources = unprocessedDataSources
    }
}

struct CreateDetectorOutputResponseBody: Swift.Equatable {
    let detectorId: Swift.String?
    let unprocessedDataSources: GuardDutyClientTypes.UnprocessedDataSourcesResult?
}

extension CreateDetectorOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case detectorId = "detectorId"
        case unprocessedDataSources = "unprocessedDataSources"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detectorIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detectorId)
        detectorId = detectorIdDecoded
        let unprocessedDataSourcesDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.UnprocessedDataSourcesResult.self, forKey: .unprocessedDataSources)
        unprocessedDataSources = unprocessedDataSourcesDecoded
    }
}

extension CreateFilterInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action = "action"
        case clientToken = "clientToken"
        case description = "description"
        case findingCriteria = "findingCriteria"
        case name = "name"
        case rank = "rank"
        case tags = "tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = self.action {
            try encodeContainer.encode(action.rawValue, forKey: .action)
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let findingCriteria = self.findingCriteria {
            try encodeContainer.encode(findingCriteria, forKey: .findingCriteria)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let rank = self.rank {
            try encodeContainer.encode(rank, forKey: .rank)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateFilterInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let detectorId = detectorId else {
            return nil
        }
        return "/detector/\(detectorId.urlPercentEncoding())/filter"
    }
}

public struct CreateFilterInput: Swift.Equatable {
    /// Specifies the action that is to be applied to the findings that match the filter.
    public var action: GuardDutyClientTypes.FilterAction?
    /// The idempotency token for the create request.
    public var clientToken: Swift.String?
    /// The description of the filter. Valid characters include alphanumeric characters, and special characters such as -, ., :, { }, [ ], ( ), /, \t, \n, \x0B, \f, \r, _, and whitespace.
    public var description: Swift.String?
    /// The ID of the detector belonging to the GuardDuty account that you want to create a filter for.
    /// This member is required.
    public var detectorId: Swift.String?
    /// Represents the criteria to be used in the filter for querying findings. You can only use the following attributes to query findings:
    ///
    /// * accountId
    ///
    /// * region
    ///
    /// * id
    ///
    /// * resource.accessKeyDetails.accessKeyId
    ///
    /// * resource.accessKeyDetails.principalId
    ///
    /// * resource.accessKeyDetails.userName
    ///
    /// * resource.accessKeyDetails.userType
    ///
    /// * resource.instanceDetails.iamInstanceProfile.id
    ///
    /// * resource.instanceDetails.imageId
    ///
    /// * resource.instanceDetails.instanceId
    ///
    /// * resource.instanceDetails.outpostArn
    ///
    /// * resource.instanceDetails.networkInterfaces.ipv6Addresses
    ///
    /// * resource.instanceDetails.networkInterfaces.privateIpAddresses.privateIpAddress
    ///
    /// * resource.instanceDetails.networkInterfaces.publicDnsName
    ///
    /// * resource.instanceDetails.networkInterfaces.publicIp
    ///
    /// * resource.instanceDetails.networkInterfaces.securityGroups.groupId
    ///
    /// * resource.instanceDetails.networkInterfaces.securityGroups.groupName
    ///
    /// * resource.instanceDetails.networkInterfaces.subnetId
    ///
    /// * resource.instanceDetails.networkInterfaces.vpcId
    ///
    /// * resource.instanceDetails.tags.key
    ///
    /// * resource.instanceDetails.tags.value
    ///
    /// * resource.resourceType
    ///
    /// * service.action.actionType
    ///
    /// * service.action.awsApiCallAction.api
    ///
    /// * service.action.awsApiCallAction.callerType
    ///
    /// * service.action.awsApiCallAction.errorCode
    ///
    /// * service.action.awsApiCallAction.userAgent
    ///
    /// * service.action.awsApiCallAction.remoteIpDetails.city.cityName
    ///
    /// * service.action.awsApiCallAction.remoteIpDetails.country.countryName
    ///
    /// * service.action.awsApiCallAction.remoteIpDetails.ipAddressV4
    ///
    /// * service.action.awsApiCallAction.remoteIpDetails.organization.asn
    ///
    /// * service.action.awsApiCallAction.remoteIpDetails.organization.asnOrg
    ///
    /// * service.action.awsApiCallAction.serviceName
    ///
    /// * service.action.dnsRequestAction.domain
    ///
    /// * service.action.networkConnectionAction.blocked
    ///
    /// * service.action.networkConnectionAction.connectionDirection
    ///
    /// * service.action.networkConnectionAction.localPortDetails.port
    ///
    /// * service.action.networkConnectionAction.protocol
    ///
    /// * service.action.networkConnectionAction.localIpDetails.ipAddressV4
    ///
    /// * service.action.networkConnectionAction.remoteIpDetails.city.cityName
    ///
    /// * service.action.networkConnectionAction.remoteIpDetails.country.countryName
    ///
    /// * service.action.networkConnectionAction.remoteIpDetails.ipAddressV4
    ///
    /// * service.action.networkConnectionAction.remoteIpDetails.organization.asn
    ///
    /// * service.action.networkConnectionAction.remoteIpDetails.organization.asnOrg
    ///
    /// * service.action.networkConnectionAction.remotePortDetails.port
    ///
    /// * service.additionalInfo.threatListName
    ///
    /// * resource.s3BucketDetails.publicAccess.effectivePermissions
    ///
    /// * resource.s3BucketDetails.name
    ///
    /// * resource.s3BucketDetails.tags.key
    ///
    /// * resource.s3BucketDetails.tags.value
    ///
    /// * resource.s3BucketDetails.type
    ///
    /// * service.resourceRole
    ///
    /// * severity
    ///
    /// * type
    ///
    /// * updatedAt Type: ISO 8601 string format: YYYY-MM-DDTHH:MM:SS.SSSZ or YYYY-MM-DDTHH:MM:SSZ depending on whether the value contains milliseconds.
    /// This member is required.
    public var findingCriteria: GuardDutyClientTypes.FindingCriteria?
    /// The name of the filter. Valid characters include period (.), underscore (_), dash (-), and alphanumeric characters. A whitespace is considered to be an invalid character.
    /// This member is required.
    public var name: Swift.String?
    /// Specifies the position of the filter in the list of current filters. Also specifies the order in which this filter is applied to the findings.
    public var rank: Swift.Int?
    /// The tags to be added to a new filter resource.
    public var tags: [Swift.String:Swift.String]?

    public init (
        action: GuardDutyClientTypes.FilterAction? = nil,
        clientToken: Swift.String? = nil,
        description: Swift.String? = nil,
        detectorId: Swift.String? = nil,
        findingCriteria: GuardDutyClientTypes.FindingCriteria? = nil,
        name: Swift.String? = nil,
        rank: Swift.Int? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.action = action
        self.clientToken = clientToken
        self.description = description
        self.detectorId = detectorId
        self.findingCriteria = findingCriteria
        self.name = name
        self.rank = rank
        self.tags = tags
    }
}

struct CreateFilterInputBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let action: GuardDutyClientTypes.FilterAction?
    let rank: Swift.Int?
    let findingCriteria: GuardDutyClientTypes.FindingCriteria?
    let clientToken: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateFilterInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action = "action"
        case clientToken = "clientToken"
        case description = "description"
        case findingCriteria = "findingCriteria"
        case name = "name"
        case rank = "rank"
        case tags = "tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let actionDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.FilterAction.self, forKey: .action)
        action = actionDecoded
        let rankDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .rank)
        rank = rankDecoded
        let findingCriteriaDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.FindingCriteria.self, forKey: .findingCriteria)
        findingCriteria = findingCriteriaDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateFilterOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateFilterOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateFilterOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateFilterOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateFilterOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.name = output.name
        } else {
            self.name = nil
        }
    }
}

public struct CreateFilterOutputResponse: Swift.Equatable {
    /// The name of the successfully created filter.
    /// This member is required.
    public var name: Swift.String?

    public init (
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct CreateFilterOutputResponseBody: Swift.Equatable {
    let name: Swift.String?
}

extension CreateFilterOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension CreateIPSetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case activate = "activate"
        case clientToken = "clientToken"
        case format = "format"
        case location = "location"
        case name = "name"
        case tags = "tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let activate = self.activate {
            try encodeContainer.encode(activate, forKey: .activate)
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let format = self.format {
            try encodeContainer.encode(format.rawValue, forKey: .format)
        }
        if let location = self.location {
            try encodeContainer.encode(location, forKey: .location)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateIPSetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let detectorId = detectorId else {
            return nil
        }
        return "/detector/\(detectorId.urlPercentEncoding())/ipset"
    }
}

public struct CreateIPSetInput: Swift.Equatable {
    /// A Boolean value that indicates whether GuardDuty is to start using the uploaded IPSet.
    /// This member is required.
    public var activate: Swift.Bool?
    /// The idempotency token for the create request.
    public var clientToken: Swift.String?
    /// The unique ID of the detector of the GuardDuty account that you want to create an IPSet for.
    /// This member is required.
    public var detectorId: Swift.String?
    /// The format of the file that contains the IPSet.
    /// This member is required.
    public var format: GuardDutyClientTypes.IpSetFormat?
    /// The URI of the file that contains the IPSet.
    /// This member is required.
    public var location: Swift.String?
    /// The user-friendly name to identify the IPSet. Allowed characters are alphanumeric, whitespace, dash (-), and underscores (_).
    /// This member is required.
    public var name: Swift.String?
    /// The tags to be added to a new IP set resource.
    public var tags: [Swift.String:Swift.String]?

    public init (
        activate: Swift.Bool? = nil,
        clientToken: Swift.String? = nil,
        detectorId: Swift.String? = nil,
        format: GuardDutyClientTypes.IpSetFormat? = nil,
        location: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.activate = activate
        self.clientToken = clientToken
        self.detectorId = detectorId
        self.format = format
        self.location = location
        self.name = name
        self.tags = tags
    }
}

struct CreateIPSetInputBody: Swift.Equatable {
    let name: Swift.String?
    let format: GuardDutyClientTypes.IpSetFormat?
    let location: Swift.String?
    let activate: Swift.Bool?
    let clientToken: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateIPSetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case activate = "activate"
        case clientToken = "clientToken"
        case format = "format"
        case location = "location"
        case name = "name"
        case tags = "tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let formatDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.IpSetFormat.self, forKey: .format)
        format = formatDecoded
        let locationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .location)
        location = locationDecoded
        let activateDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .activate)
        activate = activateDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateIPSetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateIPSetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateIPSetOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateIPSetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateIPSetOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.ipSetId = output.ipSetId
        } else {
            self.ipSetId = nil
        }
    }
}

public struct CreateIPSetOutputResponse: Swift.Equatable {
    /// The ID of the IPSet resource.
    /// This member is required.
    public var ipSetId: Swift.String?

    public init (
        ipSetId: Swift.String? = nil
    )
    {
        self.ipSetId = ipSetId
    }
}

struct CreateIPSetOutputResponseBody: Swift.Equatable {
    let ipSetId: Swift.String?
}

extension CreateIPSetOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ipSetId = "ipSetId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ipSetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ipSetId)
        ipSetId = ipSetIdDecoded
    }
}

extension CreateMembersInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountDetails = "accountDetails"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountDetails = accountDetails {
            var accountDetailsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accountDetails)
            for accountdetail0 in accountDetails {
                try accountDetailsContainer.encode(accountdetail0)
            }
        }
    }
}

extension CreateMembersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let detectorId = detectorId else {
            return nil
        }
        return "/detector/\(detectorId.urlPercentEncoding())/member"
    }
}

public struct CreateMembersInput: Swift.Equatable {
    /// A list of account ID and email address pairs of the accounts that you want to associate with the GuardDuty administrator account.
    /// This member is required.
    public var accountDetails: [GuardDutyClientTypes.AccountDetail]?
    /// The unique ID of the detector of the GuardDuty account that you want to associate member accounts with.
    /// This member is required.
    public var detectorId: Swift.String?

    public init (
        accountDetails: [GuardDutyClientTypes.AccountDetail]? = nil,
        detectorId: Swift.String? = nil
    )
    {
        self.accountDetails = accountDetails
        self.detectorId = detectorId
    }
}

struct CreateMembersInputBody: Swift.Equatable {
    let accountDetails: [GuardDutyClientTypes.AccountDetail]?
}

extension CreateMembersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountDetails = "accountDetails"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountDetailsContainer = try containerValues.decodeIfPresent([GuardDutyClientTypes.AccountDetail?].self, forKey: .accountDetails)
        var accountDetailsDecoded0:[GuardDutyClientTypes.AccountDetail]? = nil
        if let accountDetailsContainer = accountDetailsContainer {
            accountDetailsDecoded0 = [GuardDutyClientTypes.AccountDetail]()
            for structure0 in accountDetailsContainer {
                if let structure0 = structure0 {
                    accountDetailsDecoded0?.append(structure0)
                }
            }
        }
        accountDetails = accountDetailsDecoded0
    }
}

extension CreateMembersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateMembersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateMembersOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateMembersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateMembersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.unprocessedAccounts = output.unprocessedAccounts
        } else {
            self.unprocessedAccounts = nil
        }
    }
}

public struct CreateMembersOutputResponse: Swift.Equatable {
    /// A list of objects that include the accountIds of the unprocessed accounts and a result string that explains why each was unprocessed.
    /// This member is required.
    public var unprocessedAccounts: [GuardDutyClientTypes.UnprocessedAccount]?

    public init (
        unprocessedAccounts: [GuardDutyClientTypes.UnprocessedAccount]? = nil
    )
    {
        self.unprocessedAccounts = unprocessedAccounts
    }
}

struct CreateMembersOutputResponseBody: Swift.Equatable {
    let unprocessedAccounts: [GuardDutyClientTypes.UnprocessedAccount]?
}

extension CreateMembersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case unprocessedAccounts = "unprocessedAccounts"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let unprocessedAccountsContainer = try containerValues.decodeIfPresent([GuardDutyClientTypes.UnprocessedAccount?].self, forKey: .unprocessedAccounts)
        var unprocessedAccountsDecoded0:[GuardDutyClientTypes.UnprocessedAccount]? = nil
        if let unprocessedAccountsContainer = unprocessedAccountsContainer {
            unprocessedAccountsDecoded0 = [GuardDutyClientTypes.UnprocessedAccount]()
            for structure0 in unprocessedAccountsContainer {
                if let structure0 = structure0 {
                    unprocessedAccountsDecoded0?.append(structure0)
                }
            }
        }
        unprocessedAccounts = unprocessedAccountsDecoded0
    }
}

extension CreatePublishingDestinationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "clientToken"
        case destinationProperties = "destinationProperties"
        case destinationType = "destinationType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let destinationProperties = self.destinationProperties {
            try encodeContainer.encode(destinationProperties, forKey: .destinationProperties)
        }
        if let destinationType = self.destinationType {
            try encodeContainer.encode(destinationType.rawValue, forKey: .destinationType)
        }
    }
}

extension CreatePublishingDestinationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let detectorId = detectorId else {
            return nil
        }
        return "/detector/\(detectorId.urlPercentEncoding())/publishingDestination"
    }
}

public struct CreatePublishingDestinationInput: Swift.Equatable {
    /// The idempotency token for the request.
    public var clientToken: Swift.String?
    /// The properties of the publishing destination, including the ARNs for the destination and the KMS key used for encryption.
    /// This member is required.
    public var destinationProperties: GuardDutyClientTypes.DestinationProperties?
    /// The type of resource for the publishing destination. Currently only Amazon S3 buckets are supported.
    /// This member is required.
    public var destinationType: GuardDutyClientTypes.DestinationType?
    /// The ID of the GuardDuty detector associated with the publishing destination.
    /// This member is required.
    public var detectorId: Swift.String?

    public init (
        clientToken: Swift.String? = nil,
        destinationProperties: GuardDutyClientTypes.DestinationProperties? = nil,
        destinationType: GuardDutyClientTypes.DestinationType? = nil,
        detectorId: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.destinationProperties = destinationProperties
        self.destinationType = destinationType
        self.detectorId = detectorId
    }
}

struct CreatePublishingDestinationInputBody: Swift.Equatable {
    let destinationType: GuardDutyClientTypes.DestinationType?
    let destinationProperties: GuardDutyClientTypes.DestinationProperties?
    let clientToken: Swift.String?
}

extension CreatePublishingDestinationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken = "clientToken"
        case destinationProperties = "destinationProperties"
        case destinationType = "destinationType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let destinationTypeDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.DestinationType.self, forKey: .destinationType)
        destinationType = destinationTypeDecoded
        let destinationPropertiesDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.DestinationProperties.self, forKey: .destinationProperties)
        destinationProperties = destinationPropertiesDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension CreatePublishingDestinationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreatePublishingDestinationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreatePublishingDestinationOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreatePublishingDestinationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreatePublishingDestinationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.destinationId = output.destinationId
        } else {
            self.destinationId = nil
        }
    }
}

public struct CreatePublishingDestinationOutputResponse: Swift.Equatable {
    /// The ID of the publishing destination that is created.
    /// This member is required.
    public var destinationId: Swift.String?

    public init (
        destinationId: Swift.String? = nil
    )
    {
        self.destinationId = destinationId
    }
}

struct CreatePublishingDestinationOutputResponseBody: Swift.Equatable {
    let destinationId: Swift.String?
}

extension CreatePublishingDestinationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationId = "destinationId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let destinationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationId)
        destinationId = destinationIdDecoded
    }
}

extension CreateSampleFindingsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case findingTypes = "findingTypes"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let findingTypes = findingTypes {
            var findingTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .findingTypes)
            for findingtype0 in findingTypes {
                try findingTypesContainer.encode(findingtype0)
            }
        }
    }
}

extension CreateSampleFindingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let detectorId = detectorId else {
            return nil
        }
        return "/detector/\(detectorId.urlPercentEncoding())/findings/create"
    }
}

public struct CreateSampleFindingsInput: Swift.Equatable {
    /// The ID of the detector to create sample findings for.
    /// This member is required.
    public var detectorId: Swift.String?
    /// The types of sample findings to generate.
    public var findingTypes: [Swift.String]?

    public init (
        detectorId: Swift.String? = nil,
        findingTypes: [Swift.String]? = nil
    )
    {
        self.detectorId = detectorId
        self.findingTypes = findingTypes
    }
}

struct CreateSampleFindingsInputBody: Swift.Equatable {
    let findingTypes: [Swift.String]?
}

extension CreateSampleFindingsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case findingTypes = "findingTypes"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let findingTypesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .findingTypes)
        var findingTypesDecoded0:[Swift.String]? = nil
        if let findingTypesContainer = findingTypesContainer {
            findingTypesDecoded0 = [Swift.String]()
            for string0 in findingTypesContainer {
                if let string0 = string0 {
                    findingTypesDecoded0?.append(string0)
                }
            }
        }
        findingTypes = findingTypesDecoded0
    }
}

extension CreateSampleFindingsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateSampleFindingsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateSampleFindingsOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateSampleFindingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct CreateSampleFindingsOutputResponse: Swift.Equatable {

    public init () { }
}

extension CreateThreatIntelSetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case activate = "activate"
        case clientToken = "clientToken"
        case format = "format"
        case location = "location"
        case name = "name"
        case tags = "tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let activate = self.activate {
            try encodeContainer.encode(activate, forKey: .activate)
        }
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let format = self.format {
            try encodeContainer.encode(format.rawValue, forKey: .format)
        }
        if let location = self.location {
            try encodeContainer.encode(location, forKey: .location)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateThreatIntelSetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let detectorId = detectorId else {
            return nil
        }
        return "/detector/\(detectorId.urlPercentEncoding())/threatintelset"
    }
}

public struct CreateThreatIntelSetInput: Swift.Equatable {
    /// A Boolean value that indicates whether GuardDuty is to start using the uploaded ThreatIntelSet.
    /// This member is required.
    public var activate: Swift.Bool?
    /// The idempotency token for the create request.
    public var clientToken: Swift.String?
    /// The unique ID of the detector of the GuardDuty account that you want to create a threatIntelSet for.
    /// This member is required.
    public var detectorId: Swift.String?
    /// The format of the file that contains the ThreatIntelSet.
    /// This member is required.
    public var format: GuardDutyClientTypes.ThreatIntelSetFormat?
    /// The URI of the file that contains the ThreatIntelSet.
    /// This member is required.
    public var location: Swift.String?
    /// A user-friendly ThreatIntelSet name displayed in all findings that are generated by activity that involves IP addresses included in this ThreatIntelSet.
    /// This member is required.
    public var name: Swift.String?
    /// The tags to be added to a new threat list resource.
    public var tags: [Swift.String:Swift.String]?

    public init (
        activate: Swift.Bool? = nil,
        clientToken: Swift.String? = nil,
        detectorId: Swift.String? = nil,
        format: GuardDutyClientTypes.ThreatIntelSetFormat? = nil,
        location: Swift.String? = nil,
        name: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.activate = activate
        self.clientToken = clientToken
        self.detectorId = detectorId
        self.format = format
        self.location = location
        self.name = name
        self.tags = tags
    }
}

struct CreateThreatIntelSetInputBody: Swift.Equatable {
    let name: Swift.String?
    let format: GuardDutyClientTypes.ThreatIntelSetFormat?
    let location: Swift.String?
    let activate: Swift.Bool?
    let clientToken: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateThreatIntelSetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case activate = "activate"
        case clientToken = "clientToken"
        case format = "format"
        case location = "location"
        case name = "name"
        case tags = "tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let formatDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.ThreatIntelSetFormat.self, forKey: .format)
        format = formatDecoded
        let locationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .location)
        location = locationDecoded
        let activateDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .activate)
        activate = activateDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateThreatIntelSetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension CreateThreatIntelSetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum CreateThreatIntelSetOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension CreateThreatIntelSetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: CreateThreatIntelSetOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.threatIntelSetId = output.threatIntelSetId
        } else {
            self.threatIntelSetId = nil
        }
    }
}

public struct CreateThreatIntelSetOutputResponse: Swift.Equatable {
    /// The ID of the ThreatIntelSet resource.
    /// This member is required.
    public var threatIntelSetId: Swift.String?

    public init (
        threatIntelSetId: Swift.String? = nil
    )
    {
        self.threatIntelSetId = threatIntelSetId
    }
}

struct CreateThreatIntelSetOutputResponseBody: Swift.Equatable {
    let threatIntelSetId: Swift.String?
}

extension CreateThreatIntelSetOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case threatIntelSetId = "threatIntelSetId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let threatIntelSetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .threatIntelSetId)
        threatIntelSetId = threatIntelSetIdDecoded
    }
}

extension GuardDutyClientTypes {
    public enum CriterionKey: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case accountId
        case ec2InstanceArn
        case guarddutyFindingId
        case scanId
        case scanStartTime
        case scanStatus
        case sdkUnknown(Swift.String)

        public static var allCases: [CriterionKey] {
            return [
                .accountId,
                .ec2InstanceArn,
                .guarddutyFindingId,
                .scanId,
                .scanStartTime,
                .scanStatus,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .accountId: return "ACCOUNT_ID"
            case .ec2InstanceArn: return "EC2_INSTANCE_ARN"
            case .guarddutyFindingId: return "GUARDDUTY_FINDING_ID"
            case .scanId: return "SCAN_ID"
            case .scanStartTime: return "SCAN_START_TIME"
            case .scanStatus: return "SCAN_STATUS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = CriterionKey(rawValue: rawValue) ?? CriterionKey.sdkUnknown(rawValue)
        }
    }
}

extension GuardDutyClientTypes.DNSLogsConfigurationResult: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status = "status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.DataSourceStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension GuardDutyClientTypes {
    /// Contains information on the status of DNS logs as a data source.
    public struct DNSLogsConfigurationResult: Swift.Equatable {
        /// Denotes whether DNS logs is enabled as a data source.
        /// This member is required.
        public var status: GuardDutyClientTypes.DataSourceStatus?

        public init (
            status: GuardDutyClientTypes.DataSourceStatus? = nil
        )
        {
            self.status = status
        }
    }

}

extension GuardDutyClientTypes {
    public enum DataSource: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cloudTrail
        case dnsLogs
        case ec2MalwareScan
        case flowLogs
        case kubernetesAuditLogs
        case s3Logs
        case sdkUnknown(Swift.String)

        public static var allCases: [DataSource] {
            return [
                .cloudTrail,
                .dnsLogs,
                .ec2MalwareScan,
                .flowLogs,
                .kubernetesAuditLogs,
                .s3Logs,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cloudTrail: return "CLOUD_TRAIL"
            case .dnsLogs: return "DNS_LOGS"
            case .ec2MalwareScan: return "EC2_MALWARE_SCAN"
            case .flowLogs: return "FLOW_LOGS"
            case .kubernetesAuditLogs: return "KUBERNETES_AUDIT_LOGS"
            case .s3Logs: return "S3_LOGS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DataSource(rawValue: rawValue) ?? DataSource.sdkUnknown(rawValue)
        }
    }
}

extension GuardDutyClientTypes.DataSourceConfigurations: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case kubernetes = "kubernetes"
        case malwareProtection = "malwareProtection"
        case s3Logs = "s3Logs"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let kubernetes = self.kubernetes {
            try encodeContainer.encode(kubernetes, forKey: .kubernetes)
        }
        if let malwareProtection = self.malwareProtection {
            try encodeContainer.encode(malwareProtection, forKey: .malwareProtection)
        }
        if let s3Logs = self.s3Logs {
            try encodeContainer.encode(s3Logs, forKey: .s3Logs)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3LogsDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.S3LogsConfiguration.self, forKey: .s3Logs)
        s3Logs = s3LogsDecoded
        let kubernetesDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.KubernetesConfiguration.self, forKey: .kubernetes)
        kubernetes = kubernetesDecoded
        let malwareProtectionDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.MalwareProtectionConfiguration.self, forKey: .malwareProtection)
        malwareProtection = malwareProtectionDecoded
    }
}

extension GuardDutyClientTypes {
    /// Contains information about which data sources are enabled.
    public struct DataSourceConfigurations: Swift.Equatable {
        /// Describes whether any Kubernetes logs are enabled as data sources.
        public var kubernetes: GuardDutyClientTypes.KubernetesConfiguration?
        /// Describes whether Malware Protection is enabled as a data source.
        public var malwareProtection: GuardDutyClientTypes.MalwareProtectionConfiguration?
        /// Describes whether S3 data event logs are enabled as a data source.
        public var s3Logs: GuardDutyClientTypes.S3LogsConfiguration?

        public init (
            kubernetes: GuardDutyClientTypes.KubernetesConfiguration? = nil,
            malwareProtection: GuardDutyClientTypes.MalwareProtectionConfiguration? = nil,
            s3Logs: GuardDutyClientTypes.S3LogsConfiguration? = nil
        )
        {
            self.kubernetes = kubernetes
            self.malwareProtection = malwareProtection
            self.s3Logs = s3Logs
        }
    }

}

extension GuardDutyClientTypes.DataSourceConfigurationsResult: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cloudTrail = "cloudTrail"
        case dnsLogs = "dnsLogs"
        case flowLogs = "flowLogs"
        case kubernetes = "kubernetes"
        case malwareProtection = "malwareProtection"
        case s3Logs = "s3Logs"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cloudTrail = self.cloudTrail {
            try encodeContainer.encode(cloudTrail, forKey: .cloudTrail)
        }
        if let dnsLogs = self.dnsLogs {
            try encodeContainer.encode(dnsLogs, forKey: .dnsLogs)
        }
        if let flowLogs = self.flowLogs {
            try encodeContainer.encode(flowLogs, forKey: .flowLogs)
        }
        if let kubernetes = self.kubernetes {
            try encodeContainer.encode(kubernetes, forKey: .kubernetes)
        }
        if let malwareProtection = self.malwareProtection {
            try encodeContainer.encode(malwareProtection, forKey: .malwareProtection)
        }
        if let s3Logs = self.s3Logs {
            try encodeContainer.encode(s3Logs, forKey: .s3Logs)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cloudTrailDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.CloudTrailConfigurationResult.self, forKey: .cloudTrail)
        cloudTrail = cloudTrailDecoded
        let dnsLogsDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.DNSLogsConfigurationResult.self, forKey: .dnsLogs)
        dnsLogs = dnsLogsDecoded
        let flowLogsDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.FlowLogsConfigurationResult.self, forKey: .flowLogs)
        flowLogs = flowLogsDecoded
        let s3LogsDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.S3LogsConfigurationResult.self, forKey: .s3Logs)
        s3Logs = s3LogsDecoded
        let kubernetesDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.KubernetesConfigurationResult.self, forKey: .kubernetes)
        kubernetes = kubernetesDecoded
        let malwareProtectionDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.MalwareProtectionConfigurationResult.self, forKey: .malwareProtection)
        malwareProtection = malwareProtectionDecoded
    }
}

extension GuardDutyClientTypes {
    /// Contains information on the status of data sources for the detector.
    public struct DataSourceConfigurationsResult: Swift.Equatable {
        /// An object that contains information on the status of CloudTrail as a data source.
        /// This member is required.
        public var cloudTrail: GuardDutyClientTypes.CloudTrailConfigurationResult?
        /// An object that contains information on the status of DNS logs as a data source.
        /// This member is required.
        public var dnsLogs: GuardDutyClientTypes.DNSLogsConfigurationResult?
        /// An object that contains information on the status of VPC flow logs as a data source.
        /// This member is required.
        public var flowLogs: GuardDutyClientTypes.FlowLogsConfigurationResult?
        /// An object that contains information on the status of all Kubernetes data sources.
        public var kubernetes: GuardDutyClientTypes.KubernetesConfigurationResult?
        /// Describes the configuration of Malware Protection data sources.
        public var malwareProtection: GuardDutyClientTypes.MalwareProtectionConfigurationResult?
        /// An object that contains information on the status of S3 Data event logs as a data source.
        /// This member is required.
        public var s3Logs: GuardDutyClientTypes.S3LogsConfigurationResult?

        public init (
            cloudTrail: GuardDutyClientTypes.CloudTrailConfigurationResult? = nil,
            dnsLogs: GuardDutyClientTypes.DNSLogsConfigurationResult? = nil,
            flowLogs: GuardDutyClientTypes.FlowLogsConfigurationResult? = nil,
            kubernetes: GuardDutyClientTypes.KubernetesConfigurationResult? = nil,
            malwareProtection: GuardDutyClientTypes.MalwareProtectionConfigurationResult? = nil,
            s3Logs: GuardDutyClientTypes.S3LogsConfigurationResult? = nil
        )
        {
            self.cloudTrail = cloudTrail
            self.dnsLogs = dnsLogs
            self.flowLogs = flowLogs
            self.kubernetes = kubernetes
            self.malwareProtection = malwareProtection
            self.s3Logs = s3Logs
        }
    }

}

extension GuardDutyClientTypes.DataSourceFreeTrial: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case freeTrialDaysRemaining = "freeTrialDaysRemaining"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if freeTrialDaysRemaining != 0 {
            try encodeContainer.encode(freeTrialDaysRemaining, forKey: .freeTrialDaysRemaining)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let freeTrialDaysRemainingDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .freeTrialDaysRemaining) ?? 0
        freeTrialDaysRemaining = freeTrialDaysRemainingDecoded
    }
}

extension GuardDutyClientTypes {
    /// Contains information about which data sources are enabled for the GuardDuty member account.
    public struct DataSourceFreeTrial: Swift.Equatable {
        /// A value that specifies the number of days left to use each enabled data source.
        public var freeTrialDaysRemaining: Swift.Int

        public init (
            freeTrialDaysRemaining: Swift.Int = 0
        )
        {
            self.freeTrialDaysRemaining = freeTrialDaysRemaining
        }
    }

}

extension GuardDutyClientTypes {
    public enum DataSourceStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [DataSourceStatus] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DataSourceStatus(rawValue: rawValue) ?? DataSourceStatus.sdkUnknown(rawValue)
        }
    }
}

extension GuardDutyClientTypes.DataSourcesFreeTrial: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cloudTrail = "cloudTrail"
        case dnsLogs = "dnsLogs"
        case flowLogs = "flowLogs"
        case kubernetes = "kubernetes"
        case malwareProtection = "malwareProtection"
        case s3Logs = "s3Logs"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cloudTrail = self.cloudTrail {
            try encodeContainer.encode(cloudTrail, forKey: .cloudTrail)
        }
        if let dnsLogs = self.dnsLogs {
            try encodeContainer.encode(dnsLogs, forKey: .dnsLogs)
        }
        if let flowLogs = self.flowLogs {
            try encodeContainer.encode(flowLogs, forKey: .flowLogs)
        }
        if let kubernetes = self.kubernetes {
            try encodeContainer.encode(kubernetes, forKey: .kubernetes)
        }
        if let malwareProtection = self.malwareProtection {
            try encodeContainer.encode(malwareProtection, forKey: .malwareProtection)
        }
        if let s3Logs = self.s3Logs {
            try encodeContainer.encode(s3Logs, forKey: .s3Logs)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cloudTrailDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.DataSourceFreeTrial.self, forKey: .cloudTrail)
        cloudTrail = cloudTrailDecoded
        let dnsLogsDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.DataSourceFreeTrial.self, forKey: .dnsLogs)
        dnsLogs = dnsLogsDecoded
        let flowLogsDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.DataSourceFreeTrial.self, forKey: .flowLogs)
        flowLogs = flowLogsDecoded
        let s3LogsDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.DataSourceFreeTrial.self, forKey: .s3Logs)
        s3Logs = s3LogsDecoded
        let kubernetesDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.KubernetesDataSourceFreeTrial.self, forKey: .kubernetes)
        kubernetes = kubernetesDecoded
        let malwareProtectionDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.MalwareProtectionDataSourceFreeTrial.self, forKey: .malwareProtection)
        malwareProtection = malwareProtectionDecoded
    }
}

extension GuardDutyClientTypes {
    /// Contains information about which data sources are enabled for the GuardDuty member account.
    public struct DataSourcesFreeTrial: Swift.Equatable {
        /// Describes whether any Amazon Web Services CloudTrail management event logs are enabled as data sources.
        public var cloudTrail: GuardDutyClientTypes.DataSourceFreeTrial?
        /// Describes whether any DNS logs are enabled as data sources.
        public var dnsLogs: GuardDutyClientTypes.DataSourceFreeTrial?
        /// Describes whether any VPC Flow logs are enabled as data sources.
        public var flowLogs: GuardDutyClientTypes.DataSourceFreeTrial?
        /// Describes whether any Kubernetes logs are enabled as data sources.
        public var kubernetes: GuardDutyClientTypes.KubernetesDataSourceFreeTrial?
        /// Describes whether Malware Protection is enabled as a data source.
        public var malwareProtection: GuardDutyClientTypes.MalwareProtectionDataSourceFreeTrial?
        /// Describes whether any S3 data event logs are enabled as data sources.
        public var s3Logs: GuardDutyClientTypes.DataSourceFreeTrial?

        public init (
            cloudTrail: GuardDutyClientTypes.DataSourceFreeTrial? = nil,
            dnsLogs: GuardDutyClientTypes.DataSourceFreeTrial? = nil,
            flowLogs: GuardDutyClientTypes.DataSourceFreeTrial? = nil,
            kubernetes: GuardDutyClientTypes.KubernetesDataSourceFreeTrial? = nil,
            malwareProtection: GuardDutyClientTypes.MalwareProtectionDataSourceFreeTrial? = nil,
            s3Logs: GuardDutyClientTypes.DataSourceFreeTrial? = nil
        )
        {
            self.cloudTrail = cloudTrail
            self.dnsLogs = dnsLogs
            self.flowLogs = flowLogs
            self.kubernetes = kubernetes
            self.malwareProtection = malwareProtection
            self.s3Logs = s3Logs
        }
    }

}

extension DeclineInvitationsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountIds = "accountIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountIds = accountIds {
            var accountIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accountIds)
            for accountid0 in accountIds {
                try accountIdsContainer.encode(accountid0)
            }
        }
    }
}

extension DeclineInvitationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/invitation/decline"
    }
}

public struct DeclineInvitationsInput: Swift.Equatable {
    /// A list of account IDs of the Amazon Web Services accounts that sent invitations to the current member account that you want to decline invitations from.
    /// This member is required.
    public var accountIds: [Swift.String]?

    public init (
        accountIds: [Swift.String]? = nil
    )
    {
        self.accountIds = accountIds
    }
}

struct DeclineInvitationsInputBody: Swift.Equatable {
    let accountIds: [Swift.String]?
}

extension DeclineInvitationsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountIds = "accountIds"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .accountIds)
        var accountIdsDecoded0:[Swift.String]? = nil
        if let accountIdsContainer = accountIdsContainer {
            accountIdsDecoded0 = [Swift.String]()
            for string0 in accountIdsContainer {
                if let string0 = string0 {
                    accountIdsDecoded0?.append(string0)
                }
            }
        }
        accountIds = accountIdsDecoded0
    }
}

extension DeclineInvitationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeclineInvitationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeclineInvitationsOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeclineInvitationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DeclineInvitationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.unprocessedAccounts = output.unprocessedAccounts
        } else {
            self.unprocessedAccounts = nil
        }
    }
}

public struct DeclineInvitationsOutputResponse: Swift.Equatable {
    /// A list of objects that contain the unprocessed account and a result string that explains why it was unprocessed.
    /// This member is required.
    public var unprocessedAccounts: [GuardDutyClientTypes.UnprocessedAccount]?

    public init (
        unprocessedAccounts: [GuardDutyClientTypes.UnprocessedAccount]? = nil
    )
    {
        self.unprocessedAccounts = unprocessedAccounts
    }
}

struct DeclineInvitationsOutputResponseBody: Swift.Equatable {
    let unprocessedAccounts: [GuardDutyClientTypes.UnprocessedAccount]?
}

extension DeclineInvitationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case unprocessedAccounts = "unprocessedAccounts"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let unprocessedAccountsContainer = try containerValues.decodeIfPresent([GuardDutyClientTypes.UnprocessedAccount?].self, forKey: .unprocessedAccounts)
        var unprocessedAccountsDecoded0:[GuardDutyClientTypes.UnprocessedAccount]? = nil
        if let unprocessedAccountsContainer = unprocessedAccountsContainer {
            unprocessedAccountsDecoded0 = [GuardDutyClientTypes.UnprocessedAccount]()
            for structure0 in unprocessedAccountsContainer {
                if let structure0 = structure0 {
                    unprocessedAccountsDecoded0?.append(structure0)
                }
            }
        }
        unprocessedAccounts = unprocessedAccountsDecoded0
    }
}

extension GuardDutyClientTypes.DefaultServerSideEncryption: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case encryptionType = "encryptionType"
        case kmsMasterKeyArn = "kmsMasterKeyArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let encryptionType = self.encryptionType {
            try encodeContainer.encode(encryptionType, forKey: .encryptionType)
        }
        if let kmsMasterKeyArn = self.kmsMasterKeyArn {
            try encodeContainer.encode(kmsMasterKeyArn, forKey: .kmsMasterKeyArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let encryptionTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .encryptionType)
        encryptionType = encryptionTypeDecoded
        let kmsMasterKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsMasterKeyArn)
        kmsMasterKeyArn = kmsMasterKeyArnDecoded
    }
}

extension GuardDutyClientTypes {
    /// Contains information on the server side encryption method used in the S3 bucket. See [S3 Server-Side Encryption](https://docs.aws.amazon.com/AmazonS3/latest/dev/serv-side-encryption.html) for more information.
    public struct DefaultServerSideEncryption: Swift.Equatable {
        /// The type of encryption used for objects within the S3 bucket.
        public var encryptionType: Swift.String?
        /// The Amazon Resource Name (ARN) of the KMS encryption key. Only available if the bucket EncryptionType is aws:kms.
        public var kmsMasterKeyArn: Swift.String?

        public init (
            encryptionType: Swift.String? = nil,
            kmsMasterKeyArn: Swift.String? = nil
        )
        {
            self.encryptionType = encryptionType
            self.kmsMasterKeyArn = kmsMasterKeyArn
        }
    }

}

extension DeleteDetectorInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let detectorId = detectorId else {
            return nil
        }
        return "/detector/\(detectorId.urlPercentEncoding())"
    }
}

public struct DeleteDetectorInput: Swift.Equatable {
    /// The unique ID of the detector that you want to delete.
    /// This member is required.
    public var detectorId: Swift.String?

    public init (
        detectorId: Swift.String? = nil
    )
    {
        self.detectorId = detectorId
    }
}

struct DeleteDetectorInputBody: Swift.Equatable {
}

extension DeleteDetectorInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteDetectorOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteDetectorOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteDetectorOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteDetectorOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteDetectorOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteFilterInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let detectorId = detectorId else {
            return nil
        }
        guard let filterName = filterName else {
            return nil
        }
        return "/detector/\(detectorId.urlPercentEncoding())/filter/\(filterName.urlPercentEncoding())"
    }
}

public struct DeleteFilterInput: Swift.Equatable {
    /// The unique ID of the detector that the filter is associated with.
    /// This member is required.
    public var detectorId: Swift.String?
    /// The name of the filter that you want to delete.
    /// This member is required.
    public var filterName: Swift.String?

    public init (
        detectorId: Swift.String? = nil,
        filterName: Swift.String? = nil
    )
    {
        self.detectorId = detectorId
        self.filterName = filterName
    }
}

struct DeleteFilterInputBody: Swift.Equatable {
}

extension DeleteFilterInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteFilterOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteFilterOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteFilterOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteFilterOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteFilterOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteIPSetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let detectorId = detectorId else {
            return nil
        }
        guard let ipSetId = ipSetId else {
            return nil
        }
        return "/detector/\(detectorId.urlPercentEncoding())/ipset/\(ipSetId.urlPercentEncoding())"
    }
}

public struct DeleteIPSetInput: Swift.Equatable {
    /// The unique ID of the detector associated with the IPSet.
    /// This member is required.
    public var detectorId: Swift.String?
    /// The unique ID of the IPSet to delete.
    /// This member is required.
    public var ipSetId: Swift.String?

    public init (
        detectorId: Swift.String? = nil,
        ipSetId: Swift.String? = nil
    )
    {
        self.detectorId = detectorId
        self.ipSetId = ipSetId
    }
}

struct DeleteIPSetInputBody: Swift.Equatable {
}

extension DeleteIPSetInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteIPSetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteIPSetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteIPSetOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteIPSetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteIPSetOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteInvitationsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountIds = "accountIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountIds = accountIds {
            var accountIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accountIds)
            for accountid0 in accountIds {
                try accountIdsContainer.encode(accountid0)
            }
        }
    }
}

extension DeleteInvitationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/invitation/delete"
    }
}

public struct DeleteInvitationsInput: Swift.Equatable {
    /// A list of account IDs of the Amazon Web Services accounts that sent invitations to the current member account that you want to delete invitations from.
    /// This member is required.
    public var accountIds: [Swift.String]?

    public init (
        accountIds: [Swift.String]? = nil
    )
    {
        self.accountIds = accountIds
    }
}

struct DeleteInvitationsInputBody: Swift.Equatable {
    let accountIds: [Swift.String]?
}

extension DeleteInvitationsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountIds = "accountIds"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .accountIds)
        var accountIdsDecoded0:[Swift.String]? = nil
        if let accountIdsContainer = accountIdsContainer {
            accountIdsDecoded0 = [Swift.String]()
            for string0 in accountIdsContainer {
                if let string0 = string0 {
                    accountIdsDecoded0?.append(string0)
                }
            }
        }
        accountIds = accountIdsDecoded0
    }
}

extension DeleteInvitationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteInvitationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteInvitationsOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteInvitationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DeleteInvitationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.unprocessedAccounts = output.unprocessedAccounts
        } else {
            self.unprocessedAccounts = nil
        }
    }
}

public struct DeleteInvitationsOutputResponse: Swift.Equatable {
    /// A list of objects that contain the unprocessed account and a result string that explains why it was unprocessed.
    /// This member is required.
    public var unprocessedAccounts: [GuardDutyClientTypes.UnprocessedAccount]?

    public init (
        unprocessedAccounts: [GuardDutyClientTypes.UnprocessedAccount]? = nil
    )
    {
        self.unprocessedAccounts = unprocessedAccounts
    }
}

struct DeleteInvitationsOutputResponseBody: Swift.Equatable {
    let unprocessedAccounts: [GuardDutyClientTypes.UnprocessedAccount]?
}

extension DeleteInvitationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case unprocessedAccounts = "unprocessedAccounts"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let unprocessedAccountsContainer = try containerValues.decodeIfPresent([GuardDutyClientTypes.UnprocessedAccount?].self, forKey: .unprocessedAccounts)
        var unprocessedAccountsDecoded0:[GuardDutyClientTypes.UnprocessedAccount]? = nil
        if let unprocessedAccountsContainer = unprocessedAccountsContainer {
            unprocessedAccountsDecoded0 = [GuardDutyClientTypes.UnprocessedAccount]()
            for structure0 in unprocessedAccountsContainer {
                if let structure0 = structure0 {
                    unprocessedAccountsDecoded0?.append(structure0)
                }
            }
        }
        unprocessedAccounts = unprocessedAccountsDecoded0
    }
}

extension DeleteMembersInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountIds = "accountIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountIds = accountIds {
            var accountIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accountIds)
            for accountid0 in accountIds {
                try accountIdsContainer.encode(accountid0)
            }
        }
    }
}

extension DeleteMembersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let detectorId = detectorId else {
            return nil
        }
        return "/detector/\(detectorId.urlPercentEncoding())/member/delete"
    }
}

public struct DeleteMembersInput: Swift.Equatable {
    /// A list of account IDs of the GuardDuty member accounts that you want to delete.
    /// This member is required.
    public var accountIds: [Swift.String]?
    /// The unique ID of the detector of the GuardDuty account whose members you want to delete.
    /// This member is required.
    public var detectorId: Swift.String?

    public init (
        accountIds: [Swift.String]? = nil,
        detectorId: Swift.String? = nil
    )
    {
        self.accountIds = accountIds
        self.detectorId = detectorId
    }
}

struct DeleteMembersInputBody: Swift.Equatable {
    let accountIds: [Swift.String]?
}

extension DeleteMembersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountIds = "accountIds"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .accountIds)
        var accountIdsDecoded0:[Swift.String]? = nil
        if let accountIdsContainer = accountIdsContainer {
            accountIdsDecoded0 = [Swift.String]()
            for string0 in accountIdsContainer {
                if let string0 = string0 {
                    accountIdsDecoded0?.append(string0)
                }
            }
        }
        accountIds = accountIdsDecoded0
    }
}

extension DeleteMembersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteMembersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteMembersOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteMembersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DeleteMembersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.unprocessedAccounts = output.unprocessedAccounts
        } else {
            self.unprocessedAccounts = nil
        }
    }
}

public struct DeleteMembersOutputResponse: Swift.Equatable {
    /// The accounts that could not be processed.
    /// This member is required.
    public var unprocessedAccounts: [GuardDutyClientTypes.UnprocessedAccount]?

    public init (
        unprocessedAccounts: [GuardDutyClientTypes.UnprocessedAccount]? = nil
    )
    {
        self.unprocessedAccounts = unprocessedAccounts
    }
}

struct DeleteMembersOutputResponseBody: Swift.Equatable {
    let unprocessedAccounts: [GuardDutyClientTypes.UnprocessedAccount]?
}

extension DeleteMembersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case unprocessedAccounts = "unprocessedAccounts"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let unprocessedAccountsContainer = try containerValues.decodeIfPresent([GuardDutyClientTypes.UnprocessedAccount?].self, forKey: .unprocessedAccounts)
        var unprocessedAccountsDecoded0:[GuardDutyClientTypes.UnprocessedAccount]? = nil
        if let unprocessedAccountsContainer = unprocessedAccountsContainer {
            unprocessedAccountsDecoded0 = [GuardDutyClientTypes.UnprocessedAccount]()
            for structure0 in unprocessedAccountsContainer {
                if let structure0 = structure0 {
                    unprocessedAccountsDecoded0?.append(structure0)
                }
            }
        }
        unprocessedAccounts = unprocessedAccountsDecoded0
    }
}

extension DeletePublishingDestinationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let detectorId = detectorId else {
            return nil
        }
        guard let destinationId = destinationId else {
            return nil
        }
        return "/detector/\(detectorId.urlPercentEncoding())/publishingDestination/\(destinationId.urlPercentEncoding())"
    }
}

public struct DeletePublishingDestinationInput: Swift.Equatable {
    /// The ID of the publishing destination to delete.
    /// This member is required.
    public var destinationId: Swift.String?
    /// The unique ID of the detector associated with the publishing destination to delete.
    /// This member is required.
    public var detectorId: Swift.String?

    public init (
        destinationId: Swift.String? = nil,
        detectorId: Swift.String? = nil
    )
    {
        self.destinationId = destinationId
        self.detectorId = detectorId
    }
}

struct DeletePublishingDestinationInputBody: Swift.Equatable {
}

extension DeletePublishingDestinationInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeletePublishingDestinationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeletePublishingDestinationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeletePublishingDestinationOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeletePublishingDestinationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeletePublishingDestinationOutputResponse: Swift.Equatable {

    public init () { }
}

extension DeleteThreatIntelSetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let detectorId = detectorId else {
            return nil
        }
        guard let threatIntelSetId = threatIntelSetId else {
            return nil
        }
        return "/detector/\(detectorId.urlPercentEncoding())/threatintelset/\(threatIntelSetId.urlPercentEncoding())"
    }
}

public struct DeleteThreatIntelSetInput: Swift.Equatable {
    /// The unique ID of the detector that the threatIntelSet is associated with.
    /// This member is required.
    public var detectorId: Swift.String?
    /// The unique ID of the threatIntelSet that you want to delete.
    /// This member is required.
    public var threatIntelSetId: Swift.String?

    public init (
        detectorId: Swift.String? = nil,
        threatIntelSetId: Swift.String? = nil
    )
    {
        self.detectorId = detectorId
        self.threatIntelSetId = threatIntelSetId
    }
}

struct DeleteThreatIntelSetInputBody: Swift.Equatable {
}

extension DeleteThreatIntelSetInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DeleteThreatIntelSetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DeleteThreatIntelSetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DeleteThreatIntelSetOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DeleteThreatIntelSetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DeleteThreatIntelSetOutputResponse: Swift.Equatable {

    public init () { }
}

extension DescribeMalwareScansInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filterCriteria = "filterCriteria"
        case maxResults = "maxResults"
        case nextToken = "nextToken"
        case sortCriteria = "sortCriteria"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filterCriteria = self.filterCriteria {
            try encodeContainer.encode(filterCriteria, forKey: .filterCriteria)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let sortCriteria = self.sortCriteria {
            try encodeContainer.encode(sortCriteria, forKey: .sortCriteria)
        }
    }
}

extension DescribeMalwareScansInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let detectorId = detectorId else {
            return nil
        }
        return "/detector/\(detectorId.urlPercentEncoding())/malware-scans"
    }
}

public struct DescribeMalwareScansInput: Swift.Equatable {
    /// The unique ID of the detector that the request is associated with.
    /// This member is required.
    public var detectorId: Swift.String?
    /// Represents the criteria to be used in the filter for describing scan entries.
    public var filterCriteria: GuardDutyClientTypes.FilterCriteria?
    /// You can use this parameter to indicate the maximum number of items that you want in the response. The default value is 50. The maximum value is 50.
    public var maxResults: Swift.Int?
    /// You can use this parameter when paginating results. Set the value of this parameter to null on your first call to the list action. For subsequent calls to the action, fill nextToken in the request with the value of NextToken from the previous response to continue listing data.
    public var nextToken: Swift.String?
    /// Represents the criteria used for sorting scan entries. The [attributeName](https://docs.aws.amazon.com/guardduty/latest/APIReference/API_SortCriteria.html#guardduty-Type-SortCriteria-attributeName) is required and it must be scanStartTime.
    public var sortCriteria: GuardDutyClientTypes.SortCriteria?

    public init (
        detectorId: Swift.String? = nil,
        filterCriteria: GuardDutyClientTypes.FilterCriteria? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        sortCriteria: GuardDutyClientTypes.SortCriteria? = nil
    )
    {
        self.detectorId = detectorId
        self.filterCriteria = filterCriteria
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sortCriteria = sortCriteria
    }
}

struct DescribeMalwareScansInputBody: Swift.Equatable {
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
    let filterCriteria: GuardDutyClientTypes.FilterCriteria?
    let sortCriteria: GuardDutyClientTypes.SortCriteria?
}

extension DescribeMalwareScansInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filterCriteria = "filterCriteria"
        case maxResults = "maxResults"
        case nextToken = "nextToken"
        case sortCriteria = "sortCriteria"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let filterCriteriaDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.FilterCriteria.self, forKey: .filterCriteria)
        filterCriteria = filterCriteriaDecoded
        let sortCriteriaDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.SortCriteria.self, forKey: .sortCriteria)
        sortCriteria = sortCriteriaDecoded
    }
}

extension DescribeMalwareScansOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeMalwareScansOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeMalwareScansOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeMalwareScansOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeMalwareScansOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.scans = output.scans
        } else {
            self.nextToken = nil
            self.scans = nil
        }
    }
}

public struct DescribeMalwareScansOutputResponse: Swift.Equatable {
    /// The pagination parameter to be used on the next list operation to retrieve more items.
    public var nextToken: Swift.String?
    /// Contains information about malware scans.
    /// This member is required.
    public var scans: [GuardDutyClientTypes.Scan]?

    public init (
        nextToken: Swift.String? = nil,
        scans: [GuardDutyClientTypes.Scan]? = nil
    )
    {
        self.nextToken = nextToken
        self.scans = scans
    }
}

struct DescribeMalwareScansOutputResponseBody: Swift.Equatable {
    let scans: [GuardDutyClientTypes.Scan]?
    let nextToken: Swift.String?
}

extension DescribeMalwareScansOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "nextToken"
        case scans = "scans"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scansContainer = try containerValues.decodeIfPresent([GuardDutyClientTypes.Scan?].self, forKey: .scans)
        var scansDecoded0:[GuardDutyClientTypes.Scan]? = nil
        if let scansContainer = scansContainer {
            scansDecoded0 = [GuardDutyClientTypes.Scan]()
            for structure0 in scansContainer {
                if let structure0 = structure0 {
                    scansDecoded0?.append(structure0)
                }
            }
        }
        scans = scansDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension DescribeOrganizationConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let detectorId = detectorId else {
            return nil
        }
        return "/detector/\(detectorId.urlPercentEncoding())/admin"
    }
}

public struct DescribeOrganizationConfigurationInput: Swift.Equatable {
    /// The ID of the detector to retrieve information about the delegated administrator from.
    /// This member is required.
    public var detectorId: Swift.String?

    public init (
        detectorId: Swift.String? = nil
    )
    {
        self.detectorId = detectorId
    }
}

struct DescribeOrganizationConfigurationInputBody: Swift.Equatable {
}

extension DescribeOrganizationConfigurationInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribeOrganizationConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribeOrganizationConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribeOrganizationConfigurationOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribeOrganizationConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribeOrganizationConfigurationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.autoEnable = output.autoEnable
            self.dataSources = output.dataSources
            self.memberAccountLimitReached = output.memberAccountLimitReached
        } else {
            self.autoEnable = false
            self.dataSources = nil
            self.memberAccountLimitReached = false
        }
    }
}

public struct DescribeOrganizationConfigurationOutputResponse: Swift.Equatable {
    /// Indicates whether GuardDuty is automatically enabled for accounts added to the organization.
    /// This member is required.
    public var autoEnable: Swift.Bool
    /// Describes which data sources are enabled automatically for member accounts.
    public var dataSources: GuardDutyClientTypes.OrganizationDataSourceConfigurationsResult?
    /// Indicates whether the maximum number of allowed member accounts are already associated with the delegated administrator account for your organization.
    /// This member is required.
    public var memberAccountLimitReached: Swift.Bool

    public init (
        autoEnable: Swift.Bool = false,
        dataSources: GuardDutyClientTypes.OrganizationDataSourceConfigurationsResult? = nil,
        memberAccountLimitReached: Swift.Bool = false
    )
    {
        self.autoEnable = autoEnable
        self.dataSources = dataSources
        self.memberAccountLimitReached = memberAccountLimitReached
    }
}

struct DescribeOrganizationConfigurationOutputResponseBody: Swift.Equatable {
    let autoEnable: Swift.Bool
    let memberAccountLimitReached: Swift.Bool
    let dataSources: GuardDutyClientTypes.OrganizationDataSourceConfigurationsResult?
}

extension DescribeOrganizationConfigurationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoEnable = "autoEnable"
        case dataSources = "dataSources"
        case memberAccountLimitReached = "memberAccountLimitReached"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let autoEnableDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .autoEnable) ?? false
        autoEnable = autoEnableDecoded
        let memberAccountLimitReachedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .memberAccountLimitReached) ?? false
        memberAccountLimitReached = memberAccountLimitReachedDecoded
        let dataSourcesDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.OrganizationDataSourceConfigurationsResult.self, forKey: .dataSources)
        dataSources = dataSourcesDecoded
    }
}

extension DescribePublishingDestinationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let detectorId = detectorId else {
            return nil
        }
        guard let destinationId = destinationId else {
            return nil
        }
        return "/detector/\(detectorId.urlPercentEncoding())/publishingDestination/\(destinationId.urlPercentEncoding())"
    }
}

public struct DescribePublishingDestinationInput: Swift.Equatable {
    /// The ID of the publishing destination to retrieve.
    /// This member is required.
    public var destinationId: Swift.String?
    /// The unique ID of the detector associated with the publishing destination to retrieve.
    /// This member is required.
    public var detectorId: Swift.String?

    public init (
        destinationId: Swift.String? = nil,
        detectorId: Swift.String? = nil
    )
    {
        self.destinationId = destinationId
        self.detectorId = detectorId
    }
}

struct DescribePublishingDestinationInputBody: Swift.Equatable {
}

extension DescribePublishingDestinationInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DescribePublishingDestinationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DescribePublishingDestinationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DescribePublishingDestinationOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DescribePublishingDestinationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DescribePublishingDestinationOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.destinationId = output.destinationId
            self.destinationProperties = output.destinationProperties
            self.destinationType = output.destinationType
            self.publishingFailureStartTimestamp = output.publishingFailureStartTimestamp
            self.status = output.status
        } else {
            self.destinationId = nil
            self.destinationProperties = nil
            self.destinationType = nil
            self.publishingFailureStartTimestamp = 0
            self.status = nil
        }
    }
}

public struct DescribePublishingDestinationOutputResponse: Swift.Equatable {
    /// The ID of the publishing destination.
    /// This member is required.
    public var destinationId: Swift.String?
    /// A DestinationProperties object that includes the DestinationArn and KmsKeyArn of the publishing destination.
    /// This member is required.
    public var destinationProperties: GuardDutyClientTypes.DestinationProperties?
    /// The type of publishing destination. Currently, only Amazon S3 buckets are supported.
    /// This member is required.
    public var destinationType: GuardDutyClientTypes.DestinationType?
    /// The time, in epoch millisecond format, at which GuardDuty was first unable to publish findings to the destination.
    /// This member is required.
    public var publishingFailureStartTimestamp: Swift.Int
    /// The status of the publishing destination.
    /// This member is required.
    public var status: GuardDutyClientTypes.PublishingStatus?

    public init (
        destinationId: Swift.String? = nil,
        destinationProperties: GuardDutyClientTypes.DestinationProperties? = nil,
        destinationType: GuardDutyClientTypes.DestinationType? = nil,
        publishingFailureStartTimestamp: Swift.Int = 0,
        status: GuardDutyClientTypes.PublishingStatus? = nil
    )
    {
        self.destinationId = destinationId
        self.destinationProperties = destinationProperties
        self.destinationType = destinationType
        self.publishingFailureStartTimestamp = publishingFailureStartTimestamp
        self.status = status
    }
}

struct DescribePublishingDestinationOutputResponseBody: Swift.Equatable {
    let destinationId: Swift.String?
    let destinationType: GuardDutyClientTypes.DestinationType?
    let status: GuardDutyClientTypes.PublishingStatus?
    let publishingFailureStartTimestamp: Swift.Int
    let destinationProperties: GuardDutyClientTypes.DestinationProperties?
}

extension DescribePublishingDestinationOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationId = "destinationId"
        case destinationProperties = "destinationProperties"
        case destinationType = "destinationType"
        case publishingFailureStartTimestamp = "publishingFailureStartTimestamp"
        case status = "status"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let destinationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationId)
        destinationId = destinationIdDecoded
        let destinationTypeDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.DestinationType.self, forKey: .destinationType)
        destinationType = destinationTypeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.PublishingStatus.self, forKey: .status)
        status = statusDecoded
        let publishingFailureStartTimestampDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .publishingFailureStartTimestamp) ?? 0
        publishingFailureStartTimestamp = publishingFailureStartTimestampDecoded
        let destinationPropertiesDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.DestinationProperties.self, forKey: .destinationProperties)
        destinationProperties = destinationPropertiesDecoded
    }
}

extension GuardDutyClientTypes.Destination: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationId = "destinationId"
        case destinationType = "destinationType"
        case status = "status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destinationId = self.destinationId {
            try encodeContainer.encode(destinationId, forKey: .destinationId)
        }
        if let destinationType = self.destinationType {
            try encodeContainer.encode(destinationType.rawValue, forKey: .destinationType)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let destinationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationId)
        destinationId = destinationIdDecoded
        let destinationTypeDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.DestinationType.self, forKey: .destinationType)
        destinationType = destinationTypeDecoded
        let statusDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.PublishingStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension GuardDutyClientTypes {
    /// Contains information about the publishing destination, including the ID, type, and status.
    public struct Destination: Swift.Equatable {
        /// The unique ID of the publishing destination.
        /// This member is required.
        public var destinationId: Swift.String?
        /// The type of resource used for the publishing destination. Currently, only Amazon S3 buckets are supported.
        /// This member is required.
        public var destinationType: GuardDutyClientTypes.DestinationType?
        /// The status of the publishing destination.
        /// This member is required.
        public var status: GuardDutyClientTypes.PublishingStatus?

        public init (
            destinationId: Swift.String? = nil,
            destinationType: GuardDutyClientTypes.DestinationType? = nil,
            status: GuardDutyClientTypes.PublishingStatus? = nil
        )
        {
            self.destinationId = destinationId
            self.destinationType = destinationType
            self.status = status
        }
    }

}

extension GuardDutyClientTypes.DestinationProperties: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationArn = "destinationArn"
        case kmsKeyArn = "kmsKeyArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destinationArn = self.destinationArn {
            try encodeContainer.encode(destinationArn, forKey: .destinationArn)
        }
        if let kmsKeyArn = self.kmsKeyArn {
            try encodeContainer.encode(kmsKeyArn, forKey: .kmsKeyArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let destinationArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .destinationArn)
        destinationArn = destinationArnDecoded
        let kmsKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyArn)
        kmsKeyArn = kmsKeyArnDecoded
    }
}

extension GuardDutyClientTypes {
    /// Contains the Amazon Resource Name (ARN) of the resource to publish to, such as an S3 bucket, and the ARN of the KMS key to use to encrypt published findings.
    public struct DestinationProperties: Swift.Equatable {
        /// The ARN of the resource to publish to. To specify an S3 bucket folder use the following format: arn:aws:s3:::DOC-EXAMPLE-BUCKET/myFolder/
        public var destinationArn: Swift.String?
        /// The ARN of the KMS key to use for encryption.
        public var kmsKeyArn: Swift.String?

        public init (
            destinationArn: Swift.String? = nil,
            kmsKeyArn: Swift.String? = nil
        )
        {
            self.destinationArn = destinationArn
            self.kmsKeyArn = kmsKeyArn
        }
    }

}

extension GuardDutyClientTypes {
    public enum DestinationType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case s3
        case sdkUnknown(Swift.String)

        public static var allCases: [DestinationType] {
            return [
                .s3,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .s3: return "S3"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DestinationType(rawValue: rawValue) ?? DestinationType.sdkUnknown(rawValue)
        }
    }
}

extension GuardDutyClientTypes {
    public enum DetectorStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [DetectorStatus] {
            return [
                .disabled,
                .enabled,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "DISABLED"
            case .enabled: return "ENABLED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DetectorStatus(rawValue: rawValue) ?? DetectorStatus.sdkUnknown(rawValue)
        }
    }
}

extension DisableOrganizationAdminAccountInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case adminAccountId = "adminAccountId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let adminAccountId = self.adminAccountId {
            try encodeContainer.encode(adminAccountId, forKey: .adminAccountId)
        }
    }
}

extension DisableOrganizationAdminAccountInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/admin/disable"
    }
}

public struct DisableOrganizationAdminAccountInput: Swift.Equatable {
    /// The Amazon Web Services Account ID for the organizations account to be disabled as a GuardDuty delegated administrator.
    /// This member is required.
    public var adminAccountId: Swift.String?

    public init (
        adminAccountId: Swift.String? = nil
    )
    {
        self.adminAccountId = adminAccountId
    }
}

struct DisableOrganizationAdminAccountInputBody: Swift.Equatable {
    let adminAccountId: Swift.String?
}

extension DisableOrganizationAdminAccountInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case adminAccountId = "adminAccountId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let adminAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .adminAccountId)
        adminAccountId = adminAccountIdDecoded
    }
}

extension DisableOrganizationAdminAccountOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisableOrganizationAdminAccountOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DisableOrganizationAdminAccountOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisableOrganizationAdminAccountOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DisableOrganizationAdminAccountOutputResponse: Swift.Equatable {

    public init () { }
}

extension DisassociateFromAdministratorAccountInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let detectorId = detectorId else {
            return nil
        }
        return "/detector/\(detectorId.urlPercentEncoding())/administrator/disassociate"
    }
}

public struct DisassociateFromAdministratorAccountInput: Swift.Equatable {
    /// The unique ID of the detector of the GuardDuty member account.
    /// This member is required.
    public var detectorId: Swift.String?

    public init (
        detectorId: Swift.String? = nil
    )
    {
        self.detectorId = detectorId
    }
}

struct DisassociateFromAdministratorAccountInputBody: Swift.Equatable {
}

extension DisassociateFromAdministratorAccountInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DisassociateFromAdministratorAccountOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateFromAdministratorAccountOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DisassociateFromAdministratorAccountOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateFromAdministratorAccountOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct DisassociateFromAdministratorAccountOutputResponse: Swift.Equatable {

    public init () { }
}

extension DisassociateFromMasterAccountInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let detectorId = detectorId else {
            return nil
        }
        return "/detector/\(detectorId.urlPercentEncoding())/master/disassociate"
    }
}

@available(*, deprecated, message: "This input is deprecated, use DisassociateFromAdministratorAccountRequest instead")
public struct DisassociateFromMasterAccountInput: Swift.Equatable {
    /// The unique ID of the detector of the GuardDuty member account.
    /// This member is required.
    public var detectorId: Swift.String?

    public init (
        detectorId: Swift.String? = nil
    )
    {
        self.detectorId = detectorId
    }
}

struct DisassociateFromMasterAccountInputBody: Swift.Equatable {
}

extension DisassociateFromMasterAccountInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension DisassociateFromMasterAccountOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateFromMasterAccountOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DisassociateFromMasterAccountOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateFromMasterAccountOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

@available(*, deprecated, message: "This output is deprecated, use DisassociateFromAdministratorAccountResponse instead")
public struct DisassociateFromMasterAccountOutputResponse: Swift.Equatable {

    public init () { }
}

extension DisassociateMembersInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountIds = "accountIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountIds = accountIds {
            var accountIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accountIds)
            for accountid0 in accountIds {
                try accountIdsContainer.encode(accountid0)
            }
        }
    }
}

extension DisassociateMembersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let detectorId = detectorId else {
            return nil
        }
        return "/detector/\(detectorId.urlPercentEncoding())/member/disassociate"
    }
}

public struct DisassociateMembersInput: Swift.Equatable {
    /// A list of account IDs of the GuardDuty member accounts that you want to disassociate from the administrator account.
    /// This member is required.
    public var accountIds: [Swift.String]?
    /// The unique ID of the detector of the GuardDuty account whose members you want to disassociate from the administrator account.
    /// This member is required.
    public var detectorId: Swift.String?

    public init (
        accountIds: [Swift.String]? = nil,
        detectorId: Swift.String? = nil
    )
    {
        self.accountIds = accountIds
        self.detectorId = detectorId
    }
}

struct DisassociateMembersInputBody: Swift.Equatable {
    let accountIds: [Swift.String]?
}

extension DisassociateMembersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountIds = "accountIds"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .accountIds)
        var accountIdsDecoded0:[Swift.String]? = nil
        if let accountIdsContainer = accountIdsContainer {
            accountIdsDecoded0 = [Swift.String]()
            for string0 in accountIdsContainer {
                if let string0 = string0 {
                    accountIdsDecoded0?.append(string0)
                }
            }
        }
        accountIds = accountIdsDecoded0
    }
}

extension DisassociateMembersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension DisassociateMembersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum DisassociateMembersOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension DisassociateMembersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: DisassociateMembersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.unprocessedAccounts = output.unprocessedAccounts
        } else {
            self.unprocessedAccounts = nil
        }
    }
}

public struct DisassociateMembersOutputResponse: Swift.Equatable {
    /// A list of objects that contain the unprocessed account and a result string that explains why it was unprocessed.
    /// This member is required.
    public var unprocessedAccounts: [GuardDutyClientTypes.UnprocessedAccount]?

    public init (
        unprocessedAccounts: [GuardDutyClientTypes.UnprocessedAccount]? = nil
    )
    {
        self.unprocessedAccounts = unprocessedAccounts
    }
}

struct DisassociateMembersOutputResponseBody: Swift.Equatable {
    let unprocessedAccounts: [GuardDutyClientTypes.UnprocessedAccount]?
}

extension DisassociateMembersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case unprocessedAccounts = "unprocessedAccounts"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let unprocessedAccountsContainer = try containerValues.decodeIfPresent([GuardDutyClientTypes.UnprocessedAccount?].self, forKey: .unprocessedAccounts)
        var unprocessedAccountsDecoded0:[GuardDutyClientTypes.UnprocessedAccount]? = nil
        if let unprocessedAccountsContainer = unprocessedAccountsContainer {
            unprocessedAccountsDecoded0 = [GuardDutyClientTypes.UnprocessedAccount]()
            for structure0 in unprocessedAccountsContainer {
                if let structure0 = structure0 {
                    unprocessedAccountsDecoded0?.append(structure0)
                }
            }
        }
        unprocessedAccounts = unprocessedAccountsDecoded0
    }
}

extension GuardDutyClientTypes.DnsRequestAction: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case blocked = "blocked"
        case domain = "domain"
        case `protocol` = "protocol"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if blocked != false {
            try encodeContainer.encode(blocked, forKey: .blocked)
        }
        if let domain = self.domain {
            try encodeContainer.encode(domain, forKey: .domain)
        }
        if let `protocol` = self.`protocol` {
            try encodeContainer.encode(`protocol`, forKey: .`protocol`)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domain)
        domain = domainDecoded
        let protocolDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .protocol)
        `protocol` = protocolDecoded
        let blockedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .blocked) ?? false
        blocked = blockedDecoded
    }
}

extension GuardDutyClientTypes {
    /// Contains information about the DNS_REQUEST action described in this finding.
    public struct DnsRequestAction: Swift.Equatable {
        /// Indicates whether the targeted port is blocked.
        public var blocked: Swift.Bool
        /// The domain information for the API request.
        public var domain: Swift.String?
        /// The network connection protocol observed in the activity that prompted GuardDuty to generate the finding.
        public var `protocol`: Swift.String?

        public init (
            blocked: Swift.Bool = false,
            domain: Swift.String? = nil,
            `protocol`: Swift.String? = nil
        )
        {
            self.blocked = blocked
            self.domain = domain
            self.`protocol` = `protocol`
        }
    }

}

extension GuardDutyClientTypes.DomainDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case domain = "domain"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let domain = self.domain {
            try encodeContainer.encode(domain, forKey: .domain)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let domainDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .domain)
        domain = domainDecoded
    }
}

extension GuardDutyClientTypes {
    /// Contains information about the domain.
    public struct DomainDetails: Swift.Equatable {
        /// The domain information for the Amazon Web Services API call.
        public var domain: Swift.String?

        public init (
            domain: Swift.String? = nil
        )
        {
            self.domain = domain
        }
    }

}

extension GuardDutyClientTypes {
    public enum EbsSnapshotPreservation: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case noRetention
        case retentionWithFinding
        case sdkUnknown(Swift.String)

        public static var allCases: [EbsSnapshotPreservation] {
            return [
                .noRetention,
                .retentionWithFinding,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .noRetention: return "NO_RETENTION"
            case .retentionWithFinding: return "RETENTION_WITH_FINDING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EbsSnapshotPreservation(rawValue: rawValue) ?? EbsSnapshotPreservation.sdkUnknown(rawValue)
        }
    }
}

extension GuardDutyClientTypes.EbsVolumeDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case scannedVolumeDetails = "scannedVolumeDetails"
        case skippedVolumeDetails = "skippedVolumeDetails"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let scannedVolumeDetails = scannedVolumeDetails {
            var scannedVolumeDetailsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .scannedVolumeDetails)
            for volumedetail0 in scannedVolumeDetails {
                try scannedVolumeDetailsContainer.encode(volumedetail0)
            }
        }
        if let skippedVolumeDetails = skippedVolumeDetails {
            var skippedVolumeDetailsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .skippedVolumeDetails)
            for volumedetail0 in skippedVolumeDetails {
                try skippedVolumeDetailsContainer.encode(volumedetail0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scannedVolumeDetailsContainer = try containerValues.decodeIfPresent([GuardDutyClientTypes.VolumeDetail?].self, forKey: .scannedVolumeDetails)
        var scannedVolumeDetailsDecoded0:[GuardDutyClientTypes.VolumeDetail]? = nil
        if let scannedVolumeDetailsContainer = scannedVolumeDetailsContainer {
            scannedVolumeDetailsDecoded0 = [GuardDutyClientTypes.VolumeDetail]()
            for structure0 in scannedVolumeDetailsContainer {
                if let structure0 = structure0 {
                    scannedVolumeDetailsDecoded0?.append(structure0)
                }
            }
        }
        scannedVolumeDetails = scannedVolumeDetailsDecoded0
        let skippedVolumeDetailsContainer = try containerValues.decodeIfPresent([GuardDutyClientTypes.VolumeDetail?].self, forKey: .skippedVolumeDetails)
        var skippedVolumeDetailsDecoded0:[GuardDutyClientTypes.VolumeDetail]? = nil
        if let skippedVolumeDetailsContainer = skippedVolumeDetailsContainer {
            skippedVolumeDetailsDecoded0 = [GuardDutyClientTypes.VolumeDetail]()
            for structure0 in skippedVolumeDetailsContainer {
                if let structure0 = structure0 {
                    skippedVolumeDetailsDecoded0?.append(structure0)
                }
            }
        }
        skippedVolumeDetails = skippedVolumeDetailsDecoded0
    }
}

extension GuardDutyClientTypes {
    /// Contains list of scanned and skipped EBS volumes with details.
    public struct EbsVolumeDetails: Swift.Equatable {
        /// List of EBS volumes that were scanned.
        public var scannedVolumeDetails: [GuardDutyClientTypes.VolumeDetail]?
        /// List of EBS volumes that were skipped from the malware scan.
        public var skippedVolumeDetails: [GuardDutyClientTypes.VolumeDetail]?

        public init (
            scannedVolumeDetails: [GuardDutyClientTypes.VolumeDetail]? = nil,
            skippedVolumeDetails: [GuardDutyClientTypes.VolumeDetail]? = nil
        )
        {
            self.scannedVolumeDetails = scannedVolumeDetails
            self.skippedVolumeDetails = skippedVolumeDetails
        }
    }

}

extension GuardDutyClientTypes.EbsVolumeScanDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case scanCompletedAt = "scanCompletedAt"
        case scanDetections = "scanDetections"
        case scanId = "scanId"
        case scanStartedAt = "scanStartedAt"
        case sources = "sources"
        case triggerFindingId = "triggerFindingId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let scanCompletedAt = self.scanCompletedAt {
            try encodeContainer.encodeTimestamp(scanCompletedAt, format: .epochSeconds, forKey: .scanCompletedAt)
        }
        if let scanDetections = self.scanDetections {
            try encodeContainer.encode(scanDetections, forKey: .scanDetections)
        }
        if let scanId = self.scanId {
            try encodeContainer.encode(scanId, forKey: .scanId)
        }
        if let scanStartedAt = self.scanStartedAt {
            try encodeContainer.encodeTimestamp(scanStartedAt, format: .epochSeconds, forKey: .scanStartedAt)
        }
        if let sources = sources {
            var sourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sources)
            for string0 in sources {
                try sourcesContainer.encode(string0)
            }
        }
        if let triggerFindingId = self.triggerFindingId {
            try encodeContainer.encode(triggerFindingId, forKey: .triggerFindingId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scanIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .scanId)
        scanId = scanIdDecoded
        let scanStartedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .scanStartedAt)
        scanStartedAt = scanStartedAtDecoded
        let scanCompletedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .scanCompletedAt)
        scanCompletedAt = scanCompletedAtDecoded
        let triggerFindingIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .triggerFindingId)
        triggerFindingId = triggerFindingIdDecoded
        let sourcesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .sources)
        var sourcesDecoded0:[Swift.String]? = nil
        if let sourcesContainer = sourcesContainer {
            sourcesDecoded0 = [Swift.String]()
            for string0 in sourcesContainer {
                if let string0 = string0 {
                    sourcesDecoded0?.append(string0)
                }
            }
        }
        sources = sourcesDecoded0
        let scanDetectionsDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.ScanDetections.self, forKey: .scanDetections)
        scanDetections = scanDetectionsDecoded
    }
}

extension GuardDutyClientTypes {
    /// Contains details from the malware scan that created a finding.
    public struct EbsVolumeScanDetails: Swift.Equatable {
        /// Returns the completion date and time of the malware scan.
        public var scanCompletedAt: ClientRuntime.Date?
        /// Contains a complete view providing malware scan result details.
        public var scanDetections: GuardDutyClientTypes.ScanDetections?
        /// Unique Id of the malware scan that generated the finding.
        public var scanId: Swift.String?
        /// Returns the start date and time of the malware scan.
        public var scanStartedAt: ClientRuntime.Date?
        /// Contains list of threat intelligence sources used to detect threats.
        public var sources: [Swift.String]?
        /// GuardDuty finding ID that triggered a malware scan.
        public var triggerFindingId: Swift.String?

        public init (
            scanCompletedAt: ClientRuntime.Date? = nil,
            scanDetections: GuardDutyClientTypes.ScanDetections? = nil,
            scanId: Swift.String? = nil,
            scanStartedAt: ClientRuntime.Date? = nil,
            sources: [Swift.String]? = nil,
            triggerFindingId: Swift.String? = nil
        )
        {
            self.scanCompletedAt = scanCompletedAt
            self.scanDetections = scanDetections
            self.scanId = scanId
            self.scanStartedAt = scanStartedAt
            self.sources = sources
            self.triggerFindingId = triggerFindingId
        }
    }

}

extension GuardDutyClientTypes.EbsVolumesResult: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case reason = "reason"
        case status = "status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let reason = self.reason {
            try encodeContainer.encode(reason, forKey: .reason)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.DataSourceStatus.self, forKey: .status)
        status = statusDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reason)
        reason = reasonDecoded
    }
}

extension GuardDutyClientTypes {
    /// Describes the configuration of scanning EBS volumes as a data source.
    public struct EbsVolumesResult: Swift.Equatable {
        /// Specifies the reason why scanning EBS volumes (Malware Protection) was not enabled as a data source.
        public var reason: Swift.String?
        /// Describes whether scanning EBS volumes is enabled as a data source.
        public var status: GuardDutyClientTypes.DataSourceStatus?

        public init (
            reason: Swift.String? = nil,
            status: GuardDutyClientTypes.DataSourceStatus? = nil
        )
        {
            self.reason = reason
            self.status = status
        }
    }

}

extension GuardDutyClientTypes.EcsClusterDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case activeServicesCount = "activeServicesCount"
        case arn = "arn"
        case name = "name"
        case registeredContainerInstancesCount = "registeredContainerInstancesCount"
        case runningTasksCount = "runningTasksCount"
        case status = "status"
        case tags = "tags"
        case taskDetails = "taskDetails"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if activeServicesCount != 0 {
            try encodeContainer.encode(activeServicesCount, forKey: .activeServicesCount)
        }
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if registeredContainerInstancesCount != 0 {
            try encodeContainer.encode(registeredContainerInstancesCount, forKey: .registeredContainerInstancesCount)
        }
        if runningTasksCount != 0 {
            try encodeContainer.encode(runningTasksCount, forKey: .runningTasksCount)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let taskDetails = self.taskDetails {
            try encodeContainer.encode(taskDetails, forKey: .taskDetails)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let activeServicesCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .activeServicesCount) ?? 0
        activeServicesCount = activeServicesCountDecoded
        let registeredContainerInstancesCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .registeredContainerInstancesCount) ?? 0
        registeredContainerInstancesCount = registeredContainerInstancesCountDecoded
        let runningTasksCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .runningTasksCount) ?? 0
        runningTasksCount = runningTasksCountDecoded
        let tagsContainer = try containerValues.decodeIfPresent([GuardDutyClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[GuardDutyClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [GuardDutyClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let taskDetailsDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.EcsTaskDetails.self, forKey: .taskDetails)
        taskDetails = taskDetailsDecoded
    }
}

extension GuardDutyClientTypes {
    /// Contains information about the details of the ECS Cluster.
    public struct EcsClusterDetails: Swift.Equatable {
        /// The number of services that are running on the cluster in an ACTIVE state.
        public var activeServicesCount: Swift.Int
        /// The Amazon Resource Name (ARN) that identifies the cluster.
        public var arn: Swift.String?
        /// The name of the ECS Cluster.
        public var name: Swift.String?
        /// The number of container instances registered into the cluster.
        public var registeredContainerInstancesCount: Swift.Int
        /// The number of tasks in the cluster that are in the RUNNING state.
        public var runningTasksCount: Swift.Int
        /// The status of the ECS cluster.
        public var status: Swift.String?
        /// The tags of the ECS Cluster.
        public var tags: [GuardDutyClientTypes.Tag]?
        /// Contains information about the details of the ECS Task.
        public var taskDetails: GuardDutyClientTypes.EcsTaskDetails?

        public init (
            activeServicesCount: Swift.Int = 0,
            arn: Swift.String? = nil,
            name: Swift.String? = nil,
            registeredContainerInstancesCount: Swift.Int = 0,
            runningTasksCount: Swift.Int = 0,
            status: Swift.String? = nil,
            tags: [GuardDutyClientTypes.Tag]? = nil,
            taskDetails: GuardDutyClientTypes.EcsTaskDetails? = nil
        )
        {
            self.activeServicesCount = activeServicesCount
            self.arn = arn
            self.name = name
            self.registeredContainerInstancesCount = registeredContainerInstancesCount
            self.runningTasksCount = runningTasksCount
            self.status = status
            self.tags = tags
            self.taskDetails = taskDetails
        }
    }

}

extension GuardDutyClientTypes.EcsTaskDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "arn"
        case containers = "containers"
        case definitionArn = "definitionArn"
        case group = "group"
        case startedAt = "startedAt"
        case startedBy = "startedBy"
        case tags = "tags"
        case taskCreatedAt = "createdAt"
        case version = "version"
        case volumes = "volumes"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let containers = containers {
            var containersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .containers)
            for container0 in containers {
                try containersContainer.encode(container0)
            }
        }
        if let definitionArn = self.definitionArn {
            try encodeContainer.encode(definitionArn, forKey: .definitionArn)
        }
        if let group = self.group {
            try encodeContainer.encode(group, forKey: .group)
        }
        if let startedAt = self.startedAt {
            try encodeContainer.encodeTimestamp(startedAt, format: .epochSeconds, forKey: .startedAt)
        }
        if let startedBy = self.startedBy {
            try encodeContainer.encode(startedBy, forKey: .startedBy)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let taskCreatedAt = self.taskCreatedAt {
            try encodeContainer.encodeTimestamp(taskCreatedAt, format: .epochSeconds, forKey: .taskCreatedAt)
        }
        if let version = self.version {
            try encodeContainer.encode(version, forKey: .version)
        }
        if let volumes = volumes {
            var volumesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .volumes)
            for volume0 in volumes {
                try volumesContainer.encode(volume0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let definitionArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .definitionArn)
        definitionArn = definitionArnDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let taskCreatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .taskCreatedAt)
        taskCreatedAt = taskCreatedAtDecoded
        let startedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .startedAt)
        startedAt = startedAtDecoded
        let startedByDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .startedBy)
        startedBy = startedByDecoded
        let tagsContainer = try containerValues.decodeIfPresent([GuardDutyClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[GuardDutyClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [GuardDutyClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let volumesContainer = try containerValues.decodeIfPresent([GuardDutyClientTypes.Volume?].self, forKey: .volumes)
        var volumesDecoded0:[GuardDutyClientTypes.Volume]? = nil
        if let volumesContainer = volumesContainer {
            volumesDecoded0 = [GuardDutyClientTypes.Volume]()
            for structure0 in volumesContainer {
                if let structure0 = structure0 {
                    volumesDecoded0?.append(structure0)
                }
            }
        }
        volumes = volumesDecoded0
        let containersContainer = try containerValues.decodeIfPresent([GuardDutyClientTypes.Container?].self, forKey: .containers)
        var containersDecoded0:[GuardDutyClientTypes.Container]? = nil
        if let containersContainer = containersContainer {
            containersDecoded0 = [GuardDutyClientTypes.Container]()
            for structure0 in containersContainer {
                if let structure0 = structure0 {
                    containersDecoded0?.append(structure0)
                }
            }
        }
        containers = containersDecoded0
        let groupDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .group)
        group = groupDecoded
    }
}

extension GuardDutyClientTypes {
    /// Contains information about the task in an ECS cluster.
    public struct EcsTaskDetails: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the task.
        public var arn: Swift.String?
        /// The containers that's associated with the task.
        public var containers: [GuardDutyClientTypes.Container]?
        /// The ARN of the task definition that creates the task.
        public var definitionArn: Swift.String?
        /// The name of the task group that's associated with the task.
        public var group: Swift.String?
        /// The Unix timestamp for the time when the task started.
        public var startedAt: ClientRuntime.Date?
        /// Contains the tag specified when a task is started.
        public var startedBy: Swift.String?
        /// The tags of the ECS Task.
        public var tags: [GuardDutyClientTypes.Tag]?
        /// The Unix timestamp for the time when the task was created.
        public var taskCreatedAt: ClientRuntime.Date?
        /// The version counter for the task.
        public var version: Swift.String?
        /// The list of data volume definitions for the task.
        public var volumes: [GuardDutyClientTypes.Volume]?

        public init (
            arn: Swift.String? = nil,
            containers: [GuardDutyClientTypes.Container]? = nil,
            definitionArn: Swift.String? = nil,
            group: Swift.String? = nil,
            startedAt: ClientRuntime.Date? = nil,
            startedBy: Swift.String? = nil,
            tags: [GuardDutyClientTypes.Tag]? = nil,
            taskCreatedAt: ClientRuntime.Date? = nil,
            version: Swift.String? = nil,
            volumes: [GuardDutyClientTypes.Volume]? = nil
        )
        {
            self.arn = arn
            self.containers = containers
            self.definitionArn = definitionArn
            self.group = group
            self.startedAt = startedAt
            self.startedBy = startedBy
            self.tags = tags
            self.taskCreatedAt = taskCreatedAt
            self.version = version
            self.volumes = volumes
        }
    }

}

extension GuardDutyClientTypes.EksClusterDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "arn"
        case createdAt = "createdAt"
        case name = "name"
        case status = "status"
        case tags = "tags"
        case vpcId = "vpcId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let vpcId = self.vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let tagsContainer = try containerValues.decodeIfPresent([GuardDutyClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[GuardDutyClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [GuardDutyClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
    }
}

extension GuardDutyClientTypes {
    /// Details about the EKS cluster involved in a Kubernetes finding.
    public struct EksClusterDetails: Swift.Equatable {
        /// EKS cluster ARN.
        public var arn: Swift.String?
        /// The timestamp when the EKS cluster was created.
        public var createdAt: ClientRuntime.Date?
        /// EKS cluster name.
        public var name: Swift.String?
        /// The EKS cluster status.
        public var status: Swift.String?
        /// The EKS cluster tags.
        public var tags: [GuardDutyClientTypes.Tag]?
        /// The VPC ID to which the EKS cluster is attached.
        public var vpcId: Swift.String?

        public init (
            arn: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            name: Swift.String? = nil,
            status: Swift.String? = nil,
            tags: [GuardDutyClientTypes.Tag]? = nil,
            vpcId: Swift.String? = nil
        )
        {
            self.arn = arn
            self.createdAt = createdAt
            self.name = name
            self.status = status
            self.tags = tags
            self.vpcId = vpcId
        }
    }

}

extension EnableOrganizationAdminAccountInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case adminAccountId = "adminAccountId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let adminAccountId = self.adminAccountId {
            try encodeContainer.encode(adminAccountId, forKey: .adminAccountId)
        }
    }
}

extension EnableOrganizationAdminAccountInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/admin/enable"
    }
}

public struct EnableOrganizationAdminAccountInput: Swift.Equatable {
    /// The Amazon Web Services Account ID for the organization account to be enabled as a GuardDuty delegated administrator.
    /// This member is required.
    public var adminAccountId: Swift.String?

    public init (
        adminAccountId: Swift.String? = nil
    )
    {
        self.adminAccountId = adminAccountId
    }
}

struct EnableOrganizationAdminAccountInputBody: Swift.Equatable {
    let adminAccountId: Swift.String?
}

extension EnableOrganizationAdminAccountInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case adminAccountId = "adminAccountId"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let adminAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .adminAccountId)
        adminAccountId = adminAccountIdDecoded
    }
}

extension EnableOrganizationAdminAccountOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension EnableOrganizationAdminAccountOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum EnableOrganizationAdminAccountOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension EnableOrganizationAdminAccountOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct EnableOrganizationAdminAccountOutputResponse: Swift.Equatable {

    public init () { }
}

extension GuardDutyClientTypes.Evidence: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case threatIntelligenceDetails = "threatIntelligenceDetails"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let threatIntelligenceDetails = threatIntelligenceDetails {
            var threatIntelligenceDetailsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .threatIntelligenceDetails)
            for threatintelligencedetail0 in threatIntelligenceDetails {
                try threatIntelligenceDetailsContainer.encode(threatintelligencedetail0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let threatIntelligenceDetailsContainer = try containerValues.decodeIfPresent([GuardDutyClientTypes.ThreatIntelligenceDetail?].self, forKey: .threatIntelligenceDetails)
        var threatIntelligenceDetailsDecoded0:[GuardDutyClientTypes.ThreatIntelligenceDetail]? = nil
        if let threatIntelligenceDetailsContainer = threatIntelligenceDetailsContainer {
            threatIntelligenceDetailsDecoded0 = [GuardDutyClientTypes.ThreatIntelligenceDetail]()
            for structure0 in threatIntelligenceDetailsContainer {
                if let structure0 = structure0 {
                    threatIntelligenceDetailsDecoded0?.append(structure0)
                }
            }
        }
        threatIntelligenceDetails = threatIntelligenceDetailsDecoded0
    }
}

extension GuardDutyClientTypes {
    /// Contains information about the reason that the finding was generated.
    public struct Evidence: Swift.Equatable {
        /// A list of threat intelligence details related to the evidence.
        public var threatIntelligenceDetails: [GuardDutyClientTypes.ThreatIntelligenceDetail]?

        public init (
            threatIntelligenceDetails: [GuardDutyClientTypes.ThreatIntelligenceDetail]? = nil
        )
        {
            self.threatIntelligenceDetails = threatIntelligenceDetails
        }
    }

}

extension GuardDutyClientTypes {
    public enum Feedback: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case notUseful
        case useful
        case sdkUnknown(Swift.String)

        public static var allCases: [Feedback] {
            return [
                .notUseful,
                .useful,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .notUseful: return "NOT_USEFUL"
            case .useful: return "USEFUL"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = Feedback(rawValue: rawValue) ?? Feedback.sdkUnknown(rawValue)
        }
    }
}

extension GuardDutyClientTypes {
    public enum FilterAction: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case archive
        case noop
        case sdkUnknown(Swift.String)

        public static var allCases: [FilterAction] {
            return [
                .archive,
                .noop,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .archive: return "ARCHIVE"
            case .noop: return "NOOP"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FilterAction(rawValue: rawValue) ?? FilterAction.sdkUnknown(rawValue)
        }
    }
}

extension GuardDutyClientTypes.FilterCondition: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case equalsValue = "equalsValue"
        case greaterThan = "greaterThan"
        case lessThan = "lessThan"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let equalsValue = self.equalsValue {
            try encodeContainer.encode(equalsValue, forKey: .equalsValue)
        }
        if greaterThan != 0 {
            try encodeContainer.encode(greaterThan, forKey: .greaterThan)
        }
        if lessThan != 0 {
            try encodeContainer.encode(lessThan, forKey: .lessThan)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let equalsValueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .equalsValue)
        equalsValue = equalsValueDecoded
        let greaterThanDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .greaterThan) ?? 0
        greaterThan = greaterThanDecoded
        let lessThanDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .lessThan) ?? 0
        lessThan = lessThanDecoded
    }
}

extension GuardDutyClientTypes {
    /// Contains information about the condition.
    public struct FilterCondition: Swift.Equatable {
        /// Represents an equal condition to be applied to a single field when querying for scan entries.
        public var equalsValue: Swift.String?
        /// Represents a greater than condition to be applied to a single field when querying for scan entries.
        public var greaterThan: Swift.Int
        /// Represents a less than condition to be applied to a single field when querying for scan entries.
        public var lessThan: Swift.Int

        public init (
            equalsValue: Swift.String? = nil,
            greaterThan: Swift.Int = 0,
            lessThan: Swift.Int = 0
        )
        {
            self.equalsValue = equalsValue
            self.greaterThan = greaterThan
            self.lessThan = lessThan
        }
    }

}

extension GuardDutyClientTypes.FilterCriteria: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filterCriterion = "filterCriterion"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filterCriterion = filterCriterion {
            var filterCriterionContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filterCriterion)
            for filtercriterion0 in filterCriterion {
                try filterCriterionContainer.encode(filtercriterion0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filterCriterionContainer = try containerValues.decodeIfPresent([GuardDutyClientTypes.FilterCriterion?].self, forKey: .filterCriterion)
        var filterCriterionDecoded0:[GuardDutyClientTypes.FilterCriterion]? = nil
        if let filterCriterionContainer = filterCriterionContainer {
            filterCriterionDecoded0 = [GuardDutyClientTypes.FilterCriterion]()
            for structure0 in filterCriterionContainer {
                if let structure0 = structure0 {
                    filterCriterionDecoded0?.append(structure0)
                }
            }
        }
        filterCriterion = filterCriterionDecoded0
    }
}

extension GuardDutyClientTypes {
    /// Represents the criteria to be used in the filter for describing scan entries.
    public struct FilterCriteria: Swift.Equatable {
        /// Represents a condition that when matched will be added to the response of the operation.
        public var filterCriterion: [GuardDutyClientTypes.FilterCriterion]?

        public init (
            filterCriterion: [GuardDutyClientTypes.FilterCriterion]? = nil
        )
        {
            self.filterCriterion = filterCriterion
        }
    }

}

extension GuardDutyClientTypes.FilterCriterion: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case criterionKey = "criterionKey"
        case filterCondition = "filterCondition"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let criterionKey = self.criterionKey {
            try encodeContainer.encode(criterionKey.rawValue, forKey: .criterionKey)
        }
        if let filterCondition = self.filterCondition {
            try encodeContainer.encode(filterCondition, forKey: .filterCondition)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let criterionKeyDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.CriterionKey.self, forKey: .criterionKey)
        criterionKey = criterionKeyDecoded
        let filterConditionDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.FilterCondition.self, forKey: .filterCondition)
        filterCondition = filterConditionDecoded
    }
}

extension GuardDutyClientTypes {
    /// Represents a condition that when matched will be added to the response of the operation. Irrespective of using any filter criteria, an administrator account can view the scan entries for all of its member accounts. However, each member account can view the scan entries only for their own account.
    public struct FilterCriterion: Swift.Equatable {
        /// An enum value representing possible scan properties to match with given scan entries.
        public var criterionKey: GuardDutyClientTypes.CriterionKey?
        /// Contains information about the condition.
        public var filterCondition: GuardDutyClientTypes.FilterCondition?

        public init (
            criterionKey: GuardDutyClientTypes.CriterionKey? = nil,
            filterCondition: GuardDutyClientTypes.FilterCondition? = nil
        )
        {
            self.criterionKey = criterionKey
            self.filterCondition = filterCondition
        }
    }

}

extension GuardDutyClientTypes.Finding: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "accountId"
        case arn = "arn"
        case confidence = "confidence"
        case createdAt = "createdAt"
        case description = "description"
        case id = "id"
        case partition = "partition"
        case region = "region"
        case resource = "resource"
        case schemaVersion = "schemaVersion"
        case service = "service"
        case severity = "severity"
        case title = "title"
        case type = "type"
        case updatedAt = "updatedAt"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if confidence != 0.0 {
            try encodeContainer.encode(confidence, forKey: .confidence)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encode(createdAt, forKey: .createdAt)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let partition = self.partition {
            try encodeContainer.encode(partition, forKey: .partition)
        }
        if let region = self.region {
            try encodeContainer.encode(region, forKey: .region)
        }
        if let resource = self.resource {
            try encodeContainer.encode(resource, forKey: .resource)
        }
        if let schemaVersion = self.schemaVersion {
            try encodeContainer.encode(schemaVersion, forKey: .schemaVersion)
        }
        if let service = self.service {
            try encodeContainer.encode(service, forKey: .service)
        }
        if severity != 0.0 {
            try encodeContainer.encode(severity, forKey: .severity)
        }
        if let title = self.title {
            try encodeContainer.encode(title, forKey: .title)
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
        if let updatedAt = self.updatedAt {
            try encodeContainer.encode(updatedAt, forKey: .updatedAt)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let confidenceDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .confidence) ?? 0.0
        confidence = confidenceDecoded
        let createdAtDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let partitionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .partition)
        partition = partitionDecoded
        let regionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .region)
        region = regionDecoded
        let resourceDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.Resource.self, forKey: .resource)
        resource = resourceDecoded
        let schemaVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .schemaVersion)
        schemaVersion = schemaVersionDecoded
        let serviceDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.Service.self, forKey: .service)
        service = serviceDecoded
        let severityDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .severity) ?? 0.0
        severity = severityDecoded
        let titleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .title)
        title = titleDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let updatedAtDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
    }
}

extension GuardDutyClientTypes {
    /// Contains information about the finding, which is generated when abnormal or suspicious activity is detected.
    public struct Finding: Swift.Equatable {
        /// The ID of the account in which the finding was generated.
        /// This member is required.
        public var accountId: Swift.String?
        /// The ARN of the finding.
        /// This member is required.
        public var arn: Swift.String?
        /// The confidence score for the finding.
        public var confidence: Swift.Double
        /// The time and date when the finding was created.
        /// This member is required.
        public var createdAt: Swift.String?
        /// The description of the finding.
        public var description: Swift.String?
        /// The ID of the finding.
        /// This member is required.
        public var id: Swift.String?
        /// The partition associated with the finding.
        public var partition: Swift.String?
        /// The Region where the finding was generated.
        /// This member is required.
        public var region: Swift.String?
        /// Contains information about the Amazon Web Services resource associated with the activity that prompted GuardDuty to generate a finding.
        /// This member is required.
        public var resource: GuardDutyClientTypes.Resource?
        /// The version of the schema used for the finding.
        /// This member is required.
        public var schemaVersion: Swift.String?
        /// Contains additional information about the generated finding.
        public var service: GuardDutyClientTypes.Service?
        /// The severity of the finding.
        /// This member is required.
        public var severity: Swift.Double
        /// The title of the finding.
        public var title: Swift.String?
        /// The type of finding.
        /// This member is required.
        public var type: Swift.String?
        /// The time and date when the finding was last updated.
        /// This member is required.
        public var updatedAt: Swift.String?

        public init (
            accountId: Swift.String? = nil,
            arn: Swift.String? = nil,
            confidence: Swift.Double = 0.0,
            createdAt: Swift.String? = nil,
            description: Swift.String? = nil,
            id: Swift.String? = nil,
            partition: Swift.String? = nil,
            region: Swift.String? = nil,
            resource: GuardDutyClientTypes.Resource? = nil,
            schemaVersion: Swift.String? = nil,
            service: GuardDutyClientTypes.Service? = nil,
            severity: Swift.Double = 0.0,
            title: Swift.String? = nil,
            type: Swift.String? = nil,
            updatedAt: Swift.String? = nil
        )
        {
            self.accountId = accountId
            self.arn = arn
            self.confidence = confidence
            self.createdAt = createdAt
            self.description = description
            self.id = id
            self.partition = partition
            self.region = region
            self.resource = resource
            self.schemaVersion = schemaVersion
            self.service = service
            self.severity = severity
            self.title = title
            self.type = type
            self.updatedAt = updatedAt
        }
    }

}

extension GuardDutyClientTypes.FindingCriteria: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case criterion = "criterion"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let criterion = criterion {
            var criterionContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .criterion)
            for (dictKey0, criterion0) in criterion {
                try criterionContainer.encode(criterion0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let criterionContainer = try containerValues.decodeIfPresent([Swift.String: GuardDutyClientTypes.Condition?].self, forKey: .criterion)
        var criterionDecoded0: [Swift.String:GuardDutyClientTypes.Condition]? = nil
        if let criterionContainer = criterionContainer {
            criterionDecoded0 = [Swift.String:GuardDutyClientTypes.Condition]()
            for (key0, condition0) in criterionContainer {
                if let condition0 = condition0 {
                    criterionDecoded0?[key0] = condition0
                }
            }
        }
        criterion = criterionDecoded0
    }
}

extension GuardDutyClientTypes {
    /// Contains information about the criteria used for querying findings.
    public struct FindingCriteria: Swift.Equatable {
        /// Represents a map of finding properties that match specified conditions and values when querying findings.
        public var criterion: [Swift.String:GuardDutyClientTypes.Condition]?

        public init (
            criterion: [Swift.String:GuardDutyClientTypes.Condition]? = nil
        )
        {
            self.criterion = criterion
        }
    }

}

extension GuardDutyClientTypes {
    public enum FindingPublishingFrequency: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case fifteenMinutes
        case oneHour
        case sixHours
        case sdkUnknown(Swift.String)

        public static var allCases: [FindingPublishingFrequency] {
            return [
                .fifteenMinutes,
                .oneHour,
                .sixHours,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .fifteenMinutes: return "FIFTEEN_MINUTES"
            case .oneHour: return "ONE_HOUR"
            case .sixHours: return "SIX_HOURS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FindingPublishingFrequency(rawValue: rawValue) ?? FindingPublishingFrequency.sdkUnknown(rawValue)
        }
    }
}

extension GuardDutyClientTypes {
    public enum FindingStatisticType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case countBySeverity
        case sdkUnknown(Swift.String)

        public static var allCases: [FindingStatisticType] {
            return [
                .countBySeverity,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .countBySeverity: return "COUNT_BY_SEVERITY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FindingStatisticType(rawValue: rawValue) ?? FindingStatisticType.sdkUnknown(rawValue)
        }
    }
}

extension GuardDutyClientTypes.FindingStatistics: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case countBySeverity = "countBySeverity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let countBySeverity = countBySeverity {
            var countBySeverityContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .countBySeverity)
            for (dictKey0, countBySeverity0) in countBySeverity {
                try countBySeverityContainer.encode(countBySeverity0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let countBySeverityContainer = try containerValues.decodeIfPresent([Swift.String: Swift.Int?].self, forKey: .countBySeverity)
        var countBySeverityDecoded0: [Swift.String:Swift.Int]? = nil
        if let countBySeverityContainer = countBySeverityContainer {
            countBySeverityDecoded0 = [Swift.String:Swift.Int]()
            for (key0, integer0) in countBySeverityContainer {
                if let integer0 = integer0 {
                    countBySeverityDecoded0?[key0] = integer0
                }
            }
        }
        countBySeverity = countBySeverityDecoded0
    }
}

extension GuardDutyClientTypes {
    /// Contains information about finding statistics.
    public struct FindingStatistics: Swift.Equatable {
        /// Represents a map of severity to count statistics for a set of findings.
        public var countBySeverity: [Swift.String:Swift.Int]?

        public init (
            countBySeverity: [Swift.String:Swift.Int]? = nil
        )
        {
            self.countBySeverity = countBySeverity
        }
    }

}

extension GuardDutyClientTypes.FlowLogsConfigurationResult: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status = "status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.DataSourceStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension GuardDutyClientTypes {
    /// Contains information on the status of VPC flow logs as a data source.
    public struct FlowLogsConfigurationResult: Swift.Equatable {
        /// Denotes whether VPC flow logs is enabled as a data source.
        /// This member is required.
        public var status: GuardDutyClientTypes.DataSourceStatus?

        public init (
            status: GuardDutyClientTypes.DataSourceStatus? = nil
        )
        {
            self.status = status
        }
    }

}

extension GuardDutyClientTypes.GeoLocation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lat = "lat"
        case lon = "lon"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if lat != 0.0 {
            try encodeContainer.encode(lat, forKey: .lat)
        }
        if lon != 0.0 {
            try encodeContainer.encode(lon, forKey: .lon)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let latDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .lat) ?? 0.0
        lat = latDecoded
        let lonDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .lon) ?? 0.0
        lon = lonDecoded
    }
}

extension GuardDutyClientTypes {
    /// Contains information about the location of the remote IP address.
    public struct GeoLocation: Swift.Equatable {
        /// The latitude information of the remote IP address.
        public var lat: Swift.Double
        /// The longitude information of the remote IP address.
        public var lon: Swift.Double

        public init (
            lat: Swift.Double = 0.0,
            lon: Swift.Double = 0.0
        )
        {
            self.lat = lat
            self.lon = lon
        }
    }

}

extension GetAdministratorAccountInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let detectorId = detectorId else {
            return nil
        }
        return "/detector/\(detectorId.urlPercentEncoding())/administrator"
    }
}

public struct GetAdministratorAccountInput: Swift.Equatable {
    /// The unique ID of the detector of the GuardDuty member account.
    /// This member is required.
    public var detectorId: Swift.String?

    public init (
        detectorId: Swift.String? = nil
    )
    {
        self.detectorId = detectorId
    }
}

struct GetAdministratorAccountInputBody: Swift.Equatable {
}

extension GetAdministratorAccountInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetAdministratorAccountOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetAdministratorAccountOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetAdministratorAccountOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetAdministratorAccountOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetAdministratorAccountOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.administrator = output.administrator
        } else {
            self.administrator = nil
        }
    }
}

public struct GetAdministratorAccountOutputResponse: Swift.Equatable {
    /// The administrator account details.
    /// This member is required.
    public var administrator: GuardDutyClientTypes.Administrator?

    public init (
        administrator: GuardDutyClientTypes.Administrator? = nil
    )
    {
        self.administrator = administrator
    }
}

struct GetAdministratorAccountOutputResponseBody: Swift.Equatable {
    let administrator: GuardDutyClientTypes.Administrator?
}

extension GetAdministratorAccountOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case administrator = "administrator"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let administratorDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.Administrator.self, forKey: .administrator)
        administrator = administratorDecoded
    }
}

extension GetDetectorInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let detectorId = detectorId else {
            return nil
        }
        return "/detector/\(detectorId.urlPercentEncoding())"
    }
}

public struct GetDetectorInput: Swift.Equatable {
    /// The unique ID of the detector that you want to get.
    /// This member is required.
    public var detectorId: Swift.String?

    public init (
        detectorId: Swift.String? = nil
    )
    {
        self.detectorId = detectorId
    }
}

struct GetDetectorInputBody: Swift.Equatable {
}

extension GetDetectorInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetDetectorOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetDetectorOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetDetectorOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetDetectorOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetDetectorOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.createdAt = output.createdAt
            self.dataSources = output.dataSources
            self.findingPublishingFrequency = output.findingPublishingFrequency
            self.serviceRole = output.serviceRole
            self.status = output.status
            self.tags = output.tags
            self.updatedAt = output.updatedAt
        } else {
            self.createdAt = nil
            self.dataSources = nil
            self.findingPublishingFrequency = nil
            self.serviceRole = nil
            self.status = nil
            self.tags = nil
            self.updatedAt = nil
        }
    }
}

public struct GetDetectorOutputResponse: Swift.Equatable {
    /// The timestamp of when the detector was created.
    public var createdAt: Swift.String?
    /// Describes which data sources are enabled for the detector.
    public var dataSources: GuardDutyClientTypes.DataSourceConfigurationsResult?
    /// The publishing frequency of the finding.
    public var findingPublishingFrequency: GuardDutyClientTypes.FindingPublishingFrequency?
    /// The GuardDuty service role.
    /// This member is required.
    public var serviceRole: Swift.String?
    /// The detector status.
    /// This member is required.
    public var status: GuardDutyClientTypes.DetectorStatus?
    /// The tags of the detector resource.
    public var tags: [Swift.String:Swift.String]?
    /// The last-updated timestamp for the detector.
    public var updatedAt: Swift.String?

    public init (
        createdAt: Swift.String? = nil,
        dataSources: GuardDutyClientTypes.DataSourceConfigurationsResult? = nil,
        findingPublishingFrequency: GuardDutyClientTypes.FindingPublishingFrequency? = nil,
        serviceRole: Swift.String? = nil,
        status: GuardDutyClientTypes.DetectorStatus? = nil,
        tags: [Swift.String:Swift.String]? = nil,
        updatedAt: Swift.String? = nil
    )
    {
        self.createdAt = createdAt
        self.dataSources = dataSources
        self.findingPublishingFrequency = findingPublishingFrequency
        self.serviceRole = serviceRole
        self.status = status
        self.tags = tags
        self.updatedAt = updatedAt
    }
}

struct GetDetectorOutputResponseBody: Swift.Equatable {
    let createdAt: Swift.String?
    let findingPublishingFrequency: GuardDutyClientTypes.FindingPublishingFrequency?
    let serviceRole: Swift.String?
    let status: GuardDutyClientTypes.DetectorStatus?
    let updatedAt: Swift.String?
    let dataSources: GuardDutyClientTypes.DataSourceConfigurationsResult?
    let tags: [Swift.String:Swift.String]?
}

extension GetDetectorOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt = "createdAt"
        case dataSources = "dataSources"
        case findingPublishingFrequency = "findingPublishingFrequency"
        case serviceRole = "serviceRole"
        case status = "status"
        case tags = "tags"
        case updatedAt = "updatedAt"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let createdAtDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .createdAt)
        createdAt = createdAtDecoded
        let findingPublishingFrequencyDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.FindingPublishingFrequency.self, forKey: .findingPublishingFrequency)
        findingPublishingFrequency = findingPublishingFrequencyDecoded
        let serviceRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceRole)
        serviceRole = serviceRoleDecoded
        let statusDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.DetectorStatus.self, forKey: .status)
        status = statusDecoded
        let updatedAtDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let dataSourcesDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.DataSourceConfigurationsResult.self, forKey: .dataSources)
        dataSources = dataSourcesDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension GetFilterInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let detectorId = detectorId else {
            return nil
        }
        guard let filterName = filterName else {
            return nil
        }
        return "/detector/\(detectorId.urlPercentEncoding())/filter/\(filterName.urlPercentEncoding())"
    }
}

public struct GetFilterInput: Swift.Equatable {
    /// The unique ID of the detector that the filter is associated with.
    /// This member is required.
    public var detectorId: Swift.String?
    /// The name of the filter you want to get.
    /// This member is required.
    public var filterName: Swift.String?

    public init (
        detectorId: Swift.String? = nil,
        filterName: Swift.String? = nil
    )
    {
        self.detectorId = detectorId
        self.filterName = filterName
    }
}

struct GetFilterInputBody: Swift.Equatable {
}

extension GetFilterInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetFilterOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetFilterOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetFilterOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetFilterOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetFilterOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.action = output.action
            self.description = output.description
            self.findingCriteria = output.findingCriteria
            self.name = output.name
            self.rank = output.rank
            self.tags = output.tags
        } else {
            self.action = nil
            self.description = nil
            self.findingCriteria = nil
            self.name = nil
            self.rank = 0
            self.tags = nil
        }
    }
}

public struct GetFilterOutputResponse: Swift.Equatable {
    /// Specifies the action that is to be applied to the findings that match the filter.
    /// This member is required.
    public var action: GuardDutyClientTypes.FilterAction?
    /// The description of the filter.
    public var description: Swift.String?
    /// Represents the criteria to be used in the filter for querying findings.
    /// This member is required.
    public var findingCriteria: GuardDutyClientTypes.FindingCriteria?
    /// The name of the filter.
    /// This member is required.
    public var name: Swift.String?
    /// Specifies the position of the filter in the list of current filters. Also specifies the order in which this filter is applied to the findings.
    public var rank: Swift.Int
    /// The tags of the filter resource.
    public var tags: [Swift.String:Swift.String]?

    public init (
        action: GuardDutyClientTypes.FilterAction? = nil,
        description: Swift.String? = nil,
        findingCriteria: GuardDutyClientTypes.FindingCriteria? = nil,
        name: Swift.String? = nil,
        rank: Swift.Int = 0,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.action = action
        self.description = description
        self.findingCriteria = findingCriteria
        self.name = name
        self.rank = rank
        self.tags = tags
    }
}

struct GetFilterOutputResponseBody: Swift.Equatable {
    let name: Swift.String?
    let description: Swift.String?
    let action: GuardDutyClientTypes.FilterAction?
    let rank: Swift.Int
    let findingCriteria: GuardDutyClientTypes.FindingCriteria?
    let tags: [Swift.String:Swift.String]?
}

extension GetFilterOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action = "action"
        case description = "description"
        case findingCriteria = "findingCriteria"
        case name = "name"
        case rank = "rank"
        case tags = "tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let actionDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.FilterAction.self, forKey: .action)
        action = actionDecoded
        let rankDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .rank) ?? 0
        rank = rankDecoded
        let findingCriteriaDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.FindingCriteria.self, forKey: .findingCriteria)
        findingCriteria = findingCriteriaDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension GetFindingsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case findingIds = "findingIds"
        case sortCriteria = "sortCriteria"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let findingIds = findingIds {
            var findingIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .findingIds)
            for findingid0 in findingIds {
                try findingIdsContainer.encode(findingid0)
            }
        }
        if let sortCriteria = self.sortCriteria {
            try encodeContainer.encode(sortCriteria, forKey: .sortCriteria)
        }
    }
}

extension GetFindingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let detectorId = detectorId else {
            return nil
        }
        return "/detector/\(detectorId.urlPercentEncoding())/findings/get"
    }
}

public struct GetFindingsInput: Swift.Equatable {
    /// The ID of the detector that specifies the GuardDuty service whose findings you want to retrieve.
    /// This member is required.
    public var detectorId: Swift.String?
    /// The IDs of the findings that you want to retrieve.
    /// This member is required.
    public var findingIds: [Swift.String]?
    /// Represents the criteria used for sorting findings.
    public var sortCriteria: GuardDutyClientTypes.SortCriteria?

    public init (
        detectorId: Swift.String? = nil,
        findingIds: [Swift.String]? = nil,
        sortCriteria: GuardDutyClientTypes.SortCriteria? = nil
    )
    {
        self.detectorId = detectorId
        self.findingIds = findingIds
        self.sortCriteria = sortCriteria
    }
}

struct GetFindingsInputBody: Swift.Equatable {
    let findingIds: [Swift.String]?
    let sortCriteria: GuardDutyClientTypes.SortCriteria?
}

extension GetFindingsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case findingIds = "findingIds"
        case sortCriteria = "sortCriteria"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let findingIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .findingIds)
        var findingIdsDecoded0:[Swift.String]? = nil
        if let findingIdsContainer = findingIdsContainer {
            findingIdsDecoded0 = [Swift.String]()
            for string0 in findingIdsContainer {
                if let string0 = string0 {
                    findingIdsDecoded0?.append(string0)
                }
            }
        }
        findingIds = findingIdsDecoded0
        let sortCriteriaDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.SortCriteria.self, forKey: .sortCriteria)
        sortCriteria = sortCriteriaDecoded
    }
}

extension GetFindingsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetFindingsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetFindingsOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetFindingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetFindingsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.findings = output.findings
        } else {
            self.findings = nil
        }
    }
}

public struct GetFindingsOutputResponse: Swift.Equatable {
    /// A list of findings.
    /// This member is required.
    public var findings: [GuardDutyClientTypes.Finding]?

    public init (
        findings: [GuardDutyClientTypes.Finding]? = nil
    )
    {
        self.findings = findings
    }
}

struct GetFindingsOutputResponseBody: Swift.Equatable {
    let findings: [GuardDutyClientTypes.Finding]?
}

extension GetFindingsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case findings = "findings"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let findingsContainer = try containerValues.decodeIfPresent([GuardDutyClientTypes.Finding?].self, forKey: .findings)
        var findingsDecoded0:[GuardDutyClientTypes.Finding]? = nil
        if let findingsContainer = findingsContainer {
            findingsDecoded0 = [GuardDutyClientTypes.Finding]()
            for structure0 in findingsContainer {
                if let structure0 = structure0 {
                    findingsDecoded0?.append(structure0)
                }
            }
        }
        findings = findingsDecoded0
    }
}

extension GetFindingsStatisticsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case findingCriteria = "findingCriteria"
        case findingStatisticTypes = "findingStatisticTypes"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let findingCriteria = self.findingCriteria {
            try encodeContainer.encode(findingCriteria, forKey: .findingCriteria)
        }
        if let findingStatisticTypes = findingStatisticTypes {
            var findingStatisticTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .findingStatisticTypes)
            for findingstatistictype0 in findingStatisticTypes {
                try findingStatisticTypesContainer.encode(findingstatistictype0.rawValue)
            }
        }
    }
}

extension GetFindingsStatisticsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let detectorId = detectorId else {
            return nil
        }
        return "/detector/\(detectorId.urlPercentEncoding())/findings/statistics"
    }
}

public struct GetFindingsStatisticsInput: Swift.Equatable {
    /// The ID of the detector that specifies the GuardDuty service whose findings' statistics you want to retrieve.
    /// This member is required.
    public var detectorId: Swift.String?
    /// Represents the criteria that is used for querying findings.
    public var findingCriteria: GuardDutyClientTypes.FindingCriteria?
    /// The types of finding statistics to retrieve.
    /// This member is required.
    public var findingStatisticTypes: [GuardDutyClientTypes.FindingStatisticType]?

    public init (
        detectorId: Swift.String? = nil,
        findingCriteria: GuardDutyClientTypes.FindingCriteria? = nil,
        findingStatisticTypes: [GuardDutyClientTypes.FindingStatisticType]? = nil
    )
    {
        self.detectorId = detectorId
        self.findingCriteria = findingCriteria
        self.findingStatisticTypes = findingStatisticTypes
    }
}

struct GetFindingsStatisticsInputBody: Swift.Equatable {
    let findingStatisticTypes: [GuardDutyClientTypes.FindingStatisticType]?
    let findingCriteria: GuardDutyClientTypes.FindingCriteria?
}

extension GetFindingsStatisticsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case findingCriteria = "findingCriteria"
        case findingStatisticTypes = "findingStatisticTypes"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let findingStatisticTypesContainer = try containerValues.decodeIfPresent([GuardDutyClientTypes.FindingStatisticType?].self, forKey: .findingStatisticTypes)
        var findingStatisticTypesDecoded0:[GuardDutyClientTypes.FindingStatisticType]? = nil
        if let findingStatisticTypesContainer = findingStatisticTypesContainer {
            findingStatisticTypesDecoded0 = [GuardDutyClientTypes.FindingStatisticType]()
            for enum0 in findingStatisticTypesContainer {
                if let enum0 = enum0 {
                    findingStatisticTypesDecoded0?.append(enum0)
                }
            }
        }
        findingStatisticTypes = findingStatisticTypesDecoded0
        let findingCriteriaDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.FindingCriteria.self, forKey: .findingCriteria)
        findingCriteria = findingCriteriaDecoded
    }
}

extension GetFindingsStatisticsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetFindingsStatisticsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetFindingsStatisticsOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetFindingsStatisticsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetFindingsStatisticsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.findingStatistics = output.findingStatistics
        } else {
            self.findingStatistics = nil
        }
    }
}

public struct GetFindingsStatisticsOutputResponse: Swift.Equatable {
    /// The finding statistics object.
    /// This member is required.
    public var findingStatistics: GuardDutyClientTypes.FindingStatistics?

    public init (
        findingStatistics: GuardDutyClientTypes.FindingStatistics? = nil
    )
    {
        self.findingStatistics = findingStatistics
    }
}

struct GetFindingsStatisticsOutputResponseBody: Swift.Equatable {
    let findingStatistics: GuardDutyClientTypes.FindingStatistics?
}

extension GetFindingsStatisticsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case findingStatistics = "findingStatistics"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let findingStatisticsDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.FindingStatistics.self, forKey: .findingStatistics)
        findingStatistics = findingStatisticsDecoded
    }
}

extension GetIPSetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let detectorId = detectorId else {
            return nil
        }
        guard let ipSetId = ipSetId else {
            return nil
        }
        return "/detector/\(detectorId.urlPercentEncoding())/ipset/\(ipSetId.urlPercentEncoding())"
    }
}

public struct GetIPSetInput: Swift.Equatable {
    /// The unique ID of the detector that the IPSet is associated with.
    /// This member is required.
    public var detectorId: Swift.String?
    /// The unique ID of the IPSet to retrieve.
    /// This member is required.
    public var ipSetId: Swift.String?

    public init (
        detectorId: Swift.String? = nil,
        ipSetId: Swift.String? = nil
    )
    {
        self.detectorId = detectorId
        self.ipSetId = ipSetId
    }
}

struct GetIPSetInputBody: Swift.Equatable {
}

extension GetIPSetInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetIPSetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetIPSetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetIPSetOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetIPSetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetIPSetOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.format = output.format
            self.location = output.location
            self.name = output.name
            self.status = output.status
            self.tags = output.tags
        } else {
            self.format = nil
            self.location = nil
            self.name = nil
            self.status = nil
            self.tags = nil
        }
    }
}

public struct GetIPSetOutputResponse: Swift.Equatable {
    /// The format of the file that contains the IPSet.
    /// This member is required.
    public var format: GuardDutyClientTypes.IpSetFormat?
    /// The URI of the file that contains the IPSet.
    /// This member is required.
    public var location: Swift.String?
    /// The user-friendly name for the IPSet.
    /// This member is required.
    public var name: Swift.String?
    /// The status of IPSet file that was uploaded.
    /// This member is required.
    public var status: GuardDutyClientTypes.IpSetStatus?
    /// The tags of the IPSet resource.
    public var tags: [Swift.String:Swift.String]?

    public init (
        format: GuardDutyClientTypes.IpSetFormat? = nil,
        location: Swift.String? = nil,
        name: Swift.String? = nil,
        status: GuardDutyClientTypes.IpSetStatus? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.format = format
        self.location = location
        self.name = name
        self.status = status
        self.tags = tags
    }
}

struct GetIPSetOutputResponseBody: Swift.Equatable {
    let name: Swift.String?
    let format: GuardDutyClientTypes.IpSetFormat?
    let location: Swift.String?
    let status: GuardDutyClientTypes.IpSetStatus?
    let tags: [Swift.String:Swift.String]?
}

extension GetIPSetOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case format = "format"
        case location = "location"
        case name = "name"
        case status = "status"
        case tags = "tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let formatDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.IpSetFormat.self, forKey: .format)
        format = formatDecoded
        let locationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .location)
        location = locationDecoded
        let statusDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.IpSetStatus.self, forKey: .status)
        status = statusDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension GetInvitationsCountInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/invitation/count"
    }
}

public struct GetInvitationsCountInput: Swift.Equatable {

    public init () { }
}

struct GetInvitationsCountInputBody: Swift.Equatable {
}

extension GetInvitationsCountInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetInvitationsCountOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetInvitationsCountOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetInvitationsCountOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetInvitationsCountOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetInvitationsCountOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.invitationsCount = output.invitationsCount
        } else {
            self.invitationsCount = 0
        }
    }
}

public struct GetInvitationsCountOutputResponse: Swift.Equatable {
    /// The number of received invitations.
    public var invitationsCount: Swift.Int

    public init (
        invitationsCount: Swift.Int = 0
    )
    {
        self.invitationsCount = invitationsCount
    }
}

struct GetInvitationsCountOutputResponseBody: Swift.Equatable {
    let invitationsCount: Swift.Int
}

extension GetInvitationsCountOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case invitationsCount = "invitationsCount"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let invitationsCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .invitationsCount) ?? 0
        invitationsCount = invitationsCountDecoded
    }
}

extension GetMalwareScanSettingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let detectorId = detectorId else {
            return nil
        }
        return "/detector/\(detectorId.urlPercentEncoding())/malware-scan-settings"
    }
}

public struct GetMalwareScanSettingsInput: Swift.Equatable {
    /// The unique ID of the detector that the scan setting is associated with.
    /// This member is required.
    public var detectorId: Swift.String?

    public init (
        detectorId: Swift.String? = nil
    )
    {
        self.detectorId = detectorId
    }
}

struct GetMalwareScanSettingsInputBody: Swift.Equatable {
}

extension GetMalwareScanSettingsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetMalwareScanSettingsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetMalwareScanSettingsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetMalwareScanSettingsOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetMalwareScanSettingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetMalwareScanSettingsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.ebsSnapshotPreservation = output.ebsSnapshotPreservation
            self.scanResourceCriteria = output.scanResourceCriteria
        } else {
            self.ebsSnapshotPreservation = nil
            self.scanResourceCriteria = nil
        }
    }
}

public struct GetMalwareScanSettingsOutputResponse: Swift.Equatable {
    /// An enum value representing possible snapshot preservation settings.
    public var ebsSnapshotPreservation: GuardDutyClientTypes.EbsSnapshotPreservation?
    /// Represents the criteria to be used in the filter for scanning resources.
    public var scanResourceCriteria: GuardDutyClientTypes.ScanResourceCriteria?

    public init (
        ebsSnapshotPreservation: GuardDutyClientTypes.EbsSnapshotPreservation? = nil,
        scanResourceCriteria: GuardDutyClientTypes.ScanResourceCriteria? = nil
    )
    {
        self.ebsSnapshotPreservation = ebsSnapshotPreservation
        self.scanResourceCriteria = scanResourceCriteria
    }
}

struct GetMalwareScanSettingsOutputResponseBody: Swift.Equatable {
    let scanResourceCriteria: GuardDutyClientTypes.ScanResourceCriteria?
    let ebsSnapshotPreservation: GuardDutyClientTypes.EbsSnapshotPreservation?
}

extension GetMalwareScanSettingsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ebsSnapshotPreservation = "ebsSnapshotPreservation"
        case scanResourceCriteria = "scanResourceCriteria"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scanResourceCriteriaDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.ScanResourceCriteria.self, forKey: .scanResourceCriteria)
        scanResourceCriteria = scanResourceCriteriaDecoded
        let ebsSnapshotPreservationDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.EbsSnapshotPreservation.self, forKey: .ebsSnapshotPreservation)
        ebsSnapshotPreservation = ebsSnapshotPreservationDecoded
    }
}

extension GetMasterAccountInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let detectorId = detectorId else {
            return nil
        }
        return "/detector/\(detectorId.urlPercentEncoding())/master"
    }
}

@available(*, deprecated, message: "This input is deprecated, use GetAdministratorAccountRequest instead")
public struct GetMasterAccountInput: Swift.Equatable {
    /// The unique ID of the detector of the GuardDuty member account.
    /// This member is required.
    public var detectorId: Swift.String?

    public init (
        detectorId: Swift.String? = nil
    )
    {
        self.detectorId = detectorId
    }
}

struct GetMasterAccountInputBody: Swift.Equatable {
}

extension GetMasterAccountInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetMasterAccountOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetMasterAccountOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetMasterAccountOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetMasterAccountOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetMasterAccountOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.master = output.master
        } else {
            self.master = nil
        }
    }
}

@available(*, deprecated, message: "This output is deprecated, use GetAdministratorAccountResponse instead")
public struct GetMasterAccountOutputResponse: Swift.Equatable {
    /// The administrator account details.
    /// This member is required.
    public var master: GuardDutyClientTypes.Master?

    public init (
        master: GuardDutyClientTypes.Master? = nil
    )
    {
        self.master = master
    }
}

struct GetMasterAccountOutputResponseBody: Swift.Equatable {
    let master: GuardDutyClientTypes.Master?
}

extension GetMasterAccountOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case master = "master"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let masterDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.Master.self, forKey: .master)
        master = masterDecoded
    }
}

extension GetMemberDetectorsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountIds = "accountIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountIds = accountIds {
            var accountIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accountIds)
            for accountid0 in accountIds {
                try accountIdsContainer.encode(accountid0)
            }
        }
    }
}

extension GetMemberDetectorsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let detectorId = detectorId else {
            return nil
        }
        return "/detector/\(detectorId.urlPercentEncoding())/member/detector/get"
    }
}

public struct GetMemberDetectorsInput: Swift.Equatable {
    /// The account ID of the member account.
    /// This member is required.
    public var accountIds: [Swift.String]?
    /// The detector ID for the administrator account.
    /// This member is required.
    public var detectorId: Swift.String?

    public init (
        accountIds: [Swift.String]? = nil,
        detectorId: Swift.String? = nil
    )
    {
        self.accountIds = accountIds
        self.detectorId = detectorId
    }
}

struct GetMemberDetectorsInputBody: Swift.Equatable {
    let accountIds: [Swift.String]?
}

extension GetMemberDetectorsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountIds = "accountIds"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .accountIds)
        var accountIdsDecoded0:[Swift.String]? = nil
        if let accountIdsContainer = accountIdsContainer {
            accountIdsDecoded0 = [Swift.String]()
            for string0 in accountIdsContainer {
                if let string0 = string0 {
                    accountIdsDecoded0?.append(string0)
                }
            }
        }
        accountIds = accountIdsDecoded0
    }
}

extension GetMemberDetectorsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetMemberDetectorsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetMemberDetectorsOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetMemberDetectorsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetMemberDetectorsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.memberDataSourceConfigurations = output.memberDataSourceConfigurations
            self.unprocessedAccounts = output.unprocessedAccounts
        } else {
            self.memberDataSourceConfigurations = nil
            self.unprocessedAccounts = nil
        }
    }
}

public struct GetMemberDetectorsOutputResponse: Swift.Equatable {
    /// An object that describes which data sources are enabled for a member account.
    /// This member is required.
    public var memberDataSourceConfigurations: [GuardDutyClientTypes.MemberDataSourceConfiguration]?
    /// A list of member account IDs that were unable to be processed along with an explanation for why they were not processed.
    /// This member is required.
    public var unprocessedAccounts: [GuardDutyClientTypes.UnprocessedAccount]?

    public init (
        memberDataSourceConfigurations: [GuardDutyClientTypes.MemberDataSourceConfiguration]? = nil,
        unprocessedAccounts: [GuardDutyClientTypes.UnprocessedAccount]? = nil
    )
    {
        self.memberDataSourceConfigurations = memberDataSourceConfigurations
        self.unprocessedAccounts = unprocessedAccounts
    }
}

struct GetMemberDetectorsOutputResponseBody: Swift.Equatable {
    let memberDataSourceConfigurations: [GuardDutyClientTypes.MemberDataSourceConfiguration]?
    let unprocessedAccounts: [GuardDutyClientTypes.UnprocessedAccount]?
}

extension GetMemberDetectorsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case memberDataSourceConfigurations = "members"
        case unprocessedAccounts = "unprocessedAccounts"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let memberDataSourceConfigurationsContainer = try containerValues.decodeIfPresent([GuardDutyClientTypes.MemberDataSourceConfiguration?].self, forKey: .memberDataSourceConfigurations)
        var memberDataSourceConfigurationsDecoded0:[GuardDutyClientTypes.MemberDataSourceConfiguration]? = nil
        if let memberDataSourceConfigurationsContainer = memberDataSourceConfigurationsContainer {
            memberDataSourceConfigurationsDecoded0 = [GuardDutyClientTypes.MemberDataSourceConfiguration]()
            for structure0 in memberDataSourceConfigurationsContainer {
                if let structure0 = structure0 {
                    memberDataSourceConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        memberDataSourceConfigurations = memberDataSourceConfigurationsDecoded0
        let unprocessedAccountsContainer = try containerValues.decodeIfPresent([GuardDutyClientTypes.UnprocessedAccount?].self, forKey: .unprocessedAccounts)
        var unprocessedAccountsDecoded0:[GuardDutyClientTypes.UnprocessedAccount]? = nil
        if let unprocessedAccountsContainer = unprocessedAccountsContainer {
            unprocessedAccountsDecoded0 = [GuardDutyClientTypes.UnprocessedAccount]()
            for structure0 in unprocessedAccountsContainer {
                if let structure0 = structure0 {
                    unprocessedAccountsDecoded0?.append(structure0)
                }
            }
        }
        unprocessedAccounts = unprocessedAccountsDecoded0
    }
}

extension GetMembersInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountIds = "accountIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountIds = accountIds {
            var accountIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accountIds)
            for accountid0 in accountIds {
                try accountIdsContainer.encode(accountid0)
            }
        }
    }
}

extension GetMembersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let detectorId = detectorId else {
            return nil
        }
        return "/detector/\(detectorId.urlPercentEncoding())/member/get"
    }
}

public struct GetMembersInput: Swift.Equatable {
    /// A list of account IDs of the GuardDuty member accounts that you want to describe.
    /// This member is required.
    public var accountIds: [Swift.String]?
    /// The unique ID of the detector of the GuardDuty account whose members you want to retrieve.
    /// This member is required.
    public var detectorId: Swift.String?

    public init (
        accountIds: [Swift.String]? = nil,
        detectorId: Swift.String? = nil
    )
    {
        self.accountIds = accountIds
        self.detectorId = detectorId
    }
}

struct GetMembersInputBody: Swift.Equatable {
    let accountIds: [Swift.String]?
}

extension GetMembersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountIds = "accountIds"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .accountIds)
        var accountIdsDecoded0:[Swift.String]? = nil
        if let accountIdsContainer = accountIdsContainer {
            accountIdsDecoded0 = [Swift.String]()
            for string0 in accountIdsContainer {
                if let string0 = string0 {
                    accountIdsDecoded0?.append(string0)
                }
            }
        }
        accountIds = accountIdsDecoded0
    }
}

extension GetMembersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetMembersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetMembersOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetMembersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetMembersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.members = output.members
            self.unprocessedAccounts = output.unprocessedAccounts
        } else {
            self.members = nil
            self.unprocessedAccounts = nil
        }
    }
}

public struct GetMembersOutputResponse: Swift.Equatable {
    /// A list of members.
    /// This member is required.
    public var members: [GuardDutyClientTypes.Member]?
    /// A list of objects that contain the unprocessed account and a result string that explains why it was unprocessed.
    /// This member is required.
    public var unprocessedAccounts: [GuardDutyClientTypes.UnprocessedAccount]?

    public init (
        members: [GuardDutyClientTypes.Member]? = nil,
        unprocessedAccounts: [GuardDutyClientTypes.UnprocessedAccount]? = nil
    )
    {
        self.members = members
        self.unprocessedAccounts = unprocessedAccounts
    }
}

struct GetMembersOutputResponseBody: Swift.Equatable {
    let members: [GuardDutyClientTypes.Member]?
    let unprocessedAccounts: [GuardDutyClientTypes.UnprocessedAccount]?
}

extension GetMembersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case members = "members"
        case unprocessedAccounts = "unprocessedAccounts"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let membersContainer = try containerValues.decodeIfPresent([GuardDutyClientTypes.Member?].self, forKey: .members)
        var membersDecoded0:[GuardDutyClientTypes.Member]? = nil
        if let membersContainer = membersContainer {
            membersDecoded0 = [GuardDutyClientTypes.Member]()
            for structure0 in membersContainer {
                if let structure0 = structure0 {
                    membersDecoded0?.append(structure0)
                }
            }
        }
        members = membersDecoded0
        let unprocessedAccountsContainer = try containerValues.decodeIfPresent([GuardDutyClientTypes.UnprocessedAccount?].self, forKey: .unprocessedAccounts)
        var unprocessedAccountsDecoded0:[GuardDutyClientTypes.UnprocessedAccount]? = nil
        if let unprocessedAccountsContainer = unprocessedAccountsContainer {
            unprocessedAccountsDecoded0 = [GuardDutyClientTypes.UnprocessedAccount]()
            for structure0 in unprocessedAccountsContainer {
                if let structure0 = structure0 {
                    unprocessedAccountsDecoded0?.append(structure0)
                }
            }
        }
        unprocessedAccounts = unprocessedAccountsDecoded0
    }
}

extension GetRemainingFreeTrialDaysInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountIds = "accountIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountIds = accountIds {
            var accountIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accountIds)
            for accountid0 in accountIds {
                try accountIdsContainer.encode(accountid0)
            }
        }
    }
}

extension GetRemainingFreeTrialDaysInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let detectorId = detectorId else {
            return nil
        }
        return "/detector/\(detectorId.urlPercentEncoding())/freeTrial/daysRemaining"
    }
}

public struct GetRemainingFreeTrialDaysInput: Swift.Equatable {
    /// A list of account identifiers of the GuardDuty member account.
    public var accountIds: [Swift.String]?
    /// The unique ID of the detector of the GuardDuty member account.
    /// This member is required.
    public var detectorId: Swift.String?

    public init (
        accountIds: [Swift.String]? = nil,
        detectorId: Swift.String? = nil
    )
    {
        self.accountIds = accountIds
        self.detectorId = detectorId
    }
}

struct GetRemainingFreeTrialDaysInputBody: Swift.Equatable {
    let accountIds: [Swift.String]?
}

extension GetRemainingFreeTrialDaysInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountIds = "accountIds"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .accountIds)
        var accountIdsDecoded0:[Swift.String]? = nil
        if let accountIdsContainer = accountIdsContainer {
            accountIdsDecoded0 = [Swift.String]()
            for string0 in accountIdsContainer {
                if let string0 = string0 {
                    accountIdsDecoded0?.append(string0)
                }
            }
        }
        accountIds = accountIdsDecoded0
    }
}

extension GetRemainingFreeTrialDaysOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetRemainingFreeTrialDaysOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetRemainingFreeTrialDaysOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetRemainingFreeTrialDaysOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetRemainingFreeTrialDaysOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.accounts = output.accounts
            self.unprocessedAccounts = output.unprocessedAccounts
        } else {
            self.accounts = nil
            self.unprocessedAccounts = nil
        }
    }
}

public struct GetRemainingFreeTrialDaysOutputResponse: Swift.Equatable {
    /// The member accounts which were included in a request and were processed successfully.
    public var accounts: [GuardDutyClientTypes.AccountFreeTrialInfo]?
    /// The member account that was included in a request but for which the request could not be processed.
    public var unprocessedAccounts: [GuardDutyClientTypes.UnprocessedAccount]?

    public init (
        accounts: [GuardDutyClientTypes.AccountFreeTrialInfo]? = nil,
        unprocessedAccounts: [GuardDutyClientTypes.UnprocessedAccount]? = nil
    )
    {
        self.accounts = accounts
        self.unprocessedAccounts = unprocessedAccounts
    }
}

struct GetRemainingFreeTrialDaysOutputResponseBody: Swift.Equatable {
    let accounts: [GuardDutyClientTypes.AccountFreeTrialInfo]?
    let unprocessedAccounts: [GuardDutyClientTypes.UnprocessedAccount]?
}

extension GetRemainingFreeTrialDaysOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accounts = "accounts"
        case unprocessedAccounts = "unprocessedAccounts"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountsContainer = try containerValues.decodeIfPresent([GuardDutyClientTypes.AccountFreeTrialInfo?].self, forKey: .accounts)
        var accountsDecoded0:[GuardDutyClientTypes.AccountFreeTrialInfo]? = nil
        if let accountsContainer = accountsContainer {
            accountsDecoded0 = [GuardDutyClientTypes.AccountFreeTrialInfo]()
            for structure0 in accountsContainer {
                if let structure0 = structure0 {
                    accountsDecoded0?.append(structure0)
                }
            }
        }
        accounts = accountsDecoded0
        let unprocessedAccountsContainer = try containerValues.decodeIfPresent([GuardDutyClientTypes.UnprocessedAccount?].self, forKey: .unprocessedAccounts)
        var unprocessedAccountsDecoded0:[GuardDutyClientTypes.UnprocessedAccount]? = nil
        if let unprocessedAccountsContainer = unprocessedAccountsContainer {
            unprocessedAccountsDecoded0 = [GuardDutyClientTypes.UnprocessedAccount]()
            for structure0 in unprocessedAccountsContainer {
                if let structure0 = structure0 {
                    unprocessedAccountsDecoded0?.append(structure0)
                }
            }
        }
        unprocessedAccounts = unprocessedAccountsDecoded0
    }
}

extension GetThreatIntelSetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let detectorId = detectorId else {
            return nil
        }
        guard let threatIntelSetId = threatIntelSetId else {
            return nil
        }
        return "/detector/\(detectorId.urlPercentEncoding())/threatintelset/\(threatIntelSetId.urlPercentEncoding())"
    }
}

public struct GetThreatIntelSetInput: Swift.Equatable {
    /// The unique ID of the detector that the threatIntelSet is associated with.
    /// This member is required.
    public var detectorId: Swift.String?
    /// The unique ID of the threatIntelSet that you want to get.
    /// This member is required.
    public var threatIntelSetId: Swift.String?

    public init (
        detectorId: Swift.String? = nil,
        threatIntelSetId: Swift.String? = nil
    )
    {
        self.detectorId = detectorId
        self.threatIntelSetId = threatIntelSetId
    }
}

struct GetThreatIntelSetInputBody: Swift.Equatable {
}

extension GetThreatIntelSetInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension GetThreatIntelSetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetThreatIntelSetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetThreatIntelSetOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetThreatIntelSetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetThreatIntelSetOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.format = output.format
            self.location = output.location
            self.name = output.name
            self.status = output.status
            self.tags = output.tags
        } else {
            self.format = nil
            self.location = nil
            self.name = nil
            self.status = nil
            self.tags = nil
        }
    }
}

public struct GetThreatIntelSetOutputResponse: Swift.Equatable {
    /// The format of the threatIntelSet.
    /// This member is required.
    public var format: GuardDutyClientTypes.ThreatIntelSetFormat?
    /// The URI of the file that contains the ThreatIntelSet.
    /// This member is required.
    public var location: Swift.String?
    /// A user-friendly ThreatIntelSet name displayed in all findings that are generated by activity that involves IP addresses included in this ThreatIntelSet.
    /// This member is required.
    public var name: Swift.String?
    /// The status of threatIntelSet file uploaded.
    /// This member is required.
    public var status: GuardDutyClientTypes.ThreatIntelSetStatus?
    /// The tags of the threat list resource.
    public var tags: [Swift.String:Swift.String]?

    public init (
        format: GuardDutyClientTypes.ThreatIntelSetFormat? = nil,
        location: Swift.String? = nil,
        name: Swift.String? = nil,
        status: GuardDutyClientTypes.ThreatIntelSetStatus? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.format = format
        self.location = location
        self.name = name
        self.status = status
        self.tags = tags
    }
}

struct GetThreatIntelSetOutputResponseBody: Swift.Equatable {
    let name: Swift.String?
    let format: GuardDutyClientTypes.ThreatIntelSetFormat?
    let location: Swift.String?
    let status: GuardDutyClientTypes.ThreatIntelSetStatus?
    let tags: [Swift.String:Swift.String]?
}

extension GetThreatIntelSetOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case format = "format"
        case location = "location"
        case name = "name"
        case status = "status"
        case tags = "tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let formatDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.ThreatIntelSetFormat.self, forKey: .format)
        format = formatDecoded
        let locationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .location)
        location = locationDecoded
        let statusDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.ThreatIntelSetStatus.self, forKey: .status)
        status = statusDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension GetUsageStatisticsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "maxResults"
        case nextToken = "nextToken"
        case unit = "unit"
        case usageCriteria = "usageCriteria"
        case usageStatisticType = "usageStatisticsType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let unit = self.unit {
            try encodeContainer.encode(unit, forKey: .unit)
        }
        if let usageCriteria = self.usageCriteria {
            try encodeContainer.encode(usageCriteria, forKey: .usageCriteria)
        }
        if let usageStatisticType = self.usageStatisticType {
            try encodeContainer.encode(usageStatisticType.rawValue, forKey: .usageStatisticType)
        }
    }
}

extension GetUsageStatisticsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let detectorId = detectorId else {
            return nil
        }
        return "/detector/\(detectorId.urlPercentEncoding())/usage/statistics"
    }
}

public struct GetUsageStatisticsInput: Swift.Equatable {
    /// The ID of the detector that specifies the GuardDuty service whose usage statistics you want to retrieve.
    /// This member is required.
    public var detectorId: Swift.String?
    /// The maximum number of results to return in the response.
    public var maxResults: Swift.Int?
    /// A token to use for paginating results that are returned in the response. Set the value of this parameter to null for the first request to a list action. For subsequent calls, use the NextToken value returned from the previous request to continue listing results after the first page.
    public var nextToken: Swift.String?
    /// The currency unit you would like to view your usage statistics in. Current valid values are USD.
    public var unit: Swift.String?
    /// Represents the criteria used for querying usage.
    /// This member is required.
    public var usageCriteria: GuardDutyClientTypes.UsageCriteria?
    /// The type of usage statistics to retrieve.
    /// This member is required.
    public var usageStatisticType: GuardDutyClientTypes.UsageStatisticType?

    public init (
        detectorId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        unit: Swift.String? = nil,
        usageCriteria: GuardDutyClientTypes.UsageCriteria? = nil,
        usageStatisticType: GuardDutyClientTypes.UsageStatisticType? = nil
    )
    {
        self.detectorId = detectorId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.unit = unit
        self.usageCriteria = usageCriteria
        self.usageStatisticType = usageStatisticType
    }
}

struct GetUsageStatisticsInputBody: Swift.Equatable {
    let usageStatisticType: GuardDutyClientTypes.UsageStatisticType?
    let usageCriteria: GuardDutyClientTypes.UsageCriteria?
    let unit: Swift.String?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension GetUsageStatisticsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults = "maxResults"
        case nextToken = "nextToken"
        case unit = "unit"
        case usageCriteria = "usageCriteria"
        case usageStatisticType = "usageStatisticsType"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let usageStatisticTypeDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.UsageStatisticType.self, forKey: .usageStatisticType)
        usageStatisticType = usageStatisticTypeDecoded
        let usageCriteriaDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.UsageCriteria.self, forKey: .usageCriteria)
        usageCriteria = usageCriteriaDecoded
        let unitDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .unit)
        unit = unitDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GetUsageStatisticsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension GetUsageStatisticsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum GetUsageStatisticsOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension GetUsageStatisticsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: GetUsageStatisticsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.usageStatistics = output.usageStatistics
        } else {
            self.nextToken = nil
            self.usageStatistics = nil
        }
    }
}

public struct GetUsageStatisticsOutputResponse: Swift.Equatable {
    /// The pagination parameter to be used on the next list operation to retrieve more items.
    public var nextToken: Swift.String?
    /// The usage statistics object. If a UsageStatisticType was provided, the objects representing other types will be null.
    public var usageStatistics: GuardDutyClientTypes.UsageStatistics?

    public init (
        nextToken: Swift.String? = nil,
        usageStatistics: GuardDutyClientTypes.UsageStatistics? = nil
    )
    {
        self.nextToken = nextToken
        self.usageStatistics = usageStatistics
    }
}

struct GetUsageStatisticsOutputResponseBody: Swift.Equatable {
    let usageStatistics: GuardDutyClientTypes.UsageStatistics?
    let nextToken: Swift.String?
}

extension GetUsageStatisticsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "nextToken"
        case usageStatistics = "usageStatistics"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let usageStatisticsDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.UsageStatistics.self, forKey: .usageStatistics)
        usageStatistics = usageStatisticsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GuardDutyClientTypes.HighestSeverityThreatDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case count = "count"
        case severity = "severity"
        case threatName = "threatName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if count != 0 {
            try encodeContainer.encode(count, forKey: .count)
        }
        if let severity = self.severity {
            try encodeContainer.encode(severity, forKey: .severity)
        }
        if let threatName = self.threatName {
            try encodeContainer.encode(threatName, forKey: .threatName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let severityDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .severity)
        severity = severityDecoded
        let threatNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .threatName)
        threatName = threatNameDecoded
        let countDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .count) ?? 0
        count = countDecoded
    }
}

extension GuardDutyClientTypes {
    /// Contains details of the highest severity threat detected during scan and number of infected files.
    public struct HighestSeverityThreatDetails: Swift.Equatable {
        /// Total number of infected files with the highest severity threat detected.
        public var count: Swift.Int
        /// Severity level of the highest severity threat detected.
        public var severity: Swift.String?
        /// Threat name of the highest severity threat detected as part of the malware scan.
        public var threatName: Swift.String?

        public init (
            count: Swift.Int = 0,
            severity: Swift.String? = nil,
            threatName: Swift.String? = nil
        )
        {
            self.count = count
            self.severity = severity
            self.threatName = threatName
        }
    }

}

extension GuardDutyClientTypes.HostPath: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case path = "path"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let path = self.path {
            try encodeContainer.encode(path, forKey: .path)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .path)
        path = pathDecoded
    }
}

extension GuardDutyClientTypes {
    /// Represents a pre-existing file or directory on the host machine that the volume maps to.
    public struct HostPath: Swift.Equatable {
        /// Path of the file or directory on the host that the volume maps to.
        public var path: Swift.String?

        public init (
            path: Swift.String? = nil
        )
        {
            self.path = path
        }
    }

}

extension GuardDutyClientTypes.IamInstanceProfile: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "arn"
        case id = "id"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
    }
}

extension GuardDutyClientTypes {
    /// Contains information about the EC2 instance profile.
    public struct IamInstanceProfile: Swift.Equatable {
        /// The profile ARN of the EC2 instance.
        public var arn: Swift.String?
        /// The profile ID of the EC2 instance.
        public var id: Swift.String?

        public init (
            arn: Swift.String? = nil,
            id: Swift.String? = nil
        )
        {
            self.arn = arn
            self.id = id
        }
    }

}

extension GuardDutyClientTypes.InstanceDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case availabilityZone = "availabilityZone"
        case iamInstanceProfile = "iamInstanceProfile"
        case imageDescription = "imageDescription"
        case imageId = "imageId"
        case instanceId = "instanceId"
        case instanceState = "instanceState"
        case instanceType = "instanceType"
        case launchTime = "launchTime"
        case networkInterfaces = "networkInterfaces"
        case outpostArn = "outpostArn"
        case platform = "platform"
        case productCodes = "productCodes"
        case tags = "tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let availabilityZone = self.availabilityZone {
            try encodeContainer.encode(availabilityZone, forKey: .availabilityZone)
        }
        if let iamInstanceProfile = self.iamInstanceProfile {
            try encodeContainer.encode(iamInstanceProfile, forKey: .iamInstanceProfile)
        }
        if let imageDescription = self.imageDescription {
            try encodeContainer.encode(imageDescription, forKey: .imageDescription)
        }
        if let imageId = self.imageId {
            try encodeContainer.encode(imageId, forKey: .imageId)
        }
        if let instanceId = self.instanceId {
            try encodeContainer.encode(instanceId, forKey: .instanceId)
        }
        if let instanceState = self.instanceState {
            try encodeContainer.encode(instanceState, forKey: .instanceState)
        }
        if let instanceType = self.instanceType {
            try encodeContainer.encode(instanceType, forKey: .instanceType)
        }
        if let launchTime = self.launchTime {
            try encodeContainer.encode(launchTime, forKey: .launchTime)
        }
        if let networkInterfaces = networkInterfaces {
            var networkInterfacesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .networkInterfaces)
            for networkinterface0 in networkInterfaces {
                try networkInterfacesContainer.encode(networkinterface0)
            }
        }
        if let outpostArn = self.outpostArn {
            try encodeContainer.encode(outpostArn, forKey: .outpostArn)
        }
        if let platform = self.platform {
            try encodeContainer.encode(platform, forKey: .platform)
        }
        if let productCodes = productCodes {
            var productCodesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .productCodes)
            for productcode0 in productCodes {
                try productCodesContainer.encode(productcode0)
            }
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let availabilityZoneDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .availabilityZone)
        availabilityZone = availabilityZoneDecoded
        let iamInstanceProfileDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.IamInstanceProfile.self, forKey: .iamInstanceProfile)
        iamInstanceProfile = iamInstanceProfileDecoded
        let imageDescriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageDescription)
        imageDescription = imageDescriptionDecoded
        let imageIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageId)
        imageId = imageIdDecoded
        let instanceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceId)
        instanceId = instanceIdDecoded
        let instanceStateDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceState)
        instanceState = instanceStateDecoded
        let instanceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceType)
        instanceType = instanceTypeDecoded
        let outpostArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .outpostArn)
        outpostArn = outpostArnDecoded
        let launchTimeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .launchTime)
        launchTime = launchTimeDecoded
        let networkInterfacesContainer = try containerValues.decodeIfPresent([GuardDutyClientTypes.NetworkInterface?].self, forKey: .networkInterfaces)
        var networkInterfacesDecoded0:[GuardDutyClientTypes.NetworkInterface]? = nil
        if let networkInterfacesContainer = networkInterfacesContainer {
            networkInterfacesDecoded0 = [GuardDutyClientTypes.NetworkInterface]()
            for structure0 in networkInterfacesContainer {
                if let structure0 = structure0 {
                    networkInterfacesDecoded0?.append(structure0)
                }
            }
        }
        networkInterfaces = networkInterfacesDecoded0
        let platformDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .platform)
        platform = platformDecoded
        let productCodesContainer = try containerValues.decodeIfPresent([GuardDutyClientTypes.ProductCode?].self, forKey: .productCodes)
        var productCodesDecoded0:[GuardDutyClientTypes.ProductCode]? = nil
        if let productCodesContainer = productCodesContainer {
            productCodesDecoded0 = [GuardDutyClientTypes.ProductCode]()
            for structure0 in productCodesContainer {
                if let structure0 = structure0 {
                    productCodesDecoded0?.append(structure0)
                }
            }
        }
        productCodes = productCodesDecoded0
        let tagsContainer = try containerValues.decodeIfPresent([GuardDutyClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[GuardDutyClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [GuardDutyClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension GuardDutyClientTypes {
    /// Contains information about the details of an instance.
    public struct InstanceDetails: Swift.Equatable {
        /// The Availability Zone of the EC2 instance.
        public var availabilityZone: Swift.String?
        /// The profile information of the EC2 instance.
        public var iamInstanceProfile: GuardDutyClientTypes.IamInstanceProfile?
        /// The image description of the EC2 instance.
        public var imageDescription: Swift.String?
        /// The image ID of the EC2 instance.
        public var imageId: Swift.String?
        /// The ID of the EC2 instance.
        public var instanceId: Swift.String?
        /// The state of the EC2 instance.
        public var instanceState: Swift.String?
        /// The type of the EC2 instance.
        public var instanceType: Swift.String?
        /// The launch time of the EC2 instance.
        public var launchTime: Swift.String?
        /// The elastic network interface information of the EC2 instance.
        public var networkInterfaces: [GuardDutyClientTypes.NetworkInterface]?
        /// The Amazon Resource Name (ARN) of the Amazon Web Services Outpost. Only applicable to Amazon Web Services Outposts instances.
        public var outpostArn: Swift.String?
        /// The platform of the EC2 instance.
        public var platform: Swift.String?
        /// The product code of the EC2 instance.
        public var productCodes: [GuardDutyClientTypes.ProductCode]?
        /// The tags of the EC2 instance.
        public var tags: [GuardDutyClientTypes.Tag]?

        public init (
            availabilityZone: Swift.String? = nil,
            iamInstanceProfile: GuardDutyClientTypes.IamInstanceProfile? = nil,
            imageDescription: Swift.String? = nil,
            imageId: Swift.String? = nil,
            instanceId: Swift.String? = nil,
            instanceState: Swift.String? = nil,
            instanceType: Swift.String? = nil,
            launchTime: Swift.String? = nil,
            networkInterfaces: [GuardDutyClientTypes.NetworkInterface]? = nil,
            outpostArn: Swift.String? = nil,
            platform: Swift.String? = nil,
            productCodes: [GuardDutyClientTypes.ProductCode]? = nil,
            tags: [GuardDutyClientTypes.Tag]? = nil
        )
        {
            self.availabilityZone = availabilityZone
            self.iamInstanceProfile = iamInstanceProfile
            self.imageDescription = imageDescription
            self.imageId = imageId
            self.instanceId = instanceId
            self.instanceState = instanceState
            self.instanceType = instanceType
            self.launchTime = launchTime
            self.networkInterfaces = networkInterfaces
            self.outpostArn = outpostArn
            self.platform = platform
            self.productCodes = productCodes
            self.tags = tags
        }
    }

}

extension InternalServerErrorException {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InternalServerErrorExceptionBody = try responseDecoder.decode(responseBody: data)
            self.message = output.message
            self.type = output.type
        } else {
            self.message = nil
            self.type = nil
        }
        self._headers = httpResponse.headers
        self._statusCode = httpResponse.statusCode
        self._requestID = requestID
        self._message = message
    }
}

/// An internal server error exception object.
public struct InternalServerErrorException: AWSClientRuntime.AWSHttpServiceError, Swift.Equatable {
    public var _headers: ClientRuntime.Headers?
    public var _statusCode: ClientRuntime.HttpStatusCode?
    public var _message: Swift.String?
    public var _requestID: Swift.String?
    public var _retryable: Swift.Bool = false
    public var _isThrottling: Swift.Bool = false
    public var _type: ClientRuntime.ErrorType = .server
    /// The error message.
    public var message: Swift.String?
    /// The error type.
    public var type: Swift.String?

    public init (
        message: Swift.String? = nil,
        type: Swift.String? = nil
    )
    {
        self.message = message
        self.type = type
    }
}

struct InternalServerErrorExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let type: Swift.String?
}

extension InternalServerErrorExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message = "message"
        case type = "__type"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
    }
}

extension GuardDutyClientTypes.Invitation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "accountId"
        case invitationId = "invitationId"
        case invitedAt = "invitedAt"
        case relationshipStatus = "relationshipStatus"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let invitationId = self.invitationId {
            try encodeContainer.encode(invitationId, forKey: .invitationId)
        }
        if let invitedAt = self.invitedAt {
            try encodeContainer.encode(invitedAt, forKey: .invitedAt)
        }
        if let relationshipStatus = self.relationshipStatus {
            try encodeContainer.encode(relationshipStatus, forKey: .relationshipStatus)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let invitationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .invitationId)
        invitationId = invitationIdDecoded
        let relationshipStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .relationshipStatus)
        relationshipStatus = relationshipStatusDecoded
        let invitedAtDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .invitedAt)
        invitedAt = invitedAtDecoded
    }
}

extension GuardDutyClientTypes {
    /// Contains information about the invitation to become a member account.
    public struct Invitation: Swift.Equatable {
        /// The ID of the account that the invitation was sent from.
        public var accountId: Swift.String?
        /// The ID of the invitation. This value is used to validate the inviter account to the member account.
        public var invitationId: Swift.String?
        /// The timestamp when the invitation was sent.
        public var invitedAt: Swift.String?
        /// The status of the relationship between the inviter and invitee accounts.
        public var relationshipStatus: Swift.String?

        public init (
            accountId: Swift.String? = nil,
            invitationId: Swift.String? = nil,
            invitedAt: Swift.String? = nil,
            relationshipStatus: Swift.String? = nil
        )
        {
            self.accountId = accountId
            self.invitationId = invitationId
            self.invitedAt = invitedAt
            self.relationshipStatus = relationshipStatus
        }
    }

}

extension InviteMembersInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountIds = "accountIds"
        case disableEmailNotification = "disableEmailNotification"
        case message = "message"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountIds = accountIds {
            var accountIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accountIds)
            for accountid0 in accountIds {
                try accountIdsContainer.encode(accountid0)
            }
        }
        if let disableEmailNotification = self.disableEmailNotification {
            try encodeContainer.encode(disableEmailNotification, forKey: .disableEmailNotification)
        }
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
    }
}

extension InviteMembersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let detectorId = detectorId else {
            return nil
        }
        return "/detector/\(detectorId.urlPercentEncoding())/member/invite"
    }
}

public struct InviteMembersInput: Swift.Equatable {
    /// A list of account IDs of the accounts that you want to invite to GuardDuty as members.
    /// This member is required.
    public var accountIds: [Swift.String]?
    /// The unique ID of the detector of the GuardDuty account that you want to invite members with.
    /// This member is required.
    public var detectorId: Swift.String?
    /// A Boolean value that specifies whether you want to disable email notification to the accounts that you are inviting to GuardDuty as members.
    public var disableEmailNotification: Swift.Bool?
    /// The invitation message that you want to send to the accounts that you're inviting to GuardDuty as members.
    public var message: Swift.String?

    public init (
        accountIds: [Swift.String]? = nil,
        detectorId: Swift.String? = nil,
        disableEmailNotification: Swift.Bool? = nil,
        message: Swift.String? = nil
    )
    {
        self.accountIds = accountIds
        self.detectorId = detectorId
        self.disableEmailNotification = disableEmailNotification
        self.message = message
    }
}

struct InviteMembersInputBody: Swift.Equatable {
    let accountIds: [Swift.String]?
    let disableEmailNotification: Swift.Bool?
    let message: Swift.String?
}

extension InviteMembersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountIds = "accountIds"
        case disableEmailNotification = "disableEmailNotification"
        case message = "message"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .accountIds)
        var accountIdsDecoded0:[Swift.String]? = nil
        if let accountIdsContainer = accountIdsContainer {
            accountIdsDecoded0 = [Swift.String]()
            for string0 in accountIdsContainer {
                if let string0 = string0 {
                    accountIdsDecoded0?.append(string0)
                }
            }
        }
        accountIds = accountIdsDecoded0
        let disableEmailNotificationDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .disableEmailNotification)
        disableEmailNotification = disableEmailNotificationDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InviteMembersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension InviteMembersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum InviteMembersOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension InviteMembersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: InviteMembersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.unprocessedAccounts = output.unprocessedAccounts
        } else {
            self.unprocessedAccounts = nil
        }
    }
}

public struct InviteMembersOutputResponse: Swift.Equatable {
    /// A list of objects that contain the unprocessed account and a result string that explains why it was unprocessed.
    /// This member is required.
    public var unprocessedAccounts: [GuardDutyClientTypes.UnprocessedAccount]?

    public init (
        unprocessedAccounts: [GuardDutyClientTypes.UnprocessedAccount]? = nil
    )
    {
        self.unprocessedAccounts = unprocessedAccounts
    }
}

struct InviteMembersOutputResponseBody: Swift.Equatable {
    let unprocessedAccounts: [GuardDutyClientTypes.UnprocessedAccount]?
}

extension InviteMembersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case unprocessedAccounts = "unprocessedAccounts"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let unprocessedAccountsContainer = try containerValues.decodeIfPresent([GuardDutyClientTypes.UnprocessedAccount?].self, forKey: .unprocessedAccounts)
        var unprocessedAccountsDecoded0:[GuardDutyClientTypes.UnprocessedAccount]? = nil
        if let unprocessedAccountsContainer = unprocessedAccountsContainer {
            unprocessedAccountsDecoded0 = [GuardDutyClientTypes.UnprocessedAccount]()
            for structure0 in unprocessedAccountsContainer {
                if let structure0 = structure0 {
                    unprocessedAccountsDecoded0?.append(structure0)
                }
            }
        }
        unprocessedAccounts = unprocessedAccountsDecoded0
    }
}

extension GuardDutyClientTypes {
    public enum IpSetFormat: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case alienVault
        case fireEye
        case otxCsv
        case proofPoint
        case stix
        case txt
        case sdkUnknown(Swift.String)

        public static var allCases: [IpSetFormat] {
            return [
                .alienVault,
                .fireEye,
                .otxCsv,
                .proofPoint,
                .stix,
                .txt,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .alienVault: return "ALIEN_VAULT"
            case .fireEye: return "FIRE_EYE"
            case .otxCsv: return "OTX_CSV"
            case .proofPoint: return "PROOF_POINT"
            case .stix: return "STIX"
            case .txt: return "TXT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = IpSetFormat(rawValue: rawValue) ?? IpSetFormat.sdkUnknown(rawValue)
        }
    }
}

extension GuardDutyClientTypes {
    public enum IpSetStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case activating
        case active
        case deactivating
        case deleted
        case deletePending
        case error
        case inactive
        case sdkUnknown(Swift.String)

        public static var allCases: [IpSetStatus] {
            return [
                .activating,
                .active,
                .deactivating,
                .deleted,
                .deletePending,
                .error,
                .inactive,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .activating: return "ACTIVATING"
            case .active: return "ACTIVE"
            case .deactivating: return "DEACTIVATING"
            case .deleted: return "DELETED"
            case .deletePending: return "DELETE_PENDING"
            case .error: return "ERROR"
            case .inactive: return "INACTIVE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = IpSetStatus(rawValue: rawValue) ?? IpSetStatus.sdkUnknown(rawValue)
        }
    }
}

extension GuardDutyClientTypes.KubernetesApiCallAction: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case parameters = "parameters"
        case remoteIpDetails = "remoteIpDetails"
        case requestUri = "requestUri"
        case sourceIps = "sourceIps"
        case statusCode = "statusCode"
        case userAgent = "userAgent"
        case verb = "verb"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let parameters = self.parameters {
            try encodeContainer.encode(parameters, forKey: .parameters)
        }
        if let remoteIpDetails = self.remoteIpDetails {
            try encodeContainer.encode(remoteIpDetails, forKey: .remoteIpDetails)
        }
        if let requestUri = self.requestUri {
            try encodeContainer.encode(requestUri, forKey: .requestUri)
        }
        if let sourceIps = sourceIps {
            var sourceIpsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sourceIps)
            for string0 in sourceIps {
                try sourceIpsContainer.encode(string0)
            }
        }
        if statusCode != 0 {
            try encodeContainer.encode(statusCode, forKey: .statusCode)
        }
        if let userAgent = self.userAgent {
            try encodeContainer.encode(userAgent, forKey: .userAgent)
        }
        if let verb = self.verb {
            try encodeContainer.encode(verb, forKey: .verb)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let requestUriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .requestUri)
        requestUri = requestUriDecoded
        let verbDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .verb)
        verb = verbDecoded
        let sourceIpsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .sourceIps)
        var sourceIpsDecoded0:[Swift.String]? = nil
        if let sourceIpsContainer = sourceIpsContainer {
            sourceIpsDecoded0 = [Swift.String]()
            for string0 in sourceIpsContainer {
                if let string0 = string0 {
                    sourceIpsDecoded0?.append(string0)
                }
            }
        }
        sourceIps = sourceIpsDecoded0
        let userAgentDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userAgent)
        userAgent = userAgentDecoded
        let remoteIpDetailsDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.RemoteIpDetails.self, forKey: .remoteIpDetails)
        remoteIpDetails = remoteIpDetailsDecoded
        let statusCodeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .statusCode) ?? 0
        statusCode = statusCodeDecoded
        let parametersDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .parameters)
        parameters = parametersDecoded
    }
}

extension GuardDutyClientTypes {
    /// Information about the Kubernetes API call action described in this finding.
    public struct KubernetesApiCallAction: Swift.Equatable {
        /// Parameters related to the Kubernetes API call action.
        public var parameters: Swift.String?
        /// Contains information about the remote IP address of the connection.
        public var remoteIpDetails: GuardDutyClientTypes.RemoteIpDetails?
        /// The Kubernetes API request URI.
        public var requestUri: Swift.String?
        /// The IP of the Kubernetes API caller and the IPs of any proxies or load balancers between the caller and the API endpoint.
        public var sourceIps: [Swift.String]?
        /// The resulting HTTP response code of the Kubernetes API call action.
        public var statusCode: Swift.Int
        /// The user agent of the caller of the Kubernetes API.
        public var userAgent: Swift.String?
        /// The Kubernetes API request HTTP verb.
        public var verb: Swift.String?

        public init (
            parameters: Swift.String? = nil,
            remoteIpDetails: GuardDutyClientTypes.RemoteIpDetails? = nil,
            requestUri: Swift.String? = nil,
            sourceIps: [Swift.String]? = nil,
            statusCode: Swift.Int = 0,
            userAgent: Swift.String? = nil,
            verb: Swift.String? = nil
        )
        {
            self.parameters = parameters
            self.remoteIpDetails = remoteIpDetails
            self.requestUri = requestUri
            self.sourceIps = sourceIps
            self.statusCode = statusCode
            self.userAgent = userAgent
            self.verb = verb
        }
    }

}

extension GuardDutyClientTypes.KubernetesAuditLogsConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enable = "enable"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if enable != false {
            try encodeContainer.encode(enable, forKey: .enable)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enableDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enable) ?? false
        enable = enableDecoded
    }
}

extension GuardDutyClientTypes {
    /// Describes whether Kubernetes audit logs are enabled as a data source.
    public struct KubernetesAuditLogsConfiguration: Swift.Equatable {
        /// The status of Kubernetes audit logs as a data source.
        /// This member is required.
        public var enable: Swift.Bool

        public init (
            enable: Swift.Bool = false
        )
        {
            self.enable = enable
        }
    }

}

extension GuardDutyClientTypes.KubernetesAuditLogsConfigurationResult: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status = "status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.DataSourceStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension GuardDutyClientTypes {
    /// Describes whether Kubernetes audit logs are enabled as a data source.
    public struct KubernetesAuditLogsConfigurationResult: Swift.Equatable {
        /// A value that describes whether Kubernetes audit logs are enabled as a data source.
        /// This member is required.
        public var status: GuardDutyClientTypes.DataSourceStatus?

        public init (
            status: GuardDutyClientTypes.DataSourceStatus? = nil
        )
        {
            self.status = status
        }
    }

}

extension GuardDutyClientTypes.KubernetesConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case auditLogs = "auditLogs"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let auditLogs = self.auditLogs {
            try encodeContainer.encode(auditLogs, forKey: .auditLogs)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let auditLogsDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.KubernetesAuditLogsConfiguration.self, forKey: .auditLogs)
        auditLogs = auditLogsDecoded
    }
}

extension GuardDutyClientTypes {
    /// Describes whether any Kubernetes data sources are enabled.
    public struct KubernetesConfiguration: Swift.Equatable {
        /// The status of Kubernetes audit logs as a data source.
        /// This member is required.
        public var auditLogs: GuardDutyClientTypes.KubernetesAuditLogsConfiguration?

        public init (
            auditLogs: GuardDutyClientTypes.KubernetesAuditLogsConfiguration? = nil
        )
        {
            self.auditLogs = auditLogs
        }
    }

}

extension GuardDutyClientTypes.KubernetesConfigurationResult: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case auditLogs = "auditLogs"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let auditLogs = self.auditLogs {
            try encodeContainer.encode(auditLogs, forKey: .auditLogs)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let auditLogsDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.KubernetesAuditLogsConfigurationResult.self, forKey: .auditLogs)
        auditLogs = auditLogsDecoded
    }
}

extension GuardDutyClientTypes {
    /// Describes whether any Kubernetes logs will be enabled as a data source.
    public struct KubernetesConfigurationResult: Swift.Equatable {
        /// Describes whether Kubernetes audit logs are enabled as a data source.
        /// This member is required.
        public var auditLogs: GuardDutyClientTypes.KubernetesAuditLogsConfigurationResult?

        public init (
            auditLogs: GuardDutyClientTypes.KubernetesAuditLogsConfigurationResult? = nil
        )
        {
            self.auditLogs = auditLogs
        }
    }

}

extension GuardDutyClientTypes.KubernetesDataSourceFreeTrial: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case auditLogs = "auditLogs"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let auditLogs = self.auditLogs {
            try encodeContainer.encode(auditLogs, forKey: .auditLogs)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let auditLogsDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.DataSourceFreeTrial.self, forKey: .auditLogs)
        auditLogs = auditLogsDecoded
    }
}

extension GuardDutyClientTypes {
    /// Provides details about the Kubernetes resources when it is enabled as a data source.
    public struct KubernetesDataSourceFreeTrial: Swift.Equatable {
        /// Describes whether Kubernetes audit logs are enabled as a data source.
        public var auditLogs: GuardDutyClientTypes.DataSourceFreeTrial?

        public init (
            auditLogs: GuardDutyClientTypes.DataSourceFreeTrial? = nil
        )
        {
            self.auditLogs = auditLogs
        }
    }

}

extension GuardDutyClientTypes.KubernetesDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case kubernetesUserDetails = "kubernetesUserDetails"
        case kubernetesWorkloadDetails = "kubernetesWorkloadDetails"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let kubernetesUserDetails = self.kubernetesUserDetails {
            try encodeContainer.encode(kubernetesUserDetails, forKey: .kubernetesUserDetails)
        }
        if let kubernetesWorkloadDetails = self.kubernetesWorkloadDetails {
            try encodeContainer.encode(kubernetesWorkloadDetails, forKey: .kubernetesWorkloadDetails)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let kubernetesUserDetailsDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.KubernetesUserDetails.self, forKey: .kubernetesUserDetails)
        kubernetesUserDetails = kubernetesUserDetailsDecoded
        let kubernetesWorkloadDetailsDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.KubernetesWorkloadDetails.self, forKey: .kubernetesWorkloadDetails)
        kubernetesWorkloadDetails = kubernetesWorkloadDetailsDecoded
    }
}

extension GuardDutyClientTypes {
    /// Details about Kubernetes resources such as a Kubernetes user or workload resource involved in a Kubernetes finding.
    public struct KubernetesDetails: Swift.Equatable {
        /// Details about the Kubernetes user involved in a Kubernetes finding.
        public var kubernetesUserDetails: GuardDutyClientTypes.KubernetesUserDetails?
        /// Details about the Kubernetes workload involved in a Kubernetes finding.
        public var kubernetesWorkloadDetails: GuardDutyClientTypes.KubernetesWorkloadDetails?

        public init (
            kubernetesUserDetails: GuardDutyClientTypes.KubernetesUserDetails? = nil,
            kubernetesWorkloadDetails: GuardDutyClientTypes.KubernetesWorkloadDetails? = nil
        )
        {
            self.kubernetesUserDetails = kubernetesUserDetails
            self.kubernetesWorkloadDetails = kubernetesWorkloadDetails
        }
    }

}

extension GuardDutyClientTypes.KubernetesUserDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groups = "groups"
        case uid = "uid"
        case username = "username"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let groups = groups {
            var groupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .groups)
            for string0 in groups {
                try groupsContainer.encode(string0)
            }
        }
        if let uid = self.uid {
            try encodeContainer.encode(uid, forKey: .uid)
        }
        if let username = self.username {
            try encodeContainer.encode(username, forKey: .username)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let usernameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .username)
        username = usernameDecoded
        let uidDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .uid)
        uid = uidDecoded
        let groupsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .groups)
        var groupsDecoded0:[Swift.String]? = nil
        if let groupsContainer = groupsContainer {
            groupsDecoded0 = [Swift.String]()
            for string0 in groupsContainer {
                if let string0 = string0 {
                    groupsDecoded0?.append(string0)
                }
            }
        }
        groups = groupsDecoded0
    }
}

extension GuardDutyClientTypes {
    /// Details about the Kubernetes user involved in a Kubernetes finding.
    public struct KubernetesUserDetails: Swift.Equatable {
        /// The groups that include the user who called the Kubernetes API.
        public var groups: [Swift.String]?
        /// The user ID of the user who called the Kubernetes API.
        public var uid: Swift.String?
        /// The username of the user who called the Kubernetes API.
        public var username: Swift.String?

        public init (
            groups: [Swift.String]? = nil,
            uid: Swift.String? = nil,
            username: Swift.String? = nil
        )
        {
            self.groups = groups
            self.uid = uid
            self.username = username
        }
    }

}

extension GuardDutyClientTypes.KubernetesWorkloadDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case containers = "containers"
        case hostNetwork = "hostNetwork"
        case name = "name"
        case namespace = "namespace"
        case type = "type"
        case uid = "uid"
        case volumes = "volumes"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let containers = containers {
            var containersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .containers)
            for container0 in containers {
                try containersContainer.encode(container0)
            }
        }
        if hostNetwork != false {
            try encodeContainer.encode(hostNetwork, forKey: .hostNetwork)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let namespace = self.namespace {
            try encodeContainer.encode(namespace, forKey: .namespace)
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
        if let uid = self.uid {
            try encodeContainer.encode(uid, forKey: .uid)
        }
        if let volumes = volumes {
            var volumesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .volumes)
            for volume0 in volumes {
                try volumesContainer.encode(volume0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let uidDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .uid)
        uid = uidDecoded
        let namespaceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .namespace)
        namespace = namespaceDecoded
        let hostNetworkDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .hostNetwork) ?? false
        hostNetwork = hostNetworkDecoded
        let containersContainer = try containerValues.decodeIfPresent([GuardDutyClientTypes.Container?].self, forKey: .containers)
        var containersDecoded0:[GuardDutyClientTypes.Container]? = nil
        if let containersContainer = containersContainer {
            containersDecoded0 = [GuardDutyClientTypes.Container]()
            for structure0 in containersContainer {
                if let structure0 = structure0 {
                    containersDecoded0?.append(structure0)
                }
            }
        }
        containers = containersDecoded0
        let volumesContainer = try containerValues.decodeIfPresent([GuardDutyClientTypes.Volume?].self, forKey: .volumes)
        var volumesDecoded0:[GuardDutyClientTypes.Volume]? = nil
        if let volumesContainer = volumesContainer {
            volumesDecoded0 = [GuardDutyClientTypes.Volume]()
            for structure0 in volumesContainer {
                if let structure0 = structure0 {
                    volumesDecoded0?.append(structure0)
                }
            }
        }
        volumes = volumesDecoded0
    }
}

extension GuardDutyClientTypes {
    /// Details about the Kubernetes workload involved in a Kubernetes finding.
    public struct KubernetesWorkloadDetails: Swift.Equatable {
        /// Containers running as part of the Kubernetes workload.
        public var containers: [GuardDutyClientTypes.Container]?
        /// Whether the hostNetwork flag is enabled for the pods included in the workload.
        public var hostNetwork: Swift.Bool
        /// Kubernetes workload name.
        public var name: Swift.String?
        /// Kubernetes namespace that the workload is part of.
        public var namespace: Swift.String?
        /// Kubernetes workload type (e.g. Pod, Deployment, etc.).
        public var type: Swift.String?
        /// Kubernetes workload ID.
        public var uid: Swift.String?
        /// Volumes used by the Kubernetes workload.
        public var volumes: [GuardDutyClientTypes.Volume]?

        public init (
            containers: [GuardDutyClientTypes.Container]? = nil,
            hostNetwork: Swift.Bool = false,
            name: Swift.String? = nil,
            namespace: Swift.String? = nil,
            type: Swift.String? = nil,
            uid: Swift.String? = nil,
            volumes: [GuardDutyClientTypes.Volume]? = nil
        )
        {
            self.containers = containers
            self.hostNetwork = hostNetwork
            self.name = name
            self.namespace = namespace
            self.type = type
            self.uid = uid
            self.volumes = volumes
        }
    }

}

extension ListDetectorsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListDetectorsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/detector"
    }
}

public struct ListDetectorsInput: Swift.Equatable {
    /// You can use this parameter to indicate the maximum number of items that you want in the response. The default value is 50. The maximum value is 50.
    public var maxResults: Swift.Int?
    /// You can use this parameter when paginating results. Set the value of this parameter to null on your first call to the list action. For subsequent calls to the action, fill nextToken in the request with the value of NextToken from the previous response to continue listing data.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListDetectorsInputBody: Swift.Equatable {
}

extension ListDetectorsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListDetectorsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListDetectorsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListDetectorsOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListDetectorsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListDetectorsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.detectorIds = output.detectorIds
            self.nextToken = output.nextToken
        } else {
            self.detectorIds = nil
            self.nextToken = nil
        }
    }
}

public struct ListDetectorsOutputResponse: Swift.Equatable {
    /// A list of detector IDs.
    /// This member is required.
    public var detectorIds: [Swift.String]?
    /// The pagination parameter to be used on the next list operation to retrieve more items.
    public var nextToken: Swift.String?

    public init (
        detectorIds: [Swift.String]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.detectorIds = detectorIds
        self.nextToken = nextToken
    }
}

struct ListDetectorsOutputResponseBody: Swift.Equatable {
    let detectorIds: [Swift.String]?
    let nextToken: Swift.String?
}

extension ListDetectorsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case detectorIds = "detectorIds"
        case nextToken = "nextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detectorIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .detectorIds)
        var detectorIdsDecoded0:[Swift.String]? = nil
        if let detectorIdsContainer = detectorIdsContainer {
            detectorIdsDecoded0 = [Swift.String]()
            for string0 in detectorIdsContainer {
                if let string0 = string0 {
                    detectorIdsDecoded0?.append(string0)
                }
            }
        }
        detectorIds = detectorIdsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListFiltersInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListFiltersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let detectorId = detectorId else {
            return nil
        }
        return "/detector/\(detectorId.urlPercentEncoding())/filter"
    }
}

public struct ListFiltersInput: Swift.Equatable {
    /// The unique ID of the detector that the filter is associated with.
    /// This member is required.
    public var detectorId: Swift.String?
    /// You can use this parameter to indicate the maximum number of items that you want in the response. The default value is 50. The maximum value is 50.
    public var maxResults: Swift.Int?
    /// You can use this parameter when paginating results. Set the value of this parameter to null on your first call to the list action. For subsequent calls to the action, fill nextToken in the request with the value of NextToken from the previous response to continue listing data.
    public var nextToken: Swift.String?

    public init (
        detectorId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.detectorId = detectorId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListFiltersInputBody: Swift.Equatable {
}

extension ListFiltersInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListFiltersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListFiltersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListFiltersOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListFiltersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListFiltersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.filterNames = output.filterNames
            self.nextToken = output.nextToken
        } else {
            self.filterNames = nil
            self.nextToken = nil
        }
    }
}

public struct ListFiltersOutputResponse: Swift.Equatable {
    /// A list of filter names.
    /// This member is required.
    public var filterNames: [Swift.String]?
    /// The pagination parameter to be used on the next list operation to retrieve more items.
    public var nextToken: Swift.String?

    public init (
        filterNames: [Swift.String]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.filterNames = filterNames
        self.nextToken = nextToken
    }
}

struct ListFiltersOutputResponseBody: Swift.Equatable {
    let filterNames: [Swift.String]?
    let nextToken: Swift.String?
}

extension ListFiltersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filterNames = "filterNames"
        case nextToken = "nextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filterNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .filterNames)
        var filterNamesDecoded0:[Swift.String]? = nil
        if let filterNamesContainer = filterNamesContainer {
            filterNamesDecoded0 = [Swift.String]()
            for string0 in filterNamesContainer {
                if let string0 = string0 {
                    filterNamesDecoded0?.append(string0)
                }
            }
        }
        filterNames = filterNamesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListFindingsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case findingCriteria = "findingCriteria"
        case maxResults = "maxResults"
        case nextToken = "nextToken"
        case sortCriteria = "sortCriteria"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let findingCriteria = self.findingCriteria {
            try encodeContainer.encode(findingCriteria, forKey: .findingCriteria)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let sortCriteria = self.sortCriteria {
            try encodeContainer.encode(sortCriteria, forKey: .sortCriteria)
        }
    }
}

extension ListFindingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let detectorId = detectorId else {
            return nil
        }
        return "/detector/\(detectorId.urlPercentEncoding())/findings"
    }
}

public struct ListFindingsInput: Swift.Equatable {
    /// The ID of the detector that specifies the GuardDuty service whose findings you want to list.
    /// This member is required.
    public var detectorId: Swift.String?
    /// Represents the criteria used for querying findings. Valid values include:
    ///
    /// * JSON field name
    ///
    /// * accountId
    ///
    /// * region
    ///
    /// * confidence
    ///
    /// * id
    ///
    /// * resource.accessKeyDetails.accessKeyId
    ///
    /// * resource.accessKeyDetails.principalId
    ///
    /// * resource.accessKeyDetails.userName
    ///
    /// * resource.accessKeyDetails.userType
    ///
    /// * resource.instanceDetails.iamInstanceProfile.id
    ///
    /// * resource.instanceDetails.imageId
    ///
    /// * resource.instanceDetails.instanceId
    ///
    /// * resource.instanceDetails.networkInterfaces.ipv6Addresses
    ///
    /// * resource.instanceDetails.networkInterfaces.privateIpAddresses.privateIpAddress
    ///
    /// * resource.instanceDetails.networkInterfaces.publicDnsName
    ///
    /// * resource.instanceDetails.networkInterfaces.publicIp
    ///
    /// * resource.instanceDetails.networkInterfaces.securityGroups.groupId
    ///
    /// * resource.instanceDetails.networkInterfaces.securityGroups.groupName
    ///
    /// * resource.instanceDetails.networkInterfaces.subnetId
    ///
    /// * resource.instanceDetails.networkInterfaces.vpcId
    ///
    /// * resource.instanceDetails.tags.key
    ///
    /// * resource.instanceDetails.tags.value
    ///
    /// * resource.resourceType
    ///
    /// * service.action.actionType
    ///
    /// * service.action.awsApiCallAction.api
    ///
    /// * service.action.awsApiCallAction.callerType
    ///
    /// * service.action.awsApiCallAction.remoteIpDetails.city.cityName
    ///
    /// * service.action.awsApiCallAction.remoteIpDetails.country.countryName
    ///
    /// * service.action.awsApiCallAction.remoteIpDetails.ipAddressV4
    ///
    /// * service.action.awsApiCallAction.remoteIpDetails.organization.asn
    ///
    /// * service.action.awsApiCallAction.remoteIpDetails.organization.asnOrg
    ///
    /// * service.action.awsApiCallAction.serviceName
    ///
    /// * service.action.dnsRequestAction.domain
    ///
    /// * service.action.networkConnectionAction.blocked
    ///
    /// * service.action.networkConnectionAction.connectionDirection
    ///
    /// * service.action.networkConnectionAction.localPortDetails.port
    ///
    /// * service.action.networkConnectionAction.protocol
    ///
    /// * service.action.networkConnectionAction.remoteIpDetails.country.countryName
    ///
    /// * service.action.networkConnectionAction.remoteIpDetails.ipAddressV4
    ///
    /// * service.action.networkConnectionAction.remoteIpDetails.organization.asn
    ///
    /// * service.action.networkConnectionAction.remoteIpDetails.organization.asnOrg
    ///
    /// * service.action.networkConnectionAction.remotePortDetails.port
    ///
    /// * service.additionalInfo.threatListName
    ///
    /// * service.archived When this attribute is set to 'true', only archived findings are listed. When it's set to 'false', only unarchived findings are listed. When this attribute is not set, all existing findings are listed.
    ///
    /// * service.resourceRole
    ///
    /// * severity
    ///
    /// * type
    ///
    /// * updatedAt Type: Timestamp in Unix Epoch millisecond format: 1486685375000
    public var findingCriteria: GuardDutyClientTypes.FindingCriteria?
    /// You can use this parameter to indicate the maximum number of items you want in the response. The default value is 50. The maximum value is 50.
    public var maxResults: Swift.Int?
    /// You can use this parameter when paginating results. Set the value of this parameter to null on your first call to the list action. For subsequent calls to the action, fill nextToken in the request with the value of NextToken from the previous response to continue listing data.
    public var nextToken: Swift.String?
    /// Represents the criteria used for sorting findings.
    public var sortCriteria: GuardDutyClientTypes.SortCriteria?

    public init (
        detectorId: Swift.String? = nil,
        findingCriteria: GuardDutyClientTypes.FindingCriteria? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        sortCriteria: GuardDutyClientTypes.SortCriteria? = nil
    )
    {
        self.detectorId = detectorId
        self.findingCriteria = findingCriteria
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.sortCriteria = sortCriteria
    }
}

struct ListFindingsInputBody: Swift.Equatable {
    let findingCriteria: GuardDutyClientTypes.FindingCriteria?
    let sortCriteria: GuardDutyClientTypes.SortCriteria?
    let maxResults: Swift.Int?
    let nextToken: Swift.String?
}

extension ListFindingsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case findingCriteria = "findingCriteria"
        case maxResults = "maxResults"
        case nextToken = "nextToken"
        case sortCriteria = "sortCriteria"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let findingCriteriaDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.FindingCriteria.self, forKey: .findingCriteria)
        findingCriteria = findingCriteriaDecoded
        let sortCriteriaDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.SortCriteria.self, forKey: .sortCriteria)
        sortCriteria = sortCriteriaDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListFindingsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListFindingsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListFindingsOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListFindingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListFindingsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.findingIds = output.findingIds
            self.nextToken = output.nextToken
        } else {
            self.findingIds = nil
            self.nextToken = nil
        }
    }
}

public struct ListFindingsOutputResponse: Swift.Equatable {
    /// The IDs of the findings that you're listing.
    /// This member is required.
    public var findingIds: [Swift.String]?
    /// The pagination parameter to be used on the next list operation to retrieve more items.
    public var nextToken: Swift.String?

    public init (
        findingIds: [Swift.String]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.findingIds = findingIds
        self.nextToken = nextToken
    }
}

struct ListFindingsOutputResponseBody: Swift.Equatable {
    let findingIds: [Swift.String]?
    let nextToken: Swift.String?
}

extension ListFindingsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case findingIds = "findingIds"
        case nextToken = "nextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let findingIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .findingIds)
        var findingIdsDecoded0:[Swift.String]? = nil
        if let findingIdsContainer = findingIdsContainer {
            findingIdsDecoded0 = [Swift.String]()
            for string0 in findingIdsContainer {
                if let string0 = string0 {
                    findingIdsDecoded0?.append(string0)
                }
            }
        }
        findingIds = findingIdsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListIPSetsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListIPSetsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let detectorId = detectorId else {
            return nil
        }
        return "/detector/\(detectorId.urlPercentEncoding())/ipset"
    }
}

public struct ListIPSetsInput: Swift.Equatable {
    /// The unique ID of the detector that the IPSet is associated with.
    /// This member is required.
    public var detectorId: Swift.String?
    /// You can use this parameter to indicate the maximum number of items you want in the response. The default value is 50. The maximum value is 50.
    public var maxResults: Swift.Int?
    /// You can use this parameter when paginating results. Set the value of this parameter to null on your first call to the list action. For subsequent calls to the action, fill nextToken in the request with the value of NextToken from the previous response to continue listing data.
    public var nextToken: Swift.String?

    public init (
        detectorId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.detectorId = detectorId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListIPSetsInputBody: Swift.Equatable {
}

extension ListIPSetsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListIPSetsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListIPSetsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListIPSetsOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListIPSetsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListIPSetsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.ipSetIds = output.ipSetIds
            self.nextToken = output.nextToken
        } else {
            self.ipSetIds = nil
            self.nextToken = nil
        }
    }
}

public struct ListIPSetsOutputResponse: Swift.Equatable {
    /// The IDs of the IPSet resources.
    /// This member is required.
    public var ipSetIds: [Swift.String]?
    /// The pagination parameter to be used on the next list operation to retrieve more items.
    public var nextToken: Swift.String?

    public init (
        ipSetIds: [Swift.String]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.ipSetIds = ipSetIds
        self.nextToken = nextToken
    }
}

struct ListIPSetsOutputResponseBody: Swift.Equatable {
    let ipSetIds: [Swift.String]?
    let nextToken: Swift.String?
}

extension ListIPSetsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ipSetIds = "ipSetIds"
        case nextToken = "nextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ipSetIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .ipSetIds)
        var ipSetIdsDecoded0:[Swift.String]? = nil
        if let ipSetIdsContainer = ipSetIdsContainer {
            ipSetIdsDecoded0 = [Swift.String]()
            for string0 in ipSetIdsContainer {
                if let string0 = string0 {
                    ipSetIdsDecoded0?.append(string0)
                }
            }
        }
        ipSetIds = ipSetIdsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListInvitationsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListInvitationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/invitation"
    }
}

public struct ListInvitationsInput: Swift.Equatable {
    /// You can use this parameter to indicate the maximum number of items that you want in the response. The default value is 50. The maximum value is 50.
    public var maxResults: Swift.Int?
    /// You can use this parameter when paginating results. Set the value of this parameter to null on your first call to the list action. For subsequent calls to the action, fill nextToken in the request with the value of NextToken from the previous response to continue listing data.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListInvitationsInputBody: Swift.Equatable {
}

extension ListInvitationsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListInvitationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListInvitationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListInvitationsOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListInvitationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListInvitationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.invitations = output.invitations
            self.nextToken = output.nextToken
        } else {
            self.invitations = nil
            self.nextToken = nil
        }
    }
}

public struct ListInvitationsOutputResponse: Swift.Equatable {
    /// A list of invitation descriptions.
    public var invitations: [GuardDutyClientTypes.Invitation]?
    /// The pagination parameter to be used on the next list operation to retrieve more items.
    public var nextToken: Swift.String?

    public init (
        invitations: [GuardDutyClientTypes.Invitation]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.invitations = invitations
        self.nextToken = nextToken
    }
}

struct ListInvitationsOutputResponseBody: Swift.Equatable {
    let invitations: [GuardDutyClientTypes.Invitation]?
    let nextToken: Swift.String?
}

extension ListInvitationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case invitations = "invitations"
        case nextToken = "nextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let invitationsContainer = try containerValues.decodeIfPresent([GuardDutyClientTypes.Invitation?].self, forKey: .invitations)
        var invitationsDecoded0:[GuardDutyClientTypes.Invitation]? = nil
        if let invitationsContainer = invitationsContainer {
            invitationsDecoded0 = [GuardDutyClientTypes.Invitation]()
            for structure0 in invitationsContainer {
                if let structure0 = structure0 {
                    invitationsDecoded0?.append(structure0)
                }
            }
        }
        invitations = invitationsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListMembersInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            if let onlyAssociated = onlyAssociated {
                let onlyAssociatedQueryItem = ClientRuntime.URLQueryItem(name: "onlyAssociated".urlPercentEncoding(), value: Swift.String(onlyAssociated).urlPercentEncoding())
                items.append(onlyAssociatedQueryItem)
            }
            return items
        }
    }
}

extension ListMembersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let detectorId = detectorId else {
            return nil
        }
        return "/detector/\(detectorId.urlPercentEncoding())/member"
    }
}

public struct ListMembersInput: Swift.Equatable {
    /// The unique ID of the detector the member is associated with.
    /// This member is required.
    public var detectorId: Swift.String?
    /// You can use this parameter to indicate the maximum number of items you want in the response. The default value is 50. The maximum value is 50.
    public var maxResults: Swift.Int?
    /// You can use this parameter when paginating results. Set the value of this parameter to null on your first call to the list action. For subsequent calls to the action, fill nextToken in the request with the value of NextToken from the previous response to continue listing data.
    public var nextToken: Swift.String?
    /// Specifies whether to only return associated members or to return all members (including members who haven't been invited yet or have been disassociated). Member accounts must have been previously associated with the GuardDuty administrator account using [Create Members](https://docs.aws.amazon.com/guardduty/latest/APIReference/API_CreateMembers.html).
    public var onlyAssociated: Swift.String?

    public init (
        detectorId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        onlyAssociated: Swift.String? = nil
    )
    {
        self.detectorId = detectorId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.onlyAssociated = onlyAssociated
    }
}

struct ListMembersInputBody: Swift.Equatable {
}

extension ListMembersInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListMembersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListMembersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListMembersOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListMembersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListMembersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.members = output.members
            self.nextToken = output.nextToken
        } else {
            self.members = nil
            self.nextToken = nil
        }
    }
}

public struct ListMembersOutputResponse: Swift.Equatable {
    /// A list of members.
    public var members: [GuardDutyClientTypes.Member]?
    /// The pagination parameter to be used on the next list operation to retrieve more items.
    public var nextToken: Swift.String?

    public init (
        members: [GuardDutyClientTypes.Member]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.members = members
        self.nextToken = nextToken
    }
}

struct ListMembersOutputResponseBody: Swift.Equatable {
    let members: [GuardDutyClientTypes.Member]?
    let nextToken: Swift.String?
}

extension ListMembersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case members = "members"
        case nextToken = "nextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let membersContainer = try containerValues.decodeIfPresent([GuardDutyClientTypes.Member?].self, forKey: .members)
        var membersDecoded0:[GuardDutyClientTypes.Member]? = nil
        if let membersContainer = membersContainer {
            membersDecoded0 = [GuardDutyClientTypes.Member]()
            for structure0 in membersContainer {
                if let structure0 = structure0 {
                    membersDecoded0?.append(structure0)
                }
            }
        }
        members = membersDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListOrganizationAdminAccountsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListOrganizationAdminAccountsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/admin"
    }
}

public struct ListOrganizationAdminAccountsInput: Swift.Equatable {
    /// The maximum number of results to return in the response.
    public var maxResults: Swift.Int?
    /// A token to use for paginating results that are returned in the response. Set the value of this parameter to null for the first request to a list action. For subsequent calls, use the NextToken value returned from the previous request to continue listing results after the first page.
    public var nextToken: Swift.String?

    public init (
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListOrganizationAdminAccountsInputBody: Swift.Equatable {
}

extension ListOrganizationAdminAccountsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListOrganizationAdminAccountsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListOrganizationAdminAccountsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListOrganizationAdminAccountsOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListOrganizationAdminAccountsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListOrganizationAdminAccountsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.adminAccounts = output.adminAccounts
            self.nextToken = output.nextToken
        } else {
            self.adminAccounts = nil
            self.nextToken = nil
        }
    }
}

public struct ListOrganizationAdminAccountsOutputResponse: Swift.Equatable {
    /// A list of accounts configured as GuardDuty delegated administrators.
    public var adminAccounts: [GuardDutyClientTypes.AdminAccount]?
    /// The pagination parameter to be used on the next list operation to retrieve more items.
    public var nextToken: Swift.String?

    public init (
        adminAccounts: [GuardDutyClientTypes.AdminAccount]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.adminAccounts = adminAccounts
        self.nextToken = nextToken
    }
}

struct ListOrganizationAdminAccountsOutputResponseBody: Swift.Equatable {
    let adminAccounts: [GuardDutyClientTypes.AdminAccount]?
    let nextToken: Swift.String?
}

extension ListOrganizationAdminAccountsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case adminAccounts = "adminAccounts"
        case nextToken = "nextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let adminAccountsContainer = try containerValues.decodeIfPresent([GuardDutyClientTypes.AdminAccount?].self, forKey: .adminAccounts)
        var adminAccountsDecoded0:[GuardDutyClientTypes.AdminAccount]? = nil
        if let adminAccountsContainer = adminAccountsContainer {
            adminAccountsDecoded0 = [GuardDutyClientTypes.AdminAccount]()
            for structure0 in adminAccountsContainer {
                if let structure0 = structure0 {
                    adminAccountsDecoded0?.append(structure0)
                }
            }
        }
        adminAccounts = adminAccountsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListPublishingDestinationsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListPublishingDestinationsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let detectorId = detectorId else {
            return nil
        }
        return "/detector/\(detectorId.urlPercentEncoding())/publishingDestination"
    }
}

public struct ListPublishingDestinationsInput: Swift.Equatable {
    /// The ID of the detector to retrieve publishing destinations for.
    /// This member is required.
    public var detectorId: Swift.String?
    /// The maximum number of results to return in the response.
    public var maxResults: Swift.Int?
    /// A token to use for paginating results that are returned in the response. Set the value of this parameter to null for the first request to a list action. For subsequent calls, use the NextToken value returned from the previous request to continue listing results after the first page.
    public var nextToken: Swift.String?

    public init (
        detectorId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.detectorId = detectorId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListPublishingDestinationsInputBody: Swift.Equatable {
}

extension ListPublishingDestinationsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListPublishingDestinationsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListPublishingDestinationsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListPublishingDestinationsOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListPublishingDestinationsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListPublishingDestinationsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.destinations = output.destinations
            self.nextToken = output.nextToken
        } else {
            self.destinations = nil
            self.nextToken = nil
        }
    }
}

public struct ListPublishingDestinationsOutputResponse: Swift.Equatable {
    /// A Destinations object that includes information about each publishing destination returned.
    /// This member is required.
    public var destinations: [GuardDutyClientTypes.Destination]?
    /// A token to use for paginating results that are returned in the response. Set the value of this parameter to null for the first request to a list action. For subsequent calls, use the NextToken value returned from the previous request to continue listing results after the first page.
    public var nextToken: Swift.String?

    public init (
        destinations: [GuardDutyClientTypes.Destination]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.destinations = destinations
        self.nextToken = nextToken
    }
}

struct ListPublishingDestinationsOutputResponseBody: Swift.Equatable {
    let destinations: [GuardDutyClientTypes.Destination]?
    let nextToken: Swift.String?
}

extension ListPublishingDestinationsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinations = "destinations"
        case nextToken = "nextToken"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let destinationsContainer = try containerValues.decodeIfPresent([GuardDutyClientTypes.Destination?].self, forKey: .destinations)
        var destinationsDecoded0:[GuardDutyClientTypes.Destination]? = nil
        if let destinationsContainer = destinationsContainer {
            destinationsDecoded0 = [GuardDutyClientTypes.Destination]()
            for structure0 in destinationsContainer {
                if let structure0 = structure0 {
                    destinationsDecoded0?.append(structure0)
                }
            }
        }
        destinations = destinationsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) for the given GuardDuty resource.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init (
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListTagsForResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListTagsForResourceOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListTagsForResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListTagsForResourceOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutputResponse: Swift.Equatable {
    /// The tags associated with the resource.
    public var tags: [Swift.String:Swift.String]?

    public init (
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputResponseBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension ListTagsForResourceOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension ListThreatIntelSetsInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            if let nextToken = nextToken {
                let nextTokenQueryItem = ClientRuntime.URLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
                items.append(nextTokenQueryItem)
            }
            if let maxResults = maxResults {
                let maxResultsQueryItem = ClientRuntime.URLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
                items.append(maxResultsQueryItem)
            }
            return items
        }
    }
}

extension ListThreatIntelSetsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let detectorId = detectorId else {
            return nil
        }
        return "/detector/\(detectorId.urlPercentEncoding())/threatintelset"
    }
}

public struct ListThreatIntelSetsInput: Swift.Equatable {
    /// The unique ID of the detector that the threatIntelSet is associated with.
    /// This member is required.
    public var detectorId: Swift.String?
    /// You can use this parameter to indicate the maximum number of items that you want in the response. The default value is 50. The maximum value is 50.
    public var maxResults: Swift.Int?
    /// You can use this parameter to paginate results in the response. Set the value of this parameter to null on your first call to the list action. For subsequent calls to the action, fill nextToken in the request with the value of NextToken from the previous response to continue listing data.
    public var nextToken: Swift.String?

    public init (
        detectorId: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.detectorId = detectorId
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListThreatIntelSetsInputBody: Swift.Equatable {
}

extension ListThreatIntelSetsInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension ListThreatIntelSetsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension ListThreatIntelSetsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum ListThreatIntelSetsOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension ListThreatIntelSetsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: ListThreatIntelSetsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.threatIntelSetIds = output.threatIntelSetIds
        } else {
            self.nextToken = nil
            self.threatIntelSetIds = nil
        }
    }
}

public struct ListThreatIntelSetsOutputResponse: Swift.Equatable {
    /// The pagination parameter to be used on the next list operation to retrieve more items.
    public var nextToken: Swift.String?
    /// The IDs of the ThreatIntelSet resources.
    /// This member is required.
    public var threatIntelSetIds: [Swift.String]?

    public init (
        nextToken: Swift.String? = nil,
        threatIntelSetIds: [Swift.String]? = nil
    )
    {
        self.nextToken = nextToken
        self.threatIntelSetIds = threatIntelSetIds
    }
}

struct ListThreatIntelSetsOutputResponseBody: Swift.Equatable {
    let threatIntelSetIds: [Swift.String]?
    let nextToken: Swift.String?
}

extension ListThreatIntelSetsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken = "nextToken"
        case threatIntelSetIds = "threatIntelSetIds"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let threatIntelSetIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .threatIntelSetIds)
        var threatIntelSetIdsDecoded0:[Swift.String]? = nil
        if let threatIntelSetIdsContainer = threatIntelSetIdsContainer {
            threatIntelSetIdsDecoded0 = [Swift.String]()
            for string0 in threatIntelSetIdsContainer {
                if let string0 = string0 {
                    threatIntelSetIdsDecoded0?.append(string0)
                }
            }
        }
        threatIntelSetIds = threatIntelSetIdsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

extension GuardDutyClientTypes.LocalIpDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ipAddressV4 = "ipAddressV4"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ipAddressV4 = self.ipAddressV4 {
            try encodeContainer.encode(ipAddressV4, forKey: .ipAddressV4)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ipAddressV4Decoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ipAddressV4)
        ipAddressV4 = ipAddressV4Decoded
    }
}

extension GuardDutyClientTypes {
    /// Contains information about the local IP address of the connection.
    public struct LocalIpDetails: Swift.Equatable {
        /// The IPv4 local address of the connection.
        public var ipAddressV4: Swift.String?

        public init (
            ipAddressV4: Swift.String? = nil
        )
        {
            self.ipAddressV4 = ipAddressV4
        }
    }

}

extension GuardDutyClientTypes.LocalPortDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case port = "port"
        case portName = "portName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if port != 0 {
            try encodeContainer.encode(port, forKey: .port)
        }
        if let portName = self.portName {
            try encodeContainer.encode(portName, forKey: .portName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let portDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .port) ?? 0
        port = portDecoded
        let portNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .portName)
        portName = portNameDecoded
    }
}

extension GuardDutyClientTypes {
    /// Contains information about the port for the local connection.
    public struct LocalPortDetails: Swift.Equatable {
        /// The port number of the local connection.
        public var port: Swift.Int
        /// The port name of the local connection.
        public var portName: Swift.String?

        public init (
            port: Swift.Int = 0,
            portName: Swift.String? = nil
        )
        {
            self.port = port
            self.portName = portName
        }
    }

}

extension GuardDutyClientTypes.MalwareProtectionConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case scanEc2InstanceWithFindings = "scanEc2InstanceWithFindings"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let scanEc2InstanceWithFindings = self.scanEc2InstanceWithFindings {
            try encodeContainer.encode(scanEc2InstanceWithFindings, forKey: .scanEc2InstanceWithFindings)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scanEc2InstanceWithFindingsDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.ScanEc2InstanceWithFindings.self, forKey: .scanEc2InstanceWithFindings)
        scanEc2InstanceWithFindings = scanEc2InstanceWithFindingsDecoded
    }
}

extension GuardDutyClientTypes {
    /// Describes whether Malware Protection will be enabled as a data source.
    public struct MalwareProtectionConfiguration: Swift.Equatable {
        /// Describes the configuration of Malware Protection for EC2 instances with findings.
        public var scanEc2InstanceWithFindings: GuardDutyClientTypes.ScanEc2InstanceWithFindings?

        public init (
            scanEc2InstanceWithFindings: GuardDutyClientTypes.ScanEc2InstanceWithFindings? = nil
        )
        {
            self.scanEc2InstanceWithFindings = scanEc2InstanceWithFindings
        }
    }

}

extension GuardDutyClientTypes.MalwareProtectionConfigurationResult: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case scanEc2InstanceWithFindings = "scanEc2InstanceWithFindings"
        case serviceRole = "serviceRole"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let scanEc2InstanceWithFindings = self.scanEc2InstanceWithFindings {
            try encodeContainer.encode(scanEc2InstanceWithFindings, forKey: .scanEc2InstanceWithFindings)
        }
        if let serviceRole = self.serviceRole {
            try encodeContainer.encode(serviceRole, forKey: .serviceRole)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scanEc2InstanceWithFindingsDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.ScanEc2InstanceWithFindingsResult.self, forKey: .scanEc2InstanceWithFindings)
        scanEc2InstanceWithFindings = scanEc2InstanceWithFindingsDecoded
        let serviceRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceRole)
        serviceRole = serviceRoleDecoded
    }
}

extension GuardDutyClientTypes {
    /// An object that contains information on the status of all Malware Protection data sources.
    public struct MalwareProtectionConfigurationResult: Swift.Equatable {
        /// Describes the configuration of Malware Protection for EC2 instances with findings.
        public var scanEc2InstanceWithFindings: GuardDutyClientTypes.ScanEc2InstanceWithFindingsResult?
        /// The GuardDuty Malware Protection service role.
        public var serviceRole: Swift.String?

        public init (
            scanEc2InstanceWithFindings: GuardDutyClientTypes.ScanEc2InstanceWithFindingsResult? = nil,
            serviceRole: Swift.String? = nil
        )
        {
            self.scanEc2InstanceWithFindings = scanEc2InstanceWithFindings
            self.serviceRole = serviceRole
        }
    }

}

extension GuardDutyClientTypes.MalwareProtectionDataSourceFreeTrial: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case scanEc2InstanceWithFindings = "scanEc2InstanceWithFindings"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let scanEc2InstanceWithFindings = self.scanEc2InstanceWithFindings {
            try encodeContainer.encode(scanEc2InstanceWithFindings, forKey: .scanEc2InstanceWithFindings)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scanEc2InstanceWithFindingsDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.DataSourceFreeTrial.self, forKey: .scanEc2InstanceWithFindings)
        scanEc2InstanceWithFindings = scanEc2InstanceWithFindingsDecoded
    }
}

extension GuardDutyClientTypes {
    /// Provides details about Malware Protection when it is enabled as a data source.
    public struct MalwareProtectionDataSourceFreeTrial: Swift.Equatable {
        /// Describes whether Malware Protection for EC2 instances with findings is enabled as a data source.
        public var scanEc2InstanceWithFindings: GuardDutyClientTypes.DataSourceFreeTrial?

        public init (
            scanEc2InstanceWithFindings: GuardDutyClientTypes.DataSourceFreeTrial? = nil
        )
        {
            self.scanEc2InstanceWithFindings = scanEc2InstanceWithFindings
        }
    }

}

extension GuardDutyClientTypes.Master: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "accountId"
        case invitationId = "invitationId"
        case invitedAt = "invitedAt"
        case relationshipStatus = "relationshipStatus"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let invitationId = self.invitationId {
            try encodeContainer.encode(invitationId, forKey: .invitationId)
        }
        if let invitedAt = self.invitedAt {
            try encodeContainer.encode(invitedAt, forKey: .invitedAt)
        }
        if let relationshipStatus = self.relationshipStatus {
            try encodeContainer.encode(relationshipStatus, forKey: .relationshipStatus)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let invitationIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .invitationId)
        invitationId = invitationIdDecoded
        let relationshipStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .relationshipStatus)
        relationshipStatus = relationshipStatusDecoded
        let invitedAtDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .invitedAt)
        invitedAt = invitedAtDecoded
    }
}

extension GuardDutyClientTypes {
    /// Contains information about the administrator account and invitation.
    public struct Master: Swift.Equatable {
        /// The ID of the account used as the administrator account.
        public var accountId: Swift.String?
        /// The value used to validate the administrator account to the member account.
        public var invitationId: Swift.String?
        /// The timestamp when the invitation was sent.
        public var invitedAt: Swift.String?
        /// The status of the relationship between the administrator and member accounts.
        public var relationshipStatus: Swift.String?

        public init (
            accountId: Swift.String? = nil,
            invitationId: Swift.String? = nil,
            invitedAt: Swift.String? = nil,
            relationshipStatus: Swift.String? = nil
        )
        {
            self.accountId = accountId
            self.invitationId = invitationId
            self.invitedAt = invitedAt
            self.relationshipStatus = relationshipStatus
        }
    }

}

extension GuardDutyClientTypes.Member: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "accountId"
        case administratorId = "administratorId"
        case detectorId = "detectorId"
        case email = "email"
        case invitedAt = "invitedAt"
        case masterId = "masterId"
        case relationshipStatus = "relationshipStatus"
        case updatedAt = "updatedAt"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let administratorId = self.administratorId {
            try encodeContainer.encode(administratorId, forKey: .administratorId)
        }
        if let detectorId = self.detectorId {
            try encodeContainer.encode(detectorId, forKey: .detectorId)
        }
        if let email = self.email {
            try encodeContainer.encode(email, forKey: .email)
        }
        if let invitedAt = self.invitedAt {
            try encodeContainer.encode(invitedAt, forKey: .invitedAt)
        }
        if let masterId = self.masterId {
            try encodeContainer.encode(masterId, forKey: .masterId)
        }
        if let relationshipStatus = self.relationshipStatus {
            try encodeContainer.encode(relationshipStatus, forKey: .relationshipStatus)
        }
        if let updatedAt = self.updatedAt {
            try encodeContainer.encode(updatedAt, forKey: .updatedAt)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let detectorIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detectorId)
        detectorId = detectorIdDecoded
        let masterIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .masterId)
        masterId = masterIdDecoded
        let emailDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .email)
        email = emailDecoded
        let relationshipStatusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .relationshipStatus)
        relationshipStatus = relationshipStatusDecoded
        let invitedAtDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .invitedAt)
        invitedAt = invitedAtDecoded
        let updatedAtDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let administratorIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .administratorId)
        administratorId = administratorIdDecoded
    }
}

extension GuardDutyClientTypes {
    /// Contains information about the member account.
    public struct Member: Swift.Equatable {
        /// The ID of the member account.
        /// This member is required.
        public var accountId: Swift.String?
        /// The administrator account ID.
        public var administratorId: Swift.String?
        /// The detector ID of the member account.
        public var detectorId: Swift.String?
        /// The email address of the member account.
        /// This member is required.
        public var email: Swift.String?
        /// The timestamp when the invitation was sent.
        public var invitedAt: Swift.String?
        /// The administrator account ID.
        /// This member is required.
        public var masterId: Swift.String?
        /// The status of the relationship between the member and the administrator.
        /// This member is required.
        public var relationshipStatus: Swift.String?
        /// The last-updated timestamp of the member.
        /// This member is required.
        public var updatedAt: Swift.String?

        public init (
            accountId: Swift.String? = nil,
            administratorId: Swift.String? = nil,
            detectorId: Swift.String? = nil,
            email: Swift.String? = nil,
            invitedAt: Swift.String? = nil,
            masterId: Swift.String? = nil,
            relationshipStatus: Swift.String? = nil,
            updatedAt: Swift.String? = nil
        )
        {
            self.accountId = accountId
            self.administratorId = administratorId
            self.detectorId = detectorId
            self.email = email
            self.invitedAt = invitedAt
            self.masterId = masterId
            self.relationshipStatus = relationshipStatus
            self.updatedAt = updatedAt
        }
    }

}

extension GuardDutyClientTypes.MemberDataSourceConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "accountId"
        case dataSources = "dataSources"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let dataSources = self.dataSources {
            try encodeContainer.encode(dataSources, forKey: .dataSources)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let dataSourcesDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.DataSourceConfigurationsResult.self, forKey: .dataSources)
        dataSources = dataSourcesDecoded
    }
}

extension GuardDutyClientTypes {
    /// Contains information on which data sources are enabled for a member account.
    public struct MemberDataSourceConfiguration: Swift.Equatable {
        /// The account ID for the member account.
        /// This member is required.
        public var accountId: Swift.String?
        /// Contains information on the status of data sources for the account.
        /// This member is required.
        public var dataSources: GuardDutyClientTypes.DataSourceConfigurationsResult?

        public init (
            accountId: Swift.String? = nil,
            dataSources: GuardDutyClientTypes.DataSourceConfigurationsResult? = nil
        )
        {
            self.accountId = accountId
            self.dataSources = dataSources
        }
    }

}

extension GuardDutyClientTypes.NetworkConnectionAction: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case blocked = "blocked"
        case connectionDirection = "connectionDirection"
        case localIpDetails = "localIpDetails"
        case localPortDetails = "localPortDetails"
        case `protocol` = "protocol"
        case remoteIpDetails = "remoteIpDetails"
        case remotePortDetails = "remotePortDetails"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if blocked != false {
            try encodeContainer.encode(blocked, forKey: .blocked)
        }
        if let connectionDirection = self.connectionDirection {
            try encodeContainer.encode(connectionDirection, forKey: .connectionDirection)
        }
        if let localIpDetails = self.localIpDetails {
            try encodeContainer.encode(localIpDetails, forKey: .localIpDetails)
        }
        if let localPortDetails = self.localPortDetails {
            try encodeContainer.encode(localPortDetails, forKey: .localPortDetails)
        }
        if let `protocol` = self.`protocol` {
            try encodeContainer.encode(`protocol`, forKey: .`protocol`)
        }
        if let remoteIpDetails = self.remoteIpDetails {
            try encodeContainer.encode(remoteIpDetails, forKey: .remoteIpDetails)
        }
        if let remotePortDetails = self.remotePortDetails {
            try encodeContainer.encode(remotePortDetails, forKey: .remotePortDetails)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let blockedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .blocked) ?? false
        blocked = blockedDecoded
        let connectionDirectionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .connectionDirection)
        connectionDirection = connectionDirectionDecoded
        let localPortDetailsDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.LocalPortDetails.self, forKey: .localPortDetails)
        localPortDetails = localPortDetailsDecoded
        let protocolDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .protocol)
        `protocol` = protocolDecoded
        let localIpDetailsDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.LocalIpDetails.self, forKey: .localIpDetails)
        localIpDetails = localIpDetailsDecoded
        let remoteIpDetailsDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.RemoteIpDetails.self, forKey: .remoteIpDetails)
        remoteIpDetails = remoteIpDetailsDecoded
        let remotePortDetailsDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.RemotePortDetails.self, forKey: .remotePortDetails)
        remotePortDetails = remotePortDetailsDecoded
    }
}

extension GuardDutyClientTypes {
    /// Contains information about the NETWORK_CONNECTION action described in the finding.
    public struct NetworkConnectionAction: Swift.Equatable {
        /// Indicates whether EC2 blocked the network connection to your instance.
        public var blocked: Swift.Bool
        /// The network connection direction.
        public var connectionDirection: Swift.String?
        /// The local IP information of the connection.
        public var localIpDetails: GuardDutyClientTypes.LocalIpDetails?
        /// The local port information of the connection.
        public var localPortDetails: GuardDutyClientTypes.LocalPortDetails?
        /// The network connection protocol.
        public var `protocol`: Swift.String?
        /// The remote IP information of the connection.
        public var remoteIpDetails: GuardDutyClientTypes.RemoteIpDetails?
        /// The remote port information of the connection.
        public var remotePortDetails: GuardDutyClientTypes.RemotePortDetails?

        public init (
            blocked: Swift.Bool = false,
            connectionDirection: Swift.String? = nil,
            localIpDetails: GuardDutyClientTypes.LocalIpDetails? = nil,
            localPortDetails: GuardDutyClientTypes.LocalPortDetails? = nil,
            `protocol`: Swift.String? = nil,
            remoteIpDetails: GuardDutyClientTypes.RemoteIpDetails? = nil,
            remotePortDetails: GuardDutyClientTypes.RemotePortDetails? = nil
        )
        {
            self.blocked = blocked
            self.connectionDirection = connectionDirection
            self.localIpDetails = localIpDetails
            self.localPortDetails = localPortDetails
            self.`protocol` = `protocol`
            self.remoteIpDetails = remoteIpDetails
            self.remotePortDetails = remotePortDetails
        }
    }

}

extension GuardDutyClientTypes.NetworkInterface: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ipv6Addresses = "ipv6Addresses"
        case networkInterfaceId = "networkInterfaceId"
        case privateDnsName = "privateDnsName"
        case privateIpAddress = "privateIpAddress"
        case privateIpAddresses = "privateIpAddresses"
        case publicDnsName = "publicDnsName"
        case publicIp = "publicIp"
        case securityGroups = "securityGroups"
        case subnetId = "subnetId"
        case vpcId = "vpcId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ipv6Addresses = ipv6Addresses {
            var ipv6AddressesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ipv6Addresses)
            for string0 in ipv6Addresses {
                try ipv6AddressesContainer.encode(string0)
            }
        }
        if let networkInterfaceId = self.networkInterfaceId {
            try encodeContainer.encode(networkInterfaceId, forKey: .networkInterfaceId)
        }
        if let privateDnsName = self.privateDnsName {
            try encodeContainer.encode(privateDnsName, forKey: .privateDnsName)
        }
        if let privateIpAddress = self.privateIpAddress {
            try encodeContainer.encode(privateIpAddress, forKey: .privateIpAddress)
        }
        if let privateIpAddresses = privateIpAddresses {
            var privateIpAddressesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .privateIpAddresses)
            for privateipaddressdetails0 in privateIpAddresses {
                try privateIpAddressesContainer.encode(privateipaddressdetails0)
            }
        }
        if let publicDnsName = self.publicDnsName {
            try encodeContainer.encode(publicDnsName, forKey: .publicDnsName)
        }
        if let publicIp = self.publicIp {
            try encodeContainer.encode(publicIp, forKey: .publicIp)
        }
        if let securityGroups = securityGroups {
            var securityGroupsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .securityGroups)
            for securitygroup0 in securityGroups {
                try securityGroupsContainer.encode(securitygroup0)
            }
        }
        if let subnetId = self.subnetId {
            try encodeContainer.encode(subnetId, forKey: .subnetId)
        }
        if let vpcId = self.vpcId {
            try encodeContainer.encode(vpcId, forKey: .vpcId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ipv6AddressesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .ipv6Addresses)
        var ipv6AddressesDecoded0:[Swift.String]? = nil
        if let ipv6AddressesContainer = ipv6AddressesContainer {
            ipv6AddressesDecoded0 = [Swift.String]()
            for string0 in ipv6AddressesContainer {
                if let string0 = string0 {
                    ipv6AddressesDecoded0?.append(string0)
                }
            }
        }
        ipv6Addresses = ipv6AddressesDecoded0
        let networkInterfaceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .networkInterfaceId)
        networkInterfaceId = networkInterfaceIdDecoded
        let privateDnsNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .privateDnsName)
        privateDnsName = privateDnsNameDecoded
        let privateIpAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .privateIpAddress)
        privateIpAddress = privateIpAddressDecoded
        let privateIpAddressesContainer = try containerValues.decodeIfPresent([GuardDutyClientTypes.PrivateIpAddressDetails?].self, forKey: .privateIpAddresses)
        var privateIpAddressesDecoded0:[GuardDutyClientTypes.PrivateIpAddressDetails]? = nil
        if let privateIpAddressesContainer = privateIpAddressesContainer {
            privateIpAddressesDecoded0 = [GuardDutyClientTypes.PrivateIpAddressDetails]()
            for structure0 in privateIpAddressesContainer {
                if let structure0 = structure0 {
                    privateIpAddressesDecoded0?.append(structure0)
                }
            }
        }
        privateIpAddresses = privateIpAddressesDecoded0
        let publicDnsNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .publicDnsName)
        publicDnsName = publicDnsNameDecoded
        let publicIpDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .publicIp)
        publicIp = publicIpDecoded
        let securityGroupsContainer = try containerValues.decodeIfPresent([GuardDutyClientTypes.SecurityGroup?].self, forKey: .securityGroups)
        var securityGroupsDecoded0:[GuardDutyClientTypes.SecurityGroup]? = nil
        if let securityGroupsContainer = securityGroupsContainer {
            securityGroupsDecoded0 = [GuardDutyClientTypes.SecurityGroup]()
            for structure0 in securityGroupsContainer {
                if let structure0 = structure0 {
                    securityGroupsDecoded0?.append(structure0)
                }
            }
        }
        securityGroups = securityGroupsDecoded0
        let subnetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .subnetId)
        subnetId = subnetIdDecoded
        let vpcIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vpcId)
        vpcId = vpcIdDecoded
    }
}

extension GuardDutyClientTypes {
    /// Contains information about the elastic network interface of the EC2 instance.
    public struct NetworkInterface: Swift.Equatable {
        /// A list of IPv6 addresses for the EC2 instance.
        public var ipv6Addresses: [Swift.String]?
        /// The ID of the network interface.
        public var networkInterfaceId: Swift.String?
        /// The private DNS name of the EC2 instance.
        public var privateDnsName: Swift.String?
        /// The private IP address of the EC2 instance.
        public var privateIpAddress: Swift.String?
        /// Other private IP address information of the EC2 instance.
        public var privateIpAddresses: [GuardDutyClientTypes.PrivateIpAddressDetails]?
        /// The public DNS name of the EC2 instance.
        public var publicDnsName: Swift.String?
        /// The public IP address of the EC2 instance.
        public var publicIp: Swift.String?
        /// The security groups associated with the EC2 instance.
        public var securityGroups: [GuardDutyClientTypes.SecurityGroup]?
        /// The subnet ID of the EC2 instance.
        public var subnetId: Swift.String?
        /// The VPC ID of the EC2 instance.
        public var vpcId: Swift.String?

        public init (
            ipv6Addresses: [Swift.String]? = nil,
            networkInterfaceId: Swift.String? = nil,
            privateDnsName: Swift.String? = nil,
            privateIpAddress: Swift.String? = nil,
            privateIpAddresses: [GuardDutyClientTypes.PrivateIpAddressDetails]? = nil,
            publicDnsName: Swift.String? = nil,
            publicIp: Swift.String? = nil,
            securityGroups: [GuardDutyClientTypes.SecurityGroup]? = nil,
            subnetId: Swift.String? = nil,
            vpcId: Swift.String? = nil
        )
        {
            self.ipv6Addresses = ipv6Addresses
            self.networkInterfaceId = networkInterfaceId
            self.privateDnsName = privateDnsName
            self.privateIpAddress = privateIpAddress
            self.privateIpAddresses = privateIpAddresses
            self.publicDnsName = publicDnsName
            self.publicIp = publicIp
            self.securityGroups = securityGroups
            self.subnetId = subnetId
            self.vpcId = vpcId
        }
    }

}

extension GuardDutyClientTypes {
    public enum OrderBy: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case asc
        case desc
        case sdkUnknown(Swift.String)

        public static var allCases: [OrderBy] {
            return [
                .asc,
                .desc,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .asc: return "ASC"
            case .desc: return "DESC"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = OrderBy(rawValue: rawValue) ?? OrderBy.sdkUnknown(rawValue)
        }
    }
}

extension GuardDutyClientTypes.Organization: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case asn = "asn"
        case asnOrg = "asnOrg"
        case isp = "isp"
        case org = "org"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let asn = self.asn {
            try encodeContainer.encode(asn, forKey: .asn)
        }
        if let asnOrg = self.asnOrg {
            try encodeContainer.encode(asnOrg, forKey: .asnOrg)
        }
        if let isp = self.isp {
            try encodeContainer.encode(isp, forKey: .isp)
        }
        if let org = self.org {
            try encodeContainer.encode(org, forKey: .org)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let asnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .asn)
        asn = asnDecoded
        let asnOrgDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .asnOrg)
        asnOrg = asnOrgDecoded
        let ispDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .isp)
        isp = ispDecoded
        let orgDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .org)
        org = orgDecoded
    }
}

extension GuardDutyClientTypes {
    /// Contains information about the ISP organization of the remote IP address.
    public struct Organization: Swift.Equatable {
        /// The Autonomous System Number (ASN) of the internet provider of the remote IP address.
        public var asn: Swift.String?
        /// The organization that registered this ASN.
        public var asnOrg: Swift.String?
        /// The ISP information for the internet provider.
        public var isp: Swift.String?
        /// The name of the internet provider.
        public var org: Swift.String?

        public init (
            asn: Swift.String? = nil,
            asnOrg: Swift.String? = nil,
            isp: Swift.String? = nil,
            org: Swift.String? = nil
        )
        {
            self.asn = asn
            self.asnOrg = asnOrg
            self.isp = isp
            self.org = org
        }
    }

}

extension GuardDutyClientTypes.OrganizationDataSourceConfigurations: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case kubernetes = "kubernetes"
        case malwareProtection = "malwareProtection"
        case s3Logs = "s3Logs"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let kubernetes = self.kubernetes {
            try encodeContainer.encode(kubernetes, forKey: .kubernetes)
        }
        if let malwareProtection = self.malwareProtection {
            try encodeContainer.encode(malwareProtection, forKey: .malwareProtection)
        }
        if let s3Logs = self.s3Logs {
            try encodeContainer.encode(s3Logs, forKey: .s3Logs)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3LogsDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.OrganizationS3LogsConfiguration.self, forKey: .s3Logs)
        s3Logs = s3LogsDecoded
        let kubernetesDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.OrganizationKubernetesConfiguration.self, forKey: .kubernetes)
        kubernetes = kubernetesDecoded
        let malwareProtectionDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.OrganizationMalwareProtectionConfiguration.self, forKey: .malwareProtection)
        malwareProtection = malwareProtectionDecoded
    }
}

extension GuardDutyClientTypes {
    /// An object that contains information on which data sources will be configured to be automatically enabled for new members within the organization.
    public struct OrganizationDataSourceConfigurations: Swift.Equatable {
        /// Describes the configuration of Kubernetes data sources for new members of the organization.
        public var kubernetes: GuardDutyClientTypes.OrganizationKubernetesConfiguration?
        /// Describes the configuration of Malware Protection for new members of the organization.
        public var malwareProtection: GuardDutyClientTypes.OrganizationMalwareProtectionConfiguration?
        /// Describes whether S3 data event logs are enabled for new members of the organization.
        public var s3Logs: GuardDutyClientTypes.OrganizationS3LogsConfiguration?

        public init (
            kubernetes: GuardDutyClientTypes.OrganizationKubernetesConfiguration? = nil,
            malwareProtection: GuardDutyClientTypes.OrganizationMalwareProtectionConfiguration? = nil,
            s3Logs: GuardDutyClientTypes.OrganizationS3LogsConfiguration? = nil
        )
        {
            self.kubernetes = kubernetes
            self.malwareProtection = malwareProtection
            self.s3Logs = s3Logs
        }
    }

}

extension GuardDutyClientTypes.OrganizationDataSourceConfigurationsResult: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case kubernetes = "kubernetes"
        case malwareProtection = "malwareProtection"
        case s3Logs = "s3Logs"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let kubernetes = self.kubernetes {
            try encodeContainer.encode(kubernetes, forKey: .kubernetes)
        }
        if let malwareProtection = self.malwareProtection {
            try encodeContainer.encode(malwareProtection, forKey: .malwareProtection)
        }
        if let s3Logs = self.s3Logs {
            try encodeContainer.encode(s3Logs, forKey: .s3Logs)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let s3LogsDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.OrganizationS3LogsConfigurationResult.self, forKey: .s3Logs)
        s3Logs = s3LogsDecoded
        let kubernetesDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.OrganizationKubernetesConfigurationResult.self, forKey: .kubernetes)
        kubernetes = kubernetesDecoded
        let malwareProtectionDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.OrganizationMalwareProtectionConfigurationResult.self, forKey: .malwareProtection)
        malwareProtection = malwareProtectionDecoded
    }
}

extension GuardDutyClientTypes {
    /// An object that contains information on which data sources are automatically enabled for new members within the organization.
    public struct OrganizationDataSourceConfigurationsResult: Swift.Equatable {
        /// Describes the configuration of Kubernetes data sources.
        public var kubernetes: GuardDutyClientTypes.OrganizationKubernetesConfigurationResult?
        /// Describes the configuration of Malware Protection data source for an organization.
        public var malwareProtection: GuardDutyClientTypes.OrganizationMalwareProtectionConfigurationResult?
        /// Describes whether S3 data event logs are enabled as a data source.
        /// This member is required.
        public var s3Logs: GuardDutyClientTypes.OrganizationS3LogsConfigurationResult?

        public init (
            kubernetes: GuardDutyClientTypes.OrganizationKubernetesConfigurationResult? = nil,
            malwareProtection: GuardDutyClientTypes.OrganizationMalwareProtectionConfigurationResult? = nil,
            s3Logs: GuardDutyClientTypes.OrganizationS3LogsConfigurationResult? = nil
        )
        {
            self.kubernetes = kubernetes
            self.malwareProtection = malwareProtection
            self.s3Logs = s3Logs
        }
    }

}

extension GuardDutyClientTypes.OrganizationEbsVolumes: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoEnable = "autoEnable"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if autoEnable != false {
            try encodeContainer.encode(autoEnable, forKey: .autoEnable)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let autoEnableDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .autoEnable) ?? false
        autoEnable = autoEnableDecoded
    }
}

extension GuardDutyClientTypes {
    /// Organization-wide EBS volumes scan configuration.
    public struct OrganizationEbsVolumes: Swift.Equatable {
        /// Whether scanning EBS volumes should be auto-enabled for new members joining the organization.
        public var autoEnable: Swift.Bool

        public init (
            autoEnable: Swift.Bool = false
        )
        {
            self.autoEnable = autoEnable
        }
    }

}

extension GuardDutyClientTypes.OrganizationEbsVolumesResult: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoEnable = "autoEnable"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if autoEnable != false {
            try encodeContainer.encode(autoEnable, forKey: .autoEnable)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let autoEnableDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .autoEnable) ?? false
        autoEnable = autoEnableDecoded
    }
}

extension GuardDutyClientTypes {
    /// An object that contains information on the status of whether EBS volumes scanning will be enabled as a data source for an organization.
    public struct OrganizationEbsVolumesResult: Swift.Equatable {
        /// An object that contains the status of whether scanning EBS volumes should be auto-enabled for new members joining the organization.
        public var autoEnable: Swift.Bool

        public init (
            autoEnable: Swift.Bool = false
        )
        {
            self.autoEnable = autoEnable
        }
    }

}

extension GuardDutyClientTypes.OrganizationKubernetesAuditLogsConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoEnable = "autoEnable"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if autoEnable != false {
            try encodeContainer.encode(autoEnable, forKey: .autoEnable)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let autoEnableDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .autoEnable) ?? false
        autoEnable = autoEnableDecoded
    }
}

extension GuardDutyClientTypes {
    /// Organization-wide Kubernetes audit logs configuration.
    public struct OrganizationKubernetesAuditLogsConfiguration: Swift.Equatable {
        /// A value that contains information on whether Kubernetes audit logs should be enabled automatically as a data source for the organization.
        /// This member is required.
        public var autoEnable: Swift.Bool

        public init (
            autoEnable: Swift.Bool = false
        )
        {
            self.autoEnable = autoEnable
        }
    }

}

extension GuardDutyClientTypes.OrganizationKubernetesAuditLogsConfigurationResult: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoEnable = "autoEnable"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if autoEnable != false {
            try encodeContainer.encode(autoEnable, forKey: .autoEnable)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let autoEnableDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .autoEnable) ?? false
        autoEnable = autoEnableDecoded
    }
}

extension GuardDutyClientTypes {
    /// The current configuration of Kubernetes audit logs as a data source for the organization.
    public struct OrganizationKubernetesAuditLogsConfigurationResult: Swift.Equatable {
        /// Whether Kubernetes audit logs data source should be auto-enabled for new members joining the organization.
        /// This member is required.
        public var autoEnable: Swift.Bool

        public init (
            autoEnable: Swift.Bool = false
        )
        {
            self.autoEnable = autoEnable
        }
    }

}

extension GuardDutyClientTypes.OrganizationKubernetesConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case auditLogs = "auditLogs"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let auditLogs = self.auditLogs {
            try encodeContainer.encode(auditLogs, forKey: .auditLogs)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let auditLogsDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.OrganizationKubernetesAuditLogsConfiguration.self, forKey: .auditLogs)
        auditLogs = auditLogsDecoded
    }
}

extension GuardDutyClientTypes {
    /// Organization-wide Kubernetes data sources configurations.
    public struct OrganizationKubernetesConfiguration: Swift.Equatable {
        /// Whether Kubernetes audit logs data source should be auto-enabled for new members joining the organization.
        /// This member is required.
        public var auditLogs: GuardDutyClientTypes.OrganizationKubernetesAuditLogsConfiguration?

        public init (
            auditLogs: GuardDutyClientTypes.OrganizationKubernetesAuditLogsConfiguration? = nil
        )
        {
            self.auditLogs = auditLogs
        }
    }

}

extension GuardDutyClientTypes.OrganizationKubernetesConfigurationResult: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case auditLogs = "auditLogs"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let auditLogs = self.auditLogs {
            try encodeContainer.encode(auditLogs, forKey: .auditLogs)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let auditLogsDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.OrganizationKubernetesAuditLogsConfigurationResult.self, forKey: .auditLogs)
        auditLogs = auditLogsDecoded
    }
}

extension GuardDutyClientTypes {
    /// The current configuration of all Kubernetes data sources for the organization.
    public struct OrganizationKubernetesConfigurationResult: Swift.Equatable {
        /// The current configuration of Kubernetes audit logs as a data source for the organization.
        /// This member is required.
        public var auditLogs: GuardDutyClientTypes.OrganizationKubernetesAuditLogsConfigurationResult?

        public init (
            auditLogs: GuardDutyClientTypes.OrganizationKubernetesAuditLogsConfigurationResult? = nil
        )
        {
            self.auditLogs = auditLogs
        }
    }

}

extension GuardDutyClientTypes.OrganizationMalwareProtectionConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case scanEc2InstanceWithFindings = "scanEc2InstanceWithFindings"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let scanEc2InstanceWithFindings = self.scanEc2InstanceWithFindings {
            try encodeContainer.encode(scanEc2InstanceWithFindings, forKey: .scanEc2InstanceWithFindings)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scanEc2InstanceWithFindingsDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.OrganizationScanEc2InstanceWithFindings.self, forKey: .scanEc2InstanceWithFindings)
        scanEc2InstanceWithFindings = scanEc2InstanceWithFindingsDecoded
    }
}

extension GuardDutyClientTypes {
    /// Organization-wide Malware Protection configurations.
    public struct OrganizationMalwareProtectionConfiguration: Swift.Equatable {
        /// Whether Malware Protection for EC2 instances with findings should be auto-enabled for new members joining the organization.
        public var scanEc2InstanceWithFindings: GuardDutyClientTypes.OrganizationScanEc2InstanceWithFindings?

        public init (
            scanEc2InstanceWithFindings: GuardDutyClientTypes.OrganizationScanEc2InstanceWithFindings? = nil
        )
        {
            self.scanEc2InstanceWithFindings = scanEc2InstanceWithFindings
        }
    }

}

extension GuardDutyClientTypes.OrganizationMalwareProtectionConfigurationResult: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case scanEc2InstanceWithFindings = "scanEc2InstanceWithFindings"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let scanEc2InstanceWithFindings = self.scanEc2InstanceWithFindings {
            try encodeContainer.encode(scanEc2InstanceWithFindings, forKey: .scanEc2InstanceWithFindings)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scanEc2InstanceWithFindingsDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.OrganizationScanEc2InstanceWithFindingsResult.self, forKey: .scanEc2InstanceWithFindings)
        scanEc2InstanceWithFindings = scanEc2InstanceWithFindingsDecoded
    }
}

extension GuardDutyClientTypes {
    /// An object that contains information on the status of all Malware Protection data source for an organization.
    public struct OrganizationMalwareProtectionConfigurationResult: Swift.Equatable {
        /// Describes the configuration for scanning EC2 instances with findings for an organization.
        public var scanEc2InstanceWithFindings: GuardDutyClientTypes.OrganizationScanEc2InstanceWithFindingsResult?

        public init (
            scanEc2InstanceWithFindings: GuardDutyClientTypes.OrganizationScanEc2InstanceWithFindingsResult? = nil
        )
        {
            self.scanEc2InstanceWithFindings = scanEc2InstanceWithFindings
        }
    }

}

extension GuardDutyClientTypes.OrganizationS3LogsConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoEnable = "autoEnable"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if autoEnable != false {
            try encodeContainer.encode(autoEnable, forKey: .autoEnable)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let autoEnableDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .autoEnable) ?? false
        autoEnable = autoEnableDecoded
    }
}

extension GuardDutyClientTypes {
    /// Describes whether S3 data event logs will be automatically enabled for new members of the organization.
    public struct OrganizationS3LogsConfiguration: Swift.Equatable {
        /// A value that contains information on whether S3 data event logs will be enabled automatically as a data source for the organization.
        /// This member is required.
        public var autoEnable: Swift.Bool

        public init (
            autoEnable: Swift.Bool = false
        )
        {
            self.autoEnable = autoEnable
        }
    }

}

extension GuardDutyClientTypes.OrganizationS3LogsConfigurationResult: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoEnable = "autoEnable"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if autoEnable != false {
            try encodeContainer.encode(autoEnable, forKey: .autoEnable)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let autoEnableDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .autoEnable) ?? false
        autoEnable = autoEnableDecoded
    }
}

extension GuardDutyClientTypes {
    /// The current configuration of S3 data event logs as a data source for the organization.
    public struct OrganizationS3LogsConfigurationResult: Swift.Equatable {
        /// A value that describes whether S3 data event logs are automatically enabled for new members of the organization.
        /// This member is required.
        public var autoEnable: Swift.Bool

        public init (
            autoEnable: Swift.Bool = false
        )
        {
            self.autoEnable = autoEnable
        }
    }

}

extension GuardDutyClientTypes.OrganizationScanEc2InstanceWithFindings: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ebsVolumes = "ebsVolumes"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ebsVolumes = self.ebsVolumes {
            try encodeContainer.encode(ebsVolumes, forKey: .ebsVolumes)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ebsVolumesDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.OrganizationEbsVolumes.self, forKey: .ebsVolumes)
        ebsVolumes = ebsVolumesDecoded
    }
}

extension GuardDutyClientTypes {
    /// Organization-wide EC2 instances with findings scan configuration.
    public struct OrganizationScanEc2InstanceWithFindings: Swift.Equatable {
        /// Whether scanning EBS volumes should be auto-enabled for new members joining the organization.
        public var ebsVolumes: GuardDutyClientTypes.OrganizationEbsVolumes?

        public init (
            ebsVolumes: GuardDutyClientTypes.OrganizationEbsVolumes? = nil
        )
        {
            self.ebsVolumes = ebsVolumes
        }
    }

}

extension GuardDutyClientTypes.OrganizationScanEc2InstanceWithFindingsResult: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ebsVolumes = "ebsVolumes"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ebsVolumes = self.ebsVolumes {
            try encodeContainer.encode(ebsVolumes, forKey: .ebsVolumes)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ebsVolumesDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.OrganizationEbsVolumesResult.self, forKey: .ebsVolumes)
        ebsVolumes = ebsVolumesDecoded
    }
}

extension GuardDutyClientTypes {
    /// An object that contains information on the status of scanning EC2 instances with findings for an organization.
    public struct OrganizationScanEc2InstanceWithFindingsResult: Swift.Equatable {
        /// Describes the configuration for scanning EBS volumes for an organization.
        public var ebsVolumes: GuardDutyClientTypes.OrganizationEbsVolumesResult?

        public init (
            ebsVolumes: GuardDutyClientTypes.OrganizationEbsVolumesResult? = nil
        )
        {
            self.ebsVolumes = ebsVolumes
        }
    }

}

extension GuardDutyClientTypes.Owner: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case id = "id"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
    }
}

extension GuardDutyClientTypes {
    /// Contains information on the owner of the bucket.
    public struct Owner: Swift.Equatable {
        /// The canonical user ID of the bucket owner. For information about locating your canonical user ID see [Finding Your Account Canonical User ID.](https://docs.aws.amazon.com/general/latest/gr/acct-identifiers.html#FindingCanonicalId)
        public var id: Swift.String?

        public init (
            id: Swift.String? = nil
        )
        {
            self.id = id
        }
    }

}

extension GuardDutyClientTypes.PermissionConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountLevelPermissions = "accountLevelPermissions"
        case bucketLevelPermissions = "bucketLevelPermissions"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountLevelPermissions = self.accountLevelPermissions {
            try encodeContainer.encode(accountLevelPermissions, forKey: .accountLevelPermissions)
        }
        if let bucketLevelPermissions = self.bucketLevelPermissions {
            try encodeContainer.encode(bucketLevelPermissions, forKey: .bucketLevelPermissions)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let bucketLevelPermissionsDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.BucketLevelPermissions.self, forKey: .bucketLevelPermissions)
        bucketLevelPermissions = bucketLevelPermissionsDecoded
        let accountLevelPermissionsDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.AccountLevelPermissions.self, forKey: .accountLevelPermissions)
        accountLevelPermissions = accountLevelPermissionsDecoded
    }
}

extension GuardDutyClientTypes {
    /// Contains information about how permissions are configured for the S3 bucket.
    public struct PermissionConfiguration: Swift.Equatable {
        /// Contains information about the account level permissions on the S3 bucket.
        public var accountLevelPermissions: GuardDutyClientTypes.AccountLevelPermissions?
        /// Contains information about the bucket level permissions for the S3 bucket.
        public var bucketLevelPermissions: GuardDutyClientTypes.BucketLevelPermissions?

        public init (
            accountLevelPermissions: GuardDutyClientTypes.AccountLevelPermissions? = nil,
            bucketLevelPermissions: GuardDutyClientTypes.BucketLevelPermissions? = nil
        )
        {
            self.accountLevelPermissions = accountLevelPermissions
            self.bucketLevelPermissions = bucketLevelPermissions
        }
    }

}

extension GuardDutyClientTypes.PortProbeAction: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case blocked = "blocked"
        case portProbeDetails = "portProbeDetails"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if blocked != false {
            try encodeContainer.encode(blocked, forKey: .blocked)
        }
        if let portProbeDetails = portProbeDetails {
            var portProbeDetailsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .portProbeDetails)
            for portprobedetail0 in portProbeDetails {
                try portProbeDetailsContainer.encode(portprobedetail0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let blockedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .blocked) ?? false
        blocked = blockedDecoded
        let portProbeDetailsContainer = try containerValues.decodeIfPresent([GuardDutyClientTypes.PortProbeDetail?].self, forKey: .portProbeDetails)
        var portProbeDetailsDecoded0:[GuardDutyClientTypes.PortProbeDetail]? = nil
        if let portProbeDetailsContainer = portProbeDetailsContainer {
            portProbeDetailsDecoded0 = [GuardDutyClientTypes.PortProbeDetail]()
            for structure0 in portProbeDetailsContainer {
                if let structure0 = structure0 {
                    portProbeDetailsDecoded0?.append(structure0)
                }
            }
        }
        portProbeDetails = portProbeDetailsDecoded0
    }
}

extension GuardDutyClientTypes {
    /// Contains information about the PORT_PROBE action described in the finding.
    public struct PortProbeAction: Swift.Equatable {
        /// Indicates whether EC2 blocked the port probe to the instance, such as with an ACL.
        public var blocked: Swift.Bool
        /// A list of objects related to port probe details.
        public var portProbeDetails: [GuardDutyClientTypes.PortProbeDetail]?

        public init (
            blocked: Swift.Bool = false,
            portProbeDetails: [GuardDutyClientTypes.PortProbeDetail]? = nil
        )
        {
            self.blocked = blocked
            self.portProbeDetails = portProbeDetails
        }
    }

}

extension GuardDutyClientTypes.PortProbeDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case localIpDetails = "localIpDetails"
        case localPortDetails = "localPortDetails"
        case remoteIpDetails = "remoteIpDetails"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let localIpDetails = self.localIpDetails {
            try encodeContainer.encode(localIpDetails, forKey: .localIpDetails)
        }
        if let localPortDetails = self.localPortDetails {
            try encodeContainer.encode(localPortDetails, forKey: .localPortDetails)
        }
        if let remoteIpDetails = self.remoteIpDetails {
            try encodeContainer.encode(remoteIpDetails, forKey: .remoteIpDetails)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let localPortDetailsDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.LocalPortDetails.self, forKey: .localPortDetails)
        localPortDetails = localPortDetailsDecoded
        let localIpDetailsDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.LocalIpDetails.self, forKey: .localIpDetails)
        localIpDetails = localIpDetailsDecoded
        let remoteIpDetailsDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.RemoteIpDetails.self, forKey: .remoteIpDetails)
        remoteIpDetails = remoteIpDetailsDecoded
    }
}

extension GuardDutyClientTypes {
    /// Contains information about the port probe details.
    public struct PortProbeDetail: Swift.Equatable {
        /// The local IP information of the connection.
        public var localIpDetails: GuardDutyClientTypes.LocalIpDetails?
        /// The local port information of the connection.
        public var localPortDetails: GuardDutyClientTypes.LocalPortDetails?
        /// The remote IP information of the connection.
        public var remoteIpDetails: GuardDutyClientTypes.RemoteIpDetails?

        public init (
            localIpDetails: GuardDutyClientTypes.LocalIpDetails? = nil,
            localPortDetails: GuardDutyClientTypes.LocalPortDetails? = nil,
            remoteIpDetails: GuardDutyClientTypes.RemoteIpDetails? = nil
        )
        {
            self.localIpDetails = localIpDetails
            self.localPortDetails = localPortDetails
            self.remoteIpDetails = remoteIpDetails
        }
    }

}

extension GuardDutyClientTypes.PrivateIpAddressDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case privateDnsName = "privateDnsName"
        case privateIpAddress = "privateIpAddress"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let privateDnsName = self.privateDnsName {
            try encodeContainer.encode(privateDnsName, forKey: .privateDnsName)
        }
        if let privateIpAddress = self.privateIpAddress {
            try encodeContainer.encode(privateIpAddress, forKey: .privateIpAddress)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let privateDnsNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .privateDnsName)
        privateDnsName = privateDnsNameDecoded
        let privateIpAddressDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .privateIpAddress)
        privateIpAddress = privateIpAddressDecoded
    }
}

extension GuardDutyClientTypes {
    /// Contains other private IP address information of the EC2 instance.
    public struct PrivateIpAddressDetails: Swift.Equatable {
        /// The private DNS name of the EC2 instance.
        public var privateDnsName: Swift.String?
        /// The private IP address of the EC2 instance.
        public var privateIpAddress: Swift.String?

        public init (
            privateDnsName: Swift.String? = nil,
            privateIpAddress: Swift.String? = nil
        )
        {
            self.privateDnsName = privateDnsName
            self.privateIpAddress = privateIpAddress
        }
    }

}

extension GuardDutyClientTypes.ProductCode: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case code = "productCodeId"
        case productType = "productCodeType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let code = self.code {
            try encodeContainer.encode(code, forKey: .code)
        }
        if let productType = self.productType {
            try encodeContainer.encode(productType, forKey: .productType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let codeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .code)
        code = codeDecoded
        let productTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .productType)
        productType = productTypeDecoded
    }
}

extension GuardDutyClientTypes {
    /// Contains information about the product code for the EC2 instance.
    public struct ProductCode: Swift.Equatable {
        /// The product code information.
        public var code: Swift.String?
        /// The product code type.
        public var productType: Swift.String?

        public init (
            code: Swift.String? = nil,
            productType: Swift.String? = nil
        )
        {
            self.code = code
            self.productType = productType
        }
    }

}

extension GuardDutyClientTypes.PublicAccess: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case effectivePermission = "effectivePermission"
        case permissionConfiguration = "permissionConfiguration"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let effectivePermission = self.effectivePermission {
            try encodeContainer.encode(effectivePermission, forKey: .effectivePermission)
        }
        if let permissionConfiguration = self.permissionConfiguration {
            try encodeContainer.encode(permissionConfiguration, forKey: .permissionConfiguration)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let permissionConfigurationDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.PermissionConfiguration.self, forKey: .permissionConfiguration)
        permissionConfiguration = permissionConfigurationDecoded
        let effectivePermissionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .effectivePermission)
        effectivePermission = effectivePermissionDecoded
    }
}

extension GuardDutyClientTypes {
    /// Describes the public access policies that apply to the S3 bucket.
    public struct PublicAccess: Swift.Equatable {
        /// Describes the effective permission on this bucket after factoring all attached policies.
        public var effectivePermission: Swift.String?
        /// Contains information about how permissions are configured for the S3 bucket.
        public var permissionConfiguration: GuardDutyClientTypes.PermissionConfiguration?

        public init (
            effectivePermission: Swift.String? = nil,
            permissionConfiguration: GuardDutyClientTypes.PermissionConfiguration? = nil
        )
        {
            self.effectivePermission = effectivePermission
            self.permissionConfiguration = permissionConfiguration
        }
    }

}

extension GuardDutyClientTypes {
    public enum PublishingStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case pendingVerification
        case publishing
        case stopped
        case unableToPublishFixDestinationProperty
        case sdkUnknown(Swift.String)

        public static var allCases: [PublishingStatus] {
            return [
                .pendingVerification,
                .publishing,
                .stopped,
                .unableToPublishFixDestinationProperty,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .pendingVerification: return "PENDING_VERIFICATION"
            case .publishing: return "PUBLISHING"
            case .stopped: return "STOPPED"
            case .unableToPublishFixDestinationProperty: return "UNABLE_TO_PUBLISH_FIX_DESTINATION_PROPERTY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = PublishingStatus(rawValue: rawValue) ?? PublishingStatus.sdkUnknown(rawValue)
        }
    }
}

extension GuardDutyClientTypes.RemoteAccountDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "accountId"
        case affiliated = "affiliated"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if affiliated != false {
            try encodeContainer.encode(affiliated, forKey: .affiliated)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let affiliatedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .affiliated) ?? false
        affiliated = affiliatedDecoded
    }
}

extension GuardDutyClientTypes {
    /// Contains details about the remote Amazon Web Services account that made the API call.
    public struct RemoteAccountDetails: Swift.Equatable {
        /// The Amazon Web Services account ID of the remote API caller.
        public var accountId: Swift.String?
        /// Details on whether the Amazon Web Services account of the remote API caller is related to your GuardDuty environment. If this value is True the API caller is affiliated to your account in some way. If it is False the API caller is from outside your environment.
        public var affiliated: Swift.Bool

        public init (
            accountId: Swift.String? = nil,
            affiliated: Swift.Bool = false
        )
        {
            self.accountId = accountId
            self.affiliated = affiliated
        }
    }

}

extension GuardDutyClientTypes.RemoteIpDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case city = "city"
        case country = "country"
        case geoLocation = "geoLocation"
        case ipAddressV4 = "ipAddressV4"
        case organization = "organization"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let city = self.city {
            try encodeContainer.encode(city, forKey: .city)
        }
        if let country = self.country {
            try encodeContainer.encode(country, forKey: .country)
        }
        if let geoLocation = self.geoLocation {
            try encodeContainer.encode(geoLocation, forKey: .geoLocation)
        }
        if let ipAddressV4 = self.ipAddressV4 {
            try encodeContainer.encode(ipAddressV4, forKey: .ipAddressV4)
        }
        if let organization = self.organization {
            try encodeContainer.encode(organization, forKey: .organization)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cityDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.City.self, forKey: .city)
        city = cityDecoded
        let countryDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.Country.self, forKey: .country)
        country = countryDecoded
        let geoLocationDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.GeoLocation.self, forKey: .geoLocation)
        geoLocation = geoLocationDecoded
        let ipAddressV4Decoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ipAddressV4)
        ipAddressV4 = ipAddressV4Decoded
        let organizationDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.Organization.self, forKey: .organization)
        organization = organizationDecoded
    }
}

extension GuardDutyClientTypes {
    /// Contains information about the remote IP address of the connection.
    public struct RemoteIpDetails: Swift.Equatable {
        /// The city information of the remote IP address.
        public var city: GuardDutyClientTypes.City?
        /// The country code of the remote IP address.
        public var country: GuardDutyClientTypes.Country?
        /// The location information of the remote IP address.
        public var geoLocation: GuardDutyClientTypes.GeoLocation?
        /// The IPv4 remote address of the connection.
        public var ipAddressV4: Swift.String?
        /// The ISP organization information of the remote IP address.
        public var organization: GuardDutyClientTypes.Organization?

        public init (
            city: GuardDutyClientTypes.City? = nil,
            country: GuardDutyClientTypes.Country? = nil,
            geoLocation: GuardDutyClientTypes.GeoLocation? = nil,
            ipAddressV4: Swift.String? = nil,
            organization: GuardDutyClientTypes.Organization? = nil
        )
        {
            self.city = city
            self.country = country
            self.geoLocation = geoLocation
            self.ipAddressV4 = ipAddressV4
            self.organization = organization
        }
    }

}

extension GuardDutyClientTypes.RemotePortDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case port = "port"
        case portName = "portName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if port != 0 {
            try encodeContainer.encode(port, forKey: .port)
        }
        if let portName = self.portName {
            try encodeContainer.encode(portName, forKey: .portName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let portDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .port) ?? 0
        port = portDecoded
        let portNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .portName)
        portName = portNameDecoded
    }
}

extension GuardDutyClientTypes {
    /// Contains information about the remote port.
    public struct RemotePortDetails: Swift.Equatable {
        /// The port number of the remote connection.
        public var port: Swift.Int
        /// The port name of the remote connection.
        public var portName: Swift.String?

        public init (
            port: Swift.Int = 0,
            portName: Swift.String? = nil
        )
        {
            self.port = port
            self.portName = portName
        }
    }

}

extension GuardDutyClientTypes.Resource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accessKeyDetails = "accessKeyDetails"
        case containerDetails = "containerDetails"
        case ebsVolumeDetails = "ebsVolumeDetails"
        case ecsClusterDetails = "ecsClusterDetails"
        case eksClusterDetails = "eksClusterDetails"
        case instanceDetails = "instanceDetails"
        case kubernetesDetails = "kubernetesDetails"
        case resourceType = "resourceType"
        case s3BucketDetails = "s3BucketDetails"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accessKeyDetails = self.accessKeyDetails {
            try encodeContainer.encode(accessKeyDetails, forKey: .accessKeyDetails)
        }
        if let containerDetails = self.containerDetails {
            try encodeContainer.encode(containerDetails, forKey: .containerDetails)
        }
        if let ebsVolumeDetails = self.ebsVolumeDetails {
            try encodeContainer.encode(ebsVolumeDetails, forKey: .ebsVolumeDetails)
        }
        if let ecsClusterDetails = self.ecsClusterDetails {
            try encodeContainer.encode(ecsClusterDetails, forKey: .ecsClusterDetails)
        }
        if let eksClusterDetails = self.eksClusterDetails {
            try encodeContainer.encode(eksClusterDetails, forKey: .eksClusterDetails)
        }
        if let instanceDetails = self.instanceDetails {
            try encodeContainer.encode(instanceDetails, forKey: .instanceDetails)
        }
        if let kubernetesDetails = self.kubernetesDetails {
            try encodeContainer.encode(kubernetesDetails, forKey: .kubernetesDetails)
        }
        if let resourceType = self.resourceType {
            try encodeContainer.encode(resourceType, forKey: .resourceType)
        }
        if let s3BucketDetails = s3BucketDetails {
            var s3BucketDetailsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .s3BucketDetails)
            for s3bucketdetail0 in s3BucketDetails {
                try s3BucketDetailsContainer.encode(s3bucketdetail0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accessKeyDetailsDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.AccessKeyDetails.self, forKey: .accessKeyDetails)
        accessKeyDetails = accessKeyDetailsDecoded
        let s3BucketDetailsContainer = try containerValues.decodeIfPresent([GuardDutyClientTypes.S3BucketDetail?].self, forKey: .s3BucketDetails)
        var s3BucketDetailsDecoded0:[GuardDutyClientTypes.S3BucketDetail]? = nil
        if let s3BucketDetailsContainer = s3BucketDetailsContainer {
            s3BucketDetailsDecoded0 = [GuardDutyClientTypes.S3BucketDetail]()
            for structure0 in s3BucketDetailsContainer {
                if let structure0 = structure0 {
                    s3BucketDetailsDecoded0?.append(structure0)
                }
            }
        }
        s3BucketDetails = s3BucketDetailsDecoded0
        let instanceDetailsDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.InstanceDetails.self, forKey: .instanceDetails)
        instanceDetails = instanceDetailsDecoded
        let eksClusterDetailsDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.EksClusterDetails.self, forKey: .eksClusterDetails)
        eksClusterDetails = eksClusterDetailsDecoded
        let kubernetesDetailsDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.KubernetesDetails.self, forKey: .kubernetesDetails)
        kubernetesDetails = kubernetesDetailsDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let ebsVolumeDetailsDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.EbsVolumeDetails.self, forKey: .ebsVolumeDetails)
        ebsVolumeDetails = ebsVolumeDetailsDecoded
        let ecsClusterDetailsDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.EcsClusterDetails.self, forKey: .ecsClusterDetails)
        ecsClusterDetails = ecsClusterDetailsDecoded
        let containerDetailsDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.Container.self, forKey: .containerDetails)
        containerDetails = containerDetailsDecoded
    }
}

extension GuardDutyClientTypes {
    /// Contains information about the Amazon Web Services resource associated with the activity that prompted GuardDuty to generate a finding.
    public struct Resource: Swift.Equatable {
        /// The IAM access key details (user information) of a user that engaged in the activity that prompted GuardDuty to generate a finding.
        public var accessKeyDetails: GuardDutyClientTypes.AccessKeyDetails?
        /// Details of a container.
        public var containerDetails: GuardDutyClientTypes.Container?
        /// Contains list of scanned and skipped EBS volumes with details.
        public var ebsVolumeDetails: GuardDutyClientTypes.EbsVolumeDetails?
        /// Contains information about the details of the ECS Cluster.
        public var ecsClusterDetails: GuardDutyClientTypes.EcsClusterDetails?
        /// Details about the EKS cluster involved in a Kubernetes finding.
        public var eksClusterDetails: GuardDutyClientTypes.EksClusterDetails?
        /// The information about the EC2 instance associated with the activity that prompted GuardDuty to generate a finding.
        public var instanceDetails: GuardDutyClientTypes.InstanceDetails?
        /// Details about the Kubernetes user and workload involved in a Kubernetes finding.
        public var kubernetesDetails: GuardDutyClientTypes.KubernetesDetails?
        /// The type of Amazon Web Services resource.
        public var resourceType: Swift.String?
        /// Contains information on the S3 bucket.
        public var s3BucketDetails: [GuardDutyClientTypes.S3BucketDetail]?

        public init (
            accessKeyDetails: GuardDutyClientTypes.AccessKeyDetails? = nil,
            containerDetails: GuardDutyClientTypes.Container? = nil,
            ebsVolumeDetails: GuardDutyClientTypes.EbsVolumeDetails? = nil,
            ecsClusterDetails: GuardDutyClientTypes.EcsClusterDetails? = nil,
            eksClusterDetails: GuardDutyClientTypes.EksClusterDetails? = nil,
            instanceDetails: GuardDutyClientTypes.InstanceDetails? = nil,
            kubernetesDetails: GuardDutyClientTypes.KubernetesDetails? = nil,
            resourceType: Swift.String? = nil,
            s3BucketDetails: [GuardDutyClientTypes.S3BucketDetail]? = nil
        )
        {
            self.accessKeyDetails = accessKeyDetails
            self.containerDetails = containerDetails
            self.ebsVolumeDetails = ebsVolumeDetails
            self.ecsClusterDetails = ecsClusterDetails
            self.eksClusterDetails = eksClusterDetails
            self.instanceDetails = instanceDetails
            self.kubernetesDetails = kubernetesDetails
            self.resourceType = resourceType
            self.s3BucketDetails = s3BucketDetails
        }
    }

}

extension GuardDutyClientTypes.ResourceDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case instanceArn = "instanceArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let instanceArn = self.instanceArn {
            try encodeContainer.encode(instanceArn, forKey: .instanceArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let instanceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .instanceArn)
        instanceArn = instanceArnDecoded
    }
}

extension GuardDutyClientTypes {
    /// Represents the resources that were scanned in the scan entry.
    public struct ResourceDetails: Swift.Equatable {
        /// InstanceArn that was scanned in the scan entry.
        public var instanceArn: Swift.String?

        public init (
            instanceArn: Swift.String? = nil
        )
        {
            self.instanceArn = instanceArn
        }
    }

}

extension GuardDutyClientTypes.S3BucketDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn = "arn"
        case createdAt = "createdAt"
        case defaultServerSideEncryption = "defaultServerSideEncryption"
        case name = "name"
        case owner = "owner"
        case publicAccess = "publicAccess"
        case tags = "tags"
        case type = "type"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let defaultServerSideEncryption = self.defaultServerSideEncryption {
            try encodeContainer.encode(defaultServerSideEncryption, forKey: .defaultServerSideEncryption)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let owner = self.owner {
            try encodeContainer.encode(owner, forKey: .owner)
        }
        if let publicAccess = self.publicAccess {
            try encodeContainer.encode(publicAccess, forKey: .publicAccess)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let ownerDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.Owner.self, forKey: .owner)
        owner = ownerDecoded
        let tagsContainer = try containerValues.decodeIfPresent([GuardDutyClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[GuardDutyClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [GuardDutyClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let defaultServerSideEncryptionDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.DefaultServerSideEncryption.self, forKey: .defaultServerSideEncryption)
        defaultServerSideEncryption = defaultServerSideEncryptionDecoded
        let publicAccessDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.PublicAccess.self, forKey: .publicAccess)
        publicAccess = publicAccessDecoded
    }
}

extension GuardDutyClientTypes {
    /// Contains information on the S3 bucket.
    public struct S3BucketDetail: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the S3 bucket.
        public var arn: Swift.String?
        /// The date and time the bucket was created at.
        public var createdAt: ClientRuntime.Date?
        /// Describes the server side encryption method used in the S3 bucket.
        public var defaultServerSideEncryption: GuardDutyClientTypes.DefaultServerSideEncryption?
        /// The name of the S3 bucket.
        public var name: Swift.String?
        /// The owner of the S3 bucket.
        public var owner: GuardDutyClientTypes.Owner?
        /// Describes the public access policies that apply to the S3 bucket.
        public var publicAccess: GuardDutyClientTypes.PublicAccess?
        /// All tags attached to the S3 bucket
        public var tags: [GuardDutyClientTypes.Tag]?
        /// Describes whether the bucket is a source or destination bucket.
        public var type: Swift.String?

        public init (
            arn: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            defaultServerSideEncryption: GuardDutyClientTypes.DefaultServerSideEncryption? = nil,
            name: Swift.String? = nil,
            owner: GuardDutyClientTypes.Owner? = nil,
            publicAccess: GuardDutyClientTypes.PublicAccess? = nil,
            tags: [GuardDutyClientTypes.Tag]? = nil,
            type: Swift.String? = nil
        )
        {
            self.arn = arn
            self.createdAt = createdAt
            self.defaultServerSideEncryption = defaultServerSideEncryption
            self.name = name
            self.owner = owner
            self.publicAccess = publicAccess
            self.tags = tags
            self.type = type
        }
    }

}

extension GuardDutyClientTypes.S3LogsConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enable = "enable"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if enable != false {
            try encodeContainer.encode(enable, forKey: .enable)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enableDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enable) ?? false
        enable = enableDecoded
    }
}

extension GuardDutyClientTypes {
    /// Describes whether S3 data event logs will be enabled as a data source.
    public struct S3LogsConfiguration: Swift.Equatable {
        /// The status of S3 data event logs as a data source.
        /// This member is required.
        public var enable: Swift.Bool

        public init (
            enable: Swift.Bool = false
        )
        {
            self.enable = enable
        }
    }

}

extension GuardDutyClientTypes.S3LogsConfigurationResult: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case status = "status"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.DataSourceStatus.self, forKey: .status)
        status = statusDecoded
    }
}

extension GuardDutyClientTypes {
    /// Describes whether S3 data event logs will be enabled as a data source.
    public struct S3LogsConfigurationResult: Swift.Equatable {
        /// A value that describes whether S3 data event logs are automatically enabled for new members of the organization.
        /// This member is required.
        public var status: GuardDutyClientTypes.DataSourceStatus?

        public init (
            status: GuardDutyClientTypes.DataSourceStatus? = nil
        )
        {
            self.status = status
        }
    }

}

extension GuardDutyClientTypes.Scan: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "accountId"
        case adminDetectorId = "adminDetectorId"
        case attachedVolumes = "attachedVolumes"
        case detectorId = "detectorId"
        case failureReason = "failureReason"
        case fileCount = "fileCount"
        case resourceDetails = "resourceDetails"
        case scanEndTime = "scanEndTime"
        case scanId = "scanId"
        case scanResultDetails = "scanResultDetails"
        case scanStartTime = "scanStartTime"
        case scanStatus = "scanStatus"
        case totalBytes = "totalBytes"
        case triggerDetails = "triggerDetails"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let adminDetectorId = self.adminDetectorId {
            try encodeContainer.encode(adminDetectorId, forKey: .adminDetectorId)
        }
        if let attachedVolumes = attachedVolumes {
            var attachedVolumesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attachedVolumes)
            for volumedetail0 in attachedVolumes {
                try attachedVolumesContainer.encode(volumedetail0)
            }
        }
        if let detectorId = self.detectorId {
            try encodeContainer.encode(detectorId, forKey: .detectorId)
        }
        if let failureReason = self.failureReason {
            try encodeContainer.encode(failureReason, forKey: .failureReason)
        }
        if fileCount != 0 {
            try encodeContainer.encode(fileCount, forKey: .fileCount)
        }
        if let resourceDetails = self.resourceDetails {
            try encodeContainer.encode(resourceDetails, forKey: .resourceDetails)
        }
        if let scanEndTime = self.scanEndTime {
            try encodeContainer.encodeTimestamp(scanEndTime, format: .epochSeconds, forKey: .scanEndTime)
        }
        if let scanId = self.scanId {
            try encodeContainer.encode(scanId, forKey: .scanId)
        }
        if let scanResultDetails = self.scanResultDetails {
            try encodeContainer.encode(scanResultDetails, forKey: .scanResultDetails)
        }
        if let scanStartTime = self.scanStartTime {
            try encodeContainer.encodeTimestamp(scanStartTime, format: .epochSeconds, forKey: .scanStartTime)
        }
        if let scanStatus = self.scanStatus {
            try encodeContainer.encode(scanStatus.rawValue, forKey: .scanStatus)
        }
        if totalBytes != 0 {
            try encodeContainer.encode(totalBytes, forKey: .totalBytes)
        }
        if let triggerDetails = self.triggerDetails {
            try encodeContainer.encode(triggerDetails, forKey: .triggerDetails)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detectorIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detectorId)
        detectorId = detectorIdDecoded
        let adminDetectorIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .adminDetectorId)
        adminDetectorId = adminDetectorIdDecoded
        let scanIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .scanId)
        scanId = scanIdDecoded
        let scanStatusDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.ScanStatus.self, forKey: .scanStatus)
        scanStatus = scanStatusDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
        let scanStartTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .scanStartTime)
        scanStartTime = scanStartTimeDecoded
        let scanEndTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .scanEndTime)
        scanEndTime = scanEndTimeDecoded
        let triggerDetailsDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.TriggerDetails.self, forKey: .triggerDetails)
        triggerDetails = triggerDetailsDecoded
        let resourceDetailsDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.ResourceDetails.self, forKey: .resourceDetails)
        resourceDetails = resourceDetailsDecoded
        let scanResultDetailsDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.ScanResultDetails.self, forKey: .scanResultDetails)
        scanResultDetails = scanResultDetailsDecoded
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let totalBytesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalBytes) ?? 0
        totalBytes = totalBytesDecoded
        let fileCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .fileCount) ?? 0
        fileCount = fileCountDecoded
        let attachedVolumesContainer = try containerValues.decodeIfPresent([GuardDutyClientTypes.VolumeDetail?].self, forKey: .attachedVolumes)
        var attachedVolumesDecoded0:[GuardDutyClientTypes.VolumeDetail]? = nil
        if let attachedVolumesContainer = attachedVolumesContainer {
            attachedVolumesDecoded0 = [GuardDutyClientTypes.VolumeDetail]()
            for structure0 in attachedVolumesContainer {
                if let structure0 = structure0 {
                    attachedVolumesDecoded0?.append(structure0)
                }
            }
        }
        attachedVolumes = attachedVolumesDecoded0
    }
}

extension GuardDutyClientTypes {
    /// Contains information about a malware scan.
    public struct Scan: Swift.Equatable {
        /// The ID for the account that belongs to the scan.
        public var accountId: Swift.String?
        /// The unique detector ID of the administrator account that the request is associated with. Note that this value will be the same as the one used for DetectorId if the account is an administrator.
        public var adminDetectorId: Swift.String?
        /// List of volumes that were attached to the original instance to be scanned.
        public var attachedVolumes: [GuardDutyClientTypes.VolumeDetail]?
        /// The unique ID of the detector that the request is associated with.
        public var detectorId: Swift.String?
        /// Represents the reason for FAILED scan status.
        public var failureReason: Swift.String?
        /// Represents the number of files that were scanned.
        public var fileCount: Swift.Int
        /// Represents the resources that were scanned in the scan entry.
        public var resourceDetails: GuardDutyClientTypes.ResourceDetails?
        /// The timestamp of when the scan was finished.
        public var scanEndTime: ClientRuntime.Date?
        /// The unique scan ID associated with a scan entry.
        public var scanId: Swift.String?
        /// Represents the result of the scan.
        public var scanResultDetails: GuardDutyClientTypes.ScanResultDetails?
        /// The timestamp of when the scan was triggered.
        public var scanStartTime: ClientRuntime.Date?
        /// An enum value representing possible scan statuses.
        public var scanStatus: GuardDutyClientTypes.ScanStatus?
        /// Represents total bytes that were scanned.
        public var totalBytes: Swift.Int
        /// Specifies the reason why the scan was initiated.
        public var triggerDetails: GuardDutyClientTypes.TriggerDetails?

        public init (
            accountId: Swift.String? = nil,
            adminDetectorId: Swift.String? = nil,
            attachedVolumes: [GuardDutyClientTypes.VolumeDetail]? = nil,
            detectorId: Swift.String? = nil,
            failureReason: Swift.String? = nil,
            fileCount: Swift.Int = 0,
            resourceDetails: GuardDutyClientTypes.ResourceDetails? = nil,
            scanEndTime: ClientRuntime.Date? = nil,
            scanId: Swift.String? = nil,
            scanResultDetails: GuardDutyClientTypes.ScanResultDetails? = nil,
            scanStartTime: ClientRuntime.Date? = nil,
            scanStatus: GuardDutyClientTypes.ScanStatus? = nil,
            totalBytes: Swift.Int = 0,
            triggerDetails: GuardDutyClientTypes.TriggerDetails? = nil
        )
        {
            self.accountId = accountId
            self.adminDetectorId = adminDetectorId
            self.attachedVolumes = attachedVolumes
            self.detectorId = detectorId
            self.failureReason = failureReason
            self.fileCount = fileCount
            self.resourceDetails = resourceDetails
            self.scanEndTime = scanEndTime
            self.scanId = scanId
            self.scanResultDetails = scanResultDetails
            self.scanStartTime = scanStartTime
            self.scanStatus = scanStatus
            self.totalBytes = totalBytes
            self.triggerDetails = triggerDetails
        }
    }

}

extension GuardDutyClientTypes.ScanCondition: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case mapEquals = "mapEquals"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let mapEquals = mapEquals {
            var mapEqualsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .mapEquals)
            for scanconditionpair0 in mapEquals {
                try mapEqualsContainer.encode(scanconditionpair0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let mapEqualsContainer = try containerValues.decodeIfPresent([GuardDutyClientTypes.ScanConditionPair?].self, forKey: .mapEquals)
        var mapEqualsDecoded0:[GuardDutyClientTypes.ScanConditionPair]? = nil
        if let mapEqualsContainer = mapEqualsContainer {
            mapEqualsDecoded0 = [GuardDutyClientTypes.ScanConditionPair]()
            for structure0 in mapEqualsContainer {
                if let structure0 = structure0 {
                    mapEqualsDecoded0?.append(structure0)
                }
            }
        }
        mapEquals = mapEqualsDecoded0
    }
}

extension GuardDutyClientTypes {
    /// Contains information about the condition.
    public struct ScanCondition: Swift.Equatable {
        /// Represents an mapEqual condition to be applied to a single field when triggering for malware scan.
        /// This member is required.
        public var mapEquals: [GuardDutyClientTypes.ScanConditionPair]?

        public init (
            mapEquals: [GuardDutyClientTypes.ScanConditionPair]? = nil
        )
        {
            self.mapEquals = mapEquals
        }
    }

}

extension GuardDutyClientTypes.ScanConditionPair: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "key"
        case value = "value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension GuardDutyClientTypes {
    /// Represents key, value pair to be matched against given resource property.
    public struct ScanConditionPair: Swift.Equatable {
        /// Represents key in the map condition.
        /// This member is required.
        public var key: Swift.String?
        /// Represents optional value in the map condition. If not specified, only key will be matched.
        public var value: Swift.String?

        public init (
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension GuardDutyClientTypes {
    /// An enum value representing possible resource properties to match with given scan condition.
    public enum ScanCriterionKey: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case ec2InstanceTag
        case sdkUnknown(Swift.String)

        public static var allCases: [ScanCriterionKey] {
            return [
                .ec2InstanceTag,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .ec2InstanceTag: return "EC2_INSTANCE_TAG"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ScanCriterionKey(rawValue: rawValue) ?? ScanCriterionKey.sdkUnknown(rawValue)
        }
    }
}

extension GuardDutyClientTypes.ScanDetections: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case highestSeverityThreatDetails = "highestSeverityThreatDetails"
        case scannedItemCount = "scannedItemCount"
        case threatDetectedByName = "threatDetectedByName"
        case threatsDetectedItemCount = "threatsDetectedItemCount"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let highestSeverityThreatDetails = self.highestSeverityThreatDetails {
            try encodeContainer.encode(highestSeverityThreatDetails, forKey: .highestSeverityThreatDetails)
        }
        if let scannedItemCount = self.scannedItemCount {
            try encodeContainer.encode(scannedItemCount, forKey: .scannedItemCount)
        }
        if let threatDetectedByName = self.threatDetectedByName {
            try encodeContainer.encode(threatDetectedByName, forKey: .threatDetectedByName)
        }
        if let threatsDetectedItemCount = self.threatsDetectedItemCount {
            try encodeContainer.encode(threatsDetectedItemCount, forKey: .threatsDetectedItemCount)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scannedItemCountDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.ScannedItemCount.self, forKey: .scannedItemCount)
        scannedItemCount = scannedItemCountDecoded
        let threatsDetectedItemCountDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.ThreatsDetectedItemCount.self, forKey: .threatsDetectedItemCount)
        threatsDetectedItemCount = threatsDetectedItemCountDecoded
        let highestSeverityThreatDetailsDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.HighestSeverityThreatDetails.self, forKey: .highestSeverityThreatDetails)
        highestSeverityThreatDetails = highestSeverityThreatDetailsDecoded
        let threatDetectedByNameDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.ThreatDetectedByName.self, forKey: .threatDetectedByName)
        threatDetectedByName = threatDetectedByNameDecoded
    }
}

extension GuardDutyClientTypes {
    /// Contains a complete view providing malware scan result details.
    public struct ScanDetections: Swift.Equatable {
        /// Details of the highest severity threat detected during malware scan and number of infected files.
        public var highestSeverityThreatDetails: GuardDutyClientTypes.HighestSeverityThreatDetails?
        /// Total number of scanned files.
        public var scannedItemCount: GuardDutyClientTypes.ScannedItemCount?
        /// Contains details about identified threats organized by threat name.
        public var threatDetectedByName: GuardDutyClientTypes.ThreatDetectedByName?
        /// Total number of infected files.
        public var threatsDetectedItemCount: GuardDutyClientTypes.ThreatsDetectedItemCount?

        public init (
            highestSeverityThreatDetails: GuardDutyClientTypes.HighestSeverityThreatDetails? = nil,
            scannedItemCount: GuardDutyClientTypes.ScannedItemCount? = nil,
            threatDetectedByName: GuardDutyClientTypes.ThreatDetectedByName? = nil,
            threatsDetectedItemCount: GuardDutyClientTypes.ThreatsDetectedItemCount? = nil
        )
        {
            self.highestSeverityThreatDetails = highestSeverityThreatDetails
            self.scannedItemCount = scannedItemCount
            self.threatDetectedByName = threatDetectedByName
            self.threatsDetectedItemCount = threatsDetectedItemCount
        }
    }

}

extension GuardDutyClientTypes.ScanEc2InstanceWithFindings: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ebsVolumes = "ebsVolumes"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if ebsVolumes != false {
            try encodeContainer.encode(ebsVolumes, forKey: .ebsVolumes)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ebsVolumesDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .ebsVolumes) ?? false
        ebsVolumes = ebsVolumesDecoded
    }
}

extension GuardDutyClientTypes {
    /// Describes whether Malware Protection for EC2 instances with findings will be enabled as a data source.
    public struct ScanEc2InstanceWithFindings: Swift.Equatable {
        /// Describes the configuration for scanning EBS volumes as data source.
        public var ebsVolumes: Swift.Bool

        public init (
            ebsVolumes: Swift.Bool = false
        )
        {
            self.ebsVolumes = ebsVolumes
        }
    }

}

extension GuardDutyClientTypes.ScanEc2InstanceWithFindingsResult: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ebsVolumes = "ebsVolumes"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ebsVolumes = self.ebsVolumes {
            try encodeContainer.encode(ebsVolumes, forKey: .ebsVolumes)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ebsVolumesDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.EbsVolumesResult.self, forKey: .ebsVolumes)
        ebsVolumes = ebsVolumesDecoded
    }
}

extension GuardDutyClientTypes {
    /// An object that contains information on the status of whether Malware Protection for EC2 instances with findings will be enabled as a data source.
    public struct ScanEc2InstanceWithFindingsResult: Swift.Equatable {
        /// Describes the configuration of scanning EBS volumes as a data source.
        public var ebsVolumes: GuardDutyClientTypes.EbsVolumesResult?

        public init (
            ebsVolumes: GuardDutyClientTypes.EbsVolumesResult? = nil
        )
        {
            self.ebsVolumes = ebsVolumes
        }
    }

}

extension GuardDutyClientTypes.ScanFilePath: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fileName = "fileName"
        case filePath = "filePath"
        case hash = "hash"
        case volumeArn = "volumeArn"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let fileName = self.fileName {
            try encodeContainer.encode(fileName, forKey: .fileName)
        }
        if let filePath = self.filePath {
            try encodeContainer.encode(filePath, forKey: .filePath)
        }
        if let hash = self.hash {
            try encodeContainer.encode(hash, forKey: .hash)
        }
        if let volumeArn = self.volumeArn {
            try encodeContainer.encode(volumeArn, forKey: .volumeArn)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filePathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .filePath)
        filePath = filePathDecoded
        let volumeArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .volumeArn)
        volumeArn = volumeArnDecoded
        let hashDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .hash)
        hash = hashDecoded
        let fileNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .fileName)
        fileName = fileNameDecoded
    }
}

extension GuardDutyClientTypes {
    /// Contains details of infected file including name, file path and hash.
    public struct ScanFilePath: Swift.Equatable {
        /// File name of the infected file.
        public var fileName: Swift.String?
        /// The file path of the infected file.
        public var filePath: Swift.String?
        /// The hash value of the infected file.
        public var hash: Swift.String?
        /// EBS volume Arn details of the infected file.
        public var volumeArn: Swift.String?

        public init (
            fileName: Swift.String? = nil,
            filePath: Swift.String? = nil,
            hash: Swift.String? = nil,
            volumeArn: Swift.String? = nil
        )
        {
            self.fileName = fileName
            self.filePath = filePath
            self.hash = hash
            self.volumeArn = volumeArn
        }
    }

}

extension GuardDutyClientTypes.ScanResourceCriteria: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case exclude = "exclude"
        case include = "include"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let exclude = exclude {
            var excludeContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .exclude)
            for (dictKey0, scanCriterion0) in exclude {
                try excludeContainer.encode(scanCriterion0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let include = include {
            var includeContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .include)
            for (dictKey0, scanCriterion0) in include {
                try includeContainer.encode(scanCriterion0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let includeContainer = try containerValues.decodeIfPresent([Swift.String: GuardDutyClientTypes.ScanCondition?].self, forKey: .include)
        var includeDecoded0: [Swift.String:GuardDutyClientTypes.ScanCondition]? = nil
        if let includeContainer = includeContainer {
            includeDecoded0 = [Swift.String:GuardDutyClientTypes.ScanCondition]()
            for (key0, scancondition0) in includeContainer {
                if let scancondition0 = scancondition0 {
                    includeDecoded0?[key0] = scancondition0
                }
            }
        }
        include = includeDecoded0
        let excludeContainer = try containerValues.decodeIfPresent([Swift.String: GuardDutyClientTypes.ScanCondition?].self, forKey: .exclude)
        var excludeDecoded0: [Swift.String:GuardDutyClientTypes.ScanCondition]? = nil
        if let excludeContainer = excludeContainer {
            excludeDecoded0 = [Swift.String:GuardDutyClientTypes.ScanCondition]()
            for (key0, scancondition0) in excludeContainer {
                if let scancondition0 = scancondition0 {
                    excludeDecoded0?[key0] = scancondition0
                }
            }
        }
        exclude = excludeDecoded0
    }
}

extension GuardDutyClientTypes {
    /// Contains information about criteria used to filter resources before triggering malware scan.
    public struct ScanResourceCriteria: Swift.Equatable {
        /// Represents condition that when matched will prevent a malware scan for a certain resource.
        public var exclude: [Swift.String:GuardDutyClientTypes.ScanCondition]?
        /// Represents condition that when matched will allow a malware scan for a certain resource.
        public var include: [Swift.String:GuardDutyClientTypes.ScanCondition]?

        public init (
            exclude: [Swift.String:GuardDutyClientTypes.ScanCondition]? = nil,
            include: [Swift.String:GuardDutyClientTypes.ScanCondition]? = nil
        )
        {
            self.exclude = exclude
            self.include = include
        }
    }

}

extension GuardDutyClientTypes {
    public enum ScanResult: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case clean
        case infected
        case sdkUnknown(Swift.String)

        public static var allCases: [ScanResult] {
            return [
                .clean,
                .infected,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .clean: return "CLEAN"
            case .infected: return "INFECTED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ScanResult(rawValue: rawValue) ?? ScanResult.sdkUnknown(rawValue)
        }
    }
}

extension GuardDutyClientTypes.ScanResultDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case scanResult = "scanResult"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let scanResult = self.scanResult {
            try encodeContainer.encode(scanResult.rawValue, forKey: .scanResult)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scanResultDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.ScanResult.self, forKey: .scanResult)
        scanResult = scanResultDecoded
    }
}

extension GuardDutyClientTypes {
    /// Represents the result of the scan.
    public struct ScanResultDetails: Swift.Equatable {
        /// An enum value representing possible scan results.
        public var scanResult: GuardDutyClientTypes.ScanResult?

        public init (
            scanResult: GuardDutyClientTypes.ScanResult? = nil
        )
        {
            self.scanResult = scanResult
        }
    }

}

extension GuardDutyClientTypes {
    public enum ScanStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case completed
        case failed
        case running
        case sdkUnknown(Swift.String)

        public static var allCases: [ScanStatus] {
            return [
                .completed,
                .failed,
                .running,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .completed: return "COMPLETED"
            case .failed: return "FAILED"
            case .running: return "RUNNING"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ScanStatus(rawValue: rawValue) ?? ScanStatus.sdkUnknown(rawValue)
        }
    }
}

extension GuardDutyClientTypes.ScanThreatName: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filePaths = "filePaths"
        case itemCount = "itemCount"
        case name = "name"
        case severity = "severity"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filePaths = filePaths {
            var filePathsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .filePaths)
            for scanfilepath0 in filePaths {
                try filePathsContainer.encode(scanfilepath0)
            }
        }
        if itemCount != 0 {
            try encodeContainer.encode(itemCount, forKey: .itemCount)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let severity = self.severity {
            try encodeContainer.encode(severity, forKey: .severity)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let severityDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .severity)
        severity = severityDecoded
        let itemCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .itemCount) ?? 0
        itemCount = itemCountDecoded
        let filePathsContainer = try containerValues.decodeIfPresent([GuardDutyClientTypes.ScanFilePath?].self, forKey: .filePaths)
        var filePathsDecoded0:[GuardDutyClientTypes.ScanFilePath]? = nil
        if let filePathsContainer = filePathsContainer {
            filePathsDecoded0 = [GuardDutyClientTypes.ScanFilePath]()
            for structure0 in filePathsContainer {
                if let structure0 = structure0 {
                    filePathsDecoded0?.append(structure0)
                }
            }
        }
        filePaths = filePathsDecoded0
    }
}

extension GuardDutyClientTypes {
    /// Contains files infected with the given threat providing details of malware name and severity.
    public struct ScanThreatName: Swift.Equatable {
        /// List of infected files in EBS volume with details.
        public var filePaths: [GuardDutyClientTypes.ScanFilePath]?
        /// Total number of files infected with given threat.
        public var itemCount: Swift.Int
        /// The name of the identified threat.
        public var name: Swift.String?
        /// Severity of threat identified as part of the malware scan.
        public var severity: Swift.String?

        public init (
            filePaths: [GuardDutyClientTypes.ScanFilePath]? = nil,
            itemCount: Swift.Int = 0,
            name: Swift.String? = nil,
            severity: Swift.String? = nil
        )
        {
            self.filePaths = filePaths
            self.itemCount = itemCount
            self.name = name
            self.severity = severity
        }
    }

}

extension GuardDutyClientTypes.ScannedItemCount: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case files = "files"
        case totalGb = "totalGb"
        case volumes = "volumes"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if files != 0 {
            try encodeContainer.encode(files, forKey: .files)
        }
        if totalGb != 0 {
            try encodeContainer.encode(totalGb, forKey: .totalGb)
        }
        if volumes != 0 {
            try encodeContainer.encode(volumes, forKey: .volumes)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let totalGbDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .totalGb) ?? 0
        totalGb = totalGbDecoded
        let filesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .files) ?? 0
        files = filesDecoded
        let volumesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .volumes) ?? 0
        volumes = volumesDecoded
    }
}

extension GuardDutyClientTypes {
    /// Total number of scanned files.
    public struct ScannedItemCount: Swift.Equatable {
        /// Number of files scanned.
        public var files: Swift.Int
        /// Total GB of files scanned for malware.
        public var totalGb: Swift.Int
        /// Total number of scanned volumes.
        public var volumes: Swift.Int

        public init (
            files: Swift.Int = 0,
            totalGb: Swift.Int = 0,
            volumes: Swift.Int = 0
        )
        {
            self.files = files
            self.totalGb = totalGb
            self.volumes = volumes
        }
    }

}

extension GuardDutyClientTypes.SecurityContext: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case privileged = "privileged"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if privileged != false {
            try encodeContainer.encode(privileged, forKey: .privileged)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let privilegedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .privileged) ?? false
        privileged = privilegedDecoded
    }
}

extension GuardDutyClientTypes {
    /// Container security context.
    public struct SecurityContext: Swift.Equatable {
        /// Whether the container is privileged.
        public var privileged: Swift.Bool

        public init (
            privileged: Swift.Bool = false
        )
        {
            self.privileged = privileged
        }
    }

}

extension GuardDutyClientTypes.SecurityGroup: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case groupId = "groupId"
        case groupName = "groupName"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let groupId = self.groupId {
            try encodeContainer.encode(groupId, forKey: .groupId)
        }
        if let groupName = self.groupName {
            try encodeContainer.encode(groupName, forKey: .groupName)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let groupIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupId)
        groupId = groupIdDecoded
        let groupNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .groupName)
        groupName = groupNameDecoded
    }
}

extension GuardDutyClientTypes {
    /// Contains information about the security groups associated with the EC2 instance.
    public struct SecurityGroup: Swift.Equatable {
        /// The security group ID of the EC2 instance.
        public var groupId: Swift.String?
        /// The security group name of the EC2 instance.
        public var groupName: Swift.String?

        public init (
            groupId: Swift.String? = nil,
            groupName: Swift.String? = nil
        )
        {
            self.groupId = groupId
            self.groupName = groupName
        }
    }

}

extension GuardDutyClientTypes.Service: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action = "action"
        case additionalInfo = "additionalInfo"
        case archived = "archived"
        case count = "count"
        case detectorId = "detectorId"
        case ebsVolumeScanDetails = "ebsVolumeScanDetails"
        case eventFirstSeen = "eventFirstSeen"
        case eventLastSeen = "eventLastSeen"
        case evidence = "evidence"
        case featureName = "featureName"
        case resourceRole = "resourceRole"
        case serviceName = "serviceName"
        case userFeedback = "userFeedback"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = self.action {
            try encodeContainer.encode(action, forKey: .action)
        }
        if let additionalInfo = self.additionalInfo {
            try encodeContainer.encode(additionalInfo, forKey: .additionalInfo)
        }
        if archived != false {
            try encodeContainer.encode(archived, forKey: .archived)
        }
        if count != 0 {
            try encodeContainer.encode(count, forKey: .count)
        }
        if let detectorId = self.detectorId {
            try encodeContainer.encode(detectorId, forKey: .detectorId)
        }
        if let ebsVolumeScanDetails = self.ebsVolumeScanDetails {
            try encodeContainer.encode(ebsVolumeScanDetails, forKey: .ebsVolumeScanDetails)
        }
        if let eventFirstSeen = self.eventFirstSeen {
            try encodeContainer.encode(eventFirstSeen, forKey: .eventFirstSeen)
        }
        if let eventLastSeen = self.eventLastSeen {
            try encodeContainer.encode(eventLastSeen, forKey: .eventLastSeen)
        }
        if let evidence = self.evidence {
            try encodeContainer.encode(evidence, forKey: .evidence)
        }
        if let featureName = self.featureName {
            try encodeContainer.encode(featureName, forKey: .featureName)
        }
        if let resourceRole = self.resourceRole {
            try encodeContainer.encode(resourceRole, forKey: .resourceRole)
        }
        if let serviceName = self.serviceName {
            try encodeContainer.encode(serviceName, forKey: .serviceName)
        }
        if let userFeedback = self.userFeedback {
            try encodeContainer.encode(userFeedback, forKey: .userFeedback)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let actionDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.Action.self, forKey: .action)
        action = actionDecoded
        let evidenceDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.Evidence.self, forKey: .evidence)
        evidence = evidenceDecoded
        let archivedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .archived) ?? false
        archived = archivedDecoded
        let countDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .count) ?? 0
        count = countDecoded
        let detectorIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .detectorId)
        detectorId = detectorIdDecoded
        let eventFirstSeenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventFirstSeen)
        eventFirstSeen = eventFirstSeenDecoded
        let eventLastSeenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .eventLastSeen)
        eventLastSeen = eventLastSeenDecoded
        let resourceRoleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceRole)
        resourceRole = resourceRoleDecoded
        let serviceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceName)
        serviceName = serviceNameDecoded
        let userFeedbackDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .userFeedback)
        userFeedback = userFeedbackDecoded
        let additionalInfoDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.ServiceAdditionalInfo.self, forKey: .additionalInfo)
        additionalInfo = additionalInfoDecoded
        let featureNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .featureName)
        featureName = featureNameDecoded
        let ebsVolumeScanDetailsDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.EbsVolumeScanDetails.self, forKey: .ebsVolumeScanDetails)
        ebsVolumeScanDetails = ebsVolumeScanDetailsDecoded
    }
}

extension GuardDutyClientTypes {
    /// Contains additional information about the generated finding.
    public struct Service: Swift.Equatable {
        /// Information about the activity that is described in a finding.
        public var action: GuardDutyClientTypes.Action?
        /// Contains additional information about the generated finding.
        public var additionalInfo: GuardDutyClientTypes.ServiceAdditionalInfo?
        /// Indicates whether this finding is archived.
        public var archived: Swift.Bool
        /// The total count of the occurrences of this finding type.
        public var count: Swift.Int
        /// The detector ID for the GuardDuty service.
        public var detectorId: Swift.String?
        /// Returns details from the malware scan that created a finding.
        public var ebsVolumeScanDetails: GuardDutyClientTypes.EbsVolumeScanDetails?
        /// The first-seen timestamp of the activity that prompted GuardDuty to generate this finding.
        public var eventFirstSeen: Swift.String?
        /// The last-seen timestamp of the activity that prompted GuardDuty to generate this finding.
        public var eventLastSeen: Swift.String?
        /// An evidence object associated with the service.
        public var evidence: GuardDutyClientTypes.Evidence?
        /// The name of the feature that generated a finding.
        public var featureName: Swift.String?
        /// The resource role information for this finding.
        public var resourceRole: Swift.String?
        /// The name of the Amazon Web Services service (GuardDuty) that generated a finding.
        public var serviceName: Swift.String?
        /// Feedback that was submitted about the finding.
        public var userFeedback: Swift.String?

        public init (
            action: GuardDutyClientTypes.Action? = nil,
            additionalInfo: GuardDutyClientTypes.ServiceAdditionalInfo? = nil,
            archived: Swift.Bool = false,
            count: Swift.Int = 0,
            detectorId: Swift.String? = nil,
            ebsVolumeScanDetails: GuardDutyClientTypes.EbsVolumeScanDetails? = nil,
            eventFirstSeen: Swift.String? = nil,
            eventLastSeen: Swift.String? = nil,
            evidence: GuardDutyClientTypes.Evidence? = nil,
            featureName: Swift.String? = nil,
            resourceRole: Swift.String? = nil,
            serviceName: Swift.String? = nil,
            userFeedback: Swift.String? = nil
        )
        {
            self.action = action
            self.additionalInfo = additionalInfo
            self.archived = archived
            self.count = count
            self.detectorId = detectorId
            self.ebsVolumeScanDetails = ebsVolumeScanDetails
            self.eventFirstSeen = eventFirstSeen
            self.eventLastSeen = eventLastSeen
            self.evidence = evidence
            self.featureName = featureName
            self.resourceRole = resourceRole
            self.serviceName = serviceName
            self.userFeedback = userFeedback
        }
    }

}

extension GuardDutyClientTypes.ServiceAdditionalInfo: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case type = "type"
        case value = "value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
    }
}

extension GuardDutyClientTypes {
    /// Additional information about the generated finding.
    public struct ServiceAdditionalInfo: Swift.Equatable {
        /// Describes the type of the additional information.
        public var type: Swift.String?
        /// This field specifies the value of the additional information.
        public var value: Swift.String?

        public init (
            type: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.type = type
            self.value = value
        }
    }

}

extension GuardDutyClientTypes.SortCriteria: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributeName = "attributeName"
        case orderBy = "orderBy"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributeName = self.attributeName {
            try encodeContainer.encode(attributeName, forKey: .attributeName)
        }
        if let orderBy = self.orderBy {
            try encodeContainer.encode(orderBy.rawValue, forKey: .orderBy)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let attributeNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .attributeName)
        attributeName = attributeNameDecoded
        let orderByDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.OrderBy.self, forKey: .orderBy)
        orderBy = orderByDecoded
    }
}

extension GuardDutyClientTypes {
    /// Contains information about the criteria used for sorting findings.
    public struct SortCriteria: Swift.Equatable {
        /// Represents the finding attribute, such as accountId, that sorts the findings.
        public var attributeName: Swift.String?
        /// The order by which the sorted findings are to be displayed.
        public var orderBy: GuardDutyClientTypes.OrderBy?

        public init (
            attributeName: Swift.String? = nil,
            orderBy: GuardDutyClientTypes.OrderBy? = nil
        )
        {
            self.attributeName = attributeName
            self.orderBy = orderBy
        }
    }

}

extension StartMonitoringMembersInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountIds = "accountIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountIds = accountIds {
            var accountIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accountIds)
            for accountid0 in accountIds {
                try accountIdsContainer.encode(accountid0)
            }
        }
    }
}

extension StartMonitoringMembersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let detectorId = detectorId else {
            return nil
        }
        return "/detector/\(detectorId.urlPercentEncoding())/member/start"
    }
}

public struct StartMonitoringMembersInput: Swift.Equatable {
    /// A list of account IDs of the GuardDuty member accounts to start monitoring.
    /// This member is required.
    public var accountIds: [Swift.String]?
    /// The unique ID of the detector of the GuardDuty administrator account associated with the member accounts to monitor.
    /// This member is required.
    public var detectorId: Swift.String?

    public init (
        accountIds: [Swift.String]? = nil,
        detectorId: Swift.String? = nil
    )
    {
        self.accountIds = accountIds
        self.detectorId = detectorId
    }
}

struct StartMonitoringMembersInputBody: Swift.Equatable {
    let accountIds: [Swift.String]?
}

extension StartMonitoringMembersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountIds = "accountIds"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .accountIds)
        var accountIdsDecoded0:[Swift.String]? = nil
        if let accountIdsContainer = accountIdsContainer {
            accountIdsDecoded0 = [Swift.String]()
            for string0 in accountIdsContainer {
                if let string0 = string0 {
                    accountIdsDecoded0?.append(string0)
                }
            }
        }
        accountIds = accountIdsDecoded0
    }
}

extension StartMonitoringMembersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StartMonitoringMembersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum StartMonitoringMembersOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StartMonitoringMembersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: StartMonitoringMembersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.unprocessedAccounts = output.unprocessedAccounts
        } else {
            self.unprocessedAccounts = nil
        }
    }
}

public struct StartMonitoringMembersOutputResponse: Swift.Equatable {
    /// A list of objects that contain the unprocessed account and a result string that explains why it was unprocessed.
    /// This member is required.
    public var unprocessedAccounts: [GuardDutyClientTypes.UnprocessedAccount]?

    public init (
        unprocessedAccounts: [GuardDutyClientTypes.UnprocessedAccount]? = nil
    )
    {
        self.unprocessedAccounts = unprocessedAccounts
    }
}

struct StartMonitoringMembersOutputResponseBody: Swift.Equatable {
    let unprocessedAccounts: [GuardDutyClientTypes.UnprocessedAccount]?
}

extension StartMonitoringMembersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case unprocessedAccounts = "unprocessedAccounts"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let unprocessedAccountsContainer = try containerValues.decodeIfPresent([GuardDutyClientTypes.UnprocessedAccount?].self, forKey: .unprocessedAccounts)
        var unprocessedAccountsDecoded0:[GuardDutyClientTypes.UnprocessedAccount]? = nil
        if let unprocessedAccountsContainer = unprocessedAccountsContainer {
            unprocessedAccountsDecoded0 = [GuardDutyClientTypes.UnprocessedAccount]()
            for structure0 in unprocessedAccountsContainer {
                if let structure0 = structure0 {
                    unprocessedAccountsDecoded0?.append(structure0)
                }
            }
        }
        unprocessedAccounts = unprocessedAccountsDecoded0
    }
}

extension StopMonitoringMembersInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountIds = "accountIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountIds = accountIds {
            var accountIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accountIds)
            for accountid0 in accountIds {
                try accountIdsContainer.encode(accountid0)
            }
        }
    }
}

extension StopMonitoringMembersInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let detectorId = detectorId else {
            return nil
        }
        return "/detector/\(detectorId.urlPercentEncoding())/member/stop"
    }
}

public struct StopMonitoringMembersInput: Swift.Equatable {
    /// A list of account IDs for the member accounts to stop monitoring.
    /// This member is required.
    public var accountIds: [Swift.String]?
    /// The unique ID of the detector associated with the GuardDuty administrator account that is monitoring member accounts.
    /// This member is required.
    public var detectorId: Swift.String?

    public init (
        accountIds: [Swift.String]? = nil,
        detectorId: Swift.String? = nil
    )
    {
        self.accountIds = accountIds
        self.detectorId = detectorId
    }
}

struct StopMonitoringMembersInputBody: Swift.Equatable {
    let accountIds: [Swift.String]?
}

extension StopMonitoringMembersInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountIds = "accountIds"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .accountIds)
        var accountIdsDecoded0:[Swift.String]? = nil
        if let accountIdsContainer = accountIdsContainer {
            accountIdsDecoded0 = [Swift.String]()
            for string0 in accountIdsContainer {
                if let string0 = string0 {
                    accountIdsDecoded0?.append(string0)
                }
            }
        }
        accountIds = accountIdsDecoded0
    }
}

extension StopMonitoringMembersOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension StopMonitoringMembersOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum StopMonitoringMembersOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension StopMonitoringMembersOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: StopMonitoringMembersOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.unprocessedAccounts = output.unprocessedAccounts
        } else {
            self.unprocessedAccounts = nil
        }
    }
}

public struct StopMonitoringMembersOutputResponse: Swift.Equatable {
    /// A list of objects that contain an accountId for each account that could not be processed, and a result string that indicates why the account was not processed.
    /// This member is required.
    public var unprocessedAccounts: [GuardDutyClientTypes.UnprocessedAccount]?

    public init (
        unprocessedAccounts: [GuardDutyClientTypes.UnprocessedAccount]? = nil
    )
    {
        self.unprocessedAccounts = unprocessedAccounts
    }
}

struct StopMonitoringMembersOutputResponseBody: Swift.Equatable {
    let unprocessedAccounts: [GuardDutyClientTypes.UnprocessedAccount]?
}

extension StopMonitoringMembersOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case unprocessedAccounts = "unprocessedAccounts"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let unprocessedAccountsContainer = try containerValues.decodeIfPresent([GuardDutyClientTypes.UnprocessedAccount?].self, forKey: .unprocessedAccounts)
        var unprocessedAccountsDecoded0:[GuardDutyClientTypes.UnprocessedAccount]? = nil
        if let unprocessedAccountsContainer = unprocessedAccountsContainer {
            unprocessedAccountsDecoded0 = [GuardDutyClientTypes.UnprocessedAccount]()
            for structure0 in unprocessedAccountsContainer {
                if let structure0 = structure0 {
                    unprocessedAccountsDecoded0?.append(structure0)
                }
            }
        }
        unprocessedAccounts = unprocessedAccountsDecoded0
    }
}

extension GuardDutyClientTypes.Tag: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "key"
        case value = "value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension GuardDutyClientTypes {
    /// Contains information about a tag associated with the EC2 instance.
    public struct Tag: Swift.Equatable {
        /// The EC2 instance tag key.
        public var key: Swift.String?
        /// The EC2 instance tag value.
        public var value: Swift.String?

        public init (
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "tags"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagMap0) in tags {
                try tagsContainer.encode(tagMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) for the GuardDuty resource to apply a tag to.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tags to be added to a resource.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags = "tags"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension TagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum TagResourceOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension TagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct TagResourceOutputResponse: Swift.Equatable {

    public init () { }
}

extension GuardDutyClientTypes.ThreatDetectedByName: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case itemCount = "itemCount"
        case shortened = "shortened"
        case threatNames = "threatNames"
        case uniqueThreatNameCount = "uniqueThreatNameCount"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if itemCount != 0 {
            try encodeContainer.encode(itemCount, forKey: .itemCount)
        }
        if shortened != false {
            try encodeContainer.encode(shortened, forKey: .shortened)
        }
        if let threatNames = threatNames {
            var threatNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .threatNames)
            for scanthreatname0 in threatNames {
                try threatNamesContainer.encode(scanthreatname0)
            }
        }
        if uniqueThreatNameCount != 0 {
            try encodeContainer.encode(uniqueThreatNameCount, forKey: .uniqueThreatNameCount)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let itemCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .itemCount) ?? 0
        itemCount = itemCountDecoded
        let uniqueThreatNameCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .uniqueThreatNameCount) ?? 0
        uniqueThreatNameCount = uniqueThreatNameCountDecoded
        let shortenedDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .shortened) ?? false
        shortened = shortenedDecoded
        let threatNamesContainer = try containerValues.decodeIfPresent([GuardDutyClientTypes.ScanThreatName?].self, forKey: .threatNames)
        var threatNamesDecoded0:[GuardDutyClientTypes.ScanThreatName]? = nil
        if let threatNamesContainer = threatNamesContainer {
            threatNamesDecoded0 = [GuardDutyClientTypes.ScanThreatName]()
            for structure0 in threatNamesContainer {
                if let structure0 = structure0 {
                    threatNamesDecoded0?.append(structure0)
                }
            }
        }
        threatNames = threatNamesDecoded0
    }
}

extension GuardDutyClientTypes {
    /// Contains details about identified threats organized by threat name.
    public struct ThreatDetectedByName: Swift.Equatable {
        /// Total number of infected files identified.
        public var itemCount: Swift.Int
        /// Flag to determine if the finding contains every single infected file-path and/or every threat.
        public var shortened: Swift.Bool
        /// List of identified threats with details, organized by threat name.
        public var threatNames: [GuardDutyClientTypes.ScanThreatName]?
        /// Total number of unique threats by name identified, as part of the malware scan.
        public var uniqueThreatNameCount: Swift.Int

        public init (
            itemCount: Swift.Int = 0,
            shortened: Swift.Bool = false,
            threatNames: [GuardDutyClientTypes.ScanThreatName]? = nil,
            uniqueThreatNameCount: Swift.Int = 0
        )
        {
            self.itemCount = itemCount
            self.shortened = shortened
            self.threatNames = threatNames
            self.uniqueThreatNameCount = uniqueThreatNameCount
        }
    }

}

extension GuardDutyClientTypes {
    public enum ThreatIntelSetFormat: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case alienVault
        case fireEye
        case otxCsv
        case proofPoint
        case stix
        case txt
        case sdkUnknown(Swift.String)

        public static var allCases: [ThreatIntelSetFormat] {
            return [
                .alienVault,
                .fireEye,
                .otxCsv,
                .proofPoint,
                .stix,
                .txt,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .alienVault: return "ALIEN_VAULT"
            case .fireEye: return "FIRE_EYE"
            case .otxCsv: return "OTX_CSV"
            case .proofPoint: return "PROOF_POINT"
            case .stix: return "STIX"
            case .txt: return "TXT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ThreatIntelSetFormat(rawValue: rawValue) ?? ThreatIntelSetFormat.sdkUnknown(rawValue)
        }
    }
}

extension GuardDutyClientTypes {
    public enum ThreatIntelSetStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case activating
        case active
        case deactivating
        case deleted
        case deletePending
        case error
        case inactive
        case sdkUnknown(Swift.String)

        public static var allCases: [ThreatIntelSetStatus] {
            return [
                .activating,
                .active,
                .deactivating,
                .deleted,
                .deletePending,
                .error,
                .inactive,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .activating: return "ACTIVATING"
            case .active: return "ACTIVE"
            case .deactivating: return "DEACTIVATING"
            case .deleted: return "DELETED"
            case .deletePending: return "DELETE_PENDING"
            case .error: return "ERROR"
            case .inactive: return "INACTIVE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ThreatIntelSetStatus(rawValue: rawValue) ?? ThreatIntelSetStatus.sdkUnknown(rawValue)
        }
    }
}

extension GuardDutyClientTypes.ThreatIntelligenceDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case threatListName = "threatListName"
        case threatNames = "threatNames"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let threatListName = self.threatListName {
            try encodeContainer.encode(threatListName, forKey: .threatListName)
        }
        if let threatNames = threatNames {
            var threatNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .threatNames)
            for string0 in threatNames {
                try threatNamesContainer.encode(string0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let threatListNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .threatListName)
        threatListName = threatListNameDecoded
        let threatNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .threatNames)
        var threatNamesDecoded0:[Swift.String]? = nil
        if let threatNamesContainer = threatNamesContainer {
            threatNamesDecoded0 = [Swift.String]()
            for string0 in threatNamesContainer {
                if let string0 = string0 {
                    threatNamesDecoded0?.append(string0)
                }
            }
        }
        threatNames = threatNamesDecoded0
    }
}

extension GuardDutyClientTypes {
    /// An instance of a threat intelligence detail that constitutes evidence for the finding.
    public struct ThreatIntelligenceDetail: Swift.Equatable {
        /// The name of the threat intelligence list that triggered the finding.
        public var threatListName: Swift.String?
        /// A list of names of the threats in the threat intelligence list that triggered the finding.
        public var threatNames: [Swift.String]?

        public init (
            threatListName: Swift.String? = nil,
            threatNames: [Swift.String]? = nil
        )
        {
            self.threatListName = threatListName
            self.threatNames = threatNames
        }
    }

}

extension GuardDutyClientTypes.ThreatsDetectedItemCount: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case files = "files"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if files != 0 {
            try encodeContainer.encode(files, forKey: .files)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .files) ?? 0
        files = filesDecoded
    }
}

extension GuardDutyClientTypes {
    /// Contains total number of infected files.
    public struct ThreatsDetectedItemCount: Swift.Equatable {
        /// Total number of infected files.
        public var files: Swift.Int

        public init (
            files: Swift.Int = 0
        )
        {
            self.files = files
        }
    }

}

extension GuardDutyClientTypes.Total: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case amount = "amount"
        case unit = "unit"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let amount = self.amount {
            try encodeContainer.encode(amount, forKey: .amount)
        }
        if let unit = self.unit {
            try encodeContainer.encode(unit, forKey: .unit)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let amountDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .amount)
        amount = amountDecoded
        let unitDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .unit)
        unit = unitDecoded
    }
}

extension GuardDutyClientTypes {
    /// Contains the total usage with the corresponding currency unit for that value.
    public struct Total: Swift.Equatable {
        /// The total usage.
        public var amount: Swift.String?
        /// The currency unit that the amount is given in.
        public var unit: Swift.String?

        public init (
            amount: Swift.String? = nil,
            unit: Swift.String? = nil
        )
        {
            self.amount = amount
            self.unit = unit
        }
    }

}

extension GuardDutyClientTypes.TriggerDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description = "description"
        case guardDutyFindingId = "guardDutyFindingId"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let guardDutyFindingId = self.guardDutyFindingId {
            try encodeContainer.encode(guardDutyFindingId, forKey: .guardDutyFindingId)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let guardDutyFindingIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .guardDutyFindingId)
        guardDutyFindingId = guardDutyFindingIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension GuardDutyClientTypes {
    /// Represents the reason the scan was triggered.
    public struct TriggerDetails: Swift.Equatable {
        /// The description of the scan trigger.
        public var description: Swift.String?
        /// The ID of the GuardDuty finding that triggered the malware scan.
        public var guardDutyFindingId: Swift.String?

        public init (
            description: Swift.String? = nil,
            guardDutyFindingId: Swift.String? = nil
        )
        {
            self.description = description
            self.guardDutyFindingId = guardDutyFindingId
        }
    }

}

extension UnarchiveFindingsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case findingIds = "findingIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let findingIds = findingIds {
            var findingIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .findingIds)
            for findingid0 in findingIds {
                try findingIdsContainer.encode(findingid0)
            }
        }
    }
}

extension UnarchiveFindingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let detectorId = detectorId else {
            return nil
        }
        return "/detector/\(detectorId.urlPercentEncoding())/findings/unarchive"
    }
}

public struct UnarchiveFindingsInput: Swift.Equatable {
    /// The ID of the detector associated with the findings to unarchive.
    /// This member is required.
    public var detectorId: Swift.String?
    /// The IDs of the findings to unarchive.
    /// This member is required.
    public var findingIds: [Swift.String]?

    public init (
        detectorId: Swift.String? = nil,
        findingIds: [Swift.String]? = nil
    )
    {
        self.detectorId = detectorId
        self.findingIds = findingIds
    }
}

struct UnarchiveFindingsInputBody: Swift.Equatable {
    let findingIds: [Swift.String]?
}

extension UnarchiveFindingsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case findingIds = "findingIds"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let findingIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .findingIds)
        var findingIdsDecoded0:[Swift.String]? = nil
        if let findingIdsContainer = findingIdsContainer {
            findingIdsDecoded0 = [Swift.String]()
            for string0 in findingIdsContainer {
                if let string0 = string0 {
                    findingIdsDecoded0?.append(string0)
                }
            }
        }
        findingIds = findingIdsDecoded0
    }
}

extension UnarchiveFindingsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UnarchiveFindingsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UnarchiveFindingsOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UnarchiveFindingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UnarchiveFindingsOutputResponse: Swift.Equatable {

    public init () { }
}

extension GuardDutyClientTypes.UnprocessedAccount: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "accountId"
        case result = "result"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let result = self.result {
            try encodeContainer.encode(result, forKey: .result)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let resultDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .result)
        result = resultDecoded
    }
}

extension GuardDutyClientTypes {
    /// Contains information about the accounts that weren't processed.
    public struct UnprocessedAccount: Swift.Equatable {
        /// The Amazon Web Services account ID.
        /// This member is required.
        public var accountId: Swift.String?
        /// A reason why the account hasn't been processed.
        /// This member is required.
        public var result: Swift.String?

        public init (
            accountId: Swift.String? = nil,
            result: Swift.String? = nil
        )
        {
            self.accountId = accountId
            self.result = result
        }
    }

}

extension GuardDutyClientTypes.UnprocessedDataSourcesResult: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case malwareProtection = "malwareProtection"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let malwareProtection = self.malwareProtection {
            try encodeContainer.encode(malwareProtection, forKey: .malwareProtection)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let malwareProtectionDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.MalwareProtectionConfigurationResult.self, forKey: .malwareProtection)
        malwareProtection = malwareProtectionDecoded
    }
}

extension GuardDutyClientTypes {
    /// Specifies the names of the data sources that couldn't be enabled.
    public struct UnprocessedDataSourcesResult: Swift.Equatable {
        /// An object that contains information on the status of all Malware Protection data sources.
        public var malwareProtection: GuardDutyClientTypes.MalwareProtectionConfigurationResult?

        public init (
            malwareProtection: GuardDutyClientTypes.MalwareProtectionConfigurationResult? = nil
        )
        {
            self.malwareProtection = malwareProtection
        }
    }

}

extension UntagResourceInput: ClientRuntime.QueryItemProvider {
    public var queryItems: [ClientRuntime.URLQueryItem] {
        get throws {
            var items = [ClientRuntime.URLQueryItem]()
            guard let tagKeys = tagKeys else {
                let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
                throw ClientRuntime.ClientError.queryItemCreationFailed(message)
            }
            tagKeys.forEach { queryItemValue in
                let queryItem = ClientRuntime.URLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
                items.append(queryItem)
            }
            return items
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let resourceArn = resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) for the resource to remove tags from.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tag keys to remove from the resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init (
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init (from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UntagResourceOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UntagResourceOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UntagResourceOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UntagResourceOutputResponse: Swift.Equatable {

    public init () { }
}

extension UpdateDetectorInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataSources = "dataSources"
        case enable = "enable"
        case findingPublishingFrequency = "findingPublishingFrequency"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataSources = self.dataSources {
            try encodeContainer.encode(dataSources, forKey: .dataSources)
        }
        if let enable = self.enable {
            try encodeContainer.encode(enable, forKey: .enable)
        }
        if let findingPublishingFrequency = self.findingPublishingFrequency {
            try encodeContainer.encode(findingPublishingFrequency.rawValue, forKey: .findingPublishingFrequency)
        }
    }
}

extension UpdateDetectorInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let detectorId = detectorId else {
            return nil
        }
        return "/detector/\(detectorId.urlPercentEncoding())"
    }
}

public struct UpdateDetectorInput: Swift.Equatable {
    /// Describes which data sources will be updated. There might be regional differences because some data sources might not be available in all the Amazon Web Services Regions where GuardDuty is presently supported. For more information, see [Regions and endpoints](https://docs.aws.amazon.com/guardduty/latest/ug/guardduty_regions.html).
    public var dataSources: GuardDutyClientTypes.DataSourceConfigurations?
    /// The unique ID of the detector to update.
    /// This member is required.
    public var detectorId: Swift.String?
    /// Specifies whether the detector is enabled or not enabled.
    public var enable: Swift.Bool?
    /// An enum value that specifies how frequently findings are exported, such as to CloudWatch Events.
    public var findingPublishingFrequency: GuardDutyClientTypes.FindingPublishingFrequency?

    public init (
        dataSources: GuardDutyClientTypes.DataSourceConfigurations? = nil,
        detectorId: Swift.String? = nil,
        enable: Swift.Bool? = nil,
        findingPublishingFrequency: GuardDutyClientTypes.FindingPublishingFrequency? = nil
    )
    {
        self.dataSources = dataSources
        self.detectorId = detectorId
        self.enable = enable
        self.findingPublishingFrequency = findingPublishingFrequency
    }
}

struct UpdateDetectorInputBody: Swift.Equatable {
    let enable: Swift.Bool?
    let findingPublishingFrequency: GuardDutyClientTypes.FindingPublishingFrequency?
    let dataSources: GuardDutyClientTypes.DataSourceConfigurations?
}

extension UpdateDetectorInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataSources = "dataSources"
        case enable = "enable"
        case findingPublishingFrequency = "findingPublishingFrequency"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let enableDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .enable)
        enable = enableDecoded
        let findingPublishingFrequencyDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.FindingPublishingFrequency.self, forKey: .findingPublishingFrequency)
        findingPublishingFrequency = findingPublishingFrequencyDecoded
        let dataSourcesDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.DataSourceConfigurations.self, forKey: .dataSources)
        dataSources = dataSourcesDecoded
    }
}

extension UpdateDetectorOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateDetectorOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateDetectorOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateDetectorOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateDetectorOutputResponse: Swift.Equatable {

    public init () { }
}

extension UpdateFilterInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action = "action"
        case description = "description"
        case findingCriteria = "findingCriteria"
        case rank = "rank"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = self.action {
            try encodeContainer.encode(action.rawValue, forKey: .action)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let findingCriteria = self.findingCriteria {
            try encodeContainer.encode(findingCriteria, forKey: .findingCriteria)
        }
        if let rank = self.rank {
            try encodeContainer.encode(rank, forKey: .rank)
        }
    }
}

extension UpdateFilterInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let detectorId = detectorId else {
            return nil
        }
        guard let filterName = filterName else {
            return nil
        }
        return "/detector/\(detectorId.urlPercentEncoding())/filter/\(filterName.urlPercentEncoding())"
    }
}

public struct UpdateFilterInput: Swift.Equatable {
    /// Specifies the action that is to be applied to the findings that match the filter.
    public var action: GuardDutyClientTypes.FilterAction?
    /// The description of the filter. Valid characters include alphanumeric characters, and special characters such as hyphen, period, colon, underscore, parentheses ({ }, [ ], and ( )), forward slash, horizontal tab, vertical tab, newline, form feed, return, and whitespace.
    public var description: Swift.String?
    /// The unique ID of the detector that specifies the GuardDuty service where you want to update a filter.
    /// This member is required.
    public var detectorId: Swift.String?
    /// The name of the filter.
    /// This member is required.
    public var filterName: Swift.String?
    /// Represents the criteria to be used in the filter for querying findings.
    public var findingCriteria: GuardDutyClientTypes.FindingCriteria?
    /// Specifies the position of the filter in the list of current filters. Also specifies the order in which this filter is applied to the findings.
    public var rank: Swift.Int?

    public init (
        action: GuardDutyClientTypes.FilterAction? = nil,
        description: Swift.String? = nil,
        detectorId: Swift.String? = nil,
        filterName: Swift.String? = nil,
        findingCriteria: GuardDutyClientTypes.FindingCriteria? = nil,
        rank: Swift.Int? = nil
    )
    {
        self.action = action
        self.description = description
        self.detectorId = detectorId
        self.filterName = filterName
        self.findingCriteria = findingCriteria
        self.rank = rank
    }
}

struct UpdateFilterInputBody: Swift.Equatable {
    let description: Swift.String?
    let action: GuardDutyClientTypes.FilterAction?
    let rank: Swift.Int?
    let findingCriteria: GuardDutyClientTypes.FindingCriteria?
}

extension UpdateFilterInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action = "action"
        case description = "description"
        case findingCriteria = "findingCriteria"
        case rank = "rank"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let actionDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.FilterAction.self, forKey: .action)
        action = actionDecoded
        let rankDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .rank)
        rank = rankDecoded
        let findingCriteriaDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.FindingCriteria.self, forKey: .findingCriteria)
        findingCriteria = findingCriteriaDecoded
    }
}

extension UpdateFilterOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateFilterOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateFilterOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateFilterOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateFilterOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.name = output.name
        } else {
            self.name = nil
        }
    }
}

public struct UpdateFilterOutputResponse: Swift.Equatable {
    /// The name of the filter.
    /// This member is required.
    public var name: Swift.String?

    public init (
        name: Swift.String? = nil
    )
    {
        self.name = name
    }
}

struct UpdateFilterOutputResponseBody: Swift.Equatable {
    let name: Swift.String?
}

extension UpdateFilterOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name = "name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
    }
}

extension UpdateFindingsFeedbackInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case comments = "comments"
        case feedback = "feedback"
        case findingIds = "findingIds"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let comments = self.comments {
            try encodeContainer.encode(comments, forKey: .comments)
        }
        if let feedback = self.feedback {
            try encodeContainer.encode(feedback.rawValue, forKey: .feedback)
        }
        if let findingIds = findingIds {
            var findingIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .findingIds)
            for findingid0 in findingIds {
                try findingIdsContainer.encode(findingid0)
            }
        }
    }
}

extension UpdateFindingsFeedbackInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let detectorId = detectorId else {
            return nil
        }
        return "/detector/\(detectorId.urlPercentEncoding())/findings/feedback"
    }
}

public struct UpdateFindingsFeedbackInput: Swift.Equatable {
    /// Additional feedback about the GuardDuty findings.
    public var comments: Swift.String?
    /// The ID of the detector associated with the findings to update feedback for.
    /// This member is required.
    public var detectorId: Swift.String?
    /// The feedback for the finding.
    /// This member is required.
    public var feedback: GuardDutyClientTypes.Feedback?
    /// The IDs of the findings that you want to mark as useful or not useful.
    /// This member is required.
    public var findingIds: [Swift.String]?

    public init (
        comments: Swift.String? = nil,
        detectorId: Swift.String? = nil,
        feedback: GuardDutyClientTypes.Feedback? = nil,
        findingIds: [Swift.String]? = nil
    )
    {
        self.comments = comments
        self.detectorId = detectorId
        self.feedback = feedback
        self.findingIds = findingIds
    }
}

struct UpdateFindingsFeedbackInputBody: Swift.Equatable {
    let findingIds: [Swift.String]?
    let feedback: GuardDutyClientTypes.Feedback?
    let comments: Swift.String?
}

extension UpdateFindingsFeedbackInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case comments = "comments"
        case feedback = "feedback"
        case findingIds = "findingIds"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let findingIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .findingIds)
        var findingIdsDecoded0:[Swift.String]? = nil
        if let findingIdsContainer = findingIdsContainer {
            findingIdsDecoded0 = [Swift.String]()
            for string0 in findingIdsContainer {
                if let string0 = string0 {
                    findingIdsDecoded0?.append(string0)
                }
            }
        }
        findingIds = findingIdsDecoded0
        let feedbackDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.Feedback.self, forKey: .feedback)
        feedback = feedbackDecoded
        let commentsDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .comments)
        comments = commentsDecoded
    }
}

extension UpdateFindingsFeedbackOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateFindingsFeedbackOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateFindingsFeedbackOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateFindingsFeedbackOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateFindingsFeedbackOutputResponse: Swift.Equatable {

    public init () { }
}

extension UpdateIPSetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case activate = "activate"
        case location = "location"
        case name = "name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let activate = self.activate {
            try encodeContainer.encode(activate, forKey: .activate)
        }
        if let location = self.location {
            try encodeContainer.encode(location, forKey: .location)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension UpdateIPSetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let detectorId = detectorId else {
            return nil
        }
        guard let ipSetId = ipSetId else {
            return nil
        }
        return "/detector/\(detectorId.urlPercentEncoding())/ipset/\(ipSetId.urlPercentEncoding())"
    }
}

public struct UpdateIPSetInput: Swift.Equatable {
    /// The updated Boolean value that specifies whether the IPSet is active or not.
    public var activate: Swift.Bool?
    /// The detectorID that specifies the GuardDuty service whose IPSet you want to update.
    /// This member is required.
    public var detectorId: Swift.String?
    /// The unique ID that specifies the IPSet that you want to update.
    /// This member is required.
    public var ipSetId: Swift.String?
    /// The updated URI of the file that contains the IPSet.
    public var location: Swift.String?
    /// The unique ID that specifies the IPSet that you want to update.
    public var name: Swift.String?

    public init (
        activate: Swift.Bool? = nil,
        detectorId: Swift.String? = nil,
        ipSetId: Swift.String? = nil,
        location: Swift.String? = nil,
        name: Swift.String? = nil
    )
    {
        self.activate = activate
        self.detectorId = detectorId
        self.ipSetId = ipSetId
        self.location = location
        self.name = name
    }
}

struct UpdateIPSetInputBody: Swift.Equatable {
    let name: Swift.String?
    let location: Swift.String?
    let activate: Swift.Bool?
}

extension UpdateIPSetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case activate = "activate"
        case location = "location"
        case name = "name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let locationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .location)
        location = locationDecoded
        let activateDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .activate)
        activate = activateDecoded
    }
}

extension UpdateIPSetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateIPSetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateIPSetOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateIPSetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateIPSetOutputResponse: Swift.Equatable {

    public init () { }
}

extension UpdateMalwareScanSettingsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ebsSnapshotPreservation = "ebsSnapshotPreservation"
        case scanResourceCriteria = "scanResourceCriteria"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ebsSnapshotPreservation = self.ebsSnapshotPreservation {
            try encodeContainer.encode(ebsSnapshotPreservation.rawValue, forKey: .ebsSnapshotPreservation)
        }
        if let scanResourceCriteria = self.scanResourceCriteria {
            try encodeContainer.encode(scanResourceCriteria, forKey: .scanResourceCriteria)
        }
    }
}

extension UpdateMalwareScanSettingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let detectorId = detectorId else {
            return nil
        }
        return "/detector/\(detectorId.urlPercentEncoding())/malware-scan-settings"
    }
}

public struct UpdateMalwareScanSettingsInput: Swift.Equatable {
    /// The unique ID of the detector that specifies the GuardDuty service where you want to update scan settings.
    /// This member is required.
    public var detectorId: Swift.String?
    /// An enum value representing possible snapshot preservation settings.
    public var ebsSnapshotPreservation: GuardDutyClientTypes.EbsSnapshotPreservation?
    /// Represents the criteria to be used in the filter for selecting resources to scan.
    public var scanResourceCriteria: GuardDutyClientTypes.ScanResourceCriteria?

    public init (
        detectorId: Swift.String? = nil,
        ebsSnapshotPreservation: GuardDutyClientTypes.EbsSnapshotPreservation? = nil,
        scanResourceCriteria: GuardDutyClientTypes.ScanResourceCriteria? = nil
    )
    {
        self.detectorId = detectorId
        self.ebsSnapshotPreservation = ebsSnapshotPreservation
        self.scanResourceCriteria = scanResourceCriteria
    }
}

struct UpdateMalwareScanSettingsInputBody: Swift.Equatable {
    let scanResourceCriteria: GuardDutyClientTypes.ScanResourceCriteria?
    let ebsSnapshotPreservation: GuardDutyClientTypes.EbsSnapshotPreservation?
}

extension UpdateMalwareScanSettingsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ebsSnapshotPreservation = "ebsSnapshotPreservation"
        case scanResourceCriteria = "scanResourceCriteria"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scanResourceCriteriaDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.ScanResourceCriteria.self, forKey: .scanResourceCriteria)
        scanResourceCriteria = scanResourceCriteriaDecoded
        let ebsSnapshotPreservationDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.EbsSnapshotPreservation.self, forKey: .ebsSnapshotPreservation)
        ebsSnapshotPreservation = ebsSnapshotPreservationDecoded
    }
}

extension UpdateMalwareScanSettingsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateMalwareScanSettingsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateMalwareScanSettingsOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateMalwareScanSettingsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateMalwareScanSettingsOutputResponse: Swift.Equatable {

    public init () { }
}

extension UpdateMemberDetectorsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountIds = "accountIds"
        case dataSources = "dataSources"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountIds = accountIds {
            var accountIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accountIds)
            for accountid0 in accountIds {
                try accountIdsContainer.encode(accountid0)
            }
        }
        if let dataSources = self.dataSources {
            try encodeContainer.encode(dataSources, forKey: .dataSources)
        }
    }
}

extension UpdateMemberDetectorsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let detectorId = detectorId else {
            return nil
        }
        return "/detector/\(detectorId.urlPercentEncoding())/member/detector/update"
    }
}

public struct UpdateMemberDetectorsInput: Swift.Equatable {
    /// A list of member account IDs to be updated.
    /// This member is required.
    public var accountIds: [Swift.String]?
    /// Describes which data sources will be updated.
    public var dataSources: GuardDutyClientTypes.DataSourceConfigurations?
    /// The detector ID of the administrator account.
    /// This member is required.
    public var detectorId: Swift.String?

    public init (
        accountIds: [Swift.String]? = nil,
        dataSources: GuardDutyClientTypes.DataSourceConfigurations? = nil,
        detectorId: Swift.String? = nil
    )
    {
        self.accountIds = accountIds
        self.dataSources = dataSources
        self.detectorId = detectorId
    }
}

struct UpdateMemberDetectorsInputBody: Swift.Equatable {
    let accountIds: [Swift.String]?
    let dataSources: GuardDutyClientTypes.DataSourceConfigurations?
}

extension UpdateMemberDetectorsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountIds = "accountIds"
        case dataSources = "dataSources"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .accountIds)
        var accountIdsDecoded0:[Swift.String]? = nil
        if let accountIdsContainer = accountIdsContainer {
            accountIdsDecoded0 = [Swift.String]()
            for string0 in accountIdsContainer {
                if let string0 = string0 {
                    accountIdsDecoded0?.append(string0)
                }
            }
        }
        accountIds = accountIdsDecoded0
        let dataSourcesDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.DataSourceConfigurations.self, forKey: .dataSources)
        dataSources = dataSourcesDecoded
    }
}

extension UpdateMemberDetectorsOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateMemberDetectorsOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateMemberDetectorsOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateMemberDetectorsOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        if case .stream(let reader) = httpResponse.body,
            let responseDecoder = decoder {
            let data = reader.toBytes().getData()
            let output: UpdateMemberDetectorsOutputResponseBody = try responseDecoder.decode(responseBody: data)
            self.unprocessedAccounts = output.unprocessedAccounts
        } else {
            self.unprocessedAccounts = nil
        }
    }
}

public struct UpdateMemberDetectorsOutputResponse: Swift.Equatable {
    /// A list of member account IDs that were unable to be processed along with an explanation for why they were not processed.
    /// This member is required.
    public var unprocessedAccounts: [GuardDutyClientTypes.UnprocessedAccount]?

    public init (
        unprocessedAccounts: [GuardDutyClientTypes.UnprocessedAccount]? = nil
    )
    {
        self.unprocessedAccounts = unprocessedAccounts
    }
}

struct UpdateMemberDetectorsOutputResponseBody: Swift.Equatable {
    let unprocessedAccounts: [GuardDutyClientTypes.UnprocessedAccount]?
}

extension UpdateMemberDetectorsOutputResponseBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case unprocessedAccounts = "unprocessedAccounts"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let unprocessedAccountsContainer = try containerValues.decodeIfPresent([GuardDutyClientTypes.UnprocessedAccount?].self, forKey: .unprocessedAccounts)
        var unprocessedAccountsDecoded0:[GuardDutyClientTypes.UnprocessedAccount]? = nil
        if let unprocessedAccountsContainer = unprocessedAccountsContainer {
            unprocessedAccountsDecoded0 = [GuardDutyClientTypes.UnprocessedAccount]()
            for structure0 in unprocessedAccountsContainer {
                if let structure0 = structure0 {
                    unprocessedAccountsDecoded0?.append(structure0)
                }
            }
        }
        unprocessedAccounts = unprocessedAccountsDecoded0
    }
}

extension UpdateOrganizationConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoEnable = "autoEnable"
        case dataSources = "dataSources"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let autoEnable = self.autoEnable {
            try encodeContainer.encode(autoEnable, forKey: .autoEnable)
        }
        if let dataSources = self.dataSources {
            try encodeContainer.encode(dataSources, forKey: .dataSources)
        }
    }
}

extension UpdateOrganizationConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let detectorId = detectorId else {
            return nil
        }
        return "/detector/\(detectorId.urlPercentEncoding())/admin"
    }
}

public struct UpdateOrganizationConfigurationInput: Swift.Equatable {
    /// Indicates whether to automatically enable member accounts in the organization.
    /// This member is required.
    public var autoEnable: Swift.Bool?
    /// Describes which data sources will be updated.
    public var dataSources: GuardDutyClientTypes.OrganizationDataSourceConfigurations?
    /// The ID of the detector to update the delegated administrator for.
    /// This member is required.
    public var detectorId: Swift.String?

    public init (
        autoEnable: Swift.Bool? = nil,
        dataSources: GuardDutyClientTypes.OrganizationDataSourceConfigurations? = nil,
        detectorId: Swift.String? = nil
    )
    {
        self.autoEnable = autoEnable
        self.dataSources = dataSources
        self.detectorId = detectorId
    }
}

struct UpdateOrganizationConfigurationInputBody: Swift.Equatable {
    let autoEnable: Swift.Bool?
    let dataSources: GuardDutyClientTypes.OrganizationDataSourceConfigurations?
}

extension UpdateOrganizationConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case autoEnable = "autoEnable"
        case dataSources = "dataSources"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let autoEnableDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .autoEnable)
        autoEnable = autoEnableDecoded
        let dataSourcesDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.OrganizationDataSourceConfigurations.self, forKey: .dataSources)
        dataSources = dataSourcesDecoded
    }
}

extension UpdateOrganizationConfigurationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateOrganizationConfigurationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateOrganizationConfigurationOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateOrganizationConfigurationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateOrganizationConfigurationOutputResponse: Swift.Equatable {

    public init () { }
}

extension UpdatePublishingDestinationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationProperties = "destinationProperties"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destinationProperties = self.destinationProperties {
            try encodeContainer.encode(destinationProperties, forKey: .destinationProperties)
        }
    }
}

extension UpdatePublishingDestinationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let detectorId = detectorId else {
            return nil
        }
        guard let destinationId = destinationId else {
            return nil
        }
        return "/detector/\(detectorId.urlPercentEncoding())/publishingDestination/\(destinationId.urlPercentEncoding())"
    }
}

public struct UpdatePublishingDestinationInput: Swift.Equatable {
    /// The ID of the publishing destination to update.
    /// This member is required.
    public var destinationId: Swift.String?
    /// A DestinationProperties object that includes the DestinationArn and KmsKeyArn of the publishing destination.
    public var destinationProperties: GuardDutyClientTypes.DestinationProperties?
    /// The ID of the detector associated with the publishing destinations to update.
    /// This member is required.
    public var detectorId: Swift.String?

    public init (
        destinationId: Swift.String? = nil,
        destinationProperties: GuardDutyClientTypes.DestinationProperties? = nil,
        detectorId: Swift.String? = nil
    )
    {
        self.destinationId = destinationId
        self.destinationProperties = destinationProperties
        self.detectorId = detectorId
    }
}

struct UpdatePublishingDestinationInputBody: Swift.Equatable {
    let destinationProperties: GuardDutyClientTypes.DestinationProperties?
}

extension UpdatePublishingDestinationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinationProperties = "destinationProperties"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let destinationPropertiesDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.DestinationProperties.self, forKey: .destinationProperties)
        destinationProperties = destinationPropertiesDecoded
    }
}

extension UpdatePublishingDestinationOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdatePublishingDestinationOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdatePublishingDestinationOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdatePublishingDestinationOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdatePublishingDestinationOutputResponse: Swift.Equatable {

    public init () { }
}

extension UpdateThreatIntelSetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case activate = "activate"
        case location = "location"
        case name = "name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let activate = self.activate {
            try encodeContainer.encode(activate, forKey: .activate)
        }
        if let location = self.location {
            try encodeContainer.encode(location, forKey: .location)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }
}

extension UpdateThreatIntelSetInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        guard let detectorId = detectorId else {
            return nil
        }
        guard let threatIntelSetId = threatIntelSetId else {
            return nil
        }
        return "/detector/\(detectorId.urlPercentEncoding())/threatintelset/\(threatIntelSetId.urlPercentEncoding())"
    }
}

public struct UpdateThreatIntelSetInput: Swift.Equatable {
    /// The updated Boolean value that specifies whether the ThreateIntelSet is active or not.
    public var activate: Swift.Bool?
    /// The detectorID that specifies the GuardDuty service whose ThreatIntelSet you want to update.
    /// This member is required.
    public var detectorId: Swift.String?
    /// The updated URI of the file that contains the ThreateIntelSet.
    public var location: Swift.String?
    /// The unique ID that specifies the ThreatIntelSet that you want to update.
    public var name: Swift.String?
    /// The unique ID that specifies the ThreatIntelSet that you want to update.
    /// This member is required.
    public var threatIntelSetId: Swift.String?

    public init (
        activate: Swift.Bool? = nil,
        detectorId: Swift.String? = nil,
        location: Swift.String? = nil,
        name: Swift.String? = nil,
        threatIntelSetId: Swift.String? = nil
    )
    {
        self.activate = activate
        self.detectorId = detectorId
        self.location = location
        self.name = name
        self.threatIntelSetId = threatIntelSetId
    }
}

struct UpdateThreatIntelSetInputBody: Swift.Equatable {
    let name: Swift.String?
    let location: Swift.String?
    let activate: Swift.Bool?
}

extension UpdateThreatIntelSetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case activate = "activate"
        case location = "location"
        case name = "name"
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let locationDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .location)
        location = locationDecoded
        let activateDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .activate)
        activate = activateDecoded
    }
}

extension UpdateThreatIntelSetOutputError: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
        let errorDetails = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.headers.value(for: X_AMZN_REQUEST_ID_HEADER)
        try self.init(errorType: errorDetails.errorType, httpResponse: httpResponse, decoder: decoder, message: errorDetails.errorMessage, requestID: requestID)
    }
}

extension UpdateThreatIntelSetOutputError {
    public init(errorType: Swift.String?, httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) throws {
        switch errorType {
        case "BadRequestException" : self = .badRequestException(try BadRequestException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        case "InternalServerErrorException" : self = .internalServerErrorException(try InternalServerErrorException(httpResponse: httpResponse, decoder: decoder, message: message, requestID: requestID))
        default : self = .unknown(UnknownAWSHttpServiceError(httpResponse: httpResponse, message: message, requestID: requestID, errorType: errorType))
        }
    }
}

public enum UpdateThreatIntelSetOutputError: Swift.Error, Swift.Equatable {
    case badRequestException(BadRequestException)
    case internalServerErrorException(InternalServerErrorException)
    case unknown(UnknownAWSHttpServiceError)
}

extension UpdateThreatIntelSetOutputResponse: ClientRuntime.HttpResponseBinding {
    public init (httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) throws {
    }
}

public struct UpdateThreatIntelSetOutputResponse: Swift.Equatable {

    public init () { }
}

extension GuardDutyClientTypes.UsageAccountResult: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountId = "accountId"
        case total = "total"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountId = self.accountId {
            try encodeContainer.encode(accountId, forKey: .accountId)
        }
        if let total = self.total {
            try encodeContainer.encode(total, forKey: .total)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .accountId)
        accountId = accountIdDecoded
        let totalDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.Total.self, forKey: .total)
        total = totalDecoded
    }
}

extension GuardDutyClientTypes {
    /// Contains information on the total of usage based on account IDs.
    public struct UsageAccountResult: Swift.Equatable {
        /// The Account ID that generated usage.
        public var accountId: Swift.String?
        /// Represents the total of usage for the Account ID.
        public var total: GuardDutyClientTypes.Total?

        public init (
            accountId: Swift.String? = nil,
            total: GuardDutyClientTypes.Total? = nil
        )
        {
            self.accountId = accountId
            self.total = total
        }
    }

}

extension GuardDutyClientTypes.UsageCriteria: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case accountIds = "accountIds"
        case dataSources = "dataSources"
        case resources = "resources"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let accountIds = accountIds {
            var accountIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .accountIds)
            for accountid0 in accountIds {
                try accountIdsContainer.encode(accountid0)
            }
        }
        if let dataSources = dataSources {
            var dataSourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .dataSources)
            for datasource0 in dataSources {
                try dataSourcesContainer.encode(datasource0.rawValue)
            }
        }
        if let resources = resources {
            var resourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resources)
            for string0 in resources {
                try resourcesContainer.encode(string0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let accountIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .accountIds)
        var accountIdsDecoded0:[Swift.String]? = nil
        if let accountIdsContainer = accountIdsContainer {
            accountIdsDecoded0 = [Swift.String]()
            for string0 in accountIdsContainer {
                if let string0 = string0 {
                    accountIdsDecoded0?.append(string0)
                }
            }
        }
        accountIds = accountIdsDecoded0
        let dataSourcesContainer = try containerValues.decodeIfPresent([GuardDutyClientTypes.DataSource?].self, forKey: .dataSources)
        var dataSourcesDecoded0:[GuardDutyClientTypes.DataSource]? = nil
        if let dataSourcesContainer = dataSourcesContainer {
            dataSourcesDecoded0 = [GuardDutyClientTypes.DataSource]()
            for enum0 in dataSourcesContainer {
                if let enum0 = enum0 {
                    dataSourcesDecoded0?.append(enum0)
                }
            }
        }
        dataSources = dataSourcesDecoded0
        let resourcesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .resources)
        var resourcesDecoded0:[Swift.String]? = nil
        if let resourcesContainer = resourcesContainer {
            resourcesDecoded0 = [Swift.String]()
            for string0 in resourcesContainer {
                if let string0 = string0 {
                    resourcesDecoded0?.append(string0)
                }
            }
        }
        resources = resourcesDecoded0
    }
}

extension GuardDutyClientTypes {
    /// Contains information about the criteria used to query usage statistics.
    public struct UsageCriteria: Swift.Equatable {
        /// The account IDs to aggregate usage statistics from.
        public var accountIds: [Swift.String]?
        /// The data sources to aggregate usage statistics from.
        /// This member is required.
        public var dataSources: [GuardDutyClientTypes.DataSource]?
        /// The resources to aggregate usage statistics from. Only accepts exact resource names.
        public var resources: [Swift.String]?

        public init (
            accountIds: [Swift.String]? = nil,
            dataSources: [GuardDutyClientTypes.DataSource]? = nil,
            resources: [Swift.String]? = nil
        )
        {
            self.accountIds = accountIds
            self.dataSources = dataSources
            self.resources = resources
        }
    }

}

extension GuardDutyClientTypes.UsageDataSourceResult: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case dataSource = "dataSource"
        case total = "total"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let dataSource = self.dataSource {
            try encodeContainer.encode(dataSource.rawValue, forKey: .dataSource)
        }
        if let total = self.total {
            try encodeContainer.encode(total, forKey: .total)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let dataSourceDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.DataSource.self, forKey: .dataSource)
        dataSource = dataSourceDecoded
        let totalDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.Total.self, forKey: .total)
        total = totalDecoded
    }
}

extension GuardDutyClientTypes {
    /// Contains information on the result of usage based on data source type.
    public struct UsageDataSourceResult: Swift.Equatable {
        /// The data source type that generated usage.
        public var dataSource: GuardDutyClientTypes.DataSource?
        /// Represents the total of usage for the specified data source.
        public var total: GuardDutyClientTypes.Total?

        public init (
            dataSource: GuardDutyClientTypes.DataSource? = nil,
            total: GuardDutyClientTypes.Total? = nil
        )
        {
            self.dataSource = dataSource
            self.total = total
        }
    }

}

extension GuardDutyClientTypes.UsageResourceResult: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resource = "resource"
        case total = "total"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resource = self.resource {
            try encodeContainer.encode(resource, forKey: .resource)
        }
        if let total = self.total {
            try encodeContainer.encode(total, forKey: .total)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resource)
        resource = resourceDecoded
        let totalDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.Total.self, forKey: .total)
        total = totalDecoded
    }
}

extension GuardDutyClientTypes {
    /// Contains information on the sum of usage based on an Amazon Web Services resource.
    public struct UsageResourceResult: Swift.Equatable {
        /// The Amazon Web Services resource that generated usage.
        public var resource: Swift.String?
        /// Represents the sum total of usage for the specified resource type.
        public var total: GuardDutyClientTypes.Total?

        public init (
            resource: Swift.String? = nil,
            total: GuardDutyClientTypes.Total? = nil
        )
        {
            self.resource = resource
            self.total = total
        }
    }

}

extension GuardDutyClientTypes {
    public enum UsageStatisticType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case sumByAccount
        case sumByDataSource
        case sumByResource
        case topResources
        case sdkUnknown(Swift.String)

        public static var allCases: [UsageStatisticType] {
            return [
                .sumByAccount,
                .sumByDataSource,
                .sumByResource,
                .topResources,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .sumByAccount: return "SUM_BY_ACCOUNT"
            case .sumByDataSource: return "SUM_BY_DATA_SOURCE"
            case .sumByResource: return "SUM_BY_RESOURCE"
            case .topResources: return "TOP_RESOURCES"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = UsageStatisticType(rawValue: rawValue) ?? UsageStatisticType.sdkUnknown(rawValue)
        }
    }
}

extension GuardDutyClientTypes.UsageStatistics: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case sumByAccount = "sumByAccount"
        case sumByDataSource = "sumByDataSource"
        case sumByResource = "sumByResource"
        case topResources = "topResources"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let sumByAccount = sumByAccount {
            var sumByAccountContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sumByAccount)
            for usageaccountresult0 in sumByAccount {
                try sumByAccountContainer.encode(usageaccountresult0)
            }
        }
        if let sumByDataSource = sumByDataSource {
            var sumByDataSourceContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sumByDataSource)
            for usagedatasourceresult0 in sumByDataSource {
                try sumByDataSourceContainer.encode(usagedatasourceresult0)
            }
        }
        if let sumByResource = sumByResource {
            var sumByResourceContainer = encodeContainer.nestedUnkeyedContainer(forKey: .sumByResource)
            for usageresourceresult0 in sumByResource {
                try sumByResourceContainer.encode(usageresourceresult0)
            }
        }
        if let topResources = topResources {
            var topResourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .topResources)
            for usageresourceresult0 in topResources {
                try topResourcesContainer.encode(usageresourceresult0)
            }
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let sumByAccountContainer = try containerValues.decodeIfPresent([GuardDutyClientTypes.UsageAccountResult?].self, forKey: .sumByAccount)
        var sumByAccountDecoded0:[GuardDutyClientTypes.UsageAccountResult]? = nil
        if let sumByAccountContainer = sumByAccountContainer {
            sumByAccountDecoded0 = [GuardDutyClientTypes.UsageAccountResult]()
            for structure0 in sumByAccountContainer {
                if let structure0 = structure0 {
                    sumByAccountDecoded0?.append(structure0)
                }
            }
        }
        sumByAccount = sumByAccountDecoded0
        let sumByDataSourceContainer = try containerValues.decodeIfPresent([GuardDutyClientTypes.UsageDataSourceResult?].self, forKey: .sumByDataSource)
        var sumByDataSourceDecoded0:[GuardDutyClientTypes.UsageDataSourceResult]? = nil
        if let sumByDataSourceContainer = sumByDataSourceContainer {
            sumByDataSourceDecoded0 = [GuardDutyClientTypes.UsageDataSourceResult]()
            for structure0 in sumByDataSourceContainer {
                if let structure0 = structure0 {
                    sumByDataSourceDecoded0?.append(structure0)
                }
            }
        }
        sumByDataSource = sumByDataSourceDecoded0
        let sumByResourceContainer = try containerValues.decodeIfPresent([GuardDutyClientTypes.UsageResourceResult?].self, forKey: .sumByResource)
        var sumByResourceDecoded0:[GuardDutyClientTypes.UsageResourceResult]? = nil
        if let sumByResourceContainer = sumByResourceContainer {
            sumByResourceDecoded0 = [GuardDutyClientTypes.UsageResourceResult]()
            for structure0 in sumByResourceContainer {
                if let structure0 = structure0 {
                    sumByResourceDecoded0?.append(structure0)
                }
            }
        }
        sumByResource = sumByResourceDecoded0
        let topResourcesContainer = try containerValues.decodeIfPresent([GuardDutyClientTypes.UsageResourceResult?].self, forKey: .topResources)
        var topResourcesDecoded0:[GuardDutyClientTypes.UsageResourceResult]? = nil
        if let topResourcesContainer = topResourcesContainer {
            topResourcesDecoded0 = [GuardDutyClientTypes.UsageResourceResult]()
            for structure0 in topResourcesContainer {
                if let structure0 = structure0 {
                    topResourcesDecoded0?.append(structure0)
                }
            }
        }
        topResources = topResourcesDecoded0
    }
}

extension GuardDutyClientTypes {
    /// Contains the result of GuardDuty usage. If a UsageStatisticType is provided the result for other types will be null.
    public struct UsageStatistics: Swift.Equatable {
        /// The usage statistic sum organized by account ID.
        public var sumByAccount: [GuardDutyClientTypes.UsageAccountResult]?
        /// The usage statistic sum organized by on data source.
        public var sumByDataSource: [GuardDutyClientTypes.UsageDataSourceResult]?
        /// The usage statistic sum organized by resource.
        public var sumByResource: [GuardDutyClientTypes.UsageResourceResult]?
        /// Lists the top 50 resources that have generated the most GuardDuty usage, in order from most to least expensive.
        public var topResources: [GuardDutyClientTypes.UsageResourceResult]?

        public init (
            sumByAccount: [GuardDutyClientTypes.UsageAccountResult]? = nil,
            sumByDataSource: [GuardDutyClientTypes.UsageDataSourceResult]? = nil,
            sumByResource: [GuardDutyClientTypes.UsageResourceResult]? = nil,
            topResources: [GuardDutyClientTypes.UsageResourceResult]? = nil
        )
        {
            self.sumByAccount = sumByAccount
            self.sumByDataSource = sumByDataSource
            self.sumByResource = sumByResource
            self.topResources = topResources
        }
    }

}

extension GuardDutyClientTypes.Volume: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case hostPath = "hostPath"
        case name = "name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let hostPath = self.hostPath {
            try encodeContainer.encode(hostPath, forKey: .hostPath)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let hostPathDecoded = try containerValues.decodeIfPresent(GuardDutyClientTypes.HostPath.self, forKey: .hostPath)
        hostPath = hostPathDecoded
    }
}

extension GuardDutyClientTypes {
    /// Volume used by the Kubernetes workload.
    public struct Volume: Swift.Equatable {
        /// Represents a pre-existing file or directory on the host machine that the volume maps to.
        public var hostPath: GuardDutyClientTypes.HostPath?
        /// Volume name.
        public var name: Swift.String?

        public init (
            hostPath: GuardDutyClientTypes.HostPath? = nil,
            name: Swift.String? = nil
        )
        {
            self.hostPath = hostPath
            self.name = name
        }
    }

}

extension GuardDutyClientTypes.VolumeDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case deviceName = "deviceName"
        case encryptionType = "encryptionType"
        case kmsKeyArn = "kmsKeyArn"
        case snapshotArn = "snapshotArn"
        case volumeArn = "volumeArn"
        case volumeSizeInGB = "volumeSizeInGB"
        case volumeType = "volumeType"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let deviceName = self.deviceName {
            try encodeContainer.encode(deviceName, forKey: .deviceName)
        }
        if let encryptionType = self.encryptionType {
            try encodeContainer.encode(encryptionType, forKey: .encryptionType)
        }
        if let kmsKeyArn = self.kmsKeyArn {
            try encodeContainer.encode(kmsKeyArn, forKey: .kmsKeyArn)
        }
        if let snapshotArn = self.snapshotArn {
            try encodeContainer.encode(snapshotArn, forKey: .snapshotArn)
        }
        if let volumeArn = self.volumeArn {
            try encodeContainer.encode(volumeArn, forKey: .volumeArn)
        }
        if volumeSizeInGB != 0 {
            try encodeContainer.encode(volumeSizeInGB, forKey: .volumeSizeInGB)
        }
        if let volumeType = self.volumeType {
            try encodeContainer.encode(volumeType, forKey: .volumeType)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let volumeArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .volumeArn)
        volumeArn = volumeArnDecoded
        let volumeTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .volumeType)
        volumeType = volumeTypeDecoded
        let deviceNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .deviceName)
        deviceName = deviceNameDecoded
        let volumeSizeInGBDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .volumeSizeInGB) ?? 0
        volumeSizeInGB = volumeSizeInGBDecoded
        let encryptionTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .encryptionType)
        encryptionType = encryptionTypeDecoded
        let snapshotArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .snapshotArn)
        snapshotArn = snapshotArnDecoded
        let kmsKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyArn)
        kmsKeyArn = kmsKeyArnDecoded
    }
}

extension GuardDutyClientTypes {
    /// Contains EBS volume details.
    public struct VolumeDetail: Swift.Equatable {
        /// The device name for the EBS volume.
        public var deviceName: Swift.String?
        /// EBS volume encryption type.
        public var encryptionType: Swift.String?
        /// KMS key Arn used to encrypt the EBS volume.
        public var kmsKeyArn: Swift.String?
        /// Snapshot Arn of the EBS volume.
        public var snapshotArn: Swift.String?
        /// EBS volume Arn information.
        public var volumeArn: Swift.String?
        /// EBS volume size in GB.
        public var volumeSizeInGB: Swift.Int
        /// The EBS volume type.
        public var volumeType: Swift.String?

        public init (
            deviceName: Swift.String? = nil,
            encryptionType: Swift.String? = nil,
            kmsKeyArn: Swift.String? = nil,
            snapshotArn: Swift.String? = nil,
            volumeArn: Swift.String? = nil,
            volumeSizeInGB: Swift.Int = 0,
            volumeType: Swift.String? = nil
        )
        {
            self.deviceName = deviceName
            self.encryptionType = encryptionType
            self.kmsKeyArn = kmsKeyArn
            self.snapshotArn = snapshotArn
            self.volumeArn = volumeArn
            self.volumeSizeInGB = volumeSizeInGB
            self.volumeType = volumeType
        }
    }

}

extension GuardDutyClientTypes.VolumeMount: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case mountPath = "mountPath"
        case name = "name"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let mountPath = self.mountPath {
            try encodeContainer.encode(mountPath, forKey: .mountPath)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init (from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let mountPathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mountPath)
        mountPath = mountPathDecoded
    }
}

extension GuardDutyClientTypes {
    /// Container volume mount.
    public struct VolumeMount: Swift.Equatable {
        /// Volume mount path.
        public var mountPath: Swift.String?
        /// Volume mount name.
        public var name: Swift.String?

        public init (
            mountPath: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.mountPath = mountPath
            self.name = name
        }
    }

}
