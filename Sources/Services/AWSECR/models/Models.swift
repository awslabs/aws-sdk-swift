// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension ECRClientTypes.Attribute: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key
        case value
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension ECRClientTypes {
    /// This data type is used in the [ImageScanFinding] data type.
    public struct Attribute: Swift.Equatable {
        /// The attribute key.
        /// This member is required.
        public var key: Swift.String?
        /// The value assigned to the attribute key.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension ECRClientTypes.AuthorizationData: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authorizationToken
        case expiresAt
        case proxyEndpoint
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let authorizationToken = self.authorizationToken {
            try encodeContainer.encode(authorizationToken, forKey: .authorizationToken)
        }
        if let expiresAt = self.expiresAt {
            try encodeContainer.encodeTimestamp(expiresAt, format: .epochSeconds, forKey: .expiresAt)
        }
        if let proxyEndpoint = self.proxyEndpoint {
            try encodeContainer.encode(proxyEndpoint, forKey: .proxyEndpoint)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let authorizationTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .authorizationToken)
        authorizationToken = authorizationTokenDecoded
        let expiresAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .expiresAt)
        expiresAt = expiresAtDecoded
        let proxyEndpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .proxyEndpoint)
        proxyEndpoint = proxyEndpointDecoded
    }
}

extension ECRClientTypes {
    /// An object representing authorization data for an Amazon ECR registry.
    public struct AuthorizationData: Swift.Equatable {
        /// A base64-encoded string that contains authorization data for the specified Amazon ECR registry. When the string is decoded, it is presented in the format user:password for private registry authentication using docker login.
        public var authorizationToken: Swift.String?
        /// The Unix time in seconds and milliseconds when the authorization token expires. Authorization tokens are valid for 12 hours.
        public var expiresAt: ClientRuntime.Date?
        /// The registry URL to use for this authorization token in a docker login command. The Amazon ECR registry URL format is https://aws_account_id.dkr.ecr.region.amazonaws.com. For example, https://012345678910.dkr.ecr.us-east-1.amazonaws.com..
        public var proxyEndpoint: Swift.String?

        public init(
            authorizationToken: Swift.String? = nil,
            expiresAt: ClientRuntime.Date? = nil,
            proxyEndpoint: Swift.String? = nil
        )
        {
            self.authorizationToken = authorizationToken
            self.expiresAt = expiresAt
            self.proxyEndpoint = proxyEndpoint
        }
    }

}

extension ECRClientTypes.AwsEcrContainerImageDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case architecture
        case author
        case imageHash
        case imageTags
        case platform
        case pushedAt
        case registry
        case repositoryName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let architecture = self.architecture {
            try encodeContainer.encode(architecture, forKey: .architecture)
        }
        if let author = self.author {
            try encodeContainer.encode(author, forKey: .author)
        }
        if let imageHash = self.imageHash {
            try encodeContainer.encode(imageHash, forKey: .imageHash)
        }
        if let imageTags = imageTags {
            var imageTagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .imageTags)
            for imagetag0 in imageTags {
                try imageTagsContainer.encode(imagetag0)
            }
        }
        if let platform = self.platform {
            try encodeContainer.encode(platform, forKey: .platform)
        }
        if let pushedAt = self.pushedAt {
            try encodeContainer.encodeTimestamp(pushedAt, format: .epochSeconds, forKey: .pushedAt)
        }
        if let registry = self.registry {
            try encodeContainer.encode(registry, forKey: .registry)
        }
        if let repositoryName = self.repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let architectureDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .architecture)
        architecture = architectureDecoded
        let authorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .author)
        author = authorDecoded
        let imageHashDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageHash)
        imageHash = imageHashDecoded
        let imageTagsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .imageTags)
        var imageTagsDecoded0:[Swift.String]? = nil
        if let imageTagsContainer = imageTagsContainer {
            imageTagsDecoded0 = [Swift.String]()
            for string0 in imageTagsContainer {
                if let string0 = string0 {
                    imageTagsDecoded0?.append(string0)
                }
            }
        }
        imageTags = imageTagsDecoded0
        let platformDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .platform)
        platform = platformDecoded
        let pushedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .pushedAt)
        pushedAt = pushedAtDecoded
        let registryDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registry)
        registry = registryDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
    }
}

extension ECRClientTypes {
    /// The image details of the Amazon ECR container image.
    public struct AwsEcrContainerImageDetails: Swift.Equatable {
        /// The architecture of the Amazon ECR container image.
        public var architecture: Swift.String?
        /// The image author of the Amazon ECR container image.
        public var author: Swift.String?
        /// The image hash of the Amazon ECR container image.
        public var imageHash: Swift.String?
        /// The image tags attached to the Amazon ECR container image.
        public var imageTags: [Swift.String]?
        /// The platform of the Amazon ECR container image.
        public var platform: Swift.String?
        /// The date and time the Amazon ECR container image was pushed.
        public var pushedAt: ClientRuntime.Date?
        /// The registry the Amazon ECR container image belongs to.
        public var registry: Swift.String?
        /// The name of the repository the Amazon ECR container image resides in.
        public var repositoryName: Swift.String?

        public init(
            architecture: Swift.String? = nil,
            author: Swift.String? = nil,
            imageHash: Swift.String? = nil,
            imageTags: [Swift.String]? = nil,
            platform: Swift.String? = nil,
            pushedAt: ClientRuntime.Date? = nil,
            registry: Swift.String? = nil,
            repositoryName: Swift.String? = nil
        )
        {
            self.architecture = architecture
            self.author = author
            self.imageHash = imageHash
            self.imageTags = imageTags
            self.platform = platform
            self.pushedAt = pushedAt
            self.registry = registry
            self.repositoryName = repositoryName
        }
    }

}

extension BatchCheckLayerAvailabilityInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case layerDigests
        case registryId
        case repositoryName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let layerDigests = layerDigests {
            var layerDigestsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .layerDigests)
            for batchedoperationlayerdigest0 in layerDigests {
                try layerDigestsContainer.encode(batchedoperationlayerdigest0)
            }
        }
        if let registryId = self.registryId {
            try encodeContainer.encode(registryId, forKey: .registryId)
        }
        if let repositoryName = self.repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }
}

extension BatchCheckLayerAvailabilityInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct BatchCheckLayerAvailabilityInput: Swift.Equatable {
    /// The digests of the image layers to check.
    /// This member is required.
    public var layerDigests: [Swift.String]?
    /// The Amazon Web Services account ID associated with the registry that contains the image layers to check. If you do not specify a registry, the default registry is assumed.
    public var registryId: Swift.String?
    /// The name of the repository that is associated with the image layers to check.
    /// This member is required.
    public var repositoryName: Swift.String?

    public init(
        layerDigests: [Swift.String]? = nil,
        registryId: Swift.String? = nil,
        repositoryName: Swift.String? = nil
    )
    {
        self.layerDigests = layerDigests
        self.registryId = registryId
        self.repositoryName = repositoryName
    }
}

struct BatchCheckLayerAvailabilityInputBody: Swift.Equatable {
    let registryId: Swift.String?
    let repositoryName: Swift.String?
    let layerDigests: [Swift.String]?
}

extension BatchCheckLayerAvailabilityInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case layerDigests
        case registryId
        case repositoryName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let layerDigestsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .layerDigests)
        var layerDigestsDecoded0:[Swift.String]? = nil
        if let layerDigestsContainer = layerDigestsContainer {
            layerDigestsDecoded0 = [Swift.String]()
            for string0 in layerDigestsContainer {
                if let string0 = string0 {
                    layerDigestsDecoded0?.append(string0)
                }
            }
        }
        layerDigests = layerDigestsDecoded0
    }
}

extension BatchCheckLayerAvailabilityOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: BatchCheckLayerAvailabilityOutputBody = try responseDecoder.decode(responseBody: data)
            self.failures = output.failures
            self.layers = output.layers
        } else {
            self.failures = nil
            self.layers = nil
        }
    }
}

public struct BatchCheckLayerAvailabilityOutput: Swift.Equatable {
    /// Any failures associated with the call.
    public var failures: [ECRClientTypes.LayerFailure]?
    /// A list of image layer objects corresponding to the image layer references in the request.
    public var layers: [ECRClientTypes.Layer]?

    public init(
        failures: [ECRClientTypes.LayerFailure]? = nil,
        layers: [ECRClientTypes.Layer]? = nil
    )
    {
        self.failures = failures
        self.layers = layers
    }
}

struct BatchCheckLayerAvailabilityOutputBody: Swift.Equatable {
    let layers: [ECRClientTypes.Layer]?
    let failures: [ECRClientTypes.LayerFailure]?
}

extension BatchCheckLayerAvailabilityOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failures
        case layers
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let layersContainer = try containerValues.decodeIfPresent([ECRClientTypes.Layer?].self, forKey: .layers)
        var layersDecoded0:[ECRClientTypes.Layer]? = nil
        if let layersContainer = layersContainer {
            layersDecoded0 = [ECRClientTypes.Layer]()
            for structure0 in layersContainer {
                if let structure0 = structure0 {
                    layersDecoded0?.append(structure0)
                }
            }
        }
        layers = layersDecoded0
        let failuresContainer = try containerValues.decodeIfPresent([ECRClientTypes.LayerFailure?].self, forKey: .failures)
        var failuresDecoded0:[ECRClientTypes.LayerFailure]? = nil
        if let failuresContainer = failuresContainer {
            failuresDecoded0 = [ECRClientTypes.LayerFailure]()
            for structure0 in failuresContainer {
                if let structure0 = structure0 {
                    failuresDecoded0?.append(structure0)
                }
            }
        }
        failures = failuresDecoded0
    }
}

enum BatchCheckLayerAvailabilityOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RepositoryNotFoundException": return try await RepositoryNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServerException": return try await ServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension BatchDeleteImageInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imageIds
        case registryId
        case repositoryName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let imageIds = imageIds {
            var imageIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .imageIds)
            for imageidentifier0 in imageIds {
                try imageIdsContainer.encode(imageidentifier0)
            }
        }
        if let registryId = self.registryId {
            try encodeContainer.encode(registryId, forKey: .registryId)
        }
        if let repositoryName = self.repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }
}

extension BatchDeleteImageInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

/// Deletes specified images within a specified repository. Images are specified with either the imageTag or imageDigest.
public struct BatchDeleteImageInput: Swift.Equatable {
    /// A list of image ID references that correspond to images to delete. The format of the imageIds reference is imageTag=tag or imageDigest=digest.
    /// This member is required.
    public var imageIds: [ECRClientTypes.ImageIdentifier]?
    /// The Amazon Web Services account ID associated with the registry that contains the image to delete. If you do not specify a registry, the default registry is assumed.
    public var registryId: Swift.String?
    /// The repository that contains the image to delete.
    /// This member is required.
    public var repositoryName: Swift.String?

    public init(
        imageIds: [ECRClientTypes.ImageIdentifier]? = nil,
        registryId: Swift.String? = nil,
        repositoryName: Swift.String? = nil
    )
    {
        self.imageIds = imageIds
        self.registryId = registryId
        self.repositoryName = repositoryName
    }
}

struct BatchDeleteImageInputBody: Swift.Equatable {
    let registryId: Swift.String?
    let repositoryName: Swift.String?
    let imageIds: [ECRClientTypes.ImageIdentifier]?
}

extension BatchDeleteImageInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imageIds
        case registryId
        case repositoryName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let imageIdsContainer = try containerValues.decodeIfPresent([ECRClientTypes.ImageIdentifier?].self, forKey: .imageIds)
        var imageIdsDecoded0:[ECRClientTypes.ImageIdentifier]? = nil
        if let imageIdsContainer = imageIdsContainer {
            imageIdsDecoded0 = [ECRClientTypes.ImageIdentifier]()
            for structure0 in imageIdsContainer {
                if let structure0 = structure0 {
                    imageIdsDecoded0?.append(structure0)
                }
            }
        }
        imageIds = imageIdsDecoded0
    }
}

extension BatchDeleteImageOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: BatchDeleteImageOutputBody = try responseDecoder.decode(responseBody: data)
            self.failures = output.failures
            self.imageIds = output.imageIds
        } else {
            self.failures = nil
            self.imageIds = nil
        }
    }
}

public struct BatchDeleteImageOutput: Swift.Equatable {
    /// Any failures associated with the call.
    public var failures: [ECRClientTypes.ImageFailure]?
    /// The image IDs of the deleted images.
    public var imageIds: [ECRClientTypes.ImageIdentifier]?

    public init(
        failures: [ECRClientTypes.ImageFailure]? = nil,
        imageIds: [ECRClientTypes.ImageIdentifier]? = nil
    )
    {
        self.failures = failures
        self.imageIds = imageIds
    }
}

struct BatchDeleteImageOutputBody: Swift.Equatable {
    let imageIds: [ECRClientTypes.ImageIdentifier]?
    let failures: [ECRClientTypes.ImageFailure]?
}

extension BatchDeleteImageOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failures
        case imageIds
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imageIdsContainer = try containerValues.decodeIfPresent([ECRClientTypes.ImageIdentifier?].self, forKey: .imageIds)
        var imageIdsDecoded0:[ECRClientTypes.ImageIdentifier]? = nil
        if let imageIdsContainer = imageIdsContainer {
            imageIdsDecoded0 = [ECRClientTypes.ImageIdentifier]()
            for structure0 in imageIdsContainer {
                if let structure0 = structure0 {
                    imageIdsDecoded0?.append(structure0)
                }
            }
        }
        imageIds = imageIdsDecoded0
        let failuresContainer = try containerValues.decodeIfPresent([ECRClientTypes.ImageFailure?].self, forKey: .failures)
        var failuresDecoded0:[ECRClientTypes.ImageFailure]? = nil
        if let failuresContainer = failuresContainer {
            failuresDecoded0 = [ECRClientTypes.ImageFailure]()
            for structure0 in failuresContainer {
                if let structure0 = structure0 {
                    failuresDecoded0?.append(structure0)
                }
            }
        }
        failures = failuresDecoded0
    }
}

enum BatchDeleteImageOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RepositoryNotFoundException": return try await RepositoryNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServerException": return try await ServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension BatchGetImageInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptedMediaTypes
        case imageIds
        case registryId
        case repositoryName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let acceptedMediaTypes = acceptedMediaTypes {
            var acceptedMediaTypesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .acceptedMediaTypes)
            for mediatype0 in acceptedMediaTypes {
                try acceptedMediaTypesContainer.encode(mediatype0)
            }
        }
        if let imageIds = imageIds {
            var imageIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .imageIds)
            for imageidentifier0 in imageIds {
                try imageIdsContainer.encode(imageidentifier0)
            }
        }
        if let registryId = self.registryId {
            try encodeContainer.encode(registryId, forKey: .registryId)
        }
        if let repositoryName = self.repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }
}

extension BatchGetImageInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct BatchGetImageInput: Swift.Equatable {
    /// The accepted media types for the request. Valid values: application/vnd.docker.distribution.manifest.v1+json | application/vnd.docker.distribution.manifest.v2+json | application/vnd.oci.image.manifest.v1+json
    public var acceptedMediaTypes: [Swift.String]?
    /// A list of image ID references that correspond to images to describe. The format of the imageIds reference is imageTag=tag or imageDigest=digest.
    /// This member is required.
    public var imageIds: [ECRClientTypes.ImageIdentifier]?
    /// The Amazon Web Services account ID associated with the registry that contains the images to describe. If you do not specify a registry, the default registry is assumed.
    public var registryId: Swift.String?
    /// The repository that contains the images to describe.
    /// This member is required.
    public var repositoryName: Swift.String?

    public init(
        acceptedMediaTypes: [Swift.String]? = nil,
        imageIds: [ECRClientTypes.ImageIdentifier]? = nil,
        registryId: Swift.String? = nil,
        repositoryName: Swift.String? = nil
    )
    {
        self.acceptedMediaTypes = acceptedMediaTypes
        self.imageIds = imageIds
        self.registryId = registryId
        self.repositoryName = repositoryName
    }
}

struct BatchGetImageInputBody: Swift.Equatable {
    let registryId: Swift.String?
    let repositoryName: Swift.String?
    let imageIds: [ECRClientTypes.ImageIdentifier]?
    let acceptedMediaTypes: [Swift.String]?
}

extension BatchGetImageInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case acceptedMediaTypes
        case imageIds
        case registryId
        case repositoryName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let imageIdsContainer = try containerValues.decodeIfPresent([ECRClientTypes.ImageIdentifier?].self, forKey: .imageIds)
        var imageIdsDecoded0:[ECRClientTypes.ImageIdentifier]? = nil
        if let imageIdsContainer = imageIdsContainer {
            imageIdsDecoded0 = [ECRClientTypes.ImageIdentifier]()
            for structure0 in imageIdsContainer {
                if let structure0 = structure0 {
                    imageIdsDecoded0?.append(structure0)
                }
            }
        }
        imageIds = imageIdsDecoded0
        let acceptedMediaTypesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .acceptedMediaTypes)
        var acceptedMediaTypesDecoded0:[Swift.String]? = nil
        if let acceptedMediaTypesContainer = acceptedMediaTypesContainer {
            acceptedMediaTypesDecoded0 = [Swift.String]()
            for string0 in acceptedMediaTypesContainer {
                if let string0 = string0 {
                    acceptedMediaTypesDecoded0?.append(string0)
                }
            }
        }
        acceptedMediaTypes = acceptedMediaTypesDecoded0
    }
}

extension BatchGetImageOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: BatchGetImageOutputBody = try responseDecoder.decode(responseBody: data)
            self.failures = output.failures
            self.images = output.images
        } else {
            self.failures = nil
            self.images = nil
        }
    }
}

public struct BatchGetImageOutput: Swift.Equatable {
    /// Any failures associated with the call.
    public var failures: [ECRClientTypes.ImageFailure]?
    /// A list of image objects corresponding to the image references in the request.
    public var images: [ECRClientTypes.Image]?

    public init(
        failures: [ECRClientTypes.ImageFailure]? = nil,
        images: [ECRClientTypes.Image]? = nil
    )
    {
        self.failures = failures
        self.images = images
    }
}

struct BatchGetImageOutputBody: Swift.Equatable {
    let images: [ECRClientTypes.Image]?
    let failures: [ECRClientTypes.ImageFailure]?
}

extension BatchGetImageOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failures
        case images
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imagesContainer = try containerValues.decodeIfPresent([ECRClientTypes.Image?].self, forKey: .images)
        var imagesDecoded0:[ECRClientTypes.Image]? = nil
        if let imagesContainer = imagesContainer {
            imagesDecoded0 = [ECRClientTypes.Image]()
            for structure0 in imagesContainer {
                if let structure0 = structure0 {
                    imagesDecoded0?.append(structure0)
                }
            }
        }
        images = imagesDecoded0
        let failuresContainer = try containerValues.decodeIfPresent([ECRClientTypes.ImageFailure?].self, forKey: .failures)
        var failuresDecoded0:[ECRClientTypes.ImageFailure]? = nil
        if let failuresContainer = failuresContainer {
            failuresDecoded0 = [ECRClientTypes.ImageFailure]()
            for structure0 in failuresContainer {
                if let structure0 = structure0 {
                    failuresDecoded0?.append(structure0)
                }
            }
        }
        failures = failuresDecoded0
    }
}

enum BatchGetImageOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RepositoryNotFoundException": return try await RepositoryNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServerException": return try await ServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension BatchGetRepositoryScanningConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case repositoryNames
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let repositoryNames = repositoryNames {
            var repositoryNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .repositoryNames)
            for repositoryname0 in repositoryNames {
                try repositoryNamesContainer.encode(repositoryname0)
            }
        }
    }
}

extension BatchGetRepositoryScanningConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct BatchGetRepositoryScanningConfigurationInput: Swift.Equatable {
    /// One or more repository names to get the scanning configuration for.
    /// This member is required.
    public var repositoryNames: [Swift.String]?

    public init(
        repositoryNames: [Swift.String]? = nil
    )
    {
        self.repositoryNames = repositoryNames
    }
}

struct BatchGetRepositoryScanningConfigurationInputBody: Swift.Equatable {
    let repositoryNames: [Swift.String]?
}

extension BatchGetRepositoryScanningConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case repositoryNames
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .repositoryNames)
        var repositoryNamesDecoded0:[Swift.String]? = nil
        if let repositoryNamesContainer = repositoryNamesContainer {
            repositoryNamesDecoded0 = [Swift.String]()
            for string0 in repositoryNamesContainer {
                if let string0 = string0 {
                    repositoryNamesDecoded0?.append(string0)
                }
            }
        }
        repositoryNames = repositoryNamesDecoded0
    }
}

extension BatchGetRepositoryScanningConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: BatchGetRepositoryScanningConfigurationOutputBody = try responseDecoder.decode(responseBody: data)
            self.failures = output.failures
            self.scanningConfigurations = output.scanningConfigurations
        } else {
            self.failures = nil
            self.scanningConfigurations = nil
        }
    }
}

public struct BatchGetRepositoryScanningConfigurationOutput: Swift.Equatable {
    /// Any failures associated with the call.
    public var failures: [ECRClientTypes.RepositoryScanningConfigurationFailure]?
    /// The scanning configuration for the requested repositories.
    public var scanningConfigurations: [ECRClientTypes.RepositoryScanningConfiguration]?

    public init(
        failures: [ECRClientTypes.RepositoryScanningConfigurationFailure]? = nil,
        scanningConfigurations: [ECRClientTypes.RepositoryScanningConfiguration]? = nil
    )
    {
        self.failures = failures
        self.scanningConfigurations = scanningConfigurations
    }
}

struct BatchGetRepositoryScanningConfigurationOutputBody: Swift.Equatable {
    let scanningConfigurations: [ECRClientTypes.RepositoryScanningConfiguration]?
    let failures: [ECRClientTypes.RepositoryScanningConfigurationFailure]?
}

extension BatchGetRepositoryScanningConfigurationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failures
        case scanningConfigurations
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scanningConfigurationsContainer = try containerValues.decodeIfPresent([ECRClientTypes.RepositoryScanningConfiguration?].self, forKey: .scanningConfigurations)
        var scanningConfigurationsDecoded0:[ECRClientTypes.RepositoryScanningConfiguration]? = nil
        if let scanningConfigurationsContainer = scanningConfigurationsContainer {
            scanningConfigurationsDecoded0 = [ECRClientTypes.RepositoryScanningConfiguration]()
            for structure0 in scanningConfigurationsContainer {
                if let structure0 = structure0 {
                    scanningConfigurationsDecoded0?.append(structure0)
                }
            }
        }
        scanningConfigurations = scanningConfigurationsDecoded0
        let failuresContainer = try containerValues.decodeIfPresent([ECRClientTypes.RepositoryScanningConfigurationFailure?].self, forKey: .failures)
        var failuresDecoded0:[ECRClientTypes.RepositoryScanningConfigurationFailure]? = nil
        if let failuresContainer = failuresContainer {
            failuresDecoded0 = [ECRClientTypes.RepositoryScanningConfigurationFailure]()
            for structure0 in failuresContainer {
                if let structure0 = structure0 {
                    failuresDecoded0?.append(structure0)
                }
            }
        }
        failures = failuresDecoded0
    }
}

enum BatchGetRepositoryScanningConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RepositoryNotFoundException": return try await RepositoryNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServerException": return try await ServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CompleteLayerUploadInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case layerDigests
        case registryId
        case repositoryName
        case uploadId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let layerDigests = layerDigests {
            var layerDigestsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .layerDigests)
            for layerdigest0 in layerDigests {
                try layerDigestsContainer.encode(layerdigest0)
            }
        }
        if let registryId = self.registryId {
            try encodeContainer.encode(registryId, forKey: .registryId)
        }
        if let repositoryName = self.repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
        if let uploadId = self.uploadId {
            try encodeContainer.encode(uploadId, forKey: .uploadId)
        }
    }
}

extension CompleteLayerUploadInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CompleteLayerUploadInput: Swift.Equatable {
    /// The sha256 digest of the image layer.
    /// This member is required.
    public var layerDigests: [Swift.String]?
    /// The Amazon Web Services account ID associated with the registry to which to upload layers. If you do not specify a registry, the default registry is assumed.
    public var registryId: Swift.String?
    /// The name of the repository to associate with the image layer.
    /// This member is required.
    public var repositoryName: Swift.String?
    /// The upload ID from a previous [InitiateLayerUpload] operation to associate with the image layer.
    /// This member is required.
    public var uploadId: Swift.String?

    public init(
        layerDigests: [Swift.String]? = nil,
        registryId: Swift.String? = nil,
        repositoryName: Swift.String? = nil,
        uploadId: Swift.String? = nil
    )
    {
        self.layerDigests = layerDigests
        self.registryId = registryId
        self.repositoryName = repositoryName
        self.uploadId = uploadId
    }
}

struct CompleteLayerUploadInputBody: Swift.Equatable {
    let registryId: Swift.String?
    let repositoryName: Swift.String?
    let uploadId: Swift.String?
    let layerDigests: [Swift.String]?
}

extension CompleteLayerUploadInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case layerDigests
        case registryId
        case repositoryName
        case uploadId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let uploadIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .uploadId)
        uploadId = uploadIdDecoded
        let layerDigestsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .layerDigests)
        var layerDigestsDecoded0:[Swift.String]? = nil
        if let layerDigestsContainer = layerDigestsContainer {
            layerDigestsDecoded0 = [Swift.String]()
            for string0 in layerDigestsContainer {
                if let string0 = string0 {
                    layerDigestsDecoded0?.append(string0)
                }
            }
        }
        layerDigests = layerDigestsDecoded0
    }
}

extension CompleteLayerUploadOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CompleteLayerUploadOutputBody = try responseDecoder.decode(responseBody: data)
            self.layerDigest = output.layerDigest
            self.registryId = output.registryId
            self.repositoryName = output.repositoryName
            self.uploadId = output.uploadId
        } else {
            self.layerDigest = nil
            self.registryId = nil
            self.repositoryName = nil
            self.uploadId = nil
        }
    }
}

public struct CompleteLayerUploadOutput: Swift.Equatable {
    /// The sha256 digest of the image layer.
    public var layerDigest: Swift.String?
    /// The registry ID associated with the request.
    public var registryId: Swift.String?
    /// The repository name associated with the request.
    public var repositoryName: Swift.String?
    /// The upload ID associated with the layer.
    public var uploadId: Swift.String?

    public init(
        layerDigest: Swift.String? = nil,
        registryId: Swift.String? = nil,
        repositoryName: Swift.String? = nil,
        uploadId: Swift.String? = nil
    )
    {
        self.layerDigest = layerDigest
        self.registryId = registryId
        self.repositoryName = repositoryName
        self.uploadId = uploadId
    }
}

struct CompleteLayerUploadOutputBody: Swift.Equatable {
    let registryId: Swift.String?
    let repositoryName: Swift.String?
    let uploadId: Swift.String?
    let layerDigest: Swift.String?
}

extension CompleteLayerUploadOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case layerDigest
        case registryId
        case repositoryName
        case uploadId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let uploadIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .uploadId)
        uploadId = uploadIdDecoded
        let layerDigestDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .layerDigest)
        layerDigest = layerDigestDecoded
    }
}

enum CompleteLayerUploadOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "EmptyUploadException": return try await EmptyUploadException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidLayerException": return try await InvalidLayerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "KmsException": return try await KmsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LayerAlreadyExistsException": return try await LayerAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LayerPartTooSmallException": return try await LayerPartTooSmallException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RepositoryNotFoundException": return try await RepositoryNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServerException": return try await ServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UploadNotFoundException": return try await UploadNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreatePullThroughCacheRuleInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ecrRepositoryPrefix
        case registryId
        case upstreamRegistryUrl
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ecrRepositoryPrefix = self.ecrRepositoryPrefix {
            try encodeContainer.encode(ecrRepositoryPrefix, forKey: .ecrRepositoryPrefix)
        }
        if let registryId = self.registryId {
            try encodeContainer.encode(registryId, forKey: .registryId)
        }
        if let upstreamRegistryUrl = self.upstreamRegistryUrl {
            try encodeContainer.encode(upstreamRegistryUrl, forKey: .upstreamRegistryUrl)
        }
    }
}

extension CreatePullThroughCacheRuleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreatePullThroughCacheRuleInput: Swift.Equatable {
    /// The repository name prefix to use when caching images from the source registry.
    /// This member is required.
    public var ecrRepositoryPrefix: Swift.String?
    /// The Amazon Web Services account ID associated with the registry to create the pull through cache rule for. If you do not specify a registry, the default registry is assumed.
    public var registryId: Swift.String?
    /// The registry URL of the upstream public registry to use as the source for the pull through cache rule.
    /// This member is required.
    public var upstreamRegistryUrl: Swift.String?

    public init(
        ecrRepositoryPrefix: Swift.String? = nil,
        registryId: Swift.String? = nil,
        upstreamRegistryUrl: Swift.String? = nil
    )
    {
        self.ecrRepositoryPrefix = ecrRepositoryPrefix
        self.registryId = registryId
        self.upstreamRegistryUrl = upstreamRegistryUrl
    }
}

struct CreatePullThroughCacheRuleInputBody: Swift.Equatable {
    let ecrRepositoryPrefix: Swift.String?
    let upstreamRegistryUrl: Swift.String?
    let registryId: Swift.String?
}

extension CreatePullThroughCacheRuleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ecrRepositoryPrefix
        case registryId
        case upstreamRegistryUrl
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ecrRepositoryPrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ecrRepositoryPrefix)
        ecrRepositoryPrefix = ecrRepositoryPrefixDecoded
        let upstreamRegistryUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .upstreamRegistryUrl)
        upstreamRegistryUrl = upstreamRegistryUrlDecoded
        let registryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registryId)
        registryId = registryIdDecoded
    }
}

extension CreatePullThroughCacheRuleOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreatePullThroughCacheRuleOutputBody = try responseDecoder.decode(responseBody: data)
            self.createdAt = output.createdAt
            self.ecrRepositoryPrefix = output.ecrRepositoryPrefix
            self.registryId = output.registryId
            self.upstreamRegistryUrl = output.upstreamRegistryUrl
        } else {
            self.createdAt = nil
            self.ecrRepositoryPrefix = nil
            self.registryId = nil
            self.upstreamRegistryUrl = nil
        }
    }
}

public struct CreatePullThroughCacheRuleOutput: Swift.Equatable {
    /// The date and time, in JavaScript date format, when the pull through cache rule was created.
    public var createdAt: ClientRuntime.Date?
    /// The Amazon ECR repository prefix associated with the pull through cache rule.
    public var ecrRepositoryPrefix: Swift.String?
    /// The registry ID associated with the request.
    public var registryId: Swift.String?
    /// The upstream registry URL associated with the pull through cache rule.
    public var upstreamRegistryUrl: Swift.String?

    public init(
        createdAt: ClientRuntime.Date? = nil,
        ecrRepositoryPrefix: Swift.String? = nil,
        registryId: Swift.String? = nil,
        upstreamRegistryUrl: Swift.String? = nil
    )
    {
        self.createdAt = createdAt
        self.ecrRepositoryPrefix = ecrRepositoryPrefix
        self.registryId = registryId
        self.upstreamRegistryUrl = upstreamRegistryUrl
    }
}

struct CreatePullThroughCacheRuleOutputBody: Swift.Equatable {
    let ecrRepositoryPrefix: Swift.String?
    let upstreamRegistryUrl: Swift.String?
    let createdAt: ClientRuntime.Date?
    let registryId: Swift.String?
}

extension CreatePullThroughCacheRuleOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt
        case ecrRepositoryPrefix
        case registryId
        case upstreamRegistryUrl
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ecrRepositoryPrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ecrRepositoryPrefix)
        ecrRepositoryPrefix = ecrRepositoryPrefixDecoded
        let upstreamRegistryUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .upstreamRegistryUrl)
        upstreamRegistryUrl = upstreamRegistryUrlDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let registryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registryId)
        registryId = registryIdDecoded
    }
}

enum CreatePullThroughCacheRuleOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PullThroughCacheRuleAlreadyExistsException": return try await PullThroughCacheRuleAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServerException": return try await ServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnsupportedUpstreamRegistryException": return try await UnsupportedUpstreamRegistryException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension CreateRepositoryInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case encryptionConfiguration
        case imageScanningConfiguration
        case imageTagMutability
        case registryId
        case repositoryName
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let encryptionConfiguration = self.encryptionConfiguration {
            try encodeContainer.encode(encryptionConfiguration, forKey: .encryptionConfiguration)
        }
        if let imageScanningConfiguration = self.imageScanningConfiguration {
            try encodeContainer.encode(imageScanningConfiguration, forKey: .imageScanningConfiguration)
        }
        if let imageTagMutability = self.imageTagMutability {
            try encodeContainer.encode(imageTagMutability.rawValue, forKey: .imageTagMutability)
        }
        if let registryId = self.registryId {
            try encodeContainer.encode(registryId, forKey: .registryId)
        }
        if let repositoryName = self.repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension CreateRepositoryInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct CreateRepositoryInput: Swift.Equatable {
    /// The encryption configuration for the repository. This determines how the contents of your repository are encrypted at rest.
    public var encryptionConfiguration: ECRClientTypes.EncryptionConfiguration?
    /// The image scanning configuration for the repository. This determines whether images are scanned for known vulnerabilities after being pushed to the repository.
    public var imageScanningConfiguration: ECRClientTypes.ImageScanningConfiguration?
    /// The tag mutability setting for the repository. If this parameter is omitted, the default setting of MUTABLE will be used which will allow image tags to be overwritten. If IMMUTABLE is specified, all image tags within the repository will be immutable which will prevent them from being overwritten.
    public var imageTagMutability: ECRClientTypes.ImageTagMutability?
    /// The Amazon Web Services account ID associated with the registry to create the repository. If you do not specify a registry, the default registry is assumed.
    public var registryId: Swift.String?
    /// The name to use for the repository. The repository name may be specified on its own (such as nginx-web-app) or it can be prepended with a namespace to group the repository into a category (such as project-a/nginx-web-app). The repository name must start with a letter and can only contain lowercase letters, numbers, hyphens, underscores, and forward slashes.
    /// This member is required.
    public var repositoryName: Swift.String?
    /// The metadata that you apply to the repository to help you categorize and organize them. Each tag consists of a key and an optional value, both of which you define. Tag keys can have a maximum character length of 128 characters, and tag values can have a maximum length of 256 characters.
    public var tags: [ECRClientTypes.Tag]?

    public init(
        encryptionConfiguration: ECRClientTypes.EncryptionConfiguration? = nil,
        imageScanningConfiguration: ECRClientTypes.ImageScanningConfiguration? = nil,
        imageTagMutability: ECRClientTypes.ImageTagMutability? = nil,
        registryId: Swift.String? = nil,
        repositoryName: Swift.String? = nil,
        tags: [ECRClientTypes.Tag]? = nil
    )
    {
        self.encryptionConfiguration = encryptionConfiguration
        self.imageScanningConfiguration = imageScanningConfiguration
        self.imageTagMutability = imageTagMutability
        self.registryId = registryId
        self.repositoryName = repositoryName
        self.tags = tags
    }
}

struct CreateRepositoryInputBody: Swift.Equatable {
    let registryId: Swift.String?
    let repositoryName: Swift.String?
    let tags: [ECRClientTypes.Tag]?
    let imageTagMutability: ECRClientTypes.ImageTagMutability?
    let imageScanningConfiguration: ECRClientTypes.ImageScanningConfiguration?
    let encryptionConfiguration: ECRClientTypes.EncryptionConfiguration?
}

extension CreateRepositoryInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case encryptionConfiguration
        case imageScanningConfiguration
        case imageTagMutability
        case registryId
        case repositoryName
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let tagsContainer = try containerValues.decodeIfPresent([ECRClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ECRClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ECRClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
        let imageTagMutabilityDecoded = try containerValues.decodeIfPresent(ECRClientTypes.ImageTagMutability.self, forKey: .imageTagMutability)
        imageTagMutability = imageTagMutabilityDecoded
        let imageScanningConfigurationDecoded = try containerValues.decodeIfPresent(ECRClientTypes.ImageScanningConfiguration.self, forKey: .imageScanningConfiguration)
        imageScanningConfiguration = imageScanningConfigurationDecoded
        let encryptionConfigurationDecoded = try containerValues.decodeIfPresent(ECRClientTypes.EncryptionConfiguration.self, forKey: .encryptionConfiguration)
        encryptionConfiguration = encryptionConfigurationDecoded
    }
}

extension CreateRepositoryOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateRepositoryOutputBody = try responseDecoder.decode(responseBody: data)
            self.repository = output.repository
        } else {
            self.repository = nil
        }
    }
}

public struct CreateRepositoryOutput: Swift.Equatable {
    /// The repository that was created.
    public var repository: ECRClientTypes.Repository?

    public init(
        repository: ECRClientTypes.Repository? = nil
    )
    {
        self.repository = repository
    }
}

struct CreateRepositoryOutputBody: Swift.Equatable {
    let repository: ECRClientTypes.Repository?
}

extension CreateRepositoryOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case repository
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryDecoded = try containerValues.decodeIfPresent(ECRClientTypes.Repository.self, forKey: .repository)
        repository = repositoryDecoded
    }
}

enum CreateRepositoryOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidTagParameterException": return try await InvalidTagParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "KmsException": return try await KmsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RepositoryAlreadyExistsException": return try await RepositoryAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServerException": return try await ServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyTagsException": return try await TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ECRClientTypes.CvssScore: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case baseScore
        case scoringVector
        case source
        case version
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if baseScore != 0.0 {
            try encodeContainer.encode(baseScore, forKey: .baseScore)
        }
        if let scoringVector = self.scoringVector {
            try encodeContainer.encode(scoringVector, forKey: .scoringVector)
        }
        if let source = self.source {
            try encodeContainer.encode(source, forKey: .source)
        }
        if let version = self.version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let baseScoreDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .baseScore) ?? 0.0
        baseScore = baseScoreDecoded
        let scoringVectorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .scoringVector)
        scoringVector = scoringVectorDecoded
        let sourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .source)
        source = sourceDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
    }
}

extension ECRClientTypes {
    /// The CVSS score for a finding.
    public struct CvssScore: Swift.Equatable {
        /// The base CVSS score used for the finding.
        public var baseScore: Swift.Double
        /// The vector string of the CVSS score.
        public var scoringVector: Swift.String?
        /// The source of the CVSS score.
        public var source: Swift.String?
        /// The version of CVSS used for the score.
        public var version: Swift.String?

        public init(
            baseScore: Swift.Double = 0.0,
            scoringVector: Swift.String? = nil,
            source: Swift.String? = nil,
            version: Swift.String? = nil
        )
        {
            self.baseScore = baseScore
            self.scoringVector = scoringVector
            self.source = source
            self.version = version
        }
    }

}

extension ECRClientTypes.CvssScoreAdjustment: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case metric
        case reason
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let metric = self.metric {
            try encodeContainer.encode(metric, forKey: .metric)
        }
        if let reason = self.reason {
            try encodeContainer.encode(reason, forKey: .reason)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let metricDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .metric)
        metric = metricDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .reason)
        reason = reasonDecoded
    }
}

extension ECRClientTypes {
    /// Details on adjustments Amazon Inspector made to the CVSS score for a finding.
    public struct CvssScoreAdjustment: Swift.Equatable {
        /// The metric used to adjust the CVSS score.
        public var metric: Swift.String?
        /// The reason the CVSS score has been adjustment.
        public var reason: Swift.String?

        public init(
            metric: Swift.String? = nil,
            reason: Swift.String? = nil
        )
        {
            self.metric = metric
            self.reason = reason
        }
    }

}

extension ECRClientTypes.CvssScoreDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case adjustments
        case score
        case scoreSource
        case scoringVector
        case version
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let adjustments = adjustments {
            var adjustmentsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .adjustments)
            for cvssscoreadjustment0 in adjustments {
                try adjustmentsContainer.encode(cvssscoreadjustment0)
            }
        }
        if score != 0.0 {
            try encodeContainer.encode(score, forKey: .score)
        }
        if let scoreSource = self.scoreSource {
            try encodeContainer.encode(scoreSource, forKey: .scoreSource)
        }
        if let scoringVector = self.scoringVector {
            try encodeContainer.encode(scoringVector, forKey: .scoringVector)
        }
        if let version = self.version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let adjustmentsContainer = try containerValues.decodeIfPresent([ECRClientTypes.CvssScoreAdjustment?].self, forKey: .adjustments)
        var adjustmentsDecoded0:[ECRClientTypes.CvssScoreAdjustment]? = nil
        if let adjustmentsContainer = adjustmentsContainer {
            adjustmentsDecoded0 = [ECRClientTypes.CvssScoreAdjustment]()
            for structure0 in adjustmentsContainer {
                if let structure0 = structure0 {
                    adjustmentsDecoded0?.append(structure0)
                }
            }
        }
        adjustments = adjustmentsDecoded0
        let scoreDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .score) ?? 0.0
        score = scoreDecoded
        let scoreSourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .scoreSource)
        scoreSource = scoreSourceDecoded
        let scoringVectorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .scoringVector)
        scoringVector = scoringVectorDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
    }
}

extension ECRClientTypes {
    /// Information about the CVSS score.
    public struct CvssScoreDetails: Swift.Equatable {
        /// An object that contains details about adjustment Amazon Inspector made to the CVSS score.
        public var adjustments: [ECRClientTypes.CvssScoreAdjustment]?
        /// The CVSS score.
        public var score: Swift.Double
        /// The source for the CVSS score.
        public var scoreSource: Swift.String?
        /// The vector for the CVSS score.
        public var scoringVector: Swift.String?
        /// The CVSS version used in scoring.
        public var version: Swift.String?

        public init(
            adjustments: [ECRClientTypes.CvssScoreAdjustment]? = nil,
            score: Swift.Double = 0.0,
            scoreSource: Swift.String? = nil,
            scoringVector: Swift.String? = nil,
            version: Swift.String? = nil
        )
        {
            self.adjustments = adjustments
            self.score = score
            self.scoreSource = scoreSource
            self.scoringVector = scoringVector
            self.version = version
        }
    }

}

extension DeleteLifecyclePolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case registryId
        case repositoryName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let registryId = self.registryId {
            try encodeContainer.encode(registryId, forKey: .registryId)
        }
        if let repositoryName = self.repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }
}

extension DeleteLifecyclePolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteLifecyclePolicyInput: Swift.Equatable {
    /// The Amazon Web Services account ID associated with the registry that contains the repository. If you do not specify a registry, the default registry is assumed.
    public var registryId: Swift.String?
    /// The name of the repository.
    /// This member is required.
    public var repositoryName: Swift.String?

    public init(
        registryId: Swift.String? = nil,
        repositoryName: Swift.String? = nil
    )
    {
        self.registryId = registryId
        self.repositoryName = repositoryName
    }
}

struct DeleteLifecyclePolicyInputBody: Swift.Equatable {
    let registryId: Swift.String?
    let repositoryName: Swift.String?
}

extension DeleteLifecyclePolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case registryId
        case repositoryName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
    }
}

extension DeleteLifecyclePolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteLifecyclePolicyOutputBody = try responseDecoder.decode(responseBody: data)
            self.lastEvaluatedAt = output.lastEvaluatedAt
            self.lifecyclePolicyText = output.lifecyclePolicyText
            self.registryId = output.registryId
            self.repositoryName = output.repositoryName
        } else {
            self.lastEvaluatedAt = nil
            self.lifecyclePolicyText = nil
            self.registryId = nil
            self.repositoryName = nil
        }
    }
}

public struct DeleteLifecyclePolicyOutput: Swift.Equatable {
    /// The time stamp of the last time that the lifecycle policy was run.
    public var lastEvaluatedAt: ClientRuntime.Date?
    /// The JSON lifecycle policy text.
    public var lifecyclePolicyText: Swift.String?
    /// The registry ID associated with the request.
    public var registryId: Swift.String?
    /// The repository name associated with the request.
    public var repositoryName: Swift.String?

    public init(
        lastEvaluatedAt: ClientRuntime.Date? = nil,
        lifecyclePolicyText: Swift.String? = nil,
        registryId: Swift.String? = nil,
        repositoryName: Swift.String? = nil
    )
    {
        self.lastEvaluatedAt = lastEvaluatedAt
        self.lifecyclePolicyText = lifecyclePolicyText
        self.registryId = registryId
        self.repositoryName = repositoryName
    }
}

struct DeleteLifecyclePolicyOutputBody: Swift.Equatable {
    let registryId: Swift.String?
    let repositoryName: Swift.String?
    let lifecyclePolicyText: Swift.String?
    let lastEvaluatedAt: ClientRuntime.Date?
}

extension DeleteLifecyclePolicyOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lastEvaluatedAt
        case lifecyclePolicyText
        case registryId
        case repositoryName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let lifecyclePolicyTextDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lifecyclePolicyText)
        lifecyclePolicyText = lifecyclePolicyTextDecoded
        let lastEvaluatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastEvaluatedAt)
        lastEvaluatedAt = lastEvaluatedAtDecoded
    }
}

enum DeleteLifecyclePolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LifecyclePolicyNotFoundException": return try await LifecyclePolicyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RepositoryNotFoundException": return try await RepositoryNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServerException": return try await ServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeletePullThroughCacheRuleInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ecrRepositoryPrefix
        case registryId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ecrRepositoryPrefix = self.ecrRepositoryPrefix {
            try encodeContainer.encode(ecrRepositoryPrefix, forKey: .ecrRepositoryPrefix)
        }
        if let registryId = self.registryId {
            try encodeContainer.encode(registryId, forKey: .registryId)
        }
    }
}

extension DeletePullThroughCacheRuleInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeletePullThroughCacheRuleInput: Swift.Equatable {
    /// The Amazon ECR repository prefix associated with the pull through cache rule to delete.
    /// This member is required.
    public var ecrRepositoryPrefix: Swift.String?
    /// The Amazon Web Services account ID associated with the registry that contains the pull through cache rule. If you do not specify a registry, the default registry is assumed.
    public var registryId: Swift.String?

    public init(
        ecrRepositoryPrefix: Swift.String? = nil,
        registryId: Swift.String? = nil
    )
    {
        self.ecrRepositoryPrefix = ecrRepositoryPrefix
        self.registryId = registryId
    }
}

struct DeletePullThroughCacheRuleInputBody: Swift.Equatable {
    let ecrRepositoryPrefix: Swift.String?
    let registryId: Swift.String?
}

extension DeletePullThroughCacheRuleInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ecrRepositoryPrefix
        case registryId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ecrRepositoryPrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ecrRepositoryPrefix)
        ecrRepositoryPrefix = ecrRepositoryPrefixDecoded
        let registryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registryId)
        registryId = registryIdDecoded
    }
}

extension DeletePullThroughCacheRuleOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeletePullThroughCacheRuleOutputBody = try responseDecoder.decode(responseBody: data)
            self.createdAt = output.createdAt
            self.ecrRepositoryPrefix = output.ecrRepositoryPrefix
            self.registryId = output.registryId
            self.upstreamRegistryUrl = output.upstreamRegistryUrl
        } else {
            self.createdAt = nil
            self.ecrRepositoryPrefix = nil
            self.registryId = nil
            self.upstreamRegistryUrl = nil
        }
    }
}

public struct DeletePullThroughCacheRuleOutput: Swift.Equatable {
    /// The timestamp associated with the pull through cache rule.
    public var createdAt: ClientRuntime.Date?
    /// The Amazon ECR repository prefix associated with the request.
    public var ecrRepositoryPrefix: Swift.String?
    /// The registry ID associated with the request.
    public var registryId: Swift.String?
    /// The upstream registry URL associated with the pull through cache rule.
    public var upstreamRegistryUrl: Swift.String?

    public init(
        createdAt: ClientRuntime.Date? = nil,
        ecrRepositoryPrefix: Swift.String? = nil,
        registryId: Swift.String? = nil,
        upstreamRegistryUrl: Swift.String? = nil
    )
    {
        self.createdAt = createdAt
        self.ecrRepositoryPrefix = ecrRepositoryPrefix
        self.registryId = registryId
        self.upstreamRegistryUrl = upstreamRegistryUrl
    }
}

struct DeletePullThroughCacheRuleOutputBody: Swift.Equatable {
    let ecrRepositoryPrefix: Swift.String?
    let upstreamRegistryUrl: Swift.String?
    let createdAt: ClientRuntime.Date?
    let registryId: Swift.String?
}

extension DeletePullThroughCacheRuleOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt
        case ecrRepositoryPrefix
        case registryId
        case upstreamRegistryUrl
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ecrRepositoryPrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ecrRepositoryPrefix)
        ecrRepositoryPrefix = ecrRepositoryPrefixDecoded
        let upstreamRegistryUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .upstreamRegistryUrl)
        upstreamRegistryUrl = upstreamRegistryUrlDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let registryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registryId)
        registryId = registryIdDecoded
    }
}

enum DeletePullThroughCacheRuleOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PullThroughCacheRuleNotFoundException": return try await PullThroughCacheRuleNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServerException": return try await ServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteRegistryPolicyInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension DeleteRegistryPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteRegistryPolicyInput: Swift.Equatable {

    public init() { }
}

struct DeleteRegistryPolicyInputBody: Swift.Equatable {
}

extension DeleteRegistryPolicyInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteRegistryPolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteRegistryPolicyOutputBody = try responseDecoder.decode(responseBody: data)
            self.policyText = output.policyText
            self.registryId = output.registryId
        } else {
            self.policyText = nil
            self.registryId = nil
        }
    }
}

public struct DeleteRegistryPolicyOutput: Swift.Equatable {
    /// The contents of the registry permissions policy that was deleted.
    public var policyText: Swift.String?
    /// The registry ID associated with the request.
    public var registryId: Swift.String?

    public init(
        policyText: Swift.String? = nil,
        registryId: Swift.String? = nil
    )
    {
        self.policyText = policyText
        self.registryId = registryId
    }
}

struct DeleteRegistryPolicyOutputBody: Swift.Equatable {
    let registryId: Swift.String?
    let policyText: Swift.String?
}

extension DeleteRegistryPolicyOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policyText
        case registryId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let policyTextDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyText)
        policyText = policyTextDecoded
    }
}

enum DeleteRegistryPolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RegistryPolicyNotFoundException": return try await RegistryPolicyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServerException": return try await ServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteRepositoryInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case force
        case registryId
        case repositoryName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let force = self.force {
            try encodeContainer.encode(force, forKey: .force)
        }
        if let registryId = self.registryId {
            try encodeContainer.encode(registryId, forKey: .registryId)
        }
        if let repositoryName = self.repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }
}

extension DeleteRepositoryInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteRepositoryInput: Swift.Equatable {
    /// If a repository contains images, forces the deletion.
    public var force: Swift.Bool?
    /// The Amazon Web Services account ID associated with the registry that contains the repository to delete. If you do not specify a registry, the default registry is assumed.
    public var registryId: Swift.String?
    /// The name of the repository to delete.
    /// This member is required.
    public var repositoryName: Swift.String?

    public init(
        force: Swift.Bool? = nil,
        registryId: Swift.String? = nil,
        repositoryName: Swift.String? = nil
    )
    {
        self.force = force
        self.registryId = registryId
        self.repositoryName = repositoryName
    }
}

struct DeleteRepositoryInputBody: Swift.Equatable {
    let registryId: Swift.String?
    let repositoryName: Swift.String?
    let force: Swift.Bool?
}

extension DeleteRepositoryInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case force
        case registryId
        case repositoryName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let forceDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .force)
        force = forceDecoded
    }
}

extension DeleteRepositoryOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteRepositoryOutputBody = try responseDecoder.decode(responseBody: data)
            self.repository = output.repository
        } else {
            self.repository = nil
        }
    }
}

public struct DeleteRepositoryOutput: Swift.Equatable {
    /// The repository that was deleted.
    public var repository: ECRClientTypes.Repository?

    public init(
        repository: ECRClientTypes.Repository? = nil
    )
    {
        self.repository = repository
    }
}

struct DeleteRepositoryOutputBody: Swift.Equatable {
    let repository: ECRClientTypes.Repository?
}

extension DeleteRepositoryOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case repository
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryDecoded = try containerValues.decodeIfPresent(ECRClientTypes.Repository.self, forKey: .repository)
        repository = repositoryDecoded
    }
}

enum DeleteRepositoryOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "KmsException": return try await KmsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RepositoryNotEmptyException": return try await RepositoryNotEmptyException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RepositoryNotFoundException": return try await RepositoryNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServerException": return try await ServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteRepositoryPolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case registryId
        case repositoryName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let registryId = self.registryId {
            try encodeContainer.encode(registryId, forKey: .registryId)
        }
        if let repositoryName = self.repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }
}

extension DeleteRepositoryPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DeleteRepositoryPolicyInput: Swift.Equatable {
    /// The Amazon Web Services account ID associated with the registry that contains the repository policy to delete. If you do not specify a registry, the default registry is assumed.
    public var registryId: Swift.String?
    /// The name of the repository that is associated with the repository policy to delete.
    /// This member is required.
    public var repositoryName: Swift.String?

    public init(
        registryId: Swift.String? = nil,
        repositoryName: Swift.String? = nil
    )
    {
        self.registryId = registryId
        self.repositoryName = repositoryName
    }
}

struct DeleteRepositoryPolicyInputBody: Swift.Equatable {
    let registryId: Swift.String?
    let repositoryName: Swift.String?
}

extension DeleteRepositoryPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case registryId
        case repositoryName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
    }
}

extension DeleteRepositoryPolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DeleteRepositoryPolicyOutputBody = try responseDecoder.decode(responseBody: data)
            self.policyText = output.policyText
            self.registryId = output.registryId
            self.repositoryName = output.repositoryName
        } else {
            self.policyText = nil
            self.registryId = nil
            self.repositoryName = nil
        }
    }
}

public struct DeleteRepositoryPolicyOutput: Swift.Equatable {
    /// The JSON repository policy that was deleted from the repository.
    public var policyText: Swift.String?
    /// The registry ID associated with the request.
    public var registryId: Swift.String?
    /// The repository name associated with the request.
    public var repositoryName: Swift.String?

    public init(
        policyText: Swift.String? = nil,
        registryId: Swift.String? = nil,
        repositoryName: Swift.String? = nil
    )
    {
        self.policyText = policyText
        self.registryId = registryId
        self.repositoryName = repositoryName
    }
}

struct DeleteRepositoryPolicyOutputBody: Swift.Equatable {
    let registryId: Swift.String?
    let repositoryName: Swift.String?
    let policyText: Swift.String?
}

extension DeleteRepositoryPolicyOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policyText
        case registryId
        case repositoryName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let policyTextDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyText)
        policyText = policyTextDecoded
    }
}

enum DeleteRepositoryPolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RepositoryNotFoundException": return try await RepositoryNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RepositoryPolicyNotFoundException": return try await RepositoryPolicyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServerException": return try await ServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeImageReplicationStatusInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imageId
        case registryId
        case repositoryName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let imageId = self.imageId {
            try encodeContainer.encode(imageId, forKey: .imageId)
        }
        if let registryId = self.registryId {
            try encodeContainer.encode(registryId, forKey: .registryId)
        }
        if let repositoryName = self.repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }
}

extension DescribeImageReplicationStatusInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeImageReplicationStatusInput: Swift.Equatable {
    /// An object with identifying information for an image in an Amazon ECR repository.
    /// This member is required.
    public var imageId: ECRClientTypes.ImageIdentifier?
    /// The Amazon Web Services account ID associated with the registry. If you do not specify a registry, the default registry is assumed.
    public var registryId: Swift.String?
    /// The name of the repository that the image is in.
    /// This member is required.
    public var repositoryName: Swift.String?

    public init(
        imageId: ECRClientTypes.ImageIdentifier? = nil,
        registryId: Swift.String? = nil,
        repositoryName: Swift.String? = nil
    )
    {
        self.imageId = imageId
        self.registryId = registryId
        self.repositoryName = repositoryName
    }
}

struct DescribeImageReplicationStatusInputBody: Swift.Equatable {
    let repositoryName: Swift.String?
    let imageId: ECRClientTypes.ImageIdentifier?
    let registryId: Swift.String?
}

extension DescribeImageReplicationStatusInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imageId
        case registryId
        case repositoryName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let imageIdDecoded = try containerValues.decodeIfPresent(ECRClientTypes.ImageIdentifier.self, forKey: .imageId)
        imageId = imageIdDecoded
        let registryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registryId)
        registryId = registryIdDecoded
    }
}

extension DescribeImageReplicationStatusOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeImageReplicationStatusOutputBody = try responseDecoder.decode(responseBody: data)
            self.imageId = output.imageId
            self.replicationStatuses = output.replicationStatuses
            self.repositoryName = output.repositoryName
        } else {
            self.imageId = nil
            self.replicationStatuses = nil
            self.repositoryName = nil
        }
    }
}

public struct DescribeImageReplicationStatusOutput: Swift.Equatable {
    /// An object with identifying information for an image in an Amazon ECR repository.
    public var imageId: ECRClientTypes.ImageIdentifier?
    /// The replication status details for the images in the specified repository.
    public var replicationStatuses: [ECRClientTypes.ImageReplicationStatus]?
    /// The repository name associated with the request.
    public var repositoryName: Swift.String?

    public init(
        imageId: ECRClientTypes.ImageIdentifier? = nil,
        replicationStatuses: [ECRClientTypes.ImageReplicationStatus]? = nil,
        repositoryName: Swift.String? = nil
    )
    {
        self.imageId = imageId
        self.replicationStatuses = replicationStatuses
        self.repositoryName = repositoryName
    }
}

struct DescribeImageReplicationStatusOutputBody: Swift.Equatable {
    let repositoryName: Swift.String?
    let imageId: ECRClientTypes.ImageIdentifier?
    let replicationStatuses: [ECRClientTypes.ImageReplicationStatus]?
}

extension DescribeImageReplicationStatusOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imageId
        case replicationStatuses
        case repositoryName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let imageIdDecoded = try containerValues.decodeIfPresent(ECRClientTypes.ImageIdentifier.self, forKey: .imageId)
        imageId = imageIdDecoded
        let replicationStatusesContainer = try containerValues.decodeIfPresent([ECRClientTypes.ImageReplicationStatus?].self, forKey: .replicationStatuses)
        var replicationStatusesDecoded0:[ECRClientTypes.ImageReplicationStatus]? = nil
        if let replicationStatusesContainer = replicationStatusesContainer {
            replicationStatusesDecoded0 = [ECRClientTypes.ImageReplicationStatus]()
            for structure0 in replicationStatusesContainer {
                if let structure0 = structure0 {
                    replicationStatusesDecoded0?.append(structure0)
                }
            }
        }
        replicationStatuses = replicationStatusesDecoded0
    }
}

enum DescribeImageReplicationStatusOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ImageNotFoundException": return try await ImageNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RepositoryNotFoundException": return try await RepositoryNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServerException": return try await ServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeImageScanFindingsInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imageId
        case maxResults
        case nextToken
        case registryId
        case repositoryName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let imageId = self.imageId {
            try encodeContainer.encode(imageId, forKey: .imageId)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let registryId = self.registryId {
            try encodeContainer.encode(registryId, forKey: .registryId)
        }
        if let repositoryName = self.repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }
}

extension DescribeImageScanFindingsInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeImageScanFindingsInput: Swift.Equatable {
    /// An object with identifying information for an image in an Amazon ECR repository.
    /// This member is required.
    public var imageId: ECRClientTypes.ImageIdentifier?
    /// The maximum number of image scan results returned by DescribeImageScanFindings in paginated output. When this parameter is used, DescribeImageScanFindings only returns maxResults results in a single page along with a nextToken response element. The remaining results of the initial request can be seen by sending another DescribeImageScanFindings request with the returned nextToken value. This value can be between 1 and 1000. If this parameter is not used, then DescribeImageScanFindings returns up to 100 results and a nextToken value, if applicable.
    public var maxResults: Swift.Int?
    /// The nextToken value returned from a previous paginated DescribeImageScanFindings request where maxResults was used and the results exceeded the value of that parameter. Pagination continues from the end of the previous results that returned the nextToken value. This value is null when there are no more results to return.
    public var nextToken: Swift.String?
    /// The Amazon Web Services account ID associated with the registry that contains the repository in which to describe the image scan findings for. If you do not specify a registry, the default registry is assumed.
    public var registryId: Swift.String?
    /// The repository for the image for which to describe the scan findings.
    /// This member is required.
    public var repositoryName: Swift.String?

    public init(
        imageId: ECRClientTypes.ImageIdentifier? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        registryId: Swift.String? = nil,
        repositoryName: Swift.String? = nil
    )
    {
        self.imageId = imageId
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.registryId = registryId
        self.repositoryName = repositoryName
    }
}

struct DescribeImageScanFindingsInputBody: Swift.Equatable {
    let registryId: Swift.String?
    let repositoryName: Swift.String?
    let imageId: ECRClientTypes.ImageIdentifier?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension DescribeImageScanFindingsInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imageId
        case maxResults
        case nextToken
        case registryId
        case repositoryName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let imageIdDecoded = try containerValues.decodeIfPresent(ECRClientTypes.ImageIdentifier.self, forKey: .imageId)
        imageId = imageIdDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension DescribeImageScanFindingsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeImageScanFindingsOutputBody = try responseDecoder.decode(responseBody: data)
            self.imageId = output.imageId
            self.imageScanFindings = output.imageScanFindings
            self.imageScanStatus = output.imageScanStatus
            self.nextToken = output.nextToken
            self.registryId = output.registryId
            self.repositoryName = output.repositoryName
        } else {
            self.imageId = nil
            self.imageScanFindings = nil
            self.imageScanStatus = nil
            self.nextToken = nil
            self.registryId = nil
            self.repositoryName = nil
        }
    }
}

public struct DescribeImageScanFindingsOutput: Swift.Equatable {
    /// An object with identifying information for an image in an Amazon ECR repository.
    public var imageId: ECRClientTypes.ImageIdentifier?
    /// The information contained in the image scan findings.
    public var imageScanFindings: ECRClientTypes.ImageScanFindings?
    /// The current state of the scan.
    public var imageScanStatus: ECRClientTypes.ImageScanStatus?
    /// The nextToken value to include in a future DescribeImageScanFindings request. When the results of a DescribeImageScanFindings request exceed maxResults, this value can be used to retrieve the next page of results. This value is null when there are no more results to return.
    public var nextToken: Swift.String?
    /// The registry ID associated with the request.
    public var registryId: Swift.String?
    /// The repository name associated with the request.
    public var repositoryName: Swift.String?

    public init(
        imageId: ECRClientTypes.ImageIdentifier? = nil,
        imageScanFindings: ECRClientTypes.ImageScanFindings? = nil,
        imageScanStatus: ECRClientTypes.ImageScanStatus? = nil,
        nextToken: Swift.String? = nil,
        registryId: Swift.String? = nil,
        repositoryName: Swift.String? = nil
    )
    {
        self.imageId = imageId
        self.imageScanFindings = imageScanFindings
        self.imageScanStatus = imageScanStatus
        self.nextToken = nextToken
        self.registryId = registryId
        self.repositoryName = repositoryName
    }
}

struct DescribeImageScanFindingsOutputBody: Swift.Equatable {
    let registryId: Swift.String?
    let repositoryName: Swift.String?
    let imageId: ECRClientTypes.ImageIdentifier?
    let imageScanStatus: ECRClientTypes.ImageScanStatus?
    let imageScanFindings: ECRClientTypes.ImageScanFindings?
    let nextToken: Swift.String?
}

extension DescribeImageScanFindingsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imageId
        case imageScanFindings
        case imageScanStatus
        case nextToken
        case registryId
        case repositoryName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let imageIdDecoded = try containerValues.decodeIfPresent(ECRClientTypes.ImageIdentifier.self, forKey: .imageId)
        imageId = imageIdDecoded
        let imageScanStatusDecoded = try containerValues.decodeIfPresent(ECRClientTypes.ImageScanStatus.self, forKey: .imageScanStatus)
        imageScanStatus = imageScanStatusDecoded
        let imageScanFindingsDecoded = try containerValues.decodeIfPresent(ECRClientTypes.ImageScanFindings.self, forKey: .imageScanFindings)
        imageScanFindings = imageScanFindingsDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum DescribeImageScanFindingsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ImageNotFoundException": return try await ImageNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RepositoryNotFoundException": return try await RepositoryNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ScanNotFoundException": return try await ScanNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServerException": return try await ServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ECRClientTypes.DescribeImagesFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tagStatus
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tagStatus = self.tagStatus {
            try encodeContainer.encode(tagStatus.rawValue, forKey: .tagStatus)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagStatusDecoded = try containerValues.decodeIfPresent(ECRClientTypes.TagStatus.self, forKey: .tagStatus)
        tagStatus = tagStatusDecoded
    }
}

extension ECRClientTypes {
    /// An object representing a filter on a [DescribeImages] operation.
    public struct DescribeImagesFilter: Swift.Equatable {
        /// The tag status with which to filter your [DescribeImages] results. You can filter results based on whether they are TAGGED or UNTAGGED.
        public var tagStatus: ECRClientTypes.TagStatus?

        public init(
            tagStatus: ECRClientTypes.TagStatus? = nil
        )
        {
            self.tagStatus = tagStatus
        }
    }

}

extension DescribeImagesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter
        case imageIds
        case maxResults
        case nextToken
        case registryId
        case repositoryName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filter = self.filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
        if let imageIds = imageIds {
            var imageIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .imageIds)
            for imageidentifier0 in imageIds {
                try imageIdsContainer.encode(imageidentifier0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let registryId = self.registryId {
            try encodeContainer.encode(registryId, forKey: .registryId)
        }
        if let repositoryName = self.repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }
}

extension DescribeImagesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeImagesInput: Swift.Equatable {
    /// The filter key and value with which to filter your DescribeImages results.
    public var filter: ECRClientTypes.DescribeImagesFilter?
    /// The list of image IDs for the requested repository.
    public var imageIds: [ECRClientTypes.ImageIdentifier]?
    /// The maximum number of repository results returned by DescribeImages in paginated output. When this parameter is used, DescribeImages only returns maxResults results in a single page along with a nextToken response element. The remaining results of the initial request can be seen by sending another DescribeImages request with the returned nextToken value. This value can be between 1 and 1000. If this parameter is not used, then DescribeImages returns up to 100 results and a nextToken value, if applicable. This option cannot be used when you specify images with imageIds.
    public var maxResults: Swift.Int?
    /// The nextToken value returned from a previous paginated DescribeImages request where maxResults was used and the results exceeded the value of that parameter. Pagination continues from the end of the previous results that returned the nextToken value. This value is null when there are no more results to return. This option cannot be used when you specify images with imageIds.
    public var nextToken: Swift.String?
    /// The Amazon Web Services account ID associated with the registry that contains the repository in which to describe images. If you do not specify a registry, the default registry is assumed.
    public var registryId: Swift.String?
    /// The repository that contains the images to describe.
    /// This member is required.
    public var repositoryName: Swift.String?

    public init(
        filter: ECRClientTypes.DescribeImagesFilter? = nil,
        imageIds: [ECRClientTypes.ImageIdentifier]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        registryId: Swift.String? = nil,
        repositoryName: Swift.String? = nil
    )
    {
        self.filter = filter
        self.imageIds = imageIds
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.registryId = registryId
        self.repositoryName = repositoryName
    }
}

struct DescribeImagesInputBody: Swift.Equatable {
    let registryId: Swift.String?
    let repositoryName: Swift.String?
    let imageIds: [ECRClientTypes.ImageIdentifier]?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
    let filter: ECRClientTypes.DescribeImagesFilter?
}

extension DescribeImagesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter
        case imageIds
        case maxResults
        case nextToken
        case registryId
        case repositoryName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let imageIdsContainer = try containerValues.decodeIfPresent([ECRClientTypes.ImageIdentifier?].self, forKey: .imageIds)
        var imageIdsDecoded0:[ECRClientTypes.ImageIdentifier]? = nil
        if let imageIdsContainer = imageIdsContainer {
            imageIdsDecoded0 = [ECRClientTypes.ImageIdentifier]()
            for structure0 in imageIdsContainer {
                if let structure0 = structure0 {
                    imageIdsDecoded0?.append(structure0)
                }
            }
        }
        imageIds = imageIdsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let filterDecoded = try containerValues.decodeIfPresent(ECRClientTypes.DescribeImagesFilter.self, forKey: .filter)
        filter = filterDecoded
    }
}

extension DescribeImagesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeImagesOutputBody = try responseDecoder.decode(responseBody: data)
            self.imageDetails = output.imageDetails
            self.nextToken = output.nextToken
        } else {
            self.imageDetails = nil
            self.nextToken = nil
        }
    }
}

public struct DescribeImagesOutput: Swift.Equatable {
    /// A list of [ImageDetail] objects that contain data about the image.
    public var imageDetails: [ECRClientTypes.ImageDetail]?
    /// The nextToken value to include in a future DescribeImages request. When the results of a DescribeImages request exceed maxResults, this value can be used to retrieve the next page of results. This value is null when there are no more results to return.
    public var nextToken: Swift.String?

    public init(
        imageDetails: [ECRClientTypes.ImageDetail]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.imageDetails = imageDetails
        self.nextToken = nextToken
    }
}

struct DescribeImagesOutputBody: Swift.Equatable {
    let imageDetails: [ECRClientTypes.ImageDetail]?
    let nextToken: Swift.String?
}

extension DescribeImagesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imageDetails
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imageDetailsContainer = try containerValues.decodeIfPresent([ECRClientTypes.ImageDetail?].self, forKey: .imageDetails)
        var imageDetailsDecoded0:[ECRClientTypes.ImageDetail]? = nil
        if let imageDetailsContainer = imageDetailsContainer {
            imageDetailsDecoded0 = [ECRClientTypes.ImageDetail]()
            for structure0 in imageDetailsContainer {
                if let structure0 = structure0 {
                    imageDetailsDecoded0?.append(structure0)
                }
            }
        }
        imageDetails = imageDetailsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum DescribeImagesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ImageNotFoundException": return try await ImageNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RepositoryNotFoundException": return try await RepositoryNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServerException": return try await ServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribePullThroughCacheRulesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ecrRepositoryPrefixes
        case maxResults
        case nextToken
        case registryId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let ecrRepositoryPrefixes = ecrRepositoryPrefixes {
            var ecrRepositoryPrefixesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .ecrRepositoryPrefixes)
            for pullthroughcacherulerepositoryprefix0 in ecrRepositoryPrefixes {
                try ecrRepositoryPrefixesContainer.encode(pullthroughcacherulerepositoryprefix0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let registryId = self.registryId {
            try encodeContainer.encode(registryId, forKey: .registryId)
        }
    }
}

extension DescribePullThroughCacheRulesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribePullThroughCacheRulesInput: Swift.Equatable {
    /// The Amazon ECR repository prefixes associated with the pull through cache rules to return. If no repository prefix value is specified, all pull through cache rules are returned.
    public var ecrRepositoryPrefixes: [Swift.String]?
    /// The maximum number of pull through cache rules returned by DescribePullThroughCacheRulesRequest in paginated output. When this parameter is used, DescribePullThroughCacheRulesRequest only returns maxResults results in a single page along with a nextToken response element. The remaining results of the initial request can be seen by sending another DescribePullThroughCacheRulesRequest request with the returned nextToken value. This value can be between 1 and 1000. If this parameter is not used, then DescribePullThroughCacheRulesRequest returns up to 100 results and a nextToken value, if applicable.
    public var maxResults: Swift.Int?
    /// The nextToken value returned from a previous paginated DescribePullThroughCacheRulesRequest request where maxResults was used and the results exceeded the value of that parameter. Pagination continues from the end of the previous results that returned the nextToken value. This value is null when there are no more results to return.
    public var nextToken: Swift.String?
    /// The Amazon Web Services account ID associated with the registry to return the pull through cache rules for. If you do not specify a registry, the default registry is assumed.
    public var registryId: Swift.String?

    public init(
        ecrRepositoryPrefixes: [Swift.String]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        registryId: Swift.String? = nil
    )
    {
        self.ecrRepositoryPrefixes = ecrRepositoryPrefixes
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.registryId = registryId
    }
}

struct DescribePullThroughCacheRulesInputBody: Swift.Equatable {
    let registryId: Swift.String?
    let ecrRepositoryPrefixes: [Swift.String]?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension DescribePullThroughCacheRulesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case ecrRepositoryPrefixes
        case maxResults
        case nextToken
        case registryId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let ecrRepositoryPrefixesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .ecrRepositoryPrefixes)
        var ecrRepositoryPrefixesDecoded0:[Swift.String]? = nil
        if let ecrRepositoryPrefixesContainer = ecrRepositoryPrefixesContainer {
            ecrRepositoryPrefixesDecoded0 = [Swift.String]()
            for string0 in ecrRepositoryPrefixesContainer {
                if let string0 = string0 {
                    ecrRepositoryPrefixesDecoded0?.append(string0)
                }
            }
        }
        ecrRepositoryPrefixes = ecrRepositoryPrefixesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension DescribePullThroughCacheRulesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribePullThroughCacheRulesOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.pullThroughCacheRules = output.pullThroughCacheRules
        } else {
            self.nextToken = nil
            self.pullThroughCacheRules = nil
        }
    }
}

public struct DescribePullThroughCacheRulesOutput: Swift.Equatable {
    /// The nextToken value to include in a future DescribePullThroughCacheRulesRequest request. When the results of a DescribePullThroughCacheRulesRequest request exceed maxResults, this value can be used to retrieve the next page of results. This value is null when there are no more results to return.
    public var nextToken: Swift.String?
    /// The details of the pull through cache rules.
    public var pullThroughCacheRules: [ECRClientTypes.PullThroughCacheRule]?

    public init(
        nextToken: Swift.String? = nil,
        pullThroughCacheRules: [ECRClientTypes.PullThroughCacheRule]? = nil
    )
    {
        self.nextToken = nextToken
        self.pullThroughCacheRules = pullThroughCacheRules
    }
}

struct DescribePullThroughCacheRulesOutputBody: Swift.Equatable {
    let pullThroughCacheRules: [ECRClientTypes.PullThroughCacheRule]?
    let nextToken: Swift.String?
}

extension DescribePullThroughCacheRulesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case pullThroughCacheRules
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let pullThroughCacheRulesContainer = try containerValues.decodeIfPresent([ECRClientTypes.PullThroughCacheRule?].self, forKey: .pullThroughCacheRules)
        var pullThroughCacheRulesDecoded0:[ECRClientTypes.PullThroughCacheRule]? = nil
        if let pullThroughCacheRulesContainer = pullThroughCacheRulesContainer {
            pullThroughCacheRulesDecoded0 = [ECRClientTypes.PullThroughCacheRule]()
            for structure0 in pullThroughCacheRulesContainer {
                if let structure0 = structure0 {
                    pullThroughCacheRulesDecoded0?.append(structure0)
                }
            }
        }
        pullThroughCacheRules = pullThroughCacheRulesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum DescribePullThroughCacheRulesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "PullThroughCacheRuleNotFoundException": return try await PullThroughCacheRuleNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServerException": return try await ServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeRegistryInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension DescribeRegistryInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeRegistryInput: Swift.Equatable {

    public init() { }
}

struct DescribeRegistryInputBody: Swift.Equatable {
}

extension DescribeRegistryInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DescribeRegistryOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeRegistryOutputBody = try responseDecoder.decode(responseBody: data)
            self.registryId = output.registryId
            self.replicationConfiguration = output.replicationConfiguration
        } else {
            self.registryId = nil
            self.replicationConfiguration = nil
        }
    }
}

public struct DescribeRegistryOutput: Swift.Equatable {
    /// The ID of the registry.
    public var registryId: Swift.String?
    /// The replication configuration for the registry.
    public var replicationConfiguration: ECRClientTypes.ReplicationConfiguration?

    public init(
        registryId: Swift.String? = nil,
        replicationConfiguration: ECRClientTypes.ReplicationConfiguration? = nil
    )
    {
        self.registryId = registryId
        self.replicationConfiguration = replicationConfiguration
    }
}

struct DescribeRegistryOutputBody: Swift.Equatable {
    let registryId: Swift.String?
    let replicationConfiguration: ECRClientTypes.ReplicationConfiguration?
}

extension DescribeRegistryOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case registryId
        case replicationConfiguration
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let replicationConfigurationDecoded = try containerValues.decodeIfPresent(ECRClientTypes.ReplicationConfiguration.self, forKey: .replicationConfiguration)
        replicationConfiguration = replicationConfigurationDecoded
    }
}

enum DescribeRegistryOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServerException": return try await ServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DescribeRepositoriesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case registryId
        case repositoryNames
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let registryId = self.registryId {
            try encodeContainer.encode(registryId, forKey: .registryId)
        }
        if let repositoryNames = repositoryNames {
            var repositoryNamesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .repositoryNames)
            for repositoryname0 in repositoryNames {
                try repositoryNamesContainer.encode(repositoryname0)
            }
        }
    }
}

extension DescribeRepositoriesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct DescribeRepositoriesInput: Swift.Equatable {
    /// The maximum number of repository results returned by DescribeRepositories in paginated output. When this parameter is used, DescribeRepositories only returns maxResults results in a single page along with a nextToken response element. The remaining results of the initial request can be seen by sending another DescribeRepositories request with the returned nextToken value. This value can be between 1 and 1000. If this parameter is not used, then DescribeRepositories returns up to 100 results and a nextToken value, if applicable. This option cannot be used when you specify repositories with repositoryNames.
    public var maxResults: Swift.Int?
    /// The nextToken value returned from a previous paginated DescribeRepositories request where maxResults was used and the results exceeded the value of that parameter. Pagination continues from the end of the previous results that returned the nextToken value. This value is null when there are no more results to return. This option cannot be used when you specify repositories with repositoryNames. This token should be treated as an opaque identifier that is only used to retrieve the next items in a list and not for other programmatic purposes.
    public var nextToken: Swift.String?
    /// The Amazon Web Services account ID associated with the registry that contains the repositories to be described. If you do not specify a registry, the default registry is assumed.
    public var registryId: Swift.String?
    /// A list of repositories to describe. If this parameter is omitted, then all repositories in a registry are described.
    public var repositoryNames: [Swift.String]?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        registryId: Swift.String? = nil,
        repositoryNames: [Swift.String]? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.registryId = registryId
        self.repositoryNames = repositoryNames
    }
}

struct DescribeRepositoriesInputBody: Swift.Equatable {
    let registryId: Swift.String?
    let repositoryNames: [Swift.String]?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
}

extension DescribeRepositoriesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case maxResults
        case nextToken
        case registryId
        case repositoryNames
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let repositoryNamesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .repositoryNames)
        var repositoryNamesDecoded0:[Swift.String]? = nil
        if let repositoryNamesContainer = repositoryNamesContainer {
            repositoryNamesDecoded0 = [Swift.String]()
            for string0 in repositoryNamesContainer {
                if let string0 = string0 {
                    repositoryNamesDecoded0?.append(string0)
                }
            }
        }
        repositoryNames = repositoryNamesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
    }
}

extension DescribeRepositoriesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: DescribeRepositoriesOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.repositories = output.repositories
        } else {
            self.nextToken = nil
            self.repositories = nil
        }
    }
}

public struct DescribeRepositoriesOutput: Swift.Equatable {
    /// The nextToken value to include in a future DescribeRepositories request. When the results of a DescribeRepositories request exceed maxResults, this value can be used to retrieve the next page of results. This value is null when there are no more results to return.
    public var nextToken: Swift.String?
    /// A list of repository objects corresponding to valid repositories.
    public var repositories: [ECRClientTypes.Repository]?

    public init(
        nextToken: Swift.String? = nil,
        repositories: [ECRClientTypes.Repository]? = nil
    )
    {
        self.nextToken = nextToken
        self.repositories = repositories
    }
}

struct DescribeRepositoriesOutputBody: Swift.Equatable {
    let repositories: [ECRClientTypes.Repository]?
    let nextToken: Swift.String?
}

extension DescribeRepositoriesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case repositories
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoriesContainer = try containerValues.decodeIfPresent([ECRClientTypes.Repository?].self, forKey: .repositories)
        var repositoriesDecoded0:[ECRClientTypes.Repository]? = nil
        if let repositoriesContainer = repositoriesContainer {
            repositoriesDecoded0 = [ECRClientTypes.Repository]()
            for structure0 in repositoriesContainer {
                if let structure0 = structure0 {
                    repositoriesDecoded0?.append(structure0)
                }
            }
        }
        repositories = repositoriesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum DescribeRepositoriesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RepositoryNotFoundException": return try await RepositoryNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServerException": return try await ServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension EmptyUploadException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: EmptyUploadExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The specified layer upload does not contain any layer parts.
public struct EmptyUploadException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The error message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "EmptyUploadException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct EmptyUploadExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension EmptyUploadExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ECRClientTypes.EncryptionConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case encryptionType
        case kmsKey
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let encryptionType = self.encryptionType {
            try encodeContainer.encode(encryptionType.rawValue, forKey: .encryptionType)
        }
        if let kmsKey = self.kmsKey {
            try encodeContainer.encode(kmsKey, forKey: .kmsKey)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let encryptionTypeDecoded = try containerValues.decodeIfPresent(ECRClientTypes.EncryptionType.self, forKey: .encryptionType)
        encryptionType = encryptionTypeDecoded
        let kmsKeyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKey)
        kmsKey = kmsKeyDecoded
    }
}

extension ECRClientTypes {
    /// The encryption configuration for the repository. This determines how the contents of your repository are encrypted at rest. By default, when no encryption configuration is set or the AES256 encryption type is used, Amazon ECR uses server-side encryption with Amazon S3-managed encryption keys which encrypts your data at rest using an AES-256 encryption algorithm. This does not require any action on your part. For more control over the encryption of the contents of your repository, you can use server-side encryption with Key Management Service key stored in Key Management Service (KMS) to encrypt your images. For more information, see [Amazon ECR encryption at rest](https://docs.aws.amazon.com/AmazonECR/latest/userguide/encryption-at-rest.html) in the Amazon Elastic Container Registry User Guide.
    public struct EncryptionConfiguration: Swift.Equatable {
        /// The encryption type to use. If you use the KMS encryption type, the contents of the repository will be encrypted using server-side encryption with Key Management Service key stored in KMS. When you use KMS to encrypt your data, you can either use the default Amazon Web Services managed KMS key for Amazon ECR, or specify your own KMS key, which you already created. For more information, see [Protecting data using server-side encryption with an KMS key stored in Key Management Service (SSE-KMS)](https://docs.aws.amazon.com/AmazonS3/latest/dev/UsingKMSEncryption.html) in the Amazon Simple Storage Service Console Developer Guide. If you use the AES256 encryption type, Amazon ECR uses server-side encryption with Amazon S3-managed encryption keys which encrypts the images in the repository using an AES-256 encryption algorithm. For more information, see [Protecting data using server-side encryption with Amazon S3-managed encryption keys (SSE-S3)](https://docs.aws.amazon.com/AmazonS3/latest/dev/UsingServerSideEncryption.html) in the Amazon Simple Storage Service Console Developer Guide.
        /// This member is required.
        public var encryptionType: ECRClientTypes.EncryptionType?
        /// If you use the KMS encryption type, specify the KMS key to use for encryption. The alias, key ID, or full ARN of the KMS key can be specified. The key must exist in the same Region as the repository. If no key is specified, the default Amazon Web Services managed KMS key for Amazon ECR will be used.
        public var kmsKey: Swift.String?

        public init(
            encryptionType: ECRClientTypes.EncryptionType? = nil,
            kmsKey: Swift.String? = nil
        )
        {
            self.encryptionType = encryptionType
            self.kmsKey = kmsKey
        }
    }

}

extension ECRClientTypes {
    public enum EncryptionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case aes256
        case kms
        case sdkUnknown(Swift.String)

        public static var allCases: [EncryptionType] {
            return [
                .aes256,
                .kms,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .aes256: return "AES256"
            case .kms: return "KMS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EncryptionType(rawValue: rawValue) ?? EncryptionType.sdkUnknown(rawValue)
        }
    }
}

extension ECRClientTypes.EnhancedImageScanFinding: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsAccountId
        case description
        case findingArn
        case firstObservedAt
        case lastObservedAt
        case packageVulnerabilityDetails
        case remediation
        case resources
        case score
        case scoreDetails
        case severity
        case status
        case title
        case type
        case updatedAt
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let awsAccountId = self.awsAccountId {
            try encodeContainer.encode(awsAccountId, forKey: .awsAccountId)
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let findingArn = self.findingArn {
            try encodeContainer.encode(findingArn, forKey: .findingArn)
        }
        if let firstObservedAt = self.firstObservedAt {
            try encodeContainer.encodeTimestamp(firstObservedAt, format: .epochSeconds, forKey: .firstObservedAt)
        }
        if let lastObservedAt = self.lastObservedAt {
            try encodeContainer.encodeTimestamp(lastObservedAt, format: .epochSeconds, forKey: .lastObservedAt)
        }
        if let packageVulnerabilityDetails = self.packageVulnerabilityDetails {
            try encodeContainer.encode(packageVulnerabilityDetails, forKey: .packageVulnerabilityDetails)
        }
        if let remediation = self.remediation {
            try encodeContainer.encode(remediation, forKey: .remediation)
        }
        if let resources = resources {
            var resourcesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .resources)
            for resource0 in resources {
                try resourcesContainer.encode(resource0)
            }
        }
        if score != 0.0 {
            try encodeContainer.encode(score, forKey: .score)
        }
        if let scoreDetails = self.scoreDetails {
            try encodeContainer.encode(scoreDetails, forKey: .scoreDetails)
        }
        if let severity = self.severity {
            try encodeContainer.encode(severity, forKey: .severity)
        }
        if let status = self.status {
            try encodeContainer.encode(status, forKey: .status)
        }
        if let title = self.title {
            try encodeContainer.encode(title, forKey: .title)
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
        if let updatedAt = self.updatedAt {
            try encodeContainer.encodeTimestamp(updatedAt, format: .epochSeconds, forKey: .updatedAt)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let awsAccountIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .awsAccountId)
        awsAccountId = awsAccountIdDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let findingArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .findingArn)
        findingArn = findingArnDecoded
        let firstObservedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .firstObservedAt)
        firstObservedAt = firstObservedAtDecoded
        let lastObservedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastObservedAt)
        lastObservedAt = lastObservedAtDecoded
        let packageVulnerabilityDetailsDecoded = try containerValues.decodeIfPresent(ECRClientTypes.PackageVulnerabilityDetails.self, forKey: .packageVulnerabilityDetails)
        packageVulnerabilityDetails = packageVulnerabilityDetailsDecoded
        let remediationDecoded = try containerValues.decodeIfPresent(ECRClientTypes.Remediation.self, forKey: .remediation)
        remediation = remediationDecoded
        let resourcesContainer = try containerValues.decodeIfPresent([ECRClientTypes.Resource?].self, forKey: .resources)
        var resourcesDecoded0:[ECRClientTypes.Resource]? = nil
        if let resourcesContainer = resourcesContainer {
            resourcesDecoded0 = [ECRClientTypes.Resource]()
            for structure0 in resourcesContainer {
                if let structure0 = structure0 {
                    resourcesDecoded0?.append(structure0)
                }
            }
        }
        resources = resourcesDecoded0
        let scoreDecoded = try containerValues.decodeIfPresent(Swift.Double.self, forKey: .score) ?? 0.0
        score = scoreDecoded
        let scoreDetailsDecoded = try containerValues.decodeIfPresent(ECRClientTypes.ScoreDetails.self, forKey: .scoreDetails)
        scoreDetails = scoreDetailsDecoded
        let severityDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .severity)
        severity = severityDecoded
        let statusDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .status)
        status = statusDecoded
        let titleDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .title)
        title = titleDecoded
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
    }
}

extension ECRClientTypes {
    /// The details of an enhanced image scan. This is returned when enhanced scanning is enabled for your private registry.
    public struct EnhancedImageScanFinding: Swift.Equatable {
        /// The Amazon Web Services account ID associated with the image.
        public var awsAccountId: Swift.String?
        /// The description of the finding.
        public var description: Swift.String?
        /// The Amazon Resource Number (ARN) of the finding.
        public var findingArn: Swift.String?
        /// The date and time that the finding was first observed.
        public var firstObservedAt: ClientRuntime.Date?
        /// The date and time that the finding was last observed.
        public var lastObservedAt: ClientRuntime.Date?
        /// An object that contains the details of a package vulnerability finding.
        public var packageVulnerabilityDetails: ECRClientTypes.PackageVulnerabilityDetails?
        /// An object that contains the details about how to remediate a finding.
        public var remediation: ECRClientTypes.Remediation?
        /// Contains information on the resources involved in a finding.
        public var resources: [ECRClientTypes.Resource]?
        /// The Amazon Inspector score given to the finding.
        public var score: Swift.Double
        /// An object that contains details of the Amazon Inspector score.
        public var scoreDetails: ECRClientTypes.ScoreDetails?
        /// The severity of the finding.
        public var severity: Swift.String?
        /// The status of the finding.
        public var status: Swift.String?
        /// The title of the finding.
        public var title: Swift.String?
        /// The type of the finding.
        public var type: Swift.String?
        /// The date and time the finding was last updated at.
        public var updatedAt: ClientRuntime.Date?

        public init(
            awsAccountId: Swift.String? = nil,
            description: Swift.String? = nil,
            findingArn: Swift.String? = nil,
            firstObservedAt: ClientRuntime.Date? = nil,
            lastObservedAt: ClientRuntime.Date? = nil,
            packageVulnerabilityDetails: ECRClientTypes.PackageVulnerabilityDetails? = nil,
            remediation: ECRClientTypes.Remediation? = nil,
            resources: [ECRClientTypes.Resource]? = nil,
            score: Swift.Double = 0.0,
            scoreDetails: ECRClientTypes.ScoreDetails? = nil,
            severity: Swift.String? = nil,
            status: Swift.String? = nil,
            title: Swift.String? = nil,
            type: Swift.String? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.awsAccountId = awsAccountId
            self.description = description
            self.findingArn = findingArn
            self.firstObservedAt = firstObservedAt
            self.lastObservedAt = lastObservedAt
            self.packageVulnerabilityDetails = packageVulnerabilityDetails
            self.remediation = remediation
            self.resources = resources
            self.score = score
            self.scoreDetails = scoreDetails
            self.severity = severity
            self.status = status
            self.title = title
            self.type = type
            self.updatedAt = updatedAt
        }
    }

}

extension ECRClientTypes {
    public enum FindingSeverity: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case critical
        case high
        case informational
        case low
        case medium
        case undefined
        case sdkUnknown(Swift.String)

        public static var allCases: [FindingSeverity] {
            return [
                .critical,
                .high,
                .informational,
                .low,
                .medium,
                .undefined,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .critical: return "CRITICAL"
            case .high: return "HIGH"
            case .informational: return "INFORMATIONAL"
            case .low: return "LOW"
            case .medium: return "MEDIUM"
            case .undefined: return "UNDEFINED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = FindingSeverity(rawValue: rawValue) ?? FindingSeverity.sdkUnknown(rawValue)
        }
    }
}

extension GetAuthorizationTokenInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case registryIds
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let registryIds = registryIds {
            var registryIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .registryIds)
            for registryid0 in registryIds {
                try registryIdsContainer.encode(registryid0)
            }
        }
    }
}

extension GetAuthorizationTokenInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetAuthorizationTokenInput: Swift.Equatable {
    /// A list of Amazon Web Services account IDs that are associated with the registries for which to get AuthorizationData objects. If you do not specify a registry, the default registry is assumed.
    @available(*, deprecated, message: "This field is deprecated. The returned authorization token can be used to access any Amazon ECR registry that the IAM principal has access to, specifying a registry ID doesn't change the permissions scope of the authorization token.")
    public var registryIds: [Swift.String]?

    public init(
        registryIds: [Swift.String]? = nil
    )
    {
        self.registryIds = registryIds
    }
}

struct GetAuthorizationTokenInputBody: Swift.Equatable {
    let registryIds: [Swift.String]?
}

extension GetAuthorizationTokenInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case registryIds
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .registryIds)
        var registryIdsDecoded0:[Swift.String]? = nil
        if let registryIdsContainer = registryIdsContainer {
            registryIdsDecoded0 = [Swift.String]()
            for string0 in registryIdsContainer {
                if let string0 = string0 {
                    registryIdsDecoded0?.append(string0)
                }
            }
        }
        registryIds = registryIdsDecoded0
    }
}

extension GetAuthorizationTokenOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetAuthorizationTokenOutputBody = try responseDecoder.decode(responseBody: data)
            self.authorizationData = output.authorizationData
        } else {
            self.authorizationData = nil
        }
    }
}

public struct GetAuthorizationTokenOutput: Swift.Equatable {
    /// A list of authorization token data objects that correspond to the registryIds values in the request.
    public var authorizationData: [ECRClientTypes.AuthorizationData]?

    public init(
        authorizationData: [ECRClientTypes.AuthorizationData]? = nil
    )
    {
        self.authorizationData = authorizationData
    }
}

struct GetAuthorizationTokenOutputBody: Swift.Equatable {
    let authorizationData: [ECRClientTypes.AuthorizationData]?
}

extension GetAuthorizationTokenOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case authorizationData
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let authorizationDataContainer = try containerValues.decodeIfPresent([ECRClientTypes.AuthorizationData?].self, forKey: .authorizationData)
        var authorizationDataDecoded0:[ECRClientTypes.AuthorizationData]? = nil
        if let authorizationDataContainer = authorizationDataContainer {
            authorizationDataDecoded0 = [ECRClientTypes.AuthorizationData]()
            for structure0 in authorizationDataContainer {
                if let structure0 = structure0 {
                    authorizationDataDecoded0?.append(structure0)
                }
            }
        }
        authorizationData = authorizationDataDecoded0
    }
}

enum GetAuthorizationTokenOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServerException": return try await ServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetDownloadUrlForLayerInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case layerDigest
        case registryId
        case repositoryName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let layerDigest = self.layerDigest {
            try encodeContainer.encode(layerDigest, forKey: .layerDigest)
        }
        if let registryId = self.registryId {
            try encodeContainer.encode(registryId, forKey: .registryId)
        }
        if let repositoryName = self.repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }
}

extension GetDownloadUrlForLayerInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetDownloadUrlForLayerInput: Swift.Equatable {
    /// The digest of the image layer to download.
    /// This member is required.
    public var layerDigest: Swift.String?
    /// The Amazon Web Services account ID associated with the registry that contains the image layer to download. If you do not specify a registry, the default registry is assumed.
    public var registryId: Swift.String?
    /// The name of the repository that is associated with the image layer to download.
    /// This member is required.
    public var repositoryName: Swift.String?

    public init(
        layerDigest: Swift.String? = nil,
        registryId: Swift.String? = nil,
        repositoryName: Swift.String? = nil
    )
    {
        self.layerDigest = layerDigest
        self.registryId = registryId
        self.repositoryName = repositoryName
    }
}

struct GetDownloadUrlForLayerInputBody: Swift.Equatable {
    let registryId: Swift.String?
    let repositoryName: Swift.String?
    let layerDigest: Swift.String?
}

extension GetDownloadUrlForLayerInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case layerDigest
        case registryId
        case repositoryName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let layerDigestDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .layerDigest)
        layerDigest = layerDigestDecoded
    }
}

extension GetDownloadUrlForLayerOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetDownloadUrlForLayerOutputBody = try responseDecoder.decode(responseBody: data)
            self.downloadUrl = output.downloadUrl
            self.layerDigest = output.layerDigest
        } else {
            self.downloadUrl = nil
            self.layerDigest = nil
        }
    }
}

public struct GetDownloadUrlForLayerOutput: Swift.Equatable {
    /// The pre-signed Amazon S3 download URL for the requested layer.
    public var downloadUrl: Swift.String?
    /// The digest of the image layer to download.
    public var layerDigest: Swift.String?

    public init(
        downloadUrl: Swift.String? = nil,
        layerDigest: Swift.String? = nil
    )
    {
        self.downloadUrl = downloadUrl
        self.layerDigest = layerDigest
    }
}

struct GetDownloadUrlForLayerOutputBody: Swift.Equatable {
    let downloadUrl: Swift.String?
    let layerDigest: Swift.String?
}

extension GetDownloadUrlForLayerOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case downloadUrl
        case layerDigest
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let downloadUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .downloadUrl)
        downloadUrl = downloadUrlDecoded
        let layerDigestDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .layerDigest)
        layerDigest = layerDigestDecoded
    }
}

enum GetDownloadUrlForLayerOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LayerInaccessibleException": return try await LayerInaccessibleException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LayersNotFoundException": return try await LayersNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RepositoryNotFoundException": return try await RepositoryNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServerException": return try await ServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetLifecyclePolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case registryId
        case repositoryName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let registryId = self.registryId {
            try encodeContainer.encode(registryId, forKey: .registryId)
        }
        if let repositoryName = self.repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }
}

extension GetLifecyclePolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetLifecyclePolicyInput: Swift.Equatable {
    /// The Amazon Web Services account ID associated with the registry that contains the repository. If you do not specify a registry, the default registry is assumed.
    public var registryId: Swift.String?
    /// The name of the repository.
    /// This member is required.
    public var repositoryName: Swift.String?

    public init(
        registryId: Swift.String? = nil,
        repositoryName: Swift.String? = nil
    )
    {
        self.registryId = registryId
        self.repositoryName = repositoryName
    }
}

struct GetLifecyclePolicyInputBody: Swift.Equatable {
    let registryId: Swift.String?
    let repositoryName: Swift.String?
}

extension GetLifecyclePolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case registryId
        case repositoryName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
    }
}

extension GetLifecyclePolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetLifecyclePolicyOutputBody = try responseDecoder.decode(responseBody: data)
            self.lastEvaluatedAt = output.lastEvaluatedAt
            self.lifecyclePolicyText = output.lifecyclePolicyText
            self.registryId = output.registryId
            self.repositoryName = output.repositoryName
        } else {
            self.lastEvaluatedAt = nil
            self.lifecyclePolicyText = nil
            self.registryId = nil
            self.repositoryName = nil
        }
    }
}

public struct GetLifecyclePolicyOutput: Swift.Equatable {
    /// The time stamp of the last time that the lifecycle policy was run.
    public var lastEvaluatedAt: ClientRuntime.Date?
    /// The JSON lifecycle policy text.
    public var lifecyclePolicyText: Swift.String?
    /// The registry ID associated with the request.
    public var registryId: Swift.String?
    /// The repository name associated with the request.
    public var repositoryName: Swift.String?

    public init(
        lastEvaluatedAt: ClientRuntime.Date? = nil,
        lifecyclePolicyText: Swift.String? = nil,
        registryId: Swift.String? = nil,
        repositoryName: Swift.String? = nil
    )
    {
        self.lastEvaluatedAt = lastEvaluatedAt
        self.lifecyclePolicyText = lifecyclePolicyText
        self.registryId = registryId
        self.repositoryName = repositoryName
    }
}

struct GetLifecyclePolicyOutputBody: Swift.Equatable {
    let registryId: Swift.String?
    let repositoryName: Swift.String?
    let lifecyclePolicyText: Swift.String?
    let lastEvaluatedAt: ClientRuntime.Date?
}

extension GetLifecyclePolicyOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lastEvaluatedAt
        case lifecyclePolicyText
        case registryId
        case repositoryName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let lifecyclePolicyTextDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lifecyclePolicyText)
        lifecyclePolicyText = lifecyclePolicyTextDecoded
        let lastEvaluatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastEvaluatedAt)
        lastEvaluatedAt = lastEvaluatedAtDecoded
    }
}

enum GetLifecyclePolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LifecyclePolicyNotFoundException": return try await LifecyclePolicyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RepositoryNotFoundException": return try await RepositoryNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServerException": return try await ServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetLifecyclePolicyPreviewInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter
        case imageIds
        case maxResults
        case nextToken
        case registryId
        case repositoryName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filter = self.filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
        if let imageIds = imageIds {
            var imageIdsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .imageIds)
            for imageidentifier0 in imageIds {
                try imageIdsContainer.encode(imageidentifier0)
            }
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let registryId = self.registryId {
            try encodeContainer.encode(registryId, forKey: .registryId)
        }
        if let repositoryName = self.repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }
}

extension GetLifecyclePolicyPreviewInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetLifecyclePolicyPreviewInput: Swift.Equatable {
    /// An optional parameter that filters results based on image tag status and all tags, if tagged.
    public var filter: ECRClientTypes.LifecyclePolicyPreviewFilter?
    /// The list of imageIDs to be included.
    public var imageIds: [ECRClientTypes.ImageIdentifier]?
    /// The maximum number of repository results returned by GetLifecyclePolicyPreviewRequest in paginated output. When this parameter is used, GetLifecyclePolicyPreviewRequest only returns maxResults results in a single page along with a nextToken response element. The remaining results of the initial request can be seen by sending another GetLifecyclePolicyPreviewRequest request with the returned nextToken value. This value can be between 1 and 1000. If this parameter is not used, then GetLifecyclePolicyPreviewRequest returns up to 100 results and a nextToken value, if applicable. This option cannot be used when you specify images with imageIds.
    public var maxResults: Swift.Int?
    /// The nextToken value returned from a previous paginated GetLifecyclePolicyPreviewRequest request where maxResults was used and the results exceeded the value of that parameter. Pagination continues from the end of the previous results that returned the nextToken value. This value is null when there are no more results to return. This option cannot be used when you specify images with imageIds.
    public var nextToken: Swift.String?
    /// The Amazon Web Services account ID associated with the registry that contains the repository. If you do not specify a registry, the default registry is assumed.
    public var registryId: Swift.String?
    /// The name of the repository.
    /// This member is required.
    public var repositoryName: Swift.String?

    public init(
        filter: ECRClientTypes.LifecyclePolicyPreviewFilter? = nil,
        imageIds: [ECRClientTypes.ImageIdentifier]? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        registryId: Swift.String? = nil,
        repositoryName: Swift.String? = nil
    )
    {
        self.filter = filter
        self.imageIds = imageIds
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.registryId = registryId
        self.repositoryName = repositoryName
    }
}

struct GetLifecyclePolicyPreviewInputBody: Swift.Equatable {
    let registryId: Swift.String?
    let repositoryName: Swift.String?
    let imageIds: [ECRClientTypes.ImageIdentifier]?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
    let filter: ECRClientTypes.LifecyclePolicyPreviewFilter?
}

extension GetLifecyclePolicyPreviewInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter
        case imageIds
        case maxResults
        case nextToken
        case registryId
        case repositoryName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let imageIdsContainer = try containerValues.decodeIfPresent([ECRClientTypes.ImageIdentifier?].self, forKey: .imageIds)
        var imageIdsDecoded0:[ECRClientTypes.ImageIdentifier]? = nil
        if let imageIdsContainer = imageIdsContainer {
            imageIdsDecoded0 = [ECRClientTypes.ImageIdentifier]()
            for structure0 in imageIdsContainer {
                if let structure0 = structure0 {
                    imageIdsDecoded0?.append(structure0)
                }
            }
        }
        imageIds = imageIdsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let filterDecoded = try containerValues.decodeIfPresent(ECRClientTypes.LifecyclePolicyPreviewFilter.self, forKey: .filter)
        filter = filterDecoded
    }
}

extension GetLifecyclePolicyPreviewOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetLifecyclePolicyPreviewOutputBody = try responseDecoder.decode(responseBody: data)
            self.lifecyclePolicyText = output.lifecyclePolicyText
            self.nextToken = output.nextToken
            self.previewResults = output.previewResults
            self.registryId = output.registryId
            self.repositoryName = output.repositoryName
            self.status = output.status
            self.summary = output.summary
        } else {
            self.lifecyclePolicyText = nil
            self.nextToken = nil
            self.previewResults = nil
            self.registryId = nil
            self.repositoryName = nil
            self.status = nil
            self.summary = nil
        }
    }
}

public struct GetLifecyclePolicyPreviewOutput: Swift.Equatable {
    /// The JSON lifecycle policy text.
    public var lifecyclePolicyText: Swift.String?
    /// The nextToken value to include in a future GetLifecyclePolicyPreview request. When the results of a GetLifecyclePolicyPreview request exceed maxResults, this value can be used to retrieve the next page of results. This value is null when there are no more results to return.
    public var nextToken: Swift.String?
    /// The results of the lifecycle policy preview request.
    public var previewResults: [ECRClientTypes.LifecyclePolicyPreviewResult]?
    /// The registry ID associated with the request.
    public var registryId: Swift.String?
    /// The repository name associated with the request.
    public var repositoryName: Swift.String?
    /// The status of the lifecycle policy preview request.
    public var status: ECRClientTypes.LifecyclePolicyPreviewStatus?
    /// The list of images that is returned as a result of the action.
    public var summary: ECRClientTypes.LifecyclePolicyPreviewSummary?

    public init(
        lifecyclePolicyText: Swift.String? = nil,
        nextToken: Swift.String? = nil,
        previewResults: [ECRClientTypes.LifecyclePolicyPreviewResult]? = nil,
        registryId: Swift.String? = nil,
        repositoryName: Swift.String? = nil,
        status: ECRClientTypes.LifecyclePolicyPreviewStatus? = nil,
        summary: ECRClientTypes.LifecyclePolicyPreviewSummary? = nil
    )
    {
        self.lifecyclePolicyText = lifecyclePolicyText
        self.nextToken = nextToken
        self.previewResults = previewResults
        self.registryId = registryId
        self.repositoryName = repositoryName
        self.status = status
        self.summary = summary
    }
}

struct GetLifecyclePolicyPreviewOutputBody: Swift.Equatable {
    let registryId: Swift.String?
    let repositoryName: Swift.String?
    let lifecyclePolicyText: Swift.String?
    let status: ECRClientTypes.LifecyclePolicyPreviewStatus?
    let nextToken: Swift.String?
    let previewResults: [ECRClientTypes.LifecyclePolicyPreviewResult]?
    let summary: ECRClientTypes.LifecyclePolicyPreviewSummary?
}

extension GetLifecyclePolicyPreviewOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lifecyclePolicyText
        case nextToken
        case previewResults
        case registryId
        case repositoryName
        case status
        case summary
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let lifecyclePolicyTextDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lifecyclePolicyText)
        lifecyclePolicyText = lifecyclePolicyTextDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ECRClientTypes.LifecyclePolicyPreviewStatus.self, forKey: .status)
        status = statusDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let previewResultsContainer = try containerValues.decodeIfPresent([ECRClientTypes.LifecyclePolicyPreviewResult?].self, forKey: .previewResults)
        var previewResultsDecoded0:[ECRClientTypes.LifecyclePolicyPreviewResult]? = nil
        if let previewResultsContainer = previewResultsContainer {
            previewResultsDecoded0 = [ECRClientTypes.LifecyclePolicyPreviewResult]()
            for structure0 in previewResultsContainer {
                if let structure0 = structure0 {
                    previewResultsDecoded0?.append(structure0)
                }
            }
        }
        previewResults = previewResultsDecoded0
        let summaryDecoded = try containerValues.decodeIfPresent(ECRClientTypes.LifecyclePolicyPreviewSummary.self, forKey: .summary)
        summary = summaryDecoded
    }
}

enum GetLifecyclePolicyPreviewOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LifecyclePolicyPreviewNotFoundException": return try await LifecyclePolicyPreviewNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RepositoryNotFoundException": return try await RepositoryNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServerException": return try await ServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetRegistryPolicyInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension GetRegistryPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetRegistryPolicyInput: Swift.Equatable {

    public init() { }
}

struct GetRegistryPolicyInputBody: Swift.Equatable {
}

extension GetRegistryPolicyInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetRegistryPolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetRegistryPolicyOutputBody = try responseDecoder.decode(responseBody: data)
            self.policyText = output.policyText
            self.registryId = output.registryId
        } else {
            self.policyText = nil
            self.registryId = nil
        }
    }
}

public struct GetRegistryPolicyOutput: Swift.Equatable {
    /// The JSON text of the permissions policy for a registry.
    public var policyText: Swift.String?
    /// The ID of the registry.
    public var registryId: Swift.String?

    public init(
        policyText: Swift.String? = nil,
        registryId: Swift.String? = nil
    )
    {
        self.policyText = policyText
        self.registryId = registryId
    }
}

struct GetRegistryPolicyOutputBody: Swift.Equatable {
    let registryId: Swift.String?
    let policyText: Swift.String?
}

extension GetRegistryPolicyOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policyText
        case registryId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let policyTextDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyText)
        policyText = policyTextDecoded
    }
}

enum GetRegistryPolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RegistryPolicyNotFoundException": return try await RegistryPolicyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServerException": return try await ServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetRegistryScanningConfigurationInput: Swift.Encodable {

    public func encode(to encoder: Swift.Encoder) throws {
        var container = encoder.singleValueContainer()
        try container.encode([String:String]())
    }
}

extension GetRegistryScanningConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetRegistryScanningConfigurationInput: Swift.Equatable {

    public init() { }
}

struct GetRegistryScanningConfigurationInputBody: Swift.Equatable {
}

extension GetRegistryScanningConfigurationInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetRegistryScanningConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetRegistryScanningConfigurationOutputBody = try responseDecoder.decode(responseBody: data)
            self.registryId = output.registryId
            self.scanningConfiguration = output.scanningConfiguration
        } else {
            self.registryId = nil
            self.scanningConfiguration = nil
        }
    }
}

public struct GetRegistryScanningConfigurationOutput: Swift.Equatable {
    /// The ID of the registry.
    public var registryId: Swift.String?
    /// The scanning configuration for the registry.
    public var scanningConfiguration: ECRClientTypes.RegistryScanningConfiguration?

    public init(
        registryId: Swift.String? = nil,
        scanningConfiguration: ECRClientTypes.RegistryScanningConfiguration? = nil
    )
    {
        self.registryId = registryId
        self.scanningConfiguration = scanningConfiguration
    }
}

struct GetRegistryScanningConfigurationOutputBody: Swift.Equatable {
    let registryId: Swift.String?
    let scanningConfiguration: ECRClientTypes.RegistryScanningConfiguration?
}

extension GetRegistryScanningConfigurationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case registryId
        case scanningConfiguration
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let scanningConfigurationDecoded = try containerValues.decodeIfPresent(ECRClientTypes.RegistryScanningConfiguration.self, forKey: .scanningConfiguration)
        scanningConfiguration = scanningConfigurationDecoded
    }
}

enum GetRegistryScanningConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServerException": return try await ServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetRepositoryPolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case registryId
        case repositoryName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let registryId = self.registryId {
            try encodeContainer.encode(registryId, forKey: .registryId)
        }
        if let repositoryName = self.repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }
}

extension GetRepositoryPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct GetRepositoryPolicyInput: Swift.Equatable {
    /// The Amazon Web Services account ID associated with the registry that contains the repository. If you do not specify a registry, the default registry is assumed.
    public var registryId: Swift.String?
    /// The name of the repository with the policy to retrieve.
    /// This member is required.
    public var repositoryName: Swift.String?

    public init(
        registryId: Swift.String? = nil,
        repositoryName: Swift.String? = nil
    )
    {
        self.registryId = registryId
        self.repositoryName = repositoryName
    }
}

struct GetRepositoryPolicyInputBody: Swift.Equatable {
    let registryId: Swift.String?
    let repositoryName: Swift.String?
}

extension GetRepositoryPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case registryId
        case repositoryName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
    }
}

extension GetRepositoryPolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetRepositoryPolicyOutputBody = try responseDecoder.decode(responseBody: data)
            self.policyText = output.policyText
            self.registryId = output.registryId
            self.repositoryName = output.repositoryName
        } else {
            self.policyText = nil
            self.registryId = nil
            self.repositoryName = nil
        }
    }
}

public struct GetRepositoryPolicyOutput: Swift.Equatable {
    /// The JSON repository policy text associated with the repository.
    public var policyText: Swift.String?
    /// The registry ID associated with the request.
    public var registryId: Swift.String?
    /// The repository name associated with the request.
    public var repositoryName: Swift.String?

    public init(
        policyText: Swift.String? = nil,
        registryId: Swift.String? = nil,
        repositoryName: Swift.String? = nil
    )
    {
        self.policyText = policyText
        self.registryId = registryId
        self.repositoryName = repositoryName
    }
}

struct GetRepositoryPolicyOutputBody: Swift.Equatable {
    let registryId: Swift.String?
    let repositoryName: Swift.String?
    let policyText: Swift.String?
}

extension GetRepositoryPolicyOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policyText
        case registryId
        case repositoryName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let policyTextDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyText)
        policyText = policyTextDecoded
    }
}

enum GetRepositoryPolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RepositoryNotFoundException": return try await RepositoryNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RepositoryPolicyNotFoundException": return try await RepositoryPolicyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServerException": return try await ServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ECRClientTypes.Image: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imageId
        case imageManifest
        case imageManifestMediaType
        case registryId
        case repositoryName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let imageId = self.imageId {
            try encodeContainer.encode(imageId, forKey: .imageId)
        }
        if let imageManifest = self.imageManifest {
            try encodeContainer.encode(imageManifest, forKey: .imageManifest)
        }
        if let imageManifestMediaType = self.imageManifestMediaType {
            try encodeContainer.encode(imageManifestMediaType, forKey: .imageManifestMediaType)
        }
        if let registryId = self.registryId {
            try encodeContainer.encode(registryId, forKey: .registryId)
        }
        if let repositoryName = self.repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let imageIdDecoded = try containerValues.decodeIfPresent(ECRClientTypes.ImageIdentifier.self, forKey: .imageId)
        imageId = imageIdDecoded
        let imageManifestDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageManifest)
        imageManifest = imageManifestDecoded
        let imageManifestMediaTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageManifestMediaType)
        imageManifestMediaType = imageManifestMediaTypeDecoded
    }
}

extension ECRClientTypes {
    /// An object representing an Amazon ECR image.
    public struct Image: Swift.Equatable {
        /// An object containing the image tag and image digest associated with an image.
        public var imageId: ECRClientTypes.ImageIdentifier?
        /// The image manifest associated with the image.
        public var imageManifest: Swift.String?
        /// The manifest media type of the image.
        public var imageManifestMediaType: Swift.String?
        /// The Amazon Web Services account ID associated with the registry containing the image.
        public var registryId: Swift.String?
        /// The name of the repository associated with the image.
        public var repositoryName: Swift.String?

        public init(
            imageId: ECRClientTypes.ImageIdentifier? = nil,
            imageManifest: Swift.String? = nil,
            imageManifestMediaType: Swift.String? = nil,
            registryId: Swift.String? = nil,
            repositoryName: Swift.String? = nil
        )
        {
            self.imageId = imageId
            self.imageManifest = imageManifest
            self.imageManifestMediaType = imageManifestMediaType
            self.registryId = registryId
            self.repositoryName = repositoryName
        }
    }

}

extension ECRClientTypes {
    public enum ImageActionType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case expire
        case sdkUnknown(Swift.String)

        public static var allCases: [ImageActionType] {
            return [
                .expire,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .expire: return "EXPIRE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ImageActionType(rawValue: rawValue) ?? ImageActionType.sdkUnknown(rawValue)
        }
    }
}

extension ImageAlreadyExistsException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ImageAlreadyExistsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The specified image has already been pushed, and there were no changes to the manifest or image tag after the last push.
public struct ImageAlreadyExistsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The error message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ImageAlreadyExistsException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ImageAlreadyExistsExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ImageAlreadyExistsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ECRClientTypes.ImageDetail: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case artifactMediaType
        case imageDigest
        case imageManifestMediaType
        case imagePushedAt
        case imageScanFindingsSummary
        case imageScanStatus
        case imageSizeInBytes
        case imageTags
        case lastRecordedPullTime
        case registryId
        case repositoryName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let artifactMediaType = self.artifactMediaType {
            try encodeContainer.encode(artifactMediaType, forKey: .artifactMediaType)
        }
        if let imageDigest = self.imageDigest {
            try encodeContainer.encode(imageDigest, forKey: .imageDigest)
        }
        if let imageManifestMediaType = self.imageManifestMediaType {
            try encodeContainer.encode(imageManifestMediaType, forKey: .imageManifestMediaType)
        }
        if let imagePushedAt = self.imagePushedAt {
            try encodeContainer.encodeTimestamp(imagePushedAt, format: .epochSeconds, forKey: .imagePushedAt)
        }
        if let imageScanFindingsSummary = self.imageScanFindingsSummary {
            try encodeContainer.encode(imageScanFindingsSummary, forKey: .imageScanFindingsSummary)
        }
        if let imageScanStatus = self.imageScanStatus {
            try encodeContainer.encode(imageScanStatus, forKey: .imageScanStatus)
        }
        if let imageSizeInBytes = self.imageSizeInBytes {
            try encodeContainer.encode(imageSizeInBytes, forKey: .imageSizeInBytes)
        }
        if let imageTags = imageTags {
            var imageTagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .imageTags)
            for imagetag0 in imageTags {
                try imageTagsContainer.encode(imagetag0)
            }
        }
        if let lastRecordedPullTime = self.lastRecordedPullTime {
            try encodeContainer.encodeTimestamp(lastRecordedPullTime, format: .epochSeconds, forKey: .lastRecordedPullTime)
        }
        if let registryId = self.registryId {
            try encodeContainer.encode(registryId, forKey: .registryId)
        }
        if let repositoryName = self.repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let imageDigestDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageDigest)
        imageDigest = imageDigestDecoded
        let imageTagsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .imageTags)
        var imageTagsDecoded0:[Swift.String]? = nil
        if let imageTagsContainer = imageTagsContainer {
            imageTagsDecoded0 = [Swift.String]()
            for string0 in imageTagsContainer {
                if let string0 = string0 {
                    imageTagsDecoded0?.append(string0)
                }
            }
        }
        imageTags = imageTagsDecoded0
        let imageSizeInBytesDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .imageSizeInBytes)
        imageSizeInBytes = imageSizeInBytesDecoded
        let imagePushedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .imagePushedAt)
        imagePushedAt = imagePushedAtDecoded
        let imageScanStatusDecoded = try containerValues.decodeIfPresent(ECRClientTypes.ImageScanStatus.self, forKey: .imageScanStatus)
        imageScanStatus = imageScanStatusDecoded
        let imageScanFindingsSummaryDecoded = try containerValues.decodeIfPresent(ECRClientTypes.ImageScanFindingsSummary.self, forKey: .imageScanFindingsSummary)
        imageScanFindingsSummary = imageScanFindingsSummaryDecoded
        let imageManifestMediaTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageManifestMediaType)
        imageManifestMediaType = imageManifestMediaTypeDecoded
        let artifactMediaTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .artifactMediaType)
        artifactMediaType = artifactMediaTypeDecoded
        let lastRecordedPullTimeDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastRecordedPullTime)
        lastRecordedPullTime = lastRecordedPullTimeDecoded
    }
}

extension ECRClientTypes {
    /// An object that describes an image returned by a [DescribeImages] operation.
    public struct ImageDetail: Swift.Equatable {
        /// The artifact media type of the image.
        public var artifactMediaType: Swift.String?
        /// The sha256 digest of the image manifest.
        public var imageDigest: Swift.String?
        /// The media type of the image manifest.
        public var imageManifestMediaType: Swift.String?
        /// The date and time, expressed in standard JavaScript date format, at which the current image was pushed to the repository.
        public var imagePushedAt: ClientRuntime.Date?
        /// A summary of the last completed image scan.
        public var imageScanFindingsSummary: ECRClientTypes.ImageScanFindingsSummary?
        /// The current state of the scan.
        public var imageScanStatus: ECRClientTypes.ImageScanStatus?
        /// The size, in bytes, of the image in the repository. If the image is a manifest list, this will be the max size of all manifests in the list. Beginning with Docker version 1.9, the Docker client compresses image layers before pushing them to a V2 Docker registry. The output of the docker images command shows the uncompressed image size, so it may return a larger image size than the image sizes returned by [DescribeImages].
        public var imageSizeInBytes: Swift.Int?
        /// The list of tags associated with this image.
        public var imageTags: [Swift.String]?
        /// The date and time, expressed in standard JavaScript date format, when Amazon ECR recorded the last image pull. Amazon ECR refreshes the last image pull timestamp at least once every 24 hours. For example, if you pull an image once a day then the lastRecordedPullTime timestamp will indicate the exact time that the image was last pulled. However, if you pull an image once an hour, because Amazon ECR refreshes the lastRecordedPullTime timestamp at least once every 24 hours, the result may not be the exact time that the image was last pulled.
        public var lastRecordedPullTime: ClientRuntime.Date?
        /// The Amazon Web Services account ID associated with the registry to which this image belongs.
        public var registryId: Swift.String?
        /// The name of the repository to which this image belongs.
        public var repositoryName: Swift.String?

        public init(
            artifactMediaType: Swift.String? = nil,
            imageDigest: Swift.String? = nil,
            imageManifestMediaType: Swift.String? = nil,
            imagePushedAt: ClientRuntime.Date? = nil,
            imageScanFindingsSummary: ECRClientTypes.ImageScanFindingsSummary? = nil,
            imageScanStatus: ECRClientTypes.ImageScanStatus? = nil,
            imageSizeInBytes: Swift.Int? = nil,
            imageTags: [Swift.String]? = nil,
            lastRecordedPullTime: ClientRuntime.Date? = nil,
            registryId: Swift.String? = nil,
            repositoryName: Swift.String? = nil
        )
        {
            self.artifactMediaType = artifactMediaType
            self.imageDigest = imageDigest
            self.imageManifestMediaType = imageManifestMediaType
            self.imagePushedAt = imagePushedAt
            self.imageScanFindingsSummary = imageScanFindingsSummary
            self.imageScanStatus = imageScanStatus
            self.imageSizeInBytes = imageSizeInBytes
            self.imageTags = imageTags
            self.lastRecordedPullTime = lastRecordedPullTime
            self.registryId = registryId
            self.repositoryName = repositoryName
        }
    }

}

extension ImageDigestDoesNotMatchException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ImageDigestDoesNotMatchExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The specified image digest does not match the digest that Amazon ECR calculated for the image.
public struct ImageDigestDoesNotMatchException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ImageDigestDoesNotMatchException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ImageDigestDoesNotMatchExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ImageDigestDoesNotMatchExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ECRClientTypes.ImageFailure: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failureCode
        case failureReason
        case imageId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let failureCode = self.failureCode {
            try encodeContainer.encode(failureCode.rawValue, forKey: .failureCode)
        }
        if let failureReason = self.failureReason {
            try encodeContainer.encode(failureReason, forKey: .failureReason)
        }
        if let imageId = self.imageId {
            try encodeContainer.encode(imageId, forKey: .imageId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imageIdDecoded = try containerValues.decodeIfPresent(ECRClientTypes.ImageIdentifier.self, forKey: .imageId)
        imageId = imageIdDecoded
        let failureCodeDecoded = try containerValues.decodeIfPresent(ECRClientTypes.ImageFailureCode.self, forKey: .failureCode)
        failureCode = failureCodeDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
    }
}

extension ECRClientTypes {
    /// An object representing an Amazon ECR image failure.
    public struct ImageFailure: Swift.Equatable {
        /// The code associated with the failure.
        public var failureCode: ECRClientTypes.ImageFailureCode?
        /// The reason for the failure.
        public var failureReason: Swift.String?
        /// The image ID associated with the failure.
        public var imageId: ECRClientTypes.ImageIdentifier?

        public init(
            failureCode: ECRClientTypes.ImageFailureCode? = nil,
            failureReason: Swift.String? = nil,
            imageId: ECRClientTypes.ImageIdentifier? = nil
        )
        {
            self.failureCode = failureCode
            self.failureReason = failureReason
            self.imageId = imageId
        }
    }

}

extension ECRClientTypes {
    public enum ImageFailureCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case imagenotfound
        case imagereferencedbymanifestlist
        case imagetagdoesnotmatchdigest
        case invalidimagedigest
        case invalidimagetag
        case kmserror
        case missingdigestandtag
        case sdkUnknown(Swift.String)

        public static var allCases: [ImageFailureCode] {
            return [
                .imagenotfound,
                .imagereferencedbymanifestlist,
                .imagetagdoesnotmatchdigest,
                .invalidimagedigest,
                .invalidimagetag,
                .kmserror,
                .missingdigestandtag,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .imagenotfound: return "ImageNotFound"
            case .imagereferencedbymanifestlist: return "ImageReferencedByManifestList"
            case .imagetagdoesnotmatchdigest: return "ImageTagDoesNotMatchDigest"
            case .invalidimagedigest: return "InvalidImageDigest"
            case .invalidimagetag: return "InvalidImageTag"
            case .kmserror: return "KmsError"
            case .missingdigestandtag: return "MissingDigestAndTag"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ImageFailureCode(rawValue: rawValue) ?? ImageFailureCode.sdkUnknown(rawValue)
        }
    }
}

extension ECRClientTypes.ImageIdentifier: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imageDigest
        case imageTag
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let imageDigest = self.imageDigest {
            try encodeContainer.encode(imageDigest, forKey: .imageDigest)
        }
        if let imageTag = self.imageTag {
            try encodeContainer.encode(imageTag, forKey: .imageTag)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imageDigestDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageDigest)
        imageDigest = imageDigestDecoded
        let imageTagDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageTag)
        imageTag = imageTagDecoded
    }
}

extension ECRClientTypes {
    /// An object with identifying information for an image in an Amazon ECR repository.
    public struct ImageIdentifier: Swift.Equatable {
        /// The sha256 digest of the image manifest.
        public var imageDigest: Swift.String?
        /// The tag used for the image.
        public var imageTag: Swift.String?

        public init(
            imageDigest: Swift.String? = nil,
            imageTag: Swift.String? = nil
        )
        {
            self.imageDigest = imageDigest
            self.imageTag = imageTag
        }
    }

}

extension ImageNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ImageNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The image requested does not exist in the specified repository.
public struct ImageNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ImageNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ImageNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ImageNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ECRClientTypes.ImageReplicationStatus: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failureCode
        case region
        case registryId
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let failureCode = self.failureCode {
            try encodeContainer.encode(failureCode, forKey: .failureCode)
        }
        if let region = self.region {
            try encodeContainer.encode(region, forKey: .region)
        }
        if let registryId = self.registryId {
            try encodeContainer.encode(registryId, forKey: .registryId)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let regionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .region)
        region = regionDecoded
        let registryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ECRClientTypes.ReplicationStatus.self, forKey: .status)
        status = statusDecoded
        let failureCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureCode)
        failureCode = failureCodeDecoded
    }
}

extension ECRClientTypes {
    /// The status of the replication process for an image.
    public struct ImageReplicationStatus: Swift.Equatable {
        /// The failure code for a replication that has failed.
        public var failureCode: Swift.String?
        /// The destination Region for the image replication.
        public var region: Swift.String?
        /// The Amazon Web Services account ID associated with the registry to which the image belongs.
        public var registryId: Swift.String?
        /// The image replication status.
        public var status: ECRClientTypes.ReplicationStatus?

        public init(
            failureCode: Swift.String? = nil,
            region: Swift.String? = nil,
            registryId: Swift.String? = nil,
            status: ECRClientTypes.ReplicationStatus? = nil
        )
        {
            self.failureCode = failureCode
            self.region = region
            self.registryId = registryId
            self.status = status
        }
    }

}

extension ECRClientTypes.ImageScanFinding: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case attributes
        case description
        case name
        case severity
        case uri
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let attributes = attributes {
            var attributesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .attributes)
            for attribute0 in attributes {
                try attributesContainer.encode(attribute0)
            }
        }
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let severity = self.severity {
            try encodeContainer.encode(severity.rawValue, forKey: .severity)
        }
        if let uri = self.uri {
            try encodeContainer.encode(uri, forKey: .uri)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
        let uriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .uri)
        uri = uriDecoded
        let severityDecoded = try containerValues.decodeIfPresent(ECRClientTypes.FindingSeverity.self, forKey: .severity)
        severity = severityDecoded
        let attributesContainer = try containerValues.decodeIfPresent([ECRClientTypes.Attribute?].self, forKey: .attributes)
        var attributesDecoded0:[ECRClientTypes.Attribute]? = nil
        if let attributesContainer = attributesContainer {
            attributesDecoded0 = [ECRClientTypes.Attribute]()
            for structure0 in attributesContainer {
                if let structure0 = structure0 {
                    attributesDecoded0?.append(structure0)
                }
            }
        }
        attributes = attributesDecoded0
    }
}

extension ECRClientTypes {
    /// Contains information about an image scan finding.
    public struct ImageScanFinding: Swift.Equatable {
        /// A collection of attributes of the host from which the finding is generated.
        public var attributes: [ECRClientTypes.Attribute]?
        /// The description of the finding.
        public var description: Swift.String?
        /// The name associated with the finding, usually a CVE number.
        public var name: Swift.String?
        /// The finding severity.
        public var severity: ECRClientTypes.FindingSeverity?
        /// A link containing additional details about the security vulnerability.
        public var uri: Swift.String?

        public init(
            attributes: [ECRClientTypes.Attribute]? = nil,
            description: Swift.String? = nil,
            name: Swift.String? = nil,
            severity: ECRClientTypes.FindingSeverity? = nil,
            uri: Swift.String? = nil
        )
        {
            self.attributes = attributes
            self.description = description
            self.name = name
            self.severity = severity
            self.uri = uri
        }
    }

}

extension ECRClientTypes.ImageScanFindings: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case enhancedFindings
        case findingSeverityCounts
        case findings
        case imageScanCompletedAt
        case vulnerabilitySourceUpdatedAt
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let enhancedFindings = enhancedFindings {
            var enhancedFindingsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .enhancedFindings)
            for enhancedimagescanfinding0 in enhancedFindings {
                try enhancedFindingsContainer.encode(enhancedimagescanfinding0)
            }
        }
        if let findingSeverityCounts = findingSeverityCounts {
            var findingSeverityCountsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .findingSeverityCounts)
            for (dictKey0, findingSeverityCounts0) in findingSeverityCounts {
                try findingSeverityCountsContainer.encode(findingSeverityCounts0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let findings = findings {
            var findingsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .findings)
            for imagescanfinding0 in findings {
                try findingsContainer.encode(imagescanfinding0)
            }
        }
        if let imageScanCompletedAt = self.imageScanCompletedAt {
            try encodeContainer.encodeTimestamp(imageScanCompletedAt, format: .epochSeconds, forKey: .imageScanCompletedAt)
        }
        if let vulnerabilitySourceUpdatedAt = self.vulnerabilitySourceUpdatedAt {
            try encodeContainer.encodeTimestamp(vulnerabilitySourceUpdatedAt, format: .epochSeconds, forKey: .vulnerabilitySourceUpdatedAt)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imageScanCompletedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .imageScanCompletedAt)
        imageScanCompletedAt = imageScanCompletedAtDecoded
        let vulnerabilitySourceUpdatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .vulnerabilitySourceUpdatedAt)
        vulnerabilitySourceUpdatedAt = vulnerabilitySourceUpdatedAtDecoded
        let findingSeverityCountsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.Int?].self, forKey: .findingSeverityCounts)
        var findingSeverityCountsDecoded0: [Swift.String:Swift.Int]? = nil
        if let findingSeverityCountsContainer = findingSeverityCountsContainer {
            findingSeverityCountsDecoded0 = [Swift.String:Swift.Int]()
            for (key0, severitycount0) in findingSeverityCountsContainer {
                if let severitycount0 = severitycount0 {
                    findingSeverityCountsDecoded0?[key0] = severitycount0
                }
            }
        }
        findingSeverityCounts = findingSeverityCountsDecoded0
        let findingsContainer = try containerValues.decodeIfPresent([ECRClientTypes.ImageScanFinding?].self, forKey: .findings)
        var findingsDecoded0:[ECRClientTypes.ImageScanFinding]? = nil
        if let findingsContainer = findingsContainer {
            findingsDecoded0 = [ECRClientTypes.ImageScanFinding]()
            for structure0 in findingsContainer {
                if let structure0 = structure0 {
                    findingsDecoded0?.append(structure0)
                }
            }
        }
        findings = findingsDecoded0
        let enhancedFindingsContainer = try containerValues.decodeIfPresent([ECRClientTypes.EnhancedImageScanFinding?].self, forKey: .enhancedFindings)
        var enhancedFindingsDecoded0:[ECRClientTypes.EnhancedImageScanFinding]? = nil
        if let enhancedFindingsContainer = enhancedFindingsContainer {
            enhancedFindingsDecoded0 = [ECRClientTypes.EnhancedImageScanFinding]()
            for structure0 in enhancedFindingsContainer {
                if let structure0 = structure0 {
                    enhancedFindingsDecoded0?.append(structure0)
                }
            }
        }
        enhancedFindings = enhancedFindingsDecoded0
    }
}

extension ECRClientTypes {
    /// The details of an image scan.
    public struct ImageScanFindings: Swift.Equatable {
        /// Details about the enhanced scan findings from Amazon Inspector.
        public var enhancedFindings: [ECRClientTypes.EnhancedImageScanFinding]?
        /// The image vulnerability counts, sorted by severity.
        public var findingSeverityCounts: [Swift.String:Swift.Int]?
        /// The findings from the image scan.
        public var findings: [ECRClientTypes.ImageScanFinding]?
        /// The time of the last completed image scan.
        public var imageScanCompletedAt: ClientRuntime.Date?
        /// The time when the vulnerability data was last scanned.
        public var vulnerabilitySourceUpdatedAt: ClientRuntime.Date?

        public init(
            enhancedFindings: [ECRClientTypes.EnhancedImageScanFinding]? = nil,
            findingSeverityCounts: [Swift.String:Swift.Int]? = nil,
            findings: [ECRClientTypes.ImageScanFinding]? = nil,
            imageScanCompletedAt: ClientRuntime.Date? = nil,
            vulnerabilitySourceUpdatedAt: ClientRuntime.Date? = nil
        )
        {
            self.enhancedFindings = enhancedFindings
            self.findingSeverityCounts = findingSeverityCounts
            self.findings = findings
            self.imageScanCompletedAt = imageScanCompletedAt
            self.vulnerabilitySourceUpdatedAt = vulnerabilitySourceUpdatedAt
        }
    }

}

extension ECRClientTypes.ImageScanFindingsSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case findingSeverityCounts
        case imageScanCompletedAt
        case vulnerabilitySourceUpdatedAt
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let findingSeverityCounts = findingSeverityCounts {
            var findingSeverityCountsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .findingSeverityCounts)
            for (dictKey0, findingSeverityCounts0) in findingSeverityCounts {
                try findingSeverityCountsContainer.encode(findingSeverityCounts0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let imageScanCompletedAt = self.imageScanCompletedAt {
            try encodeContainer.encodeTimestamp(imageScanCompletedAt, format: .epochSeconds, forKey: .imageScanCompletedAt)
        }
        if let vulnerabilitySourceUpdatedAt = self.vulnerabilitySourceUpdatedAt {
            try encodeContainer.encodeTimestamp(vulnerabilitySourceUpdatedAt, format: .epochSeconds, forKey: .vulnerabilitySourceUpdatedAt)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imageScanCompletedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .imageScanCompletedAt)
        imageScanCompletedAt = imageScanCompletedAtDecoded
        let vulnerabilitySourceUpdatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .vulnerabilitySourceUpdatedAt)
        vulnerabilitySourceUpdatedAt = vulnerabilitySourceUpdatedAtDecoded
        let findingSeverityCountsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.Int?].self, forKey: .findingSeverityCounts)
        var findingSeverityCountsDecoded0: [Swift.String:Swift.Int]? = nil
        if let findingSeverityCountsContainer = findingSeverityCountsContainer {
            findingSeverityCountsDecoded0 = [Swift.String:Swift.Int]()
            for (key0, severitycount0) in findingSeverityCountsContainer {
                if let severitycount0 = severitycount0 {
                    findingSeverityCountsDecoded0?[key0] = severitycount0
                }
            }
        }
        findingSeverityCounts = findingSeverityCountsDecoded0
    }
}

extension ECRClientTypes {
    /// A summary of the last completed image scan.
    public struct ImageScanFindingsSummary: Swift.Equatable {
        /// The image vulnerability counts, sorted by severity.
        public var findingSeverityCounts: [Swift.String:Swift.Int]?
        /// The time of the last completed image scan.
        public var imageScanCompletedAt: ClientRuntime.Date?
        /// The time when the vulnerability data was last scanned.
        public var vulnerabilitySourceUpdatedAt: ClientRuntime.Date?

        public init(
            findingSeverityCounts: [Swift.String:Swift.Int]? = nil,
            imageScanCompletedAt: ClientRuntime.Date? = nil,
            vulnerabilitySourceUpdatedAt: ClientRuntime.Date? = nil
        )
        {
            self.findingSeverityCounts = findingSeverityCounts
            self.imageScanCompletedAt = imageScanCompletedAt
            self.vulnerabilitySourceUpdatedAt = vulnerabilitySourceUpdatedAt
        }
    }

}

extension ECRClientTypes.ImageScanStatus: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case description
        case status
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let description = self.description {
            try encodeContainer.encode(description, forKey: .description)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let statusDecoded = try containerValues.decodeIfPresent(ECRClientTypes.ScanStatus.self, forKey: .status)
        status = statusDecoded
        let descriptionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .description)
        description = descriptionDecoded
    }
}

extension ECRClientTypes {
    /// The current status of an image scan.
    public struct ImageScanStatus: Swift.Equatable {
        /// The description of the image scan status.
        public var description: Swift.String?
        /// The current state of an image scan.
        public var status: ECRClientTypes.ScanStatus?

        public init(
            description: Swift.String? = nil,
            status: ECRClientTypes.ScanStatus? = nil
        )
        {
            self.description = description
            self.status = status
        }
    }

}

extension ECRClientTypes.ImageScanningConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case scanOnPush
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if scanOnPush != false {
            try encodeContainer.encode(scanOnPush, forKey: .scanOnPush)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scanOnPushDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .scanOnPush) ?? false
        scanOnPush = scanOnPushDecoded
    }
}

extension ECRClientTypes {
    /// The image scanning configuration for a repository.
    public struct ImageScanningConfiguration: Swift.Equatable {
        /// The setting that determines whether images are scanned after being pushed to a repository. If set to true, images will be scanned after being pushed. If this parameter is not specified, it will default to false and images will not be scanned unless a scan is manually started with the [API_StartImageScan](https://docs.aws.amazon.com/AmazonECR/latest/APIReference/API_StartImageScan.html) API.
        public var scanOnPush: Swift.Bool

        public init(
            scanOnPush: Swift.Bool = false
        )
        {
            self.scanOnPush = scanOnPush
        }
    }

}

extension ImageTagAlreadyExistsException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ImageTagAlreadyExistsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The specified image is tagged with a tag that already exists. The repository is configured for tag immutability.
public struct ImageTagAlreadyExistsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ImageTagAlreadyExistsException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ImageTagAlreadyExistsExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ImageTagAlreadyExistsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ECRClientTypes {
    public enum ImageTagMutability: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case immutable
        case mutable
        case sdkUnknown(Swift.String)

        public static var allCases: [ImageTagMutability] {
            return [
                .immutable,
                .mutable,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .immutable: return "IMMUTABLE"
            case .mutable: return "MUTABLE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ImageTagMutability(rawValue: rawValue) ?? ImageTagMutability.sdkUnknown(rawValue)
        }
    }
}

extension InitiateLayerUploadInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case registryId
        case repositoryName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let registryId = self.registryId {
            try encodeContainer.encode(registryId, forKey: .registryId)
        }
        if let repositoryName = self.repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }
}

extension InitiateLayerUploadInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct InitiateLayerUploadInput: Swift.Equatable {
    /// The Amazon Web Services account ID associated with the registry to which you intend to upload layers. If you do not specify a registry, the default registry is assumed.
    public var registryId: Swift.String?
    /// The name of the repository to which you intend to upload layers.
    /// This member is required.
    public var repositoryName: Swift.String?

    public init(
        registryId: Swift.String? = nil,
        repositoryName: Swift.String? = nil
    )
    {
        self.registryId = registryId
        self.repositoryName = repositoryName
    }
}

struct InitiateLayerUploadInputBody: Swift.Equatable {
    let registryId: Swift.String?
    let repositoryName: Swift.String?
}

extension InitiateLayerUploadInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case registryId
        case repositoryName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
    }
}

extension InitiateLayerUploadOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InitiateLayerUploadOutputBody = try responseDecoder.decode(responseBody: data)
            self.partSize = output.partSize
            self.uploadId = output.uploadId
        } else {
            self.partSize = nil
            self.uploadId = nil
        }
    }
}

public struct InitiateLayerUploadOutput: Swift.Equatable {
    /// The size, in bytes, that Amazon ECR expects future layer part uploads to be.
    public var partSize: Swift.Int?
    /// The upload ID for the layer upload. This parameter is passed to further [UploadLayerPart] and [CompleteLayerUpload] operations.
    public var uploadId: Swift.String?

    public init(
        partSize: Swift.Int? = nil,
        uploadId: Swift.String? = nil
    )
    {
        self.partSize = partSize
        self.uploadId = uploadId
    }
}

struct InitiateLayerUploadOutputBody: Swift.Equatable {
    let uploadId: Swift.String?
    let partSize: Swift.Int?
}

extension InitiateLayerUploadOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case partSize
        case uploadId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let uploadIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .uploadId)
        uploadId = uploadIdDecoded
        let partSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .partSize)
        partSize = partSizeDecoded
    }
}

enum InitiateLayerUploadOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "KmsException": return try await KmsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RepositoryNotFoundException": return try await RepositoryNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServerException": return try await ServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension InvalidLayerException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidLayerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The layer digest calculation performed by Amazon ECR upon receipt of the image layer does not match the digest specified.
public struct InvalidLayerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The error message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidLayerException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidLayerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidLayerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidLayerPartException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidLayerPartExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.lastValidByteReceived = output.lastValidByteReceived
            self.properties.message = output.message
            self.properties.registryId = output.registryId
            self.properties.repositoryName = output.repositoryName
            self.properties.uploadId = output.uploadId
        } else {
            self.properties.lastValidByteReceived = nil
            self.properties.message = nil
            self.properties.registryId = nil
            self.properties.repositoryName = nil
            self.properties.uploadId = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The layer part size is not valid, or the first byte specified is not consecutive to the last byte of a previous layer part upload.
public struct InvalidLayerPartException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The last valid byte received from the layer part upload that is associated with the exception.
        public internal(set) var lastValidByteReceived: Swift.Int? = nil
        /// The error message associated with the exception.
        public internal(set) var message: Swift.String? = nil
        /// The registry ID associated with the exception.
        public internal(set) var registryId: Swift.String? = nil
        /// The repository name associated with the exception.
        public internal(set) var repositoryName: Swift.String? = nil
        /// The upload ID associated with the exception.
        public internal(set) var uploadId: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidLayerPartException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        lastValidByteReceived: Swift.Int? = nil,
        message: Swift.String? = nil,
        registryId: Swift.String? = nil,
        repositoryName: Swift.String? = nil,
        uploadId: Swift.String? = nil
    )
    {
        self.properties.lastValidByteReceived = lastValidByteReceived
        self.properties.message = message
        self.properties.registryId = registryId
        self.properties.repositoryName = repositoryName
        self.properties.uploadId = uploadId
    }
}

struct InvalidLayerPartExceptionBody: Swift.Equatable {
    let registryId: Swift.String?
    let repositoryName: Swift.String?
    let uploadId: Swift.String?
    let lastValidByteReceived: Swift.Int?
    let message: Swift.String?
}

extension InvalidLayerPartExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lastValidByteReceived
        case message
        case registryId
        case repositoryName
        case uploadId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let uploadIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .uploadId)
        uploadId = uploadIdDecoded
        let lastValidByteReceivedDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .lastValidByteReceived)
        lastValidByteReceived = lastValidByteReceivedDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidParameterException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidParameterExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The specified parameter is invalid. Review the available parameters for the API request.
public struct InvalidParameterException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The error message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidParameterException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidParameterExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidParameterExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InvalidTagParameterException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InvalidTagParameterExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// An invalid parameter has been specified. Tag keys can have a maximum character length of 128 characters, and tag values can have a maximum length of 256 characters.
public struct InvalidTagParameterException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InvalidTagParameterException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct InvalidTagParameterExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InvalidTagParameterExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension KmsException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: KmsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.kmsError = output.kmsError
            self.properties.message = output.message
        } else {
            self.properties.kmsError = nil
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The operation failed due to a KMS exception.
public struct KmsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The error code returned by KMS.
        public internal(set) var kmsError: Swift.String? = nil
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "KmsException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        kmsError: Swift.String? = nil,
        message: Swift.String? = nil
    )
    {
        self.properties.kmsError = kmsError
        self.properties.message = message
    }
}

struct KmsExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let kmsError: Swift.String?
}

extension KmsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case kmsError
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let kmsErrorDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsError)
        kmsError = kmsErrorDecoded
    }
}

extension ECRClientTypes.Layer: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case layerAvailability
        case layerDigest
        case layerSize
        case mediaType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let layerAvailability = self.layerAvailability {
            try encodeContainer.encode(layerAvailability.rawValue, forKey: .layerAvailability)
        }
        if let layerDigest = self.layerDigest {
            try encodeContainer.encode(layerDigest, forKey: .layerDigest)
        }
        if let layerSize = self.layerSize {
            try encodeContainer.encode(layerSize, forKey: .layerSize)
        }
        if let mediaType = self.mediaType {
            try encodeContainer.encode(mediaType, forKey: .mediaType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let layerDigestDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .layerDigest)
        layerDigest = layerDigestDecoded
        let layerAvailabilityDecoded = try containerValues.decodeIfPresent(ECRClientTypes.LayerAvailability.self, forKey: .layerAvailability)
        layerAvailability = layerAvailabilityDecoded
        let layerSizeDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .layerSize)
        layerSize = layerSizeDecoded
        let mediaTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .mediaType)
        mediaType = mediaTypeDecoded
    }
}

extension ECRClientTypes {
    /// An object representing an Amazon ECR image layer.
    public struct Layer: Swift.Equatable {
        /// The availability status of the image layer.
        public var layerAvailability: ECRClientTypes.LayerAvailability?
        /// The sha256 digest of the image layer.
        public var layerDigest: Swift.String?
        /// The size, in bytes, of the image layer.
        public var layerSize: Swift.Int?
        /// The media type of the layer, such as application/vnd.docker.image.rootfs.diff.tar.gzip or application/vnd.oci.image.layer.v1.tar+gzip.
        public var mediaType: Swift.String?

        public init(
            layerAvailability: ECRClientTypes.LayerAvailability? = nil,
            layerDigest: Swift.String? = nil,
            layerSize: Swift.Int? = nil,
            mediaType: Swift.String? = nil
        )
        {
            self.layerAvailability = layerAvailability
            self.layerDigest = layerDigest
            self.layerSize = layerSize
            self.mediaType = mediaType
        }
    }

}

extension LayerAlreadyExistsException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: LayerAlreadyExistsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The image layer already exists in the associated repository.
public struct LayerAlreadyExistsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The error message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "LayerAlreadyExistsException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct LayerAlreadyExistsExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension LayerAlreadyExistsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ECRClientTypes {
    public enum LayerAvailability: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case available
        case unavailable
        case sdkUnknown(Swift.String)

        public static var allCases: [LayerAvailability] {
            return [
                .available,
                .unavailable,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .unavailable: return "UNAVAILABLE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LayerAvailability(rawValue: rawValue) ?? LayerAvailability.sdkUnknown(rawValue)
        }
    }
}

extension ECRClientTypes.LayerFailure: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failureCode
        case failureReason
        case layerDigest
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let failureCode = self.failureCode {
            try encodeContainer.encode(failureCode.rawValue, forKey: .failureCode)
        }
        if let failureReason = self.failureReason {
            try encodeContainer.encode(failureReason, forKey: .failureReason)
        }
        if let layerDigest = self.layerDigest {
            try encodeContainer.encode(layerDigest, forKey: .layerDigest)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let layerDigestDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .layerDigest)
        layerDigest = layerDigestDecoded
        let failureCodeDecoded = try containerValues.decodeIfPresent(ECRClientTypes.LayerFailureCode.self, forKey: .failureCode)
        failureCode = failureCodeDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
    }
}

extension ECRClientTypes {
    /// An object representing an Amazon ECR image layer failure.
    public struct LayerFailure: Swift.Equatable {
        /// The failure code associated with the failure.
        public var failureCode: ECRClientTypes.LayerFailureCode?
        /// The reason for the failure.
        public var failureReason: Swift.String?
        /// The layer digest associated with the failure.
        public var layerDigest: Swift.String?

        public init(
            failureCode: ECRClientTypes.LayerFailureCode? = nil,
            failureReason: Swift.String? = nil,
            layerDigest: Swift.String? = nil
        )
        {
            self.failureCode = failureCode
            self.failureReason = failureReason
            self.layerDigest = layerDigest
        }
    }

}

extension ECRClientTypes {
    public enum LayerFailureCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case invalidlayerdigest
        case missinglayerdigest
        case sdkUnknown(Swift.String)

        public static var allCases: [LayerFailureCode] {
            return [
                .invalidlayerdigest,
                .missinglayerdigest,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .invalidlayerdigest: return "InvalidLayerDigest"
            case .missinglayerdigest: return "MissingLayerDigest"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LayerFailureCode(rawValue: rawValue) ?? LayerFailureCode.sdkUnknown(rawValue)
        }
    }
}

extension LayerInaccessibleException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: LayerInaccessibleExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The specified layer is not available because it is not associated with an image. Unassociated image layers may be cleaned up at any time.
public struct LayerInaccessibleException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The error message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "LayerInaccessibleException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct LayerInaccessibleExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension LayerInaccessibleExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LayerPartTooSmallException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: LayerPartTooSmallExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Layer parts must be at least 5 MiB in size.
public struct LayerPartTooSmallException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The error message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "LayerPartTooSmallException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct LayerPartTooSmallExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension LayerPartTooSmallExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LayersNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: LayersNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The specified layers could not be found, or the specified layer is not valid for this repository.
public struct LayersNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The error message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "LayersNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct LayersNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension LayersNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LifecyclePolicyNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: LifecyclePolicyNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The lifecycle policy could not be found, and no policy is set to the repository.
public struct LifecyclePolicyNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "LifecyclePolicyNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct LifecyclePolicyNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension LifecyclePolicyNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ECRClientTypes.LifecyclePolicyPreviewFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tagStatus
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tagStatus = self.tagStatus {
            try encodeContainer.encode(tagStatus.rawValue, forKey: .tagStatus)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagStatusDecoded = try containerValues.decodeIfPresent(ECRClientTypes.TagStatus.self, forKey: .tagStatus)
        tagStatus = tagStatusDecoded
    }
}

extension ECRClientTypes {
    /// The filter for the lifecycle policy preview.
    public struct LifecyclePolicyPreviewFilter: Swift.Equatable {
        /// The tag status of the image.
        public var tagStatus: ECRClientTypes.TagStatus?

        public init(
            tagStatus: ECRClientTypes.TagStatus? = nil
        )
        {
            self.tagStatus = tagStatus
        }
    }

}

extension LifecyclePolicyPreviewInProgressException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: LifecyclePolicyPreviewInProgressExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The previous lifecycle policy preview request has not completed. Wait and try again.
public struct LifecyclePolicyPreviewInProgressException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "LifecyclePolicyPreviewInProgressException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct LifecyclePolicyPreviewInProgressExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension LifecyclePolicyPreviewInProgressExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension LifecyclePolicyPreviewNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: LifecyclePolicyPreviewNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// There is no dry run for this repository.
public struct LifecyclePolicyPreviewNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "LifecyclePolicyPreviewNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct LifecyclePolicyPreviewNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension LifecyclePolicyPreviewNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ECRClientTypes.LifecyclePolicyPreviewResult: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case action
        case appliedRulePriority
        case imageDigest
        case imagePushedAt
        case imageTags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let action = self.action {
            try encodeContainer.encode(action, forKey: .action)
        }
        if let appliedRulePriority = self.appliedRulePriority {
            try encodeContainer.encode(appliedRulePriority, forKey: .appliedRulePriority)
        }
        if let imageDigest = self.imageDigest {
            try encodeContainer.encode(imageDigest, forKey: .imageDigest)
        }
        if let imagePushedAt = self.imagePushedAt {
            try encodeContainer.encodeTimestamp(imagePushedAt, format: .epochSeconds, forKey: .imagePushedAt)
        }
        if let imageTags = imageTags {
            var imageTagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .imageTags)
            for imagetag0 in imageTags {
                try imageTagsContainer.encode(imagetag0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imageTagsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .imageTags)
        var imageTagsDecoded0:[Swift.String]? = nil
        if let imageTagsContainer = imageTagsContainer {
            imageTagsDecoded0 = [Swift.String]()
            for string0 in imageTagsContainer {
                if let string0 = string0 {
                    imageTagsDecoded0?.append(string0)
                }
            }
        }
        imageTags = imageTagsDecoded0
        let imageDigestDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageDigest)
        imageDigest = imageDigestDecoded
        let imagePushedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .imagePushedAt)
        imagePushedAt = imagePushedAtDecoded
        let actionDecoded = try containerValues.decodeIfPresent(ECRClientTypes.LifecyclePolicyRuleAction.self, forKey: .action)
        action = actionDecoded
        let appliedRulePriorityDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .appliedRulePriority)
        appliedRulePriority = appliedRulePriorityDecoded
    }
}

extension ECRClientTypes {
    /// The result of the lifecycle policy preview.
    public struct LifecyclePolicyPreviewResult: Swift.Equatable {
        /// The type of action to be taken.
        public var action: ECRClientTypes.LifecyclePolicyRuleAction?
        /// The priority of the applied rule.
        public var appliedRulePriority: Swift.Int?
        /// The sha256 digest of the image manifest.
        public var imageDigest: Swift.String?
        /// The date and time, expressed in standard JavaScript date format, at which the current image was pushed to the repository.
        public var imagePushedAt: ClientRuntime.Date?
        /// The list of tags associated with this image.
        public var imageTags: [Swift.String]?

        public init(
            action: ECRClientTypes.LifecyclePolicyRuleAction? = nil,
            appliedRulePriority: Swift.Int? = nil,
            imageDigest: Swift.String? = nil,
            imagePushedAt: ClientRuntime.Date? = nil,
            imageTags: [Swift.String]? = nil
        )
        {
            self.action = action
            self.appliedRulePriority = appliedRulePriority
            self.imageDigest = imageDigest
            self.imagePushedAt = imagePushedAt
            self.imageTags = imageTags
        }
    }

}

extension ECRClientTypes {
    public enum LifecyclePolicyPreviewStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case complete
        case expired
        case failed
        case inProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [LifecyclePolicyPreviewStatus] {
            return [
                .complete,
                .expired,
                .failed,
                .inProgress,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .complete: return "COMPLETE"
            case .expired: return "EXPIRED"
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = LifecyclePolicyPreviewStatus(rawValue: rawValue) ?? LifecyclePolicyPreviewStatus.sdkUnknown(rawValue)
        }
    }
}

extension ECRClientTypes.LifecyclePolicyPreviewSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case expiringImageTotalCount
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let expiringImageTotalCount = self.expiringImageTotalCount {
            try encodeContainer.encode(expiringImageTotalCount, forKey: .expiringImageTotalCount)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let expiringImageTotalCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .expiringImageTotalCount)
        expiringImageTotalCount = expiringImageTotalCountDecoded
    }
}

extension ECRClientTypes {
    /// The summary of the lifecycle policy preview request.
    public struct LifecyclePolicyPreviewSummary: Swift.Equatable {
        /// The number of expiring images.
        public var expiringImageTotalCount: Swift.Int?

        public init(
            expiringImageTotalCount: Swift.Int? = nil
        )
        {
            self.expiringImageTotalCount = expiringImageTotalCount
        }
    }

}

extension ECRClientTypes.LifecyclePolicyRuleAction: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(ECRClientTypes.ImageActionType.self, forKey: .type)
        type = typeDecoded
    }
}

extension ECRClientTypes {
    /// The type of action to be taken.
    public struct LifecyclePolicyRuleAction: Swift.Equatable {
        /// The type of action to be taken.
        public var type: ECRClientTypes.ImageActionType?

        public init(
            type: ECRClientTypes.ImageActionType? = nil
        )
        {
            self.type = type
        }
    }

}

extension LimitExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: LimitExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The operation did not succeed because it would have exceeded a service limit for your account. For more information, see [Amazon ECR service quotas](https://docs.aws.amazon.com/AmazonECR/latest/userguide/service-quotas.html) in the Amazon Elastic Container Registry User Guide.
public struct LimitExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The error message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "LimitExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct LimitExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension LimitExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ECRClientTypes.ListImagesFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tagStatus
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tagStatus = self.tagStatus {
            try encodeContainer.encode(tagStatus.rawValue, forKey: .tagStatus)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagStatusDecoded = try containerValues.decodeIfPresent(ECRClientTypes.TagStatus.self, forKey: .tagStatus)
        tagStatus = tagStatusDecoded
    }
}

extension ECRClientTypes {
    /// An object representing a filter on a [ListImages] operation.
    public struct ListImagesFilter: Swift.Equatable {
        /// The tag status with which to filter your [ListImages] results. You can filter results based on whether they are TAGGED or UNTAGGED.
        public var tagStatus: ECRClientTypes.TagStatus?

        public init(
            tagStatus: ECRClientTypes.TagStatus? = nil
        )
        {
            self.tagStatus = tagStatus
        }
    }

}

extension ListImagesInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter
        case maxResults
        case nextToken
        case registryId
        case repositoryName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filter = self.filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
        if let maxResults = self.maxResults {
            try encodeContainer.encode(maxResults, forKey: .maxResults)
        }
        if let nextToken = self.nextToken {
            try encodeContainer.encode(nextToken, forKey: .nextToken)
        }
        if let registryId = self.registryId {
            try encodeContainer.encode(registryId, forKey: .registryId)
        }
        if let repositoryName = self.repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }
}

extension ListImagesInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListImagesInput: Swift.Equatable {
    /// The filter key and value with which to filter your ListImages results.
    public var filter: ECRClientTypes.ListImagesFilter?
    /// The maximum number of image results returned by ListImages in paginated output. When this parameter is used, ListImages only returns maxResults results in a single page along with a nextToken response element. The remaining results of the initial request can be seen by sending another ListImages request with the returned nextToken value. This value can be between 1 and 1000. If this parameter is not used, then ListImages returns up to 100 results and a nextToken value, if applicable.
    public var maxResults: Swift.Int?
    /// The nextToken value returned from a previous paginated ListImages request where maxResults was used and the results exceeded the value of that parameter. Pagination continues from the end of the previous results that returned the nextToken value. This value is null when there are no more results to return. This token should be treated as an opaque identifier that is only used to retrieve the next items in a list and not for other programmatic purposes.
    public var nextToken: Swift.String?
    /// The Amazon Web Services account ID associated with the registry that contains the repository in which to list images. If you do not specify a registry, the default registry is assumed.
    public var registryId: Swift.String?
    /// The repository with image IDs to be listed.
    /// This member is required.
    public var repositoryName: Swift.String?

    public init(
        filter: ECRClientTypes.ListImagesFilter? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        registryId: Swift.String? = nil,
        repositoryName: Swift.String? = nil
    )
    {
        self.filter = filter
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.registryId = registryId
        self.repositoryName = repositoryName
    }
}

struct ListImagesInputBody: Swift.Equatable {
    let registryId: Swift.String?
    let repositoryName: Swift.String?
    let nextToken: Swift.String?
    let maxResults: Swift.Int?
    let filter: ECRClientTypes.ListImagesFilter?
}

extension ListImagesInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter
        case maxResults
        case nextToken
        case registryId
        case repositoryName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
        let maxResultsDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .maxResults)
        maxResults = maxResultsDecoded
        let filterDecoded = try containerValues.decodeIfPresent(ECRClientTypes.ListImagesFilter.self, forKey: .filter)
        filter = filterDecoded
    }
}

extension ListImagesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListImagesOutputBody = try responseDecoder.decode(responseBody: data)
            self.imageIds = output.imageIds
            self.nextToken = output.nextToken
        } else {
            self.imageIds = nil
            self.nextToken = nil
        }
    }
}

public struct ListImagesOutput: Swift.Equatable {
    /// The list of image IDs for the requested repository.
    public var imageIds: [ECRClientTypes.ImageIdentifier]?
    /// The nextToken value to include in a future ListImages request. When the results of a ListImages request exceed maxResults, this value can be used to retrieve the next page of results. This value is null when there are no more results to return.
    public var nextToken: Swift.String?

    public init(
        imageIds: [ECRClientTypes.ImageIdentifier]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.imageIds = imageIds
        self.nextToken = nextToken
    }
}

struct ListImagesOutputBody: Swift.Equatable {
    let imageIds: [ECRClientTypes.ImageIdentifier]?
    let nextToken: Swift.String?
}

extension ListImagesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imageIds
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imageIdsContainer = try containerValues.decodeIfPresent([ECRClientTypes.ImageIdentifier?].self, forKey: .imageIds)
        var imageIdsDecoded0:[ECRClientTypes.ImageIdentifier]? = nil
        if let imageIdsContainer = imageIdsContainer {
            imageIdsDecoded0 = [ECRClientTypes.ImageIdentifier]()
            for structure0 in imageIdsContainer {
                if let structure0 = structure0 {
                    imageIdsDecoded0?.append(structure0)
                }
            }
        }
        imageIds = imageIdsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListImagesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RepositoryNotFoundException": return try await RepositoryNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServerException": return try await ServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTagsForResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }
}

extension ListTagsForResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) that identifies the resource for which to list the tags. Currently, the only supported resource is an Amazon ECR repository.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
}

extension ListTagsForResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
    }
}

extension ListTagsForResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutput: Swift.Equatable {
    /// The tags for the resource.
    public var tags: [ECRClientTypes.Tag]?

    public init(
        tags: [ECRClientTypes.Tag]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputBody: Swift.Equatable {
    let tags: [ECRClientTypes.Tag]?
}

extension ListTagsForResourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([ECRClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ECRClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ECRClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum ListTagsForResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RepositoryNotFoundException": return try await RepositoryNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServerException": return try await ServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ECRClientTypes.PackageVulnerabilityDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cvss
        case referenceUrls
        case relatedVulnerabilities
        case source
        case sourceUrl
        case vendorCreatedAt
        case vendorSeverity
        case vendorUpdatedAt
        case vulnerabilityId
        case vulnerablePackages
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cvss = cvss {
            var cvssContainer = encodeContainer.nestedUnkeyedContainer(forKey: .cvss)
            for cvssscore0 in cvss {
                try cvssContainer.encode(cvssscore0)
            }
        }
        if let referenceUrls = referenceUrls {
            var referenceUrlsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .referenceUrls)
            for url0 in referenceUrls {
                try referenceUrlsContainer.encode(url0)
            }
        }
        if let relatedVulnerabilities = relatedVulnerabilities {
            var relatedVulnerabilitiesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .relatedVulnerabilities)
            for relatedvulnerability0 in relatedVulnerabilities {
                try relatedVulnerabilitiesContainer.encode(relatedvulnerability0)
            }
        }
        if let source = self.source {
            try encodeContainer.encode(source, forKey: .source)
        }
        if let sourceUrl = self.sourceUrl {
            try encodeContainer.encode(sourceUrl, forKey: .sourceUrl)
        }
        if let vendorCreatedAt = self.vendorCreatedAt {
            try encodeContainer.encodeTimestamp(vendorCreatedAt, format: .epochSeconds, forKey: .vendorCreatedAt)
        }
        if let vendorSeverity = self.vendorSeverity {
            try encodeContainer.encode(vendorSeverity, forKey: .vendorSeverity)
        }
        if let vendorUpdatedAt = self.vendorUpdatedAt {
            try encodeContainer.encodeTimestamp(vendorUpdatedAt, format: .epochSeconds, forKey: .vendorUpdatedAt)
        }
        if let vulnerabilityId = self.vulnerabilityId {
            try encodeContainer.encode(vulnerabilityId, forKey: .vulnerabilityId)
        }
        if let vulnerablePackages = vulnerablePackages {
            var vulnerablePackagesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .vulnerablePackages)
            for vulnerablepackage0 in vulnerablePackages {
                try vulnerablePackagesContainer.encode(vulnerablepackage0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cvssContainer = try containerValues.decodeIfPresent([ECRClientTypes.CvssScore?].self, forKey: .cvss)
        var cvssDecoded0:[ECRClientTypes.CvssScore]? = nil
        if let cvssContainer = cvssContainer {
            cvssDecoded0 = [ECRClientTypes.CvssScore]()
            for structure0 in cvssContainer {
                if let structure0 = structure0 {
                    cvssDecoded0?.append(structure0)
                }
            }
        }
        cvss = cvssDecoded0
        let referenceUrlsContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .referenceUrls)
        var referenceUrlsDecoded0:[Swift.String]? = nil
        if let referenceUrlsContainer = referenceUrlsContainer {
            referenceUrlsDecoded0 = [Swift.String]()
            for string0 in referenceUrlsContainer {
                if let string0 = string0 {
                    referenceUrlsDecoded0?.append(string0)
                }
            }
        }
        referenceUrls = referenceUrlsDecoded0
        let relatedVulnerabilitiesContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .relatedVulnerabilities)
        var relatedVulnerabilitiesDecoded0:[Swift.String]? = nil
        if let relatedVulnerabilitiesContainer = relatedVulnerabilitiesContainer {
            relatedVulnerabilitiesDecoded0 = [Swift.String]()
            for string0 in relatedVulnerabilitiesContainer {
                if let string0 = string0 {
                    relatedVulnerabilitiesDecoded0?.append(string0)
                }
            }
        }
        relatedVulnerabilities = relatedVulnerabilitiesDecoded0
        let sourceDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .source)
        source = sourceDecoded
        let sourceUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceUrl)
        sourceUrl = sourceUrlDecoded
        let vendorCreatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .vendorCreatedAt)
        vendorCreatedAt = vendorCreatedAtDecoded
        let vendorSeverityDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vendorSeverity)
        vendorSeverity = vendorSeverityDecoded
        let vendorUpdatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .vendorUpdatedAt)
        vendorUpdatedAt = vendorUpdatedAtDecoded
        let vulnerabilityIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .vulnerabilityId)
        vulnerabilityId = vulnerabilityIdDecoded
        let vulnerablePackagesContainer = try containerValues.decodeIfPresent([ECRClientTypes.VulnerablePackage?].self, forKey: .vulnerablePackages)
        var vulnerablePackagesDecoded0:[ECRClientTypes.VulnerablePackage]? = nil
        if let vulnerablePackagesContainer = vulnerablePackagesContainer {
            vulnerablePackagesDecoded0 = [ECRClientTypes.VulnerablePackage]()
            for structure0 in vulnerablePackagesContainer {
                if let structure0 = structure0 {
                    vulnerablePackagesDecoded0?.append(structure0)
                }
            }
        }
        vulnerablePackages = vulnerablePackagesDecoded0
    }
}

extension ECRClientTypes {
    /// Information about a package vulnerability finding.
    public struct PackageVulnerabilityDetails: Swift.Equatable {
        /// An object that contains details about the CVSS score of a finding.
        public var cvss: [ECRClientTypes.CvssScore]?
        /// One or more URLs that contain details about this vulnerability type.
        public var referenceUrls: [Swift.String]?
        /// One or more vulnerabilities related to the one identified in this finding.
        public var relatedVulnerabilities: [Swift.String]?
        /// The source of the vulnerability information.
        public var source: Swift.String?
        /// A URL to the source of the vulnerability information.
        public var sourceUrl: Swift.String?
        /// The date and time that this vulnerability was first added to the vendor's database.
        public var vendorCreatedAt: ClientRuntime.Date?
        /// The severity the vendor has given to this vulnerability type.
        public var vendorSeverity: Swift.String?
        /// The date and time the vendor last updated this vulnerability in their database.
        public var vendorUpdatedAt: ClientRuntime.Date?
        /// The ID given to this vulnerability.
        public var vulnerabilityId: Swift.String?
        /// The packages impacted by this vulnerability.
        public var vulnerablePackages: [ECRClientTypes.VulnerablePackage]?

        public init(
            cvss: [ECRClientTypes.CvssScore]? = nil,
            referenceUrls: [Swift.String]? = nil,
            relatedVulnerabilities: [Swift.String]? = nil,
            source: Swift.String? = nil,
            sourceUrl: Swift.String? = nil,
            vendorCreatedAt: ClientRuntime.Date? = nil,
            vendorSeverity: Swift.String? = nil,
            vendorUpdatedAt: ClientRuntime.Date? = nil,
            vulnerabilityId: Swift.String? = nil,
            vulnerablePackages: [ECRClientTypes.VulnerablePackage]? = nil
        )
        {
            self.cvss = cvss
            self.referenceUrls = referenceUrls
            self.relatedVulnerabilities = relatedVulnerabilities
            self.source = source
            self.sourceUrl = sourceUrl
            self.vendorCreatedAt = vendorCreatedAt
            self.vendorSeverity = vendorSeverity
            self.vendorUpdatedAt = vendorUpdatedAt
            self.vulnerabilityId = vulnerabilityId
            self.vulnerablePackages = vulnerablePackages
        }
    }

}

extension ECRClientTypes.PullThroughCacheRule: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt
        case ecrRepositoryPrefix
        case registryId
        case upstreamRegistryUrl
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let ecrRepositoryPrefix = self.ecrRepositoryPrefix {
            try encodeContainer.encode(ecrRepositoryPrefix, forKey: .ecrRepositoryPrefix)
        }
        if let registryId = self.registryId {
            try encodeContainer.encode(registryId, forKey: .registryId)
        }
        if let upstreamRegistryUrl = self.upstreamRegistryUrl {
            try encodeContainer.encode(upstreamRegistryUrl, forKey: .upstreamRegistryUrl)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let ecrRepositoryPrefixDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .ecrRepositoryPrefix)
        ecrRepositoryPrefix = ecrRepositoryPrefixDecoded
        let upstreamRegistryUrlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .upstreamRegistryUrl)
        upstreamRegistryUrl = upstreamRegistryUrlDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let registryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registryId)
        registryId = registryIdDecoded
    }
}

extension ECRClientTypes {
    /// The details of a pull through cache rule.
    public struct PullThroughCacheRule: Swift.Equatable {
        /// The date and time the pull through cache was created.
        public var createdAt: ClientRuntime.Date?
        /// The Amazon ECR repository prefix associated with the pull through cache rule.
        public var ecrRepositoryPrefix: Swift.String?
        /// The Amazon Web Services account ID associated with the registry the pull through cache rule is associated with.
        public var registryId: Swift.String?
        /// The upstream registry URL associated with the pull through cache rule.
        public var upstreamRegistryUrl: Swift.String?

        public init(
            createdAt: ClientRuntime.Date? = nil,
            ecrRepositoryPrefix: Swift.String? = nil,
            registryId: Swift.String? = nil,
            upstreamRegistryUrl: Swift.String? = nil
        )
        {
            self.createdAt = createdAt
            self.ecrRepositoryPrefix = ecrRepositoryPrefix
            self.registryId = registryId
            self.upstreamRegistryUrl = upstreamRegistryUrl
        }
    }

}

extension PullThroughCacheRuleAlreadyExistsException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: PullThroughCacheRuleAlreadyExistsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// A pull through cache rule with these settings already exists for the private registry.
public struct PullThroughCacheRuleAlreadyExistsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "PullThroughCacheRuleAlreadyExistsException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct PullThroughCacheRuleAlreadyExistsExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension PullThroughCacheRuleAlreadyExistsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension PullThroughCacheRuleNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: PullThroughCacheRuleNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The pull through cache rule was not found. Specify a valid pull through cache rule and try again.
public struct PullThroughCacheRuleNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "PullThroughCacheRuleNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct PullThroughCacheRuleNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension PullThroughCacheRuleNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension PutImageInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imageDigest
        case imageManifest
        case imageManifestMediaType
        case imageTag
        case registryId
        case repositoryName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let imageDigest = self.imageDigest {
            try encodeContainer.encode(imageDigest, forKey: .imageDigest)
        }
        if let imageManifest = self.imageManifest {
            try encodeContainer.encode(imageManifest, forKey: .imageManifest)
        }
        if let imageManifestMediaType = self.imageManifestMediaType {
            try encodeContainer.encode(imageManifestMediaType, forKey: .imageManifestMediaType)
        }
        if let imageTag = self.imageTag {
            try encodeContainer.encode(imageTag, forKey: .imageTag)
        }
        if let registryId = self.registryId {
            try encodeContainer.encode(registryId, forKey: .registryId)
        }
        if let repositoryName = self.repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }
}

extension PutImageInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct PutImageInput: Swift.Equatable {
    /// The image digest of the image manifest corresponding to the image.
    public var imageDigest: Swift.String?
    /// The image manifest corresponding to the image to be uploaded.
    /// This member is required.
    public var imageManifest: Swift.String?
    /// The media type of the image manifest. If you push an image manifest that does not contain the mediaType field, you must specify the imageManifestMediaType in the request.
    public var imageManifestMediaType: Swift.String?
    /// The tag to associate with the image. This parameter is required for images that use the Docker Image Manifest V2 Schema 2 or Open Container Initiative (OCI) formats.
    public var imageTag: Swift.String?
    /// The Amazon Web Services account ID associated with the registry that contains the repository in which to put the image. If you do not specify a registry, the default registry is assumed.
    public var registryId: Swift.String?
    /// The name of the repository in which to put the image.
    /// This member is required.
    public var repositoryName: Swift.String?

    public init(
        imageDigest: Swift.String? = nil,
        imageManifest: Swift.String? = nil,
        imageManifestMediaType: Swift.String? = nil,
        imageTag: Swift.String? = nil,
        registryId: Swift.String? = nil,
        repositoryName: Swift.String? = nil
    )
    {
        self.imageDigest = imageDigest
        self.imageManifest = imageManifest
        self.imageManifestMediaType = imageManifestMediaType
        self.imageTag = imageTag
        self.registryId = registryId
        self.repositoryName = repositoryName
    }
}

struct PutImageInputBody: Swift.Equatable {
    let registryId: Swift.String?
    let repositoryName: Swift.String?
    let imageManifest: Swift.String?
    let imageManifestMediaType: Swift.String?
    let imageTag: Swift.String?
    let imageDigest: Swift.String?
}

extension PutImageInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imageDigest
        case imageManifest
        case imageManifestMediaType
        case imageTag
        case registryId
        case repositoryName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let imageManifestDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageManifest)
        imageManifest = imageManifestDecoded
        let imageManifestMediaTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageManifestMediaType)
        imageManifestMediaType = imageManifestMediaTypeDecoded
        let imageTagDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageTag)
        imageTag = imageTagDecoded
        let imageDigestDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .imageDigest)
        imageDigest = imageDigestDecoded
    }
}

extension PutImageOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: PutImageOutputBody = try responseDecoder.decode(responseBody: data)
            self.image = output.image
        } else {
            self.image = nil
        }
    }
}

public struct PutImageOutput: Swift.Equatable {
    /// Details of the image uploaded.
    public var image: ECRClientTypes.Image?

    public init(
        image: ECRClientTypes.Image? = nil
    )
    {
        self.image = image
    }
}

struct PutImageOutputBody: Swift.Equatable {
    let image: ECRClientTypes.Image?
}

extension PutImageOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case image
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let imageDecoded = try containerValues.decodeIfPresent(ECRClientTypes.Image.self, forKey: .image)
        image = imageDecoded
    }
}

enum PutImageOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ImageAlreadyExistsException": return try await ImageAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ImageDigestDoesNotMatchException": return try await ImageDigestDoesNotMatchException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ImageTagAlreadyExistsException": return try await ImageTagAlreadyExistsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "KmsException": return try await KmsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LayersNotFoundException": return try await LayersNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ReferencedImagesNotFoundException": return try await ReferencedImagesNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RepositoryNotFoundException": return try await RepositoryNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServerException": return try await ServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension PutImageScanningConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imageScanningConfiguration
        case registryId
        case repositoryName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let imageScanningConfiguration = self.imageScanningConfiguration {
            try encodeContainer.encode(imageScanningConfiguration, forKey: .imageScanningConfiguration)
        }
        if let registryId = self.registryId {
            try encodeContainer.encode(registryId, forKey: .registryId)
        }
        if let repositoryName = self.repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }
}

extension PutImageScanningConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct PutImageScanningConfigurationInput: Swift.Equatable {
    /// The image scanning configuration for the repository. This setting determines whether images are scanned for known vulnerabilities after being pushed to the repository.
    /// This member is required.
    public var imageScanningConfiguration: ECRClientTypes.ImageScanningConfiguration?
    /// The Amazon Web Services account ID associated with the registry that contains the repository in which to update the image scanning configuration setting. If you do not specify a registry, the default registry is assumed.
    public var registryId: Swift.String?
    /// The name of the repository in which to update the image scanning configuration setting.
    /// This member is required.
    public var repositoryName: Swift.String?

    public init(
        imageScanningConfiguration: ECRClientTypes.ImageScanningConfiguration? = nil,
        registryId: Swift.String? = nil,
        repositoryName: Swift.String? = nil
    )
    {
        self.imageScanningConfiguration = imageScanningConfiguration
        self.registryId = registryId
        self.repositoryName = repositoryName
    }
}

struct PutImageScanningConfigurationInputBody: Swift.Equatable {
    let registryId: Swift.String?
    let repositoryName: Swift.String?
    let imageScanningConfiguration: ECRClientTypes.ImageScanningConfiguration?
}

extension PutImageScanningConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imageScanningConfiguration
        case registryId
        case repositoryName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let imageScanningConfigurationDecoded = try containerValues.decodeIfPresent(ECRClientTypes.ImageScanningConfiguration.self, forKey: .imageScanningConfiguration)
        imageScanningConfiguration = imageScanningConfigurationDecoded
    }
}

extension PutImageScanningConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: PutImageScanningConfigurationOutputBody = try responseDecoder.decode(responseBody: data)
            self.imageScanningConfiguration = output.imageScanningConfiguration
            self.registryId = output.registryId
            self.repositoryName = output.repositoryName
        } else {
            self.imageScanningConfiguration = nil
            self.registryId = nil
            self.repositoryName = nil
        }
    }
}

public struct PutImageScanningConfigurationOutput: Swift.Equatable {
    /// The image scanning configuration setting for the repository.
    public var imageScanningConfiguration: ECRClientTypes.ImageScanningConfiguration?
    /// The registry ID associated with the request.
    public var registryId: Swift.String?
    /// The repository name associated with the request.
    public var repositoryName: Swift.String?

    public init(
        imageScanningConfiguration: ECRClientTypes.ImageScanningConfiguration? = nil,
        registryId: Swift.String? = nil,
        repositoryName: Swift.String? = nil
    )
    {
        self.imageScanningConfiguration = imageScanningConfiguration
        self.registryId = registryId
        self.repositoryName = repositoryName
    }
}

struct PutImageScanningConfigurationOutputBody: Swift.Equatable {
    let registryId: Swift.String?
    let repositoryName: Swift.String?
    let imageScanningConfiguration: ECRClientTypes.ImageScanningConfiguration?
}

extension PutImageScanningConfigurationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imageScanningConfiguration
        case registryId
        case repositoryName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let imageScanningConfigurationDecoded = try containerValues.decodeIfPresent(ECRClientTypes.ImageScanningConfiguration.self, forKey: .imageScanningConfiguration)
        imageScanningConfiguration = imageScanningConfigurationDecoded
    }
}

enum PutImageScanningConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RepositoryNotFoundException": return try await RepositoryNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServerException": return try await ServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension PutImageTagMutabilityInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imageTagMutability
        case registryId
        case repositoryName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let imageTagMutability = self.imageTagMutability {
            try encodeContainer.encode(imageTagMutability.rawValue, forKey: .imageTagMutability)
        }
        if let registryId = self.registryId {
            try encodeContainer.encode(registryId, forKey: .registryId)
        }
        if let repositoryName = self.repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }
}

extension PutImageTagMutabilityInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct PutImageTagMutabilityInput: Swift.Equatable {
    /// The tag mutability setting for the repository. If MUTABLE is specified, image tags can be overwritten. If IMMUTABLE is specified, all image tags within the repository will be immutable which will prevent them from being overwritten.
    /// This member is required.
    public var imageTagMutability: ECRClientTypes.ImageTagMutability?
    /// The Amazon Web Services account ID associated with the registry that contains the repository in which to update the image tag mutability settings. If you do not specify a registry, the default registry is assumed.
    public var registryId: Swift.String?
    /// The name of the repository in which to update the image tag mutability settings.
    /// This member is required.
    public var repositoryName: Swift.String?

    public init(
        imageTagMutability: ECRClientTypes.ImageTagMutability? = nil,
        registryId: Swift.String? = nil,
        repositoryName: Swift.String? = nil
    )
    {
        self.imageTagMutability = imageTagMutability
        self.registryId = registryId
        self.repositoryName = repositoryName
    }
}

struct PutImageTagMutabilityInputBody: Swift.Equatable {
    let registryId: Swift.String?
    let repositoryName: Swift.String?
    let imageTagMutability: ECRClientTypes.ImageTagMutability?
}

extension PutImageTagMutabilityInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imageTagMutability
        case registryId
        case repositoryName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let imageTagMutabilityDecoded = try containerValues.decodeIfPresent(ECRClientTypes.ImageTagMutability.self, forKey: .imageTagMutability)
        imageTagMutability = imageTagMutabilityDecoded
    }
}

extension PutImageTagMutabilityOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: PutImageTagMutabilityOutputBody = try responseDecoder.decode(responseBody: data)
            self.imageTagMutability = output.imageTagMutability
            self.registryId = output.registryId
            self.repositoryName = output.repositoryName
        } else {
            self.imageTagMutability = nil
            self.registryId = nil
            self.repositoryName = nil
        }
    }
}

public struct PutImageTagMutabilityOutput: Swift.Equatable {
    /// The image tag mutability setting for the repository.
    public var imageTagMutability: ECRClientTypes.ImageTagMutability?
    /// The registry ID associated with the request.
    public var registryId: Swift.String?
    /// The repository name associated with the request.
    public var repositoryName: Swift.String?

    public init(
        imageTagMutability: ECRClientTypes.ImageTagMutability? = nil,
        registryId: Swift.String? = nil,
        repositoryName: Swift.String? = nil
    )
    {
        self.imageTagMutability = imageTagMutability
        self.registryId = registryId
        self.repositoryName = repositoryName
    }
}

struct PutImageTagMutabilityOutputBody: Swift.Equatable {
    let registryId: Swift.String?
    let repositoryName: Swift.String?
    let imageTagMutability: ECRClientTypes.ImageTagMutability?
}

extension PutImageTagMutabilityOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imageTagMutability
        case registryId
        case repositoryName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let imageTagMutabilityDecoded = try containerValues.decodeIfPresent(ECRClientTypes.ImageTagMutability.self, forKey: .imageTagMutability)
        imageTagMutability = imageTagMutabilityDecoded
    }
}

enum PutImageTagMutabilityOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RepositoryNotFoundException": return try await RepositoryNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServerException": return try await ServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension PutLifecyclePolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lifecyclePolicyText
        case registryId
        case repositoryName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lifecyclePolicyText = self.lifecyclePolicyText {
            try encodeContainer.encode(lifecyclePolicyText, forKey: .lifecyclePolicyText)
        }
        if let registryId = self.registryId {
            try encodeContainer.encode(registryId, forKey: .registryId)
        }
        if let repositoryName = self.repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }
}

extension PutLifecyclePolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct PutLifecyclePolicyInput: Swift.Equatable {
    /// The JSON repository policy text to apply to the repository.
    /// This member is required.
    public var lifecyclePolicyText: Swift.String?
    /// The Amazon Web Services account ID associated with the registry that contains the repository. If you do not specify a registry, the default registry is assumed.
    public var registryId: Swift.String?
    /// The name of the repository to receive the policy.
    /// This member is required.
    public var repositoryName: Swift.String?

    public init(
        lifecyclePolicyText: Swift.String? = nil,
        registryId: Swift.String? = nil,
        repositoryName: Swift.String? = nil
    )
    {
        self.lifecyclePolicyText = lifecyclePolicyText
        self.registryId = registryId
        self.repositoryName = repositoryName
    }
}

struct PutLifecyclePolicyInputBody: Swift.Equatable {
    let registryId: Swift.String?
    let repositoryName: Swift.String?
    let lifecyclePolicyText: Swift.String?
}

extension PutLifecyclePolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lifecyclePolicyText
        case registryId
        case repositoryName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let lifecyclePolicyTextDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lifecyclePolicyText)
        lifecyclePolicyText = lifecyclePolicyTextDecoded
    }
}

extension PutLifecyclePolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: PutLifecyclePolicyOutputBody = try responseDecoder.decode(responseBody: data)
            self.lifecyclePolicyText = output.lifecyclePolicyText
            self.registryId = output.registryId
            self.repositoryName = output.repositoryName
        } else {
            self.lifecyclePolicyText = nil
            self.registryId = nil
            self.repositoryName = nil
        }
    }
}

public struct PutLifecyclePolicyOutput: Swift.Equatable {
    /// The JSON repository policy text.
    public var lifecyclePolicyText: Swift.String?
    /// The registry ID associated with the request.
    public var registryId: Swift.String?
    /// The repository name associated with the request.
    public var repositoryName: Swift.String?

    public init(
        lifecyclePolicyText: Swift.String? = nil,
        registryId: Swift.String? = nil,
        repositoryName: Swift.String? = nil
    )
    {
        self.lifecyclePolicyText = lifecyclePolicyText
        self.registryId = registryId
        self.repositoryName = repositoryName
    }
}

struct PutLifecyclePolicyOutputBody: Swift.Equatable {
    let registryId: Swift.String?
    let repositoryName: Swift.String?
    let lifecyclePolicyText: Swift.String?
}

extension PutLifecyclePolicyOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lifecyclePolicyText
        case registryId
        case repositoryName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let lifecyclePolicyTextDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lifecyclePolicyText)
        lifecyclePolicyText = lifecyclePolicyTextDecoded
    }
}

enum PutLifecyclePolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RepositoryNotFoundException": return try await RepositoryNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServerException": return try await ServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension PutRegistryPolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policyText
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let policyText = self.policyText {
            try encodeContainer.encode(policyText, forKey: .policyText)
        }
    }
}

extension PutRegistryPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct PutRegistryPolicyInput: Swift.Equatable {
    /// The JSON policy text to apply to your registry. The policy text follows the same format as IAM policy text. For more information, see [Registry permissions](https://docs.aws.amazon.com/AmazonECR/latest/userguide/registry-permissions.html) in the Amazon Elastic Container Registry User Guide.
    /// This member is required.
    public var policyText: Swift.String?

    public init(
        policyText: Swift.String? = nil
    )
    {
        self.policyText = policyText
    }
}

struct PutRegistryPolicyInputBody: Swift.Equatable {
    let policyText: Swift.String?
}

extension PutRegistryPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policyText
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let policyTextDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyText)
        policyText = policyTextDecoded
    }
}

extension PutRegistryPolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: PutRegistryPolicyOutputBody = try responseDecoder.decode(responseBody: data)
            self.policyText = output.policyText
            self.registryId = output.registryId
        } else {
            self.policyText = nil
            self.registryId = nil
        }
    }
}

public struct PutRegistryPolicyOutput: Swift.Equatable {
    /// The JSON policy text for your registry.
    public var policyText: Swift.String?
    /// The registry ID.
    public var registryId: Swift.String?

    public init(
        policyText: Swift.String? = nil,
        registryId: Swift.String? = nil
    )
    {
        self.policyText = policyText
        self.registryId = registryId
    }
}

struct PutRegistryPolicyOutputBody: Swift.Equatable {
    let registryId: Swift.String?
    let policyText: Swift.String?
}

extension PutRegistryPolicyOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policyText
        case registryId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let policyTextDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyText)
        policyText = policyTextDecoded
    }
}

enum PutRegistryPolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServerException": return try await ServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension PutRegistryScanningConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case rules
        case scanType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let rules = rules {
            var rulesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .rules)
            for registryscanningrule0 in rules {
                try rulesContainer.encode(registryscanningrule0)
            }
        }
        if let scanType = self.scanType {
            try encodeContainer.encode(scanType.rawValue, forKey: .scanType)
        }
    }
}

extension PutRegistryScanningConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct PutRegistryScanningConfigurationInput: Swift.Equatable {
    /// The scanning rules to use for the registry. A scanning rule is used to determine which repository filters are used and at what frequency scanning will occur.
    public var rules: [ECRClientTypes.RegistryScanningRule]?
    /// The scanning type to set for the registry. When a registry scanning configuration is not defined, by default the BASIC scan type is used. When basic scanning is used, you may specify filters to determine which individual repositories, or all repositories, are scanned when new images are pushed to those repositories. Alternatively, you can do manual scans of images with basic scanning. When the ENHANCED scan type is set, Amazon Inspector provides automated vulnerability scanning. You may choose between continuous scanning or scan on push and you may specify filters to determine which individual repositories, or all repositories, are scanned.
    public var scanType: ECRClientTypes.ScanType?

    public init(
        rules: [ECRClientTypes.RegistryScanningRule]? = nil,
        scanType: ECRClientTypes.ScanType? = nil
    )
    {
        self.rules = rules
        self.scanType = scanType
    }
}

struct PutRegistryScanningConfigurationInputBody: Swift.Equatable {
    let scanType: ECRClientTypes.ScanType?
    let rules: [ECRClientTypes.RegistryScanningRule]?
}

extension PutRegistryScanningConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case rules
        case scanType
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scanTypeDecoded = try containerValues.decodeIfPresent(ECRClientTypes.ScanType.self, forKey: .scanType)
        scanType = scanTypeDecoded
        let rulesContainer = try containerValues.decodeIfPresent([ECRClientTypes.RegistryScanningRule?].self, forKey: .rules)
        var rulesDecoded0:[ECRClientTypes.RegistryScanningRule]? = nil
        if let rulesContainer = rulesContainer {
            rulesDecoded0 = [ECRClientTypes.RegistryScanningRule]()
            for structure0 in rulesContainer {
                if let structure0 = structure0 {
                    rulesDecoded0?.append(structure0)
                }
            }
        }
        rules = rulesDecoded0
    }
}

extension PutRegistryScanningConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: PutRegistryScanningConfigurationOutputBody = try responseDecoder.decode(responseBody: data)
            self.registryScanningConfiguration = output.registryScanningConfiguration
        } else {
            self.registryScanningConfiguration = nil
        }
    }
}

public struct PutRegistryScanningConfigurationOutput: Swift.Equatable {
    /// The scanning configuration for your registry.
    public var registryScanningConfiguration: ECRClientTypes.RegistryScanningConfiguration?

    public init(
        registryScanningConfiguration: ECRClientTypes.RegistryScanningConfiguration? = nil
    )
    {
        self.registryScanningConfiguration = registryScanningConfiguration
    }
}

struct PutRegistryScanningConfigurationOutputBody: Swift.Equatable {
    let registryScanningConfiguration: ECRClientTypes.RegistryScanningConfiguration?
}

extension PutRegistryScanningConfigurationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case registryScanningConfiguration
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryScanningConfigurationDecoded = try containerValues.decodeIfPresent(ECRClientTypes.RegistryScanningConfiguration.self, forKey: .registryScanningConfiguration)
        registryScanningConfiguration = registryScanningConfigurationDecoded
    }
}

enum PutRegistryScanningConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServerException": return try await ServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension PutReplicationConfigurationInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case replicationConfiguration
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let replicationConfiguration = self.replicationConfiguration {
            try encodeContainer.encode(replicationConfiguration, forKey: .replicationConfiguration)
        }
    }
}

extension PutReplicationConfigurationInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct PutReplicationConfigurationInput: Swift.Equatable {
    /// An object representing the replication configuration for a registry.
    /// This member is required.
    public var replicationConfiguration: ECRClientTypes.ReplicationConfiguration?

    public init(
        replicationConfiguration: ECRClientTypes.ReplicationConfiguration? = nil
    )
    {
        self.replicationConfiguration = replicationConfiguration
    }
}

struct PutReplicationConfigurationInputBody: Swift.Equatable {
    let replicationConfiguration: ECRClientTypes.ReplicationConfiguration?
}

extension PutReplicationConfigurationInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case replicationConfiguration
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationConfigurationDecoded = try containerValues.decodeIfPresent(ECRClientTypes.ReplicationConfiguration.self, forKey: .replicationConfiguration)
        replicationConfiguration = replicationConfigurationDecoded
    }
}

extension PutReplicationConfigurationOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: PutReplicationConfigurationOutputBody = try responseDecoder.decode(responseBody: data)
            self.replicationConfiguration = output.replicationConfiguration
        } else {
            self.replicationConfiguration = nil
        }
    }
}

public struct PutReplicationConfigurationOutput: Swift.Equatable {
    /// The contents of the replication configuration for the registry.
    public var replicationConfiguration: ECRClientTypes.ReplicationConfiguration?

    public init(
        replicationConfiguration: ECRClientTypes.ReplicationConfiguration? = nil
    )
    {
        self.replicationConfiguration = replicationConfiguration
    }
}

struct PutReplicationConfigurationOutputBody: Swift.Equatable {
    let replicationConfiguration: ECRClientTypes.ReplicationConfiguration?
}

extension PutReplicationConfigurationOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case replicationConfiguration
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let replicationConfigurationDecoded = try containerValues.decodeIfPresent(ECRClientTypes.ReplicationConfiguration.self, forKey: .replicationConfiguration)
        replicationConfiguration = replicationConfigurationDecoded
    }
}

enum PutReplicationConfigurationOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServerException": return try await ServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ECRClientTypes.Recommendation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case text
        case url
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let text = self.text {
            try encodeContainer.encode(text, forKey: .text)
        }
        if let url = self.url {
            try encodeContainer.encode(url, forKey: .url)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let urlDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .url)
        url = urlDecoded
        let textDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .text)
        text = textDecoded
    }
}

extension ECRClientTypes {
    /// Details about the recommended course of action to remediate the finding.
    public struct Recommendation: Swift.Equatable {
        /// The recommended course of action to remediate the finding.
        public var text: Swift.String?
        /// The URL address to the CVE remediation recommendations.
        public var url: Swift.String?

        public init(
            text: Swift.String? = nil,
            url: Swift.String? = nil
        )
        {
            self.text = text
            self.url = url
        }
    }

}

extension ReferencedImagesNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ReferencedImagesNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The manifest list is referencing an image that does not exist.
public struct ReferencedImagesNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ReferencedImagesNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ReferencedImagesNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ReferencedImagesNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RegistryPolicyNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: RegistryPolicyNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The registry doesn't have an associated registry policy.
public struct RegistryPolicyNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "RegistryPolicyNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct RegistryPolicyNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension RegistryPolicyNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ECRClientTypes.RegistryScanningConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case rules
        case scanType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let rules = rules {
            var rulesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .rules)
            for registryscanningrule0 in rules {
                try rulesContainer.encode(registryscanningrule0)
            }
        }
        if let scanType = self.scanType {
            try encodeContainer.encode(scanType.rawValue, forKey: .scanType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scanTypeDecoded = try containerValues.decodeIfPresent(ECRClientTypes.ScanType.self, forKey: .scanType)
        scanType = scanTypeDecoded
        let rulesContainer = try containerValues.decodeIfPresent([ECRClientTypes.RegistryScanningRule?].self, forKey: .rules)
        var rulesDecoded0:[ECRClientTypes.RegistryScanningRule]? = nil
        if let rulesContainer = rulesContainer {
            rulesDecoded0 = [ECRClientTypes.RegistryScanningRule]()
            for structure0 in rulesContainer {
                if let structure0 = structure0 {
                    rulesDecoded0?.append(structure0)
                }
            }
        }
        rules = rulesDecoded0
    }
}

extension ECRClientTypes {
    /// The scanning configuration for a private registry.
    public struct RegistryScanningConfiguration: Swift.Equatable {
        /// The scanning rules associated with the registry.
        public var rules: [ECRClientTypes.RegistryScanningRule]?
        /// The type of scanning configured for the registry.
        public var scanType: ECRClientTypes.ScanType?

        public init(
            rules: [ECRClientTypes.RegistryScanningRule]? = nil,
            scanType: ECRClientTypes.ScanType? = nil
        )
        {
            self.rules = rules
            self.scanType = scanType
        }
    }

}

extension ECRClientTypes.RegistryScanningRule: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case repositoryFilters
        case scanFrequency
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let repositoryFilters = repositoryFilters {
            var repositoryFiltersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .repositoryFilters)
            for scanningrepositoryfilter0 in repositoryFilters {
                try repositoryFiltersContainer.encode(scanningrepositoryfilter0)
            }
        }
        if let scanFrequency = self.scanFrequency {
            try encodeContainer.encode(scanFrequency.rawValue, forKey: .scanFrequency)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let scanFrequencyDecoded = try containerValues.decodeIfPresent(ECRClientTypes.ScanFrequency.self, forKey: .scanFrequency)
        scanFrequency = scanFrequencyDecoded
        let repositoryFiltersContainer = try containerValues.decodeIfPresent([ECRClientTypes.ScanningRepositoryFilter?].self, forKey: .repositoryFilters)
        var repositoryFiltersDecoded0:[ECRClientTypes.ScanningRepositoryFilter]? = nil
        if let repositoryFiltersContainer = repositoryFiltersContainer {
            repositoryFiltersDecoded0 = [ECRClientTypes.ScanningRepositoryFilter]()
            for structure0 in repositoryFiltersContainer {
                if let structure0 = structure0 {
                    repositoryFiltersDecoded0?.append(structure0)
                }
            }
        }
        repositoryFilters = repositoryFiltersDecoded0
    }
}

extension ECRClientTypes {
    /// The details of a scanning rule for a private registry.
    public struct RegistryScanningRule: Swift.Equatable {
        /// The repository filters associated with the scanning configuration for a private registry.
        /// This member is required.
        public var repositoryFilters: [ECRClientTypes.ScanningRepositoryFilter]?
        /// The frequency that scans are performed at for a private registry. When the ENHANCED scan type is specified, the supported scan frequencies are CONTINUOUS_SCAN and SCAN_ON_PUSH. When the BASIC scan type is specified, the SCAN_ON_PUSH scan frequency is supported. If scan on push is not specified, then the MANUAL scan frequency is set by default.
        /// This member is required.
        public var scanFrequency: ECRClientTypes.ScanFrequency?

        public init(
            repositoryFilters: [ECRClientTypes.ScanningRepositoryFilter]? = nil,
            scanFrequency: ECRClientTypes.ScanFrequency? = nil
        )
        {
            self.repositoryFilters = repositoryFilters
            self.scanFrequency = scanFrequency
        }
    }

}

extension ECRClientTypes.Remediation: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case recommendation
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let recommendation = self.recommendation {
            try encodeContainer.encode(recommendation, forKey: .recommendation)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let recommendationDecoded = try containerValues.decodeIfPresent(ECRClientTypes.Recommendation.self, forKey: .recommendation)
        recommendation = recommendationDecoded
    }
}

extension ECRClientTypes {
    /// Information on how to remediate a finding.
    public struct Remediation: Swift.Equatable {
        /// An object that contains information about the recommended course of action to remediate the finding.
        public var recommendation: ECRClientTypes.Recommendation?

        public init(
            recommendation: ECRClientTypes.Recommendation? = nil
        )
        {
            self.recommendation = recommendation
        }
    }

}

extension ECRClientTypes.ReplicationConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case rules
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let rules = rules {
            var rulesContainer = encodeContainer.nestedUnkeyedContainer(forKey: .rules)
            for replicationrule0 in rules {
                try rulesContainer.encode(replicationrule0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let rulesContainer = try containerValues.decodeIfPresent([ECRClientTypes.ReplicationRule?].self, forKey: .rules)
        var rulesDecoded0:[ECRClientTypes.ReplicationRule]? = nil
        if let rulesContainer = rulesContainer {
            rulesDecoded0 = [ECRClientTypes.ReplicationRule]()
            for structure0 in rulesContainer {
                if let structure0 = structure0 {
                    rulesDecoded0?.append(structure0)
                }
            }
        }
        rules = rulesDecoded0
    }
}

extension ECRClientTypes {
    /// The replication configuration for a registry.
    public struct ReplicationConfiguration: Swift.Equatable {
        /// An array of objects representing the replication destinations and repository filters for a replication configuration.
        /// This member is required.
        public var rules: [ECRClientTypes.ReplicationRule]?

        public init(
            rules: [ECRClientTypes.ReplicationRule]? = nil
        )
        {
            self.rules = rules
        }
    }

}

extension ECRClientTypes.ReplicationDestination: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case region
        case registryId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let region = self.region {
            try encodeContainer.encode(region, forKey: .region)
        }
        if let registryId = self.registryId {
            try encodeContainer.encode(registryId, forKey: .registryId)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let regionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .region)
        region = regionDecoded
        let registryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registryId)
        registryId = registryIdDecoded
    }
}

extension ECRClientTypes {
    /// An array of objects representing the destination for a replication rule.
    public struct ReplicationDestination: Swift.Equatable {
        /// The Region to replicate to.
        /// This member is required.
        public var region: Swift.String?
        /// The Amazon Web Services account ID of the Amazon ECR private registry to replicate to. When configuring cross-Region replication within your own registry, specify your own account ID.
        /// This member is required.
        public var registryId: Swift.String?

        public init(
            region: Swift.String? = nil,
            registryId: Swift.String? = nil
        )
        {
            self.region = region
            self.registryId = registryId
        }
    }

}

extension ECRClientTypes.ReplicationRule: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case destinations
        case repositoryFilters
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let destinations = destinations {
            var destinationsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .destinations)
            for replicationdestination0 in destinations {
                try destinationsContainer.encode(replicationdestination0)
            }
        }
        if let repositoryFilters = repositoryFilters {
            var repositoryFiltersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .repositoryFilters)
            for repositoryfilter0 in repositoryFilters {
                try repositoryFiltersContainer.encode(repositoryfilter0)
            }
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let destinationsContainer = try containerValues.decodeIfPresent([ECRClientTypes.ReplicationDestination?].self, forKey: .destinations)
        var destinationsDecoded0:[ECRClientTypes.ReplicationDestination]? = nil
        if let destinationsContainer = destinationsContainer {
            destinationsDecoded0 = [ECRClientTypes.ReplicationDestination]()
            for structure0 in destinationsContainer {
                if let structure0 = structure0 {
                    destinationsDecoded0?.append(structure0)
                }
            }
        }
        destinations = destinationsDecoded0
        let repositoryFiltersContainer = try containerValues.decodeIfPresent([ECRClientTypes.RepositoryFilter?].self, forKey: .repositoryFilters)
        var repositoryFiltersDecoded0:[ECRClientTypes.RepositoryFilter]? = nil
        if let repositoryFiltersContainer = repositoryFiltersContainer {
            repositoryFiltersDecoded0 = [ECRClientTypes.RepositoryFilter]()
            for structure0 in repositoryFiltersContainer {
                if let structure0 = structure0 {
                    repositoryFiltersDecoded0?.append(structure0)
                }
            }
        }
        repositoryFilters = repositoryFiltersDecoded0
    }
}

extension ECRClientTypes {
    /// An array of objects representing the replication destinations and repository filters for a replication configuration.
    public struct ReplicationRule: Swift.Equatable {
        /// An array of objects representing the destination for a replication rule.
        /// This member is required.
        public var destinations: [ECRClientTypes.ReplicationDestination]?
        /// An array of objects representing the filters for a replication rule. Specifying a repository filter for a replication rule provides a method for controlling which repositories in a private registry are replicated.
        public var repositoryFilters: [ECRClientTypes.RepositoryFilter]?

        public init(
            destinations: [ECRClientTypes.ReplicationDestination]? = nil,
            repositoryFilters: [ECRClientTypes.RepositoryFilter]? = nil
        )
        {
            self.destinations = destinations
            self.repositoryFilters = repositoryFilters
        }
    }

}

extension ECRClientTypes {
    public enum ReplicationStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case complete
        case failed
        case inProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [ReplicationStatus] {
            return [
                .complete,
                .failed,
                .inProgress,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .complete: return "COMPLETE"
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ReplicationStatus(rawValue: rawValue) ?? ReplicationStatus.sdkUnknown(rawValue)
        }
    }
}

extension ECRClientTypes.Repository: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case createdAt
        case encryptionConfiguration
        case imageScanningConfiguration
        case imageTagMutability
        case registryId
        case repositoryArn
        case repositoryName
        case repositoryUri
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let encryptionConfiguration = self.encryptionConfiguration {
            try encodeContainer.encode(encryptionConfiguration, forKey: .encryptionConfiguration)
        }
        if let imageScanningConfiguration = self.imageScanningConfiguration {
            try encodeContainer.encode(imageScanningConfiguration, forKey: .imageScanningConfiguration)
        }
        if let imageTagMutability = self.imageTagMutability {
            try encodeContainer.encode(imageTagMutability.rawValue, forKey: .imageTagMutability)
        }
        if let registryId = self.registryId {
            try encodeContainer.encode(registryId, forKey: .registryId)
        }
        if let repositoryArn = self.repositoryArn {
            try encodeContainer.encode(repositoryArn, forKey: .repositoryArn)
        }
        if let repositoryName = self.repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
        if let repositoryUri = self.repositoryUri {
            try encodeContainer.encode(repositoryUri, forKey: .repositoryUri)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryArn)
        repositoryArn = repositoryArnDecoded
        let registryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let repositoryUriDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryUri)
        repositoryUri = repositoryUriDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let imageTagMutabilityDecoded = try containerValues.decodeIfPresent(ECRClientTypes.ImageTagMutability.self, forKey: .imageTagMutability)
        imageTagMutability = imageTagMutabilityDecoded
        let imageScanningConfigurationDecoded = try containerValues.decodeIfPresent(ECRClientTypes.ImageScanningConfiguration.self, forKey: .imageScanningConfiguration)
        imageScanningConfiguration = imageScanningConfigurationDecoded
        let encryptionConfigurationDecoded = try containerValues.decodeIfPresent(ECRClientTypes.EncryptionConfiguration.self, forKey: .encryptionConfiguration)
        encryptionConfiguration = encryptionConfigurationDecoded
    }
}

extension ECRClientTypes {
    /// An object representing a repository.
    public struct Repository: Swift.Equatable {
        /// The date and time, in JavaScript date format, when the repository was created.
        public var createdAt: ClientRuntime.Date?
        /// The encryption configuration for the repository. This determines how the contents of your repository are encrypted at rest.
        public var encryptionConfiguration: ECRClientTypes.EncryptionConfiguration?
        /// The image scanning configuration for a repository.
        public var imageScanningConfiguration: ECRClientTypes.ImageScanningConfiguration?
        /// The tag mutability setting for the repository.
        public var imageTagMutability: ECRClientTypes.ImageTagMutability?
        /// The Amazon Web Services account ID associated with the registry that contains the repository.
        public var registryId: Swift.String?
        /// The Amazon Resource Name (ARN) that identifies the repository. The ARN contains the arn:aws:ecr namespace, followed by the region of the repository, Amazon Web Services account ID of the repository owner, repository namespace, and repository name. For example, arn:aws:ecr:region:012345678910:repository-namespace/repository-name.
        public var repositoryArn: Swift.String?
        /// The name of the repository.
        public var repositoryName: Swift.String?
        /// The URI for the repository. You can use this URI for container image push and pull operations.
        public var repositoryUri: Swift.String?

        public init(
            createdAt: ClientRuntime.Date? = nil,
            encryptionConfiguration: ECRClientTypes.EncryptionConfiguration? = nil,
            imageScanningConfiguration: ECRClientTypes.ImageScanningConfiguration? = nil,
            imageTagMutability: ECRClientTypes.ImageTagMutability? = nil,
            registryId: Swift.String? = nil,
            repositoryArn: Swift.String? = nil,
            repositoryName: Swift.String? = nil,
            repositoryUri: Swift.String? = nil
        )
        {
            self.createdAt = createdAt
            self.encryptionConfiguration = encryptionConfiguration
            self.imageScanningConfiguration = imageScanningConfiguration
            self.imageTagMutability = imageTagMutability
            self.registryId = registryId
            self.repositoryArn = repositoryArn
            self.repositoryName = repositoryName
            self.repositoryUri = repositoryUri
        }
    }

}

extension RepositoryAlreadyExistsException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: RepositoryAlreadyExistsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The specified repository already exists in the specified registry.
public struct RepositoryAlreadyExistsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The error message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "RepositoryAlreadyExistsException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct RepositoryAlreadyExistsExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension RepositoryAlreadyExistsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ECRClientTypes.RepositoryFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter
        case filterType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filter = self.filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
        if let filterType = self.filterType {
            try encodeContainer.encode(filterType.rawValue, forKey: .filterType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filterDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .filter)
        filter = filterDecoded
        let filterTypeDecoded = try containerValues.decodeIfPresent(ECRClientTypes.RepositoryFilterType.self, forKey: .filterType)
        filterType = filterTypeDecoded
    }
}

extension ECRClientTypes {
    /// The filter settings used with image replication. Specifying a repository filter to a replication rule provides a method for controlling which repositories in a private registry are replicated. If no filters are added, the contents of all repositories are replicated.
    public struct RepositoryFilter: Swift.Equatable {
        /// The repository filter details. When the PREFIX_MATCH filter type is specified, this value is required and should be the repository name prefix to configure replication for.
        /// This member is required.
        public var filter: Swift.String?
        /// The repository filter type. The only supported value is PREFIX_MATCH, which is a repository name prefix specified with the filter parameter.
        /// This member is required.
        public var filterType: ECRClientTypes.RepositoryFilterType?

        public init(
            filter: Swift.String? = nil,
            filterType: ECRClientTypes.RepositoryFilterType? = nil
        )
        {
            self.filter = filter
            self.filterType = filterType
        }
    }

}

extension ECRClientTypes {
    public enum RepositoryFilterType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case prefixMatch
        case sdkUnknown(Swift.String)

        public static var allCases: [RepositoryFilterType] {
            return [
                .prefixMatch,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .prefixMatch: return "PREFIX_MATCH"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = RepositoryFilterType(rawValue: rawValue) ?? RepositoryFilterType.sdkUnknown(rawValue)
        }
    }
}

extension RepositoryNotEmptyException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: RepositoryNotEmptyExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The specified repository contains images. To delete a repository that contains images, you must force the deletion with the force parameter.
public struct RepositoryNotEmptyException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The error message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "RepositoryNotEmptyException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct RepositoryNotEmptyExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension RepositoryNotEmptyExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RepositoryNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: RepositoryNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The specified repository could not be found. Check the spelling of the specified repository and ensure that you are performing operations on the correct registry.
public struct RepositoryNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The error message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "RepositoryNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct RepositoryNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension RepositoryNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension RepositoryPolicyNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: RepositoryPolicyNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The specified repository and registry combination does not have an associated repository policy.
public struct RepositoryPolicyNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The error message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "RepositoryPolicyNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct RepositoryPolicyNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension RepositoryPolicyNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ECRClientTypes.RepositoryScanningConfiguration: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case appliedScanFilters
        case repositoryArn
        case repositoryName
        case scanFrequency
        case scanOnPush
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let appliedScanFilters = appliedScanFilters {
            var appliedScanFiltersContainer = encodeContainer.nestedUnkeyedContainer(forKey: .appliedScanFilters)
            for scanningrepositoryfilter0 in appliedScanFilters {
                try appliedScanFiltersContainer.encode(scanningrepositoryfilter0)
            }
        }
        if let repositoryArn = self.repositoryArn {
            try encodeContainer.encode(repositoryArn, forKey: .repositoryArn)
        }
        if let repositoryName = self.repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
        if let scanFrequency = self.scanFrequency {
            try encodeContainer.encode(scanFrequency.rawValue, forKey: .scanFrequency)
        }
        if scanOnPush != false {
            try encodeContainer.encode(scanOnPush, forKey: .scanOnPush)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryArn)
        repositoryArn = repositoryArnDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let scanOnPushDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .scanOnPush) ?? false
        scanOnPush = scanOnPushDecoded
        let scanFrequencyDecoded = try containerValues.decodeIfPresent(ECRClientTypes.ScanFrequency.self, forKey: .scanFrequency)
        scanFrequency = scanFrequencyDecoded
        let appliedScanFiltersContainer = try containerValues.decodeIfPresent([ECRClientTypes.ScanningRepositoryFilter?].self, forKey: .appliedScanFilters)
        var appliedScanFiltersDecoded0:[ECRClientTypes.ScanningRepositoryFilter]? = nil
        if let appliedScanFiltersContainer = appliedScanFiltersContainer {
            appliedScanFiltersDecoded0 = [ECRClientTypes.ScanningRepositoryFilter]()
            for structure0 in appliedScanFiltersContainer {
                if let structure0 = structure0 {
                    appliedScanFiltersDecoded0?.append(structure0)
                }
            }
        }
        appliedScanFilters = appliedScanFiltersDecoded0
    }
}

extension ECRClientTypes {
    /// The details of the scanning configuration for a repository.
    public struct RepositoryScanningConfiguration: Swift.Equatable {
        /// The scan filters applied to the repository.
        public var appliedScanFilters: [ECRClientTypes.ScanningRepositoryFilter]?
        /// The ARN of the repository.
        public var repositoryArn: Swift.String?
        /// The name of the repository.
        public var repositoryName: Swift.String?
        /// The scan frequency for the repository.
        public var scanFrequency: ECRClientTypes.ScanFrequency?
        /// Whether or not scan on push is configured for the repository.
        public var scanOnPush: Swift.Bool

        public init(
            appliedScanFilters: [ECRClientTypes.ScanningRepositoryFilter]? = nil,
            repositoryArn: Swift.String? = nil,
            repositoryName: Swift.String? = nil,
            scanFrequency: ECRClientTypes.ScanFrequency? = nil,
            scanOnPush: Swift.Bool = false
        )
        {
            self.appliedScanFilters = appliedScanFilters
            self.repositoryArn = repositoryArn
            self.repositoryName = repositoryName
            self.scanFrequency = scanFrequency
            self.scanOnPush = scanOnPush
        }
    }

}

extension ECRClientTypes.RepositoryScanningConfigurationFailure: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case failureCode
        case failureReason
        case repositoryName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let failureCode = self.failureCode {
            try encodeContainer.encode(failureCode.rawValue, forKey: .failureCode)
        }
        if let failureReason = self.failureReason {
            try encodeContainer.encode(failureReason, forKey: .failureReason)
        }
        if let repositoryName = self.repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let failureCodeDecoded = try containerValues.decodeIfPresent(ECRClientTypes.ScanningConfigurationFailureCode.self, forKey: .failureCode)
        failureCode = failureCodeDecoded
        let failureReasonDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .failureReason)
        failureReason = failureReasonDecoded
    }
}

extension ECRClientTypes {
    /// The details about any failures associated with the scanning configuration of a repository.
    public struct RepositoryScanningConfigurationFailure: Swift.Equatable {
        /// The failure code.
        public var failureCode: ECRClientTypes.ScanningConfigurationFailureCode?
        /// The reason for the failure.
        public var failureReason: Swift.String?
        /// The name of the repository.
        public var repositoryName: Swift.String?

        public init(
            failureCode: ECRClientTypes.ScanningConfigurationFailureCode? = nil,
            failureReason: Swift.String? = nil,
            repositoryName: Swift.String? = nil
        )
        {
            self.failureCode = failureCode
            self.failureReason = failureReason
            self.repositoryName = repositoryName
        }
    }

}

extension ECRClientTypes.Resource: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case details
        case id
        case tags
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let details = self.details {
            try encodeContainer.encode(details, forKey: .details)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tags0) in tags {
                try tagsContainer.encode(tags0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
        if let type = self.type {
            try encodeContainer.encode(type, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let detailsDecoded = try containerValues.decodeIfPresent(ECRClientTypes.ResourceDetails.self, forKey: .details)
        details = detailsDecoded
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, tagvalue0) in tagsContainer {
                if let tagvalue0 = tagvalue0 {
                    tagsDecoded0?[key0] = tagvalue0
                }
            }
        }
        tags = tagsDecoded0
        let typeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .type)
        type = typeDecoded
    }
}

extension ECRClientTypes {
    /// Details about the resource involved in a finding.
    public struct Resource: Swift.Equatable {
        /// An object that contains details about the resource involved in a finding.
        public var details: ECRClientTypes.ResourceDetails?
        /// The ID of the resource.
        public var id: Swift.String?
        /// The tags attached to the resource.
        public var tags: [Swift.String:Swift.String]?
        /// The type of resource.
        public var type: Swift.String?

        public init(
            details: ECRClientTypes.ResourceDetails? = nil,
            id: Swift.String? = nil,
            tags: [Swift.String:Swift.String]? = nil,
            type: Swift.String? = nil
        )
        {
            self.details = details
            self.id = id
            self.tags = tags
            self.type = type
        }
    }

}

extension ECRClientTypes.ResourceDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case awsEcrContainerImage
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let awsEcrContainerImage = self.awsEcrContainerImage {
            try encodeContainer.encode(awsEcrContainerImage, forKey: .awsEcrContainerImage)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let awsEcrContainerImageDecoded = try containerValues.decodeIfPresent(ECRClientTypes.AwsEcrContainerImageDetails.self, forKey: .awsEcrContainerImage)
        awsEcrContainerImage = awsEcrContainerImageDecoded
    }
}

extension ECRClientTypes {
    /// Contains details about the resource involved in the finding.
    public struct ResourceDetails: Swift.Equatable {
        /// An object that contains details about the Amazon ECR container image involved in the finding.
        public var awsEcrContainerImage: ECRClientTypes.AwsEcrContainerImageDetails?

        public init(
            awsEcrContainerImage: ECRClientTypes.AwsEcrContainerImageDetails? = nil
        )
        {
            self.awsEcrContainerImage = awsEcrContainerImage
        }
    }

}

extension ECRClientTypes {
    public enum ScanFrequency: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case continuousScan
        case manual
        case scanOnPush
        case sdkUnknown(Swift.String)

        public static var allCases: [ScanFrequency] {
            return [
                .continuousScan,
                .manual,
                .scanOnPush,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .continuousScan: return "CONTINUOUS_SCAN"
            case .manual: return "MANUAL"
            case .scanOnPush: return "SCAN_ON_PUSH"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ScanFrequency(rawValue: rawValue) ?? ScanFrequency.sdkUnknown(rawValue)
        }
    }
}

extension ScanNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ScanNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The specified image scan could not be found. Ensure that image scanning is enabled on the repository and try again.
public struct ScanNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ScanNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ScanNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ScanNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ECRClientTypes {
    public enum ScanStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case active
        case complete
        case failed
        case findingsUnavailable
        case inProgress
        case pending
        case scanEligibilityExpired
        case unsupportedImage
        case sdkUnknown(Swift.String)

        public static var allCases: [ScanStatus] {
            return [
                .active,
                .complete,
                .failed,
                .findingsUnavailable,
                .inProgress,
                .pending,
                .scanEligibilityExpired,
                .unsupportedImage,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .complete: return "COMPLETE"
            case .failed: return "FAILED"
            case .findingsUnavailable: return "FINDINGS_UNAVAILABLE"
            case .inProgress: return "IN_PROGRESS"
            case .pending: return "PENDING"
            case .scanEligibilityExpired: return "SCAN_ELIGIBILITY_EXPIRED"
            case .unsupportedImage: return "UNSUPPORTED_IMAGE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ScanStatus(rawValue: rawValue) ?? ScanStatus.sdkUnknown(rawValue)
        }
    }
}

extension ECRClientTypes {
    public enum ScanType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case basic
        case enhanced
        case sdkUnknown(Swift.String)

        public static var allCases: [ScanType] {
            return [
                .basic,
                .enhanced,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .basic: return "BASIC"
            case .enhanced: return "ENHANCED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ScanType(rawValue: rawValue) ?? ScanType.sdkUnknown(rawValue)
        }
    }
}

extension ECRClientTypes {
    public enum ScanningConfigurationFailureCode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case repositoryNotFound
        case sdkUnknown(Swift.String)

        public static var allCases: [ScanningConfigurationFailureCode] {
            return [
                .repositoryNotFound,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .repositoryNotFound: return "REPOSITORY_NOT_FOUND"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ScanningConfigurationFailureCode(rawValue: rawValue) ?? ScanningConfigurationFailureCode.sdkUnknown(rawValue)
        }
    }
}

extension ECRClientTypes.ScanningRepositoryFilter: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case filter
        case filterType
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let filter = self.filter {
            try encodeContainer.encode(filter, forKey: .filter)
        }
        if let filterType = self.filterType {
            try encodeContainer.encode(filterType.rawValue, forKey: .filterType)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let filterDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .filter)
        filter = filterDecoded
        let filterTypeDecoded = try containerValues.decodeIfPresent(ECRClientTypes.ScanningRepositoryFilterType.self, forKey: .filterType)
        filterType = filterTypeDecoded
    }
}

extension ECRClientTypes {
    /// The details of a scanning repository filter. For more information on how to use filters, see [Using filters](https://docs.aws.amazon.com/AmazonECR/latest/userguide/image-scanning.html#image-scanning-filters) in the Amazon Elastic Container Registry User Guide.
    public struct ScanningRepositoryFilter: Swift.Equatable {
        /// The filter to use when scanning.
        /// This member is required.
        public var filter: Swift.String?
        /// The type associated with the filter.
        /// This member is required.
        public var filterType: ECRClientTypes.ScanningRepositoryFilterType?

        public init(
            filter: Swift.String? = nil,
            filterType: ECRClientTypes.ScanningRepositoryFilterType? = nil
        )
        {
            self.filter = filter
            self.filterType = filterType
        }
    }

}

extension ECRClientTypes {
    public enum ScanningRepositoryFilterType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case wildcard
        case sdkUnknown(Swift.String)

        public static var allCases: [ScanningRepositoryFilterType] {
            return [
                .wildcard,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .wildcard: return "WILDCARD"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ScanningRepositoryFilterType(rawValue: rawValue) ?? ScanningRepositoryFilterType.sdkUnknown(rawValue)
        }
    }
}

extension ECRClientTypes.ScoreDetails: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case cvss
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let cvss = self.cvss {
            try encodeContainer.encode(cvss, forKey: .cvss)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let cvssDecoded = try containerValues.decodeIfPresent(ECRClientTypes.CvssScoreDetails.self, forKey: .cvss)
        cvss = cvssDecoded
    }
}

extension ECRClientTypes {
    /// Information about the Amazon Inspector score given to a finding.
    public struct ScoreDetails: Swift.Equatable {
        /// An object that contains details about the CVSS score given to a finding.
        public var cvss: ECRClientTypes.CvssScoreDetails?

        public init(
            cvss: ECRClientTypes.CvssScoreDetails? = nil
        )
        {
            self.cvss = cvss
        }
    }

}

extension ServerException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// These errors are usually caused by a server-side issue.
public struct ServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The error message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServerException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension SetRepositoryPolicyInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case force
        case policyText
        case registryId
        case repositoryName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let force = self.force {
            try encodeContainer.encode(force, forKey: .force)
        }
        if let policyText = self.policyText {
            try encodeContainer.encode(policyText, forKey: .policyText)
        }
        if let registryId = self.registryId {
            try encodeContainer.encode(registryId, forKey: .registryId)
        }
        if let repositoryName = self.repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }
}

extension SetRepositoryPolicyInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct SetRepositoryPolicyInput: Swift.Equatable {
    /// If the policy you are attempting to set on a repository policy would prevent you from setting another policy in the future, you must force the [SetRepositoryPolicy] operation. This is intended to prevent accidental repository lock outs.
    public var force: Swift.Bool?
    /// The JSON repository policy text to apply to the repository. For more information, see [Amazon ECR repository policies](https://docs.aws.amazon.com/AmazonECR/latest/userguide/repository-policy-examples.html) in the Amazon Elastic Container Registry User Guide.
    /// This member is required.
    public var policyText: Swift.String?
    /// The Amazon Web Services account ID associated with the registry that contains the repository. If you do not specify a registry, the default registry is assumed.
    public var registryId: Swift.String?
    /// The name of the repository to receive the policy.
    /// This member is required.
    public var repositoryName: Swift.String?

    public init(
        force: Swift.Bool? = nil,
        policyText: Swift.String? = nil,
        registryId: Swift.String? = nil,
        repositoryName: Swift.String? = nil
    )
    {
        self.force = force
        self.policyText = policyText
        self.registryId = registryId
        self.repositoryName = repositoryName
    }
}

struct SetRepositoryPolicyInputBody: Swift.Equatable {
    let registryId: Swift.String?
    let repositoryName: Swift.String?
    let policyText: Swift.String?
    let force: Swift.Bool?
}

extension SetRepositoryPolicyInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case force
        case policyText
        case registryId
        case repositoryName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let policyTextDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyText)
        policyText = policyTextDecoded
        let forceDecoded = try containerValues.decodeIfPresent(Swift.Bool.self, forKey: .force)
        force = forceDecoded
    }
}

extension SetRepositoryPolicyOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: SetRepositoryPolicyOutputBody = try responseDecoder.decode(responseBody: data)
            self.policyText = output.policyText
            self.registryId = output.registryId
            self.repositoryName = output.repositoryName
        } else {
            self.policyText = nil
            self.registryId = nil
            self.repositoryName = nil
        }
    }
}

public struct SetRepositoryPolicyOutput: Swift.Equatable {
    /// The JSON repository policy text applied to the repository.
    public var policyText: Swift.String?
    /// The registry ID associated with the request.
    public var registryId: Swift.String?
    /// The repository name associated with the request.
    public var repositoryName: Swift.String?

    public init(
        policyText: Swift.String? = nil,
        registryId: Swift.String? = nil,
        repositoryName: Swift.String? = nil
    )
    {
        self.policyText = policyText
        self.registryId = registryId
        self.repositoryName = repositoryName
    }
}

struct SetRepositoryPolicyOutputBody: Swift.Equatable {
    let registryId: Swift.String?
    let repositoryName: Swift.String?
    let policyText: Swift.String?
}

extension SetRepositoryPolicyOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case policyText
        case registryId
        case repositoryName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let policyTextDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .policyText)
        policyText = policyTextDecoded
    }
}

enum SetRepositoryPolicyOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RepositoryNotFoundException": return try await RepositoryNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServerException": return try await ServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension StartImageScanInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imageId
        case registryId
        case repositoryName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let imageId = self.imageId {
            try encodeContainer.encode(imageId, forKey: .imageId)
        }
        if let registryId = self.registryId {
            try encodeContainer.encode(registryId, forKey: .registryId)
        }
        if let repositoryName = self.repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }
}

extension StartImageScanInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct StartImageScanInput: Swift.Equatable {
    /// An object with identifying information for an image in an Amazon ECR repository.
    /// This member is required.
    public var imageId: ECRClientTypes.ImageIdentifier?
    /// The Amazon Web Services account ID associated with the registry that contains the repository in which to start an image scan request. If you do not specify a registry, the default registry is assumed.
    public var registryId: Swift.String?
    /// The name of the repository that contains the images to scan.
    /// This member is required.
    public var repositoryName: Swift.String?

    public init(
        imageId: ECRClientTypes.ImageIdentifier? = nil,
        registryId: Swift.String? = nil,
        repositoryName: Swift.String? = nil
    )
    {
        self.imageId = imageId
        self.registryId = registryId
        self.repositoryName = repositoryName
    }
}

struct StartImageScanInputBody: Swift.Equatable {
    let registryId: Swift.String?
    let repositoryName: Swift.String?
    let imageId: ECRClientTypes.ImageIdentifier?
}

extension StartImageScanInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imageId
        case registryId
        case repositoryName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let imageIdDecoded = try containerValues.decodeIfPresent(ECRClientTypes.ImageIdentifier.self, forKey: .imageId)
        imageId = imageIdDecoded
    }
}

extension StartImageScanOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StartImageScanOutputBody = try responseDecoder.decode(responseBody: data)
            self.imageId = output.imageId
            self.imageScanStatus = output.imageScanStatus
            self.registryId = output.registryId
            self.repositoryName = output.repositoryName
        } else {
            self.imageId = nil
            self.imageScanStatus = nil
            self.registryId = nil
            self.repositoryName = nil
        }
    }
}

public struct StartImageScanOutput: Swift.Equatable {
    /// An object with identifying information for an image in an Amazon ECR repository.
    public var imageId: ECRClientTypes.ImageIdentifier?
    /// The current state of the scan.
    public var imageScanStatus: ECRClientTypes.ImageScanStatus?
    /// The registry ID associated with the request.
    public var registryId: Swift.String?
    /// The repository name associated with the request.
    public var repositoryName: Swift.String?

    public init(
        imageId: ECRClientTypes.ImageIdentifier? = nil,
        imageScanStatus: ECRClientTypes.ImageScanStatus? = nil,
        registryId: Swift.String? = nil,
        repositoryName: Swift.String? = nil
    )
    {
        self.imageId = imageId
        self.imageScanStatus = imageScanStatus
        self.registryId = registryId
        self.repositoryName = repositoryName
    }
}

struct StartImageScanOutputBody: Swift.Equatable {
    let registryId: Swift.String?
    let repositoryName: Swift.String?
    let imageId: ECRClientTypes.ImageIdentifier?
    let imageScanStatus: ECRClientTypes.ImageScanStatus?
}

extension StartImageScanOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case imageId
        case imageScanStatus
        case registryId
        case repositoryName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let imageIdDecoded = try containerValues.decodeIfPresent(ECRClientTypes.ImageIdentifier.self, forKey: .imageId)
        imageId = imageIdDecoded
        let imageScanStatusDecoded = try containerValues.decodeIfPresent(ECRClientTypes.ImageScanStatus.self, forKey: .imageScanStatus)
        imageScanStatus = imageScanStatusDecoded
    }
}

enum StartImageScanOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "ImageNotFoundException": return try await ImageNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RepositoryNotFoundException": return try await RepositoryNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServerException": return try await ServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UnsupportedImageTypeException": return try await UnsupportedImageTypeException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension StartLifecyclePolicyPreviewInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lifecyclePolicyText
        case registryId
        case repositoryName
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let lifecyclePolicyText = self.lifecyclePolicyText {
            try encodeContainer.encode(lifecyclePolicyText, forKey: .lifecyclePolicyText)
        }
        if let registryId = self.registryId {
            try encodeContainer.encode(registryId, forKey: .registryId)
        }
        if let repositoryName = self.repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
    }
}

extension StartLifecyclePolicyPreviewInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct StartLifecyclePolicyPreviewInput: Swift.Equatable {
    /// The policy to be evaluated against. If you do not specify a policy, the current policy for the repository is used.
    public var lifecyclePolicyText: Swift.String?
    /// The Amazon Web Services account ID associated with the registry that contains the repository. If you do not specify a registry, the default registry is assumed.
    public var registryId: Swift.String?
    /// The name of the repository to be evaluated.
    /// This member is required.
    public var repositoryName: Swift.String?

    public init(
        lifecyclePolicyText: Swift.String? = nil,
        registryId: Swift.String? = nil,
        repositoryName: Swift.String? = nil
    )
    {
        self.lifecyclePolicyText = lifecyclePolicyText
        self.registryId = registryId
        self.repositoryName = repositoryName
    }
}

struct StartLifecyclePolicyPreviewInputBody: Swift.Equatable {
    let registryId: Swift.String?
    let repositoryName: Swift.String?
    let lifecyclePolicyText: Swift.String?
}

extension StartLifecyclePolicyPreviewInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lifecyclePolicyText
        case registryId
        case repositoryName
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let lifecyclePolicyTextDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lifecyclePolicyText)
        lifecyclePolicyText = lifecyclePolicyTextDecoded
    }
}

extension StartLifecyclePolicyPreviewOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: StartLifecyclePolicyPreviewOutputBody = try responseDecoder.decode(responseBody: data)
            self.lifecyclePolicyText = output.lifecyclePolicyText
            self.registryId = output.registryId
            self.repositoryName = output.repositoryName
            self.status = output.status
        } else {
            self.lifecyclePolicyText = nil
            self.registryId = nil
            self.repositoryName = nil
            self.status = nil
        }
    }
}

public struct StartLifecyclePolicyPreviewOutput: Swift.Equatable {
    /// The JSON repository policy text.
    public var lifecyclePolicyText: Swift.String?
    /// The registry ID associated with the request.
    public var registryId: Swift.String?
    /// The repository name associated with the request.
    public var repositoryName: Swift.String?
    /// The status of the lifecycle policy preview request.
    public var status: ECRClientTypes.LifecyclePolicyPreviewStatus?

    public init(
        lifecyclePolicyText: Swift.String? = nil,
        registryId: Swift.String? = nil,
        repositoryName: Swift.String? = nil,
        status: ECRClientTypes.LifecyclePolicyPreviewStatus? = nil
    )
    {
        self.lifecyclePolicyText = lifecyclePolicyText
        self.registryId = registryId
        self.repositoryName = repositoryName
        self.status = status
    }
}

struct StartLifecyclePolicyPreviewOutputBody: Swift.Equatable {
    let registryId: Swift.String?
    let repositoryName: Swift.String?
    let lifecyclePolicyText: Swift.String?
    let status: ECRClientTypes.LifecyclePolicyPreviewStatus?
}

extension StartLifecyclePolicyPreviewOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lifecyclePolicyText
        case registryId
        case repositoryName
        case status
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let lifecyclePolicyTextDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .lifecyclePolicyText)
        lifecyclePolicyText = lifecyclePolicyTextDecoded
        let statusDecoded = try containerValues.decodeIfPresent(ECRClientTypes.LifecyclePolicyPreviewStatus.self, forKey: .status)
        status = statusDecoded
    }
}

enum StartLifecyclePolicyPreviewOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LifecyclePolicyNotFoundException": return try await LifecyclePolicyNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LifecyclePolicyPreviewInProgressException": return try await LifecyclePolicyPreviewInProgressException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RepositoryNotFoundException": return try await RepositoryNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServerException": return try await ServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ECRClientTypes.Tag: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case key = "Key"
        case value = "Value"
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let key = self.key {
            try encodeContainer.encode(key, forKey: .key)
        }
        if let value = self.value {
            try encodeContainer.encode(value, forKey: .value)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let keyDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .key)
        key = keyDecoded
        let valueDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .value)
        value = valueDecoded
    }
}

extension ECRClientTypes {
    /// The metadata to apply to a resource to help you categorize and organize them. Each tag consists of a key and a value, both of which you define. Tag keys can have a maximum character length of 128 characters, and tag values can have a maximum length of 256 characters.
    public struct Tag: Swift.Equatable {
        /// One part of a key-value pair that make up a tag. A key is a general label that acts like a category for more specific tag values.
        /// This member is required.
        public var key: Swift.String?
        /// A value acts as a descriptor within a tag category (key).
        /// This member is required.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        )
        {
            self.key = key
            self.value = value
        }
    }

}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tags)
            for tag0 in tags {
                try tagsContainer.encode(tag0)
            }
        }
    }
}

extension TagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the the resource to which to add tags. Currently, the only supported resource is an Amazon ECR repository.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The tags to add to the resource. A tag is an array of key-value pairs. Tag keys can have a maximum character length of 128 characters, and tag values can have a maximum length of 256 characters.
    /// This member is required.
    public var tags: [ECRClientTypes.Tag]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [ECRClientTypes.Tag]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
    let tags: [ECRClientTypes.Tag]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagsContainer = try containerValues.decodeIfPresent([ECRClientTypes.Tag?].self, forKey: .tags)
        var tagsDecoded0:[ECRClientTypes.Tag]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [ECRClientTypes.Tag]()
            for structure0 in tagsContainer {
                if let structure0 = structure0 {
                    tagsDecoded0?.append(structure0)
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct TagResourceOutput: Swift.Equatable {

    public init() { }
}

enum TagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidTagParameterException": return try await InvalidTagParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RepositoryNotFoundException": return try await RepositoryNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServerException": return try await ServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyTagsException": return try await TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ECRClientTypes {
    public enum TagStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case any
        case tagged
        case untagged
        case sdkUnknown(Swift.String)

        public static var allCases: [TagStatus] {
            return [
                .any,
                .tagged,
                .untagged,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .any: return "ANY"
            case .tagged: return "TAGGED"
            case .untagged: return "UNTAGGED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TagStatus(rawValue: rawValue) ?? TagStatus.sdkUnknown(rawValue)
        }
    }
}

extension TooManyTagsException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: TooManyTagsExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The list of tags on the repository is over the limit. The maximum number of tags that can be applied to a repository is 50.
public struct TooManyTagsException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "TooManyTagsException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct TooManyTagsExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension TooManyTagsExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UnsupportedImageTypeException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UnsupportedImageTypeExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The image is of a type that cannot be scanned.
public struct UnsupportedImageTypeException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "UnsupportedImageTypeException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct UnsupportedImageTypeExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension UnsupportedImageTypeExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UnsupportedUpstreamRegistryException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UnsupportedUpstreamRegistryExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The specified upstream registry isn't supported.
public struct UnsupportedUpstreamRegistryException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "UnsupportedUpstreamRegistryException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct UnsupportedUpstreamRegistryExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension UnsupportedUpstreamRegistryExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension UntagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn
        case tagKeys
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
        if let tagKeys = tagKeys {
            var tagKeysContainer = encodeContainer.nestedUnkeyedContainer(forKey: .tagKeys)
            for tagkey0 in tagKeys {
                try tagKeysContainer.encode(tagkey0)
            }
        }
    }
}

extension UntagResourceInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource from which to remove tags. Currently, the only supported resource is an Amazon ECR repository.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The keys of the tags to be removed.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
    let resourceArn: Swift.String?
    let tagKeys: [Swift.String]?
}

extension UntagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case resourceArn
        case tagKeys
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let tagKeysContainer = try containerValues.decodeIfPresent([Swift.String?].self, forKey: .tagKeys)
        var tagKeysDecoded0:[Swift.String]? = nil
        if let tagKeysContainer = tagKeysContainer {
            tagKeysDecoded0 = [Swift.String]()
            for string0 in tagKeysContainer {
                if let string0 = string0 {
                    tagKeysDecoded0?.append(string0)
                }
            }
        }
        tagKeys = tagKeysDecoded0
    }
}

extension UntagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UntagResourceOutput: Swift.Equatable {

    public init() { }
}

enum UntagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidTagParameterException": return try await InvalidTagParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RepositoryNotFoundException": return try await RepositoryNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServerException": return try await ServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "TooManyTagsException": return try await TooManyTagsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UploadLayerPartInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case layerPartBlob
        case partFirstByte
        case partLastByte
        case registryId
        case repositoryName
        case uploadId
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let layerPartBlob = self.layerPartBlob {
            try encodeContainer.encode(layerPartBlob.base64EncodedString(), forKey: .layerPartBlob)
        }
        if let partFirstByte = self.partFirstByte {
            try encodeContainer.encode(partFirstByte, forKey: .partFirstByte)
        }
        if let partLastByte = self.partLastByte {
            try encodeContainer.encode(partLastByte, forKey: .partLastByte)
        }
        if let registryId = self.registryId {
            try encodeContainer.encode(registryId, forKey: .registryId)
        }
        if let repositoryName = self.repositoryName {
            try encodeContainer.encode(repositoryName, forKey: .repositoryName)
        }
        if let uploadId = self.uploadId {
            try encodeContainer.encode(uploadId, forKey: .uploadId)
        }
    }
}

extension UploadLayerPartInput: ClientRuntime.URLPathProvider {
    public var urlPath: Swift.String? {
        return "/"
    }
}

public struct UploadLayerPartInput: Swift.Equatable {
    /// The base64-encoded layer part payload.
    /// This member is required.
    public var layerPartBlob: ClientRuntime.Data?
    /// The position of the first byte of the layer part witin the overall image layer.
    /// This member is required.
    public var partFirstByte: Swift.Int?
    /// The position of the last byte of the layer part within the overall image layer.
    /// This member is required.
    public var partLastByte: Swift.Int?
    /// The Amazon Web Services account ID associated with the registry to which you are uploading layer parts. If you do not specify a registry, the default registry is assumed.
    public var registryId: Swift.String?
    /// The name of the repository to which you are uploading layer parts.
    /// This member is required.
    public var repositoryName: Swift.String?
    /// The upload ID from a previous [InitiateLayerUpload] operation to associate with the layer part upload.
    /// This member is required.
    public var uploadId: Swift.String?

    public init(
        layerPartBlob: ClientRuntime.Data? = nil,
        partFirstByte: Swift.Int? = nil,
        partLastByte: Swift.Int? = nil,
        registryId: Swift.String? = nil,
        repositoryName: Swift.String? = nil,
        uploadId: Swift.String? = nil
    )
    {
        self.layerPartBlob = layerPartBlob
        self.partFirstByte = partFirstByte
        self.partLastByte = partLastByte
        self.registryId = registryId
        self.repositoryName = repositoryName
        self.uploadId = uploadId
    }
}

struct UploadLayerPartInputBody: Swift.Equatable {
    let registryId: Swift.String?
    let repositoryName: Swift.String?
    let uploadId: Swift.String?
    let partFirstByte: Swift.Int?
    let partLastByte: Swift.Int?
    let layerPartBlob: ClientRuntime.Data?
}

extension UploadLayerPartInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case layerPartBlob
        case partFirstByte
        case partLastByte
        case registryId
        case repositoryName
        case uploadId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let uploadIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .uploadId)
        uploadId = uploadIdDecoded
        let partFirstByteDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .partFirstByte)
        partFirstByte = partFirstByteDecoded
        let partLastByteDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .partLastByte)
        partLastByte = partLastByteDecoded
        let layerPartBlobDecoded = try containerValues.decodeIfPresent(ClientRuntime.Data.self, forKey: .layerPartBlob)
        layerPartBlob = layerPartBlobDecoded
    }
}

extension UploadLayerPartOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UploadLayerPartOutputBody = try responseDecoder.decode(responseBody: data)
            self.lastByteReceived = output.lastByteReceived
            self.registryId = output.registryId
            self.repositoryName = output.repositoryName
            self.uploadId = output.uploadId
        } else {
            self.lastByteReceived = nil
            self.registryId = nil
            self.repositoryName = nil
            self.uploadId = nil
        }
    }
}

public struct UploadLayerPartOutput: Swift.Equatable {
    /// The integer value of the last byte received in the request.
    public var lastByteReceived: Swift.Int?
    /// The registry ID associated with the request.
    public var registryId: Swift.String?
    /// The repository name associated with the request.
    public var repositoryName: Swift.String?
    /// The upload ID associated with the request.
    public var uploadId: Swift.String?

    public init(
        lastByteReceived: Swift.Int? = nil,
        registryId: Swift.String? = nil,
        repositoryName: Swift.String? = nil,
        uploadId: Swift.String? = nil
    )
    {
        self.lastByteReceived = lastByteReceived
        self.registryId = registryId
        self.repositoryName = repositoryName
        self.uploadId = uploadId
    }
}

struct UploadLayerPartOutputBody: Swift.Equatable {
    let registryId: Swift.String?
    let repositoryName: Swift.String?
    let uploadId: Swift.String?
    let lastByteReceived: Swift.Int?
}

extension UploadLayerPartOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case lastByteReceived
        case registryId
        case repositoryName
        case uploadId
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let registryIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .registryId)
        registryId = registryIdDecoded
        let repositoryNameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .repositoryName)
        repositoryName = repositoryNameDecoded
        let uploadIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .uploadId)
        uploadId = uploadIdDecoded
        let lastByteReceivedDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .lastByteReceived)
        lastByteReceived = lastByteReceivedDecoded
    }
}

enum UploadLayerPartOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InvalidLayerPartException": return try await InvalidLayerPartException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InvalidParameterException": return try await InvalidParameterException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "KmsException": return try await KmsException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "LimitExceededException": return try await LimitExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "RepositoryNotFoundException": return try await RepositoryNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServerException": return try await ServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "UploadNotFoundException": return try await UploadNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UploadNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UploadNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The upload could not be found, or the specified upload ID is not valid for this repository.
public struct UploadNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// The error message associated with the exception.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "UploadNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct UploadNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension UploadNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ValidationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// There was an exception validating this request.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ECRClientTypes.VulnerablePackage: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arch
        case epoch
        case filePath
        case name
        case packageManager
        case release
        case sourceLayerHash
        case version
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arch = self.arch {
            try encodeContainer.encode(arch, forKey: .arch)
        }
        if let epoch = self.epoch {
            try encodeContainer.encode(epoch, forKey: .epoch)
        }
        if let filePath = self.filePath {
            try encodeContainer.encode(filePath, forKey: .filePath)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let packageManager = self.packageManager {
            try encodeContainer.encode(packageManager, forKey: .packageManager)
        }
        if let release = self.release {
            try encodeContainer.encode(release, forKey: .release)
        }
        if let sourceLayerHash = self.sourceLayerHash {
            try encodeContainer.encode(sourceLayerHash, forKey: .sourceLayerHash)
        }
        if let version = self.version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let archDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arch)
        arch = archDecoded
        let epochDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .epoch)
        epoch = epochDecoded
        let filePathDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .filePath)
        filePath = filePathDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let packageManagerDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .packageManager)
        packageManager = packageManagerDecoded
        let releaseDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .release)
        release = releaseDecoded
        let sourceLayerHashDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .sourceLayerHash)
        sourceLayerHash = sourceLayerHashDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
    }
}

extension ECRClientTypes {
    /// Information on the vulnerable package identified by a finding.
    public struct VulnerablePackage: Swift.Equatable {
        /// The architecture of the vulnerable package.
        public var arch: Swift.String?
        /// The epoch of the vulnerable package.
        public var epoch: Swift.Int?
        /// The file path of the vulnerable package.
        public var filePath: Swift.String?
        /// The name of the vulnerable package.
        public var name: Swift.String?
        /// The package manager of the vulnerable package.
        public var packageManager: Swift.String?
        /// The release of the vulnerable package.
        public var release: Swift.String?
        /// The source layer hash of the vulnerable package.
        public var sourceLayerHash: Swift.String?
        /// The version of the vulnerable package.
        public var version: Swift.String?

        public init(
            arch: Swift.String? = nil,
            epoch: Swift.Int? = nil,
            filePath: Swift.String? = nil,
            name: Swift.String? = nil,
            packageManager: Swift.String? = nil,
            release: Swift.String? = nil,
            sourceLayerHash: Swift.String? = nil,
            version: Swift.String? = nil
        )
        {
            self.arch = arch
            self.epoch = epoch
            self.filePath = filePath
            self.name = name
            self.packageManager = packageManager
            self.release = release
            self.sourceLayerHash = sourceLayerHash
            self.version = version
        }
    }

}
