//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

import protocol ClientRuntime.PaginateToken
import struct ClientRuntime.PaginatorSequence

extension WorkspacesInstancesClient {
    /// Paginate over `[ListInstanceTypesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListInstanceTypesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListInstanceTypesOutput`
    public func listInstanceTypesPaginated(input: ListInstanceTypesInput) -> ClientRuntime.PaginatorSequence<ListInstanceTypesInput, ListInstanceTypesOutput> {
        return ClientRuntime.PaginatorSequence<ListInstanceTypesInput, ListInstanceTypesOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listInstanceTypes(input:))
    }
}

extension ListInstanceTypesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListInstanceTypesInput {
        return ListInstanceTypesInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListInstanceTypesInput, OperationStackOutput == ListInstanceTypesOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listInstanceTypesPaginated`
    /// to access the nested member `[WorkspacesInstancesClientTypes.InstanceTypeInfo]`
    /// - Returns: `[WorkspacesInstancesClientTypes.InstanceTypeInfo]`
    public func instanceTypes() async throws -> [WorkspacesInstancesClientTypes.InstanceTypeInfo] {
        return try await self.asyncCompactMap { item in item.instanceTypes }
    }
}
extension WorkspacesInstancesClient {
    /// Paginate over `[ListRegionsOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListRegionsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListRegionsOutput`
    public func listRegionsPaginated(input: ListRegionsInput) -> ClientRuntime.PaginatorSequence<ListRegionsInput, ListRegionsOutput> {
        return ClientRuntime.PaginatorSequence<ListRegionsInput, ListRegionsOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listRegions(input:))
    }
}

extension ListRegionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListRegionsInput {
        return ListRegionsInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where OperationStackInput == ListRegionsInput, OperationStackOutput == ListRegionsOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listRegionsPaginated`
    /// to access the nested member `[WorkspacesInstancesClientTypes.Region]`
    /// - Returns: `[WorkspacesInstancesClientTypes.Region]`
    public func regions() async throws -> [WorkspacesInstancesClientTypes.Region] {
        return try await self.asyncCompactMap { item in item.regions }
    }
}
extension WorkspacesInstancesClient {
    /// Paginate over `[ListWorkspaceInstancesOutput]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListWorkspaceInstancesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListWorkspaceInstancesOutput`
    public func listWorkspaceInstancesPaginated(input: ListWorkspaceInstancesInput) -> ClientRuntime.PaginatorSequence<ListWorkspaceInstancesInput, ListWorkspaceInstancesOutput> {
        return ClientRuntime.PaginatorSequence<ListWorkspaceInstancesInput, ListWorkspaceInstancesOutput>(input: input, inputKey: \.nextToken, outputKey: \.nextToken, paginationFunction: self.listWorkspaceInstances(input:))
    }
}

extension ListWorkspaceInstancesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListWorkspaceInstancesInput {
        return ListWorkspaceInstancesInput(
            maxResults: self.maxResults,
            nextToken: token,
            provisionStates: self.provisionStates
        )}
}

extension PaginatorSequence where OperationStackInput == ListWorkspaceInstancesInput, OperationStackOutput == ListWorkspaceInstancesOutput {
    /// This paginator transforms the `AsyncSequence` returned by `listWorkspaceInstancesPaginated`
    /// to access the nested member `[WorkspacesInstancesClientTypes.WorkspaceInstance]`
    /// - Returns: `[WorkspacesInstancesClientTypes.WorkspaceInstance]`
    public func workspaceInstances() async throws -> [WorkspacesInstancesClientTypes.WorkspaceInstance] {
        return try await self.asyncCompactMap { item in item.workspaceInstances }
    }
}
