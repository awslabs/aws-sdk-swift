//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.AWSJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
@_spi(SmithyReadWrite) import struct SmithyReadWrite.WritingClosureBox

/// Indicates insufficient permissions to perform the requested action.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// Detailed explanation of the access denial.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

extension WorkspacesInstancesClientTypes {

    public enum AmdSevSnpEnum: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [AmdSevSnpEnum] {
            return [
                .disabled,
                .enabled
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "disabled"
            case .enabled: return "enabled"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// Signals a conflict with the current state of the resource.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// Description of the conflict encountered.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// Identifier of the conflicting resource.
        /// This member is required.
        public internal(set) var resourceId: Swift.String? = nil
        /// Type of the conflicting resource.
        /// This member is required.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    ) {
        self.properties.message = message
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
    }
}

/// Indicates an unexpected server-side error occurred.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// Description of the internal server error.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// Recommended wait time before retrying the request.
        public internal(set) var retryAfterSeconds: Swift.Int? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        retryAfterSeconds: Swift.Int? = nil
    ) {
        self.properties.message = message
        self.properties.retryAfterSeconds = retryAfterSeconds
    }
}

/// Indicates the requested resource could not be found.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// Details about the missing resource.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// Identifier of the resource that was not found.
        /// This member is required.
        public internal(set) var resourceId: Swift.String? = nil
        /// Type of the resource that was not found.
        /// This member is required.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    ) {
        self.properties.message = message
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
    }
}

/// Indicates the request rate has exceeded limits.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// Description of the throttling event.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// Specific code for the throttling quota.
        public internal(set) var quotaCode: Swift.String? = nil
        /// Recommended wait time before retrying the request.
        public internal(set) var retryAfterSeconds: Swift.Int? = nil
        /// Code identifying the service experiencing throttling.
        public internal(set) var serviceCode: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { true }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        quotaCode: Swift.String? = nil,
        retryAfterSeconds: Swift.Int? = nil,
        serviceCode: Swift.String? = nil
    ) {
        self.properties.message = message
        self.properties.quotaCode = quotaCode
        self.properties.retryAfterSeconds = retryAfterSeconds
        self.properties.serviceCode = serviceCode
    }
}

extension WorkspacesInstancesClientTypes {

    /// Represents a validation error field in an API request.
    public struct ValidationExceptionField: Swift.Sendable {
        /// Detailed error message describing the validation issue.
        /// This member is required.
        public var message: Swift.String?
        /// Name of the field that failed validation.
        /// This member is required.
        public var name: Swift.String?
        /// Reason for the validation failure.
        /// This member is required.
        public var reason: Swift.String?

        public init(
            message: Swift.String? = nil,
            name: Swift.String? = nil,
            reason: Swift.String? = nil
        ) {
            self.message = message
            self.name = name
            self.reason = reason
        }
    }
}

extension WorkspacesInstancesClientTypes {

    public enum ValidationExceptionReason: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case cannotParse
        case dependencyFailure
        case fieldValidationFailed
        case other
        case unknownOperation
        case unsupportedOperation
        case sdkUnknown(Swift.String)

        public static var allCases: [ValidationExceptionReason] {
            return [
                .cannotParse,
                .dependencyFailure,
                .fieldValidationFailed,
                .other,
                .unknownOperation,
                .unsupportedOperation
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .cannotParse: return "CANNOT_PARSE"
            case .dependencyFailure: return "DEPENDENCY_FAILURE"
            case .fieldValidationFailed: return "FIELD_VALIDATION_FAILED"
            case .other: return "OTHER"
            case .unknownOperation: return "UNKNOWN_OPERATION"
            case .unsupportedOperation: return "UNSUPPORTED_OPERATION"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// Indicates invalid input parameters in the request.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// List of fields that failed validation.
        public internal(set) var fieldList: [WorkspacesInstancesClientTypes.ValidationExceptionField]? = nil
        /// Overall description of validation failures.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// Specific reason for the validation failure.
        /// This member is required.
        public internal(set) var reason: WorkspacesInstancesClientTypes.ValidationExceptionReason? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        fieldList: [WorkspacesInstancesClientTypes.ValidationExceptionField]? = nil,
        message: Swift.String? = nil,
        reason: WorkspacesInstancesClientTypes.ValidationExceptionReason? = nil
    ) {
        self.properties.fieldList = fieldList
        self.properties.message = message
        self.properties.reason = reason
    }
}

/// Specifies volume attachment parameters.
public struct AssociateVolumeInput: Swift.Sendable {
    /// Device path for volume attachment.
    /// This member is required.
    public var device: Swift.String?
    /// Volume to be attached.
    /// This member is required.
    public var volumeId: Swift.String?
    /// WorkSpace Instance to attach volume to.
    /// This member is required.
    public var workspaceInstanceId: Swift.String?

    public init(
        device: Swift.String? = nil,
        volumeId: Swift.String? = nil,
        workspaceInstanceId: Swift.String? = nil
    ) {
        self.device = device
        self.volumeId = volumeId
        self.workspaceInstanceId = workspaceInstanceId
    }
}

/// Confirms volume attachment.
public struct AssociateVolumeOutput: Swift.Sendable {

    public init() { }
}

extension WorkspacesInstancesClientTypes {

    public enum AutoRecoveryEnum: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case `default`
        case disabled
        case sdkUnknown(Swift.String)

        public static var allCases: [AutoRecoveryEnum] {
            return [
                .default,
                .disabled
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .default: return "default"
            case .disabled: return "disabled"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension WorkspacesInstancesClientTypes {

    public enum BandwidthWeightingEnum: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case `default`
        case ebs1
        case vpc1
        case sdkUnknown(Swift.String)

        public static var allCases: [BandwidthWeightingEnum] {
            return [
                .default,
                .ebs1,
                .vpc1
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .default: return "default"
            case .ebs1: return "ebs-1"
            case .vpc1: return "vpc-1"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension WorkspacesInstancesClientTypes {

    public enum BillingMode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case hourly
        case monthly
        case sdkUnknown(Swift.String)

        public static var allCases: [BillingMode] {
            return [
                .hourly,
                .monthly
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .hourly: return "HOURLY"
            case .monthly: return "MONTHLY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension WorkspacesInstancesClientTypes {

    /// Defines billing configuration settings for WorkSpace Instances, containing the billing mode selection.
    public struct BillingConfiguration: Swift.Sendable {
        /// Specifies the billing mode for WorkSpace Instances. MONTHLY provides fixed monthly rates for predictable budgeting, while HOURLY enables pay-per-second billing for actual usage.
        /// This member is required.
        public var billingMode: WorkspacesInstancesClientTypes.BillingMode?

        public init(
            billingMode: WorkspacesInstancesClientTypes.BillingMode? = nil
        ) {
            self.billingMode = billingMode
        }
    }
}

extension WorkspacesInstancesClientTypes {

    public enum VolumeTypeEnum: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case gp2
        case gp3
        case io1
        case io2
        case sc1
        case st1
        case standard
        case sdkUnknown(Swift.String)

        public static var allCases: [VolumeTypeEnum] {
            return [
                .gp2,
                .gp3,
                .io1,
                .io2,
                .sc1,
                .st1,
                .standard
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .gp2: return "gp2"
            case .gp3: return "gp3"
            case .io1: return "io1"
            case .io2: return "io2"
            case .sc1: return "sc1"
            case .st1: return "st1"
            case .standard: return "standard"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension WorkspacesInstancesClientTypes {

    /// Defines configuration for an Elastic Block Store volume.
    public struct EbsBlockDevice: Swift.Sendable {
        /// Indicates if the volume is encrypted.
        public var encrypted: Swift.Bool?
        /// Input/output operations per second for the volume.
        public var iops: Swift.Int?
        /// KMS key used for volume encryption.
        public var kmsKeyId: Swift.String?
        /// Volume data transfer rate.
        public var throughput: Swift.Int?
        /// Size of the EBS volume in gigabytes.
        public var volumeSize: Swift.Int?
        /// Type of EBS volume (e.g., gp2, io1).
        public var volumeType: WorkspacesInstancesClientTypes.VolumeTypeEnum?

        public init(
            encrypted: Swift.Bool? = nil,
            iops: Swift.Int? = nil,
            kmsKeyId: Swift.String? = nil,
            throughput: Swift.Int? = nil,
            volumeSize: Swift.Int? = nil,
            volumeType: WorkspacesInstancesClientTypes.VolumeTypeEnum? = nil
        ) {
            self.encrypted = encrypted
            self.iops = iops
            self.kmsKeyId = kmsKeyId
            self.throughput = throughput
            self.volumeSize = volumeSize
            self.volumeType = volumeType
        }
    }
}

extension WorkspacesInstancesClientTypes.EbsBlockDevice: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EbsBlockDevice(encrypted: \(Swift.String(describing: encrypted)), iops: \(Swift.String(describing: iops)), throughput: \(Swift.String(describing: throughput)), volumeSize: \(Swift.String(describing: volumeSize)), volumeType: \(Swift.String(describing: volumeType)), kmsKeyId: \"CONTENT_REDACTED\")"}
}

extension WorkspacesInstancesClientTypes {

    /// Defines device mapping for WorkSpace Instance storage.
    public struct BlockDeviceMappingRequest: Swift.Sendable {
        /// Name of the device for storage mapping.
        public var deviceName: Swift.String?
        /// EBS volume configuration for the device.
        public var ebs: WorkspacesInstancesClientTypes.EbsBlockDevice?
        /// Indicates device should not be mapped.
        public var noDevice: Swift.String?
        /// Virtual device name for ephemeral storage.
        public var virtualName: Swift.String?

        public init(
            deviceName: Swift.String? = nil,
            ebs: WorkspacesInstancesClientTypes.EbsBlockDevice? = nil,
            noDevice: Swift.String? = nil,
            virtualName: Swift.String? = nil
        ) {
            self.deviceName = deviceName
            self.ebs = ebs
            self.noDevice = noDevice
            self.virtualName = virtualName
        }
    }
}

extension WorkspacesInstancesClientTypes {

    public enum CapacityReservationPreferenceEnum: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case capacityReservationsOnly
        case `none`
        case `open`
        case sdkUnknown(Swift.String)

        public static var allCases: [CapacityReservationPreferenceEnum] {
            return [
                .capacityReservationsOnly,
                .none,
                .open
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .capacityReservationsOnly: return "capacity-reservations-only"
            case .none: return "none"
            case .open: return "open"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension WorkspacesInstancesClientTypes {

    /// Identifies a specific capacity reservation.
    public struct CapacityReservationTarget: Swift.Sendable {
        /// Unique identifier for the capacity reservation.
        public var capacityReservationId: Swift.String?
        /// ARN of the capacity reservation resource group.
        public var capacityReservationResourceGroupArn: Swift.String?

        public init(
            capacityReservationId: Swift.String? = nil,
            capacityReservationResourceGroupArn: Swift.String? = nil
        ) {
            self.capacityReservationId = capacityReservationId
            self.capacityReservationResourceGroupArn = capacityReservationResourceGroupArn
        }
    }
}

extension WorkspacesInstancesClientTypes {

    /// Specifies capacity reservation preferences.
    public struct CapacityReservationSpecification: Swift.Sendable {
        /// Preference for using capacity reservation.
        public var capacityReservationPreference: WorkspacesInstancesClientTypes.CapacityReservationPreferenceEnum?
        /// Specific capacity reservation target.
        public var capacityReservationTarget: WorkspacesInstancesClientTypes.CapacityReservationTarget?

        public init(
            capacityReservationPreference: WorkspacesInstancesClientTypes.CapacityReservationPreferenceEnum? = nil,
            capacityReservationTarget: WorkspacesInstancesClientTypes.CapacityReservationTarget? = nil
        ) {
            self.capacityReservationPreference = capacityReservationPreference
            self.capacityReservationTarget = capacityReservationTarget
        }
    }
}

extension WorkspacesInstancesClientTypes {

    /// Defines connection tracking parameters for network interfaces.
    public struct ConnectionTrackingSpecificationRequest: Swift.Sendable {
        /// Timeout for established TCP connections.
        public var tcpEstablishedTimeout: Swift.Int?
        /// Timeout for UDP stream connections.
        public var udpStreamTimeout: Swift.Int?
        /// General timeout for UDP connections.
        public var udpTimeout: Swift.Int?

        public init(
            tcpEstablishedTimeout: Swift.Int? = nil,
            udpStreamTimeout: Swift.Int? = nil,
            udpTimeout: Swift.Int? = nil
        ) {
            self.tcpEstablishedTimeout = tcpEstablishedTimeout
            self.udpStreamTimeout = udpStreamTimeout
            self.udpTimeout = udpTimeout
        }
    }
}

extension WorkspacesInstancesClientTypes {

    public enum CpuCreditsEnum: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case standard
        case unlimited
        case sdkUnknown(Swift.String)

        public static var allCases: [CpuCreditsEnum] {
            return [
                .standard,
                .unlimited
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .standard: return "standard"
            case .unlimited: return "unlimited"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension WorkspacesInstancesClientTypes {

    /// Configures CPU-specific settings for WorkSpace Instance.
    public struct CpuOptionsRequest: Swift.Sendable {
        /// AMD Secure Encrypted Virtualization configuration.
        public var amdSevSnp: WorkspacesInstancesClientTypes.AmdSevSnpEnum?
        /// Number of CPU cores to allocate.
        public var coreCount: Swift.Int?
        /// Number of threads per CPU core.
        public var threadsPerCore: Swift.Int?

        public init(
            amdSevSnp: WorkspacesInstancesClientTypes.AmdSevSnpEnum? = nil,
            coreCount: Swift.Int? = nil,
            threadsPerCore: Swift.Int? = nil
        ) {
            self.amdSevSnp = amdSevSnp
            self.coreCount = coreCount
            self.threadsPerCore = threadsPerCore
        }
    }
}

/// Indicates that a service quota has been exceeded.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// Description of the quota limitation.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// Specific code for the exceeded quota.
        /// This member is required.
        public internal(set) var quotaCode: Swift.String? = nil
        /// Identifier of the resource related to the quota.
        /// This member is required.
        public internal(set) var resourceId: Swift.String? = nil
        /// Type of resource related to the quota.
        /// This member is required.
        public internal(set) var resourceType: Swift.String? = nil
        /// Code identifying the service with the quota limitation.
        /// This member is required.
        public internal(set) var serviceCode: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        quotaCode: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil,
        serviceCode: Swift.String? = nil
    ) {
        self.properties.message = message
        self.properties.quotaCode = quotaCode
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
        self.properties.serviceCode = serviceCode
    }
}

extension WorkspacesInstancesClientTypes {

    public enum ResourceTypeEnum: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case instance
        case networkInterface
        case spotInstancesRequest
        case volume
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceTypeEnum] {
            return [
                .instance,
                .networkInterface,
                .spotInstancesRequest,
                .volume
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .instance: return "instance"
            case .networkInterface: return "network-interface"
            case .spotInstancesRequest: return "spot-instances-request"
            case .volume: return "volume"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension WorkspacesInstancesClientTypes {

    /// Represents a key-value metadata tag.
    public struct Tag: Swift.Sendable {
        /// Unique identifier for the tag.
        public var key: Swift.String?
        /// Value associated with the tag key.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        ) {
            self.key = key
            self.value = value
        }
    }
}

extension WorkspacesInstancesClientTypes {

    /// Defines tagging configuration for a resource.
    public struct TagSpecification: Swift.Sendable {
        /// Type of resource being tagged.
        public var resourceType: WorkspacesInstancesClientTypes.ResourceTypeEnum?
        /// Collection of tags for the specified resource.
        public var tags: [WorkspacesInstancesClientTypes.Tag]?

        public init(
            resourceType: WorkspacesInstancesClientTypes.ResourceTypeEnum? = nil,
            tags: [WorkspacesInstancesClientTypes.Tag]? = nil
        ) {
            self.resourceType = resourceType
            self.tags = tags
        }
    }
}

/// Specifies volume creation parameters.
public struct CreateVolumeInput: Swift.Sendable {
    /// Availability zone for the volume.
    /// This member is required.
    public var availabilityZone: Swift.String?
    /// Unique token to prevent duplicate volume creation.
    public var clientToken: Swift.String?
    /// Indicates if the volume should be encrypted.
    public var encrypted: Swift.Bool?
    /// Input/output operations per second for the volume.
    public var iops: Swift.Int?
    /// KMS key for volume encryption.
    public var kmsKeyId: Swift.String?
    /// Volume size in gigabytes.
    public var sizeInGB: Swift.Int?
    /// Source snapshot for volume creation.
    public var snapshotId: Swift.String?
    /// Metadata tags for the volume.
    public var tagSpecifications: [WorkspacesInstancesClientTypes.TagSpecification]?
    /// Volume throughput performance.
    public var throughput: Swift.Int?
    /// Type of EBS volume.
    public var volumeType: WorkspacesInstancesClientTypes.VolumeTypeEnum?

    public init(
        availabilityZone: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        encrypted: Swift.Bool? = nil,
        iops: Swift.Int? = nil,
        kmsKeyId: Swift.String? = nil,
        sizeInGB: Swift.Int? = nil,
        snapshotId: Swift.String? = nil,
        tagSpecifications: [WorkspacesInstancesClientTypes.TagSpecification]? = nil,
        throughput: Swift.Int? = nil,
        volumeType: WorkspacesInstancesClientTypes.VolumeTypeEnum? = nil
    ) {
        self.availabilityZone = availabilityZone
        self.clientToken = clientToken
        self.encrypted = encrypted
        self.iops = iops
        self.kmsKeyId = kmsKeyId
        self.sizeInGB = sizeInGB
        self.snapshotId = snapshotId
        self.tagSpecifications = tagSpecifications
        self.throughput = throughput
        self.volumeType = volumeType
    }
}

extension CreateVolumeInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateVolumeInput(availabilityZone: \(Swift.String(describing: availabilityZone)), encrypted: \(Swift.String(describing: encrypted)), iops: \(Swift.String(describing: iops)), sizeInGB: \(Swift.String(describing: sizeInGB)), snapshotId: \(Swift.String(describing: snapshotId)), tagSpecifications: \(Swift.String(describing: tagSpecifications)), throughput: \(Swift.String(describing: throughput)), volumeType: \(Swift.String(describing: volumeType)), clientToken: \"CONTENT_REDACTED\", kmsKeyId: \"CONTENT_REDACTED\")"}
}

/// Returns the created volume identifier.
public struct CreateVolumeOutput: Swift.Sendable {
    /// Unique identifier for the new volume.
    public var volumeId: Swift.String?

    public init(
        volumeId: Swift.String? = nil
    ) {
        self.volumeId = volumeId
    }
}

extension WorkspacesInstancesClientTypes {

    /// Defines CPU credit configuration for burstable instances.
    public struct CreditSpecificationRequest: Swift.Sendable {
        /// CPU credit specification mode.
        public var cpuCredits: WorkspacesInstancesClientTypes.CpuCreditsEnum?

        public init(
            cpuCredits: WorkspacesInstancesClientTypes.CpuCreditsEnum? = nil
        ) {
            self.cpuCredits = cpuCredits
        }
    }
}

extension WorkspacesInstancesClientTypes {

    /// Configures AWS Nitro Enclave options for the WorkSpace Instance.
    public struct EnclaveOptionsRequest: Swift.Sendable {
        /// Enables or disables AWS Nitro Enclaves for enhanced security.
        public var enabled: Swift.Bool?

        public init(
            enabled: Swift.Bool? = nil
        ) {
            self.enabled = enabled
        }
    }
}

extension WorkspacesInstancesClientTypes {

    /// Defines hibernation configuration for the WorkSpace Instance.
    public struct HibernationOptionsRequest: Swift.Sendable {
        /// Enables or disables instance hibernation capability.
        public var configured: Swift.Bool?

        public init(
            configured: Swift.Bool? = nil
        ) {
            self.configured = configured
        }
    }
}

extension WorkspacesInstancesClientTypes {

    /// Defines IAM instance profile configuration for WorkSpace Instance.
    public struct IamInstanceProfileSpecification: Swift.Sendable {
        /// Amazon Resource Name (ARN) of the IAM instance profile.
        public var arn: Swift.String?
        /// Name of the IAM instance profile.
        public var name: Swift.String?

        public init(
            arn: Swift.String? = nil,
            name: Swift.String? = nil
        ) {
            self.arn = arn
            self.name = name
        }
    }
}

extension WorkspacesInstancesClientTypes {

    public enum MarketTypeEnum: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case capacityBlock
        case spot
        case sdkUnknown(Swift.String)

        public static var allCases: [MarketTypeEnum] {
            return [
                .capacityBlock,
                .spot
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .capacityBlock: return "capacity-block"
            case .spot: return "spot"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension WorkspacesInstancesClientTypes {

    public enum InstanceInterruptionBehaviorEnum: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case hibernate
        case stop
        case sdkUnknown(Swift.String)

        public static var allCases: [InstanceInterruptionBehaviorEnum] {
            return [
                .hibernate,
                .stop
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .hibernate: return "hibernate"
            case .stop: return "stop"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension WorkspacesInstancesClientTypes {

    public enum SpotInstanceTypeEnum: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case oneTime
        case persistent
        case sdkUnknown(Swift.String)

        public static var allCases: [SpotInstanceTypeEnum] {
            return [
                .oneTime,
                .persistent
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .oneTime: return "one-time"
            case .persistent: return "persistent"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension WorkspacesInstancesClientTypes {

    /// Defines configuration for spot instance deployment.
    public struct SpotMarketOptions: Swift.Sendable {
        /// Duration of spot instance block reservation.
        public var blockDurationMinutes: Swift.Int?
        /// Specifies behavior when spot instance is interrupted.
        public var instanceInterruptionBehavior: WorkspacesInstancesClientTypes.InstanceInterruptionBehaviorEnum?
        /// Maximum hourly price for spot instance.
        public var maxPrice: Swift.String?
        /// Defines the type of spot instance request.
        public var spotInstanceType: WorkspacesInstancesClientTypes.SpotInstanceTypeEnum?
        /// Timestamp until which spot instance request is valid.
        public var validUntilUtc: Foundation.Date?

        public init(
            blockDurationMinutes: Swift.Int? = nil,
            instanceInterruptionBehavior: WorkspacesInstancesClientTypes.InstanceInterruptionBehaviorEnum? = nil,
            maxPrice: Swift.String? = nil,
            spotInstanceType: WorkspacesInstancesClientTypes.SpotInstanceTypeEnum? = nil,
            validUntilUtc: Foundation.Date? = nil
        ) {
            self.blockDurationMinutes = blockDurationMinutes
            self.instanceInterruptionBehavior = instanceInterruptionBehavior
            self.maxPrice = maxPrice
            self.spotInstanceType = spotInstanceType
            self.validUntilUtc = validUntilUtc
        }
    }
}

extension WorkspacesInstancesClientTypes {

    /// Configures marketplace-specific instance deployment options.
    public struct InstanceMarketOptionsRequest: Swift.Sendable {
        /// Specifies the type of marketplace for instance deployment.
        public var marketType: WorkspacesInstancesClientTypes.MarketTypeEnum?
        /// Configuration options for spot instance deployment.
        public var spotOptions: WorkspacesInstancesClientTypes.SpotMarketOptions?

        public init(
            marketType: WorkspacesInstancesClientTypes.MarketTypeEnum? = nil,
            spotOptions: WorkspacesInstancesClientTypes.SpotMarketOptions? = nil
        ) {
            self.marketType = marketType
            self.spotOptions = spotOptions
        }
    }
}

extension WorkspacesInstancesClientTypes {

    /// Represents an IPv6 address configuration for a WorkSpace Instance.
    public struct InstanceIpv6Address: Swift.Sendable {
        /// Specific IPv6 address assigned to the instance.
        public var ipv6Address: Swift.String?
        /// Indicates if this is the primary IPv6 address for the instance.
        public var isPrimaryIpv6: Swift.Bool?

        public init(
            ipv6Address: Swift.String? = nil,
            isPrimaryIpv6: Swift.Bool? = nil
        ) {
            self.ipv6Address = ipv6Address
            self.isPrimaryIpv6 = isPrimaryIpv6
        }
    }
}

extension WorkspacesInstancesClientTypes.InstanceIpv6Address: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InstanceIpv6Address(isPrimaryIpv6: \(Swift.String(describing: isPrimaryIpv6)), ipv6Address: \"CONTENT_REDACTED\")"}
}

extension WorkspacesInstancesClientTypes {

    /// Specifies license configuration for WorkSpace Instance.
    public struct LicenseConfigurationRequest: Swift.Sendable {
        /// ARN of the license configuration for the WorkSpace Instance.
        public var licenseConfigurationArn: Swift.String?

        public init(
            licenseConfigurationArn: Swift.String? = nil
        ) {
            self.licenseConfigurationArn = licenseConfigurationArn
        }
    }
}

extension WorkspacesInstancesClientTypes {

    /// Configures automatic maintenance settings for WorkSpace Instance.
    public struct InstanceMaintenanceOptionsRequest: Swift.Sendable {
        /// Enables or disables automatic instance recovery.
        public var autoRecovery: WorkspacesInstancesClientTypes.AutoRecoveryEnum?

        public init(
            autoRecovery: WorkspacesInstancesClientTypes.AutoRecoveryEnum? = nil
        ) {
            self.autoRecovery = autoRecovery
        }
    }
}

extension WorkspacesInstancesClientTypes {

    public enum HttpEndpointEnum: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [HttpEndpointEnum] {
            return [
                .disabled,
                .enabled
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "disabled"
            case .enabled: return "enabled"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension WorkspacesInstancesClientTypes {

    public enum HttpProtocolIpv6Enum: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [HttpProtocolIpv6Enum] {
            return [
                .disabled,
                .enabled
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "disabled"
            case .enabled: return "enabled"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension WorkspacesInstancesClientTypes {

    public enum HttpTokensEnum: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case `optional`
        case `required`
        case sdkUnknown(Swift.String)

        public static var allCases: [HttpTokensEnum] {
            return [
                .optional,
                .required
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .optional: return "optional"
            case .required: return "required"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension WorkspacesInstancesClientTypes {

    public enum InstanceMetadataTagsEnum: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [InstanceMetadataTagsEnum] {
            return [
                .disabled,
                .enabled
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "disabled"
            case .enabled: return "enabled"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension WorkspacesInstancesClientTypes {

    /// Defines instance metadata service configuration.
    public struct InstanceMetadataOptionsRequest: Swift.Sendable {
        /// Enables or disables HTTP endpoint for instance metadata.
        public var httpEndpoint: WorkspacesInstancesClientTypes.HttpEndpointEnum?
        /// Configures IPv6 support for instance metadata HTTP protocol.
        public var httpProtocolIpv6: WorkspacesInstancesClientTypes.HttpProtocolIpv6Enum?
        /// Sets maximum number of network hops for metadata PUT responses.
        public var httpPutResponseHopLimit: Swift.Int?
        /// Configures token requirement for instance metadata retrieval.
        public var httpTokens: WorkspacesInstancesClientTypes.HttpTokensEnum?
        /// Enables or disables instance metadata tags retrieval.
        public var instanceMetadataTags: WorkspacesInstancesClientTypes.InstanceMetadataTagsEnum?

        public init(
            httpEndpoint: WorkspacesInstancesClientTypes.HttpEndpointEnum? = nil,
            httpProtocolIpv6: WorkspacesInstancesClientTypes.HttpProtocolIpv6Enum? = nil,
            httpPutResponseHopLimit: Swift.Int? = nil,
            httpTokens: WorkspacesInstancesClientTypes.HttpTokensEnum? = nil,
            instanceMetadataTags: WorkspacesInstancesClientTypes.InstanceMetadataTagsEnum? = nil
        ) {
            self.httpEndpoint = httpEndpoint
            self.httpProtocolIpv6 = httpProtocolIpv6
            self.httpPutResponseHopLimit = httpPutResponseHopLimit
            self.httpTokens = httpTokens
            self.instanceMetadataTags = instanceMetadataTags
        }
    }
}

extension WorkspacesInstancesClientTypes {

    /// Configures detailed monitoring for WorkSpace Instance.
    public struct RunInstancesMonitoringEnabled: Swift.Sendable {
        /// Enables or disables detailed instance monitoring.
        public var enabled: Swift.Bool?

        public init(
            enabled: Swift.Bool? = nil
        ) {
            self.enabled = enabled
        }
    }
}

extension WorkspacesInstancesClientTypes {

    /// Specifies UDP configuration for ENA SRD.
    public struct EnaSrdUdpSpecificationRequest: Swift.Sendable {
        /// Enables or disables ENA SRD for UDP traffic.
        public var enaSrdUdpEnabled: Swift.Bool?

        public init(
            enaSrdUdpEnabled: Swift.Bool? = nil
        ) {
            self.enaSrdUdpEnabled = enaSrdUdpEnabled
        }
    }
}

extension WorkspacesInstancesClientTypes {

    /// Defines Elastic Network Adapter (ENA) Scalable Reliable Datagram (SRD) configuration.
    public struct EnaSrdSpecificationRequest: Swift.Sendable {
        /// Enables or disables ENA SRD for network performance.
        public var enaSrdEnabled: Swift.Bool?
        /// Configures UDP-specific ENA SRD settings.
        public var enaSrdUdpSpecification: WorkspacesInstancesClientTypes.EnaSrdUdpSpecificationRequest?

        public init(
            enaSrdEnabled: Swift.Bool? = nil,
            enaSrdUdpSpecification: WorkspacesInstancesClientTypes.EnaSrdUdpSpecificationRequest? = nil
        ) {
            self.enaSrdEnabled = enaSrdEnabled
            self.enaSrdUdpSpecification = enaSrdUdpSpecification
        }
    }
}

extension WorkspacesInstancesClientTypes {

    public enum InterfaceTypeEnum: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case efa
        case efaOnly
        case interface
        case sdkUnknown(Swift.String)

        public static var allCases: [InterfaceTypeEnum] {
            return [
                .efa,
                .efaOnly,
                .interface
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .efa: return "efa"
            case .efaOnly: return "efa-only"
            case .interface: return "interface"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension WorkspacesInstancesClientTypes {

    /// Specifies IPv4 prefix configuration for network interfaces.
    public struct Ipv4PrefixSpecificationRequest: Swift.Sendable {
        /// Specific IPv4 prefix for network interface configuration.
        public var ipv4Prefix: Swift.String?

        public init(
            ipv4Prefix: Swift.String? = nil
        ) {
            self.ipv4Prefix = ipv4Prefix
        }
    }
}

extension WorkspacesInstancesClientTypes {

    /// Specifies IPv6 prefix configuration for network interfaces.
    public struct Ipv6PrefixSpecificationRequest: Swift.Sendable {
        /// Specific IPv6 prefix for network interface configuration.
        public var ipv6Prefix: Swift.String?

        public init(
            ipv6Prefix: Swift.String? = nil
        ) {
            self.ipv6Prefix = ipv6Prefix
        }
    }
}

extension WorkspacesInstancesClientTypes {

    /// Defines private IP address configuration for network interface.
    public struct PrivateIpAddressSpecification: Swift.Sendable {
        /// Indicates if this is the primary private IP address.
        public var primary: Swift.Bool?
        /// Specific private IP address for the network interface.
        public var privateIpAddress: Swift.String?

        public init(
            primary: Swift.Bool? = nil,
            privateIpAddress: Swift.String? = nil
        ) {
            self.primary = primary
            self.privateIpAddress = privateIpAddress
        }
    }
}

extension WorkspacesInstancesClientTypes.PrivateIpAddressSpecification: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PrivateIpAddressSpecification(primary: \(Swift.String(describing: primary)), privateIpAddress: \"CONTENT_REDACTED\")"}
}

extension WorkspacesInstancesClientTypes {

    /// Defines network interface configuration for WorkSpace Instance.
    public struct InstanceNetworkInterfaceSpecification: Swift.Sendable {
        /// Enables carrier IP address association.
        public var associateCarrierIpAddress: Swift.Bool?
        /// Enables public IP address assignment.
        public var associatePublicIpAddress: Swift.Bool?
        /// Configures network connection tracking parameters.
        public var connectionTrackingSpecification: WorkspacesInstancesClientTypes.ConnectionTrackingSpecificationRequest?
        /// Descriptive text for the network interface.
        public var description: Swift.String?
        /// Unique index for the network interface.
        public var deviceIndex: Swift.Int?
        /// Configures Elastic Network Adapter Scalable Reliable Datagram settings.
        public var enaSrdSpecification: WorkspacesInstancesClientTypes.EnaSrdSpecificationRequest?
        /// Security groups associated with the network interface.
        public var groups: [Swift.String]?
        /// Specifies the type of network interface.
        public var interfaceType: WorkspacesInstancesClientTypes.InterfaceTypeEnum?
        /// Number of IPv4 prefixes to assign.
        public var ipv4PrefixCount: Swift.Int?
        /// IPv4 prefix configurations for the interface.
        public var ipv4Prefixes: [WorkspacesInstancesClientTypes.Ipv4PrefixSpecificationRequest]?
        /// Number of IPv6 addresses to assign.
        public var ipv6AddressCount: Swift.Int?
        /// Specific IPv6 addresses for the interface.
        public var ipv6Addresses: [WorkspacesInstancesClientTypes.InstanceIpv6Address]?
        /// Number of IPv6 prefixes to assign.
        public var ipv6PrefixCount: Swift.Int?
        /// IPv6 prefix configurations for the interface.
        public var ipv6Prefixes: [WorkspacesInstancesClientTypes.Ipv6PrefixSpecificationRequest]?
        /// Index of the network card for multiple network interfaces.
        public var networkCardIndex: Swift.Int?
        /// Unique identifier for the network interface.
        public var networkInterfaceId: Swift.String?
        /// Indicates the primary IPv6 configuration.
        public var primaryIpv6: Swift.Bool?
        /// Primary private IP address for the interface.
        public var privateIpAddress: Swift.String?
        /// List of private IP addresses for the interface.
        public var privateIpAddresses: [WorkspacesInstancesClientTypes.PrivateIpAddressSpecification]?
        /// Number of additional private IP addresses to assign.
        public var secondaryPrivateIpAddressCount: Swift.Int?
        /// Subnet identifier for the network interface.
        public var subnetId: Swift.String?

        public init(
            associateCarrierIpAddress: Swift.Bool? = nil,
            associatePublicIpAddress: Swift.Bool? = nil,
            connectionTrackingSpecification: WorkspacesInstancesClientTypes.ConnectionTrackingSpecificationRequest? = nil,
            description: Swift.String? = nil,
            deviceIndex: Swift.Int? = nil,
            enaSrdSpecification: WorkspacesInstancesClientTypes.EnaSrdSpecificationRequest? = nil,
            groups: [Swift.String]? = nil,
            interfaceType: WorkspacesInstancesClientTypes.InterfaceTypeEnum? = nil,
            ipv4PrefixCount: Swift.Int? = nil,
            ipv4Prefixes: [WorkspacesInstancesClientTypes.Ipv4PrefixSpecificationRequest]? = nil,
            ipv6AddressCount: Swift.Int? = nil,
            ipv6Addresses: [WorkspacesInstancesClientTypes.InstanceIpv6Address]? = nil,
            ipv6PrefixCount: Swift.Int? = nil,
            ipv6Prefixes: [WorkspacesInstancesClientTypes.Ipv6PrefixSpecificationRequest]? = nil,
            networkCardIndex: Swift.Int? = nil,
            networkInterfaceId: Swift.String? = nil,
            primaryIpv6: Swift.Bool? = nil,
            privateIpAddress: Swift.String? = nil,
            privateIpAddresses: [WorkspacesInstancesClientTypes.PrivateIpAddressSpecification]? = nil,
            secondaryPrivateIpAddressCount: Swift.Int? = nil,
            subnetId: Swift.String? = nil
        ) {
            self.associateCarrierIpAddress = associateCarrierIpAddress
            self.associatePublicIpAddress = associatePublicIpAddress
            self.connectionTrackingSpecification = connectionTrackingSpecification
            self.description = description
            self.deviceIndex = deviceIndex
            self.enaSrdSpecification = enaSrdSpecification
            self.groups = groups
            self.interfaceType = interfaceType
            self.ipv4PrefixCount = ipv4PrefixCount
            self.ipv4Prefixes = ipv4Prefixes
            self.ipv6AddressCount = ipv6AddressCount
            self.ipv6Addresses = ipv6Addresses
            self.ipv6PrefixCount = ipv6PrefixCount
            self.ipv6Prefixes = ipv6Prefixes
            self.networkCardIndex = networkCardIndex
            self.networkInterfaceId = networkInterfaceId
            self.primaryIpv6 = primaryIpv6
            self.privateIpAddress = privateIpAddress
            self.privateIpAddresses = privateIpAddresses
            self.secondaryPrivateIpAddressCount = secondaryPrivateIpAddressCount
            self.subnetId = subnetId
        }
    }
}

extension WorkspacesInstancesClientTypes.InstanceNetworkInterfaceSpecification: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InstanceNetworkInterfaceSpecification(associateCarrierIpAddress: \(Swift.String(describing: associateCarrierIpAddress)), associatePublicIpAddress: \(Swift.String(describing: associatePublicIpAddress)), connectionTrackingSpecification: \(Swift.String(describing: connectionTrackingSpecification)), description: \(Swift.String(describing: description)), deviceIndex: \(Swift.String(describing: deviceIndex)), enaSrdSpecification: \(Swift.String(describing: enaSrdSpecification)), groups: \(Swift.String(describing: groups)), interfaceType: \(Swift.String(describing: interfaceType)), ipv4PrefixCount: \(Swift.String(describing: ipv4PrefixCount)), ipv4Prefixes: \(Swift.String(describing: ipv4Prefixes)), ipv6AddressCount: \(Swift.String(describing: ipv6AddressCount)), ipv6Addresses: \(Swift.String(describing: ipv6Addresses)), ipv6PrefixCount: \(Swift.String(describing: ipv6PrefixCount)), ipv6Prefixes: \(Swift.String(describing: ipv6Prefixes)), networkCardIndex: \(Swift.String(describing: networkCardIndex)), networkInterfaceId: \(Swift.String(describing: networkInterfaceId)), primaryIpv6: \(Swift.String(describing: primaryIpv6)), privateIpAddresses: \(Swift.String(describing: privateIpAddresses)), secondaryPrivateIpAddressCount: \(Swift.String(describing: secondaryPrivateIpAddressCount)), subnetId: \(Swift.String(describing: subnetId)), privateIpAddress: \"CONTENT_REDACTED\")"}
}

extension WorkspacesInstancesClientTypes {

    /// Configures network performance settings for WorkSpace Instance.
    public struct InstanceNetworkPerformanceOptionsRequest: Swift.Sendable {
        /// Defines bandwidth allocation strategy for network interfaces.
        public var bandwidthWeighting: WorkspacesInstancesClientTypes.BandwidthWeightingEnum?

        public init(
            bandwidthWeighting: WorkspacesInstancesClientTypes.BandwidthWeightingEnum? = nil
        ) {
            self.bandwidthWeighting = bandwidthWeighting
        }
    }
}

extension WorkspacesInstancesClientTypes {

    public enum TenancyEnum: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case dedicated
        case `default`
        case host
        case sdkUnknown(Swift.String)

        public static var allCases: [TenancyEnum] {
            return [
                .dedicated,
                .default,
                .host
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .dedicated: return "dedicated"
            case .default: return "default"
            case .host: return "host"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension WorkspacesInstancesClientTypes {

    /// Defines instance placement configuration for WorkSpace Instance.
    public struct Placement: Swift.Sendable {
        /// Specifies host affinity for dedicated instances.
        public var affinity: Swift.String?
        /// Identifies the specific AWS availability zone.
        public var availabilityZone: Swift.String?
        /// Unique identifier for placement group.
        public var groupId: Swift.String?
        /// Name of the placement group.
        public var groupName: Swift.String?
        /// Identifies the specific dedicated host.
        public var hostId: Swift.String?
        /// ARN of the host resource group.
        public var hostResourceGroupArn: Swift.String?
        /// Specifies partition number for partition placement groups.
        public var partitionNumber: Swift.Int?
        /// Defines instance tenancy configuration.
        public var tenancy: WorkspacesInstancesClientTypes.TenancyEnum?

        public init(
            affinity: Swift.String? = nil,
            availabilityZone: Swift.String? = nil,
            groupId: Swift.String? = nil,
            groupName: Swift.String? = nil,
            hostId: Swift.String? = nil,
            hostResourceGroupArn: Swift.String? = nil,
            partitionNumber: Swift.Int? = nil,
            tenancy: WorkspacesInstancesClientTypes.TenancyEnum? = nil
        ) {
            self.affinity = affinity
            self.availabilityZone = availabilityZone
            self.groupId = groupId
            self.groupName = groupName
            self.hostId = hostId
            self.hostResourceGroupArn = hostResourceGroupArn
            self.partitionNumber = partitionNumber
            self.tenancy = tenancy
        }
    }
}

extension WorkspacesInstancesClientTypes {

    public enum HostnameTypeEnum: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case ipName
        case resourceName
        case sdkUnknown(Swift.String)

        public static var allCases: [HostnameTypeEnum] {
            return [
                .ipName,
                .resourceName
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .ipName: return "ip-name"
            case .resourceName: return "resource-name"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension WorkspacesInstancesClientTypes {

    /// Configures private DNS name settings for WorkSpace Instance.
    public struct PrivateDnsNameOptionsRequest: Swift.Sendable {
        /// Enables DNS AAAA record for resource name resolution.
        public var enableResourceNameDnsAAAARecord: Swift.Bool?
        /// Enables DNS A record for resource name resolution.
        public var enableResourceNameDnsARecord: Swift.Bool?
        /// Specifies the type of hostname configuration.
        public var hostnameType: WorkspacesInstancesClientTypes.HostnameTypeEnum?

        public init(
            enableResourceNameDnsAAAARecord: Swift.Bool? = nil,
            enableResourceNameDnsARecord: Swift.Bool? = nil,
            hostnameType: WorkspacesInstancesClientTypes.HostnameTypeEnum? = nil
        ) {
            self.enableResourceNameDnsAAAARecord = enableResourceNameDnsAAAARecord
            self.enableResourceNameDnsARecord = enableResourceNameDnsARecord
            self.hostnameType = hostnameType
        }
    }
}

extension WorkspacesInstancesClientTypes {

    /// Defines comprehensive configuration for a managed WorkSpace Instance.
    public struct ManagedInstanceRequest: Swift.Sendable {
        /// Configures block device mappings for storage.
        public var blockDeviceMappings: [WorkspacesInstancesClientTypes.BlockDeviceMappingRequest]?
        /// Specifies capacity reservation preferences.
        public var capacityReservationSpecification: WorkspacesInstancesClientTypes.CapacityReservationSpecification?
        /// Configures CPU-specific settings.
        public var cpuOptions: WorkspacesInstancesClientTypes.CpuOptionsRequest?
        /// Defines CPU credit configuration for burstable instances.
        public var creditSpecification: WorkspacesInstancesClientTypes.CreditSpecificationRequest?
        /// Prevents API-initiated instance stop.
        public var disableApiStop: Swift.Bool?
        /// Enables optimized EBS performance.
        public var ebsOptimized: Swift.Bool?
        /// Enables primary IPv6 address configuration.
        public var enablePrimaryIpv6: Swift.Bool?
        /// Configures AWS Nitro Enclave settings.
        public var enclaveOptions: WorkspacesInstancesClientTypes.EnclaveOptionsRequest?
        /// Configures instance hibernation capabilities.
        public var hibernationOptions: WorkspacesInstancesClientTypes.HibernationOptionsRequest?
        /// Specifies IAM instance profile configuration.
        public var iamInstanceProfile: WorkspacesInstancesClientTypes.IamInstanceProfileSpecification?
        /// Identifies the Amazon Machine Image (AMI) for the instance.
        public var imageId: Swift.String?
        /// Configures marketplace-specific deployment options.
        public var instanceMarketOptions: WorkspacesInstancesClientTypes.InstanceMarketOptionsRequest?
        /// Specifies the WorkSpace Instance type.
        public var instanceType: Swift.String?
        /// Specifies number of IPv6 addresses to assign.
        public var ipv6AddressCount: Swift.Int?
        /// Configures specific IPv6 addresses.
        public var ipv6Addresses: [WorkspacesInstancesClientTypes.InstanceIpv6Address]?
        /// Identifies the kernel for the instance.
        public var kernelId: Swift.String?
        /// Specifies the key pair for instance access.
        public var keyName: Swift.String?
        /// Configures license-related settings.
        public var licenseSpecifications: [WorkspacesInstancesClientTypes.LicenseConfigurationRequest]?
        /// Defines automatic maintenance settings.
        public var maintenanceOptions: WorkspacesInstancesClientTypes.InstanceMaintenanceOptionsRequest?
        /// Configures instance metadata service settings.
        public var metadataOptions: WorkspacesInstancesClientTypes.InstanceMetadataOptionsRequest?
        /// Enables or disables detailed instance monitoring.
        public var monitoring: WorkspacesInstancesClientTypes.RunInstancesMonitoringEnabled?
        /// Configures network interface settings.
        public var networkInterfaces: [WorkspacesInstancesClientTypes.InstanceNetworkInterfaceSpecification]?
        /// Defines network performance configuration.
        public var networkPerformanceOptions: WorkspacesInstancesClientTypes.InstanceNetworkPerformanceOptionsRequest?
        /// Specifies instance placement preferences.
        public var placement: WorkspacesInstancesClientTypes.Placement?
        /// Configures private DNS name settings.
        public var privateDnsNameOptions: WorkspacesInstancesClientTypes.PrivateDnsNameOptionsRequest?
        /// Specifies the primary private IP address.
        public var privateIpAddress: Swift.String?
        /// Identifies the ramdisk for the instance.
        public var ramdiskId: Swift.String?
        /// Specifies security group identifiers.
        public var securityGroupIds: [Swift.String]?
        /// Configures security group settings.
        public var securityGroups: [Swift.String]?
        /// Identifies the subnet for the instance.
        public var subnetId: Swift.String?
        /// Configures resource tagging specifications.
        public var tagSpecifications: [WorkspacesInstancesClientTypes.TagSpecification]?
        /// Provides custom initialization data for the instance.
        public var userData: Swift.String?

        public init(
            blockDeviceMappings: [WorkspacesInstancesClientTypes.BlockDeviceMappingRequest]? = nil,
            capacityReservationSpecification: WorkspacesInstancesClientTypes.CapacityReservationSpecification? = nil,
            cpuOptions: WorkspacesInstancesClientTypes.CpuOptionsRequest? = nil,
            creditSpecification: WorkspacesInstancesClientTypes.CreditSpecificationRequest? = nil,
            disableApiStop: Swift.Bool? = nil,
            ebsOptimized: Swift.Bool? = nil,
            enablePrimaryIpv6: Swift.Bool? = nil,
            enclaveOptions: WorkspacesInstancesClientTypes.EnclaveOptionsRequest? = nil,
            hibernationOptions: WorkspacesInstancesClientTypes.HibernationOptionsRequest? = nil,
            iamInstanceProfile: WorkspacesInstancesClientTypes.IamInstanceProfileSpecification? = nil,
            imageId: Swift.String? = nil,
            instanceMarketOptions: WorkspacesInstancesClientTypes.InstanceMarketOptionsRequest? = nil,
            instanceType: Swift.String? = nil,
            ipv6AddressCount: Swift.Int? = nil,
            ipv6Addresses: [WorkspacesInstancesClientTypes.InstanceIpv6Address]? = nil,
            kernelId: Swift.String? = nil,
            keyName: Swift.String? = nil,
            licenseSpecifications: [WorkspacesInstancesClientTypes.LicenseConfigurationRequest]? = nil,
            maintenanceOptions: WorkspacesInstancesClientTypes.InstanceMaintenanceOptionsRequest? = nil,
            metadataOptions: WorkspacesInstancesClientTypes.InstanceMetadataOptionsRequest? = nil,
            monitoring: WorkspacesInstancesClientTypes.RunInstancesMonitoringEnabled? = nil,
            networkInterfaces: [WorkspacesInstancesClientTypes.InstanceNetworkInterfaceSpecification]? = nil,
            networkPerformanceOptions: WorkspacesInstancesClientTypes.InstanceNetworkPerformanceOptionsRequest? = nil,
            placement: WorkspacesInstancesClientTypes.Placement? = nil,
            privateDnsNameOptions: WorkspacesInstancesClientTypes.PrivateDnsNameOptionsRequest? = nil,
            privateIpAddress: Swift.String? = nil,
            ramdiskId: Swift.String? = nil,
            securityGroupIds: [Swift.String]? = nil,
            securityGroups: [Swift.String]? = nil,
            subnetId: Swift.String? = nil,
            tagSpecifications: [WorkspacesInstancesClientTypes.TagSpecification]? = nil,
            userData: Swift.String? = nil
        ) {
            self.blockDeviceMappings = blockDeviceMappings
            self.capacityReservationSpecification = capacityReservationSpecification
            self.cpuOptions = cpuOptions
            self.creditSpecification = creditSpecification
            self.disableApiStop = disableApiStop
            self.ebsOptimized = ebsOptimized
            self.enablePrimaryIpv6 = enablePrimaryIpv6
            self.enclaveOptions = enclaveOptions
            self.hibernationOptions = hibernationOptions
            self.iamInstanceProfile = iamInstanceProfile
            self.imageId = imageId
            self.instanceMarketOptions = instanceMarketOptions
            self.instanceType = instanceType
            self.ipv6AddressCount = ipv6AddressCount
            self.ipv6Addresses = ipv6Addresses
            self.kernelId = kernelId
            self.keyName = keyName
            self.licenseSpecifications = licenseSpecifications
            self.maintenanceOptions = maintenanceOptions
            self.metadataOptions = metadataOptions
            self.monitoring = monitoring
            self.networkInterfaces = networkInterfaces
            self.networkPerformanceOptions = networkPerformanceOptions
            self.placement = placement
            self.privateDnsNameOptions = privateDnsNameOptions
            self.privateIpAddress = privateIpAddress
            self.ramdiskId = ramdiskId
            self.securityGroupIds = securityGroupIds
            self.securityGroups = securityGroups
            self.subnetId = subnetId
            self.tagSpecifications = tagSpecifications
            self.userData = userData
        }
    }
}

extension WorkspacesInstancesClientTypes.ManagedInstanceRequest: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ManagedInstanceRequest(blockDeviceMappings: \(Swift.String(describing: blockDeviceMappings)), capacityReservationSpecification: \(Swift.String(describing: capacityReservationSpecification)), cpuOptions: \(Swift.String(describing: cpuOptions)), creditSpecification: \(Swift.String(describing: creditSpecification)), disableApiStop: \(Swift.String(describing: disableApiStop)), ebsOptimized: \(Swift.String(describing: ebsOptimized)), enablePrimaryIpv6: \(Swift.String(describing: enablePrimaryIpv6)), enclaveOptions: \(Swift.String(describing: enclaveOptions)), hibernationOptions: \(Swift.String(describing: hibernationOptions)), iamInstanceProfile: \(Swift.String(describing: iamInstanceProfile)), imageId: \(Swift.String(describing: imageId)), instanceMarketOptions: \(Swift.String(describing: instanceMarketOptions)), instanceType: \(Swift.String(describing: instanceType)), ipv6AddressCount: \(Swift.String(describing: ipv6AddressCount)), ipv6Addresses: \(Swift.String(describing: ipv6Addresses)), kernelId: \(Swift.String(describing: kernelId)), keyName: \(Swift.String(describing: keyName)), licenseSpecifications: \(Swift.String(describing: licenseSpecifications)), maintenanceOptions: \(Swift.String(describing: maintenanceOptions)), metadataOptions: \(Swift.String(describing: metadataOptions)), monitoring: \(Swift.String(describing: monitoring)), networkInterfaces: \(Swift.String(describing: networkInterfaces)), networkPerformanceOptions: \(Swift.String(describing: networkPerformanceOptions)), placement: \(Swift.String(describing: placement)), privateDnsNameOptions: \(Swift.String(describing: privateDnsNameOptions)), ramdiskId: \(Swift.String(describing: ramdiskId)), securityGroupIds: \(Swift.String(describing: securityGroupIds)), securityGroups: \(Swift.String(describing: securityGroups)), subnetId: \(Swift.String(describing: subnetId)), tagSpecifications: \(Swift.String(describing: tagSpecifications)), privateIpAddress: \"CONTENT_REDACTED\", userData: \"CONTENT_REDACTED\")"}
}

/// Defines the configuration parameters for creating a new WorkSpaces Instance.
public struct CreateWorkspaceInstanceInput: Swift.Sendable {
    /// Optional billing configuration for the WorkSpace Instance. Allows customers to specify their preferred billing mode when creating a new instance. Defaults to hourly billing if not specified.
    public var billingConfiguration: WorkspacesInstancesClientTypes.BillingConfiguration?
    /// Unique token to ensure idempotent instance creation, preventing duplicate workspace launches.
    public var clientToken: Swift.String?
    /// Comprehensive configuration settings for the WorkSpaces Instance, including network, compute, and storage parameters.
    /// This member is required.
    public var managedInstance: WorkspacesInstancesClientTypes.ManagedInstanceRequest?
    /// Optional metadata tags for categorizing and managing WorkSpaces Instances.
    public var tags: [WorkspacesInstancesClientTypes.Tag]?

    public init(
        billingConfiguration: WorkspacesInstancesClientTypes.BillingConfiguration? = nil,
        clientToken: Swift.String? = nil,
        managedInstance: WorkspacesInstancesClientTypes.ManagedInstanceRequest? = nil,
        tags: [WorkspacesInstancesClientTypes.Tag]? = nil
    ) {
        self.billingConfiguration = billingConfiguration
        self.clientToken = clientToken
        self.managedInstance = managedInstance
        self.tags = tags
    }
}

extension CreateWorkspaceInstanceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateWorkspaceInstanceInput(billingConfiguration: \(Swift.String(describing: billingConfiguration)), managedInstance: \(Swift.String(describing: managedInstance)), tags: \(Swift.String(describing: tags)), clientToken: \"CONTENT_REDACTED\")"}
}

/// Returns the unique identifier for the newly created WorkSpaces Instance.
public struct CreateWorkspaceInstanceOutput: Swift.Sendable {
    /// Unique identifier assigned to the newly created WorkSpaces Instance.
    public var workspaceInstanceId: Swift.String?

    public init(
        workspaceInstanceId: Swift.String? = nil
    ) {
        self.workspaceInstanceId = workspaceInstanceId
    }
}

/// Specifies the volume to delete.
public struct DeleteVolumeInput: Swift.Sendable {
    /// Identifier of the volume to delete.
    /// This member is required.
    public var volumeId: Swift.String?

    public init(
        volumeId: Swift.String? = nil
    ) {
        self.volumeId = volumeId
    }
}

/// Confirms volume deletion.
public struct DeleteVolumeOutput: Swift.Sendable {

    public init() { }
}

/// The WorkSpace to delete
public struct DeleteWorkspaceInstanceInput: Swift.Sendable {
    /// Unique identifier of the WorkSpaces Instance targeted for deletion.
    /// This member is required.
    public var workspaceInstanceId: Swift.String?

    public init(
        workspaceInstanceId: Swift.String? = nil
    ) {
        self.workspaceInstanceId = workspaceInstanceId
    }
}

/// Confirms the successful deletion of the specified WorkSpace Instance.
public struct DeleteWorkspaceInstanceOutput: Swift.Sendable {

    public init() { }
}

extension WorkspacesInstancesClientTypes {

    public enum DisassociateModeEnum: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case force
        case noForce
        case sdkUnknown(Swift.String)

        public static var allCases: [DisassociateModeEnum] {
            return [
                .force,
                .noForce
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .force: return "FORCE"
            case .noForce: return "NO_FORCE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// Specifies volume detachment parameters.
public struct DisassociateVolumeInput: Swift.Sendable {
    /// Device path of volume to detach.
    public var device: Swift.String?
    /// Mode for volume detachment.
    public var disassociateMode: WorkspacesInstancesClientTypes.DisassociateModeEnum?
    /// Volume to be detached.
    /// This member is required.
    public var volumeId: Swift.String?
    /// WorkSpace Instance to detach volume from.
    /// This member is required.
    public var workspaceInstanceId: Swift.String?

    public init(
        device: Swift.String? = nil,
        disassociateMode: WorkspacesInstancesClientTypes.DisassociateModeEnum? = nil,
        volumeId: Swift.String? = nil,
        workspaceInstanceId: Swift.String? = nil
    ) {
        self.device = device
        self.disassociateMode = disassociateMode
        self.volumeId = volumeId
        self.workspaceInstanceId = workspaceInstanceId
    }
}

/// Confirms volume detachment.
public struct DisassociateVolumeOutput: Swift.Sendable {

    public init() { }
}

extension WorkspacesInstancesClientTypes {

    /// Captures detailed error information for EC2 instance operations.
    public struct EC2InstanceError: Swift.Sendable {
        /// Unique error code identifying the specific EC2 instance error.
        public var ec2ErrorCode: Swift.String?
        /// Detailed description of the EC2 instance error.
        public var ec2ErrorMessage: Swift.String?
        /// Type of exception encountered during EC2 instance operation.
        public var ec2ExceptionType: Swift.String?

        public init(
            ec2ErrorCode: Swift.String? = nil,
            ec2ErrorMessage: Swift.String? = nil,
            ec2ExceptionType: Swift.String? = nil
        ) {
            self.ec2ErrorCode = ec2ErrorCode
            self.ec2ErrorMessage = ec2ErrorMessage
            self.ec2ExceptionType = ec2ExceptionType
        }
    }
}

extension WorkspacesInstancesClientTypes {

    /// Represents an EC2 instance managed by WorkSpaces.
    public struct EC2ManagedInstance: Swift.Sendable {
        /// Unique identifier of the managed EC2 instance.
        public var instanceId: Swift.String?

        public init(
            instanceId: Swift.String? = nil
        ) {
            self.instanceId = instanceId
        }
    }
}

/// Identifies the WorkSpaces Instance to retrieve detailed information for.
public struct GetWorkspaceInstanceInput: Swift.Sendable {
    /// Unique identifier of the WorkSpace Instance to retrieve.
    /// This member is required.
    public var workspaceInstanceId: Swift.String?

    public init(
        workspaceInstanceId: Swift.String? = nil
    ) {
        self.workspaceInstanceId = workspaceInstanceId
    }
}

extension WorkspacesInstancesClientTypes {

    public enum ProvisionStateEnum: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case allocated
        case allocating
        case deallocated
        case deallocating
        case errorAllocating
        case errorDeallocating
        case sdkUnknown(Swift.String)

        public static var allCases: [ProvisionStateEnum] {
            return [
                .allocated,
                .allocating,
                .deallocated,
                .deallocating,
                .errorAllocating,
                .errorDeallocating
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .allocated: return "ALLOCATED"
            case .allocating: return "ALLOCATING"
            case .deallocated: return "DEALLOCATED"
            case .deallocating: return "DEALLOCATING"
            case .errorAllocating: return "ERROR_ALLOCATING"
            case .errorDeallocating: return "ERROR_DEALLOCATING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension WorkspacesInstancesClientTypes {

    /// Captures errors specific to WorkSpace Instance operations.
    public struct WorkspaceInstanceError: Swift.Sendable {
        /// Unique error code for the WorkSpace Instance error.
        public var errorCode: Swift.String?
        /// Detailed description of the WorkSpace Instance error.
        public var errorMessage: Swift.String?

        public init(
            errorCode: Swift.String? = nil,
            errorMessage: Swift.String? = nil
        ) {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
        }
    }
}

/// Provides comprehensive details about the requested WorkSpaces Instance.
public struct GetWorkspaceInstanceOutput: Swift.Sendable {
    /// Returns the current billing configuration for the WorkSpace Instance, indicating the active billing mode.
    public var billingConfiguration: WorkspacesInstancesClientTypes.BillingConfiguration?
    /// Includes any underlying EC2 instance errors encountered.
    public var ec2InstanceErrors: [WorkspacesInstancesClientTypes.EC2InstanceError]?
    /// Details of the associated EC2 managed instance.
    public var ec2ManagedInstance: WorkspacesInstancesClientTypes.EC2ManagedInstance?
    /// Current provisioning state of the WorkSpaces Instance.
    public var provisionState: WorkspacesInstancesClientTypes.ProvisionStateEnum?
    /// Captures any errors specific to the WorkSpace Instance lifecycle.
    public var workspaceInstanceErrors: [WorkspacesInstancesClientTypes.WorkspaceInstanceError]?
    /// Unique identifier of the retrieved WorkSpaces Instance.
    public var workspaceInstanceId: Swift.String?

    public init(
        billingConfiguration: WorkspacesInstancesClientTypes.BillingConfiguration? = nil,
        ec2InstanceErrors: [WorkspacesInstancesClientTypes.EC2InstanceError]? = nil,
        ec2ManagedInstance: WorkspacesInstancesClientTypes.EC2ManagedInstance? = nil,
        provisionState: WorkspacesInstancesClientTypes.ProvisionStateEnum? = nil,
        workspaceInstanceErrors: [WorkspacesInstancesClientTypes.WorkspaceInstanceError]? = nil,
        workspaceInstanceId: Swift.String? = nil
    ) {
        self.billingConfiguration = billingConfiguration
        self.ec2InstanceErrors = ec2InstanceErrors
        self.ec2ManagedInstance = ec2ManagedInstance
        self.provisionState = provisionState
        self.workspaceInstanceErrors = workspaceInstanceErrors
        self.workspaceInstanceId = workspaceInstanceId
    }
}

extension WorkspacesInstancesClientTypes {

    public enum PlatformTypeEnum: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case linuxByol
        case linuxUnix
        case rhel
        case suse
        case ubuntuPro
        case windows
        case windowsByol
        case sdkUnknown(Swift.String)

        public static var allCases: [PlatformTypeEnum] {
            return [
                .linuxByol,
                .linuxUnix,
                .rhel,
                .suse,
                .ubuntuPro,
                .windows,
                .windowsByol
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .linuxByol: return "Red Hat BYOL Linux"
            case .linuxUnix: return "Linux/UNIX"
            case .rhel: return "Red Hat Enterprise Linux"
            case .suse: return "SUSE Linux"
            case .ubuntuPro: return "Ubuntu Pro Linux"
            case .windows: return "Windows"
            case .windowsByol: return "Windows BYOL"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension WorkspacesInstancesClientTypes {

    public enum InstanceConfigurationTenancyEnum: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case dedicated
        case shared
        case sdkUnknown(Swift.String)

        public static var allCases: [InstanceConfigurationTenancyEnum] {
            return [
                .dedicated,
                .shared
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .dedicated: return "DEDICATED"
            case .shared: return "SHARED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension WorkspacesInstancesClientTypes {

    /// Defines filtering criteria for WorkSpace Instance type searches. Combines multiple filter conditions including billing mode, platform type, and tenancy to help customers find instance types that meet their specific requirements.
    public struct InstanceConfigurationFilter: Swift.Sendable {
        /// Filters WorkSpace Instance types based on supported billing modes. Allows customers to search for instance types that support their preferred billing model, such as HOURLY or MONTHLY billing.
        /// This member is required.
        public var billingMode: WorkspacesInstancesClientTypes.BillingMode?
        /// Filters WorkSpace Instance types by operating system platform. Allows customers to find instances that support their desired OS, such as Windows, Linux/UNIX, Ubuntu Pro, RHEL, or SUSE.
        /// This member is required.
        public var platformType: WorkspacesInstancesClientTypes.PlatformTypeEnum?
        /// Filters WorkSpace Instance types by tenancy model. Allows customers to find instances that match their tenancy requirements, such as SHARED or DEDICATED.
        /// This member is required.
        public var tenancy: WorkspacesInstancesClientTypes.InstanceConfigurationTenancyEnum?

        public init(
            billingMode: WorkspacesInstancesClientTypes.BillingMode? = nil,
            platformType: WorkspacesInstancesClientTypes.PlatformTypeEnum? = nil,
            tenancy: WorkspacesInstancesClientTypes.InstanceConfigurationTenancyEnum? = nil
        ) {
            self.billingMode = billingMode
            self.platformType = platformType
            self.tenancy = tenancy
        }
    }
}

/// Defines input parameters for retrieving supported WorkSpaces Instances instance types.
public struct ListInstanceTypesInput: Swift.Sendable {
    /// Optional filter to narrow instance type results based on configuration requirements. Only returns instance types that support the specified combination of tenancy, platform type, and billing mode.
    public var instanceConfigurationFilter: WorkspacesInstancesClientTypes.InstanceConfigurationFilter?
    /// Maximum number of instance types to return in a single API call. Enables pagination of instance type results.
    public var maxResults: Swift.Int?
    /// Pagination token for retrieving subsequent pages of instance type results.
    public var nextToken: Swift.String?

    public init(
        instanceConfigurationFilter: WorkspacesInstancesClientTypes.InstanceConfigurationFilter? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.instanceConfigurationFilter = instanceConfigurationFilter
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ListInstanceTypesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListInstanceTypesInput(instanceConfigurationFilter: \(Swift.String(describing: instanceConfigurationFilter)), maxResults: \(Swift.String(describing: maxResults)), nextToken: \"CONTENT_REDACTED\")"}
}

extension WorkspacesInstancesClientTypes {

    /// Represents a single valid configuration combination that an instance type supports, combining tenancy, platform type, and billing mode into one complete configuration specification.
    public struct SupportedInstanceConfiguration: Swift.Sendable {
        /// Specifies the billing mode supported in this configuration combination.
        public var billingMode: WorkspacesInstancesClientTypes.BillingMode?
        /// Specifies the operating system platform supported in this configuration combination.
        public var platformType: WorkspacesInstancesClientTypes.PlatformTypeEnum?
        /// Specifies the tenancy model supported in this configuration combination.
        public var tenancy: WorkspacesInstancesClientTypes.InstanceConfigurationTenancyEnum?

        public init(
            billingMode: WorkspacesInstancesClientTypes.BillingMode? = nil,
            platformType: WorkspacesInstancesClientTypes.PlatformTypeEnum? = nil,
            tenancy: WorkspacesInstancesClientTypes.InstanceConfigurationTenancyEnum? = nil
        ) {
            self.billingMode = billingMode
            self.platformType = platformType
            self.tenancy = tenancy
        }
    }
}

extension WorkspacesInstancesClientTypes {

    /// Provides details about a specific WorkSpace Instance type.
    public struct InstanceTypeInfo: Swift.Sendable {
        /// Unique identifier for the WorkSpace Instance type.
        public var instanceType: Swift.String?
        /// Lists all valid combinations of tenancy, platform type, and billing mode supported for the specific WorkSpace Instance type. Contains the complete set of configuration options available for this instance type.
        public var supportedInstanceConfigurations: [WorkspacesInstancesClientTypes.SupportedInstanceConfiguration]?

        public init(
            instanceType: Swift.String? = nil,
            supportedInstanceConfigurations: [WorkspacesInstancesClientTypes.SupportedInstanceConfiguration]? = nil
        ) {
            self.instanceType = instanceType
            self.supportedInstanceConfigurations = supportedInstanceConfigurations
        }
    }
}

/// Contains the list of instance types supported by WorkSpaces Instances.
public struct ListInstanceTypesOutput: Swift.Sendable {
    /// Collection of supported instance types for WorkSpaces Instances.
    /// This member is required.
    public var instanceTypes: [WorkspacesInstancesClientTypes.InstanceTypeInfo]?
    /// Token for retrieving additional instance types if the result set is paginated.
    public var nextToken: Swift.String?

    public init(
        instanceTypes: [WorkspacesInstancesClientTypes.InstanceTypeInfo]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.instanceTypes = instanceTypes
        self.nextToken = nextToken
    }
}

extension ListInstanceTypesOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListInstanceTypesOutput(instanceTypes: \(Swift.String(describing: instanceTypes)), nextToken: \"CONTENT_REDACTED\")"}
}

/// Defines input parameters for retrieving supported WorkSpaces Instances regions.
public struct ListRegionsInput: Swift.Sendable {
    /// Maximum number of regions to return in a single API call. Enables pagination of region results.
    public var maxResults: Swift.Int?
    /// Pagination token for retrieving subsequent pages of region results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ListRegionsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListRegionsInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \"CONTENT_REDACTED\")"}
}

extension WorkspacesInstancesClientTypes {

    /// Represents an AWS region supported by WorkSpaces Instances.
    public struct Region: Swift.Sendable {
        /// Name of the AWS region.
        public var regionName: Swift.String?

        public init(
            regionName: Swift.String? = nil
        ) {
            self.regionName = regionName
        }
    }
}

/// Contains the list of supported AWS regions for WorkSpaces Instances.
public struct ListRegionsOutput: Swift.Sendable {
    /// Token for retrieving additional regions if the result set is paginated.
    public var nextToken: Swift.String?
    /// Collection of AWS regions supported by WorkSpaces Instances.
    /// This member is required.
    public var regions: [WorkspacesInstancesClientTypes.Region]?

    public init(
        nextToken: Swift.String? = nil,
        regions: [WorkspacesInstancesClientTypes.Region]? = nil
    ) {
        self.nextToken = nextToken
        self.regions = regions
    }
}

extension ListRegionsOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListRegionsOutput(regions: \(Swift.String(describing: regions)), nextToken: \"CONTENT_REDACTED\")"}
}

/// Specifies the WorkSpace Instance to retrieve tags for.
public struct ListTagsForResourceInput: Swift.Sendable {
    /// Unique identifier of the WorkSpace Instance.
    /// This member is required.
    public var workspaceInstanceId: Swift.String?

    public init(
        workspaceInstanceId: Swift.String? = nil
    ) {
        self.workspaceInstanceId = workspaceInstanceId
    }
}

/// Returns the list of tags for the specified WorkSpace Instance.
public struct ListTagsForResourceOutput: Swift.Sendable {
    /// Collection of tags associated with the WorkSpace Instance.
    public var tags: [WorkspacesInstancesClientTypes.Tag]?

    public init(
        tags: [WorkspacesInstancesClientTypes.Tag]? = nil
    ) {
        self.tags = tags
    }
}

/// Defines filters and pagination parameters for retrieving WorkSpaces Instances.
public struct ListWorkspaceInstancesInput: Swift.Sendable {
    /// Maximum number of WorkSpaces Instances to return in a single response.
    public var maxResults: Swift.Int?
    /// Pagination token for retrieving subsequent pages of WorkSpaces Instances.
    public var nextToken: Swift.String?
    /// Filter WorkSpaces Instances by their current provisioning states.
    public var provisionStates: [WorkspacesInstancesClientTypes.ProvisionStateEnum]?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        provisionStates: [WorkspacesInstancesClientTypes.ProvisionStateEnum]? = nil
    ) {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.provisionStates = provisionStates
    }
}

extension ListWorkspaceInstancesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListWorkspaceInstancesInput(maxResults: \(Swift.String(describing: maxResults)), provisionStates: \(Swift.String(describing: provisionStates)), nextToken: \"CONTENT_REDACTED\")"}
}

extension WorkspacesInstancesClientTypes {

    /// Represents a single WorkSpace Instance.
    public struct WorkspaceInstance: Swift.Sendable {
        /// Details of the associated EC2 managed instance.
        public var ec2ManagedInstance: WorkspacesInstancesClientTypes.EC2ManagedInstance?
        /// Current provisioning state of the WorkSpace Instance.
        public var provisionState: WorkspacesInstancesClientTypes.ProvisionStateEnum?
        /// Unique identifier for the WorkSpace Instance.
        public var workspaceInstanceId: Swift.String?

        public init(
            ec2ManagedInstance: WorkspacesInstancesClientTypes.EC2ManagedInstance? = nil,
            provisionState: WorkspacesInstancesClientTypes.ProvisionStateEnum? = nil,
            workspaceInstanceId: Swift.String? = nil
        ) {
            self.ec2ManagedInstance = ec2ManagedInstance
            self.provisionState = provisionState
            self.workspaceInstanceId = workspaceInstanceId
        }
    }
}

/// Contains the list of WorkSpaces Instances matching the specified criteria.
public struct ListWorkspaceInstancesOutput: Swift.Sendable {
    /// Token for retrieving additional WorkSpaces Instances if the result set is paginated.
    public var nextToken: Swift.String?
    /// Collection of WorkSpaces Instances returned by the query.
    /// This member is required.
    public var workspaceInstances: [WorkspacesInstancesClientTypes.WorkspaceInstance]?

    public init(
        nextToken: Swift.String? = nil,
        workspaceInstances: [WorkspacesInstancesClientTypes.WorkspaceInstance]? = nil
    ) {
        self.nextToken = nextToken
        self.workspaceInstances = workspaceInstances
    }
}

extension ListWorkspaceInstancesOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListWorkspaceInstancesOutput(workspaceInstances: \(Swift.String(describing: workspaceInstances)), nextToken: \"CONTENT_REDACTED\")"}
}

/// Specifies tags to add to a WorkSpace Instance.
public struct TagResourceInput: Swift.Sendable {
    /// Tags to be added to the WorkSpace Instance.
    /// This member is required.
    public var tags: [WorkspacesInstancesClientTypes.Tag]?
    /// Unique identifier of the WorkSpace Instance to tag.
    /// This member is required.
    public var workspaceInstanceId: Swift.String?

    public init(
        tags: [WorkspacesInstancesClientTypes.Tag]? = nil,
        workspaceInstanceId: Swift.String? = nil
    ) {
        self.tags = tags
        self.workspaceInstanceId = workspaceInstanceId
    }
}

/// Confirms successful tag addition.
public struct TagResourceOutput: Swift.Sendable {

    public init() { }
}

/// Specifies tags to remove from a WorkSpace Instance.
public struct UntagResourceInput: Swift.Sendable {
    /// Keys of tags to be removed.
    /// This member is required.
    public var tagKeys: [Swift.String]?
    /// Unique identifier of the WorkSpace Instance to untag.
    /// This member is required.
    public var workspaceInstanceId: Swift.String?

    public init(
        tagKeys: [Swift.String]? = nil,
        workspaceInstanceId: Swift.String? = nil
    ) {
        self.tagKeys = tagKeys
        self.workspaceInstanceId = workspaceInstanceId
    }
}

/// Confirms successful tag removal.
public struct UntagResourceOutput: Swift.Sendable {

    public init() { }
}

extension AssociateVolumeInput {

    static func urlPathProvider(_ value: AssociateVolumeInput) -> Swift.String? {
        return "/"
    }
}

extension CreateVolumeInput {

    static func urlPathProvider(_ value: CreateVolumeInput) -> Swift.String? {
        return "/"
    }
}

extension CreateWorkspaceInstanceInput {

    static func urlPathProvider(_ value: CreateWorkspaceInstanceInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteVolumeInput {

    static func urlPathProvider(_ value: DeleteVolumeInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteWorkspaceInstanceInput {

    static func urlPathProvider(_ value: DeleteWorkspaceInstanceInput) -> Swift.String? {
        return "/"
    }
}

extension DisassociateVolumeInput {

    static func urlPathProvider(_ value: DisassociateVolumeInput) -> Swift.String? {
        return "/"
    }
}

extension GetWorkspaceInstanceInput {

    static func urlPathProvider(_ value: GetWorkspaceInstanceInput) -> Swift.String? {
        return "/"
    }
}

extension ListInstanceTypesInput {

    static func urlPathProvider(_ value: ListInstanceTypesInput) -> Swift.String? {
        return "/"
    }
}

extension ListRegionsInput {

    static func urlPathProvider(_ value: ListRegionsInput) -> Swift.String? {
        return "/"
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        return "/"
    }
}

extension ListWorkspaceInstancesInput {

    static func urlPathProvider(_ value: ListWorkspaceInstancesInput) -> Swift.String? {
        return "/"
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        return "/"
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        return "/"
    }
}

extension AssociateVolumeInput {

    static func write(value: AssociateVolumeInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Device"].write(value.device)
        try writer["VolumeId"].write(value.volumeId)
        try writer["WorkspaceInstanceId"].write(value.workspaceInstanceId)
    }
}

extension CreateVolumeInput {

    static func write(value: CreateVolumeInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AvailabilityZone"].write(value.availabilityZone)
        try writer["ClientToken"].write(value.clientToken)
        try writer["Encrypted"].write(value.encrypted)
        try writer["Iops"].write(value.iops)
        try writer["KmsKeyId"].write(value.kmsKeyId)
        try writer["SizeInGB"].write(value.sizeInGB)
        try writer["SnapshotId"].write(value.snapshotId)
        try writer["TagSpecifications"].writeList(value.tagSpecifications, memberWritingClosure: WorkspacesInstancesClientTypes.TagSpecification.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Throughput"].write(value.throughput)
        try writer["VolumeType"].write(value.volumeType)
    }
}

extension CreateWorkspaceInstanceInput {

    static func write(value: CreateWorkspaceInstanceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BillingConfiguration"].write(value.billingConfiguration, with: WorkspacesInstancesClientTypes.BillingConfiguration.write(value:to:))
        try writer["ClientToken"].write(value.clientToken)
        try writer["ManagedInstance"].write(value.managedInstance, with: WorkspacesInstancesClientTypes.ManagedInstanceRequest.write(value:to:))
        try writer["Tags"].writeList(value.tags, memberWritingClosure: WorkspacesInstancesClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension DeleteVolumeInput {

    static func write(value: DeleteVolumeInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["VolumeId"].write(value.volumeId)
    }
}

extension DeleteWorkspaceInstanceInput {

    static func write(value: DeleteWorkspaceInstanceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["WorkspaceInstanceId"].write(value.workspaceInstanceId)
    }
}

extension DisassociateVolumeInput {

    static func write(value: DisassociateVolumeInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Device"].write(value.device)
        try writer["DisassociateMode"].write(value.disassociateMode)
        try writer["VolumeId"].write(value.volumeId)
        try writer["WorkspaceInstanceId"].write(value.workspaceInstanceId)
    }
}

extension GetWorkspaceInstanceInput {

    static func write(value: GetWorkspaceInstanceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["WorkspaceInstanceId"].write(value.workspaceInstanceId)
    }
}

extension ListInstanceTypesInput {

    static func write(value: ListInstanceTypesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["InstanceConfigurationFilter"].write(value.instanceConfigurationFilter, with: WorkspacesInstancesClientTypes.InstanceConfigurationFilter.write(value:to:))
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension ListRegionsInput {

    static func write(value: ListRegionsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension ListTagsForResourceInput {

    static func write(value: ListTagsForResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["WorkspaceInstanceId"].write(value.workspaceInstanceId)
    }
}

extension ListWorkspaceInstancesInput {

    static func write(value: ListWorkspaceInstancesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["ProvisionStates"].writeList(value.provisionStates, memberWritingClosure: SmithyReadWrite.WritingClosureBox<WorkspacesInstancesClientTypes.ProvisionStateEnum>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Tags"].writeList(value.tags, memberWritingClosure: WorkspacesInstancesClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["WorkspaceInstanceId"].write(value.workspaceInstanceId)
    }
}

extension UntagResourceInput {

    static func write(value: UntagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["TagKeys"].writeList(value.tagKeys, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["WorkspaceInstanceId"].write(value.workspaceInstanceId)
    }
}

extension AssociateVolumeOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AssociateVolumeOutput {
        return AssociateVolumeOutput()
    }
}

extension CreateVolumeOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateVolumeOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateVolumeOutput()
        value.volumeId = try reader["VolumeId"].readIfPresent()
        return value
    }
}

extension CreateWorkspaceInstanceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateWorkspaceInstanceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateWorkspaceInstanceOutput()
        value.workspaceInstanceId = try reader["WorkspaceInstanceId"].readIfPresent()
        return value
    }
}

extension DeleteVolumeOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteVolumeOutput {
        return DeleteVolumeOutput()
    }
}

extension DeleteWorkspaceInstanceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteWorkspaceInstanceOutput {
        return DeleteWorkspaceInstanceOutput()
    }
}

extension DisassociateVolumeOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DisassociateVolumeOutput {
        return DisassociateVolumeOutput()
    }
}

extension GetWorkspaceInstanceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetWorkspaceInstanceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetWorkspaceInstanceOutput()
        value.billingConfiguration = try reader["BillingConfiguration"].readIfPresent(with: WorkspacesInstancesClientTypes.BillingConfiguration.read(from:))
        value.ec2InstanceErrors = try reader["EC2InstanceErrors"].readListIfPresent(memberReadingClosure: WorkspacesInstancesClientTypes.EC2InstanceError.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.ec2ManagedInstance = try reader["EC2ManagedInstance"].readIfPresent(with: WorkspacesInstancesClientTypes.EC2ManagedInstance.read(from:))
        value.provisionState = try reader["ProvisionState"].readIfPresent()
        value.workspaceInstanceErrors = try reader["WorkspaceInstanceErrors"].readListIfPresent(memberReadingClosure: WorkspacesInstancesClientTypes.WorkspaceInstanceError.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.workspaceInstanceId = try reader["WorkspaceInstanceId"].readIfPresent()
        return value
    }
}

extension ListInstanceTypesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListInstanceTypesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListInstanceTypesOutput()
        value.instanceTypes = try reader["InstanceTypes"].readListIfPresent(memberReadingClosure: WorkspacesInstancesClientTypes.InstanceTypeInfo.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListRegionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListRegionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListRegionsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.regions = try reader["Regions"].readListIfPresent(memberReadingClosure: WorkspacesInstancesClientTypes.Region.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.tags = try reader["Tags"].readListIfPresent(memberReadingClosure: WorkspacesInstancesClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListWorkspaceInstancesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListWorkspaceInstancesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListWorkspaceInstancesOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.workspaceInstances = try reader["WorkspaceInstances"].readListIfPresent(memberReadingClosure: WorkspacesInstancesClientTypes.WorkspaceInstance.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

enum AssociateVolumeOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateVolumeOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateWorkspaceInstanceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteVolumeOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteWorkspaceInstanceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DisassociateVolumeOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetWorkspaceInstanceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListInstanceTypesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListRegionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListWorkspaceInstancesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension AccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> AccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = AccessDeniedException()
        value.properties.message = try reader["Message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ConflictException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ConflictException {
        let reader = baseError.errorBodyReader
        var value = ConflictException()
        value.properties.message = try reader["Message"].readIfPresent() ?? ""
        value.properties.resourceId = try reader["ResourceId"].readIfPresent() ?? ""
        value.properties.resourceType = try reader["ResourceType"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InternalServerException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InternalServerException {
        let reader = baseError.errorBodyReader
        let httpResponse = baseError.httpResponse
        var value = InternalServerException()
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            value.properties.retryAfterSeconds = Swift.Int(retryAfterSecondsHeaderValue) ?? 0
        }
        value.properties.message = try reader["Message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.message = try reader["Message"].readIfPresent() ?? ""
        value.properties.resourceId = try reader["ResourceId"].readIfPresent() ?? ""
        value.properties.resourceType = try reader["ResourceType"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ThrottlingException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ThrottlingException {
        let reader = baseError.errorBodyReader
        let httpResponse = baseError.httpResponse
        var value = ThrottlingException()
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            value.properties.retryAfterSeconds = Swift.Int(retryAfterSecondsHeaderValue) ?? 0
        }
        value.properties.message = try reader["Message"].readIfPresent() ?? ""
        value.properties.quotaCode = try reader["QuotaCode"].readIfPresent()
        value.properties.serviceCode = try reader["ServiceCode"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ValidationException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ValidationException {
        let reader = baseError.errorBodyReader
        var value = ValidationException()
        value.properties.fieldList = try reader["FieldList"].readListIfPresent(memberReadingClosure: WorkspacesInstancesClientTypes.ValidationExceptionField.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.properties.message = try reader["Message"].readIfPresent() ?? ""
        value.properties.reason = try reader["Reason"].readIfPresent() ?? .sdkUnknown("")
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ServiceQuotaExceededException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ServiceQuotaExceededException {
        let reader = baseError.errorBodyReader
        var value = ServiceQuotaExceededException()
        value.properties.message = try reader["Message"].readIfPresent() ?? ""
        value.properties.quotaCode = try reader["QuotaCode"].readIfPresent() ?? ""
        value.properties.resourceId = try reader["ResourceId"].readIfPresent() ?? ""
        value.properties.resourceType = try reader["ResourceType"].readIfPresent() ?? ""
        value.properties.serviceCode = try reader["ServiceCode"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension WorkspacesInstancesClientTypes.BillingConfiguration {

    static func write(value: WorkspacesInstancesClientTypes.BillingConfiguration?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BillingMode"].write(value.billingMode)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> WorkspacesInstancesClientTypes.BillingConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WorkspacesInstancesClientTypes.BillingConfiguration()
        value.billingMode = try reader["BillingMode"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension WorkspacesInstancesClientTypes.BlockDeviceMappingRequest {

    static func write(value: WorkspacesInstancesClientTypes.BlockDeviceMappingRequest?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DeviceName"].write(value.deviceName)
        try writer["Ebs"].write(value.ebs, with: WorkspacesInstancesClientTypes.EbsBlockDevice.write(value:to:))
        try writer["NoDevice"].write(value.noDevice)
        try writer["VirtualName"].write(value.virtualName)
    }
}

extension WorkspacesInstancesClientTypes.CapacityReservationSpecification {

    static func write(value: WorkspacesInstancesClientTypes.CapacityReservationSpecification?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CapacityReservationPreference"].write(value.capacityReservationPreference)
        try writer["CapacityReservationTarget"].write(value.capacityReservationTarget, with: WorkspacesInstancesClientTypes.CapacityReservationTarget.write(value:to:))
    }
}

extension WorkspacesInstancesClientTypes.CapacityReservationTarget {

    static func write(value: WorkspacesInstancesClientTypes.CapacityReservationTarget?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CapacityReservationId"].write(value.capacityReservationId)
        try writer["CapacityReservationResourceGroupArn"].write(value.capacityReservationResourceGroupArn)
    }
}

extension WorkspacesInstancesClientTypes.ConnectionTrackingSpecificationRequest {

    static func write(value: WorkspacesInstancesClientTypes.ConnectionTrackingSpecificationRequest?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["TcpEstablishedTimeout"].write(value.tcpEstablishedTimeout)
        try writer["UdpStreamTimeout"].write(value.udpStreamTimeout)
        try writer["UdpTimeout"].write(value.udpTimeout)
    }
}

extension WorkspacesInstancesClientTypes.CpuOptionsRequest {

    static func write(value: WorkspacesInstancesClientTypes.CpuOptionsRequest?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AmdSevSnp"].write(value.amdSevSnp)
        try writer["CoreCount"].write(value.coreCount)
        try writer["ThreadsPerCore"].write(value.threadsPerCore)
    }
}

extension WorkspacesInstancesClientTypes.CreditSpecificationRequest {

    static func write(value: WorkspacesInstancesClientTypes.CreditSpecificationRequest?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CpuCredits"].write(value.cpuCredits)
    }
}

extension WorkspacesInstancesClientTypes.EbsBlockDevice {

    static func write(value: WorkspacesInstancesClientTypes.EbsBlockDevice?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Encrypted"].write(value.encrypted)
        try writer["Iops"].write(value.iops)
        try writer["KmsKeyId"].write(value.kmsKeyId)
        try writer["Throughput"].write(value.throughput)
        try writer["VolumeSize"].write(value.volumeSize)
        try writer["VolumeType"].write(value.volumeType)
    }
}

extension WorkspacesInstancesClientTypes.EC2InstanceError {

    static func read(from reader: SmithyJSON.Reader) throws -> WorkspacesInstancesClientTypes.EC2InstanceError {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WorkspacesInstancesClientTypes.EC2InstanceError()
        value.ec2ErrorCode = try reader["EC2ErrorCode"].readIfPresent()
        value.ec2ExceptionType = try reader["EC2ExceptionType"].readIfPresent()
        value.ec2ErrorMessage = try reader["EC2ErrorMessage"].readIfPresent()
        return value
    }
}

extension WorkspacesInstancesClientTypes.EC2ManagedInstance {

    static func read(from reader: SmithyJSON.Reader) throws -> WorkspacesInstancesClientTypes.EC2ManagedInstance {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WorkspacesInstancesClientTypes.EC2ManagedInstance()
        value.instanceId = try reader["InstanceId"].readIfPresent()
        return value
    }
}

extension WorkspacesInstancesClientTypes.EnaSrdSpecificationRequest {

    static func write(value: WorkspacesInstancesClientTypes.EnaSrdSpecificationRequest?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EnaSrdEnabled"].write(value.enaSrdEnabled)
        try writer["EnaSrdUdpSpecification"].write(value.enaSrdUdpSpecification, with: WorkspacesInstancesClientTypes.EnaSrdUdpSpecificationRequest.write(value:to:))
    }
}

extension WorkspacesInstancesClientTypes.EnaSrdUdpSpecificationRequest {

    static func write(value: WorkspacesInstancesClientTypes.EnaSrdUdpSpecificationRequest?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EnaSrdUdpEnabled"].write(value.enaSrdUdpEnabled)
    }
}

extension WorkspacesInstancesClientTypes.EnclaveOptionsRequest {

    static func write(value: WorkspacesInstancesClientTypes.EnclaveOptionsRequest?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Enabled"].write(value.enabled)
    }
}

extension WorkspacesInstancesClientTypes.HibernationOptionsRequest {

    static func write(value: WorkspacesInstancesClientTypes.HibernationOptionsRequest?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Configured"].write(value.configured)
    }
}

extension WorkspacesInstancesClientTypes.IamInstanceProfileSpecification {

    static func write(value: WorkspacesInstancesClientTypes.IamInstanceProfileSpecification?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Arn"].write(value.arn)
        try writer["Name"].write(value.name)
    }
}

extension WorkspacesInstancesClientTypes.InstanceConfigurationFilter {

    static func write(value: WorkspacesInstancesClientTypes.InstanceConfigurationFilter?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BillingMode"].write(value.billingMode)
        try writer["PlatformType"].write(value.platformType)
        try writer["Tenancy"].write(value.tenancy)
    }
}

extension WorkspacesInstancesClientTypes.InstanceIpv6Address {

    static func write(value: WorkspacesInstancesClientTypes.InstanceIpv6Address?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Ipv6Address"].write(value.ipv6Address)
        try writer["IsPrimaryIpv6"].write(value.isPrimaryIpv6)
    }
}

extension WorkspacesInstancesClientTypes.InstanceMaintenanceOptionsRequest {

    static func write(value: WorkspacesInstancesClientTypes.InstanceMaintenanceOptionsRequest?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AutoRecovery"].write(value.autoRecovery)
    }
}

extension WorkspacesInstancesClientTypes.InstanceMarketOptionsRequest {

    static func write(value: WorkspacesInstancesClientTypes.InstanceMarketOptionsRequest?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MarketType"].write(value.marketType)
        try writer["SpotOptions"].write(value.spotOptions, with: WorkspacesInstancesClientTypes.SpotMarketOptions.write(value:to:))
    }
}

extension WorkspacesInstancesClientTypes.InstanceMetadataOptionsRequest {

    static func write(value: WorkspacesInstancesClientTypes.InstanceMetadataOptionsRequest?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["HttpEndpoint"].write(value.httpEndpoint)
        try writer["HttpProtocolIpv6"].write(value.httpProtocolIpv6)
        try writer["HttpPutResponseHopLimit"].write(value.httpPutResponseHopLimit)
        try writer["HttpTokens"].write(value.httpTokens)
        try writer["InstanceMetadataTags"].write(value.instanceMetadataTags)
    }
}

extension WorkspacesInstancesClientTypes.InstanceNetworkInterfaceSpecification {

    static func write(value: WorkspacesInstancesClientTypes.InstanceNetworkInterfaceSpecification?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AssociateCarrierIpAddress"].write(value.associateCarrierIpAddress)
        try writer["AssociatePublicIpAddress"].write(value.associatePublicIpAddress)
        try writer["ConnectionTrackingSpecification"].write(value.connectionTrackingSpecification, with: WorkspacesInstancesClientTypes.ConnectionTrackingSpecificationRequest.write(value:to:))
        try writer["Description"].write(value.description)
        try writer["DeviceIndex"].write(value.deviceIndex)
        try writer["EnaSrdSpecification"].write(value.enaSrdSpecification, with: WorkspacesInstancesClientTypes.EnaSrdSpecificationRequest.write(value:to:))
        try writer["Groups"].writeList(value.groups, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["InterfaceType"].write(value.interfaceType)
        try writer["Ipv4PrefixCount"].write(value.ipv4PrefixCount)
        try writer["Ipv4Prefixes"].writeList(value.ipv4Prefixes, memberWritingClosure: WorkspacesInstancesClientTypes.Ipv4PrefixSpecificationRequest.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Ipv6AddressCount"].write(value.ipv6AddressCount)
        try writer["Ipv6Addresses"].writeList(value.ipv6Addresses, memberWritingClosure: WorkspacesInstancesClientTypes.InstanceIpv6Address.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Ipv6PrefixCount"].write(value.ipv6PrefixCount)
        try writer["Ipv6Prefixes"].writeList(value.ipv6Prefixes, memberWritingClosure: WorkspacesInstancesClientTypes.Ipv6PrefixSpecificationRequest.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["NetworkCardIndex"].write(value.networkCardIndex)
        try writer["NetworkInterfaceId"].write(value.networkInterfaceId)
        try writer["PrimaryIpv6"].write(value.primaryIpv6)
        try writer["PrivateIpAddress"].write(value.privateIpAddress)
        try writer["PrivateIpAddresses"].writeList(value.privateIpAddresses, memberWritingClosure: WorkspacesInstancesClientTypes.PrivateIpAddressSpecification.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["SecondaryPrivateIpAddressCount"].write(value.secondaryPrivateIpAddressCount)
        try writer["SubnetId"].write(value.subnetId)
    }
}

extension WorkspacesInstancesClientTypes.InstanceNetworkPerformanceOptionsRequest {

    static func write(value: WorkspacesInstancesClientTypes.InstanceNetworkPerformanceOptionsRequest?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BandwidthWeighting"].write(value.bandwidthWeighting)
    }
}

extension WorkspacesInstancesClientTypes.InstanceTypeInfo {

    static func read(from reader: SmithyJSON.Reader) throws -> WorkspacesInstancesClientTypes.InstanceTypeInfo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WorkspacesInstancesClientTypes.InstanceTypeInfo()
        value.instanceType = try reader["InstanceType"].readIfPresent()
        value.supportedInstanceConfigurations = try reader["SupportedInstanceConfigurations"].readListIfPresent(memberReadingClosure: WorkspacesInstancesClientTypes.SupportedInstanceConfiguration.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension WorkspacesInstancesClientTypes.Ipv4PrefixSpecificationRequest {

    static func write(value: WorkspacesInstancesClientTypes.Ipv4PrefixSpecificationRequest?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Ipv4Prefix"].write(value.ipv4Prefix)
    }
}

extension WorkspacesInstancesClientTypes.Ipv6PrefixSpecificationRequest {

    static func write(value: WorkspacesInstancesClientTypes.Ipv6PrefixSpecificationRequest?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Ipv6Prefix"].write(value.ipv6Prefix)
    }
}

extension WorkspacesInstancesClientTypes.LicenseConfigurationRequest {

    static func write(value: WorkspacesInstancesClientTypes.LicenseConfigurationRequest?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["LicenseConfigurationArn"].write(value.licenseConfigurationArn)
    }
}

extension WorkspacesInstancesClientTypes.ManagedInstanceRequest {

    static func write(value: WorkspacesInstancesClientTypes.ManagedInstanceRequest?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BlockDeviceMappings"].writeList(value.blockDeviceMappings, memberWritingClosure: WorkspacesInstancesClientTypes.BlockDeviceMappingRequest.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["CapacityReservationSpecification"].write(value.capacityReservationSpecification, with: WorkspacesInstancesClientTypes.CapacityReservationSpecification.write(value:to:))
        try writer["CpuOptions"].write(value.cpuOptions, with: WorkspacesInstancesClientTypes.CpuOptionsRequest.write(value:to:))
        try writer["CreditSpecification"].write(value.creditSpecification, with: WorkspacesInstancesClientTypes.CreditSpecificationRequest.write(value:to:))
        try writer["DisableApiStop"].write(value.disableApiStop)
        try writer["EbsOptimized"].write(value.ebsOptimized)
        try writer["EnablePrimaryIpv6"].write(value.enablePrimaryIpv6)
        try writer["EnclaveOptions"].write(value.enclaveOptions, with: WorkspacesInstancesClientTypes.EnclaveOptionsRequest.write(value:to:))
        try writer["HibernationOptions"].write(value.hibernationOptions, with: WorkspacesInstancesClientTypes.HibernationOptionsRequest.write(value:to:))
        try writer["IamInstanceProfile"].write(value.iamInstanceProfile, with: WorkspacesInstancesClientTypes.IamInstanceProfileSpecification.write(value:to:))
        try writer["ImageId"].write(value.imageId)
        try writer["InstanceMarketOptions"].write(value.instanceMarketOptions, with: WorkspacesInstancesClientTypes.InstanceMarketOptionsRequest.write(value:to:))
        try writer["InstanceType"].write(value.instanceType)
        try writer["Ipv6AddressCount"].write(value.ipv6AddressCount)
        try writer["Ipv6Addresses"].writeList(value.ipv6Addresses, memberWritingClosure: WorkspacesInstancesClientTypes.InstanceIpv6Address.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["KernelId"].write(value.kernelId)
        try writer["KeyName"].write(value.keyName)
        try writer["LicenseSpecifications"].writeList(value.licenseSpecifications, memberWritingClosure: WorkspacesInstancesClientTypes.LicenseConfigurationRequest.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MaintenanceOptions"].write(value.maintenanceOptions, with: WorkspacesInstancesClientTypes.InstanceMaintenanceOptionsRequest.write(value:to:))
        try writer["MetadataOptions"].write(value.metadataOptions, with: WorkspacesInstancesClientTypes.InstanceMetadataOptionsRequest.write(value:to:))
        try writer["Monitoring"].write(value.monitoring, with: WorkspacesInstancesClientTypes.RunInstancesMonitoringEnabled.write(value:to:))
        try writer["NetworkInterfaces"].writeList(value.networkInterfaces, memberWritingClosure: WorkspacesInstancesClientTypes.InstanceNetworkInterfaceSpecification.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["NetworkPerformanceOptions"].write(value.networkPerformanceOptions, with: WorkspacesInstancesClientTypes.InstanceNetworkPerformanceOptionsRequest.write(value:to:))
        try writer["Placement"].write(value.placement, with: WorkspacesInstancesClientTypes.Placement.write(value:to:))
        try writer["PrivateDnsNameOptions"].write(value.privateDnsNameOptions, with: WorkspacesInstancesClientTypes.PrivateDnsNameOptionsRequest.write(value:to:))
        try writer["PrivateIpAddress"].write(value.privateIpAddress)
        try writer["RamdiskId"].write(value.ramdiskId)
        try writer["SecurityGroupIds"].writeList(value.securityGroupIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["SecurityGroups"].writeList(value.securityGroups, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["SubnetId"].write(value.subnetId)
        try writer["TagSpecifications"].writeList(value.tagSpecifications, memberWritingClosure: WorkspacesInstancesClientTypes.TagSpecification.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["UserData"].write(value.userData)
    }
}

extension WorkspacesInstancesClientTypes.Placement {

    static func write(value: WorkspacesInstancesClientTypes.Placement?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Affinity"].write(value.affinity)
        try writer["AvailabilityZone"].write(value.availabilityZone)
        try writer["GroupId"].write(value.groupId)
        try writer["GroupName"].write(value.groupName)
        try writer["HostId"].write(value.hostId)
        try writer["HostResourceGroupArn"].write(value.hostResourceGroupArn)
        try writer["PartitionNumber"].write(value.partitionNumber)
        try writer["Tenancy"].write(value.tenancy)
    }
}

extension WorkspacesInstancesClientTypes.PrivateDnsNameOptionsRequest {

    static func write(value: WorkspacesInstancesClientTypes.PrivateDnsNameOptionsRequest?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EnableResourceNameDnsAAAARecord"].write(value.enableResourceNameDnsAAAARecord)
        try writer["EnableResourceNameDnsARecord"].write(value.enableResourceNameDnsARecord)
        try writer["HostnameType"].write(value.hostnameType)
    }
}

extension WorkspacesInstancesClientTypes.PrivateIpAddressSpecification {

    static func write(value: WorkspacesInstancesClientTypes.PrivateIpAddressSpecification?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Primary"].write(value.primary)
        try writer["PrivateIpAddress"].write(value.privateIpAddress)
    }
}

extension WorkspacesInstancesClientTypes.Region {

    static func read(from reader: SmithyJSON.Reader) throws -> WorkspacesInstancesClientTypes.Region {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WorkspacesInstancesClientTypes.Region()
        value.regionName = try reader["RegionName"].readIfPresent()
        return value
    }
}

extension WorkspacesInstancesClientTypes.RunInstancesMonitoringEnabled {

    static func write(value: WorkspacesInstancesClientTypes.RunInstancesMonitoringEnabled?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Enabled"].write(value.enabled)
    }
}

extension WorkspacesInstancesClientTypes.SpotMarketOptions {

    static func write(value: WorkspacesInstancesClientTypes.SpotMarketOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BlockDurationMinutes"].write(value.blockDurationMinutes)
        try writer["InstanceInterruptionBehavior"].write(value.instanceInterruptionBehavior)
        try writer["MaxPrice"].write(value.maxPrice)
        try writer["SpotInstanceType"].write(value.spotInstanceType)
        try writer["ValidUntilUtc"].writeTimestamp(value.validUntilUtc, format: SmithyTimestamps.TimestampFormat.epochSeconds)
    }
}

extension WorkspacesInstancesClientTypes.SupportedInstanceConfiguration {

    static func read(from reader: SmithyJSON.Reader) throws -> WorkspacesInstancesClientTypes.SupportedInstanceConfiguration {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WorkspacesInstancesClientTypes.SupportedInstanceConfiguration()
        value.billingMode = try reader["BillingMode"].readIfPresent()
        value.platformType = try reader["PlatformType"].readIfPresent()
        value.tenancy = try reader["Tenancy"].readIfPresent()
        return value
    }
}

extension WorkspacesInstancesClientTypes.Tag {

    static func write(value: WorkspacesInstancesClientTypes.Tag?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Key"].write(value.key)
        try writer["Value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> WorkspacesInstancesClientTypes.Tag {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WorkspacesInstancesClientTypes.Tag()
        value.key = try reader["Key"].readIfPresent()
        value.value = try reader["Value"].readIfPresent()
        return value
    }
}

extension WorkspacesInstancesClientTypes.TagSpecification {

    static func write(value: WorkspacesInstancesClientTypes.TagSpecification?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceType"].write(value.resourceType)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: WorkspacesInstancesClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension WorkspacesInstancesClientTypes.ValidationExceptionField {

    static func read(from reader: SmithyJSON.Reader) throws -> WorkspacesInstancesClientTypes.ValidationExceptionField {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WorkspacesInstancesClientTypes.ValidationExceptionField()
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.reason = try reader["Reason"].readIfPresent() ?? ""
        value.message = try reader["Message"].readIfPresent() ?? ""
        return value
    }
}

extension WorkspacesInstancesClientTypes.WorkspaceInstance {

    static func read(from reader: SmithyJSON.Reader) throws -> WorkspacesInstancesClientTypes.WorkspaceInstance {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WorkspacesInstancesClientTypes.WorkspaceInstance()
        value.provisionState = try reader["ProvisionState"].readIfPresent()
        value.workspaceInstanceId = try reader["WorkspaceInstanceId"].readIfPresent()
        value.ec2ManagedInstance = try reader["EC2ManagedInstance"].readIfPresent(with: WorkspacesInstancesClientTypes.EC2ManagedInstance.read(from:))
        return value
    }
}

extension WorkspacesInstancesClientTypes.WorkspaceInstanceError {

    static func read(from reader: SmithyJSON.Reader) throws -> WorkspacesInstancesClientTypes.WorkspaceInstanceError {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WorkspacesInstancesClientTypes.WorkspaceInstanceError()
        value.errorCode = try reader["ErrorCode"].readIfPresent()
        value.errorMessage = try reader["ErrorMessage"].readIfPresent()
        return value
    }
}

public enum WorkspacesInstancesClientTypes {}
