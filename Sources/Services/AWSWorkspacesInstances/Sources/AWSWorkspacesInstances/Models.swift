//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.AWSJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
@_spi(SmithyReadWrite) import struct SmithyReadWrite.WritingClosureBox

/// Indicates insufficient permissions to perform the requested action.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// Detailed explanation of the access denial.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

extension WorkspacesInstancesClientTypes {

    public enum AmdSevSnpEnum: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [AmdSevSnpEnum] {
            return [
                .disabled,
                .enabled
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "disabled"
            case .enabled: return "enabled"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// Signals a conflict with the current state of the resource.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// Description of the conflict encountered.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// Identifier of the conflicting resource.
        /// This member is required.
        public internal(set) var resourceId: Swift.String? = nil
        /// Type of the conflicting resource.
        /// This member is required.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    ) {
        self.properties.message = message
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
    }
}

/// Indicates an unexpected server-side error occurred.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// Description of the internal server error.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// Recommended wait time before retrying the request.
        public internal(set) var retryAfterSeconds: Swift.Int? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        retryAfterSeconds: Swift.Int? = nil
    ) {
        self.properties.message = message
        self.properties.retryAfterSeconds = retryAfterSeconds
    }
}

/// Indicates the requested resource could not be found.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// Details about the missing resource.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// Identifier of the resource that was not found.
        /// This member is required.
        public internal(set) var resourceId: Swift.String? = nil
        /// Type of the resource that was not found.
        /// This member is required.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    ) {
        self.properties.message = message
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
    }
}

/// Indicates the request rate has exceeded limits.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// Description of the throttling event.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// Specific code for the throttling quota.
        public internal(set) var quotaCode: Swift.String? = nil
        /// Recommended wait time before retrying the request.
        public internal(set) var retryAfterSeconds: Swift.Int? = nil
        /// Code identifying the service experiencing throttling.
        public internal(set) var serviceCode: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { true }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        quotaCode: Swift.String? = nil,
        retryAfterSeconds: Swift.Int? = nil,
        serviceCode: Swift.String? = nil
    ) {
        self.properties.message = message
        self.properties.quotaCode = quotaCode
        self.properties.retryAfterSeconds = retryAfterSeconds
        self.properties.serviceCode = serviceCode
    }
}

extension WorkspacesInstancesClientTypes {

    /// Represents a validation error field in an API request.
    public struct ValidationExceptionField: Swift.Sendable {
        /// Detailed error message describing the validation issue.
        /// This member is required.
        public var message: Swift.String?
        /// Name of the field that failed validation.
        /// This member is required.
        public var name: Swift.String?
        /// Reason for the validation failure.
        /// This member is required.
        public var reason: Swift.String?

        public init(
            message: Swift.String? = nil,
            name: Swift.String? = nil,
            reason: Swift.String? = nil
        ) {
            self.message = message
            self.name = name
            self.reason = reason
        }
    }
}

extension WorkspacesInstancesClientTypes {

    public enum ValidationExceptionReason: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case cannotParse
        case dependencyFailure
        case fieldValidationFailed
        case other
        case unknownOperation
        case unsupportedOperation
        case sdkUnknown(Swift.String)

        public static var allCases: [ValidationExceptionReason] {
            return [
                .cannotParse,
                .dependencyFailure,
                .fieldValidationFailed,
                .other,
                .unknownOperation,
                .unsupportedOperation
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .cannotParse: return "CANNOT_PARSE"
            case .dependencyFailure: return "DEPENDENCY_FAILURE"
            case .fieldValidationFailed: return "FIELD_VALIDATION_FAILED"
            case .other: return "OTHER"
            case .unknownOperation: return "UNKNOWN_OPERATION"
            case .unsupportedOperation: return "UNSUPPORTED_OPERATION"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// Indicates invalid input parameters in the request.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// List of fields that failed validation.
        public internal(set) var fieldList: [WorkspacesInstancesClientTypes.ValidationExceptionField]? = nil
        /// Overall description of validation failures.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// Specific reason for the validation failure.
        /// This member is required.
        public internal(set) var reason: WorkspacesInstancesClientTypes.ValidationExceptionReason? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        fieldList: [WorkspacesInstancesClientTypes.ValidationExceptionField]? = nil,
        message: Swift.String? = nil,
        reason: WorkspacesInstancesClientTypes.ValidationExceptionReason? = nil
    ) {
        self.properties.fieldList = fieldList
        self.properties.message = message
        self.properties.reason = reason
    }
}

/// Specifies volume attachment parameters.
public struct AssociateVolumeInput: Swift.Sendable {
    /// Device path for volume attachment.
    /// This member is required.
    public var device: Swift.String?
    /// Volume to be attached.
    /// This member is required.
    public var volumeId: Swift.String?
    /// WorkSpace Instance to attach volume to.
    /// This member is required.
    public var workspaceInstanceId: Swift.String?

    public init(
        device: Swift.String? = nil,
        volumeId: Swift.String? = nil,
        workspaceInstanceId: Swift.String? = nil
    ) {
        self.device = device
        self.volumeId = volumeId
        self.workspaceInstanceId = workspaceInstanceId
    }
}

/// Confirms volume attachment.
public struct AssociateVolumeOutput: Swift.Sendable {

    public init() { }
}

extension WorkspacesInstancesClientTypes {

    public enum AutoRecoveryEnum: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case `default`
        case disabled
        case sdkUnknown(Swift.String)

        public static var allCases: [AutoRecoveryEnum] {
            return [
                .default,
                .disabled
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .default: return "default"
            case .disabled: return "disabled"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension WorkspacesInstancesClientTypes {

    public enum BandwidthWeightingEnum: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case `default`
        case ebs1
        case vpc1
        case sdkUnknown(Swift.String)

        public static var allCases: [BandwidthWeightingEnum] {
            return [
                .default,
                .ebs1,
                .vpc1
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .default: return "default"
            case .ebs1: return "ebs-1"
            case .vpc1: return "vpc-1"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension WorkspacesInstancesClientTypes {

    public enum VolumeTypeEnum: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case gp2
        case gp3
        case io1
        case io2
        case sc1
        case st1
        case standard
        case sdkUnknown(Swift.String)

        public static var allCases: [VolumeTypeEnum] {
            return [
                .gp2,
                .gp3,
                .io1,
                .io2,
                .sc1,
                .st1,
                .standard
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .gp2: return "gp2"
            case .gp3: return "gp3"
            case .io1: return "io1"
            case .io2: return "io2"
            case .sc1: return "sc1"
            case .st1: return "st1"
            case .standard: return "standard"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension WorkspacesInstancesClientTypes {

    /// Defines configuration for an Elastic Block Store volume.
    public struct EbsBlockDevice: Swift.Sendable {
        /// Indicates if the volume is encrypted.
        public var encrypted: Swift.Bool?
        /// Input/output operations per second for the volume.
        public var iops: Swift.Int?
        /// KMS key used for volume encryption.
        public var kmsKeyId: Swift.String?
        /// Volume data transfer rate.
        public var throughput: Swift.Int?
        /// Size of the EBS volume in gigabytes.
        public var volumeSize: Swift.Int?
        /// Type of EBS volume (e.g., gp2, io1).
        public var volumeType: WorkspacesInstancesClientTypes.VolumeTypeEnum?

        public init(
            encrypted: Swift.Bool? = nil,
            iops: Swift.Int? = nil,
            kmsKeyId: Swift.String? = nil,
            throughput: Swift.Int? = nil,
            volumeSize: Swift.Int? = nil,
            volumeType: WorkspacesInstancesClientTypes.VolumeTypeEnum? = nil
        ) {
            self.encrypted = encrypted
            self.iops = iops
            self.kmsKeyId = kmsKeyId
            self.throughput = throughput
            self.volumeSize = volumeSize
            self.volumeType = volumeType
        }
    }
}

extension WorkspacesInstancesClientTypes.EbsBlockDevice: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EbsBlockDevice(encrypted: \(Swift.String(describing: encrypted)), iops: \(Swift.String(describing: iops)), throughput: \(Swift.String(describing: throughput)), volumeSize: \(Swift.String(describing: volumeSize)), volumeType: \(Swift.String(describing: volumeType)), kmsKeyId: \"CONTENT_REDACTED\")"}
}

extension WorkspacesInstancesClientTypes {

    /// Defines device mapping for WorkSpace Instance storage.
    public struct BlockDeviceMappingRequest: Swift.Sendable {
        /// Name of the device for storage mapping.
        public var deviceName: Swift.String?
        /// EBS volume configuration for the device.
        public var ebs: WorkspacesInstancesClientTypes.EbsBlockDevice?
        /// Indicates device should not be mapped.
        public var noDevice: Swift.String?
        /// Virtual device name for ephemeral storage.
        public var virtualName: Swift.String?

        public init(
            deviceName: Swift.String? = nil,
            ebs: WorkspacesInstancesClientTypes.EbsBlockDevice? = nil,
            noDevice: Swift.String? = nil,
            virtualName: Swift.String? = nil
        ) {
            self.deviceName = deviceName
            self.ebs = ebs
            self.noDevice = noDevice
            self.virtualName = virtualName
        }
    }
}

extension WorkspacesInstancesClientTypes {

    public enum CapacityReservationPreferenceEnum: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case capacityReservationsOnly
        case `none`
        case `open`
        case sdkUnknown(Swift.String)

        public static var allCases: [CapacityReservationPreferenceEnum] {
            return [
                .capacityReservationsOnly,
                .none,
                .open
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .capacityReservationsOnly: return "capacity-reservations-only"
            case .none: return "none"
            case .open: return "open"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension WorkspacesInstancesClientTypes {

    /// Identifies a specific capacity reservation.
    public struct CapacityReservationTarget: Swift.Sendable {
        /// Unique identifier for the capacity reservation.
        public var capacityReservationId: Swift.String?
        /// ARN of the capacity reservation resource group.
        public var capacityReservationResourceGroupArn: Swift.String?

        public init(
            capacityReservationId: Swift.String? = nil,
            capacityReservationResourceGroupArn: Swift.String? = nil
        ) {
            self.capacityReservationId = capacityReservationId
            self.capacityReservationResourceGroupArn = capacityReservationResourceGroupArn
        }
    }
}

extension WorkspacesInstancesClientTypes {

    /// Specifies capacity reservation preferences.
    public struct CapacityReservationSpecification: Swift.Sendable {
        /// Preference for using capacity reservation.
        public var capacityReservationPreference: WorkspacesInstancesClientTypes.CapacityReservationPreferenceEnum?
        /// Specific capacity reservation target.
        public var capacityReservationTarget: WorkspacesInstancesClientTypes.CapacityReservationTarget?

        public init(
            capacityReservationPreference: WorkspacesInstancesClientTypes.CapacityReservationPreferenceEnum? = nil,
            capacityReservationTarget: WorkspacesInstancesClientTypes.CapacityReservationTarget? = nil
        ) {
            self.capacityReservationPreference = capacityReservationPreference
            self.capacityReservationTarget = capacityReservationTarget
        }
    }
}

extension WorkspacesInstancesClientTypes {

    /// Defines connection tracking parameters for network interfaces.
    public struct ConnectionTrackingSpecificationRequest: Swift.Sendable {
        /// Timeout for established TCP connections.
        public var tcpEstablishedTimeout: Swift.Int?
        /// Timeout for UDP stream connections.
        public var udpStreamTimeout: Swift.Int?
        /// General timeout for UDP connections.
        public var udpTimeout: Swift.Int?

        public init(
            tcpEstablishedTimeout: Swift.Int? = nil,
            udpStreamTimeout: Swift.Int? = nil,
            udpTimeout: Swift.Int? = nil
        ) {
            self.tcpEstablishedTimeout = tcpEstablishedTimeout
            self.udpStreamTimeout = udpStreamTimeout
            self.udpTimeout = udpTimeout
        }
    }
}

extension WorkspacesInstancesClientTypes {

    public enum CpuCreditsEnum: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case standard
        case unlimited
        case sdkUnknown(Swift.String)

        public static var allCases: [CpuCreditsEnum] {
            return [
                .standard,
                .unlimited
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .standard: return "standard"
            case .unlimited: return "unlimited"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension WorkspacesInstancesClientTypes {

    /// Configures CPU-specific settings for WorkSpace Instance.
    public struct CpuOptionsRequest: Swift.Sendable {
        /// AMD Secure Encrypted Virtualization configuration.
        public var amdSevSnp: WorkspacesInstancesClientTypes.AmdSevSnpEnum?
        /// Number of CPU cores to allocate.
        public var coreCount: Swift.Int?
        /// Number of threads per CPU core.
        public var threadsPerCore: Swift.Int?

        public init(
            amdSevSnp: WorkspacesInstancesClientTypes.AmdSevSnpEnum? = nil,
            coreCount: Swift.Int? = nil,
            threadsPerCore: Swift.Int? = nil
        ) {
            self.amdSevSnp = amdSevSnp
            self.coreCount = coreCount
            self.threadsPerCore = threadsPerCore
        }
    }
}

/// Indicates that a service quota has been exceeded.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// Description of the quota limitation.
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// Specific code for the exceeded quota.
        /// This member is required.
        public internal(set) var quotaCode: Swift.String? = nil
        /// Identifier of the resource related to the quota.
        /// This member is required.
        public internal(set) var resourceId: Swift.String? = nil
        /// Type of resource related to the quota.
        /// This member is required.
        public internal(set) var resourceType: Swift.String? = nil
        /// Code identifying the service with the quota limitation.
        /// This member is required.
        public internal(set) var serviceCode: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        quotaCode: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil,
        serviceCode: Swift.String? = nil
    ) {
        self.properties.message = message
        self.properties.quotaCode = quotaCode
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
        self.properties.serviceCode = serviceCode
    }
}

extension WorkspacesInstancesClientTypes {

    public enum ResourceTypeEnum: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case instance
        case networkInterface
        case spotInstancesRequest
        case volume
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceTypeEnum] {
            return [
                .instance,
                .networkInterface,
                .spotInstancesRequest,
                .volume
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .instance: return "instance"
            case .networkInterface: return "network-interface"
            case .spotInstancesRequest: return "spot-instances-request"
            case .volume: return "volume"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension WorkspacesInstancesClientTypes {

    /// Represents a key-value metadata tag.
    public struct Tag: Swift.Sendable {
        /// Unique identifier for the tag.
        public var key: Swift.String?
        /// Value associated with the tag key.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        ) {
            self.key = key
            self.value = value
        }
    }
}

extension WorkspacesInstancesClientTypes {

    /// Defines tagging configuration for a resource.
    public struct TagSpecification: Swift.Sendable {
        /// Type of resource being tagged.
        public var resourceType: WorkspacesInstancesClientTypes.ResourceTypeEnum?
        /// Collection of tags for the specified resource.
        public var tags: [WorkspacesInstancesClientTypes.Tag]?

        public init(
            resourceType: WorkspacesInstancesClientTypes.ResourceTypeEnum? = nil,
            tags: [WorkspacesInstancesClientTypes.Tag]? = nil
        ) {
            self.resourceType = resourceType
            self.tags = tags
        }
    }
}

/// Specifies volume creation parameters.
public struct CreateVolumeInput: Swift.Sendable {
    /// Availability zone for the volume.
    /// This member is required.
    public var availabilityZone: Swift.String?
    /// Unique token to prevent duplicate volume creation.
    public var clientToken: Swift.String?
    /// Indicates if the volume should be encrypted.
    public var encrypted: Swift.Bool?
    /// Input/output operations per second for the volume.
    public var iops: Swift.Int?
    /// KMS key for volume encryption.
    public var kmsKeyId: Swift.String?
    /// Volume size in gigabytes.
    public var sizeInGB: Swift.Int?
    /// Source snapshot for volume creation.
    public var snapshotId: Swift.String?
    /// Metadata tags for the volume.
    public var tagSpecifications: [WorkspacesInstancesClientTypes.TagSpecification]?
    /// Volume throughput performance.
    public var throughput: Swift.Int?
    /// Type of EBS volume.
    public var volumeType: WorkspacesInstancesClientTypes.VolumeTypeEnum?

    public init(
        availabilityZone: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        encrypted: Swift.Bool? = nil,
        iops: Swift.Int? = nil,
        kmsKeyId: Swift.String? = nil,
        sizeInGB: Swift.Int? = nil,
        snapshotId: Swift.String? = nil,
        tagSpecifications: [WorkspacesInstancesClientTypes.TagSpecification]? = nil,
        throughput: Swift.Int? = nil,
        volumeType: WorkspacesInstancesClientTypes.VolumeTypeEnum? = nil
    ) {
        self.availabilityZone = availabilityZone
        self.clientToken = clientToken
        self.encrypted = encrypted
        self.iops = iops
        self.kmsKeyId = kmsKeyId
        self.sizeInGB = sizeInGB
        self.snapshotId = snapshotId
        self.tagSpecifications = tagSpecifications
        self.throughput = throughput
        self.volumeType = volumeType
    }
}

extension CreateVolumeInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateVolumeInput(availabilityZone: \(Swift.String(describing: availabilityZone)), encrypted: \(Swift.String(describing: encrypted)), iops: \(Swift.String(describing: iops)), sizeInGB: \(Swift.String(describing: sizeInGB)), snapshotId: \(Swift.String(describing: snapshotId)), tagSpecifications: \(Swift.String(describing: tagSpecifications)), throughput: \(Swift.String(describing: throughput)), volumeType: \(Swift.String(describing: volumeType)), clientToken: \"CONTENT_REDACTED\", kmsKeyId: \"CONTENT_REDACTED\")"}
}

/// Returns the created volume identifier.
public struct CreateVolumeOutput: Swift.Sendable {
    /// Unique identifier for the new volume.
    public var volumeId: Swift.String?

    public init(
        volumeId: Swift.String? = nil
    ) {
        self.volumeId = volumeId
    }
}

extension WorkspacesInstancesClientTypes {

    /// Defines CPU credit configuration for burstable instances.
    public struct CreditSpecificationRequest: Swift.Sendable {
        /// CPU credit specification mode.
        public var cpuCredits: WorkspacesInstancesClientTypes.CpuCreditsEnum?

        public init(
            cpuCredits: WorkspacesInstancesClientTypes.CpuCreditsEnum? = nil
        ) {
            self.cpuCredits = cpuCredits
        }
    }
}

extension WorkspacesInstancesClientTypes {

    /// Configures AWS Nitro Enclave options for the WorkSpace Instance.
    public struct EnclaveOptionsRequest: Swift.Sendable {
        /// Enables or disables AWS Nitro Enclaves for enhanced security.
        public var enabled: Swift.Bool?

        public init(
            enabled: Swift.Bool? = nil
        ) {
            self.enabled = enabled
        }
    }
}

extension WorkspacesInstancesClientTypes {

    /// Defines hibernation configuration for the WorkSpace Instance.
    public struct HibernationOptionsRequest: Swift.Sendable {
        /// Enables or disables instance hibernation capability.
        public var configured: Swift.Bool?

        public init(
            configured: Swift.Bool? = nil
        ) {
            self.configured = configured
        }
    }
}

extension WorkspacesInstancesClientTypes {

    /// Defines IAM instance profile configuration for WorkSpace Instance.
    public struct IamInstanceProfileSpecification: Swift.Sendable {
        /// Amazon Resource Name (ARN) of the IAM instance profile.
        public var arn: Swift.String?
        /// Name of the IAM instance profile.
        public var name: Swift.String?

        public init(
            arn: Swift.String? = nil,
            name: Swift.String? = nil
        ) {
            self.arn = arn
            self.name = name
        }
    }
}

extension WorkspacesInstancesClientTypes {

    public enum MarketTypeEnum: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case capacityBlock
        case spot
        case sdkUnknown(Swift.String)

        public static var allCases: [MarketTypeEnum] {
            return [
                .capacityBlock,
                .spot
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .capacityBlock: return "capacity-block"
            case .spot: return "spot"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension WorkspacesInstancesClientTypes {

    public enum InstanceInterruptionBehaviorEnum: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case hibernate
        case stop
        case sdkUnknown(Swift.String)

        public static var allCases: [InstanceInterruptionBehaviorEnum] {
            return [
                .hibernate,
                .stop
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .hibernate: return "hibernate"
            case .stop: return "stop"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension WorkspacesInstancesClientTypes {

    public enum SpotInstanceTypeEnum: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case oneTime
        case persistent
        case sdkUnknown(Swift.String)

        public static var allCases: [SpotInstanceTypeEnum] {
            return [
                .oneTime,
                .persistent
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .oneTime: return "one-time"
            case .persistent: return "persistent"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension WorkspacesInstancesClientTypes {

    /// Defines configuration for spot instance deployment.
    public struct SpotMarketOptions: Swift.Sendable {
        /// Duration of spot instance block reservation.
        public var blockDurationMinutes: Swift.Int?
        /// Specifies behavior when spot instance is interrupted.
        public var instanceInterruptionBehavior: WorkspacesInstancesClientTypes.InstanceInterruptionBehaviorEnum?
        /// Maximum hourly price for spot instance.
        public var maxPrice: Swift.String?
        /// Defines the type of spot instance request.
        public var spotInstanceType: WorkspacesInstancesClientTypes.SpotInstanceTypeEnum?
        /// Timestamp until which spot instance request is valid.
        public var validUntilUtc: Foundation.Date?

        public init(
            blockDurationMinutes: Swift.Int? = nil,
            instanceInterruptionBehavior: WorkspacesInstancesClientTypes.InstanceInterruptionBehaviorEnum? = nil,
            maxPrice: Swift.String? = nil,
            spotInstanceType: WorkspacesInstancesClientTypes.SpotInstanceTypeEnum? = nil,
            validUntilUtc: Foundation.Date? = nil
        ) {
            self.blockDurationMinutes = blockDurationMinutes
            self.instanceInterruptionBehavior = instanceInterruptionBehavior
            self.maxPrice = maxPrice
            self.spotInstanceType = spotInstanceType
            self.validUntilUtc = validUntilUtc
        }
    }
}

extension WorkspacesInstancesClientTypes {

    /// Configures marketplace-specific instance deployment options.
    public struct InstanceMarketOptionsRequest: Swift.Sendable {
        /// Specifies the type of marketplace for instance deployment.
        public var marketType: WorkspacesInstancesClientTypes.MarketTypeEnum?
        /// Configuration options for spot instance deployment.
        public var spotOptions: WorkspacesInstancesClientTypes.SpotMarketOptions?

        public init(
            marketType: WorkspacesInstancesClientTypes.MarketTypeEnum? = nil,
            spotOptions: WorkspacesInstancesClientTypes.SpotMarketOptions? = nil
        ) {
            self.marketType = marketType
            self.spotOptions = spotOptions
        }
    }
}

extension WorkspacesInstancesClientTypes {

    /// Represents an IPv6 address configuration for a WorkSpace Instance.
    public struct InstanceIpv6Address: Swift.Sendable {
        /// Specific IPv6 address assigned to the instance.
        public var ipv6Address: Swift.String?
        /// Indicates if this is the primary IPv6 address for the instance.
        public var isPrimaryIpv6: Swift.Bool?

        public init(
            ipv6Address: Swift.String? = nil,
            isPrimaryIpv6: Swift.Bool? = nil
        ) {
            self.ipv6Address = ipv6Address
            self.isPrimaryIpv6 = isPrimaryIpv6
        }
    }
}

extension WorkspacesInstancesClientTypes.InstanceIpv6Address: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InstanceIpv6Address(isPrimaryIpv6: \(Swift.String(describing: isPrimaryIpv6)), ipv6Address: \"CONTENT_REDACTED\")"}
}

extension WorkspacesInstancesClientTypes {

    /// Specifies license configuration for WorkSpace Instance.
    public struct LicenseConfigurationRequest: Swift.Sendable {
        /// ARN of the license configuration for the WorkSpace Instance.
        public var licenseConfigurationArn: Swift.String?

        public init(
            licenseConfigurationArn: Swift.String? = nil
        ) {
            self.licenseConfigurationArn = licenseConfigurationArn
        }
    }
}

extension WorkspacesInstancesClientTypes {

    /// Configures automatic maintenance settings for WorkSpace Instance.
    public struct InstanceMaintenanceOptionsRequest: Swift.Sendable {
        /// Enables or disables automatic instance recovery.
        public var autoRecovery: WorkspacesInstancesClientTypes.AutoRecoveryEnum?

        public init(
            autoRecovery: WorkspacesInstancesClientTypes.AutoRecoveryEnum? = nil
        ) {
            self.autoRecovery = autoRecovery
        }
    }
}

extension WorkspacesInstancesClientTypes {

    public enum HttpEndpointEnum: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [HttpEndpointEnum] {
            return [
                .disabled,
                .enabled
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "disabled"
            case .enabled: return "enabled"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension WorkspacesInstancesClientTypes {

    public enum HttpProtocolIpv6Enum: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [HttpProtocolIpv6Enum] {
            return [
                .disabled,
                .enabled
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "disabled"
            case .enabled: return "enabled"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension WorkspacesInstancesClientTypes {

    public enum HttpTokensEnum: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case `optional`
        case `required`
        case sdkUnknown(Swift.String)

        public static var allCases: [HttpTokensEnum] {
            return [
                .optional,
                .required
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .optional: return "optional"
            case .required: return "required"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension WorkspacesInstancesClientTypes {

    public enum InstanceMetadataTagsEnum: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case disabled
        case enabled
        case sdkUnknown(Swift.String)

        public static var allCases: [InstanceMetadataTagsEnum] {
            return [
                .disabled,
                .enabled
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .disabled: return "disabled"
            case .enabled: return "enabled"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension WorkspacesInstancesClientTypes {

    /// Defines instance metadata service configuration.
    public struct InstanceMetadataOptionsRequest: Swift.Sendable {
        /// Enables or disables HTTP endpoint for instance metadata.
        public var httpEndpoint: WorkspacesInstancesClientTypes.HttpEndpointEnum?
        /// Configures IPv6 support for instance metadata HTTP protocol.
        public var httpProtocolIpv6: WorkspacesInstancesClientTypes.HttpProtocolIpv6Enum?
        /// Sets maximum number of network hops for metadata PUT responses.
        public var httpPutResponseHopLimit: Swift.Int?
        /// Configures token requirement for instance metadata retrieval.
        public var httpTokens: WorkspacesInstancesClientTypes.HttpTokensEnum?
        /// Enables or disables instance metadata tags retrieval.
        public var instanceMetadataTags: WorkspacesInstancesClientTypes.InstanceMetadataTagsEnum?

        public init(
            httpEndpoint: WorkspacesInstancesClientTypes.HttpEndpointEnum? = nil,
            httpProtocolIpv6: WorkspacesInstancesClientTypes.HttpProtocolIpv6Enum? = nil,
            httpPutResponseHopLimit: Swift.Int? = nil,
            httpTokens: WorkspacesInstancesClientTypes.HttpTokensEnum? = nil,
            instanceMetadataTags: WorkspacesInstancesClientTypes.InstanceMetadataTagsEnum? = nil
        ) {
            self.httpEndpoint = httpEndpoint
            self.httpProtocolIpv6 = httpProtocolIpv6
            self.httpPutResponseHopLimit = httpPutResponseHopLimit
            self.httpTokens = httpTokens
            self.instanceMetadataTags = instanceMetadataTags
        }
    }
}

extension WorkspacesInstancesClientTypes {

    /// Configures detailed monitoring for WorkSpace Instance.
    public struct RunInstancesMonitoringEnabled: Swift.Sendable {
        /// Enables or disables detailed instance monitoring.
        public var enabled: Swift.Bool?

        public init(
            enabled: Swift.Bool? = nil
        ) {
            self.enabled = enabled
        }
    }
}

extension WorkspacesInstancesClientTypes {

    /// Specifies UDP configuration for ENA SRD.
    public struct EnaSrdUdpSpecificationRequest: Swift.Sendable {
        /// Enables or disables ENA SRD for UDP traffic.
        public var enaSrdUdpEnabled: Swift.Bool?

        public init(
            enaSrdUdpEnabled: Swift.Bool? = nil
        ) {
            self.enaSrdUdpEnabled = enaSrdUdpEnabled
        }
    }
}

extension WorkspacesInstancesClientTypes {

    /// Defines Elastic Network Adapter (ENA) Scalable Reliable Datagram (SRD) configuration.
    public struct EnaSrdSpecificationRequest: Swift.Sendable {
        /// Enables or disables ENA SRD for network performance.
        public var enaSrdEnabled: Swift.Bool?
        /// Configures UDP-specific ENA SRD settings.
        public var enaSrdUdpSpecification: WorkspacesInstancesClientTypes.EnaSrdUdpSpecificationRequest?

        public init(
            enaSrdEnabled: Swift.Bool? = nil,
            enaSrdUdpSpecification: WorkspacesInstancesClientTypes.EnaSrdUdpSpecificationRequest? = nil
        ) {
            self.enaSrdEnabled = enaSrdEnabled
            self.enaSrdUdpSpecification = enaSrdUdpSpecification
        }
    }
}

extension WorkspacesInstancesClientTypes {

    public enum InterfaceTypeEnum: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case efa
        case efaOnly
        case interface
        case sdkUnknown(Swift.String)

        public static var allCases: [InterfaceTypeEnum] {
            return [
                .efa,
                .efaOnly,
                .interface
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .efa: return "efa"
            case .efaOnly: return "efa-only"
            case .interface: return "interface"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension WorkspacesInstancesClientTypes {

    /// Specifies IPv4 prefix configuration for network interfaces.
    public struct Ipv4PrefixSpecificationRequest: Swift.Sendable {
        /// Specific IPv4 prefix for network interface configuration.
        public var ipv4Prefix: Swift.String?

        public init(
            ipv4Prefix: Swift.String? = nil
        ) {
            self.ipv4Prefix = ipv4Prefix
        }
    }
}

extension WorkspacesInstancesClientTypes {

    /// Specifies IPv6 prefix configuration for network interfaces.
    public struct Ipv6PrefixSpecificationRequest: Swift.Sendable {
        /// Specific IPv6 prefix for network interface configuration.
        public var ipv6Prefix: Swift.String?

        public init(
            ipv6Prefix: Swift.String? = nil
        ) {
            self.ipv6Prefix = ipv6Prefix
        }
    }
}

extension WorkspacesInstancesClientTypes {

    /// Defines private IP address configuration for network interface.
    public struct PrivateIpAddressSpecification: Swift.Sendable {
        /// Indicates if this is the primary private IP address.
        public var primary: Swift.Bool?
        /// Specific private IP address for the network interface.
        public var privateIpAddress: Swift.String?

        public init(
            primary: Swift.Bool? = nil,
            privateIpAddress: Swift.String? = nil
        ) {
            self.primary = primary
            self.privateIpAddress = privateIpAddress
        }
    }
}

extension WorkspacesInstancesClientTypes.PrivateIpAddressSpecification: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PrivateIpAddressSpecification(primary: \(Swift.String(describing: primary)), privateIpAddress: \"CONTENT_REDACTED\")"}
}

extension WorkspacesInstancesClientTypes {

    /// Defines network interface configuration for WorkSpace Instance.
    public struct InstanceNetworkInterfaceSpecification: Swift.Sendable {
        /// Enables carrier IP address association.
        public var associateCarrierIpAddress: Swift.Bool?
        /// Enables public IP address assignment.
        public var associatePublicIpAddress: Swift.Bool?
        /// Configures network connection tracking parameters.
        public var connectionTrackingSpecification: WorkspacesInstancesClientTypes.ConnectionTrackingSpecificationRequest?
        /// Descriptive text for the network interface.
        public var description: Swift.String?
        /// Unique index for the network interface.
        public var deviceIndex: Swift.Int?
        /// Configures Elastic Network Adapter Scalable Reliable Datagram settings.
        public var enaSrdSpecification: WorkspacesInstancesClientTypes.EnaSrdSpecificationRequest?
        /// Security groups associated with the network interface.
        public var groups: [Swift.String]?
        /// Specifies the type of network interface.
        public var interfaceType: WorkspacesInstancesClientTypes.InterfaceTypeEnum?
        /// Number of IPv4 prefixes to assign.
        public var ipv4PrefixCount: Swift.Int?
        /// IPv4 prefix configurations for the interface.
        public var ipv4Prefixes: [WorkspacesInstancesClientTypes.Ipv4PrefixSpecificationRequest]?
        /// Number of IPv6 addresses to assign.
        public var ipv6AddressCount: Swift.Int?
        /// Specific IPv6 addresses for the interface.
        public var ipv6Addresses: [WorkspacesInstancesClientTypes.InstanceIpv6Address]?
        /// Number of IPv6 prefixes to assign.
        public var ipv6PrefixCount: Swift.Int?
        /// IPv6 prefix configurations for the interface.
        public var ipv6Prefixes: [WorkspacesInstancesClientTypes.Ipv6PrefixSpecificationRequest]?
        /// Index of the network card for multiple network interfaces.
        public var networkCardIndex: Swift.Int?
        /// Unique identifier for the network interface.
        public var networkInterfaceId: Swift.String?
        /// Indicates the primary IPv6 configuration.
        public var primaryIpv6: Swift.Bool?
        /// Primary private IP address for the interface.
        public var privateIpAddress: Swift.String?
        /// List of private IP addresses for the interface.
        public var privateIpAddresses: [WorkspacesInstancesClientTypes.PrivateIpAddressSpecification]?
        /// Number of additional private IP addresses to assign.
        public var secondaryPrivateIpAddressCount: Swift.Int?
        /// Subnet identifier for the network interface.
        public var subnetId: Swift.String?

        public init(
            associateCarrierIpAddress: Swift.Bool? = nil,
            associatePublicIpAddress: Swift.Bool? = nil,
            connectionTrackingSpecification: WorkspacesInstancesClientTypes.ConnectionTrackingSpecificationRequest? = nil,
            description: Swift.String? = nil,
            deviceIndex: Swift.Int? = nil,
            enaSrdSpecification: WorkspacesInstancesClientTypes.EnaSrdSpecificationRequest? = nil,
            groups: [Swift.String]? = nil,
            interfaceType: WorkspacesInstancesClientTypes.InterfaceTypeEnum? = nil,
            ipv4PrefixCount: Swift.Int? = nil,
            ipv4Prefixes: [WorkspacesInstancesClientTypes.Ipv4PrefixSpecificationRequest]? = nil,
            ipv6AddressCount: Swift.Int? = nil,
            ipv6Addresses: [WorkspacesInstancesClientTypes.InstanceIpv6Address]? = nil,
            ipv6PrefixCount: Swift.Int? = nil,
            ipv6Prefixes: [WorkspacesInstancesClientTypes.Ipv6PrefixSpecificationRequest]? = nil,
            networkCardIndex: Swift.Int? = nil,
            networkInterfaceId: Swift.String? = nil,
            primaryIpv6: Swift.Bool? = nil,
            privateIpAddress: Swift.String? = nil,
            privateIpAddresses: [WorkspacesInstancesClientTypes.PrivateIpAddressSpecification]? = nil,
            secondaryPrivateIpAddressCount: Swift.Int? = nil,
            subnetId: Swift.String? = nil
        ) {
            self.associateCarrierIpAddress = associateCarrierIpAddress
            self.associatePublicIpAddress = associatePublicIpAddress
            self.connectionTrackingSpecification = connectionTrackingSpecification
            self.description = description
            self.deviceIndex = deviceIndex
            self.enaSrdSpecification = enaSrdSpecification
            self.groups = groups
            self.interfaceType = interfaceType
            self.ipv4PrefixCount = ipv4PrefixCount
            self.ipv4Prefixes = ipv4Prefixes
            self.ipv6AddressCount = ipv6AddressCount
            self.ipv6Addresses = ipv6Addresses
            self.ipv6PrefixCount = ipv6PrefixCount
            self.ipv6Prefixes = ipv6Prefixes
            self.networkCardIndex = networkCardIndex
            self.networkInterfaceId = networkInterfaceId
            self.primaryIpv6 = primaryIpv6
            self.privateIpAddress = privateIpAddress
            self.privateIpAddresses = privateIpAddresses
            self.secondaryPrivateIpAddressCount = secondaryPrivateIpAddressCount
            self.subnetId = subnetId
        }
    }
}

extension WorkspacesInstancesClientTypes.InstanceNetworkInterfaceSpecification: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "InstanceNetworkInterfaceSpecification(associateCarrierIpAddress: \(Swift.String(describing: associateCarrierIpAddress)), associatePublicIpAddress: \(Swift.String(describing: associatePublicIpAddress)), connectionTrackingSpecification: \(Swift.String(describing: connectionTrackingSpecification)), description: \(Swift.String(describing: description)), deviceIndex: \(Swift.String(describing: deviceIndex)), enaSrdSpecification: \(Swift.String(describing: enaSrdSpecification)), groups: \(Swift.String(describing: groups)), interfaceType: \(Swift.String(describing: interfaceType)), ipv4PrefixCount: \(Swift.String(describing: ipv4PrefixCount)), ipv4Prefixes: \(Swift.String(describing: ipv4Prefixes)), ipv6AddressCount: \(Swift.String(describing: ipv6AddressCount)), ipv6Addresses: \(Swift.String(describing: ipv6Addresses)), ipv6PrefixCount: \(Swift.String(describing: ipv6PrefixCount)), ipv6Prefixes: \(Swift.String(describing: ipv6Prefixes)), networkCardIndex: \(Swift.String(describing: networkCardIndex)), networkInterfaceId: \(Swift.String(describing: networkInterfaceId)), primaryIpv6: \(Swift.String(describing: primaryIpv6)), privateIpAddresses: \(Swift.String(describing: privateIpAddresses)), secondaryPrivateIpAddressCount: \(Swift.String(describing: secondaryPrivateIpAddressCount)), subnetId: \(Swift.String(describing: subnetId)), privateIpAddress: \"CONTENT_REDACTED\")"}
}

extension WorkspacesInstancesClientTypes {

    /// Configures network performance settings for WorkSpace Instance.
    public struct InstanceNetworkPerformanceOptionsRequest: Swift.Sendable {
        /// Defines bandwidth allocation strategy for network interfaces.
        public var bandwidthWeighting: WorkspacesInstancesClientTypes.BandwidthWeightingEnum?

        public init(
            bandwidthWeighting: WorkspacesInstancesClientTypes.BandwidthWeightingEnum? = nil
        ) {
            self.bandwidthWeighting = bandwidthWeighting
        }
    }
}

extension WorkspacesInstancesClientTypes {

    public enum TenancyEnum: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case dedicated
        case `default`
        case host
        case sdkUnknown(Swift.String)

        public static var allCases: [TenancyEnum] {
            return [
                .dedicated,
                .default,
                .host
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .dedicated: return "dedicated"
            case .default: return "default"
            case .host: return "host"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension WorkspacesInstancesClientTypes {

    /// Defines instance placement configuration for WorkSpace Instance.
    public struct Placement: Swift.Sendable {
        /// Specifies host affinity for dedicated instances.
        public var affinity: Swift.String?
        /// Identifies the specific AWS availability zone.
        public var availabilityZone: Swift.String?
        /// Unique identifier for placement group.
        public var groupId: Swift.String?
        /// Name of the placement group.
        public var groupName: Swift.String?
        /// Identifies the specific dedicated host.
        public var hostId: Swift.String?
        /// ARN of the host resource group.
        public var hostResourceGroupArn: Swift.String?
        /// Specifies partition number for partition placement groups.
        public var partitionNumber: Swift.Int?
        /// Defines instance tenancy configuration.
        public var tenancy: WorkspacesInstancesClientTypes.TenancyEnum?

        public init(
            affinity: Swift.String? = nil,
            availabilityZone: Swift.String? = nil,
            groupId: Swift.String? = nil,
            groupName: Swift.String? = nil,
            hostId: Swift.String? = nil,
            hostResourceGroupArn: Swift.String? = nil,
            partitionNumber: Swift.Int? = nil,
            tenancy: WorkspacesInstancesClientTypes.TenancyEnum? = nil
        ) {
            self.affinity = affinity
            self.availabilityZone = availabilityZone
            self.groupId = groupId
            self.groupName = groupName
            self.hostId = hostId
            self.hostResourceGroupArn = hostResourceGroupArn
            self.partitionNumber = partitionNumber
            self.tenancy = tenancy
        }
    }
}

extension WorkspacesInstancesClientTypes {

    public enum HostnameTypeEnum: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case ipName
        case resourceName
        case sdkUnknown(Swift.String)

        public static var allCases: [HostnameTypeEnum] {
            return [
                .ipName,
                .resourceName
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .ipName: return "ip-name"
            case .resourceName: return "resource-name"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension WorkspacesInstancesClientTypes {

    /// Configures private DNS name settings for WorkSpace Instance.
    public struct PrivateDnsNameOptionsRequest: Swift.Sendable {
        /// Enables DNS AAAA record for resource name resolution.
        public var enableResourceNameDnsAAAARecord: Swift.Bool?
        /// Enables DNS A record for resource name resolution.
        public var enableResourceNameDnsARecord: Swift.Bool?
        /// Specifies the type of hostname configuration.
        public var hostnameType: WorkspacesInstancesClientTypes.HostnameTypeEnum?

        public init(
            enableResourceNameDnsAAAARecord: Swift.Bool? = nil,
            enableResourceNameDnsARecord: Swift.Bool? = nil,
            hostnameType: WorkspacesInstancesClientTypes.HostnameTypeEnum? = nil
        ) {
            self.enableResourceNameDnsAAAARecord = enableResourceNameDnsAAAARecord
            self.enableResourceNameDnsARecord = enableResourceNameDnsARecord
            self.hostnameType = hostnameType
        }
    }
}

extension WorkspacesInstancesClientTypes {

    /// Defines comprehensive configuration for a managed WorkSpace Instance.
    public struct ManagedInstanceRequest: Swift.Sendable {
        /// Configures block device mappings for storage.
        public var blockDeviceMappings: [WorkspacesInstancesClientTypes.BlockDeviceMappingRequest]?
        /// Specifies capacity reservation preferences.
        public var capacityReservationSpecification: WorkspacesInstancesClientTypes.CapacityReservationSpecification?
        /// Configures CPU-specific settings.
        public var cpuOptions: WorkspacesInstancesClientTypes.CpuOptionsRequest?
        /// Defines CPU credit configuration for burstable instances.
        public var creditSpecification: WorkspacesInstancesClientTypes.CreditSpecificationRequest?
        /// Prevents API-initiated instance stop.
        public var disableApiStop: Swift.Bool?
        /// Enables optimized EBS performance.
        public var ebsOptimized: Swift.Bool?
        /// Enables primary IPv6 address configuration.
        public var enablePrimaryIpv6: Swift.Bool?
        /// Configures AWS Nitro Enclave settings.
        public var enclaveOptions: WorkspacesInstancesClientTypes.EnclaveOptionsRequest?
        /// Configures instance hibernation capabilities.
        public var hibernationOptions: WorkspacesInstancesClientTypes.HibernationOptionsRequest?
        /// Specifies IAM instance profile configuration.
        public var iamInstanceProfile: WorkspacesInstancesClientTypes.IamInstanceProfileSpecification?
        /// Identifies the Amazon Machine Image (AMI) for the instance.
        public var imageId: Swift.String?
        /// Configures marketplace-specific deployment options.
        public var instanceMarketOptions: WorkspacesInstancesClientTypes.InstanceMarketOptionsRequest?
        /// Specifies the WorkSpace Instance type.
        public var instanceType: Swift.String?
        /// Specifies number of IPv6 addresses to assign.
        public var ipv6AddressCount: Swift.Int?
        /// Configures specific IPv6 addresses.
        public var ipv6Addresses: [WorkspacesInstancesClientTypes.InstanceIpv6Address]?
        /// Identifies the kernel for the instance.
        public var kernelId: Swift.String?
        /// Specifies the key pair for instance access.
        public var keyName: Swift.String?
        /// Configures license-related settings.
        public var licenseSpecifications: [WorkspacesInstancesClientTypes.LicenseConfigurationRequest]?
        /// Defines automatic maintenance settings.
        public var maintenanceOptions: WorkspacesInstancesClientTypes.InstanceMaintenanceOptionsRequest?
        /// Configures instance metadata service settings.
        public var metadataOptions: WorkspacesInstancesClientTypes.InstanceMetadataOptionsRequest?
        /// Enables or disables detailed instance monitoring.
        public var monitoring: WorkspacesInstancesClientTypes.RunInstancesMonitoringEnabled?
        /// Configures network interface settings.
        public var networkInterfaces: [WorkspacesInstancesClientTypes.InstanceNetworkInterfaceSpecification]?
        /// Defines network performance configuration.
        public var networkPerformanceOptions: WorkspacesInstancesClientTypes.InstanceNetworkPerformanceOptionsRequest?
        /// Specifies instance placement preferences.
        public var placement: WorkspacesInstancesClientTypes.Placement?
        /// Configures private DNS name settings.
        public var privateDnsNameOptions: WorkspacesInstancesClientTypes.PrivateDnsNameOptionsRequest?
        /// Specifies the primary private IP address.
        public var privateIpAddress: Swift.String?
        /// Identifies the ramdisk for the instance.
        public var ramdiskId: Swift.String?
        /// Specifies security group identifiers.
        public var securityGroupIds: [Swift.String]?
        /// Configures security group settings.
        public var securityGroups: [Swift.String]?
        /// Identifies the subnet for the instance.
        public var subnetId: Swift.String?
        /// Configures resource tagging specifications.
        public var tagSpecifications: [WorkspacesInstancesClientTypes.TagSpecification]?
        /// Provides custom initialization data for the instance.
        public var userData: Swift.String?

        public init(
            blockDeviceMappings: [WorkspacesInstancesClientTypes.BlockDeviceMappingRequest]? = nil,
            capacityReservationSpecification: WorkspacesInstancesClientTypes.CapacityReservationSpecification? = nil,
            cpuOptions: WorkspacesInstancesClientTypes.CpuOptionsRequest? = nil,
            creditSpecification: WorkspacesInstancesClientTypes.CreditSpecificationRequest? = nil,
            disableApiStop: Swift.Bool? = nil,
            ebsOptimized: Swift.Bool? = nil,
            enablePrimaryIpv6: Swift.Bool? = nil,
            enclaveOptions: WorkspacesInstancesClientTypes.EnclaveOptionsRequest? = nil,
            hibernationOptions: WorkspacesInstancesClientTypes.HibernationOptionsRequest? = nil,
            iamInstanceProfile: WorkspacesInstancesClientTypes.IamInstanceProfileSpecification? = nil,
            imageId: Swift.String? = nil,
            instanceMarketOptions: WorkspacesInstancesClientTypes.InstanceMarketOptionsRequest? = nil,
            instanceType: Swift.String? = nil,
            ipv6AddressCount: Swift.Int? = nil,
            ipv6Addresses: [WorkspacesInstancesClientTypes.InstanceIpv6Address]? = nil,
            kernelId: Swift.String? = nil,
            keyName: Swift.String? = nil,
            licenseSpecifications: [WorkspacesInstancesClientTypes.LicenseConfigurationRequest]? = nil,
            maintenanceOptions: WorkspacesInstancesClientTypes.InstanceMaintenanceOptionsRequest? = nil,
            metadataOptions: WorkspacesInstancesClientTypes.InstanceMetadataOptionsRequest? = nil,
            monitoring: WorkspacesInstancesClientTypes.RunInstancesMonitoringEnabled? = nil,
            networkInterfaces: [WorkspacesInstancesClientTypes.InstanceNetworkInterfaceSpecification]? = nil,
            networkPerformanceOptions: WorkspacesInstancesClientTypes.InstanceNetworkPerformanceOptionsRequest? = nil,
            placement: WorkspacesInstancesClientTypes.Placement? = nil,
            privateDnsNameOptions: WorkspacesInstancesClientTypes.PrivateDnsNameOptionsRequest? = nil,
            privateIpAddress: Swift.String? = nil,
            ramdiskId: Swift.String? = nil,
            securityGroupIds: [Swift.String]? = nil,
            securityGroups: [Swift.String]? = nil,
            subnetId: Swift.String? = nil,
            tagSpecifications: [WorkspacesInstancesClientTypes.TagSpecification]? = nil,
            userData: Swift.String? = nil
        ) {
            self.blockDeviceMappings = blockDeviceMappings
            self.capacityReservationSpecification = capacityReservationSpecification
            self.cpuOptions = cpuOptions
            self.creditSpecification = creditSpecification
            self.disableApiStop = disableApiStop
            self.ebsOptimized = ebsOptimized
            self.enablePrimaryIpv6 = enablePrimaryIpv6
            self.enclaveOptions = enclaveOptions
            self.hibernationOptions = hibernationOptions
            self.iamInstanceProfile = iamInstanceProfile
            self.imageId = imageId
            self.instanceMarketOptions = instanceMarketOptions
            self.instanceType = instanceType
            self.ipv6AddressCount = ipv6AddressCount
            self.ipv6Addresses = ipv6Addresses
            self.kernelId = kernelId
            self.keyName = keyName
            self.licenseSpecifications = licenseSpecifications
            self.maintenanceOptions = maintenanceOptions
            self.metadataOptions = metadataOptions
            self.monitoring = monitoring
            self.networkInterfaces = networkInterfaces
            self.networkPerformanceOptions = networkPerformanceOptions
            self.placement = placement
            self.privateDnsNameOptions = privateDnsNameOptions
            self.privateIpAddress = privateIpAddress
            self.ramdiskId = ramdiskId
            self.securityGroupIds = securityGroupIds
            self.securityGroups = securityGroups
            self.subnetId = subnetId
            self.tagSpecifications = tagSpecifications
            self.userData = userData
        }
    }
}

extension WorkspacesInstancesClientTypes.ManagedInstanceRequest: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ManagedInstanceRequest(blockDeviceMappings: \(Swift.String(describing: blockDeviceMappings)), capacityReservationSpecification: \(Swift.String(describing: capacityReservationSpecification)), cpuOptions: \(Swift.String(describing: cpuOptions)), creditSpecification: \(Swift.String(describing: creditSpecification)), disableApiStop: \(Swift.String(describing: disableApiStop)), ebsOptimized: \(Swift.String(describing: ebsOptimized)), enablePrimaryIpv6: \(Swift.String(describing: enablePrimaryIpv6)), enclaveOptions: \(Swift.String(describing: enclaveOptions)), hibernationOptions: \(Swift.String(describing: hibernationOptions)), iamInstanceProfile: \(Swift.String(describing: iamInstanceProfile)), imageId: \(Swift.String(describing: imageId)), instanceMarketOptions: \(Swift.String(describing: instanceMarketOptions)), instanceType: \(Swift.String(describing: instanceType)), ipv6AddressCount: \(Swift.String(describing: ipv6AddressCount)), ipv6Addresses: \(Swift.String(describing: ipv6Addresses)), kernelId: \(Swift.String(describing: kernelId)), keyName: \(Swift.String(describing: keyName)), licenseSpecifications: \(Swift.String(describing: licenseSpecifications)), maintenanceOptions: \(Swift.String(describing: maintenanceOptions)), metadataOptions: \(Swift.String(describing: metadataOptions)), monitoring: \(Swift.String(describing: monitoring)), networkInterfaces: \(Swift.String(describing: networkInterfaces)), networkPerformanceOptions: \(Swift.String(describing: networkPerformanceOptions)), placement: \(Swift.String(describing: placement)), privateDnsNameOptions: \(Swift.String(describing: privateDnsNameOptions)), ramdiskId: \(Swift.String(describing: ramdiskId)), securityGroupIds: \(Swift.String(describing: securityGroupIds)), securityGroups: \(Swift.String(describing: securityGroups)), subnetId: \(Swift.String(describing: subnetId)), tagSpecifications: \(Swift.String(describing: tagSpecifications)), privateIpAddress: \"CONTENT_REDACTED\", userData: \"CONTENT_REDACTED\")"}
}

/// Defines the configuration parameters for creating a new WorkSpaces Instance.
public struct CreateWorkspaceInstanceInput: Swift.Sendable {
    /// Unique token to ensure idempotent instance creation, preventing duplicate workspace launches.
    public var clientToken: Swift.String?
    /// Comprehensive configuration settings for the WorkSpaces Instance, including network, compute, and storage parameters.
    /// This member is required.
    public var managedInstance: WorkspacesInstancesClientTypes.ManagedInstanceRequest?
    /// Optional metadata tags for categorizing and managing WorkSpaces Instances.
    public var tags: [WorkspacesInstancesClientTypes.Tag]?

    public init(
        clientToken: Swift.String? = nil,
        managedInstance: WorkspacesInstancesClientTypes.ManagedInstanceRequest? = nil,
        tags: [WorkspacesInstancesClientTypes.Tag]? = nil
    ) {
        self.clientToken = clientToken
        self.managedInstance = managedInstance
        self.tags = tags
    }
}

extension CreateWorkspaceInstanceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateWorkspaceInstanceInput(managedInstance: \(Swift.String(describing: managedInstance)), tags: \(Swift.String(describing: tags)), clientToken: \"CONTENT_REDACTED\")"}
}

/// Returns the unique identifier for the newly created WorkSpaces Instance.
public struct CreateWorkspaceInstanceOutput: Swift.Sendable {
    /// Unique identifier assigned to the newly created WorkSpaces Instance.
    public var workspaceInstanceId: Swift.String?

    public init(
        workspaceInstanceId: Swift.String? = nil
    ) {
        self.workspaceInstanceId = workspaceInstanceId
    }
}

/// Specifies the volume to delete.
public struct DeleteVolumeInput: Swift.Sendable {
    /// Identifier of the volume to delete.
    /// This member is required.
    public var volumeId: Swift.String?

    public init(
        volumeId: Swift.String? = nil
    ) {
        self.volumeId = volumeId
    }
}

/// Confirms volume deletion.
public struct DeleteVolumeOutput: Swift.Sendable {

    public init() { }
}

/// The WorkSpace to delete
public struct DeleteWorkspaceInstanceInput: Swift.Sendable {
    /// Unique identifier of the WorkSpaces Instance targeted for deletion.
    /// This member is required.
    public var workspaceInstanceId: Swift.String?

    public init(
        workspaceInstanceId: Swift.String? = nil
    ) {
        self.workspaceInstanceId = workspaceInstanceId
    }
}

/// Confirms the successful deletion of the specified WorkSpace Instance.
public struct DeleteWorkspaceInstanceOutput: Swift.Sendable {

    public init() { }
}

extension WorkspacesInstancesClientTypes {

    public enum DisassociateModeEnum: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case force
        case noForce
        case sdkUnknown(Swift.String)

        public static var allCases: [DisassociateModeEnum] {
            return [
                .force,
                .noForce
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .force: return "FORCE"
            case .noForce: return "NO_FORCE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// Specifies volume detachment parameters.
public struct DisassociateVolumeInput: Swift.Sendable {
    /// Device path of volume to detach.
    public var device: Swift.String?
    /// Mode for volume detachment.
    public var disassociateMode: WorkspacesInstancesClientTypes.DisassociateModeEnum?
    /// Volume to be detached.
    /// This member is required.
    public var volumeId: Swift.String?
    /// WorkSpace Instance to detach volume from.
    /// This member is required.
    public var workspaceInstanceId: Swift.String?

    public init(
        device: Swift.String? = nil,
        disassociateMode: WorkspacesInstancesClientTypes.DisassociateModeEnum? = nil,
        volumeId: Swift.String? = nil,
        workspaceInstanceId: Swift.String? = nil
    ) {
        self.device = device
        self.disassociateMode = disassociateMode
        self.volumeId = volumeId
        self.workspaceInstanceId = workspaceInstanceId
    }
}

/// Confirms volume detachment.
public struct DisassociateVolumeOutput: Swift.Sendable {

    public init() { }
}

extension WorkspacesInstancesClientTypes {

    /// Captures detailed error information for EC2 instance operations.
    public struct EC2InstanceError: Swift.Sendable {
        /// Unique error code identifying the specific EC2 instance error.
        public var ec2ErrorCode: Swift.String?
        /// Detailed description of the EC2 instance error.
        public var ec2ErrorMessage: Swift.String?
        /// Type of exception encountered during EC2 instance operation.
        public var ec2ExceptionType: Swift.String?

        public init(
            ec2ErrorCode: Swift.String? = nil,
            ec2ErrorMessage: Swift.String? = nil,
            ec2ExceptionType: Swift.String? = nil
        ) {
            self.ec2ErrorCode = ec2ErrorCode
            self.ec2ErrorMessage = ec2ErrorMessage
            self.ec2ExceptionType = ec2ExceptionType
        }
    }
}

extension WorkspacesInstancesClientTypes {

    /// Represents an EC2 instance managed by WorkSpaces.
    public struct EC2ManagedInstance: Swift.Sendable {
        /// Unique identifier of the managed EC2 instance.
        public var instanceId: Swift.String?

        public init(
            instanceId: Swift.String? = nil
        ) {
            self.instanceId = instanceId
        }
    }
}

/// Identifies the WorkSpaces Instance to retrieve detailed information for.
public struct GetWorkspaceInstanceInput: Swift.Sendable {
    /// Unique identifier of the WorkSpace Instance to retrieve.
    /// This member is required.
    public var workspaceInstanceId: Swift.String?

    public init(
        workspaceInstanceId: Swift.String? = nil
    ) {
        self.workspaceInstanceId = workspaceInstanceId
    }
}

extension WorkspacesInstancesClientTypes {

    public enum ProvisionStateEnum: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case allocated
        case allocating
        case deallocated
        case deallocating
        case errorAllocating
        case errorDeallocating
        case sdkUnknown(Swift.String)

        public static var allCases: [ProvisionStateEnum] {
            return [
                .allocated,
                .allocating,
                .deallocated,
                .deallocating,
                .errorAllocating,
                .errorDeallocating
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .allocated: return "ALLOCATED"
            case .allocating: return "ALLOCATING"
            case .deallocated: return "DEALLOCATED"
            case .deallocating: return "DEALLOCATING"
            case .errorAllocating: return "ERROR_ALLOCATING"
            case .errorDeallocating: return "ERROR_DEALLOCATING"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension WorkspacesInstancesClientTypes {

    /// Captures errors specific to WorkSpace Instance operations.
    public struct WorkspaceInstanceError: Swift.Sendable {
        /// Unique error code for the WorkSpace Instance error.
        public var errorCode: Swift.String?
        /// Detailed description of the WorkSpace Instance error.
        public var errorMessage: Swift.String?

        public init(
            errorCode: Swift.String? = nil,
            errorMessage: Swift.String? = nil
        ) {
            self.errorCode = errorCode
            self.errorMessage = errorMessage
        }
    }
}

/// Provides comprehensive details about the requested WorkSpaces Instance.
public struct GetWorkspaceInstanceOutput: Swift.Sendable {
    /// Includes any underlying EC2 instance errors encountered.
    public var ec2InstanceErrors: [WorkspacesInstancesClientTypes.EC2InstanceError]?
    /// Details of the associated EC2 managed instance.
    public var ec2ManagedInstance: WorkspacesInstancesClientTypes.EC2ManagedInstance?
    /// Current provisioning state of the WorkSpaces Instance.
    public var provisionState: WorkspacesInstancesClientTypes.ProvisionStateEnum?
    /// Captures any errors specific to the WorkSpace Instance lifecycle.
    public var workspaceInstanceErrors: [WorkspacesInstancesClientTypes.WorkspaceInstanceError]?
    /// Unique identifier of the retrieved WorkSpaces Instance.
    public var workspaceInstanceId: Swift.String?

    public init(
        ec2InstanceErrors: [WorkspacesInstancesClientTypes.EC2InstanceError]? = nil,
        ec2ManagedInstance: WorkspacesInstancesClientTypes.EC2ManagedInstance? = nil,
        provisionState: WorkspacesInstancesClientTypes.ProvisionStateEnum? = nil,
        workspaceInstanceErrors: [WorkspacesInstancesClientTypes.WorkspaceInstanceError]? = nil,
        workspaceInstanceId: Swift.String? = nil
    ) {
        self.ec2InstanceErrors = ec2InstanceErrors
        self.ec2ManagedInstance = ec2ManagedInstance
        self.provisionState = provisionState
        self.workspaceInstanceErrors = workspaceInstanceErrors
        self.workspaceInstanceId = workspaceInstanceId
    }
}

/// Defines input parameters for retrieving supported WorkSpaces Instances instance types.
public struct ListInstanceTypesInput: Swift.Sendable {
    /// Maximum number of instance types to return in a single API call. Enables pagination of instance type results.
    public var maxResults: Swift.Int?
    /// Pagination token for retrieving subsequent pages of instance type results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ListInstanceTypesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListInstanceTypesInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \"CONTENT_REDACTED\")"}
}

extension WorkspacesInstancesClientTypes {

    /// Provides details about a specific WorkSpace Instance type.
    public struct InstanceTypeInfo: Swift.Sendable {
        /// Unique identifier for the WorkSpace Instance type.
        public var instanceType: Swift.String?

        public init(
            instanceType: Swift.String? = nil
        ) {
            self.instanceType = instanceType
        }
    }
}

/// Contains the list of instance types supported by WorkSpaces Instances.
public struct ListInstanceTypesOutput: Swift.Sendable {
    /// Collection of supported instance types for WorkSpaces Instances.
    /// This member is required.
    public var instanceTypes: [WorkspacesInstancesClientTypes.InstanceTypeInfo]?
    /// Token for retrieving additional instance types if the result set is paginated.
    public var nextToken: Swift.String?

    public init(
        instanceTypes: [WorkspacesInstancesClientTypes.InstanceTypeInfo]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.instanceTypes = instanceTypes
        self.nextToken = nextToken
    }
}

extension ListInstanceTypesOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListInstanceTypesOutput(instanceTypes: \(Swift.String(describing: instanceTypes)), nextToken: \"CONTENT_REDACTED\")"}
}

/// Defines input parameters for retrieving supported WorkSpaces Instances regions.
public struct ListRegionsInput: Swift.Sendable {
    /// Maximum number of regions to return in a single API call. Enables pagination of region results.
    public var maxResults: Swift.Int?
    /// Pagination token for retrieving subsequent pages of region results.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension ListRegionsInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListRegionsInput(maxResults: \(Swift.String(describing: maxResults)), nextToken: \"CONTENT_REDACTED\")"}
}

extension WorkspacesInstancesClientTypes {

    /// Represents an AWS region supported by WorkSpaces Instances.
    public struct Region: Swift.Sendable {
        /// Name of the AWS region.
        public var regionName: Swift.String?

        public init(
            regionName: Swift.String? = nil
        ) {
            self.regionName = regionName
        }
    }
}

/// Contains the list of supported AWS regions for WorkSpaces Instances.
public struct ListRegionsOutput: Swift.Sendable {
    /// Token for retrieving additional regions if the result set is paginated.
    public var nextToken: Swift.String?
    /// Collection of AWS regions supported by WorkSpaces Instances.
    /// This member is required.
    public var regions: [WorkspacesInstancesClientTypes.Region]?

    public init(
        nextToken: Swift.String? = nil,
        regions: [WorkspacesInstancesClientTypes.Region]? = nil
    ) {
        self.nextToken = nextToken
        self.regions = regions
    }
}

extension ListRegionsOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListRegionsOutput(regions: \(Swift.String(describing: regions)), nextToken: \"CONTENT_REDACTED\")"}
}

/// Specifies the WorkSpace Instance to retrieve tags for.
public struct ListTagsForResourceInput: Swift.Sendable {
    /// Unique identifier of the WorkSpace Instance.
    /// This member is required.
    public var workspaceInstanceId: Swift.String?

    public init(
        workspaceInstanceId: Swift.String? = nil
    ) {
        self.workspaceInstanceId = workspaceInstanceId
    }
}

/// Returns the list of tags for the specified WorkSpace Instance.
public struct ListTagsForResourceOutput: Swift.Sendable {
    /// Collection of tags associated with the WorkSpace Instance.
    public var tags: [WorkspacesInstancesClientTypes.Tag]?

    public init(
        tags: [WorkspacesInstancesClientTypes.Tag]? = nil
    ) {
        self.tags = tags
    }
}

/// Defines filters and pagination parameters for retrieving WorkSpaces Instances.
public struct ListWorkspaceInstancesInput: Swift.Sendable {
    /// Maximum number of WorkSpaces Instances to return in a single response.
    public var maxResults: Swift.Int?
    /// Pagination token for retrieving subsequent pages of WorkSpaces Instances.
    public var nextToken: Swift.String?
    /// Filter WorkSpaces Instances by their current provisioning states.
    public var provisionStates: [WorkspacesInstancesClientTypes.ProvisionStateEnum]?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        provisionStates: [WorkspacesInstancesClientTypes.ProvisionStateEnum]? = nil
    ) {
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.provisionStates = provisionStates
    }
}

extension ListWorkspaceInstancesInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListWorkspaceInstancesInput(maxResults: \(Swift.String(describing: maxResults)), provisionStates: \(Swift.String(describing: provisionStates)), nextToken: \"CONTENT_REDACTED\")"}
}

extension WorkspacesInstancesClientTypes {

    /// Represents a single WorkSpace Instance.
    public struct WorkspaceInstance: Swift.Sendable {
        /// Details of the associated EC2 managed instance.
        public var ec2ManagedInstance: WorkspacesInstancesClientTypes.EC2ManagedInstance?
        /// Current provisioning state of the WorkSpace Instance.
        public var provisionState: WorkspacesInstancesClientTypes.ProvisionStateEnum?
        /// Unique identifier for the WorkSpace Instance.
        public var workspaceInstanceId: Swift.String?

        public init(
            ec2ManagedInstance: WorkspacesInstancesClientTypes.EC2ManagedInstance? = nil,
            provisionState: WorkspacesInstancesClientTypes.ProvisionStateEnum? = nil,
            workspaceInstanceId: Swift.String? = nil
        ) {
            self.ec2ManagedInstance = ec2ManagedInstance
            self.provisionState = provisionState
            self.workspaceInstanceId = workspaceInstanceId
        }
    }
}

/// Contains the list of WorkSpaces Instances matching the specified criteria.
public struct ListWorkspaceInstancesOutput: Swift.Sendable {
    /// Token for retrieving additional WorkSpaces Instances if the result set is paginated.
    public var nextToken: Swift.String?
    /// Collection of WorkSpaces Instances returned by the query.
    /// This member is required.
    public var workspaceInstances: [WorkspacesInstancesClientTypes.WorkspaceInstance]?

    public init(
        nextToken: Swift.String? = nil,
        workspaceInstances: [WorkspacesInstancesClientTypes.WorkspaceInstance]? = nil
    ) {
        self.nextToken = nextToken
        self.workspaceInstances = workspaceInstances
    }
}

extension ListWorkspaceInstancesOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListWorkspaceInstancesOutput(workspaceInstances: \(Swift.String(describing: workspaceInstances)), nextToken: \"CONTENT_REDACTED\")"}
}

/// Specifies tags to add to a WorkSpace Instance.
public struct TagResourceInput: Swift.Sendable {
    /// Tags to be added to the WorkSpace Instance.
    /// This member is required.
    public var tags: [WorkspacesInstancesClientTypes.Tag]?
    /// Unique identifier of the WorkSpace Instance to tag.
    /// This member is required.
    public var workspaceInstanceId: Swift.String?

    public init(
        tags: [WorkspacesInstancesClientTypes.Tag]? = nil,
        workspaceInstanceId: Swift.String? = nil
    ) {
        self.tags = tags
        self.workspaceInstanceId = workspaceInstanceId
    }
}

/// Confirms successful tag addition.
public struct TagResourceOutput: Swift.Sendable {

    public init() { }
}

/// Specifies tags to remove from a WorkSpace Instance.
public struct UntagResourceInput: Swift.Sendable {
    /// Keys of tags to be removed.
    /// This member is required.
    public var tagKeys: [Swift.String]?
    /// Unique identifier of the WorkSpace Instance to untag.
    /// This member is required.
    public var workspaceInstanceId: Swift.String?

    public init(
        tagKeys: [Swift.String]? = nil,
        workspaceInstanceId: Swift.String? = nil
    ) {
        self.tagKeys = tagKeys
        self.workspaceInstanceId = workspaceInstanceId
    }
}

/// Confirms successful tag removal.
public struct UntagResourceOutput: Swift.Sendable {

    public init() { }
}

extension AssociateVolumeInput {

    static func urlPathProvider(_ value: AssociateVolumeInput) -> Swift.String? {
        return "/"
    }
}

extension CreateVolumeInput {

    static func urlPathProvider(_ value: CreateVolumeInput) -> Swift.String? {
        return "/"
    }
}

extension CreateWorkspaceInstanceInput {

    static func urlPathProvider(_ value: CreateWorkspaceInstanceInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteVolumeInput {

    static func urlPathProvider(_ value: DeleteVolumeInput) -> Swift.String? {
        return "/"
    }
}

extension DeleteWorkspaceInstanceInput {

    static func urlPathProvider(_ value: DeleteWorkspaceInstanceInput) -> Swift.String? {
        return "/"
    }
}

extension DisassociateVolumeInput {

    static func urlPathProvider(_ value: DisassociateVolumeInput) -> Swift.String? {
        return "/"
    }
}

extension GetWorkspaceInstanceInput {

    static func urlPathProvider(_ value: GetWorkspaceInstanceInput) -> Swift.String? {
        return "/"
    }
}

extension ListInstanceTypesInput {

    static func urlPathProvider(_ value: ListInstanceTypesInput) -> Swift.String? {
        return "/"
    }
}

extension ListRegionsInput {

    static func urlPathProvider(_ value: ListRegionsInput) -> Swift.String? {
        return "/"
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        return "/"
    }
}

extension ListWorkspaceInstancesInput {

    static func urlPathProvider(_ value: ListWorkspaceInstancesInput) -> Swift.String? {
        return "/"
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        return "/"
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        return "/"
    }
}

extension AssociateVolumeInput {

    static func write(value: AssociateVolumeInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Device"].write(value.device)
        try writer["VolumeId"].write(value.volumeId)
        try writer["WorkspaceInstanceId"].write(value.workspaceInstanceId)
    }
}

extension CreateVolumeInput {

    static func write(value: CreateVolumeInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AvailabilityZone"].write(value.availabilityZone)
        try writer["ClientToken"].write(value.clientToken)
        try writer["Encrypted"].write(value.encrypted)
        try writer["Iops"].write(value.iops)
        try writer["KmsKeyId"].write(value.kmsKeyId)
        try writer["SizeInGB"].write(value.sizeInGB)
        try writer["SnapshotId"].write(value.snapshotId)
        try writer["TagSpecifications"].writeList(value.tagSpecifications, memberWritingClosure: WorkspacesInstancesClientTypes.TagSpecification.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Throughput"].write(value.throughput)
        try writer["VolumeType"].write(value.volumeType)
    }
}

extension CreateWorkspaceInstanceInput {

    static func write(value: CreateWorkspaceInstanceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClientToken"].write(value.clientToken)
        try writer["ManagedInstance"].write(value.managedInstance, with: WorkspacesInstancesClientTypes.ManagedInstanceRequest.write(value:to:))
        try writer["Tags"].writeList(value.tags, memberWritingClosure: WorkspacesInstancesClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension DeleteVolumeInput {

    static func write(value: DeleteVolumeInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["VolumeId"].write(value.volumeId)
    }
}

extension DeleteWorkspaceInstanceInput {

    static func write(value: DeleteWorkspaceInstanceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["WorkspaceInstanceId"].write(value.workspaceInstanceId)
    }
}

extension DisassociateVolumeInput {

    static func write(value: DisassociateVolumeInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Device"].write(value.device)
        try writer["DisassociateMode"].write(value.disassociateMode)
        try writer["VolumeId"].write(value.volumeId)
        try writer["WorkspaceInstanceId"].write(value.workspaceInstanceId)
    }
}

extension GetWorkspaceInstanceInput {

    static func write(value: GetWorkspaceInstanceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["WorkspaceInstanceId"].write(value.workspaceInstanceId)
    }
}

extension ListInstanceTypesInput {

    static func write(value: ListInstanceTypesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension ListRegionsInput {

    static func write(value: ListRegionsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension ListTagsForResourceInput {

    static func write(value: ListTagsForResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["WorkspaceInstanceId"].write(value.workspaceInstanceId)
    }
}

extension ListWorkspaceInstancesInput {

    static func write(value: ListWorkspaceInstancesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["ProvisionStates"].writeList(value.provisionStates, memberWritingClosure: SmithyReadWrite.WritingClosureBox<WorkspacesInstancesClientTypes.ProvisionStateEnum>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Tags"].writeList(value.tags, memberWritingClosure: WorkspacesInstancesClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["WorkspaceInstanceId"].write(value.workspaceInstanceId)
    }
}

extension UntagResourceInput {

    static func write(value: UntagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["TagKeys"].writeList(value.tagKeys, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["WorkspaceInstanceId"].write(value.workspaceInstanceId)
    }
}

extension AssociateVolumeOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AssociateVolumeOutput {
        return AssociateVolumeOutput()
    }
}

extension CreateVolumeOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateVolumeOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateVolumeOutput()
        value.volumeId = try reader["VolumeId"].readIfPresent()
        return value
    }
}

extension CreateWorkspaceInstanceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateWorkspaceInstanceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateWorkspaceInstanceOutput()
        value.workspaceInstanceId = try reader["WorkspaceInstanceId"].readIfPresent()
        return value
    }
}

extension DeleteVolumeOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteVolumeOutput {
        return DeleteVolumeOutput()
    }
}

extension DeleteWorkspaceInstanceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteWorkspaceInstanceOutput {
        return DeleteWorkspaceInstanceOutput()
    }
}

extension DisassociateVolumeOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DisassociateVolumeOutput {
        return DisassociateVolumeOutput()
    }
}

extension GetWorkspaceInstanceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetWorkspaceInstanceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetWorkspaceInstanceOutput()
        value.ec2InstanceErrors = try reader["EC2InstanceErrors"].readListIfPresent(memberReadingClosure: WorkspacesInstancesClientTypes.EC2InstanceError.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.ec2ManagedInstance = try reader["EC2ManagedInstance"].readIfPresent(with: WorkspacesInstancesClientTypes.EC2ManagedInstance.read(from:))
        value.provisionState = try reader["ProvisionState"].readIfPresent()
        value.workspaceInstanceErrors = try reader["WorkspaceInstanceErrors"].readListIfPresent(memberReadingClosure: WorkspacesInstancesClientTypes.WorkspaceInstanceError.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.workspaceInstanceId = try reader["WorkspaceInstanceId"].readIfPresent()
        return value
    }
}

extension ListInstanceTypesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListInstanceTypesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListInstanceTypesOutput()
        value.instanceTypes = try reader["InstanceTypes"].readListIfPresent(memberReadingClosure: WorkspacesInstancesClientTypes.InstanceTypeInfo.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListRegionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListRegionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListRegionsOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.regions = try reader["Regions"].readListIfPresent(memberReadingClosure: WorkspacesInstancesClientTypes.Region.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.tags = try reader["Tags"].readListIfPresent(memberReadingClosure: WorkspacesInstancesClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListWorkspaceInstancesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListWorkspaceInstancesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListWorkspaceInstancesOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.workspaceInstances = try reader["WorkspaceInstances"].readListIfPresent(memberReadingClosure: WorkspacesInstancesClientTypes.WorkspaceInstance.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

enum AssociateVolumeOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateVolumeOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateWorkspaceInstanceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteVolumeOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteWorkspaceInstanceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DisassociateVolumeOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetWorkspaceInstanceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListInstanceTypesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListRegionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListWorkspaceInstancesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension AccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> AccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = AccessDeniedException()
        value.properties.message = try reader["Message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ConflictException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ConflictException {
        let reader = baseError.errorBodyReader
        var value = ConflictException()
        value.properties.message = try reader["Message"].readIfPresent() ?? ""
        value.properties.resourceId = try reader["ResourceId"].readIfPresent() ?? ""
        value.properties.resourceType = try reader["ResourceType"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InternalServerException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InternalServerException {
        let reader = baseError.errorBodyReader
        let httpResponse = baseError.httpResponse
        var value = InternalServerException()
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            value.properties.retryAfterSeconds = Swift.Int(retryAfterSecondsHeaderValue) ?? 0
        }
        value.properties.message = try reader["Message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.message = try reader["Message"].readIfPresent() ?? ""
        value.properties.resourceId = try reader["ResourceId"].readIfPresent() ?? ""
        value.properties.resourceType = try reader["ResourceType"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ThrottlingException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ThrottlingException {
        let reader = baseError.errorBodyReader
        let httpResponse = baseError.httpResponse
        var value = ThrottlingException()
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            value.properties.retryAfterSeconds = Swift.Int(retryAfterSecondsHeaderValue) ?? 0
        }
        value.properties.message = try reader["Message"].readIfPresent() ?? ""
        value.properties.quotaCode = try reader["QuotaCode"].readIfPresent()
        value.properties.serviceCode = try reader["ServiceCode"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ValidationException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ValidationException {
        let reader = baseError.errorBodyReader
        var value = ValidationException()
        value.properties.fieldList = try reader["FieldList"].readListIfPresent(memberReadingClosure: WorkspacesInstancesClientTypes.ValidationExceptionField.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.properties.message = try reader["Message"].readIfPresent() ?? ""
        value.properties.reason = try reader["Reason"].readIfPresent() ?? .sdkUnknown("")
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ServiceQuotaExceededException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ServiceQuotaExceededException {
        let reader = baseError.errorBodyReader
        var value = ServiceQuotaExceededException()
        value.properties.message = try reader["Message"].readIfPresent() ?? ""
        value.properties.quotaCode = try reader["QuotaCode"].readIfPresent() ?? ""
        value.properties.resourceId = try reader["ResourceId"].readIfPresent() ?? ""
        value.properties.resourceType = try reader["ResourceType"].readIfPresent() ?? ""
        value.properties.serviceCode = try reader["ServiceCode"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension WorkspacesInstancesClientTypes.WorkspaceInstanceError {

    static func read(from reader: SmithyJSON.Reader) throws -> WorkspacesInstancesClientTypes.WorkspaceInstanceError {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WorkspacesInstancesClientTypes.WorkspaceInstanceError()
        value.errorCode = try reader["ErrorCode"].readIfPresent()
        value.errorMessage = try reader["ErrorMessage"].readIfPresent()
        return value
    }
}

extension WorkspacesInstancesClientTypes.EC2InstanceError {

    static func read(from reader: SmithyJSON.Reader) throws -> WorkspacesInstancesClientTypes.EC2InstanceError {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WorkspacesInstancesClientTypes.EC2InstanceError()
        value.ec2ErrorCode = try reader["EC2ErrorCode"].readIfPresent()
        value.ec2ExceptionType = try reader["EC2ExceptionType"].readIfPresent()
        value.ec2ErrorMessage = try reader["EC2ErrorMessage"].readIfPresent()
        return value
    }
}

extension WorkspacesInstancesClientTypes.EC2ManagedInstance {

    static func read(from reader: SmithyJSON.Reader) throws -> WorkspacesInstancesClientTypes.EC2ManagedInstance {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WorkspacesInstancesClientTypes.EC2ManagedInstance()
        value.instanceId = try reader["InstanceId"].readIfPresent()
        return value
    }
}

extension WorkspacesInstancesClientTypes.InstanceTypeInfo {

    static func read(from reader: SmithyJSON.Reader) throws -> WorkspacesInstancesClientTypes.InstanceTypeInfo {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WorkspacesInstancesClientTypes.InstanceTypeInfo()
        value.instanceType = try reader["InstanceType"].readIfPresent()
        return value
    }
}

extension WorkspacesInstancesClientTypes.Region {

    static func read(from reader: SmithyJSON.Reader) throws -> WorkspacesInstancesClientTypes.Region {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WorkspacesInstancesClientTypes.Region()
        value.regionName = try reader["RegionName"].readIfPresent()
        return value
    }
}

extension WorkspacesInstancesClientTypes.Tag {

    static func write(value: WorkspacesInstancesClientTypes.Tag?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Key"].write(value.key)
        try writer["Value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> WorkspacesInstancesClientTypes.Tag {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WorkspacesInstancesClientTypes.Tag()
        value.key = try reader["Key"].readIfPresent()
        value.value = try reader["Value"].readIfPresent()
        return value
    }
}

extension WorkspacesInstancesClientTypes.WorkspaceInstance {

    static func read(from reader: SmithyJSON.Reader) throws -> WorkspacesInstancesClientTypes.WorkspaceInstance {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WorkspacesInstancesClientTypes.WorkspaceInstance()
        value.provisionState = try reader["ProvisionState"].readIfPresent()
        value.workspaceInstanceId = try reader["WorkspaceInstanceId"].readIfPresent()
        value.ec2ManagedInstance = try reader["EC2ManagedInstance"].readIfPresent(with: WorkspacesInstancesClientTypes.EC2ManagedInstance.read(from:))
        return value
    }
}

extension WorkspacesInstancesClientTypes.ValidationExceptionField {

    static func read(from reader: SmithyJSON.Reader) throws -> WorkspacesInstancesClientTypes.ValidationExceptionField {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WorkspacesInstancesClientTypes.ValidationExceptionField()
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.reason = try reader["Reason"].readIfPresent() ?? ""
        value.message = try reader["Message"].readIfPresent() ?? ""
        return value
    }
}

extension WorkspacesInstancesClientTypes.TagSpecification {

    static func write(value: WorkspacesInstancesClientTypes.TagSpecification?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceType"].write(value.resourceType)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: WorkspacesInstancesClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension WorkspacesInstancesClientTypes.ManagedInstanceRequest {

    static func write(value: WorkspacesInstancesClientTypes.ManagedInstanceRequest?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BlockDeviceMappings"].writeList(value.blockDeviceMappings, memberWritingClosure: WorkspacesInstancesClientTypes.BlockDeviceMappingRequest.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["CapacityReservationSpecification"].write(value.capacityReservationSpecification, with: WorkspacesInstancesClientTypes.CapacityReservationSpecification.write(value:to:))
        try writer["CpuOptions"].write(value.cpuOptions, with: WorkspacesInstancesClientTypes.CpuOptionsRequest.write(value:to:))
        try writer["CreditSpecification"].write(value.creditSpecification, with: WorkspacesInstancesClientTypes.CreditSpecificationRequest.write(value:to:))
        try writer["DisableApiStop"].write(value.disableApiStop)
        try writer["EbsOptimized"].write(value.ebsOptimized)
        try writer["EnablePrimaryIpv6"].write(value.enablePrimaryIpv6)
        try writer["EnclaveOptions"].write(value.enclaveOptions, with: WorkspacesInstancesClientTypes.EnclaveOptionsRequest.write(value:to:))
        try writer["HibernationOptions"].write(value.hibernationOptions, with: WorkspacesInstancesClientTypes.HibernationOptionsRequest.write(value:to:))
        try writer["IamInstanceProfile"].write(value.iamInstanceProfile, with: WorkspacesInstancesClientTypes.IamInstanceProfileSpecification.write(value:to:))
        try writer["ImageId"].write(value.imageId)
        try writer["InstanceMarketOptions"].write(value.instanceMarketOptions, with: WorkspacesInstancesClientTypes.InstanceMarketOptionsRequest.write(value:to:))
        try writer["InstanceType"].write(value.instanceType)
        try writer["Ipv6AddressCount"].write(value.ipv6AddressCount)
        try writer["Ipv6Addresses"].writeList(value.ipv6Addresses, memberWritingClosure: WorkspacesInstancesClientTypes.InstanceIpv6Address.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["KernelId"].write(value.kernelId)
        try writer["KeyName"].write(value.keyName)
        try writer["LicenseSpecifications"].writeList(value.licenseSpecifications, memberWritingClosure: WorkspacesInstancesClientTypes.LicenseConfigurationRequest.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["MaintenanceOptions"].write(value.maintenanceOptions, with: WorkspacesInstancesClientTypes.InstanceMaintenanceOptionsRequest.write(value:to:))
        try writer["MetadataOptions"].write(value.metadataOptions, with: WorkspacesInstancesClientTypes.InstanceMetadataOptionsRequest.write(value:to:))
        try writer["Monitoring"].write(value.monitoring, with: WorkspacesInstancesClientTypes.RunInstancesMonitoringEnabled.write(value:to:))
        try writer["NetworkInterfaces"].writeList(value.networkInterfaces, memberWritingClosure: WorkspacesInstancesClientTypes.InstanceNetworkInterfaceSpecification.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["NetworkPerformanceOptions"].write(value.networkPerformanceOptions, with: WorkspacesInstancesClientTypes.InstanceNetworkPerformanceOptionsRequest.write(value:to:))
        try writer["Placement"].write(value.placement, with: WorkspacesInstancesClientTypes.Placement.write(value:to:))
        try writer["PrivateDnsNameOptions"].write(value.privateDnsNameOptions, with: WorkspacesInstancesClientTypes.PrivateDnsNameOptionsRequest.write(value:to:))
        try writer["PrivateIpAddress"].write(value.privateIpAddress)
        try writer["RamdiskId"].write(value.ramdiskId)
        try writer["SecurityGroupIds"].writeList(value.securityGroupIds, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["SecurityGroups"].writeList(value.securityGroups, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["SubnetId"].write(value.subnetId)
        try writer["TagSpecifications"].writeList(value.tagSpecifications, memberWritingClosure: WorkspacesInstancesClientTypes.TagSpecification.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["UserData"].write(value.userData)
    }
}

extension WorkspacesInstancesClientTypes.PrivateDnsNameOptionsRequest {

    static func write(value: WorkspacesInstancesClientTypes.PrivateDnsNameOptionsRequest?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EnableResourceNameDnsAAAARecord"].write(value.enableResourceNameDnsAAAARecord)
        try writer["EnableResourceNameDnsARecord"].write(value.enableResourceNameDnsARecord)
        try writer["HostnameType"].write(value.hostnameType)
    }
}

extension WorkspacesInstancesClientTypes.Placement {

    static func write(value: WorkspacesInstancesClientTypes.Placement?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Affinity"].write(value.affinity)
        try writer["AvailabilityZone"].write(value.availabilityZone)
        try writer["GroupId"].write(value.groupId)
        try writer["GroupName"].write(value.groupName)
        try writer["HostId"].write(value.hostId)
        try writer["HostResourceGroupArn"].write(value.hostResourceGroupArn)
        try writer["PartitionNumber"].write(value.partitionNumber)
        try writer["Tenancy"].write(value.tenancy)
    }
}

extension WorkspacesInstancesClientTypes.InstanceNetworkPerformanceOptionsRequest {

    static func write(value: WorkspacesInstancesClientTypes.InstanceNetworkPerformanceOptionsRequest?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BandwidthWeighting"].write(value.bandwidthWeighting)
    }
}

extension WorkspacesInstancesClientTypes.InstanceNetworkInterfaceSpecification {

    static func write(value: WorkspacesInstancesClientTypes.InstanceNetworkInterfaceSpecification?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AssociateCarrierIpAddress"].write(value.associateCarrierIpAddress)
        try writer["AssociatePublicIpAddress"].write(value.associatePublicIpAddress)
        try writer["ConnectionTrackingSpecification"].write(value.connectionTrackingSpecification, with: WorkspacesInstancesClientTypes.ConnectionTrackingSpecificationRequest.write(value:to:))
        try writer["Description"].write(value.description)
        try writer["DeviceIndex"].write(value.deviceIndex)
        try writer["EnaSrdSpecification"].write(value.enaSrdSpecification, with: WorkspacesInstancesClientTypes.EnaSrdSpecificationRequest.write(value:to:))
        try writer["Groups"].writeList(value.groups, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["InterfaceType"].write(value.interfaceType)
        try writer["Ipv4PrefixCount"].write(value.ipv4PrefixCount)
        try writer["Ipv4Prefixes"].writeList(value.ipv4Prefixes, memberWritingClosure: WorkspacesInstancesClientTypes.Ipv4PrefixSpecificationRequest.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Ipv6AddressCount"].write(value.ipv6AddressCount)
        try writer["Ipv6Addresses"].writeList(value.ipv6Addresses, memberWritingClosure: WorkspacesInstancesClientTypes.InstanceIpv6Address.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Ipv6PrefixCount"].write(value.ipv6PrefixCount)
        try writer["Ipv6Prefixes"].writeList(value.ipv6Prefixes, memberWritingClosure: WorkspacesInstancesClientTypes.Ipv6PrefixSpecificationRequest.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["NetworkCardIndex"].write(value.networkCardIndex)
        try writer["NetworkInterfaceId"].write(value.networkInterfaceId)
        try writer["PrimaryIpv6"].write(value.primaryIpv6)
        try writer["PrivateIpAddress"].write(value.privateIpAddress)
        try writer["PrivateIpAddresses"].writeList(value.privateIpAddresses, memberWritingClosure: WorkspacesInstancesClientTypes.PrivateIpAddressSpecification.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["SecondaryPrivateIpAddressCount"].write(value.secondaryPrivateIpAddressCount)
        try writer["SubnetId"].write(value.subnetId)
    }
}

extension WorkspacesInstancesClientTypes.PrivateIpAddressSpecification {

    static func write(value: WorkspacesInstancesClientTypes.PrivateIpAddressSpecification?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Primary"].write(value.primary)
        try writer["PrivateIpAddress"].write(value.privateIpAddress)
    }
}

extension WorkspacesInstancesClientTypes.Ipv6PrefixSpecificationRequest {

    static func write(value: WorkspacesInstancesClientTypes.Ipv6PrefixSpecificationRequest?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Ipv6Prefix"].write(value.ipv6Prefix)
    }
}

extension WorkspacesInstancesClientTypes.InstanceIpv6Address {

    static func write(value: WorkspacesInstancesClientTypes.InstanceIpv6Address?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Ipv6Address"].write(value.ipv6Address)
        try writer["IsPrimaryIpv6"].write(value.isPrimaryIpv6)
    }
}

extension WorkspacesInstancesClientTypes.Ipv4PrefixSpecificationRequest {

    static func write(value: WorkspacesInstancesClientTypes.Ipv4PrefixSpecificationRequest?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Ipv4Prefix"].write(value.ipv4Prefix)
    }
}

extension WorkspacesInstancesClientTypes.EnaSrdSpecificationRequest {

    static func write(value: WorkspacesInstancesClientTypes.EnaSrdSpecificationRequest?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EnaSrdEnabled"].write(value.enaSrdEnabled)
        try writer["EnaSrdUdpSpecification"].write(value.enaSrdUdpSpecification, with: WorkspacesInstancesClientTypes.EnaSrdUdpSpecificationRequest.write(value:to:))
    }
}

extension WorkspacesInstancesClientTypes.EnaSrdUdpSpecificationRequest {

    static func write(value: WorkspacesInstancesClientTypes.EnaSrdUdpSpecificationRequest?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["EnaSrdUdpEnabled"].write(value.enaSrdUdpEnabled)
    }
}

extension WorkspacesInstancesClientTypes.ConnectionTrackingSpecificationRequest {

    static func write(value: WorkspacesInstancesClientTypes.ConnectionTrackingSpecificationRequest?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["TcpEstablishedTimeout"].write(value.tcpEstablishedTimeout)
        try writer["UdpStreamTimeout"].write(value.udpStreamTimeout)
        try writer["UdpTimeout"].write(value.udpTimeout)
    }
}

extension WorkspacesInstancesClientTypes.RunInstancesMonitoringEnabled {

    static func write(value: WorkspacesInstancesClientTypes.RunInstancesMonitoringEnabled?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Enabled"].write(value.enabled)
    }
}

extension WorkspacesInstancesClientTypes.InstanceMetadataOptionsRequest {

    static func write(value: WorkspacesInstancesClientTypes.InstanceMetadataOptionsRequest?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["HttpEndpoint"].write(value.httpEndpoint)
        try writer["HttpProtocolIpv6"].write(value.httpProtocolIpv6)
        try writer["HttpPutResponseHopLimit"].write(value.httpPutResponseHopLimit)
        try writer["HttpTokens"].write(value.httpTokens)
        try writer["InstanceMetadataTags"].write(value.instanceMetadataTags)
    }
}

extension WorkspacesInstancesClientTypes.InstanceMaintenanceOptionsRequest {

    static func write(value: WorkspacesInstancesClientTypes.InstanceMaintenanceOptionsRequest?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AutoRecovery"].write(value.autoRecovery)
    }
}

extension WorkspacesInstancesClientTypes.LicenseConfigurationRequest {

    static func write(value: WorkspacesInstancesClientTypes.LicenseConfigurationRequest?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["LicenseConfigurationArn"].write(value.licenseConfigurationArn)
    }
}

extension WorkspacesInstancesClientTypes.InstanceMarketOptionsRequest {

    static func write(value: WorkspacesInstancesClientTypes.InstanceMarketOptionsRequest?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["MarketType"].write(value.marketType)
        try writer["SpotOptions"].write(value.spotOptions, with: WorkspacesInstancesClientTypes.SpotMarketOptions.write(value:to:))
    }
}

extension WorkspacesInstancesClientTypes.SpotMarketOptions {

    static func write(value: WorkspacesInstancesClientTypes.SpotMarketOptions?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BlockDurationMinutes"].write(value.blockDurationMinutes)
        try writer["InstanceInterruptionBehavior"].write(value.instanceInterruptionBehavior)
        try writer["MaxPrice"].write(value.maxPrice)
        try writer["SpotInstanceType"].write(value.spotInstanceType)
        try writer["ValidUntilUtc"].writeTimestamp(value.validUntilUtc, format: SmithyTimestamps.TimestampFormat.epochSeconds)
    }
}

extension WorkspacesInstancesClientTypes.IamInstanceProfileSpecification {

    static func write(value: WorkspacesInstancesClientTypes.IamInstanceProfileSpecification?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Arn"].write(value.arn)
        try writer["Name"].write(value.name)
    }
}

extension WorkspacesInstancesClientTypes.HibernationOptionsRequest {

    static func write(value: WorkspacesInstancesClientTypes.HibernationOptionsRequest?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Configured"].write(value.configured)
    }
}

extension WorkspacesInstancesClientTypes.EnclaveOptionsRequest {

    static func write(value: WorkspacesInstancesClientTypes.EnclaveOptionsRequest?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Enabled"].write(value.enabled)
    }
}

extension WorkspacesInstancesClientTypes.CreditSpecificationRequest {

    static func write(value: WorkspacesInstancesClientTypes.CreditSpecificationRequest?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CpuCredits"].write(value.cpuCredits)
    }
}

extension WorkspacesInstancesClientTypes.CpuOptionsRequest {

    static func write(value: WorkspacesInstancesClientTypes.CpuOptionsRequest?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AmdSevSnp"].write(value.amdSevSnp)
        try writer["CoreCount"].write(value.coreCount)
        try writer["ThreadsPerCore"].write(value.threadsPerCore)
    }
}

extension WorkspacesInstancesClientTypes.CapacityReservationSpecification {

    static func write(value: WorkspacesInstancesClientTypes.CapacityReservationSpecification?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CapacityReservationPreference"].write(value.capacityReservationPreference)
        try writer["CapacityReservationTarget"].write(value.capacityReservationTarget, with: WorkspacesInstancesClientTypes.CapacityReservationTarget.write(value:to:))
    }
}

extension WorkspacesInstancesClientTypes.CapacityReservationTarget {

    static func write(value: WorkspacesInstancesClientTypes.CapacityReservationTarget?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CapacityReservationId"].write(value.capacityReservationId)
        try writer["CapacityReservationResourceGroupArn"].write(value.capacityReservationResourceGroupArn)
    }
}

extension WorkspacesInstancesClientTypes.BlockDeviceMappingRequest {

    static func write(value: WorkspacesInstancesClientTypes.BlockDeviceMappingRequest?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["DeviceName"].write(value.deviceName)
        try writer["Ebs"].write(value.ebs, with: WorkspacesInstancesClientTypes.EbsBlockDevice.write(value:to:))
        try writer["NoDevice"].write(value.noDevice)
        try writer["VirtualName"].write(value.virtualName)
    }
}

extension WorkspacesInstancesClientTypes.EbsBlockDevice {

    static func write(value: WorkspacesInstancesClientTypes.EbsBlockDevice?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Encrypted"].write(value.encrypted)
        try writer["Iops"].write(value.iops)
        try writer["KmsKeyId"].write(value.kmsKeyId)
        try writer["Throughput"].write(value.throughput)
        try writer["VolumeSize"].write(value.volumeSize)
        try writer["VolumeType"].write(value.volumeType)
    }
}

public enum WorkspacesInstancesClientTypes {}
