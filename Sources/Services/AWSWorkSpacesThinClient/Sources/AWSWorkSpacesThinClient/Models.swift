//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum Smithy.ClientError
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.RestJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
import struct Smithy.URIQueryItem
@_spi(SmithyReadWrite) import struct SmithyReadWrite.ReadingClosureBox
@_spi(SmithyReadWrite) import struct SmithyReadWrite.WritingClosureBox

/// You do not have sufficient access to perform this action.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

extension WorkSpacesThinClientClientTypes {

    public enum ApplyTimeOf: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case device
        case utc
        case sdkUnknown(Swift.String)

        public static var allCases: [ApplyTimeOf] {
            return [
                .device,
                .utc
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .device: return "DEVICE"
            case .utc: return "UTC"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// The requested operation would cause a conflict with the current state of a service resource associated with the request. Resolve the conflict before retrying this request.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        /// The ID of the resource associated with the request.
        public internal(set) var resourceId: Swift.String? = nil
        /// The type of the resource associated with the request.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
    }
}

/// The server encountered an internal error and is unable to complete the request.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        /// The number of seconds to wait before retrying the next request.
        public internal(set) var retryAfterSeconds: Swift.Int? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        retryAfterSeconds: Swift.Int? = nil
    )
    {
        self.properties.message = message
        self.properties.retryAfterSeconds = retryAfterSeconds
    }
}

/// The resource specified in the request was not found.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        /// The ID of the resource associated with the request.
        public internal(set) var resourceId: Swift.String? = nil
        /// The type of the resource associated with the request.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
    }
}

/// Your request exceeds a service quota.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        /// The code for the quota in [Service Quotas](https://docs.aws.amazon.com/servicequotas/latest/userguide/intro.html).
        public internal(set) var quotaCode: Swift.String? = nil
        /// The ID of the resource that exceeds the service quota.
        public internal(set) var resourceId: Swift.String? = nil
        /// The type of the resource that exceeds the service quota.
        public internal(set) var resourceType: Swift.String? = nil
        /// The code for the service in [Service Quotas](https://docs.aws.amazon.com/servicequotas/latest/userguide/intro.html).
        public internal(set) var serviceCode: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        quotaCode: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil,
        serviceCode: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.quotaCode = quotaCode
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
        self.properties.serviceCode = serviceCode
    }
}

/// The request was denied due to request throttling.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        /// The code for the quota in [Service Quotas](https://docs.aws.amazon.com/servicequotas/latest/userguide/intro.html).
        public internal(set) var quotaCode: Swift.String? = nil
        /// The number of seconds to wait before retrying the next request.
        public internal(set) var retryAfterSeconds: Swift.Int? = nil
        /// The code for the service in [Service Quotas](https://docs.aws.amazon.com/servicequotas/latest/userguide/intro.html).
        public internal(set) var serviceCode: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        quotaCode: Swift.String? = nil,
        retryAfterSeconds: Swift.Int? = nil,
        serviceCode: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.quotaCode = quotaCode
        self.properties.retryAfterSeconds = retryAfterSeconds
        self.properties.serviceCode = serviceCode
    }
}

extension WorkSpacesThinClientClientTypes {

    /// Describes a validation exception.
    public struct ValidationExceptionField: Swift.Sendable {
        /// A message that describes the reason for the exception.
        /// This member is required.
        public var message: Swift.String?
        /// The name of the exception.
        /// This member is required.
        public var name: Swift.String?

        public init(
            message: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.message = message
            self.name = name
        }
    }
}

extension WorkSpacesThinClientClientTypes {

    public enum ValidationExceptionReason: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case cannotParse
        case fieldValidationFailed
        case other
        case unknownOperation
        case sdkUnknown(Swift.String)

        public static var allCases: [ValidationExceptionReason] {
            return [
                .cannotParse,
                .fieldValidationFailed,
                .other,
                .unknownOperation
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .cannotParse: return "cannotParse"
            case .fieldValidationFailed: return "fieldValidationFailed"
            case .other: return "other"
            case .unknownOperation: return "unknownOperation"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// The input fails to satisfy the specified constraints.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// A list of fields that didn't validate.
        public internal(set) var fieldList: [WorkSpacesThinClientClientTypes.ValidationExceptionField]? = nil
        public internal(set) var message: Swift.String? = nil
        /// The reason for the exception.
        public internal(set) var reason: WorkSpacesThinClientClientTypes.ValidationExceptionReason? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        fieldList: [WorkSpacesThinClientClientTypes.ValidationExceptionField]? = nil,
        message: Swift.String? = nil,
        reason: WorkSpacesThinClientClientTypes.ValidationExceptionReason? = nil
    )
    {
        self.properties.fieldList = fieldList
        self.properties.message = message
        self.properties.reason = reason
    }
}

extension WorkSpacesThinClientClientTypes {

    public enum DayOfWeek: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case friday
        case monday
        case saturday
        case sunday
        case thursday
        case tuesday
        case wednesday
        case sdkUnknown(Swift.String)

        public static var allCases: [DayOfWeek] {
            return [
                .friday,
                .monday,
                .saturday,
                .sunday,
                .thursday,
                .tuesday,
                .wednesday
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .friday: return "FRIDAY"
            case .monday: return "MONDAY"
            case .saturday: return "SATURDAY"
            case .sunday: return "SUNDAY"
            case .thursday: return "THURSDAY"
            case .tuesday: return "TUESDAY"
            case .wednesday: return "WEDNESDAY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension WorkSpacesThinClientClientTypes {

    public enum MaintenanceWindowType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case custom
        case system
        case sdkUnknown(Swift.String)

        public static var allCases: [MaintenanceWindowType] {
            return [
                .custom,
                .system
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .custom: return "CUSTOM"
            case .system: return "SYSTEM"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension WorkSpacesThinClientClientTypes {

    /// Describes the maintenance window for a thin client device.
    public struct MaintenanceWindow: Swift.Sendable {
        /// The option to set the maintenance window during the device local time or Universal Coordinated Time (UTC).
        public var applyTimeOf: WorkSpacesThinClientClientTypes.ApplyTimeOf?
        /// The days of the week during which the maintenance window is open.
        public var daysOfTheWeek: [WorkSpacesThinClientClientTypes.DayOfWeek]?
        /// The hour for the maintenance window end (00-23).
        public var endTimeHour: Swift.Int?
        /// The minutes for the maintenance window end (00-59).
        public var endTimeMinute: Swift.Int?
        /// The hour for the maintenance window start (00-23).
        public var startTimeHour: Swift.Int?
        /// The minutes past the hour for the maintenance window start (00-59).
        public var startTimeMinute: Swift.Int?
        /// An option to select the default or custom maintenance window.
        public var type: WorkSpacesThinClientClientTypes.MaintenanceWindowType?

        public init(
            applyTimeOf: WorkSpacesThinClientClientTypes.ApplyTimeOf? = nil,
            daysOfTheWeek: [WorkSpacesThinClientClientTypes.DayOfWeek]? = nil,
            endTimeHour: Swift.Int? = nil,
            endTimeMinute: Swift.Int? = nil,
            startTimeHour: Swift.Int? = nil,
            startTimeMinute: Swift.Int? = nil,
            type: WorkSpacesThinClientClientTypes.MaintenanceWindowType? = nil
        )
        {
            self.applyTimeOf = applyTimeOf
            self.daysOfTheWeek = daysOfTheWeek
            self.endTimeHour = endTimeHour
            self.endTimeMinute = endTimeMinute
            self.startTimeHour = startTimeHour
            self.startTimeMinute = startTimeMinute
            self.type = type
        }
    }
}

extension WorkSpacesThinClientClientTypes {

    public enum SoftwareSetUpdateMode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case useDesired
        case useLatest
        case sdkUnknown(Swift.String)

        public static var allCases: [SoftwareSetUpdateMode] {
            return [
                .useDesired,
                .useLatest
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .useDesired: return "USE_DESIRED"
            case .useLatest: return "USE_LATEST"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension WorkSpacesThinClientClientTypes {

    public enum SoftwareSetUpdateSchedule: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case applyImmediately
        case useMaintenanceWindow
        case sdkUnknown(Swift.String)

        public static var allCases: [SoftwareSetUpdateSchedule] {
            return [
                .applyImmediately,
                .useMaintenanceWindow
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .applyImmediately: return "APPLY_IMMEDIATELY"
            case .useMaintenanceWindow: return "USE_MAINTENANCE_WINDOW"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CreateEnvironmentInput: Swift.Sendable {
    /// Specifies a unique, case-sensitive identifier that you provide to ensure the idempotency of the request. This lets you safely retry the request without accidentally performing the same operation a second time. Passing the same value to a later call to an operation requires that you also pass the same value for all other parameters. We recommend that you use a [UUID type of value](https://wikipedia.org/wiki/Universally_unique_identifier). If you don't provide this value, then Amazon Web Services generates a random one for you. If you retry the operation with the same ClientToken, but with different parameters, the retry fails with an IdempotentParameterMismatch error.
    public var clientToken: Swift.String?
    /// The ID of the software set to apply.
    public var desiredSoftwareSetId: Swift.String?
    /// The Amazon Resource Name (ARN) of the desktop to stream from Amazon WorkSpaces, WorkSpaces Web, or AppStream 2.0.
    /// This member is required.
    public var desktopArn: Swift.String?
    /// The URL for the identity provider login (only for environments that use AppStream 2.0).
    public var desktopEndpoint: Swift.String?
    /// A map of the key-value pairs of the tag or tags to assign to the newly created devices for this environment.
    public var deviceCreationTags: [Swift.String: Swift.String]?
    /// The Amazon Resource Name (ARN) of the Key Management Service key to use to encrypt the environment.
    public var kmsKeyArn: Swift.String?
    /// A specification for a time window to apply software updates.
    public var maintenanceWindow: WorkSpacesThinClientClientTypes.MaintenanceWindow?
    /// The name for the environment.
    public var name: Swift.String?
    /// An option to define which software updates to apply.
    public var softwareSetUpdateMode: WorkSpacesThinClientClientTypes.SoftwareSetUpdateMode?
    /// An option to define if software updates should be applied within a maintenance window.
    public var softwareSetUpdateSchedule: WorkSpacesThinClientClientTypes.SoftwareSetUpdateSchedule?
    /// A map of the key-value pairs of the tag or tags to assign to the resource.
    public var tags: [Swift.String: Swift.String]?

    public init(
        clientToken: Swift.String? = nil,
        desiredSoftwareSetId: Swift.String? = nil,
        desktopArn: Swift.String? = nil,
        desktopEndpoint: Swift.String? = nil,
        deviceCreationTags: [Swift.String: Swift.String]? = nil,
        kmsKeyArn: Swift.String? = nil,
        maintenanceWindow: WorkSpacesThinClientClientTypes.MaintenanceWindow? = nil,
        name: Swift.String? = nil,
        softwareSetUpdateMode: WorkSpacesThinClientClientTypes.SoftwareSetUpdateMode? = nil,
        softwareSetUpdateSchedule: WorkSpacesThinClientClientTypes.SoftwareSetUpdateSchedule? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.clientToken = clientToken
        self.desiredSoftwareSetId = desiredSoftwareSetId
        self.desktopArn = desktopArn
        self.desktopEndpoint = desktopEndpoint
        self.deviceCreationTags = deviceCreationTags
        self.kmsKeyArn = kmsKeyArn
        self.maintenanceWindow = maintenanceWindow
        self.name = name
        self.softwareSetUpdateMode = softwareSetUpdateMode
        self.softwareSetUpdateSchedule = softwareSetUpdateSchedule
        self.tags = tags
    }
}

extension CreateEnvironmentInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateEnvironmentInput(clientToken: \(Swift.String(describing: clientToken)), desiredSoftwareSetId: \(Swift.String(describing: desiredSoftwareSetId)), desktopArn: \(Swift.String(describing: desktopArn)), kmsKeyArn: \(Swift.String(describing: kmsKeyArn)), maintenanceWindow: \(Swift.String(describing: maintenanceWindow)), softwareSetUpdateMode: \(Swift.String(describing: softwareSetUpdateMode)), softwareSetUpdateSchedule: \(Swift.String(describing: softwareSetUpdateSchedule)), desktopEndpoint: \"CONTENT_REDACTED\", deviceCreationTags: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\", tags: \"CONTENT_REDACTED\")"}
}

extension WorkSpacesThinClientClientTypes {

    public enum DesktopType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case appstream
        case workspaces
        case workspacesWeb
        case sdkUnknown(Swift.String)

        public static var allCases: [DesktopType] {
            return [
                .appstream,
                .workspaces,
                .workspacesWeb
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .appstream: return "appstream"
            case .workspaces: return "workspaces"
            case .workspacesWeb: return "workspaces-web"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension WorkSpacesThinClientClientTypes {

    /// Describes an environment.
    public struct EnvironmentSummary: Swift.Sendable {
        /// The activation code to register a device to the environment.
        public var activationCode: Swift.String?
        /// The Amazon Resource Name (ARN) of the environment.
        public var arn: Swift.String?
        /// The timestamp of when the environment was created.
        public var createdAt: Foundation.Date?
        /// The ID of the software set to apply.
        public var desiredSoftwareSetId: Swift.String?
        /// The Amazon Resource Name (ARN) of the desktop to stream from Amazon WorkSpaces, WorkSpaces Web, or AppStream 2.0.
        public var desktopArn: Swift.String?
        /// The URL for the identity provider login (only for environments that use AppStream 2.0).
        public var desktopEndpoint: Swift.String?
        /// The type of streaming desktop for the environment.
        public var desktopType: WorkSpacesThinClientClientTypes.DesktopType?
        /// The ID of the environment.
        public var id: Swift.String?
        /// A specification for a time window to apply software updates.
        public var maintenanceWindow: WorkSpacesThinClientClientTypes.MaintenanceWindow?
        /// The name of the environment.
        public var name: Swift.String?
        /// The ID of the software set that is pending to be installed.
        public var pendingSoftwareSetId: Swift.String?
        /// An option to define which software updates to apply.
        public var softwareSetUpdateMode: WorkSpacesThinClientClientTypes.SoftwareSetUpdateMode?
        /// An option to define if software updates should be applied within a maintenance window.
        public var softwareSetUpdateSchedule: WorkSpacesThinClientClientTypes.SoftwareSetUpdateSchedule?
        /// The timestamp of when the device was updated.
        public var updatedAt: Foundation.Date?

        public init(
            activationCode: Swift.String? = nil,
            arn: Swift.String? = nil,
            createdAt: Foundation.Date? = nil,
            desiredSoftwareSetId: Swift.String? = nil,
            desktopArn: Swift.String? = nil,
            desktopEndpoint: Swift.String? = nil,
            desktopType: WorkSpacesThinClientClientTypes.DesktopType? = nil,
            id: Swift.String? = nil,
            maintenanceWindow: WorkSpacesThinClientClientTypes.MaintenanceWindow? = nil,
            name: Swift.String? = nil,
            pendingSoftwareSetId: Swift.String? = nil,
            softwareSetUpdateMode: WorkSpacesThinClientClientTypes.SoftwareSetUpdateMode? = nil,
            softwareSetUpdateSchedule: WorkSpacesThinClientClientTypes.SoftwareSetUpdateSchedule? = nil,
            updatedAt: Foundation.Date? = nil
        )
        {
            self.activationCode = activationCode
            self.arn = arn
            self.createdAt = createdAt
            self.desiredSoftwareSetId = desiredSoftwareSetId
            self.desktopArn = desktopArn
            self.desktopEndpoint = desktopEndpoint
            self.desktopType = desktopType
            self.id = id
            self.maintenanceWindow = maintenanceWindow
            self.name = name
            self.pendingSoftwareSetId = pendingSoftwareSetId
            self.softwareSetUpdateMode = softwareSetUpdateMode
            self.softwareSetUpdateSchedule = softwareSetUpdateSchedule
            self.updatedAt = updatedAt
        }
    }
}

extension WorkSpacesThinClientClientTypes.EnvironmentSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EnvironmentSummary(activationCode: \(Swift.String(describing: activationCode)), arn: \(Swift.String(describing: arn)), createdAt: \(Swift.String(describing: createdAt)), desiredSoftwareSetId: \(Swift.String(describing: desiredSoftwareSetId)), desktopArn: \(Swift.String(describing: desktopArn)), desktopType: \(Swift.String(describing: desktopType)), id: \(Swift.String(describing: id)), maintenanceWindow: \(Swift.String(describing: maintenanceWindow)), pendingSoftwareSetId: \(Swift.String(describing: pendingSoftwareSetId)), softwareSetUpdateMode: \(Swift.String(describing: softwareSetUpdateMode)), softwareSetUpdateSchedule: \(Swift.String(describing: softwareSetUpdateSchedule)), updatedAt: \(Swift.String(describing: updatedAt)), desktopEndpoint: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

public struct CreateEnvironmentOutput: Swift.Sendable {
    /// Describes an environment.
    public var environment: WorkSpacesThinClientClientTypes.EnvironmentSummary?

    public init(
        environment: WorkSpacesThinClientClientTypes.EnvironmentSummary? = nil
    )
    {
        self.environment = environment
    }
}

public struct DeleteDeviceInput: Swift.Sendable {
    /// Specifies a unique, case-sensitive identifier that you provide to ensure the idempotency of the request. This lets you safely retry the request without accidentally performing the same operation a second time. Passing the same value to a later call to an operation requires that you also pass the same value for all other parameters. We recommend that you use a [UUID type of value](https://wikipedia.org/wiki/Universally_unique_identifier). If you don't provide this value, then Amazon Web Services generates a random one for you. If you retry the operation with the same ClientToken, but with different parameters, the retry fails with an IdempotentParameterMismatch error.
    public var clientToken: Swift.String?
    /// The ID of the device to delete.
    /// This member is required.
    public var id: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        id: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.id = id
    }
}

public struct DeleteDeviceOutput: Swift.Sendable {

    public init() { }
}

public struct DeleteEnvironmentInput: Swift.Sendable {
    /// Specifies a unique, case-sensitive identifier that you provide to ensure the idempotency of the request. This lets you safely retry the request without accidentally performing the same operation a second time. Passing the same value to a later call to an operation requires that you also pass the same value for all other parameters. We recommend that you use a [UUID type of value](https://wikipedia.org/wiki/Universally_unique_identifier). If you don't provide this value, then Amazon Web Services generates a random one for you. If you retry the operation with the same ClientToken, but with different parameters, the retry fails with an IdempotentParameterMismatch error.
    public var clientToken: Swift.String?
    /// The ID of the environment to delete.
    /// This member is required.
    public var id: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        id: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.id = id
    }
}

public struct DeleteEnvironmentOutput: Swift.Sendable {

    public init() { }
}

extension WorkSpacesThinClientClientTypes {

    public enum TargetDeviceStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case archived
        case deregistered
        case sdkUnknown(Swift.String)

        public static var allCases: [TargetDeviceStatus] {
            return [
                .archived,
                .deregistered
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .archived: return "ARCHIVED"
            case .deregistered: return "DEREGISTERED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct DeregisterDeviceInput: Swift.Sendable {
    /// Specifies a unique, case-sensitive identifier that you provide to ensure the idempotency of the request. This lets you safely retry the request without accidentally performing the same operation a second time. Passing the same value to a later call to an operation requires that you also pass the same value for all other parameters. We recommend that you use a [UUID type of value](https://wikipedia.org/wiki/Universally_unique_identifier). If you don't provide this value, then Amazon Web Services generates a random one for you. If you retry the operation with the same ClientToken, but with different parameters, the retry fails with an IdempotentParameterMismatch error.
    public var clientToken: Swift.String?
    /// The ID of the device to deregister.
    /// This member is required.
    public var id: Swift.String?
    /// The desired new status for the device.
    public var targetDeviceStatus: WorkSpacesThinClientClientTypes.TargetDeviceStatus?

    public init(
        clientToken: Swift.String? = nil,
        id: Swift.String? = nil,
        targetDeviceStatus: WorkSpacesThinClientClientTypes.TargetDeviceStatus? = nil
    )
    {
        self.clientToken = clientToken
        self.id = id
        self.targetDeviceStatus = targetDeviceStatus
    }
}

public struct DeregisterDeviceOutput: Swift.Sendable {

    public init() { }
}

extension WorkSpacesThinClientClientTypes {

    public enum DeviceSoftwareSetComplianceStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case compliant
        case `none`
        case notCompliant
        case sdkUnknown(Swift.String)

        public static var allCases: [DeviceSoftwareSetComplianceStatus] {
            return [
                .compliant,
                .none,
                .notCompliant
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .compliant: return "COMPLIANT"
            case .none: return "NONE"
            case .notCompliant: return "NOT_COMPLIANT"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension WorkSpacesThinClientClientTypes {

    public enum SoftwareSetUpdateStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case available
        case inProgress
        case upToDate
        case sdkUnknown(Swift.String)

        public static var allCases: [SoftwareSetUpdateStatus] {
            return [
                .available,
                .inProgress,
                .upToDate
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .inProgress: return "IN_PROGRESS"
            case .upToDate: return "UP_TO_DATE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension WorkSpacesThinClientClientTypes {

    public enum DeviceStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case archived
        case deregistered
        case deregistering
        case registered
        case sdkUnknown(Swift.String)

        public static var allCases: [DeviceStatus] {
            return [
                .archived,
                .deregistered,
                .deregistering,
                .registered
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .archived: return "ARCHIVED"
            case .deregistered: return "DEREGISTERED"
            case .deregistering: return "DEREGISTERING"
            case .registered: return "REGISTERED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension WorkSpacesThinClientClientTypes {

    /// Describes a thin client device.
    public struct Device: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the device.
        public var arn: Swift.String?
        /// The timestamp of when the device was created.
        public var createdAt: Foundation.Date?
        /// The ID of the software set currently installed on the device.
        public var currentSoftwareSetId: Swift.String?
        /// The version of the software set currently installed on the device.
        public var currentSoftwareSetVersion: Swift.String?
        /// The ID of the software set which the device has been set to.
        public var desiredSoftwareSetId: Swift.String?
        /// The ID of the environment the device is associated with.
        public var environmentId: Swift.String?
        /// The ID of the device.
        public var id: Swift.String?
        /// The Amazon Resource Name (ARN) of the Key Management Service key used to encrypt the device.
        public var kmsKeyArn: Swift.String?
        /// The timestamp of the most recent session on the device.
        public var lastConnectedAt: Foundation.Date?
        /// The timestamp of the most recent check-in of the device.
        public var lastPostureAt: Foundation.Date?
        /// The model number of the device.
        public var model: Swift.String?
        /// The name of the device.
        public var name: Swift.String?
        /// The ID of the software set that is pending to be installed on the device.
        public var pendingSoftwareSetId: Swift.String?
        /// The version of the software set that is pending to be installed on the device.
        public var pendingSoftwareSetVersion: Swift.String?
        /// The hardware serial number of the device.
        public var serialNumber: Swift.String?
        /// Describes if the software currently installed on the device is a supported version.
        public var softwareSetComplianceStatus: WorkSpacesThinClientClientTypes.DeviceSoftwareSetComplianceStatus?
        /// An option to define if software updates should be applied within a maintenance window.
        public var softwareSetUpdateSchedule: WorkSpacesThinClientClientTypes.SoftwareSetUpdateSchedule?
        /// Describes if the device has a supported version of software installed.
        public var softwareSetUpdateStatus: WorkSpacesThinClientClientTypes.SoftwareSetUpdateStatus?
        /// The status of the device.
        public var status: WorkSpacesThinClientClientTypes.DeviceStatus?
        /// The tag keys and optional values for the resource.
        public var tags: [Swift.String: Swift.String]?
        /// The timestamp of when the device was updated.
        public var updatedAt: Foundation.Date?

        public init(
            arn: Swift.String? = nil,
            createdAt: Foundation.Date? = nil,
            currentSoftwareSetId: Swift.String? = nil,
            currentSoftwareSetVersion: Swift.String? = nil,
            desiredSoftwareSetId: Swift.String? = nil,
            environmentId: Swift.String? = nil,
            id: Swift.String? = nil,
            kmsKeyArn: Swift.String? = nil,
            lastConnectedAt: Foundation.Date? = nil,
            lastPostureAt: Foundation.Date? = nil,
            model: Swift.String? = nil,
            name: Swift.String? = nil,
            pendingSoftwareSetId: Swift.String? = nil,
            pendingSoftwareSetVersion: Swift.String? = nil,
            serialNumber: Swift.String? = nil,
            softwareSetComplianceStatus: WorkSpacesThinClientClientTypes.DeviceSoftwareSetComplianceStatus? = nil,
            softwareSetUpdateSchedule: WorkSpacesThinClientClientTypes.SoftwareSetUpdateSchedule? = nil,
            softwareSetUpdateStatus: WorkSpacesThinClientClientTypes.SoftwareSetUpdateStatus? = nil,
            status: WorkSpacesThinClientClientTypes.DeviceStatus? = nil,
            tags: [Swift.String: Swift.String]? = nil,
            updatedAt: Foundation.Date? = nil
        )
        {
            self.arn = arn
            self.createdAt = createdAt
            self.currentSoftwareSetId = currentSoftwareSetId
            self.currentSoftwareSetVersion = currentSoftwareSetVersion
            self.desiredSoftwareSetId = desiredSoftwareSetId
            self.environmentId = environmentId
            self.id = id
            self.kmsKeyArn = kmsKeyArn
            self.lastConnectedAt = lastConnectedAt
            self.lastPostureAt = lastPostureAt
            self.model = model
            self.name = name
            self.pendingSoftwareSetId = pendingSoftwareSetId
            self.pendingSoftwareSetVersion = pendingSoftwareSetVersion
            self.serialNumber = serialNumber
            self.softwareSetComplianceStatus = softwareSetComplianceStatus
            self.softwareSetUpdateSchedule = softwareSetUpdateSchedule
            self.softwareSetUpdateStatus = softwareSetUpdateStatus
            self.status = status
            self.tags = tags
            self.updatedAt = updatedAt
        }
    }
}

extension WorkSpacesThinClientClientTypes.Device: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Device(arn: \(Swift.String(describing: arn)), createdAt: \(Swift.String(describing: createdAt)), currentSoftwareSetId: \(Swift.String(describing: currentSoftwareSetId)), currentSoftwareSetVersion: \(Swift.String(describing: currentSoftwareSetVersion)), desiredSoftwareSetId: \(Swift.String(describing: desiredSoftwareSetId)), environmentId: \(Swift.String(describing: environmentId)), id: \(Swift.String(describing: id)), kmsKeyArn: \(Swift.String(describing: kmsKeyArn)), lastConnectedAt: \(Swift.String(describing: lastConnectedAt)), lastPostureAt: \(Swift.String(describing: lastPostureAt)), model: \(Swift.String(describing: model)), pendingSoftwareSetId: \(Swift.String(describing: pendingSoftwareSetId)), pendingSoftwareSetVersion: \(Swift.String(describing: pendingSoftwareSetVersion)), serialNumber: \(Swift.String(describing: serialNumber)), softwareSetComplianceStatus: \(Swift.String(describing: softwareSetComplianceStatus)), softwareSetUpdateSchedule: \(Swift.String(describing: softwareSetUpdateSchedule)), softwareSetUpdateStatus: \(Swift.String(describing: softwareSetUpdateStatus)), status: \(Swift.String(describing: status)), updatedAt: \(Swift.String(describing: updatedAt)), name: \"CONTENT_REDACTED\", tags: \"CONTENT_REDACTED\")"}
}

extension WorkSpacesThinClientClientTypes {

    /// Describes a thin client device.
    public struct DeviceSummary: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the device.
        public var arn: Swift.String?
        /// The timestamp of when the device was created.
        public var createdAt: Foundation.Date?
        /// The ID of the software set currently installed on the device.
        public var currentSoftwareSetId: Swift.String?
        /// The ID of the software set which the device has been set to.
        public var desiredSoftwareSetId: Swift.String?
        /// The ID of the environment the device is associated with.
        public var environmentId: Swift.String?
        /// The ID of the device.
        public var id: Swift.String?
        /// The timestamp of the most recent session on the device.
        public var lastConnectedAt: Foundation.Date?
        /// The timestamp of the most recent check-in of the device.
        public var lastPostureAt: Foundation.Date?
        /// The model number of the device.
        public var model: Swift.String?
        /// The name of the device.
        public var name: Swift.String?
        /// The ID of the software set that is pending to be installed on the device.
        public var pendingSoftwareSetId: Swift.String?
        /// The hardware serial number of the device.
        public var serialNumber: Swift.String?
        /// An option to define if software updates should be applied within a maintenance window.
        public var softwareSetUpdateSchedule: WorkSpacesThinClientClientTypes.SoftwareSetUpdateSchedule?
        /// The status of the device.
        public var status: WorkSpacesThinClientClientTypes.DeviceStatus?
        /// The timestamp of when the device was updated.
        public var updatedAt: Foundation.Date?

        public init(
            arn: Swift.String? = nil,
            createdAt: Foundation.Date? = nil,
            currentSoftwareSetId: Swift.String? = nil,
            desiredSoftwareSetId: Swift.String? = nil,
            environmentId: Swift.String? = nil,
            id: Swift.String? = nil,
            lastConnectedAt: Foundation.Date? = nil,
            lastPostureAt: Foundation.Date? = nil,
            model: Swift.String? = nil,
            name: Swift.String? = nil,
            pendingSoftwareSetId: Swift.String? = nil,
            serialNumber: Swift.String? = nil,
            softwareSetUpdateSchedule: WorkSpacesThinClientClientTypes.SoftwareSetUpdateSchedule? = nil,
            status: WorkSpacesThinClientClientTypes.DeviceStatus? = nil,
            updatedAt: Foundation.Date? = nil
        )
        {
            self.arn = arn
            self.createdAt = createdAt
            self.currentSoftwareSetId = currentSoftwareSetId
            self.desiredSoftwareSetId = desiredSoftwareSetId
            self.environmentId = environmentId
            self.id = id
            self.lastConnectedAt = lastConnectedAt
            self.lastPostureAt = lastPostureAt
            self.model = model
            self.name = name
            self.pendingSoftwareSetId = pendingSoftwareSetId
            self.serialNumber = serialNumber
            self.softwareSetUpdateSchedule = softwareSetUpdateSchedule
            self.status = status
            self.updatedAt = updatedAt
        }
    }
}

extension WorkSpacesThinClientClientTypes.DeviceSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeviceSummary(arn: \(Swift.String(describing: arn)), createdAt: \(Swift.String(describing: createdAt)), currentSoftwareSetId: \(Swift.String(describing: currentSoftwareSetId)), desiredSoftwareSetId: \(Swift.String(describing: desiredSoftwareSetId)), environmentId: \(Swift.String(describing: environmentId)), id: \(Swift.String(describing: id)), lastConnectedAt: \(Swift.String(describing: lastConnectedAt)), lastPostureAt: \(Swift.String(describing: lastPostureAt)), model: \(Swift.String(describing: model)), pendingSoftwareSetId: \(Swift.String(describing: pendingSoftwareSetId)), serialNumber: \(Swift.String(describing: serialNumber)), softwareSetUpdateSchedule: \(Swift.String(describing: softwareSetUpdateSchedule)), status: \(Swift.String(describing: status)), updatedAt: \(Swift.String(describing: updatedAt)), name: \"CONTENT_REDACTED\")"}
}

extension WorkSpacesThinClientClientTypes {

    public enum EnvironmentSoftwareSetComplianceStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case compliant
        case notCompliant
        case noRegisteredDevices
        case sdkUnknown(Swift.String)

        public static var allCases: [EnvironmentSoftwareSetComplianceStatus] {
            return [
                .compliant,
                .notCompliant,
                .noRegisteredDevices
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .compliant: return "COMPLIANT"
            case .notCompliant: return "NOT_COMPLIANT"
            case .noRegisteredDevices: return "NO_REGISTERED_DEVICES"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension WorkSpacesThinClientClientTypes {

    /// Describes an environment.
    public struct Environment: Swift.Sendable {
        /// The activation code to register a device to the environment.
        public var activationCode: Swift.String?
        /// The Amazon Resource Name (ARN) of the environment.
        public var arn: Swift.String?
        /// The timestamp of when the environment was created.
        public var createdAt: Foundation.Date?
        /// The ID of the software set to apply.
        public var desiredSoftwareSetId: Swift.String?
        /// The Amazon Resource Name (ARN) of the desktop to stream from Amazon WorkSpaces, WorkSpaces Web, or AppStream 2.0.
        public var desktopArn: Swift.String?
        /// The URL for the identity provider login (only for environments that use AppStream 2.0).
        public var desktopEndpoint: Swift.String?
        /// The type of streaming desktop for the environment.
        public var desktopType: WorkSpacesThinClientClientTypes.DesktopType?
        /// The tag keys and optional values for the newly created devices for this environment.
        public var deviceCreationTags: [Swift.String: Swift.String]?
        /// The ID of the environment.
        public var id: Swift.String?
        /// The Amazon Resource Name (ARN) of the Key Management Service key used to encrypt the environment.
        public var kmsKeyArn: Swift.String?
        /// A specification for a time window to apply software updates.
        public var maintenanceWindow: WorkSpacesThinClientClientTypes.MaintenanceWindow?
        /// The name of the environment.
        public var name: Swift.String?
        /// The ID of the software set that is pending to be installed.
        public var pendingSoftwareSetId: Swift.String?
        /// The version of the software set that is pending to be installed.
        public var pendingSoftwareSetVersion: Swift.String?
        /// The number of devices registered to the environment.
        public var registeredDevicesCount: Swift.Int?
        /// Describes if the software currently installed on all devices in the environment is a supported version.
        public var softwareSetComplianceStatus: WorkSpacesThinClientClientTypes.EnvironmentSoftwareSetComplianceStatus?
        /// An option to define which software updates to apply.
        public var softwareSetUpdateMode: WorkSpacesThinClientClientTypes.SoftwareSetUpdateMode?
        /// An option to define if software updates should be applied within a maintenance window.
        public var softwareSetUpdateSchedule: WorkSpacesThinClientClientTypes.SoftwareSetUpdateSchedule?
        /// The tag keys and optional values for the resource.
        public var tags: [Swift.String: Swift.String]?
        /// The timestamp of when the device was updated.
        public var updatedAt: Foundation.Date?

        public init(
            activationCode: Swift.String? = nil,
            arn: Swift.String? = nil,
            createdAt: Foundation.Date? = nil,
            desiredSoftwareSetId: Swift.String? = nil,
            desktopArn: Swift.String? = nil,
            desktopEndpoint: Swift.String? = nil,
            desktopType: WorkSpacesThinClientClientTypes.DesktopType? = nil,
            deviceCreationTags: [Swift.String: Swift.String]? = nil,
            id: Swift.String? = nil,
            kmsKeyArn: Swift.String? = nil,
            maintenanceWindow: WorkSpacesThinClientClientTypes.MaintenanceWindow? = nil,
            name: Swift.String? = nil,
            pendingSoftwareSetId: Swift.String? = nil,
            pendingSoftwareSetVersion: Swift.String? = nil,
            registeredDevicesCount: Swift.Int? = nil,
            softwareSetComplianceStatus: WorkSpacesThinClientClientTypes.EnvironmentSoftwareSetComplianceStatus? = nil,
            softwareSetUpdateMode: WorkSpacesThinClientClientTypes.SoftwareSetUpdateMode? = nil,
            softwareSetUpdateSchedule: WorkSpacesThinClientClientTypes.SoftwareSetUpdateSchedule? = nil,
            tags: [Swift.String: Swift.String]? = nil,
            updatedAt: Foundation.Date? = nil
        )
        {
            self.activationCode = activationCode
            self.arn = arn
            self.createdAt = createdAt
            self.desiredSoftwareSetId = desiredSoftwareSetId
            self.desktopArn = desktopArn
            self.desktopEndpoint = desktopEndpoint
            self.desktopType = desktopType
            self.deviceCreationTags = deviceCreationTags
            self.id = id
            self.kmsKeyArn = kmsKeyArn
            self.maintenanceWindow = maintenanceWindow
            self.name = name
            self.pendingSoftwareSetId = pendingSoftwareSetId
            self.pendingSoftwareSetVersion = pendingSoftwareSetVersion
            self.registeredDevicesCount = registeredDevicesCount
            self.softwareSetComplianceStatus = softwareSetComplianceStatus
            self.softwareSetUpdateMode = softwareSetUpdateMode
            self.softwareSetUpdateSchedule = softwareSetUpdateSchedule
            self.tags = tags
            self.updatedAt = updatedAt
        }
    }
}

extension WorkSpacesThinClientClientTypes.Environment: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Environment(activationCode: \(Swift.String(describing: activationCode)), arn: \(Swift.String(describing: arn)), createdAt: \(Swift.String(describing: createdAt)), desiredSoftwareSetId: \(Swift.String(describing: desiredSoftwareSetId)), desktopArn: \(Swift.String(describing: desktopArn)), desktopType: \(Swift.String(describing: desktopType)), id: \(Swift.String(describing: id)), kmsKeyArn: \(Swift.String(describing: kmsKeyArn)), maintenanceWindow: \(Swift.String(describing: maintenanceWindow)), pendingSoftwareSetId: \(Swift.String(describing: pendingSoftwareSetId)), pendingSoftwareSetVersion: \(Swift.String(describing: pendingSoftwareSetVersion)), registeredDevicesCount: \(Swift.String(describing: registeredDevicesCount)), softwareSetComplianceStatus: \(Swift.String(describing: softwareSetComplianceStatus)), softwareSetUpdateMode: \(Swift.String(describing: softwareSetUpdateMode)), softwareSetUpdateSchedule: \(Swift.String(describing: softwareSetUpdateSchedule)), updatedAt: \(Swift.String(describing: updatedAt)), desktopEndpoint: \"CONTENT_REDACTED\", deviceCreationTags: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\", tags: \"CONTENT_REDACTED\")"}
}

public struct GetDeviceInput: Swift.Sendable {
    /// The ID of the device for which to return information.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

public struct GetDeviceOutput: Swift.Sendable {
    /// Describes an device.
    public var device: WorkSpacesThinClientClientTypes.Device?

    public init(
        device: WorkSpacesThinClientClientTypes.Device? = nil
    )
    {
        self.device = device
    }
}

public struct GetEnvironmentInput: Swift.Sendable {
    /// The ID of the environment for which to return information.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

public struct GetEnvironmentOutput: Swift.Sendable {
    /// Describes an environment.
    public var environment: WorkSpacesThinClientClientTypes.Environment?

    public init(
        environment: WorkSpacesThinClientClientTypes.Environment? = nil
    )
    {
        self.environment = environment
    }
}

public struct GetSoftwareSetInput: Swift.Sendable {
    /// The ID of the software set for which to return information.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

extension WorkSpacesThinClientClientTypes {

    /// Describes software.
    public struct Software: Swift.Sendable {
        /// The name of the software component.
        public var name: Swift.String?
        /// The version of the software component.
        public var version: Swift.String?

        public init(
            name: Swift.String? = nil,
            version: Swift.String? = nil
        )
        {
            self.name = name
            self.version = version
        }
    }
}

extension WorkSpacesThinClientClientTypes {

    public enum SoftwareSetValidationStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case notValidated
        case validated
        case sdkUnknown(Swift.String)

        public static var allCases: [SoftwareSetValidationStatus] {
            return [
                .notValidated,
                .validated
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .notValidated: return "NOT_VALIDATED"
            case .validated: return "VALIDATED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension WorkSpacesThinClientClientTypes {

    /// Describes a software set.
    public struct SoftwareSet: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the software set.
        public var arn: Swift.String?
        /// The ID of the software set.
        public var id: Swift.String?
        /// The timestamp of when the software set was released.
        public var releasedAt: Foundation.Date?
        /// A list of the software components in the software set.
        public var software: [WorkSpacesThinClientClientTypes.Software]?
        /// The timestamp of the end of support for the software set.
        public var supportedUntil: Foundation.Date?
        /// The tag keys and optional values for the resource.
        public var tags: [Swift.String: Swift.String]?
        /// An option to define if the software set has been validated.
        public var validationStatus: WorkSpacesThinClientClientTypes.SoftwareSetValidationStatus?
        /// The version of the software set.
        public var version: Swift.String?

        public init(
            arn: Swift.String? = nil,
            id: Swift.String? = nil,
            releasedAt: Foundation.Date? = nil,
            software: [WorkSpacesThinClientClientTypes.Software]? = nil,
            supportedUntil: Foundation.Date? = nil,
            tags: [Swift.String: Swift.String]? = nil,
            validationStatus: WorkSpacesThinClientClientTypes.SoftwareSetValidationStatus? = nil,
            version: Swift.String? = nil
        )
        {
            self.arn = arn
            self.id = id
            self.releasedAt = releasedAt
            self.software = software
            self.supportedUntil = supportedUntil
            self.tags = tags
            self.validationStatus = validationStatus
            self.version = version
        }
    }
}

extension WorkSpacesThinClientClientTypes.SoftwareSet: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "SoftwareSet(arn: \(Swift.String(describing: arn)), id: \(Swift.String(describing: id)), releasedAt: \(Swift.String(describing: releasedAt)), software: \(Swift.String(describing: software)), supportedUntil: \(Swift.String(describing: supportedUntil)), validationStatus: \(Swift.String(describing: validationStatus)), version: \(Swift.String(describing: version)), tags: \"CONTENT_REDACTED\")"}
}

public struct GetSoftwareSetOutput: Swift.Sendable {
    /// Describes a software set.
    public var softwareSet: WorkSpacesThinClientClientTypes.SoftwareSet?

    public init(
        softwareSet: WorkSpacesThinClientClientTypes.SoftwareSet? = nil
    )
    {
        self.softwareSet = softwareSet
    }
}

public struct ListDevicesInput: Swift.Sendable {
    /// The maximum number of results that are returned per call. You can use nextToken to obtain further pages of results. This is only an upper limit. The actual number of results returned per call might be fewer than the specified maximum.
    public var maxResults: Swift.Int?
    /// If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires after 24 hours. Using an expired pagination token will return an HTTP 400 InvalidToken error.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListDevicesOutput: Swift.Sendable {
    /// Describes devices.
    public var devices: [WorkSpacesThinClientClientTypes.DeviceSummary]?
    /// If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires after 24 hours. Using an expired pagination token will return an HTTP 400 InvalidToken error.
    public var nextToken: Swift.String?

    public init(
        devices: [WorkSpacesThinClientClientTypes.DeviceSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.devices = devices
        self.nextToken = nextToken
    }
}

public struct ListEnvironmentsInput: Swift.Sendable {
    /// The maximum number of results that are returned per call. You can use nextToken to obtain further pages of results. This is only an upper limit. The actual number of results returned per call might be fewer than the specified maximum.
    public var maxResults: Swift.Int?
    /// If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires after 24 hours. Using an expired pagination token will return an HTTP 400 InvalidToken error.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

public struct ListEnvironmentsOutput: Swift.Sendable {
    /// Describes environments.
    public var environments: [WorkSpacesThinClientClientTypes.EnvironmentSummary]?
    /// If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires after 24 hours. Using an expired pagination token will return an HTTP 400 InvalidToken error.
    public var nextToken: Swift.String?

    public init(
        environments: [WorkSpacesThinClientClientTypes.EnvironmentSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.environments = environments
        self.nextToken = nextToken
    }
}

public struct ListSoftwareSetsInput: Swift.Sendable {
    /// The maximum number of results that are returned per call. You can use nextToken to obtain further pages of results. This is only an upper limit. The actual number of results returned per call might be fewer than the specified maximum.
    public var maxResults: Swift.Int?
    /// If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires after 24 hours. Using an expired pagination token will return an HTTP 400 InvalidToken error.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

extension WorkSpacesThinClientClientTypes {

    /// Describes a software set.
    public struct SoftwareSetSummary: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the software set.
        public var arn: Swift.String?
        /// The ID of the software set.
        public var id: Swift.String?
        /// The timestamp of when the software set was released.
        public var releasedAt: Foundation.Date?
        /// The timestamp of the end of support for the software set.
        public var supportedUntil: Foundation.Date?
        /// An option to define if the software set has been validated.
        public var validationStatus: WorkSpacesThinClientClientTypes.SoftwareSetValidationStatus?
        /// The version of the software set.
        public var version: Swift.String?

        public init(
            arn: Swift.String? = nil,
            id: Swift.String? = nil,
            releasedAt: Foundation.Date? = nil,
            supportedUntil: Foundation.Date? = nil,
            validationStatus: WorkSpacesThinClientClientTypes.SoftwareSetValidationStatus? = nil,
            version: Swift.String? = nil
        )
        {
            self.arn = arn
            self.id = id
            self.releasedAt = releasedAt
            self.supportedUntil = supportedUntil
            self.validationStatus = validationStatus
            self.version = version
        }
    }
}

public struct ListSoftwareSetsOutput: Swift.Sendable {
    /// If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires after 24 hours. Using an expired pagination token will return an HTTP 400 InvalidToken error.
    public var nextToken: Swift.String?
    /// Describes software sets.
    public var softwareSets: [WorkSpacesThinClientClientTypes.SoftwareSetSummary]?

    public init(
        nextToken: Swift.String? = nil,
        softwareSets: [WorkSpacesThinClientClientTypes.SoftwareSetSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.softwareSets = softwareSets
    }
}

public struct ListTagsForResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the resource for which you want to retrieve tags.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

public struct ListTagsForResourceOutput: Swift.Sendable {
    /// A map of the key-value pairs for the tag or tags assigned to the specified resource.
    public var tags: [Swift.String: Swift.String]?

    public init(
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

extension ListTagsForResourceOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForResourceOutput(tags: \"CONTENT_REDACTED\")"}
}

public struct TagResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the resource that you want to tag.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// A map of the key-value pairs of the tag or tags to assign to the resource.
    /// This member is required.
    public var tags: [Swift.String: Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String: Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

extension TagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceInput(resourceArn: \(Swift.String(describing: resourceArn)), tags: \"CONTENT_REDACTED\")"}
}

public struct TagResourceOutput: Swift.Sendable {

    public init() { }
}

public struct UntagResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the resource that you want to untag.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The keys of the key-value pairs for the tag or tags you want to remove from the specified resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

extension UntagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceInput(resourceArn: \(Swift.String(describing: resourceArn)), tagKeys: \"CONTENT_REDACTED\")"}
}

public struct UntagResourceOutput: Swift.Sendable {

    public init() { }
}

public struct UpdateDeviceInput: Swift.Sendable {
    /// The ID of the software set to apply.
    public var desiredSoftwareSetId: Swift.String?
    /// The ID of the device to update.
    /// This member is required.
    public var id: Swift.String?
    /// The name of the device to update.
    public var name: Swift.String?
    /// An option to define if software updates should be applied within a maintenance window.
    public var softwareSetUpdateSchedule: WorkSpacesThinClientClientTypes.SoftwareSetUpdateSchedule?

    public init(
        desiredSoftwareSetId: Swift.String? = nil,
        id: Swift.String? = nil,
        name: Swift.String? = nil,
        softwareSetUpdateSchedule: WorkSpacesThinClientClientTypes.SoftwareSetUpdateSchedule? = nil
    )
    {
        self.desiredSoftwareSetId = desiredSoftwareSetId
        self.id = id
        self.name = name
        self.softwareSetUpdateSchedule = softwareSetUpdateSchedule
    }
}

extension UpdateDeviceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateDeviceInput(desiredSoftwareSetId: \(Swift.String(describing: desiredSoftwareSetId)), id: \(Swift.String(describing: id)), softwareSetUpdateSchedule: \(Swift.String(describing: softwareSetUpdateSchedule)), name: \"CONTENT_REDACTED\")"}
}

public struct UpdateDeviceOutput: Swift.Sendable {
    /// Describes a device.
    public var device: WorkSpacesThinClientClientTypes.DeviceSummary?

    public init(
        device: WorkSpacesThinClientClientTypes.DeviceSummary? = nil
    )
    {
        self.device = device
    }
}

public struct UpdateEnvironmentInput: Swift.Sendable {
    /// The ID of the software set to apply.
    public var desiredSoftwareSetId: Swift.String?
    /// The Amazon Resource Name (ARN) of the desktop to stream from Amazon WorkSpaces, WorkSpaces Web, or AppStream 2.0.
    public var desktopArn: Swift.String?
    /// The URL for the identity provider login (only for environments that use AppStream 2.0).
    public var desktopEndpoint: Swift.String?
    /// A map of the key-value pairs of the tag or tags to assign to the newly created devices for this environment.
    public var deviceCreationTags: [Swift.String: Swift.String]?
    /// The ID of the environment to update.
    /// This member is required.
    public var id: Swift.String?
    /// A specification for a time window to apply software updates.
    public var maintenanceWindow: WorkSpacesThinClientClientTypes.MaintenanceWindow?
    /// The name of the environment to update.
    public var name: Swift.String?
    /// An option to define which software updates to apply.
    public var softwareSetUpdateMode: WorkSpacesThinClientClientTypes.SoftwareSetUpdateMode?
    /// An option to define if software updates should be applied within a maintenance window.
    public var softwareSetUpdateSchedule: WorkSpacesThinClientClientTypes.SoftwareSetUpdateSchedule?

    public init(
        desiredSoftwareSetId: Swift.String? = nil,
        desktopArn: Swift.String? = nil,
        desktopEndpoint: Swift.String? = nil,
        deviceCreationTags: [Swift.String: Swift.String]? = nil,
        id: Swift.String? = nil,
        maintenanceWindow: WorkSpacesThinClientClientTypes.MaintenanceWindow? = nil,
        name: Swift.String? = nil,
        softwareSetUpdateMode: WorkSpacesThinClientClientTypes.SoftwareSetUpdateMode? = nil,
        softwareSetUpdateSchedule: WorkSpacesThinClientClientTypes.SoftwareSetUpdateSchedule? = nil
    )
    {
        self.desiredSoftwareSetId = desiredSoftwareSetId
        self.desktopArn = desktopArn
        self.desktopEndpoint = desktopEndpoint
        self.deviceCreationTags = deviceCreationTags
        self.id = id
        self.maintenanceWindow = maintenanceWindow
        self.name = name
        self.softwareSetUpdateMode = softwareSetUpdateMode
        self.softwareSetUpdateSchedule = softwareSetUpdateSchedule
    }
}

extension UpdateEnvironmentInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateEnvironmentInput(desiredSoftwareSetId: \(Swift.String(describing: desiredSoftwareSetId)), desktopArn: \(Swift.String(describing: desktopArn)), id: \(Swift.String(describing: id)), maintenanceWindow: \(Swift.String(describing: maintenanceWindow)), softwareSetUpdateMode: \(Swift.String(describing: softwareSetUpdateMode)), softwareSetUpdateSchedule: \(Swift.String(describing: softwareSetUpdateSchedule)), desktopEndpoint: \"CONTENT_REDACTED\", deviceCreationTags: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

public struct UpdateEnvironmentOutput: Swift.Sendable {
    /// Describes an environment.
    public var environment: WorkSpacesThinClientClientTypes.EnvironmentSummary?

    public init(
        environment: WorkSpacesThinClientClientTypes.EnvironmentSummary? = nil
    )
    {
        self.environment = environment
    }
}

public struct UpdateSoftwareSetInput: Swift.Sendable {
    /// The ID of the software set to update.
    /// This member is required.
    public var id: Swift.String?
    /// An option to define if the software set has been validated.
    /// This member is required.
    public var validationStatus: WorkSpacesThinClientClientTypes.SoftwareSetValidationStatus?

    public init(
        id: Swift.String? = nil,
        validationStatus: WorkSpacesThinClientClientTypes.SoftwareSetValidationStatus? = nil
    )
    {
        self.id = id
        self.validationStatus = validationStatus
    }
}

public struct UpdateSoftwareSetOutput: Swift.Sendable {

    public init() { }
}

extension CreateEnvironmentInput {

    static func urlPathProvider(_ value: CreateEnvironmentInput) -> Swift.String? {
        return "/environments"
    }
}

extension DeleteDeviceInput {

    static func urlPathProvider(_ value: DeleteDeviceInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/devices/\(id.urlPercentEncoding())"
    }
}

extension DeleteDeviceInput {

    static func queryItemProvider(_ value: DeleteDeviceInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let clientToken = value.clientToken {
            let clientTokenQueryItem = Smithy.URIQueryItem(name: "clientToken".urlPercentEncoding(), value: Swift.String(clientToken).urlPercentEncoding())
            items.append(clientTokenQueryItem)
        }
        return items
    }
}

extension DeleteEnvironmentInput {

    static func urlPathProvider(_ value: DeleteEnvironmentInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/environments/\(id.urlPercentEncoding())"
    }
}

extension DeleteEnvironmentInput {

    static func queryItemProvider(_ value: DeleteEnvironmentInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let clientToken = value.clientToken {
            let clientTokenQueryItem = Smithy.URIQueryItem(name: "clientToken".urlPercentEncoding(), value: Swift.String(clientToken).urlPercentEncoding())
            items.append(clientTokenQueryItem)
        }
        return items
    }
}

extension DeregisterDeviceInput {

    static func urlPathProvider(_ value: DeregisterDeviceInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/deregister-device/\(id.urlPercentEncoding())"
    }
}

extension GetDeviceInput {

    static func urlPathProvider(_ value: GetDeviceInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/devices/\(id.urlPercentEncoding())"
    }
}

extension GetEnvironmentInput {

    static func urlPathProvider(_ value: GetEnvironmentInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/environments/\(id.urlPercentEncoding())"
    }
}

extension GetSoftwareSetInput {

    static func urlPathProvider(_ value: GetSoftwareSetInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/softwaresets/\(id.urlPercentEncoding())"
    }
}

extension ListDevicesInput {

    static func urlPathProvider(_ value: ListDevicesInput) -> Swift.String? {
        return "/devices"
    }
}

extension ListDevicesInput {

    static func queryItemProvider(_ value: ListDevicesInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListEnvironmentsInput {

    static func urlPathProvider(_ value: ListEnvironmentsInput) -> Swift.String? {
        return "/environments"
    }
}

extension ListEnvironmentsInput {

    static func queryItemProvider(_ value: ListEnvironmentsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListSoftwareSetsInput {

    static func urlPathProvider(_ value: ListSoftwareSetsInput) -> Swift.String? {
        return "/softwaresets"
    }
}

extension ListSoftwareSetsInput {

    static func queryItemProvider(_ value: ListSoftwareSetsInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = Smithy.URIQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = Smithy.URIQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

extension UntagResourceInput {

    static func queryItemProvider(_ value: UntagResourceInput) throws -> [Smithy.URIQueryItem] {
        var items = [Smithy.URIQueryItem]()
        guard let tagKeys = value.tagKeys else {
            let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
            throw Smithy.ClientError.unknownError(message)
        }
        tagKeys.forEach { queryItemValue in
            let queryItem = Smithy.URIQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
            items.append(queryItem)
        }
        return items
    }
}

extension UpdateDeviceInput {

    static func urlPathProvider(_ value: UpdateDeviceInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/devices/\(id.urlPercentEncoding())"
    }
}

extension UpdateEnvironmentInput {

    static func urlPathProvider(_ value: UpdateEnvironmentInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/environments/\(id.urlPercentEncoding())"
    }
}

extension UpdateSoftwareSetInput {

    static func urlPathProvider(_ value: UpdateSoftwareSetInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/softwaresets/\(id.urlPercentEncoding())"
    }
}

extension CreateEnvironmentInput {

    static func write(value: CreateEnvironmentInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["desiredSoftwareSetId"].write(value.desiredSoftwareSetId)
        try writer["desktopArn"].write(value.desktopArn)
        try writer["desktopEndpoint"].write(value.desktopEndpoint)
        try writer["deviceCreationTags"].writeMap(value.deviceCreationTags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["kmsKeyArn"].write(value.kmsKeyArn)
        try writer["maintenanceWindow"].write(value.maintenanceWindow, with: WorkSpacesThinClientClientTypes.MaintenanceWindow.write(value:to:))
        try writer["name"].write(value.name)
        try writer["softwareSetUpdateMode"].write(value.softwareSetUpdateMode)
        try writer["softwareSetUpdateSchedule"].write(value.softwareSetUpdateSchedule)
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension DeregisterDeviceInput {

    static func write(value: DeregisterDeviceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["clientToken"].write(value.clientToken)
        try writer["targetDeviceStatus"].write(value.targetDeviceStatus)
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["tags"].writeMap(value.tags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
    }
}

extension UpdateDeviceInput {

    static func write(value: UpdateDeviceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["desiredSoftwareSetId"].write(value.desiredSoftwareSetId)
        try writer["name"].write(value.name)
        try writer["softwareSetUpdateSchedule"].write(value.softwareSetUpdateSchedule)
    }
}

extension UpdateEnvironmentInput {

    static func write(value: UpdateEnvironmentInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["desiredSoftwareSetId"].write(value.desiredSoftwareSetId)
        try writer["desktopArn"].write(value.desktopArn)
        try writer["desktopEndpoint"].write(value.desktopEndpoint)
        try writer["deviceCreationTags"].writeMap(value.deviceCreationTags, valueWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        try writer["maintenanceWindow"].write(value.maintenanceWindow, with: WorkSpacesThinClientClientTypes.MaintenanceWindow.write(value:to:))
        try writer["name"].write(value.name)
        try writer["softwareSetUpdateMode"].write(value.softwareSetUpdateMode)
        try writer["softwareSetUpdateSchedule"].write(value.softwareSetUpdateSchedule)
    }
}

extension UpdateSoftwareSetInput {

    static func write(value: UpdateSoftwareSetInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["validationStatus"].write(value.validationStatus)
    }
}

extension CreateEnvironmentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateEnvironmentOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateEnvironmentOutput()
        value.environment = try reader["environment"].readIfPresent(with: WorkSpacesThinClientClientTypes.EnvironmentSummary.read(from:))
        return value
    }
}

extension DeleteDeviceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteDeviceOutput {
        return DeleteDeviceOutput()
    }
}

extension DeleteEnvironmentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeleteEnvironmentOutput {
        return DeleteEnvironmentOutput()
    }
}

extension DeregisterDeviceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DeregisterDeviceOutput {
        return DeregisterDeviceOutput()
    }
}

extension GetDeviceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetDeviceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetDeviceOutput()
        value.device = try reader["device"].readIfPresent(with: WorkSpacesThinClientClientTypes.Device.read(from:))
        return value
    }
}

extension GetEnvironmentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetEnvironmentOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetEnvironmentOutput()
        value.environment = try reader["environment"].readIfPresent(with: WorkSpacesThinClientClientTypes.Environment.read(from:))
        return value
    }
}

extension GetSoftwareSetOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetSoftwareSetOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetSoftwareSetOutput()
        value.softwareSet = try reader["softwareSet"].readIfPresent(with: WorkSpacesThinClientClientTypes.SoftwareSet.read(from:))
        return value
    }
}

extension ListDevicesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListDevicesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListDevicesOutput()
        value.devices = try reader["devices"].readListIfPresent(memberReadingClosure: WorkSpacesThinClientClientTypes.DeviceSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListEnvironmentsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListEnvironmentsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListEnvironmentsOutput()
        value.environments = try reader["environments"].readListIfPresent(memberReadingClosure: WorkSpacesThinClientClientTypes.EnvironmentSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.nextToken = try reader["nextToken"].readIfPresent()
        return value
    }
}

extension ListSoftwareSetsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListSoftwareSetsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListSoftwareSetsOutput()
        value.nextToken = try reader["nextToken"].readIfPresent()
        value.softwareSets = try reader["softwareSets"].readListIfPresent(memberReadingClosure: WorkSpacesThinClientClientTypes.SoftwareSetSummary.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

extension UpdateDeviceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateDeviceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateDeviceOutput()
        value.device = try reader["device"].readIfPresent(with: WorkSpacesThinClientClientTypes.DeviceSummary.read(from:))
        return value
    }
}

extension UpdateEnvironmentOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateEnvironmentOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateEnvironmentOutput()
        value.environment = try reader["environment"].readIfPresent(with: WorkSpacesThinClientClientTypes.EnvironmentSummary.read(from:))
        return value
    }
}

extension UpdateSoftwareSetOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateSoftwareSetOutput {
        return UpdateSoftwareSetOutput()
    }
}

enum CreateEnvironmentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteDeviceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeleteEnvironmentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DeregisterDeviceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetDeviceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetEnvironmentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetSoftwareSetOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListDevicesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListEnvironmentsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListSoftwareSetsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateDeviceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateEnvironmentOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateSoftwareSetOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.RestJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension InternalServerException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> InternalServerException {
        let reader = baseError.errorBodyReader
        let httpResponse = baseError.httpResponse
        var value = InternalServerException()
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            value.properties.retryAfterSeconds = Swift.Int(retryAfterSecondsHeaderValue) ?? 0
        }
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ConflictException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ConflictException {
        let reader = baseError.errorBodyReader
        var value = ConflictException()
        value.properties.message = try reader["message"].readIfPresent()
        value.properties.resourceId = try reader["resourceId"].readIfPresent()
        value.properties.resourceType = try reader["resourceType"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ServiceQuotaExceededException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ServiceQuotaExceededException {
        let reader = baseError.errorBodyReader
        var value = ServiceQuotaExceededException()
        value.properties.message = try reader["message"].readIfPresent()
        value.properties.quotaCode = try reader["quotaCode"].readIfPresent()
        value.properties.resourceId = try reader["resourceId"].readIfPresent()
        value.properties.resourceType = try reader["resourceType"].readIfPresent()
        value.properties.serviceCode = try reader["serviceCode"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ValidationException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ValidationException {
        let reader = baseError.errorBodyReader
        var value = ValidationException()
        value.properties.fieldList = try reader["fieldList"].readListIfPresent(memberReadingClosure: WorkSpacesThinClientClientTypes.ValidationExceptionField.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.properties.message = try reader["message"].readIfPresent()
        value.properties.reason = try reader["reason"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension AccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> AccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = AccessDeniedException()
        value.properties.message = try reader["message"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.message = try reader["message"].readIfPresent()
        value.properties.resourceId = try reader["resourceId"].readIfPresent()
        value.properties.resourceType = try reader["resourceType"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ThrottlingException {

    static func makeError(baseError: AWSClientRuntime.RestJSONError) throws -> ThrottlingException {
        let reader = baseError.errorBodyReader
        let httpResponse = baseError.httpResponse
        var value = ThrottlingException()
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            value.properties.retryAfterSeconds = Swift.Int(retryAfterSecondsHeaderValue) ?? 0
        }
        value.properties.message = try reader["message"].readIfPresent()
        value.properties.quotaCode = try reader["quotaCode"].readIfPresent()
        value.properties.serviceCode = try reader["serviceCode"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension WorkSpacesThinClientClientTypes.EnvironmentSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> WorkSpacesThinClientClientTypes.EnvironmentSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WorkSpacesThinClientClientTypes.EnvironmentSummary()
        value.id = try reader["id"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.desktopArn = try reader["desktopArn"].readIfPresent()
        value.desktopEndpoint = try reader["desktopEndpoint"].readIfPresent()
        value.desktopType = try reader["desktopType"].readIfPresent()
        value.activationCode = try reader["activationCode"].readIfPresent()
        value.softwareSetUpdateSchedule = try reader["softwareSetUpdateSchedule"].readIfPresent()
        value.maintenanceWindow = try reader["maintenanceWindow"].readIfPresent(with: WorkSpacesThinClientClientTypes.MaintenanceWindow.read(from:))
        value.softwareSetUpdateMode = try reader["softwareSetUpdateMode"].readIfPresent()
        value.desiredSoftwareSetId = try reader["desiredSoftwareSetId"].readIfPresent()
        value.pendingSoftwareSetId = try reader["pendingSoftwareSetId"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.arn = try reader["arn"].readIfPresent()
        return value
    }
}

extension WorkSpacesThinClientClientTypes.MaintenanceWindow {

    static func write(value: WorkSpacesThinClientClientTypes.MaintenanceWindow?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["applyTimeOf"].write(value.applyTimeOf)
        try writer["daysOfTheWeek"].writeList(value.daysOfTheWeek, memberWritingClosure: SmithyReadWrite.WritingClosureBox<WorkSpacesThinClientClientTypes.DayOfWeek>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["endTimeHour"].write(value.endTimeHour)
        try writer["endTimeMinute"].write(value.endTimeMinute)
        try writer["startTimeHour"].write(value.startTimeHour)
        try writer["startTimeMinute"].write(value.startTimeMinute)
        try writer["type"].write(value.type)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> WorkSpacesThinClientClientTypes.MaintenanceWindow {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WorkSpacesThinClientClientTypes.MaintenanceWindow()
        value.type = try reader["type"].readIfPresent()
        value.startTimeHour = try reader["startTimeHour"].readIfPresent()
        value.startTimeMinute = try reader["startTimeMinute"].readIfPresent()
        value.endTimeHour = try reader["endTimeHour"].readIfPresent()
        value.endTimeMinute = try reader["endTimeMinute"].readIfPresent()
        value.daysOfTheWeek = try reader["daysOfTheWeek"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<WorkSpacesThinClientClientTypes.DayOfWeek>().read(from:), memberNodeInfo: "member", isFlattened: false)
        value.applyTimeOf = try reader["applyTimeOf"].readIfPresent()
        return value
    }
}

extension WorkSpacesThinClientClientTypes.Device {

    static func read(from reader: SmithyJSON.Reader) throws -> WorkSpacesThinClientClientTypes.Device {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WorkSpacesThinClientClientTypes.Device()
        value.id = try reader["id"].readIfPresent()
        value.serialNumber = try reader["serialNumber"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.model = try reader["model"].readIfPresent()
        value.environmentId = try reader["environmentId"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.currentSoftwareSetId = try reader["currentSoftwareSetId"].readIfPresent()
        value.currentSoftwareSetVersion = try reader["currentSoftwareSetVersion"].readIfPresent()
        value.desiredSoftwareSetId = try reader["desiredSoftwareSetId"].readIfPresent()
        value.pendingSoftwareSetId = try reader["pendingSoftwareSetId"].readIfPresent()
        value.pendingSoftwareSetVersion = try reader["pendingSoftwareSetVersion"].readIfPresent()
        value.softwareSetUpdateSchedule = try reader["softwareSetUpdateSchedule"].readIfPresent()
        value.softwareSetComplianceStatus = try reader["softwareSetComplianceStatus"].readIfPresent()
        value.softwareSetUpdateStatus = try reader["softwareSetUpdateStatus"].readIfPresent()
        value.lastConnectedAt = try reader["lastConnectedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastPostureAt = try reader["lastPostureAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.arn = try reader["arn"].readIfPresent()
        value.kmsKeyArn = try reader["kmsKeyArn"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension WorkSpacesThinClientClientTypes.Environment {

    static func read(from reader: SmithyJSON.Reader) throws -> WorkSpacesThinClientClientTypes.Environment {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WorkSpacesThinClientClientTypes.Environment()
        value.id = try reader["id"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.desktopArn = try reader["desktopArn"].readIfPresent()
        value.desktopEndpoint = try reader["desktopEndpoint"].readIfPresent()
        value.desktopType = try reader["desktopType"].readIfPresent()
        value.activationCode = try reader["activationCode"].readIfPresent()
        value.registeredDevicesCount = try reader["registeredDevicesCount"].readIfPresent()
        value.softwareSetUpdateSchedule = try reader["softwareSetUpdateSchedule"].readIfPresent()
        value.maintenanceWindow = try reader["maintenanceWindow"].readIfPresent(with: WorkSpacesThinClientClientTypes.MaintenanceWindow.read(from:))
        value.softwareSetUpdateMode = try reader["softwareSetUpdateMode"].readIfPresent()
        value.desiredSoftwareSetId = try reader["desiredSoftwareSetId"].readIfPresent()
        value.pendingSoftwareSetId = try reader["pendingSoftwareSetId"].readIfPresent()
        value.pendingSoftwareSetVersion = try reader["pendingSoftwareSetVersion"].readIfPresent()
        value.softwareSetComplianceStatus = try reader["softwareSetComplianceStatus"].readIfPresent()
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.arn = try reader["arn"].readIfPresent()
        value.kmsKeyArn = try reader["kmsKeyArn"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        value.deviceCreationTags = try reader["deviceCreationTags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension WorkSpacesThinClientClientTypes.SoftwareSet {

    static func read(from reader: SmithyJSON.Reader) throws -> WorkSpacesThinClientClientTypes.SoftwareSet {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WorkSpacesThinClientClientTypes.SoftwareSet()
        value.id = try reader["id"].readIfPresent()
        value.version = try reader["version"].readIfPresent()
        value.releasedAt = try reader["releasedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.supportedUntil = try reader["supportedUntil"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.validationStatus = try reader["validationStatus"].readIfPresent()
        value.software = try reader["software"].readListIfPresent(memberReadingClosure: WorkSpacesThinClientClientTypes.Software.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.arn = try reader["arn"].readIfPresent()
        value.tags = try reader["tags"].readMapIfPresent(valueReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false)
        return value
    }
}

extension WorkSpacesThinClientClientTypes.Software {

    static func read(from reader: SmithyJSON.Reader) throws -> WorkSpacesThinClientClientTypes.Software {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WorkSpacesThinClientClientTypes.Software()
        value.name = try reader["name"].readIfPresent()
        value.version = try reader["version"].readIfPresent()
        return value
    }
}

extension WorkSpacesThinClientClientTypes.DeviceSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> WorkSpacesThinClientClientTypes.DeviceSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WorkSpacesThinClientClientTypes.DeviceSummary()
        value.id = try reader["id"].readIfPresent()
        value.serialNumber = try reader["serialNumber"].readIfPresent()
        value.name = try reader["name"].readIfPresent()
        value.model = try reader["model"].readIfPresent()
        value.environmentId = try reader["environmentId"].readIfPresent()
        value.status = try reader["status"].readIfPresent()
        value.currentSoftwareSetId = try reader["currentSoftwareSetId"].readIfPresent()
        value.desiredSoftwareSetId = try reader["desiredSoftwareSetId"].readIfPresent()
        value.pendingSoftwareSetId = try reader["pendingSoftwareSetId"].readIfPresent()
        value.softwareSetUpdateSchedule = try reader["softwareSetUpdateSchedule"].readIfPresent()
        value.lastConnectedAt = try reader["lastConnectedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.lastPostureAt = try reader["lastPostureAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.createdAt = try reader["createdAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.updatedAt = try reader["updatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.arn = try reader["arn"].readIfPresent()
        return value
    }
}

extension WorkSpacesThinClientClientTypes.SoftwareSetSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> WorkSpacesThinClientClientTypes.SoftwareSetSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WorkSpacesThinClientClientTypes.SoftwareSetSummary()
        value.id = try reader["id"].readIfPresent()
        value.version = try reader["version"].readIfPresent()
        value.releasedAt = try reader["releasedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.supportedUntil = try reader["supportedUntil"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.epochSeconds)
        value.validationStatus = try reader["validationStatus"].readIfPresent()
        value.arn = try reader["arn"].readIfPresent()
        return value
    }
}

extension WorkSpacesThinClientClientTypes.ValidationExceptionField {

    static func read(from reader: SmithyJSON.Reader) throws -> WorkSpacesThinClientClientTypes.ValidationExceptionField {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = WorkSpacesThinClientClientTypes.ValidationExceptionField()
        value.name = try reader["name"].readIfPresent() ?? ""
        value.message = try reader["message"].readIfPresent() ?? ""
        return value
    }
}

public enum WorkSpacesThinClientClientTypes {}
