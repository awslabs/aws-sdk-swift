// Code generated by smithy-swift-codegen. DO NOT EDIT!
import AWSClientRuntime
import ClientRuntime

extension AccessDeniedException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: AccessDeniedExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// You do not have sufficient access to perform this action.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    )
    {
        self.properties.message = message
    }
}

struct AccessDeniedExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension AccessDeniedExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension WorkSpacesThinClientClientTypes {
    public enum ApplyTimeOf: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case device
        case utc
        case sdkUnknown(Swift.String)

        public static var allCases: [ApplyTimeOf] {
            return [
                .device,
                .utc,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .device: return "DEVICE"
            case .utc: return "UTC"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ApplyTimeOf(rawValue: rawValue) ?? ApplyTimeOf.sdkUnknown(rawValue)
        }
    }
}

extension ConflictException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ConflictExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.resourceId = output.resourceId
            self.properties.resourceType = output.resourceType
        } else {
            self.properties.message = nil
            self.properties.resourceId = nil
            self.properties.resourceType = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The requested operation would cause a conflict with the current state of a service resource associated with the request. Resolve the conflict before retrying this request.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        /// The ID of the resource associated with the request.
        public internal(set) var resourceId: Swift.String? = nil
        /// The type of the resource associated with the request.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
    }
}

struct ConflictExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceId: Swift.String?
    let resourceType: Swift.String?
}

extension ConflictExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case resourceId
        case resourceType
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension CreateEnvironmentInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateEnvironmentInput(clientToken: \(Swift.String(describing: clientToken)), desiredSoftwareSetId: \(Swift.String(describing: desiredSoftwareSetId)), desktopArn: \(Swift.String(describing: desktopArn)), kmsKeyArn: \(Swift.String(describing: kmsKeyArn)), maintenanceWindow: \(Swift.String(describing: maintenanceWindow)), softwareSetUpdateMode: \(Swift.String(describing: softwareSetUpdateMode)), softwareSetUpdateSchedule: \(Swift.String(describing: softwareSetUpdateSchedule)), desktopEndpoint: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\", tags: \"CONTENT_REDACTED\")"}
}

extension CreateEnvironmentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case desiredSoftwareSetId
        case desktopArn
        case desktopEndpoint
        case kmsKeyArn
        case maintenanceWindow
        case name
        case softwareSetUpdateMode
        case softwareSetUpdateSchedule
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let desiredSoftwareSetId = self.desiredSoftwareSetId {
            try encodeContainer.encode(desiredSoftwareSetId, forKey: .desiredSoftwareSetId)
        }
        if let desktopArn = self.desktopArn {
            try encodeContainer.encode(desktopArn, forKey: .desktopArn)
        }
        if let desktopEndpoint = self.desktopEndpoint {
            try encodeContainer.encode(desktopEndpoint, forKey: .desktopEndpoint)
        }
        if let kmsKeyArn = self.kmsKeyArn {
            try encodeContainer.encode(kmsKeyArn, forKey: .kmsKeyArn)
        }
        if let maintenanceWindow = self.maintenanceWindow {
            try encodeContainer.encode(maintenanceWindow, forKey: .maintenanceWindow)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let softwareSetUpdateMode = self.softwareSetUpdateMode {
            try encodeContainer.encode(softwareSetUpdateMode.rawValue, forKey: .softwareSetUpdateMode)
        }
        if let softwareSetUpdateSchedule = self.softwareSetUpdateSchedule {
            try encodeContainer.encode(softwareSetUpdateSchedule.rawValue, forKey: .softwareSetUpdateSchedule)
        }
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagsMap0) in tags {
                try tagsContainer.encode(tagsMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension CreateEnvironmentInput {

    static func urlPathProvider(_ value: CreateEnvironmentInput) -> Swift.String? {
        return "/environments"
    }
}

public struct CreateEnvironmentInput: Swift.Equatable {
    /// Specifies a unique, case-sensitive identifier that you provide to ensure the idempotency of the request. This lets you safely retry the request without accidentally performing the same operation a second time. Passing the same value to a later call to an operation requires that you also pass the same value for all other parameters. We recommend that you use a [UUID type of value](https://wikipedia.org/wiki/Universally_unique_identifier). If you don't provide this value, then Amazon Web Services generates a random one for you. If you retry the operation with the same ClientToken, but with different parameters, the retry fails with an IdempotentParameterMismatch error.
    public var clientToken: Swift.String?
    /// The ID of the software set to apply.
    public var desiredSoftwareSetId: Swift.String?
    /// The Amazon Resource Name (ARN) of the desktop to stream from Amazon WorkSpaces, WorkSpaces Web, or AppStream 2.0.
    /// This member is required.
    public var desktopArn: Swift.String?
    /// The URL for the identity provider login (only for environments that use AppStream 2.0).
    public var desktopEndpoint: Swift.String?
    /// The Amazon Resource Name (ARN) of the Key Management Service key to use to encrypt the environment.
    public var kmsKeyArn: Swift.String?
    /// A specification for a time window to apply software updates.
    public var maintenanceWindow: WorkSpacesThinClientClientTypes.MaintenanceWindow?
    /// The name for the environment.
    public var name: Swift.String?
    /// An option to define which software updates to apply.
    public var softwareSetUpdateMode: WorkSpacesThinClientClientTypes.SoftwareSetUpdateMode?
    /// An option to define if software updates should be applied within a maintenance window.
    public var softwareSetUpdateSchedule: WorkSpacesThinClientClientTypes.SoftwareSetUpdateSchedule?
    /// A map of the key-value pairs of the tag or tags to assign to the resource.
    public var tags: [Swift.String:Swift.String]?

    public init(
        clientToken: Swift.String? = nil,
        desiredSoftwareSetId: Swift.String? = nil,
        desktopArn: Swift.String? = nil,
        desktopEndpoint: Swift.String? = nil,
        kmsKeyArn: Swift.String? = nil,
        maintenanceWindow: WorkSpacesThinClientClientTypes.MaintenanceWindow? = nil,
        name: Swift.String? = nil,
        softwareSetUpdateMode: WorkSpacesThinClientClientTypes.SoftwareSetUpdateMode? = nil,
        softwareSetUpdateSchedule: WorkSpacesThinClientClientTypes.SoftwareSetUpdateSchedule? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.clientToken = clientToken
        self.desiredSoftwareSetId = desiredSoftwareSetId
        self.desktopArn = desktopArn
        self.desktopEndpoint = desktopEndpoint
        self.kmsKeyArn = kmsKeyArn
        self.maintenanceWindow = maintenanceWindow
        self.name = name
        self.softwareSetUpdateMode = softwareSetUpdateMode
        self.softwareSetUpdateSchedule = softwareSetUpdateSchedule
        self.tags = tags
    }
}

struct CreateEnvironmentInputBody: Swift.Equatable {
    let name: Swift.String?
    let desktopArn: Swift.String?
    let desktopEndpoint: Swift.String?
    let softwareSetUpdateSchedule: WorkSpacesThinClientClientTypes.SoftwareSetUpdateSchedule?
    let maintenanceWindow: WorkSpacesThinClientClientTypes.MaintenanceWindow?
    let softwareSetUpdateMode: WorkSpacesThinClientClientTypes.SoftwareSetUpdateMode?
    let desiredSoftwareSetId: Swift.String?
    let kmsKeyArn: Swift.String?
    let clientToken: Swift.String?
    let tags: [Swift.String:Swift.String]?
}

extension CreateEnvironmentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case desiredSoftwareSetId
        case desktopArn
        case desktopEndpoint
        case kmsKeyArn
        case maintenanceWindow
        case name
        case softwareSetUpdateMode
        case softwareSetUpdateSchedule
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let desktopArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .desktopArn)
        desktopArn = desktopArnDecoded
        let desktopEndpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .desktopEndpoint)
        desktopEndpoint = desktopEndpointDecoded
        let softwareSetUpdateScheduleDecoded = try containerValues.decodeIfPresent(WorkSpacesThinClientClientTypes.SoftwareSetUpdateSchedule.self, forKey: .softwareSetUpdateSchedule)
        softwareSetUpdateSchedule = softwareSetUpdateScheduleDecoded
        let maintenanceWindowDecoded = try containerValues.decodeIfPresent(WorkSpacesThinClientClientTypes.MaintenanceWindow.self, forKey: .maintenanceWindow)
        maintenanceWindow = maintenanceWindowDecoded
        let softwareSetUpdateModeDecoded = try containerValues.decodeIfPresent(WorkSpacesThinClientClientTypes.SoftwareSetUpdateMode.self, forKey: .softwareSetUpdateMode)
        softwareSetUpdateMode = softwareSetUpdateModeDecoded
        let desiredSoftwareSetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .desiredSoftwareSetId)
        desiredSoftwareSetId = desiredSoftwareSetIdDecoded
        let kmsKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyArn)
        kmsKeyArn = kmsKeyArnDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension CreateEnvironmentOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: CreateEnvironmentOutputBody = try responseDecoder.decode(responseBody: data)
            self.environment = output.environment
        } else {
            self.environment = nil
        }
    }
}

public struct CreateEnvironmentOutput: Swift.Equatable {
    /// Describes an environment.
    public var environment: WorkSpacesThinClientClientTypes.EnvironmentSummary?

    public init(
        environment: WorkSpacesThinClientClientTypes.EnvironmentSummary? = nil
    )
    {
        self.environment = environment
    }
}

struct CreateEnvironmentOutputBody: Swift.Equatable {
    let environment: WorkSpacesThinClientClientTypes.EnvironmentSummary?
}

extension CreateEnvironmentOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case environment
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let environmentDecoded = try containerValues.decodeIfPresent(WorkSpacesThinClientClientTypes.EnvironmentSummary.self, forKey: .environment)
        environment = environmentDecoded
    }
}

enum CreateEnvironmentOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ServiceQuotaExceededException": return try await ServiceQuotaExceededException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension WorkSpacesThinClientClientTypes {
    public enum DayOfWeek: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case friday
        case monday
        case saturday
        case sunday
        case thursday
        case tuesday
        case wednesday
        case sdkUnknown(Swift.String)

        public static var allCases: [DayOfWeek] {
            return [
                .friday,
                .monday,
                .saturday,
                .sunday,
                .thursday,
                .tuesday,
                .wednesday,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .friday: return "FRIDAY"
            case .monday: return "MONDAY"
            case .saturday: return "SATURDAY"
            case .sunday: return "SUNDAY"
            case .thursday: return "THURSDAY"
            case .tuesday: return "TUESDAY"
            case .wednesday: return "WEDNESDAY"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DayOfWeek(rawValue: rawValue) ?? DayOfWeek.sdkUnknown(rawValue)
        }
    }
}

extension DeleteDeviceInput {

    static func queryItemProvider(_ value: DeleteDeviceInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let clientToken = value.clientToken {
            let clientTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "clientToken".urlPercentEncoding(), value: Swift.String(clientToken).urlPercentEncoding())
            items.append(clientTokenQueryItem)
        }
        return items
    }
}

extension DeleteDeviceInput {

    static func urlPathProvider(_ value: DeleteDeviceInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/devices/\(id.urlPercentEncoding())"
    }
}

public struct DeleteDeviceInput: Swift.Equatable {
    /// Specifies a unique, case-sensitive identifier that you provide to ensure the idempotency of the request. This lets you safely retry the request without accidentally performing the same operation a second time. Passing the same value to a later call to an operation requires that you also pass the same value for all other parameters. We recommend that you use a [UUID type of value](https://wikipedia.org/wiki/Universally_unique_identifier). If you don't provide this value, then Amazon Web Services generates a random one for you. If you retry the operation with the same ClientToken, but with different parameters, the retry fails with an IdempotentParameterMismatch error.
    public var clientToken: Swift.String?
    /// The ID of the device to delete.
    /// This member is required.
    public var id: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        id: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.id = id
    }
}

struct DeleteDeviceInputBody: Swift.Equatable {
}

extension DeleteDeviceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteDeviceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteDeviceOutput: Swift.Equatable {

    public init() { }
}

enum DeleteDeviceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeleteEnvironmentInput {

    static func queryItemProvider(_ value: DeleteEnvironmentInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let clientToken = value.clientToken {
            let clientTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "clientToken".urlPercentEncoding(), value: Swift.String(clientToken).urlPercentEncoding())
            items.append(clientTokenQueryItem)
        }
        return items
    }
}

extension DeleteEnvironmentInput {

    static func urlPathProvider(_ value: DeleteEnvironmentInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/environments/\(id.urlPercentEncoding())"
    }
}

public struct DeleteEnvironmentInput: Swift.Equatable {
    /// Specifies a unique, case-sensitive identifier that you provide to ensure the idempotency of the request. This lets you safely retry the request without accidentally performing the same operation a second time. Passing the same value to a later call to an operation requires that you also pass the same value for all other parameters. We recommend that you use a [UUID type of value](https://wikipedia.org/wiki/Universally_unique_identifier). If you don't provide this value, then Amazon Web Services generates a random one for you. If you retry the operation with the same ClientToken, but with different parameters, the retry fails with an IdempotentParameterMismatch error.
    public var clientToken: Swift.String?
    /// The ID of the environment to delete.
    /// This member is required.
    public var id: Swift.String?

    public init(
        clientToken: Swift.String? = nil,
        id: Swift.String? = nil
    )
    {
        self.clientToken = clientToken
        self.id = id
    }
}

struct DeleteEnvironmentInputBody: Swift.Equatable {
}

extension DeleteEnvironmentInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension DeleteEnvironmentOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeleteEnvironmentOutput: Swift.Equatable {

    public init() { }
}

enum DeleteEnvironmentOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension DeregisterDeviceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case targetDeviceStatus
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let clientToken = self.clientToken {
            try encodeContainer.encode(clientToken, forKey: .clientToken)
        }
        if let targetDeviceStatus = self.targetDeviceStatus {
            try encodeContainer.encode(targetDeviceStatus.rawValue, forKey: .targetDeviceStatus)
        }
    }
}

extension DeregisterDeviceInput {

    static func urlPathProvider(_ value: DeregisterDeviceInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/deregister-device/\(id.urlPercentEncoding())"
    }
}

public struct DeregisterDeviceInput: Swift.Equatable {
    /// Specifies a unique, case-sensitive identifier that you provide to ensure the idempotency of the request. This lets you safely retry the request without accidentally performing the same operation a second time. Passing the same value to a later call to an operation requires that you also pass the same value for all other parameters. We recommend that you use a [UUID type of value](https://wikipedia.org/wiki/Universally_unique_identifier). If you don't provide this value, then Amazon Web Services generates a random one for you. If you retry the operation with the same ClientToken, but with different parameters, the retry fails with an IdempotentParameterMismatch error.
    public var clientToken: Swift.String?
    /// The ID of the device to deregister.
    /// This member is required.
    public var id: Swift.String?
    /// The desired new status for the device.
    public var targetDeviceStatus: WorkSpacesThinClientClientTypes.TargetDeviceStatus?

    public init(
        clientToken: Swift.String? = nil,
        id: Swift.String? = nil,
        targetDeviceStatus: WorkSpacesThinClientClientTypes.TargetDeviceStatus? = nil
    )
    {
        self.clientToken = clientToken
        self.id = id
        self.targetDeviceStatus = targetDeviceStatus
    }
}

struct DeregisterDeviceInputBody: Swift.Equatable {
    let targetDeviceStatus: WorkSpacesThinClientClientTypes.TargetDeviceStatus?
    let clientToken: Swift.String?
}

extension DeregisterDeviceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case clientToken
        case targetDeviceStatus
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let targetDeviceStatusDecoded = try containerValues.decodeIfPresent(WorkSpacesThinClientClientTypes.TargetDeviceStatus.self, forKey: .targetDeviceStatus)
        targetDeviceStatus = targetDeviceStatusDecoded
        let clientTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .clientToken)
        clientToken = clientTokenDecoded
    }
}

extension DeregisterDeviceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct DeregisterDeviceOutput: Swift.Equatable {

    public init() { }
}

enum DeregisterDeviceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ConflictException": return try await ConflictException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension WorkSpacesThinClientClientTypes {
    public enum DesktopType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case appstream
        case workspaces
        case workspacesWeb
        case sdkUnknown(Swift.String)

        public static var allCases: [DesktopType] {
            return [
                .appstream,
                .workspaces,
                .workspacesWeb,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .appstream: return "appstream"
            case .workspaces: return "workspaces"
            case .workspacesWeb: return "workspaces-web"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DesktopType(rawValue: rawValue) ?? DesktopType.sdkUnknown(rawValue)
        }
    }
}

extension WorkSpacesThinClientClientTypes.Device: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createdAt
        case currentSoftwareSetId
        case currentSoftwareSetVersion
        case desiredSoftwareSetId
        case environmentId
        case id
        case kmsKeyArn
        case lastConnectedAt
        case lastPostureAt
        case model
        case name
        case pendingSoftwareSetId
        case pendingSoftwareSetVersion
        case serialNumber
        case softwareSetComplianceStatus
        case softwareSetUpdateSchedule
        case softwareSetUpdateStatus
        case status
        case tags
        case updatedAt
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let currentSoftwareSetId = self.currentSoftwareSetId {
            try encodeContainer.encode(currentSoftwareSetId, forKey: .currentSoftwareSetId)
        }
        if let currentSoftwareSetVersion = self.currentSoftwareSetVersion {
            try encodeContainer.encode(currentSoftwareSetVersion, forKey: .currentSoftwareSetVersion)
        }
        if let desiredSoftwareSetId = self.desiredSoftwareSetId {
            try encodeContainer.encode(desiredSoftwareSetId, forKey: .desiredSoftwareSetId)
        }
        if let environmentId = self.environmentId {
            try encodeContainer.encode(environmentId, forKey: .environmentId)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let kmsKeyArn = self.kmsKeyArn {
            try encodeContainer.encode(kmsKeyArn, forKey: .kmsKeyArn)
        }
        if let lastConnectedAt = self.lastConnectedAt {
            try encodeContainer.encodeTimestamp(lastConnectedAt, format: .epochSeconds, forKey: .lastConnectedAt)
        }
        if let lastPostureAt = self.lastPostureAt {
            try encodeContainer.encodeTimestamp(lastPostureAt, format: .epochSeconds, forKey: .lastPostureAt)
        }
        if let model = self.model {
            try encodeContainer.encode(model, forKey: .model)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let pendingSoftwareSetId = self.pendingSoftwareSetId {
            try encodeContainer.encode(pendingSoftwareSetId, forKey: .pendingSoftwareSetId)
        }
        if let pendingSoftwareSetVersion = self.pendingSoftwareSetVersion {
            try encodeContainer.encode(pendingSoftwareSetVersion, forKey: .pendingSoftwareSetVersion)
        }
        if let serialNumber = self.serialNumber {
            try encodeContainer.encode(serialNumber, forKey: .serialNumber)
        }
        if let softwareSetComplianceStatus = self.softwareSetComplianceStatus {
            try encodeContainer.encode(softwareSetComplianceStatus.rawValue, forKey: .softwareSetComplianceStatus)
        }
        if let softwareSetUpdateSchedule = self.softwareSetUpdateSchedule {
            try encodeContainer.encode(softwareSetUpdateSchedule.rawValue, forKey: .softwareSetUpdateSchedule)
        }
        if let softwareSetUpdateStatus = self.softwareSetUpdateStatus {
            try encodeContainer.encode(softwareSetUpdateStatus.rawValue, forKey: .softwareSetUpdateStatus)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let tags = self.tags {
            try encodeContainer.encode(tags, forKey: .tags)
        }
        if let updatedAt = self.updatedAt {
            try encodeContainer.encodeTimestamp(updatedAt, format: .epochSeconds, forKey: .updatedAt)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let serialNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serialNumber)
        serialNumber = serialNumberDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let modelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .model)
        model = modelDecoded
        let environmentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentId)
        environmentId = environmentIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(WorkSpacesThinClientClientTypes.DeviceStatus.self, forKey: .status)
        status = statusDecoded
        let currentSoftwareSetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .currentSoftwareSetId)
        currentSoftwareSetId = currentSoftwareSetIdDecoded
        let currentSoftwareSetVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .currentSoftwareSetVersion)
        currentSoftwareSetVersion = currentSoftwareSetVersionDecoded
        let desiredSoftwareSetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .desiredSoftwareSetId)
        desiredSoftwareSetId = desiredSoftwareSetIdDecoded
        let pendingSoftwareSetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pendingSoftwareSetId)
        pendingSoftwareSetId = pendingSoftwareSetIdDecoded
        let pendingSoftwareSetVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pendingSoftwareSetVersion)
        pendingSoftwareSetVersion = pendingSoftwareSetVersionDecoded
        let softwareSetUpdateScheduleDecoded = try containerValues.decodeIfPresent(WorkSpacesThinClientClientTypes.SoftwareSetUpdateSchedule.self, forKey: .softwareSetUpdateSchedule)
        softwareSetUpdateSchedule = softwareSetUpdateScheduleDecoded
        let softwareSetComplianceStatusDecoded = try containerValues.decodeIfPresent(WorkSpacesThinClientClientTypes.DeviceSoftwareSetComplianceStatus.self, forKey: .softwareSetComplianceStatus)
        softwareSetComplianceStatus = softwareSetComplianceStatusDecoded
        let softwareSetUpdateStatusDecoded = try containerValues.decodeIfPresent(WorkSpacesThinClientClientTypes.SoftwareSetUpdateStatus.self, forKey: .softwareSetUpdateStatus)
        softwareSetUpdateStatus = softwareSetUpdateStatusDecoded
        let lastConnectedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastConnectedAt)
        lastConnectedAt = lastConnectedAtDecoded
        let lastPostureAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastPostureAt)
        lastPostureAt = lastPostureAtDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let kmsKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyArn)
        kmsKeyArn = kmsKeyArnDecoded
        let tagsDecoded = try containerValues.decodeIfPresent(WorkSpacesThinClientClientTypes.EmbeddedTag.self, forKey: .tags)
        tags = tagsDecoded
    }
}

extension WorkSpacesThinClientClientTypes.Device: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Device(arn: \(Swift.String(describing: arn)), createdAt: \(Swift.String(describing: createdAt)), currentSoftwareSetId: \(Swift.String(describing: currentSoftwareSetId)), currentSoftwareSetVersion: \(Swift.String(describing: currentSoftwareSetVersion)), desiredSoftwareSetId: \(Swift.String(describing: desiredSoftwareSetId)), environmentId: \(Swift.String(describing: environmentId)), id: \(Swift.String(describing: id)), kmsKeyArn: \(Swift.String(describing: kmsKeyArn)), lastConnectedAt: \(Swift.String(describing: lastConnectedAt)), lastPostureAt: \(Swift.String(describing: lastPostureAt)), model: \(Swift.String(describing: model)), pendingSoftwareSetId: \(Swift.String(describing: pendingSoftwareSetId)), pendingSoftwareSetVersion: \(Swift.String(describing: pendingSoftwareSetVersion)), serialNumber: \(Swift.String(describing: serialNumber)), softwareSetComplianceStatus: \(Swift.String(describing: softwareSetComplianceStatus)), softwareSetUpdateSchedule: \(Swift.String(describing: softwareSetUpdateSchedule)), softwareSetUpdateStatus: \(Swift.String(describing: softwareSetUpdateStatus)), status: \(Swift.String(describing: status)), updatedAt: \(Swift.String(describing: updatedAt)), name: \"CONTENT_REDACTED\", tags: \"CONTENT_REDACTED\")"}
}

extension WorkSpacesThinClientClientTypes {
    /// Describes a thin client device.
    public struct Device: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the device.
        public var arn: Swift.String?
        /// The timestamp of when the device was created.
        public var createdAt: ClientRuntime.Date?
        /// The ID of the software set currently installed on the device.
        public var currentSoftwareSetId: Swift.String?
        /// The version of the software set currently installed on the device.
        public var currentSoftwareSetVersion: Swift.String?
        /// The ID of the software set which the device has been set to.
        public var desiredSoftwareSetId: Swift.String?
        /// The ID of the environment the device is associated with.
        public var environmentId: Swift.String?
        /// The ID of the device.
        public var id: Swift.String?
        /// The Amazon Resource Name (ARN) of the Key Management Service key used to encrypt the device.
        public var kmsKeyArn: Swift.String?
        /// The timestamp of the most recent session on the device.
        public var lastConnectedAt: ClientRuntime.Date?
        /// The timestamp of the most recent check-in of the device.
        public var lastPostureAt: ClientRuntime.Date?
        /// The model number of the device.
        public var model: Swift.String?
        /// The name of the device.
        public var name: Swift.String?
        /// The ID of the software set that is pending to be installed on the device.
        public var pendingSoftwareSetId: Swift.String?
        /// The version of the software set that is pending to be installed on the device.
        public var pendingSoftwareSetVersion: Swift.String?
        /// The hardware serial number of the device.
        public var serialNumber: Swift.String?
        /// Describes if the software currently installed on the device is a supported version.
        public var softwareSetComplianceStatus: WorkSpacesThinClientClientTypes.DeviceSoftwareSetComplianceStatus?
        /// An option to define if software updates should be applied within a maintenance window.
        public var softwareSetUpdateSchedule: WorkSpacesThinClientClientTypes.SoftwareSetUpdateSchedule?
        /// Describes if the device has a supported version of software installed.
        public var softwareSetUpdateStatus: WorkSpacesThinClientClientTypes.SoftwareSetUpdateStatus?
        /// The status of the device.
        public var status: WorkSpacesThinClientClientTypes.DeviceStatus?
        /// The tag keys and optional values for the resource.
        public var tags: WorkSpacesThinClientClientTypes.EmbeddedTag?
        /// The timestamp of when the device was updated.
        public var updatedAt: ClientRuntime.Date?

        public init(
            arn: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            currentSoftwareSetId: Swift.String? = nil,
            currentSoftwareSetVersion: Swift.String? = nil,
            desiredSoftwareSetId: Swift.String? = nil,
            environmentId: Swift.String? = nil,
            id: Swift.String? = nil,
            kmsKeyArn: Swift.String? = nil,
            lastConnectedAt: ClientRuntime.Date? = nil,
            lastPostureAt: ClientRuntime.Date? = nil,
            model: Swift.String? = nil,
            name: Swift.String? = nil,
            pendingSoftwareSetId: Swift.String? = nil,
            pendingSoftwareSetVersion: Swift.String? = nil,
            serialNumber: Swift.String? = nil,
            softwareSetComplianceStatus: WorkSpacesThinClientClientTypes.DeviceSoftwareSetComplianceStatus? = nil,
            softwareSetUpdateSchedule: WorkSpacesThinClientClientTypes.SoftwareSetUpdateSchedule? = nil,
            softwareSetUpdateStatus: WorkSpacesThinClientClientTypes.SoftwareSetUpdateStatus? = nil,
            status: WorkSpacesThinClientClientTypes.DeviceStatus? = nil,
            tags: WorkSpacesThinClientClientTypes.EmbeddedTag? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.arn = arn
            self.createdAt = createdAt
            self.currentSoftwareSetId = currentSoftwareSetId
            self.currentSoftwareSetVersion = currentSoftwareSetVersion
            self.desiredSoftwareSetId = desiredSoftwareSetId
            self.environmentId = environmentId
            self.id = id
            self.kmsKeyArn = kmsKeyArn
            self.lastConnectedAt = lastConnectedAt
            self.lastPostureAt = lastPostureAt
            self.model = model
            self.name = name
            self.pendingSoftwareSetId = pendingSoftwareSetId
            self.pendingSoftwareSetVersion = pendingSoftwareSetVersion
            self.serialNumber = serialNumber
            self.softwareSetComplianceStatus = softwareSetComplianceStatus
            self.softwareSetUpdateSchedule = softwareSetUpdateSchedule
            self.softwareSetUpdateStatus = softwareSetUpdateStatus
            self.status = status
            self.tags = tags
            self.updatedAt = updatedAt
        }
    }

}

extension WorkSpacesThinClientClientTypes {
    public enum DeviceSoftwareSetComplianceStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case compliant
        case `none`
        case notCompliant
        case sdkUnknown(Swift.String)

        public static var allCases: [DeviceSoftwareSetComplianceStatus] {
            return [
                .compliant,
                .none,
                .notCompliant,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .compliant: return "COMPLIANT"
            case .none: return "NONE"
            case .notCompliant: return "NOT_COMPLIANT"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DeviceSoftwareSetComplianceStatus(rawValue: rawValue) ?? DeviceSoftwareSetComplianceStatus.sdkUnknown(rawValue)
        }
    }
}

extension WorkSpacesThinClientClientTypes {
    public enum DeviceStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case archived
        case deregistered
        case deregistering
        case registered
        case sdkUnknown(Swift.String)

        public static var allCases: [DeviceStatus] {
            return [
                .archived,
                .deregistered,
                .deregistering,
                .registered,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .archived: return "ARCHIVED"
            case .deregistered: return "DEREGISTERED"
            case .deregistering: return "DEREGISTERING"
            case .registered: return "REGISTERED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = DeviceStatus(rawValue: rawValue) ?? DeviceStatus.sdkUnknown(rawValue)
        }
    }
}

extension WorkSpacesThinClientClientTypes.DeviceSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case createdAt
        case currentSoftwareSetId
        case desiredSoftwareSetId
        case environmentId
        case id
        case lastConnectedAt
        case lastPostureAt
        case model
        case name
        case pendingSoftwareSetId
        case serialNumber
        case softwareSetUpdateSchedule
        case status
        case tags
        case updatedAt
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let currentSoftwareSetId = self.currentSoftwareSetId {
            try encodeContainer.encode(currentSoftwareSetId, forKey: .currentSoftwareSetId)
        }
        if let desiredSoftwareSetId = self.desiredSoftwareSetId {
            try encodeContainer.encode(desiredSoftwareSetId, forKey: .desiredSoftwareSetId)
        }
        if let environmentId = self.environmentId {
            try encodeContainer.encode(environmentId, forKey: .environmentId)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let lastConnectedAt = self.lastConnectedAt {
            try encodeContainer.encodeTimestamp(lastConnectedAt, format: .epochSeconds, forKey: .lastConnectedAt)
        }
        if let lastPostureAt = self.lastPostureAt {
            try encodeContainer.encodeTimestamp(lastPostureAt, format: .epochSeconds, forKey: .lastPostureAt)
        }
        if let model = self.model {
            try encodeContainer.encode(model, forKey: .model)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let pendingSoftwareSetId = self.pendingSoftwareSetId {
            try encodeContainer.encode(pendingSoftwareSetId, forKey: .pendingSoftwareSetId)
        }
        if let serialNumber = self.serialNumber {
            try encodeContainer.encode(serialNumber, forKey: .serialNumber)
        }
        if let softwareSetUpdateSchedule = self.softwareSetUpdateSchedule {
            try encodeContainer.encode(softwareSetUpdateSchedule.rawValue, forKey: .softwareSetUpdateSchedule)
        }
        if let status = self.status {
            try encodeContainer.encode(status.rawValue, forKey: .status)
        }
        if let tags = self.tags {
            try encodeContainer.encode(tags, forKey: .tags)
        }
        if let updatedAt = self.updatedAt {
            try encodeContainer.encodeTimestamp(updatedAt, format: .epochSeconds, forKey: .updatedAt)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let serialNumberDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serialNumber)
        serialNumber = serialNumberDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let modelDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .model)
        model = modelDecoded
        let environmentIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .environmentId)
        environmentId = environmentIdDecoded
        let statusDecoded = try containerValues.decodeIfPresent(WorkSpacesThinClientClientTypes.DeviceStatus.self, forKey: .status)
        status = statusDecoded
        let currentSoftwareSetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .currentSoftwareSetId)
        currentSoftwareSetId = currentSoftwareSetIdDecoded
        let desiredSoftwareSetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .desiredSoftwareSetId)
        desiredSoftwareSetId = desiredSoftwareSetIdDecoded
        let pendingSoftwareSetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pendingSoftwareSetId)
        pendingSoftwareSetId = pendingSoftwareSetIdDecoded
        let softwareSetUpdateScheduleDecoded = try containerValues.decodeIfPresent(WorkSpacesThinClientClientTypes.SoftwareSetUpdateSchedule.self, forKey: .softwareSetUpdateSchedule)
        softwareSetUpdateSchedule = softwareSetUpdateScheduleDecoded
        let lastConnectedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastConnectedAt)
        lastConnectedAt = lastConnectedAtDecoded
        let lastPostureAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .lastPostureAt)
        lastPostureAt = lastPostureAtDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let tagsDecoded = try containerValues.decodeIfPresent(WorkSpacesThinClientClientTypes.EmbeddedTag.self, forKey: .tags)
        tags = tagsDecoded
    }
}

extension WorkSpacesThinClientClientTypes.DeviceSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "DeviceSummary(arn: \(Swift.String(describing: arn)), createdAt: \(Swift.String(describing: createdAt)), currentSoftwareSetId: \(Swift.String(describing: currentSoftwareSetId)), desiredSoftwareSetId: \(Swift.String(describing: desiredSoftwareSetId)), environmentId: \(Swift.String(describing: environmentId)), id: \(Swift.String(describing: id)), lastConnectedAt: \(Swift.String(describing: lastConnectedAt)), lastPostureAt: \(Swift.String(describing: lastPostureAt)), model: \(Swift.String(describing: model)), pendingSoftwareSetId: \(Swift.String(describing: pendingSoftwareSetId)), serialNumber: \(Swift.String(describing: serialNumber)), softwareSetUpdateSchedule: \(Swift.String(describing: softwareSetUpdateSchedule)), status: \(Swift.String(describing: status)), updatedAt: \(Swift.String(describing: updatedAt)), name: \"CONTENT_REDACTED\", tags: \"CONTENT_REDACTED\")"}
}

extension WorkSpacesThinClientClientTypes {
    /// Describes a thin client device.
    public struct DeviceSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the device.
        public var arn: Swift.String?
        /// The timestamp of when the device was created.
        public var createdAt: ClientRuntime.Date?
        /// The ID of the software set currently installed on the device.
        public var currentSoftwareSetId: Swift.String?
        /// The ID of the software set which the device has been set to.
        public var desiredSoftwareSetId: Swift.String?
        /// The ID of the environment the device is associated with.
        public var environmentId: Swift.String?
        /// The ID of the device.
        public var id: Swift.String?
        /// The timestamp of the most recent session on the device.
        public var lastConnectedAt: ClientRuntime.Date?
        /// The timestamp of the most recent check-in of the device.
        public var lastPostureAt: ClientRuntime.Date?
        /// The model number of the device.
        public var model: Swift.String?
        /// The name of the device.
        public var name: Swift.String?
        /// The ID of the software set that is pending to be installed on the device.
        public var pendingSoftwareSetId: Swift.String?
        /// The hardware serial number of the device.
        public var serialNumber: Swift.String?
        /// An option to define if software updates should be applied within a maintenance window.
        public var softwareSetUpdateSchedule: WorkSpacesThinClientClientTypes.SoftwareSetUpdateSchedule?
        /// The status of the device.
        public var status: WorkSpacesThinClientClientTypes.DeviceStatus?
        /// The tag keys and optional values for the resource.
        public var tags: WorkSpacesThinClientClientTypes.EmbeddedTag?
        /// The timestamp of when the device was updated.
        public var updatedAt: ClientRuntime.Date?

        public init(
            arn: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            currentSoftwareSetId: Swift.String? = nil,
            desiredSoftwareSetId: Swift.String? = nil,
            environmentId: Swift.String? = nil,
            id: Swift.String? = nil,
            lastConnectedAt: ClientRuntime.Date? = nil,
            lastPostureAt: ClientRuntime.Date? = nil,
            model: Swift.String? = nil,
            name: Swift.String? = nil,
            pendingSoftwareSetId: Swift.String? = nil,
            serialNumber: Swift.String? = nil,
            softwareSetUpdateSchedule: WorkSpacesThinClientClientTypes.SoftwareSetUpdateSchedule? = nil,
            status: WorkSpacesThinClientClientTypes.DeviceStatus? = nil,
            tags: WorkSpacesThinClientClientTypes.EmbeddedTag? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.arn = arn
            self.createdAt = createdAt
            self.currentSoftwareSetId = currentSoftwareSetId
            self.desiredSoftwareSetId = desiredSoftwareSetId
            self.environmentId = environmentId
            self.id = id
            self.lastConnectedAt = lastConnectedAt
            self.lastPostureAt = lastPostureAt
            self.model = model
            self.name = name
            self.pendingSoftwareSetId = pendingSoftwareSetId
            self.serialNumber = serialNumber
            self.softwareSetUpdateSchedule = softwareSetUpdateSchedule
            self.status = status
            self.tags = tags
            self.updatedAt = updatedAt
        }
    }

}

extension WorkSpacesThinClientClientTypes.EmbeddedTag: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case internalId
        case resourceArn
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let internalId = self.internalId {
            try encodeContainer.encode(internalId, forKey: .internalId)
        }
        if let resourceArn = self.resourceArn {
            try encodeContainer.encode(resourceArn, forKey: .resourceArn)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let resourceArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceArn)
        resourceArn = resourceArnDecoded
        let internalIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .internalId)
        internalId = internalIdDecoded
    }
}

extension WorkSpacesThinClientClientTypes.EmbeddedTag: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CONTENT_REDACTED"
    }
}

extension WorkSpacesThinClientClientTypes {
    /// The resource and internal ID of a resource to tag.
    public struct EmbeddedTag: Swift.Equatable {
        /// The internal ID of a resource to tag.
        public var internalId: Swift.String?
        /// The Amazon Resource Name (ARN) of a resource to tag.
        public var resourceArn: Swift.String?

        public init(
            internalId: Swift.String? = nil,
            resourceArn: Swift.String? = nil
        )
        {
            self.internalId = internalId
            self.resourceArn = resourceArn
        }
    }

}

extension WorkSpacesThinClientClientTypes.Environment: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case activationCode
        case arn
        case createdAt
        case desiredSoftwareSetId
        case desktopArn
        case desktopEndpoint
        case desktopType
        case id
        case kmsKeyArn
        case maintenanceWindow
        case name
        case pendingSoftwareSetId
        case pendingSoftwareSetVersion
        case registeredDevicesCount
        case softwareSetComplianceStatus
        case softwareSetUpdateMode
        case softwareSetUpdateSchedule
        case tags
        case updatedAt
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let activationCode = self.activationCode {
            try encodeContainer.encode(activationCode, forKey: .activationCode)
        }
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let desiredSoftwareSetId = self.desiredSoftwareSetId {
            try encodeContainer.encode(desiredSoftwareSetId, forKey: .desiredSoftwareSetId)
        }
        if let desktopArn = self.desktopArn {
            try encodeContainer.encode(desktopArn, forKey: .desktopArn)
        }
        if let desktopEndpoint = self.desktopEndpoint {
            try encodeContainer.encode(desktopEndpoint, forKey: .desktopEndpoint)
        }
        if let desktopType = self.desktopType {
            try encodeContainer.encode(desktopType.rawValue, forKey: .desktopType)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let kmsKeyArn = self.kmsKeyArn {
            try encodeContainer.encode(kmsKeyArn, forKey: .kmsKeyArn)
        }
        if let maintenanceWindow = self.maintenanceWindow {
            try encodeContainer.encode(maintenanceWindow, forKey: .maintenanceWindow)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let pendingSoftwareSetId = self.pendingSoftwareSetId {
            try encodeContainer.encode(pendingSoftwareSetId, forKey: .pendingSoftwareSetId)
        }
        if let pendingSoftwareSetVersion = self.pendingSoftwareSetVersion {
            try encodeContainer.encode(pendingSoftwareSetVersion, forKey: .pendingSoftwareSetVersion)
        }
        if let registeredDevicesCount = self.registeredDevicesCount {
            try encodeContainer.encode(registeredDevicesCount, forKey: .registeredDevicesCount)
        }
        if let softwareSetComplianceStatus = self.softwareSetComplianceStatus {
            try encodeContainer.encode(softwareSetComplianceStatus.rawValue, forKey: .softwareSetComplianceStatus)
        }
        if let softwareSetUpdateMode = self.softwareSetUpdateMode {
            try encodeContainer.encode(softwareSetUpdateMode.rawValue, forKey: .softwareSetUpdateMode)
        }
        if let softwareSetUpdateSchedule = self.softwareSetUpdateSchedule {
            try encodeContainer.encode(softwareSetUpdateSchedule.rawValue, forKey: .softwareSetUpdateSchedule)
        }
        if let tags = self.tags {
            try encodeContainer.encode(tags, forKey: .tags)
        }
        if let updatedAt = self.updatedAt {
            try encodeContainer.encodeTimestamp(updatedAt, format: .epochSeconds, forKey: .updatedAt)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let desktopArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .desktopArn)
        desktopArn = desktopArnDecoded
        let desktopEndpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .desktopEndpoint)
        desktopEndpoint = desktopEndpointDecoded
        let desktopTypeDecoded = try containerValues.decodeIfPresent(WorkSpacesThinClientClientTypes.DesktopType.self, forKey: .desktopType)
        desktopType = desktopTypeDecoded
        let activationCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .activationCode)
        activationCode = activationCodeDecoded
        let registeredDevicesCountDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .registeredDevicesCount)
        registeredDevicesCount = registeredDevicesCountDecoded
        let softwareSetUpdateScheduleDecoded = try containerValues.decodeIfPresent(WorkSpacesThinClientClientTypes.SoftwareSetUpdateSchedule.self, forKey: .softwareSetUpdateSchedule)
        softwareSetUpdateSchedule = softwareSetUpdateScheduleDecoded
        let maintenanceWindowDecoded = try containerValues.decodeIfPresent(WorkSpacesThinClientClientTypes.MaintenanceWindow.self, forKey: .maintenanceWindow)
        maintenanceWindow = maintenanceWindowDecoded
        let softwareSetUpdateModeDecoded = try containerValues.decodeIfPresent(WorkSpacesThinClientClientTypes.SoftwareSetUpdateMode.self, forKey: .softwareSetUpdateMode)
        softwareSetUpdateMode = softwareSetUpdateModeDecoded
        let desiredSoftwareSetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .desiredSoftwareSetId)
        desiredSoftwareSetId = desiredSoftwareSetIdDecoded
        let pendingSoftwareSetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pendingSoftwareSetId)
        pendingSoftwareSetId = pendingSoftwareSetIdDecoded
        let pendingSoftwareSetVersionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pendingSoftwareSetVersion)
        pendingSoftwareSetVersion = pendingSoftwareSetVersionDecoded
        let softwareSetComplianceStatusDecoded = try containerValues.decodeIfPresent(WorkSpacesThinClientClientTypes.EnvironmentSoftwareSetComplianceStatus.self, forKey: .softwareSetComplianceStatus)
        softwareSetComplianceStatus = softwareSetComplianceStatusDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let kmsKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyArn)
        kmsKeyArn = kmsKeyArnDecoded
        let tagsDecoded = try containerValues.decodeIfPresent(WorkSpacesThinClientClientTypes.EmbeddedTag.self, forKey: .tags)
        tags = tagsDecoded
    }
}

extension WorkSpacesThinClientClientTypes.Environment: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "Environment(activationCode: \(Swift.String(describing: activationCode)), arn: \(Swift.String(describing: arn)), createdAt: \(Swift.String(describing: createdAt)), desiredSoftwareSetId: \(Swift.String(describing: desiredSoftwareSetId)), desktopArn: \(Swift.String(describing: desktopArn)), desktopType: \(Swift.String(describing: desktopType)), id: \(Swift.String(describing: id)), kmsKeyArn: \(Swift.String(describing: kmsKeyArn)), maintenanceWindow: \(Swift.String(describing: maintenanceWindow)), pendingSoftwareSetId: \(Swift.String(describing: pendingSoftwareSetId)), pendingSoftwareSetVersion: \(Swift.String(describing: pendingSoftwareSetVersion)), registeredDevicesCount: \(Swift.String(describing: registeredDevicesCount)), softwareSetComplianceStatus: \(Swift.String(describing: softwareSetComplianceStatus)), softwareSetUpdateMode: \(Swift.String(describing: softwareSetUpdateMode)), softwareSetUpdateSchedule: \(Swift.String(describing: softwareSetUpdateSchedule)), updatedAt: \(Swift.String(describing: updatedAt)), desktopEndpoint: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\", tags: \"CONTENT_REDACTED\")"}
}

extension WorkSpacesThinClientClientTypes {
    /// Describes an environment.
    public struct Environment: Swift.Equatable {
        /// The activation code to register a device to the environment.
        public var activationCode: Swift.String?
        /// The Amazon Resource Name (ARN) of the environment.
        public var arn: Swift.String?
        /// The timestamp of when the environment was created.
        public var createdAt: ClientRuntime.Date?
        /// The ID of the software set to apply.
        public var desiredSoftwareSetId: Swift.String?
        /// The Amazon Resource Name (ARN) of the desktop to stream from Amazon WorkSpaces, WorkSpaces Web, or AppStream 2.0.
        public var desktopArn: Swift.String?
        /// The URL for the identity provider login (only for environments that use AppStream 2.0).
        public var desktopEndpoint: Swift.String?
        /// The type of streaming desktop for the environment.
        public var desktopType: WorkSpacesThinClientClientTypes.DesktopType?
        /// The ID of the environment.
        public var id: Swift.String?
        /// The Amazon Resource Name (ARN) of the Key Management Service key used to encrypt the environment.
        public var kmsKeyArn: Swift.String?
        /// A specification for a time window to apply software updates.
        public var maintenanceWindow: WorkSpacesThinClientClientTypes.MaintenanceWindow?
        /// The name of the environment.
        public var name: Swift.String?
        /// The ID of the software set that is pending to be installed.
        public var pendingSoftwareSetId: Swift.String?
        /// The version of the software set that is pending to be installed.
        public var pendingSoftwareSetVersion: Swift.String?
        /// The number of devices registered to the environment.
        public var registeredDevicesCount: Swift.Int?
        /// Describes if the software currently installed on all devices in the environment is a supported version.
        public var softwareSetComplianceStatus: WorkSpacesThinClientClientTypes.EnvironmentSoftwareSetComplianceStatus?
        /// An option to define which software updates to apply.
        public var softwareSetUpdateMode: WorkSpacesThinClientClientTypes.SoftwareSetUpdateMode?
        /// An option to define if software updates should be applied within a maintenance window.
        public var softwareSetUpdateSchedule: WorkSpacesThinClientClientTypes.SoftwareSetUpdateSchedule?
        /// The tag keys and optional values for the resource.
        public var tags: WorkSpacesThinClientClientTypes.EmbeddedTag?
        /// The timestamp of when the device was updated.
        public var updatedAt: ClientRuntime.Date?

        public init(
            activationCode: Swift.String? = nil,
            arn: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            desiredSoftwareSetId: Swift.String? = nil,
            desktopArn: Swift.String? = nil,
            desktopEndpoint: Swift.String? = nil,
            desktopType: WorkSpacesThinClientClientTypes.DesktopType? = nil,
            id: Swift.String? = nil,
            kmsKeyArn: Swift.String? = nil,
            maintenanceWindow: WorkSpacesThinClientClientTypes.MaintenanceWindow? = nil,
            name: Swift.String? = nil,
            pendingSoftwareSetId: Swift.String? = nil,
            pendingSoftwareSetVersion: Swift.String? = nil,
            registeredDevicesCount: Swift.Int? = nil,
            softwareSetComplianceStatus: WorkSpacesThinClientClientTypes.EnvironmentSoftwareSetComplianceStatus? = nil,
            softwareSetUpdateMode: WorkSpacesThinClientClientTypes.SoftwareSetUpdateMode? = nil,
            softwareSetUpdateSchedule: WorkSpacesThinClientClientTypes.SoftwareSetUpdateSchedule? = nil,
            tags: WorkSpacesThinClientClientTypes.EmbeddedTag? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.activationCode = activationCode
            self.arn = arn
            self.createdAt = createdAt
            self.desiredSoftwareSetId = desiredSoftwareSetId
            self.desktopArn = desktopArn
            self.desktopEndpoint = desktopEndpoint
            self.desktopType = desktopType
            self.id = id
            self.kmsKeyArn = kmsKeyArn
            self.maintenanceWindow = maintenanceWindow
            self.name = name
            self.pendingSoftwareSetId = pendingSoftwareSetId
            self.pendingSoftwareSetVersion = pendingSoftwareSetVersion
            self.registeredDevicesCount = registeredDevicesCount
            self.softwareSetComplianceStatus = softwareSetComplianceStatus
            self.softwareSetUpdateMode = softwareSetUpdateMode
            self.softwareSetUpdateSchedule = softwareSetUpdateSchedule
            self.tags = tags
            self.updatedAt = updatedAt
        }
    }

}

extension WorkSpacesThinClientClientTypes {
    public enum EnvironmentSoftwareSetComplianceStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case compliant
        case notCompliant
        case noRegisteredDevices
        case sdkUnknown(Swift.String)

        public static var allCases: [EnvironmentSoftwareSetComplianceStatus] {
            return [
                .compliant,
                .notCompliant,
                .noRegisteredDevices,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .compliant: return "COMPLIANT"
            case .notCompliant: return "NOT_COMPLIANT"
            case .noRegisteredDevices: return "NO_REGISTERED_DEVICES"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = EnvironmentSoftwareSetComplianceStatus(rawValue: rawValue) ?? EnvironmentSoftwareSetComplianceStatus.sdkUnknown(rawValue)
        }
    }
}

extension WorkSpacesThinClientClientTypes.EnvironmentSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case activationCode
        case arn
        case createdAt
        case desiredSoftwareSetId
        case desktopArn
        case desktopEndpoint
        case desktopType
        case id
        case maintenanceWindow
        case name
        case pendingSoftwareSetId
        case softwareSetUpdateMode
        case softwareSetUpdateSchedule
        case tags
        case updatedAt
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let activationCode = self.activationCode {
            try encodeContainer.encode(activationCode, forKey: .activationCode)
        }
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let createdAt = self.createdAt {
            try encodeContainer.encodeTimestamp(createdAt, format: .epochSeconds, forKey: .createdAt)
        }
        if let desiredSoftwareSetId = self.desiredSoftwareSetId {
            try encodeContainer.encode(desiredSoftwareSetId, forKey: .desiredSoftwareSetId)
        }
        if let desktopArn = self.desktopArn {
            try encodeContainer.encode(desktopArn, forKey: .desktopArn)
        }
        if let desktopEndpoint = self.desktopEndpoint {
            try encodeContainer.encode(desktopEndpoint, forKey: .desktopEndpoint)
        }
        if let desktopType = self.desktopType {
            try encodeContainer.encode(desktopType.rawValue, forKey: .desktopType)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let maintenanceWindow = self.maintenanceWindow {
            try encodeContainer.encode(maintenanceWindow, forKey: .maintenanceWindow)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let pendingSoftwareSetId = self.pendingSoftwareSetId {
            try encodeContainer.encode(pendingSoftwareSetId, forKey: .pendingSoftwareSetId)
        }
        if let softwareSetUpdateMode = self.softwareSetUpdateMode {
            try encodeContainer.encode(softwareSetUpdateMode.rawValue, forKey: .softwareSetUpdateMode)
        }
        if let softwareSetUpdateSchedule = self.softwareSetUpdateSchedule {
            try encodeContainer.encode(softwareSetUpdateSchedule.rawValue, forKey: .softwareSetUpdateSchedule)
        }
        if let tags = self.tags {
            try encodeContainer.encode(tags, forKey: .tags)
        }
        if let updatedAt = self.updatedAt {
            try encodeContainer.encodeTimestamp(updatedAt, format: .epochSeconds, forKey: .updatedAt)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let desktopArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .desktopArn)
        desktopArn = desktopArnDecoded
        let desktopEndpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .desktopEndpoint)
        desktopEndpoint = desktopEndpointDecoded
        let desktopTypeDecoded = try containerValues.decodeIfPresent(WorkSpacesThinClientClientTypes.DesktopType.self, forKey: .desktopType)
        desktopType = desktopTypeDecoded
        let activationCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .activationCode)
        activationCode = activationCodeDecoded
        let softwareSetUpdateScheduleDecoded = try containerValues.decodeIfPresent(WorkSpacesThinClientClientTypes.SoftwareSetUpdateSchedule.self, forKey: .softwareSetUpdateSchedule)
        softwareSetUpdateSchedule = softwareSetUpdateScheduleDecoded
        let maintenanceWindowDecoded = try containerValues.decodeIfPresent(WorkSpacesThinClientClientTypes.MaintenanceWindow.self, forKey: .maintenanceWindow)
        maintenanceWindow = maintenanceWindowDecoded
        let softwareSetUpdateModeDecoded = try containerValues.decodeIfPresent(WorkSpacesThinClientClientTypes.SoftwareSetUpdateMode.self, forKey: .softwareSetUpdateMode)
        softwareSetUpdateMode = softwareSetUpdateModeDecoded
        let desiredSoftwareSetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .desiredSoftwareSetId)
        desiredSoftwareSetId = desiredSoftwareSetIdDecoded
        let pendingSoftwareSetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .pendingSoftwareSetId)
        pendingSoftwareSetId = pendingSoftwareSetIdDecoded
        let createdAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .createdAt)
        createdAt = createdAtDecoded
        let updatedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .updatedAt)
        updatedAt = updatedAtDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
        let tagsDecoded = try containerValues.decodeIfPresent(WorkSpacesThinClientClientTypes.EmbeddedTag.self, forKey: .tags)
        tags = tagsDecoded
    }
}

extension WorkSpacesThinClientClientTypes.EnvironmentSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "EnvironmentSummary(activationCode: \(Swift.String(describing: activationCode)), arn: \(Swift.String(describing: arn)), createdAt: \(Swift.String(describing: createdAt)), desiredSoftwareSetId: \(Swift.String(describing: desiredSoftwareSetId)), desktopArn: \(Swift.String(describing: desktopArn)), desktopType: \(Swift.String(describing: desktopType)), id: \(Swift.String(describing: id)), maintenanceWindow: \(Swift.String(describing: maintenanceWindow)), pendingSoftwareSetId: \(Swift.String(describing: pendingSoftwareSetId)), softwareSetUpdateMode: \(Swift.String(describing: softwareSetUpdateMode)), softwareSetUpdateSchedule: \(Swift.String(describing: softwareSetUpdateSchedule)), updatedAt: \(Swift.String(describing: updatedAt)), desktopEndpoint: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\", tags: \"CONTENT_REDACTED\")"}
}

extension WorkSpacesThinClientClientTypes {
    /// Describes an environment.
    public struct EnvironmentSummary: Swift.Equatable {
        /// The activation code to register a device to the environment.
        public var activationCode: Swift.String?
        /// The Amazon Resource Name (ARN) of the environment.
        public var arn: Swift.String?
        /// The timestamp of when the environment was created.
        public var createdAt: ClientRuntime.Date?
        /// The ID of the software set to apply.
        public var desiredSoftwareSetId: Swift.String?
        /// The Amazon Resource Name (ARN) of the desktop to stream from Amazon WorkSpaces, WorkSpaces Web, or AppStream 2.0.
        public var desktopArn: Swift.String?
        /// The URL for the identity provider login (only for environments that use AppStream 2.0).
        public var desktopEndpoint: Swift.String?
        /// The type of streaming desktop for the environment.
        public var desktopType: WorkSpacesThinClientClientTypes.DesktopType?
        /// The ID of the environment.
        public var id: Swift.String?
        /// A specification for a time window to apply software updates.
        public var maintenanceWindow: WorkSpacesThinClientClientTypes.MaintenanceWindow?
        /// The name of the environment.
        public var name: Swift.String?
        /// The ID of the software set that is pending to be installed.
        public var pendingSoftwareSetId: Swift.String?
        /// An option to define which software updates to apply.
        public var softwareSetUpdateMode: WorkSpacesThinClientClientTypes.SoftwareSetUpdateMode?
        /// An option to define if software updates should be applied within a maintenance window.
        public var softwareSetUpdateSchedule: WorkSpacesThinClientClientTypes.SoftwareSetUpdateSchedule?
        /// The tag keys and optional values for the resource.
        public var tags: WorkSpacesThinClientClientTypes.EmbeddedTag?
        /// The timestamp of when the device was updated.
        public var updatedAt: ClientRuntime.Date?

        public init(
            activationCode: Swift.String? = nil,
            arn: Swift.String? = nil,
            createdAt: ClientRuntime.Date? = nil,
            desiredSoftwareSetId: Swift.String? = nil,
            desktopArn: Swift.String? = nil,
            desktopEndpoint: Swift.String? = nil,
            desktopType: WorkSpacesThinClientClientTypes.DesktopType? = nil,
            id: Swift.String? = nil,
            maintenanceWindow: WorkSpacesThinClientClientTypes.MaintenanceWindow? = nil,
            name: Swift.String? = nil,
            pendingSoftwareSetId: Swift.String? = nil,
            softwareSetUpdateMode: WorkSpacesThinClientClientTypes.SoftwareSetUpdateMode? = nil,
            softwareSetUpdateSchedule: WorkSpacesThinClientClientTypes.SoftwareSetUpdateSchedule? = nil,
            tags: WorkSpacesThinClientClientTypes.EmbeddedTag? = nil,
            updatedAt: ClientRuntime.Date? = nil
        )
        {
            self.activationCode = activationCode
            self.arn = arn
            self.createdAt = createdAt
            self.desiredSoftwareSetId = desiredSoftwareSetId
            self.desktopArn = desktopArn
            self.desktopEndpoint = desktopEndpoint
            self.desktopType = desktopType
            self.id = id
            self.maintenanceWindow = maintenanceWindow
            self.name = name
            self.pendingSoftwareSetId = pendingSoftwareSetId
            self.softwareSetUpdateMode = softwareSetUpdateMode
            self.softwareSetUpdateSchedule = softwareSetUpdateSchedule
            self.tags = tags
            self.updatedAt = updatedAt
        }
    }

}

extension GetDeviceInput {

    static func urlPathProvider(_ value: GetDeviceInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/devices/\(id.urlPercentEncoding())"
    }
}

public struct GetDeviceInput: Swift.Equatable {
    /// The ID of the device for which to return information.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct GetDeviceInputBody: Swift.Equatable {
}

extension GetDeviceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetDeviceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetDeviceOutputBody = try responseDecoder.decode(responseBody: data)
            self.device = output.device
        } else {
            self.device = nil
        }
    }
}

public struct GetDeviceOutput: Swift.Equatable {
    /// Describes an device.
    public var device: WorkSpacesThinClientClientTypes.Device?

    public init(
        device: WorkSpacesThinClientClientTypes.Device? = nil
    )
    {
        self.device = device
    }
}

struct GetDeviceOutputBody: Swift.Equatable {
    let device: WorkSpacesThinClientClientTypes.Device?
}

extension GetDeviceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case device
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceDecoded = try containerValues.decodeIfPresent(WorkSpacesThinClientClientTypes.Device.self, forKey: .device)
        device = deviceDecoded
    }
}

enum GetDeviceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetEnvironmentInput {

    static func urlPathProvider(_ value: GetEnvironmentInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/environments/\(id.urlPercentEncoding())"
    }
}

public struct GetEnvironmentInput: Swift.Equatable {
    /// The ID of the environment for which to return information.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct GetEnvironmentInputBody: Swift.Equatable {
}

extension GetEnvironmentInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetEnvironmentOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetEnvironmentOutputBody = try responseDecoder.decode(responseBody: data)
            self.environment = output.environment
        } else {
            self.environment = nil
        }
    }
}

public struct GetEnvironmentOutput: Swift.Equatable {
    /// Describes an environment.
    public var environment: WorkSpacesThinClientClientTypes.Environment?

    public init(
        environment: WorkSpacesThinClientClientTypes.Environment? = nil
    )
    {
        self.environment = environment
    }
}

struct GetEnvironmentOutputBody: Swift.Equatable {
    let environment: WorkSpacesThinClientClientTypes.Environment?
}

extension GetEnvironmentOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case environment
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let environmentDecoded = try containerValues.decodeIfPresent(WorkSpacesThinClientClientTypes.Environment.self, forKey: .environment)
        environment = environmentDecoded
    }
}

enum GetEnvironmentOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension GetSoftwareSetInput {

    static func urlPathProvider(_ value: GetSoftwareSetInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/softwaresets/\(id.urlPercentEncoding())"
    }
}

public struct GetSoftwareSetInput: Swift.Equatable {
    /// The ID of the software set for which to return information.
    /// This member is required.
    public var id: Swift.String?

    public init(
        id: Swift.String? = nil
    )
    {
        self.id = id
    }
}

struct GetSoftwareSetInputBody: Swift.Equatable {
}

extension GetSoftwareSetInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension GetSoftwareSetOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: GetSoftwareSetOutputBody = try responseDecoder.decode(responseBody: data)
            self.softwareSet = output.softwareSet
        } else {
            self.softwareSet = nil
        }
    }
}

public struct GetSoftwareSetOutput: Swift.Equatable {
    /// Describes a software set.
    public var softwareSet: WorkSpacesThinClientClientTypes.SoftwareSet?

    public init(
        softwareSet: WorkSpacesThinClientClientTypes.SoftwareSet? = nil
    )
    {
        self.softwareSet = softwareSet
    }
}

struct GetSoftwareSetOutputBody: Swift.Equatable {
    let softwareSet: WorkSpacesThinClientClientTypes.SoftwareSet?
}

extension GetSoftwareSetOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case softwareSet
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let softwareSetDecoded = try containerValues.decodeIfPresent(WorkSpacesThinClientClientTypes.SoftwareSet.self, forKey: .softwareSet)
        softwareSet = softwareSetDecoded
    }
}

enum GetSoftwareSetOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension InternalServerException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            self.properties.retryAfterSeconds = Swift.Int(retryAfterSecondsHeaderValue) ?? 0
        } else {
            self.properties.retryAfterSeconds = nil
        }
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InternalServerExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The server encountered an internal error and is unable to complete the request.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        /// The number of seconds to wait before retrying the next request.
        public internal(set) var retryAfterSeconds: Swift.Int? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        retryAfterSeconds: Swift.Int? = nil
    )
    {
        self.properties.message = message
        self.properties.retryAfterSeconds = retryAfterSeconds
    }
}

struct InternalServerExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServerExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension InternalServiceException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            self.properties.retryAfterSeconds = Swift.Int(retryAfterSecondsHeaderValue) ?? 0
        } else {
            self.properties.retryAfterSeconds = nil
        }
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: InternalServiceExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
        } else {
            self.properties.message = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Request processing failed due to some unknown error, exception, or failure.
public struct InternalServiceException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        /// The number of seconds to wait before retrying the next request.
        public internal(set) var retryAfterSeconds: Swift.Int? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServiceException" }
    public static var fault: ErrorFault { .server }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        retryAfterSeconds: Swift.Int? = nil
    )
    {
        self.properties.message = message
        self.properties.retryAfterSeconds = retryAfterSeconds
    }
}

struct InternalServiceExceptionBody: Swift.Equatable {
    let message: Swift.String?
}

extension InternalServiceExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension ListDevicesInput {

    static func queryItemProvider(_ value: ListDevicesInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListDevicesInput {

    static func urlPathProvider(_ value: ListDevicesInput) -> Swift.String? {
        return "/devices"
    }
}

public struct ListDevicesInput: Swift.Equatable {
    /// The maximum number of results that are returned per call. You can use nextToken to obtain further pages of results. This is only an upper limit. The actual number of results returned per call might be fewer than the specified maximum.
    public var maxResults: Swift.Int?
    /// If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires after 24 hours. Using an expired pagination token will return an HTTP 400 InvalidToken error.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListDevicesInputBody: Swift.Equatable {
}

extension ListDevicesInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListDevicesOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListDevicesOutputBody = try responseDecoder.decode(responseBody: data)
            self.devices = output.devices
            self.nextToken = output.nextToken
        } else {
            self.devices = nil
            self.nextToken = nil
        }
    }
}

public struct ListDevicesOutput: Swift.Equatable {
    /// Describes devices.
    public var devices: [WorkSpacesThinClientClientTypes.DeviceSummary]?
    /// If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires after 24 hours. Using an expired pagination token will return an HTTP 400 InvalidToken error.
    public var nextToken: Swift.String?

    public init(
        devices: [WorkSpacesThinClientClientTypes.DeviceSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.devices = devices
        self.nextToken = nextToken
    }
}

struct ListDevicesOutputBody: Swift.Equatable {
    let devices: [WorkSpacesThinClientClientTypes.DeviceSummary]?
    let nextToken: Swift.String?
}

extension ListDevicesOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case devices
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let devicesContainer = try containerValues.decodeIfPresent([WorkSpacesThinClientClientTypes.DeviceSummary?].self, forKey: .devices)
        var devicesDecoded0:[WorkSpacesThinClientClientTypes.DeviceSummary]? = nil
        if let devicesContainer = devicesContainer {
            devicesDecoded0 = [WorkSpacesThinClientClientTypes.DeviceSummary]()
            for structure0 in devicesContainer {
                if let structure0 = structure0 {
                    devicesDecoded0?.append(structure0)
                }
            }
        }
        devices = devicesDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListDevicesOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListEnvironmentsInput {

    static func queryItemProvider(_ value: ListEnvironmentsInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListEnvironmentsInput {

    static func urlPathProvider(_ value: ListEnvironmentsInput) -> Swift.String? {
        return "/environments"
    }
}

public struct ListEnvironmentsInput: Swift.Equatable {
    /// The maximum number of results that are returned per call. You can use nextToken to obtain further pages of results. This is only an upper limit. The actual number of results returned per call might be fewer than the specified maximum.
    public var maxResults: Swift.Int?
    /// If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires after 24 hours. Using an expired pagination token will return an HTTP 400 InvalidToken error.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListEnvironmentsInputBody: Swift.Equatable {
}

extension ListEnvironmentsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListEnvironmentsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListEnvironmentsOutputBody = try responseDecoder.decode(responseBody: data)
            self.environments = output.environments
            self.nextToken = output.nextToken
        } else {
            self.environments = nil
            self.nextToken = nil
        }
    }
}

public struct ListEnvironmentsOutput: Swift.Equatable {
    /// Describes environments.
    public var environments: [WorkSpacesThinClientClientTypes.EnvironmentSummary]?
    /// If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires after 24 hours. Using an expired pagination token will return an HTTP 400 InvalidToken error.
    public var nextToken: Swift.String?

    public init(
        environments: [WorkSpacesThinClientClientTypes.EnvironmentSummary]? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.environments = environments
        self.nextToken = nextToken
    }
}

struct ListEnvironmentsOutputBody: Swift.Equatable {
    let environments: [WorkSpacesThinClientClientTypes.EnvironmentSummary]?
    let nextToken: Swift.String?
}

extension ListEnvironmentsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case environments
        case nextToken
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let environmentsContainer = try containerValues.decodeIfPresent([WorkSpacesThinClientClientTypes.EnvironmentSummary?].self, forKey: .environments)
        var environmentsDecoded0:[WorkSpacesThinClientClientTypes.EnvironmentSummary]? = nil
        if let environmentsContainer = environmentsContainer {
            environmentsDecoded0 = [WorkSpacesThinClientClientTypes.EnvironmentSummary]()
            for structure0 in environmentsContainer {
                if let structure0 = structure0 {
                    environmentsDecoded0?.append(structure0)
                }
            }
        }
        environments = environmentsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListEnvironmentsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListSoftwareSetsInput {

    static func queryItemProvider(_ value: ListSoftwareSetsInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        if let nextToken = value.nextToken {
            let nextTokenQueryItem = ClientRuntime.SDKURLQueryItem(name: "nextToken".urlPercentEncoding(), value: Swift.String(nextToken).urlPercentEncoding())
            items.append(nextTokenQueryItem)
        }
        if let maxResults = value.maxResults {
            let maxResultsQueryItem = ClientRuntime.SDKURLQueryItem(name: "maxResults".urlPercentEncoding(), value: Swift.String(maxResults).urlPercentEncoding())
            items.append(maxResultsQueryItem)
        }
        return items
    }
}

extension ListSoftwareSetsInput {

    static func urlPathProvider(_ value: ListSoftwareSetsInput) -> Swift.String? {
        return "/softwaresets"
    }
}

public struct ListSoftwareSetsInput: Swift.Equatable {
    /// The maximum number of results that are returned per call. You can use nextToken to obtain further pages of results. This is only an upper limit. The actual number of results returned per call might be fewer than the specified maximum.
    public var maxResults: Swift.Int?
    /// If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires after 24 hours. Using an expired pagination token will return an HTTP 400 InvalidToken error.
    public var nextToken: Swift.String?

    public init(
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil
    )
    {
        self.maxResults = maxResults
        self.nextToken = nextToken
    }
}

struct ListSoftwareSetsInputBody: Swift.Equatable {
}

extension ListSoftwareSetsInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListSoftwareSetsOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListSoftwareSetsOutputBody = try responseDecoder.decode(responseBody: data)
            self.nextToken = output.nextToken
            self.softwareSets = output.softwareSets
        } else {
            self.nextToken = nil
            self.softwareSets = nil
        }
    }
}

public struct ListSoftwareSetsOutput: Swift.Equatable {
    /// If nextToken is returned, there are more results available. The value of nextToken is a unique pagination token for each page. Make the call again using the returned token to retrieve the next page. Keep all other arguments unchanged. Each pagination token expires after 24 hours. Using an expired pagination token will return an HTTP 400 InvalidToken error.
    public var nextToken: Swift.String?
    /// Describes software sets.
    public var softwareSets: [WorkSpacesThinClientClientTypes.SoftwareSetSummary]?

    public init(
        nextToken: Swift.String? = nil,
        softwareSets: [WorkSpacesThinClientClientTypes.SoftwareSetSummary]? = nil
    )
    {
        self.nextToken = nextToken
        self.softwareSets = softwareSets
    }
}

struct ListSoftwareSetsOutputBody: Swift.Equatable {
    let softwareSets: [WorkSpacesThinClientClientTypes.SoftwareSetSummary]?
    let nextToken: Swift.String?
}

extension ListSoftwareSetsOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case nextToken
        case softwareSets
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let softwareSetsContainer = try containerValues.decodeIfPresent([WorkSpacesThinClientClientTypes.SoftwareSetSummary?].self, forKey: .softwareSets)
        var softwareSetsDecoded0:[WorkSpacesThinClientClientTypes.SoftwareSetSummary]? = nil
        if let softwareSetsContainer = softwareSetsContainer {
            softwareSetsDecoded0 = [WorkSpacesThinClientClientTypes.SoftwareSetSummary]()
            for structure0 in softwareSetsContainer {
                if let structure0 = structure0 {
                    softwareSetsDecoded0?.append(structure0)
                }
            }
        }
        softwareSets = softwareSetsDecoded0
        let nextTokenDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .nextToken)
        nextToken = nextTokenDecoded
    }
}

enum ListSoftwareSetsOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct ListTagsForResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource for which you want to retrieve tags.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    )
    {
        self.resourceArn = resourceArn
    }
}

struct ListTagsForResourceInputBody: Swift.Equatable {
}

extension ListTagsForResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension ListTagsForResourceOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ListTagsForResourceOutput(tags: \"CONTENT_REDACTED\")"}
}

extension ListTagsForResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ListTagsForResourceOutputBody = try responseDecoder.decode(responseBody: data)
            self.tags = output.tags
        } else {
            self.tags = nil
        }
    }
}

public struct ListTagsForResourceOutput: Swift.Equatable {
    /// A map of the key-value pairs for the tag or tags assigned to the specified resource.
    public var tags: [Swift.String:Swift.String]?

    public init(
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.tags = tags
    }
}

struct ListTagsForResourceOutputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension ListTagsForResourceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

enum ListTagsForResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension WorkSpacesThinClientClientTypes.MaintenanceWindow: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case applyTimeOf
        case daysOfTheWeek
        case endTimeHour
        case endTimeMinute
        case startTimeHour
        case startTimeMinute
        case type
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let applyTimeOf = self.applyTimeOf {
            try encodeContainer.encode(applyTimeOf.rawValue, forKey: .applyTimeOf)
        }
        if let daysOfTheWeek = daysOfTheWeek {
            var daysOfTheWeekContainer = encodeContainer.nestedUnkeyedContainer(forKey: .daysOfTheWeek)
            for dayofweek0 in daysOfTheWeek {
                try daysOfTheWeekContainer.encode(dayofweek0.rawValue)
            }
        }
        if let endTimeHour = self.endTimeHour {
            try encodeContainer.encode(endTimeHour, forKey: .endTimeHour)
        }
        if let endTimeMinute = self.endTimeMinute {
            try encodeContainer.encode(endTimeMinute, forKey: .endTimeMinute)
        }
        if let startTimeHour = self.startTimeHour {
            try encodeContainer.encode(startTimeHour, forKey: .startTimeHour)
        }
        if let startTimeMinute = self.startTimeMinute {
            try encodeContainer.encode(startTimeMinute, forKey: .startTimeMinute)
        }
        if let type = self.type {
            try encodeContainer.encode(type.rawValue, forKey: .type)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let typeDecoded = try containerValues.decodeIfPresent(WorkSpacesThinClientClientTypes.MaintenanceWindowType.self, forKey: .type)
        type = typeDecoded
        let startTimeHourDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .startTimeHour)
        startTimeHour = startTimeHourDecoded
        let startTimeMinuteDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .startTimeMinute)
        startTimeMinute = startTimeMinuteDecoded
        let endTimeHourDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .endTimeHour)
        endTimeHour = endTimeHourDecoded
        let endTimeMinuteDecoded = try containerValues.decodeIfPresent(Swift.Int.self, forKey: .endTimeMinute)
        endTimeMinute = endTimeMinuteDecoded
        let daysOfTheWeekContainer = try containerValues.decodeIfPresent([WorkSpacesThinClientClientTypes.DayOfWeek?].self, forKey: .daysOfTheWeek)
        var daysOfTheWeekDecoded0:[WorkSpacesThinClientClientTypes.DayOfWeek]? = nil
        if let daysOfTheWeekContainer = daysOfTheWeekContainer {
            daysOfTheWeekDecoded0 = [WorkSpacesThinClientClientTypes.DayOfWeek]()
            for enum0 in daysOfTheWeekContainer {
                if let enum0 = enum0 {
                    daysOfTheWeekDecoded0?.append(enum0)
                }
            }
        }
        daysOfTheWeek = daysOfTheWeekDecoded0
        let applyTimeOfDecoded = try containerValues.decodeIfPresent(WorkSpacesThinClientClientTypes.ApplyTimeOf.self, forKey: .applyTimeOf)
        applyTimeOf = applyTimeOfDecoded
    }
}

extension WorkSpacesThinClientClientTypes {
    /// Describes the maintenance window for a thin client device.
    public struct MaintenanceWindow: Swift.Equatable {
        /// The option to set the maintenance window during the device local time or Universal Coordinated Time (UTC).
        public var applyTimeOf: WorkSpacesThinClientClientTypes.ApplyTimeOf?
        /// The days of the week during which the maintenance window is open.
        public var daysOfTheWeek: [WorkSpacesThinClientClientTypes.DayOfWeek]?
        /// The hour for the maintenance window end (00-23).
        public var endTimeHour: Swift.Int?
        /// The minutes for the maintenance window end (00-59).
        public var endTimeMinute: Swift.Int?
        /// The hour for the maintenance window start (00-23).
        public var startTimeHour: Swift.Int?
        /// The minutes past the hour for the maintenance window start (00-59).
        public var startTimeMinute: Swift.Int?
        /// An option to select the default or custom maintenance window.
        public var type: WorkSpacesThinClientClientTypes.MaintenanceWindowType?

        public init(
            applyTimeOf: WorkSpacesThinClientClientTypes.ApplyTimeOf? = nil,
            daysOfTheWeek: [WorkSpacesThinClientClientTypes.DayOfWeek]? = nil,
            endTimeHour: Swift.Int? = nil,
            endTimeMinute: Swift.Int? = nil,
            startTimeHour: Swift.Int? = nil,
            startTimeMinute: Swift.Int? = nil,
            type: WorkSpacesThinClientClientTypes.MaintenanceWindowType? = nil
        )
        {
            self.applyTimeOf = applyTimeOf
            self.daysOfTheWeek = daysOfTheWeek
            self.endTimeHour = endTimeHour
            self.endTimeMinute = endTimeMinute
            self.startTimeHour = startTimeHour
            self.startTimeMinute = startTimeMinute
            self.type = type
        }
    }

}

extension WorkSpacesThinClientClientTypes {
    public enum MaintenanceWindowType: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case custom
        case system
        case sdkUnknown(Swift.String)

        public static var allCases: [MaintenanceWindowType] {
            return [
                .custom,
                .system,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .custom: return "CUSTOM"
            case .system: return "SYSTEM"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = MaintenanceWindowType(rawValue: rawValue) ?? MaintenanceWindowType.sdkUnknown(rawValue)
        }
    }
}

extension ResourceNotFoundException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ResourceNotFoundExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.resourceId = output.resourceId
            self.properties.resourceType = output.resourceType
        } else {
            self.properties.message = nil
            self.properties.resourceId = nil
            self.properties.resourceType = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The resource specified in the request was not found.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        /// The ID of the resource associated with the request.
        public internal(set) var resourceId: Swift.String? = nil
        /// The type of the resource associated with the request.
        public internal(set) var resourceType: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
    }
}

struct ResourceNotFoundExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceId: Swift.String?
    let resourceType: Swift.String?
}

extension ResourceNotFoundExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case resourceId
        case resourceType
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
    }
}

extension ServiceQuotaExceededException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ServiceQuotaExceededExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.quotaCode = output.quotaCode
            self.properties.resourceId = output.resourceId
            self.properties.resourceType = output.resourceType
            self.properties.serviceCode = output.serviceCode
        } else {
            self.properties.message = nil
            self.properties.quotaCode = nil
            self.properties.resourceId = nil
            self.properties.resourceType = nil
            self.properties.serviceCode = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// Your request exceeds a service quota.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        /// The code for the quota in [Service Quotas](https://docs.aws.amazon.com/servicequotas/latest/userguide/intro.html).
        public internal(set) var quotaCode: Swift.String? = nil
        /// The ID of the resource that exceeds the service quota.
        public internal(set) var resourceId: Swift.String? = nil
        /// The type of the resource that exceeds the service quota.
        public internal(set) var resourceType: Swift.String? = nil
        /// The code for the service in [Service Quotas](https://docs.aws.amazon.com/servicequotas/latest/userguide/intro.html).
        public internal(set) var serviceCode: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        quotaCode: Swift.String? = nil,
        resourceId: Swift.String? = nil,
        resourceType: Swift.String? = nil,
        serviceCode: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.quotaCode = quotaCode
        self.properties.resourceId = resourceId
        self.properties.resourceType = resourceType
        self.properties.serviceCode = serviceCode
    }
}

struct ServiceQuotaExceededExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let resourceId: Swift.String?
    let resourceType: Swift.String?
    let serviceCode: Swift.String?
    let quotaCode: Swift.String?
}

extension ServiceQuotaExceededExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case quotaCode
        case resourceId
        case resourceType
        case serviceCode
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let resourceIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceId)
        resourceId = resourceIdDecoded
        let resourceTypeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .resourceType)
        resourceType = resourceTypeDecoded
        let serviceCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
        let quotaCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .quotaCode)
        quotaCode = quotaCodeDecoded
    }
}

extension WorkSpacesThinClientClientTypes.Software: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case name
        case version
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let version = self.version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
    }
}

extension WorkSpacesThinClientClientTypes {
    /// Describes software.
    public struct Software: Swift.Equatable {
        /// The name of the software component.
        public var name: Swift.String?
        /// The version of the software component.
        public var version: Swift.String?

        public init(
            name: Swift.String? = nil,
            version: Swift.String? = nil
        )
        {
            self.name = name
            self.version = version
        }
    }

}

extension WorkSpacesThinClientClientTypes.SoftwareSet: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case id
        case releasedAt
        case software
        case supportedUntil
        case validationStatus
        case version
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let releasedAt = self.releasedAt {
            try encodeContainer.encodeTimestamp(releasedAt, format: .epochSeconds, forKey: .releasedAt)
        }
        if let software = software {
            var softwareContainer = encodeContainer.nestedUnkeyedContainer(forKey: .software)
            for software0 in software {
                try softwareContainer.encode(software0)
            }
        }
        if let supportedUntil = self.supportedUntil {
            try encodeContainer.encodeTimestamp(supportedUntil, format: .epochSeconds, forKey: .supportedUntil)
        }
        if let validationStatus = self.validationStatus {
            try encodeContainer.encode(validationStatus.rawValue, forKey: .validationStatus)
        }
        if let version = self.version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let releasedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .releasedAt)
        releasedAt = releasedAtDecoded
        let supportedUntilDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .supportedUntil)
        supportedUntil = supportedUntilDecoded
        let validationStatusDecoded = try containerValues.decodeIfPresent(WorkSpacesThinClientClientTypes.SoftwareSetValidationStatus.self, forKey: .validationStatus)
        validationStatus = validationStatusDecoded
        let softwareContainer = try containerValues.decodeIfPresent([WorkSpacesThinClientClientTypes.Software?].self, forKey: .software)
        var softwareDecoded0:[WorkSpacesThinClientClientTypes.Software]? = nil
        if let softwareContainer = softwareContainer {
            softwareDecoded0 = [WorkSpacesThinClientClientTypes.Software]()
            for structure0 in softwareContainer {
                if let structure0 = structure0 {
                    softwareDecoded0?.append(structure0)
                }
            }
        }
        software = softwareDecoded0
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension WorkSpacesThinClientClientTypes {
    /// Describes a software set.
    public struct SoftwareSet: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the software set.
        public var arn: Swift.String?
        /// The ID of the software set.
        public var id: Swift.String?
        /// The timestamp of when the software set was released.
        public var releasedAt: ClientRuntime.Date?
        /// A list of the software components in the software set.
        public var software: [WorkSpacesThinClientClientTypes.Software]?
        /// The timestamp of the end of support for the software set.
        public var supportedUntil: ClientRuntime.Date?
        /// An option to define if the software set has been validated.
        public var validationStatus: WorkSpacesThinClientClientTypes.SoftwareSetValidationStatus?
        /// The version of the software set.
        public var version: Swift.String?

        public init(
            arn: Swift.String? = nil,
            id: Swift.String? = nil,
            releasedAt: ClientRuntime.Date? = nil,
            software: [WorkSpacesThinClientClientTypes.Software]? = nil,
            supportedUntil: ClientRuntime.Date? = nil,
            validationStatus: WorkSpacesThinClientClientTypes.SoftwareSetValidationStatus? = nil,
            version: Swift.String? = nil
        )
        {
            self.arn = arn
            self.id = id
            self.releasedAt = releasedAt
            self.software = software
            self.supportedUntil = supportedUntil
            self.validationStatus = validationStatus
            self.version = version
        }
    }

}

extension WorkSpacesThinClientClientTypes.SoftwareSetSummary: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case arn
        case id
        case releasedAt
        case supportedUntil
        case validationStatus
        case version
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let arn = self.arn {
            try encodeContainer.encode(arn, forKey: .arn)
        }
        if let id = self.id {
            try encodeContainer.encode(id, forKey: .id)
        }
        if let releasedAt = self.releasedAt {
            try encodeContainer.encodeTimestamp(releasedAt, format: .epochSeconds, forKey: .releasedAt)
        }
        if let supportedUntil = self.supportedUntil {
            try encodeContainer.encodeTimestamp(supportedUntil, format: .epochSeconds, forKey: .supportedUntil)
        }
        if let validationStatus = self.validationStatus {
            try encodeContainer.encode(validationStatus.rawValue, forKey: .validationStatus)
        }
        if let version = self.version {
            try encodeContainer.encode(version, forKey: .version)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let idDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .id)
        id = idDecoded
        let versionDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .version)
        version = versionDecoded
        let releasedAtDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .releasedAt)
        releasedAt = releasedAtDecoded
        let supportedUntilDecoded = try containerValues.decodeTimestampIfPresent(.epochSeconds, forKey: .supportedUntil)
        supportedUntil = supportedUntilDecoded
        let validationStatusDecoded = try containerValues.decodeIfPresent(WorkSpacesThinClientClientTypes.SoftwareSetValidationStatus.self, forKey: .validationStatus)
        validationStatus = validationStatusDecoded
        let arnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .arn)
        arn = arnDecoded
    }
}

extension WorkSpacesThinClientClientTypes {
    /// Describes a software set.
    public struct SoftwareSetSummary: Swift.Equatable {
        /// The Amazon Resource Name (ARN) of the software set.
        public var arn: Swift.String?
        /// The ID of the software set.
        public var id: Swift.String?
        /// The timestamp of when the software set was released.
        public var releasedAt: ClientRuntime.Date?
        /// The timestamp of the end of support for the software set.
        public var supportedUntil: ClientRuntime.Date?
        /// An option to define if the software set has been validated.
        public var validationStatus: WorkSpacesThinClientClientTypes.SoftwareSetValidationStatus?
        /// The version of the software set.
        public var version: Swift.String?

        public init(
            arn: Swift.String? = nil,
            id: Swift.String? = nil,
            releasedAt: ClientRuntime.Date? = nil,
            supportedUntil: ClientRuntime.Date? = nil,
            validationStatus: WorkSpacesThinClientClientTypes.SoftwareSetValidationStatus? = nil,
            version: Swift.String? = nil
        )
        {
            self.arn = arn
            self.id = id
            self.releasedAt = releasedAt
            self.supportedUntil = supportedUntil
            self.validationStatus = validationStatus
            self.version = version
        }
    }

}

extension WorkSpacesThinClientClientTypes {
    public enum SoftwareSetUpdateMode: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case useDesired
        case useLatest
        case sdkUnknown(Swift.String)

        public static var allCases: [SoftwareSetUpdateMode] {
            return [
                .useDesired,
                .useLatest,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .useDesired: return "USE_DESIRED"
            case .useLatest: return "USE_LATEST"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SoftwareSetUpdateMode(rawValue: rawValue) ?? SoftwareSetUpdateMode.sdkUnknown(rawValue)
        }
    }
}

extension WorkSpacesThinClientClientTypes {
    public enum SoftwareSetUpdateSchedule: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case applyImmediately
        case useMaintenanceWindow
        case sdkUnknown(Swift.String)

        public static var allCases: [SoftwareSetUpdateSchedule] {
            return [
                .applyImmediately,
                .useMaintenanceWindow,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .applyImmediately: return "APPLY_IMMEDIATELY"
            case .useMaintenanceWindow: return "USE_MAINTENANCE_WINDOW"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SoftwareSetUpdateSchedule(rawValue: rawValue) ?? SoftwareSetUpdateSchedule.sdkUnknown(rawValue)
        }
    }
}

extension WorkSpacesThinClientClientTypes {
    public enum SoftwareSetUpdateStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case available
        case inProgress
        case upToDate
        case sdkUnknown(Swift.String)

        public static var allCases: [SoftwareSetUpdateStatus] {
            return [
                .available,
                .inProgress,
                .upToDate,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .available: return "AVAILABLE"
            case .inProgress: return "IN_PROGRESS"
            case .upToDate: return "UP_TO_DATE"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SoftwareSetUpdateStatus(rawValue: rawValue) ?? SoftwareSetUpdateStatus.sdkUnknown(rawValue)
        }
    }
}

extension WorkSpacesThinClientClientTypes {
    public enum SoftwareSetValidationStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case notValidated
        case validated
        case sdkUnknown(Swift.String)

        public static var allCases: [SoftwareSetValidationStatus] {
            return [
                .notValidated,
                .validated,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .notValidated: return "NOT_VALIDATED"
            case .validated: return "VALIDATED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = SoftwareSetValidationStatus(rawValue: rawValue) ?? SoftwareSetValidationStatus.sdkUnknown(rawValue)
        }
    }
}

extension TagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "TagResourceInput(resourceArn: \(Swift.String(describing: resourceArn)), tags: \"CONTENT_REDACTED\")"}
}

extension TagResourceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let tags = tags {
            var tagsContainer = encodeContainer.nestedContainer(keyedBy: ClientRuntime.Key.self, forKey: .tags)
            for (dictKey0, tagsMap0) in tags {
                try tagsContainer.encode(tagsMap0, forKey: ClientRuntime.Key(stringValue: dictKey0))
            }
        }
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct TagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource that you want to tag.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// A map of the key-value pairs of the tag or tags to assign to the resource.
    /// This member is required.
    public var tags: [Swift.String:Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [Swift.String:Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

struct TagResourceInputBody: Swift.Equatable {
    let tags: [Swift.String:Swift.String]?
}

extension TagResourceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case tags
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let tagsContainer = try containerValues.decodeIfPresent([Swift.String: Swift.String?].self, forKey: .tags)
        var tagsDecoded0: [Swift.String:Swift.String]? = nil
        if let tagsContainer = tagsContainer {
            tagsDecoded0 = [Swift.String:Swift.String]()
            for (key0, string0) in tagsContainer {
                if let string0 = string0 {
                    tagsDecoded0?[key0] = string0
                }
            }
        }
        tags = tagsDecoded0
    }
}

extension TagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct TagResourceOutput: Swift.Equatable {

    public init() { }
}

enum TagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension WorkSpacesThinClientClientTypes {
    public enum TargetDeviceStatus: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case archived
        case deregistered
        case sdkUnknown(Swift.String)

        public static var allCases: [TargetDeviceStatus] {
            return [
                .archived,
                .deregistered,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .archived: return "ARCHIVED"
            case .deregistered: return "DEREGISTERED"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = TargetDeviceStatus(rawValue: rawValue) ?? TargetDeviceStatus.sdkUnknown(rawValue)
        }
    }
}

extension ThrottlingException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let retryAfterSecondsHeaderValue = httpResponse.headers.value(for: "Retry-After") {
            self.properties.retryAfterSeconds = Swift.Int(retryAfterSecondsHeaderValue) ?? 0
        } else {
            self.properties.retryAfterSeconds = nil
        }
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ThrottlingExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.message = output.message
            self.properties.quotaCode = output.quotaCode
            self.properties.serviceCode = output.serviceCode
        } else {
            self.properties.message = nil
            self.properties.quotaCode = nil
            self.properties.serviceCode = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The request was denied due to request throttling.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        public internal(set) var message: Swift.String? = nil
        /// The code for the quota in [Service Quotas](https://docs.aws.amazon.com/servicequotas/latest/userguide/intro.html).
        public internal(set) var quotaCode: Swift.String? = nil
        /// The number of seconds to wait before retrying the next request.
        public internal(set) var retryAfterSeconds: Swift.Int? = nil
        /// The code for the service in [Service Quotas](https://docs.aws.amazon.com/servicequotas/latest/userguide/intro.html).
        public internal(set) var serviceCode: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        quotaCode: Swift.String? = nil,
        retryAfterSeconds: Swift.Int? = nil,
        serviceCode: Swift.String? = nil
    )
    {
        self.properties.message = message
        self.properties.quotaCode = quotaCode
        self.properties.retryAfterSeconds = retryAfterSeconds
        self.properties.serviceCode = serviceCode
    }
}

struct ThrottlingExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let serviceCode: Swift.String?
    let quotaCode: Swift.String?
}

extension ThrottlingExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case quotaCode
        case serviceCode
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let serviceCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .serviceCode)
        serviceCode = serviceCodeDecoded
        let quotaCodeDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .quotaCode)
        quotaCode = quotaCodeDecoded
    }
}

extension UntagResourceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UntagResourceInput(resourceArn: \(Swift.String(describing: resourceArn)), tagKeys: \"CONTENT_REDACTED\")"}
}

extension UntagResourceInput {

    static func queryItemProvider(_ value: UntagResourceInput) throws -> [ClientRuntime.SDKURLQueryItem] {
        var items = [ClientRuntime.SDKURLQueryItem]()
        guard let tagKeys = value.tagKeys else {
            let message = "Creating a URL Query Item failed. tagKeys is required and must not be nil."
            throw ClientRuntime.ClientError.unknownError(message)
        }
        tagKeys.forEach { queryItemValue in
            let queryItem = ClientRuntime.SDKURLQueryItem(name: "tagKeys".urlPercentEncoding(), value: Swift.String(queryItemValue).urlPercentEncoding())
            items.append(queryItem)
        }
        return items
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        guard let resourceArn = value.resourceArn else {
            return nil
        }
        return "/tags/\(resourceArn.urlPercentEncoding())"
    }
}

public struct UntagResourceInput: Swift.Equatable {
    /// The Amazon Resource Name (ARN) of the resource that you want to untag.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// The keys of the key-value pairs for the tag or tags you want to remove from the specified resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    )
    {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

struct UntagResourceInputBody: Swift.Equatable {
}

extension UntagResourceInputBody: Swift.Decodable {

    public init(from decoder: Swift.Decoder) throws {
    }
}

extension UntagResourceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UntagResourceOutput: Swift.Equatable {

    public init() { }
}

enum UntagResourceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "InternalServiceException": return try await InternalServiceException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateDeviceInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateDeviceInput(desiredSoftwareSetId: \(Swift.String(describing: desiredSoftwareSetId)), id: \(Swift.String(describing: id)), kmsKeyArn: \(Swift.String(describing: kmsKeyArn)), softwareSetUpdateSchedule: \(Swift.String(describing: softwareSetUpdateSchedule)), name: \"CONTENT_REDACTED\")"}
}

extension UpdateDeviceInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case desiredSoftwareSetId
        case kmsKeyArn
        case name
        case softwareSetUpdateSchedule
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let desiredSoftwareSetId = self.desiredSoftwareSetId {
            try encodeContainer.encode(desiredSoftwareSetId, forKey: .desiredSoftwareSetId)
        }
        if let kmsKeyArn = self.kmsKeyArn {
            try encodeContainer.encode(kmsKeyArn, forKey: .kmsKeyArn)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let softwareSetUpdateSchedule = self.softwareSetUpdateSchedule {
            try encodeContainer.encode(softwareSetUpdateSchedule.rawValue, forKey: .softwareSetUpdateSchedule)
        }
    }
}

extension UpdateDeviceInput {

    static func urlPathProvider(_ value: UpdateDeviceInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/devices/\(id.urlPercentEncoding())"
    }
}

public struct UpdateDeviceInput: Swift.Equatable {
    /// The ID of the software set to apply.
    public var desiredSoftwareSetId: Swift.String?
    /// The ID of the device to update.
    /// This member is required.
    public var id: Swift.String?
    /// The Amazon Resource Name (ARN) of the Key Management Service key to use for the update.
    public var kmsKeyArn: Swift.String?
    /// The name of the device to update.
    public var name: Swift.String?
    /// An option to define if software updates should be applied within a maintenance window.
    public var softwareSetUpdateSchedule: WorkSpacesThinClientClientTypes.SoftwareSetUpdateSchedule?

    public init(
        desiredSoftwareSetId: Swift.String? = nil,
        id: Swift.String? = nil,
        kmsKeyArn: Swift.String? = nil,
        name: Swift.String? = nil,
        softwareSetUpdateSchedule: WorkSpacesThinClientClientTypes.SoftwareSetUpdateSchedule? = nil
    )
    {
        self.desiredSoftwareSetId = desiredSoftwareSetId
        self.id = id
        self.kmsKeyArn = kmsKeyArn
        self.name = name
        self.softwareSetUpdateSchedule = softwareSetUpdateSchedule
    }
}

struct UpdateDeviceInputBody: Swift.Equatable {
    let name: Swift.String?
    let desiredSoftwareSetId: Swift.String?
    let softwareSetUpdateSchedule: WorkSpacesThinClientClientTypes.SoftwareSetUpdateSchedule?
    let kmsKeyArn: Swift.String?
}

extension UpdateDeviceInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case desiredSoftwareSetId
        case kmsKeyArn
        case name
        case softwareSetUpdateSchedule
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let desiredSoftwareSetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .desiredSoftwareSetId)
        desiredSoftwareSetId = desiredSoftwareSetIdDecoded
        let softwareSetUpdateScheduleDecoded = try containerValues.decodeIfPresent(WorkSpacesThinClientClientTypes.SoftwareSetUpdateSchedule.self, forKey: .softwareSetUpdateSchedule)
        softwareSetUpdateSchedule = softwareSetUpdateScheduleDecoded
        let kmsKeyArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .kmsKeyArn)
        kmsKeyArn = kmsKeyArnDecoded
    }
}

extension UpdateDeviceOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateDeviceOutputBody = try responseDecoder.decode(responseBody: data)
            self.device = output.device
        } else {
            self.device = nil
        }
    }
}

public struct UpdateDeviceOutput: Swift.Equatable {
    /// Describes a device.
    public var device: WorkSpacesThinClientClientTypes.DeviceSummary?

    public init(
        device: WorkSpacesThinClientClientTypes.DeviceSummary? = nil
    )
    {
        self.device = device
    }
}

struct UpdateDeviceOutputBody: Swift.Equatable {
    let device: WorkSpacesThinClientClientTypes.DeviceSummary?
}

extension UpdateDeviceOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case device
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let deviceDecoded = try containerValues.decodeIfPresent(WorkSpacesThinClientClientTypes.DeviceSummary.self, forKey: .device)
        device = deviceDecoded
    }
}

enum UpdateDeviceOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateEnvironmentInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "UpdateEnvironmentInput(desiredSoftwareSetId: \(Swift.String(describing: desiredSoftwareSetId)), desktopArn: \(Swift.String(describing: desktopArn)), id: \(Swift.String(describing: id)), maintenanceWindow: \(Swift.String(describing: maintenanceWindow)), softwareSetUpdateMode: \(Swift.String(describing: softwareSetUpdateMode)), softwareSetUpdateSchedule: \(Swift.String(describing: softwareSetUpdateSchedule)), desktopEndpoint: \"CONTENT_REDACTED\", name: \"CONTENT_REDACTED\")"}
}

extension UpdateEnvironmentInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case desiredSoftwareSetId
        case desktopArn
        case desktopEndpoint
        case maintenanceWindow
        case name
        case softwareSetUpdateMode
        case softwareSetUpdateSchedule
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let desiredSoftwareSetId = self.desiredSoftwareSetId {
            try encodeContainer.encode(desiredSoftwareSetId, forKey: .desiredSoftwareSetId)
        }
        if let desktopArn = self.desktopArn {
            try encodeContainer.encode(desktopArn, forKey: .desktopArn)
        }
        if let desktopEndpoint = self.desktopEndpoint {
            try encodeContainer.encode(desktopEndpoint, forKey: .desktopEndpoint)
        }
        if let maintenanceWindow = self.maintenanceWindow {
            try encodeContainer.encode(maintenanceWindow, forKey: .maintenanceWindow)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
        if let softwareSetUpdateMode = self.softwareSetUpdateMode {
            try encodeContainer.encode(softwareSetUpdateMode.rawValue, forKey: .softwareSetUpdateMode)
        }
        if let softwareSetUpdateSchedule = self.softwareSetUpdateSchedule {
            try encodeContainer.encode(softwareSetUpdateSchedule.rawValue, forKey: .softwareSetUpdateSchedule)
        }
    }
}

extension UpdateEnvironmentInput {

    static func urlPathProvider(_ value: UpdateEnvironmentInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/environments/\(id.urlPercentEncoding())"
    }
}

public struct UpdateEnvironmentInput: Swift.Equatable {
    /// The ID of the software set to apply.
    public var desiredSoftwareSetId: Swift.String?
    /// The Amazon Resource Name (ARN) of the desktop to stream from Amazon WorkSpaces, WorkSpaces Web, or AppStream 2.0.
    public var desktopArn: Swift.String?
    /// The URL for the identity provider login (only for environments that use AppStream 2.0).
    public var desktopEndpoint: Swift.String?
    /// The ID of the environment to update.
    /// This member is required.
    public var id: Swift.String?
    /// A specification for a time window to apply software updates.
    public var maintenanceWindow: WorkSpacesThinClientClientTypes.MaintenanceWindow?
    /// The name of the environment to update.
    public var name: Swift.String?
    /// An option to define which software updates to apply.
    public var softwareSetUpdateMode: WorkSpacesThinClientClientTypes.SoftwareSetUpdateMode?
    /// An option to define if software updates should be applied within a maintenance window.
    public var softwareSetUpdateSchedule: WorkSpacesThinClientClientTypes.SoftwareSetUpdateSchedule?

    public init(
        desiredSoftwareSetId: Swift.String? = nil,
        desktopArn: Swift.String? = nil,
        desktopEndpoint: Swift.String? = nil,
        id: Swift.String? = nil,
        maintenanceWindow: WorkSpacesThinClientClientTypes.MaintenanceWindow? = nil,
        name: Swift.String? = nil,
        softwareSetUpdateMode: WorkSpacesThinClientClientTypes.SoftwareSetUpdateMode? = nil,
        softwareSetUpdateSchedule: WorkSpacesThinClientClientTypes.SoftwareSetUpdateSchedule? = nil
    )
    {
        self.desiredSoftwareSetId = desiredSoftwareSetId
        self.desktopArn = desktopArn
        self.desktopEndpoint = desktopEndpoint
        self.id = id
        self.maintenanceWindow = maintenanceWindow
        self.name = name
        self.softwareSetUpdateMode = softwareSetUpdateMode
        self.softwareSetUpdateSchedule = softwareSetUpdateSchedule
    }
}

struct UpdateEnvironmentInputBody: Swift.Equatable {
    let name: Swift.String?
    let desktopArn: Swift.String?
    let desktopEndpoint: Swift.String?
    let softwareSetUpdateSchedule: WorkSpacesThinClientClientTypes.SoftwareSetUpdateSchedule?
    let maintenanceWindow: WorkSpacesThinClientClientTypes.MaintenanceWindow?
    let softwareSetUpdateMode: WorkSpacesThinClientClientTypes.SoftwareSetUpdateMode?
    let desiredSoftwareSetId: Swift.String?
}

extension UpdateEnvironmentInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case desiredSoftwareSetId
        case desktopArn
        case desktopEndpoint
        case maintenanceWindow
        case name
        case softwareSetUpdateMode
        case softwareSetUpdateSchedule
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let desktopArnDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .desktopArn)
        desktopArn = desktopArnDecoded
        let desktopEndpointDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .desktopEndpoint)
        desktopEndpoint = desktopEndpointDecoded
        let softwareSetUpdateScheduleDecoded = try containerValues.decodeIfPresent(WorkSpacesThinClientClientTypes.SoftwareSetUpdateSchedule.self, forKey: .softwareSetUpdateSchedule)
        softwareSetUpdateSchedule = softwareSetUpdateScheduleDecoded
        let maintenanceWindowDecoded = try containerValues.decodeIfPresent(WorkSpacesThinClientClientTypes.MaintenanceWindow.self, forKey: .maintenanceWindow)
        maintenanceWindow = maintenanceWindowDecoded
        let softwareSetUpdateModeDecoded = try containerValues.decodeIfPresent(WorkSpacesThinClientClientTypes.SoftwareSetUpdateMode.self, forKey: .softwareSetUpdateMode)
        softwareSetUpdateMode = softwareSetUpdateModeDecoded
        let desiredSoftwareSetIdDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .desiredSoftwareSetId)
        desiredSoftwareSetId = desiredSoftwareSetIdDecoded
    }
}

extension UpdateEnvironmentOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: UpdateEnvironmentOutputBody = try responseDecoder.decode(responseBody: data)
            self.environment = output.environment
        } else {
            self.environment = nil
        }
    }
}

public struct UpdateEnvironmentOutput: Swift.Equatable {
    /// Describes an environment.
    public var environment: WorkSpacesThinClientClientTypes.EnvironmentSummary?

    public init(
        environment: WorkSpacesThinClientClientTypes.EnvironmentSummary? = nil
    )
    {
        self.environment = environment
    }
}

struct UpdateEnvironmentOutputBody: Swift.Equatable {
    let environment: WorkSpacesThinClientClientTypes.EnvironmentSummary?
}

extension UpdateEnvironmentOutputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case environment
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let environmentDecoded = try containerValues.decodeIfPresent(WorkSpacesThinClientClientTypes.EnvironmentSummary.self, forKey: .environment)
        environment = environmentDecoded
    }
}

enum UpdateEnvironmentOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension UpdateSoftwareSetInput: Swift.Encodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case validationStatus
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let validationStatus = self.validationStatus {
            try encodeContainer.encode(validationStatus.rawValue, forKey: .validationStatus)
        }
    }
}

extension UpdateSoftwareSetInput {

    static func urlPathProvider(_ value: UpdateSoftwareSetInput) -> Swift.String? {
        guard let id = value.id else {
            return nil
        }
        return "/softwaresets/\(id.urlPercentEncoding())"
    }
}

public struct UpdateSoftwareSetInput: Swift.Equatable {
    /// The ID of the software set to update.
    /// This member is required.
    public var id: Swift.String?
    /// An option to define if the software set has been validated.
    /// This member is required.
    public var validationStatus: WorkSpacesThinClientClientTypes.SoftwareSetValidationStatus?

    public init(
        id: Swift.String? = nil,
        validationStatus: WorkSpacesThinClientClientTypes.SoftwareSetValidationStatus? = nil
    )
    {
        self.id = id
        self.validationStatus = validationStatus
    }
}

struct UpdateSoftwareSetInputBody: Swift.Equatable {
    let validationStatus: WorkSpacesThinClientClientTypes.SoftwareSetValidationStatus?
}

extension UpdateSoftwareSetInputBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case validationStatus
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let validationStatusDecoded = try containerValues.decodeIfPresent(WorkSpacesThinClientClientTypes.SoftwareSetValidationStatus.self, forKey: .validationStatus)
        validationStatus = validationStatusDecoded
    }
}

extension UpdateSoftwareSetOutput: ClientRuntime.HttpResponseBinding {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws {
    }
}

public struct UpdateSoftwareSetOutput: Swift.Equatable {

    public init() { }
}

enum UpdateSoftwareSetOutputError: ClientRuntime.HttpResponseErrorBinding {
    static func makeError(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil) async throws -> Swift.Error {
        let restJSONError = try await AWSClientRuntime.RestJSONError(httpResponse: httpResponse)
        let requestID = httpResponse.requestId
        switch restJSONError.errorType {
            case "AccessDeniedException": return try await AccessDeniedException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "InternalServerException": return try await InternalServerException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ResourceNotFoundException": return try await ResourceNotFoundException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ThrottlingException": return try await ThrottlingException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            case "ValidationException": return try await ValidationException(httpResponse: httpResponse, decoder: decoder, message: restJSONError.errorMessage, requestID: requestID)
            default: return try await AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(httpResponse: httpResponse, message: restJSONError.errorMessage, requestID: requestID, typeName: restJSONError.errorType)
        }
    }
}

extension ValidationException {
    public init(httpResponse: ClientRuntime.HttpResponse, decoder: ClientRuntime.ResponseDecoder? = nil, message: Swift.String? = nil, requestID: Swift.String? = nil) async throws {
        if let data = try await httpResponse.body.readData(),
            let responseDecoder = decoder {
            let output: ValidationExceptionBody = try responseDecoder.decode(responseBody: data)
            self.properties.fieldList = output.fieldList
            self.properties.message = output.message
            self.properties.reason = output.reason
        } else {
            self.properties.fieldList = nil
            self.properties.message = nil
            self.properties.reason = nil
        }
        self.httpResponse = httpResponse
        self.requestID = requestID
        self.message = message
    }
}

/// The input fails to satisfy the specified constraints.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error {

    public struct Properties {
        /// A list of fields that didn't validate.
        public internal(set) var fieldList: [WorkSpacesThinClientClientTypes.ValidationExceptionField]? = nil
        public internal(set) var message: Swift.String? = nil
        /// The reason for the exception.
        public internal(set) var reason: WorkSpacesThinClientClientTypes.ValidationExceptionReason? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = HttpResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        fieldList: [WorkSpacesThinClientClientTypes.ValidationExceptionField]? = nil,
        message: Swift.String? = nil,
        reason: WorkSpacesThinClientClientTypes.ValidationExceptionReason? = nil
    )
    {
        self.properties.fieldList = fieldList
        self.properties.message = message
        self.properties.reason = reason
    }
}

struct ValidationExceptionBody: Swift.Equatable {
    let message: Swift.String?
    let reason: WorkSpacesThinClientClientTypes.ValidationExceptionReason?
    let fieldList: [WorkSpacesThinClientClientTypes.ValidationExceptionField]?
}

extension ValidationExceptionBody: Swift.Decodable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case fieldList
        case message
        case reason
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
        let reasonDecoded = try containerValues.decodeIfPresent(WorkSpacesThinClientClientTypes.ValidationExceptionReason.self, forKey: .reason)
        reason = reasonDecoded
        let fieldListContainer = try containerValues.decodeIfPresent([WorkSpacesThinClientClientTypes.ValidationExceptionField?].self, forKey: .fieldList)
        var fieldListDecoded0:[WorkSpacesThinClientClientTypes.ValidationExceptionField]? = nil
        if let fieldListContainer = fieldListContainer {
            fieldListDecoded0 = [WorkSpacesThinClientClientTypes.ValidationExceptionField]()
            for structure0 in fieldListContainer {
                if let structure0 = structure0 {
                    fieldListDecoded0?.append(structure0)
                }
            }
        }
        fieldList = fieldListDecoded0
    }
}

extension WorkSpacesThinClientClientTypes.ValidationExceptionField: Swift.Codable {
    enum CodingKeys: Swift.String, Swift.CodingKey {
        case message
        case name
    }

    public func encode(to encoder: Swift.Encoder) throws {
        var encodeContainer = encoder.container(keyedBy: CodingKeys.self)
        if let message = self.message {
            try encodeContainer.encode(message, forKey: .message)
        }
        if let name = self.name {
            try encodeContainer.encode(name, forKey: .name)
        }
    }

    public init(from decoder: Swift.Decoder) throws {
        let containerValues = try decoder.container(keyedBy: CodingKeys.self)
        let nameDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .name)
        name = nameDecoded
        let messageDecoded = try containerValues.decodeIfPresent(Swift.String.self, forKey: .message)
        message = messageDecoded
    }
}

extension WorkSpacesThinClientClientTypes {
    /// Describes a validation exception.
    public struct ValidationExceptionField: Swift.Equatable {
        /// A message that describes the reason for the exception.
        /// This member is required.
        public var message: Swift.String?
        /// The name of the exception.
        /// This member is required.
        public var name: Swift.String?

        public init(
            message: Swift.String? = nil,
            name: Swift.String? = nil
        )
        {
            self.message = message
            self.name = name
        }
    }

}

extension WorkSpacesThinClientClientTypes {
    public enum ValidationExceptionReason: Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Codable, Swift.Hashable {
        case cannotParse
        case fieldValidationFailed
        case other
        case unknownOperation
        case sdkUnknown(Swift.String)

        public static var allCases: [ValidationExceptionReason] {
            return [
                .cannotParse,
                .fieldValidationFailed,
                .other,
                .unknownOperation,
                .sdkUnknown("")
            ]
        }
        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }
        public var rawValue: Swift.String {
            switch self {
            case .cannotParse: return "cannotParse"
            case .fieldValidationFailed: return "fieldValidationFailed"
            case .other: return "other"
            case .unknownOperation: return "unknownOperation"
            case let .sdkUnknown(s): return s
            }
        }
        public init(from decoder: Swift.Decoder) throws {
            let container = try decoder.singleValueContainer()
            let rawValue = try container.decode(RawValue.self)
            self = ValidationExceptionReason(rawValue: rawValue) ?? ValidationExceptionReason.sdkUnknown(rawValue)
        }
    }
}

public enum WorkSpacesThinClientClientTypes {}
