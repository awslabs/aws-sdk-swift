//
// Copyright Amazon.com Inc. or its affiliates.
// All Rights Reserved.
//
// SPDX-License-Identifier: Apache-2.0
//

// Code generated by smithy-swift-codegen. DO NOT EDIT!

@_spi(SmithyReadWrite) import ClientRuntime
import Foundation
import class SmithyHTTPAPI.HTTPResponse
@_spi(SmithyReadWrite) import class SmithyJSON.Reader
@_spi(SmithyReadWrite) import class SmithyJSON.Writer
import enum ClientRuntime.ErrorFault
import enum SmithyReadWrite.ReaderError
@_spi(SmithyReadWrite) import enum SmithyReadWrite.ReadingClosures
@_spi(SmithyReadWrite) import enum SmithyReadWrite.WritingClosures
@_spi(SmithyTimestamps) import enum SmithyTimestamps.TimestampFormat
import protocol AWSClientRuntime.AWSServiceError
import protocol ClientRuntime.HTTPError
import protocol ClientRuntime.ModeledError
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyReader
@_spi(SmithyReadWrite) import protocol SmithyReadWrite.SmithyWriter
@_spi(SmithyReadWrite) import struct AWSClientRuntime.AWSJSONError
@_spi(UnknownAWSHTTPServiceError) import struct AWSClientRuntime.UnknownAWSHTTPServiceError
@_spi(SmithyReadWrite) import struct SmithyReadWrite.ReadingClosureBox
@_spi(SmithyReadWrite) import struct SmithyReadWrite.WritingClosureBox
@_spi(SmithyTimestamps) import struct SmithyTimestamps.TimestampFormatter

extension PartnerCentralAccountClientTypes {

    public enum AccessDeniedExceptionReason: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case accessDenied
        case incompatibleBenefitAwsPartnerState
        case sdkUnknown(Swift.String)

        public static var allCases: [AccessDeniedExceptionReason] {
            return [
                .accessDenied,
                .incompatibleBenefitAwsPartnerState
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .accessDenied: return "ACCESS_DENIED"
            case .incompatibleBenefitAwsPartnerState: return "INCOMPATIBLE_BENEFIT_AWS_PARTNER_STATE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// The request was denied due to insufficient permissions. The caller does not have the required permissions to perform this operation.
public struct AccessDeniedException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The specific reason for the access denial.
        /// This member is required.
        public internal(set) var reason: PartnerCentralAccountClientTypes.AccessDeniedExceptionReason? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "AccessDeniedException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        reason: PartnerCentralAccountClientTypes.AccessDeniedExceptionReason? = nil
    ) {
        self.properties.message = message
        self.properties.reason = reason
    }
}

extension PartnerCentralAccountClientTypes {

    public enum ConflictExceptionReason: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case accountAlreadyVerified
        case conflictClientToken
        case duplicateConnection
        case duplicateConnectionInvitation
        case duplicatePartner
        case incompatibleConnectionInvitationReceiver
        case incompatibleConnectionInvitationState
        case incompatibleConnectionPreferencesRevision
        case incompatibleConnectionState
        case incompatiblePartnerProfileTaskState
        case incompatibleProfileState
        case verificationAlreadyInProgress
        case sdkUnknown(Swift.String)

        public static var allCases: [ConflictExceptionReason] {
            return [
                .accountAlreadyVerified,
                .conflictClientToken,
                .duplicateConnection,
                .duplicateConnectionInvitation,
                .duplicatePartner,
                .incompatibleConnectionInvitationReceiver,
                .incompatibleConnectionInvitationState,
                .incompatibleConnectionPreferencesRevision,
                .incompatibleConnectionState,
                .incompatiblePartnerProfileTaskState,
                .incompatibleProfileState,
                .verificationAlreadyInProgress
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .accountAlreadyVerified: return "ACCOUNT_ALREADY_VERIFIED"
            case .conflictClientToken: return "CONFLICT_CLIENT_TOKEN"
            case .duplicateConnection: return "DUPLICATE_CONNECTION"
            case .duplicateConnectionInvitation: return "DUPLICATE_CONNECTION_INVITATION"
            case .duplicatePartner: return "DUPLICATE_PARTNER"
            case .incompatibleConnectionInvitationReceiver: return "INCOMPATIBLE_CONNECTION_INVITATION_RECEIVER"
            case .incompatibleConnectionInvitationState: return "INCOMPATIBLE_CONNECTION_INVITATION_STATE"
            case .incompatibleConnectionPreferencesRevision: return "INCOMPATIBLE_CONNECTION_PREFERENCES_REVISION"
            case .incompatibleConnectionState: return "INCOMPATIBLE_CONNECTION_STATE"
            case .incompatiblePartnerProfileTaskState: return "INCOMPATIBLE_PARTNER_PROFILE_TASK_STATE"
            case .incompatibleProfileState: return "INCOMPATIBLE_PROFILE_STATE"
            case .verificationAlreadyInProgress: return "VERIFICATION_ALREADY_IN_PROGRESS"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// The request could not be completed due to a conflict with the current state of the resource. This typically occurs when trying to create a resource that already exists or modify a resource that has been changed by another process.
public struct ConflictException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The specific reason for the conflict.
        /// This member is required.
        public internal(set) var reason: PartnerCentralAccountClientTypes.ConflictExceptionReason? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ConflictException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        reason: PartnerCentralAccountClientTypes.ConflictExceptionReason? = nil
    ) {
        self.properties.message = message
        self.properties.reason = reason
    }
}

/// An internal server error occurred while processing the request. This is typically a temporary condition and the request may be retried.
public struct InternalServerException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "InternalServerException" }
    public static var fault: ClientRuntime.ErrorFault { .server }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil
    ) {
        self.properties.message = message
    }
}

extension PartnerCentralAccountClientTypes {

    public enum ResourceNotFoundExceptionReason: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case connectionInvitationNotFound
        case connectionNotFound
        case partnerDomainNotFound
        case partnerNotFound
        case partnerProfileNotFound
        case partnerProfileTaskNotFound
        case receiverProfileNotFound
        case senderProfileNotFound
        case verificationNotFound
        case sdkUnknown(Swift.String)

        public static var allCases: [ResourceNotFoundExceptionReason] {
            return [
                .connectionInvitationNotFound,
                .connectionNotFound,
                .partnerDomainNotFound,
                .partnerNotFound,
                .partnerProfileNotFound,
                .partnerProfileTaskNotFound,
                .receiverProfileNotFound,
                .senderProfileNotFound,
                .verificationNotFound
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .connectionInvitationNotFound: return "CONNECTION_INVITATION_NOT_FOUND"
            case .connectionNotFound: return "CONNECTION_NOT_FOUND"
            case .partnerDomainNotFound: return "PARTNER_DOMAIN_NOT_FOUND"
            case .partnerNotFound: return "PARTNER_NOT_FOUND"
            case .partnerProfileNotFound: return "PARTNER_PROFILE_NOT_FOUND"
            case .partnerProfileTaskNotFound: return "PARTNER_PROFILE_TASK_NOT_FOUND"
            case .receiverProfileNotFound: return "RECEIVER_PROFILE_NOT_FOUND"
            case .senderProfileNotFound: return "SENDER_PROFILE_NOT_FOUND"
            case .verificationNotFound: return "VERIFICATION_NOT_FOUND"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// The specified resource could not be found. This may occur when referencing a resource that does not exist or has been deleted.
public struct ResourceNotFoundException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The specific reason why the resource was not found.
        /// This member is required.
        public internal(set) var reason: PartnerCentralAccountClientTypes.ResourceNotFoundExceptionReason? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ResourceNotFoundException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        reason: PartnerCentralAccountClientTypes.ResourceNotFoundExceptionReason? = nil
    ) {
        self.properties.message = message
        self.properties.reason = reason
    }
}

/// The request was throttled due to too many requests being sent in a short period of time. The client should implement exponential backoff and retry the request.
public struct ThrottlingException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The quota code associated with the throttling error.
        public internal(set) var quotaCode: Swift.String? = nil
        /// The service code associated with the throttling error.
        public internal(set) var serviceCode: Swift.String? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ThrottlingException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { true }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        quotaCode: Swift.String? = nil,
        serviceCode: Swift.String? = nil
    ) {
        self.properties.message = message
        self.properties.quotaCode = quotaCode
        self.properties.serviceCode = serviceCode
    }
}

extension PartnerCentralAccountClientTypes {

    public enum BusinessValidationCode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case incompatibleConnectionInvitationRequest
        case incompatibleDomain
        case incompatibleIdentityVerificationStatus
        case incompatibleKnowYourBusinessStatus
        case incompatibleLegalName
        case invalidAccountLinkingStatus
        case invalidAccountState
        case sdkUnknown(Swift.String)

        public static var allCases: [BusinessValidationCode] {
            return [
                .incompatibleConnectionInvitationRequest,
                .incompatibleDomain,
                .incompatibleIdentityVerificationStatus,
                .incompatibleKnowYourBusinessStatus,
                .incompatibleLegalName,
                .invalidAccountLinkingStatus,
                .invalidAccountState
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .incompatibleConnectionInvitationRequest: return "INCOMPATIBLE_CONNECTION_INVITATION_REQUEST"
            case .incompatibleDomain: return "INCOMPATIBLE_DOMAIN"
            case .incompatibleIdentityVerificationStatus: return "INCOMPATIBLE_IDENTITY_VERIFICATION_STATUS"
            case .incompatibleKnowYourBusinessStatus: return "INCOMPATIBLE_KNOW_YOUR_BUSINESS_STATUS"
            case .incompatibleLegalName: return "INCOMPATIBLE_LEGAL_NAME"
            case .invalidAccountLinkingStatus: return "INVALID_ACCOUNT_LINKING_STATUS"
            case .invalidAccountState: return "INVALID_ACCOUNT_STATE"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension PartnerCentralAccountClientTypes {

    /// Contains information about a business rule validation error that occurred during an operation.
    public struct BusinessValidationError: Swift.Sendable {
        /// A code identifying the specific business validation error.
        /// This member is required.
        public var code: PartnerCentralAccountClientTypes.BusinessValidationCode?
        /// A description of the business validation error.
        /// This member is required.
        public var message: Swift.String?

        public init(
            code: PartnerCentralAccountClientTypes.BusinessValidationCode? = nil,
            message: Swift.String? = nil
        ) {
            self.code = code
            self.message = message
        }
    }
}

extension PartnerCentralAccountClientTypes {

    public enum FieldValidationCode: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case actionNotPermitted
        case duplicateValue
        case invalidEnumValue
        case invalidStringFormat
        case invalidValue
        case requiredFieldMissing
        case tooManyValues
        case sdkUnknown(Swift.String)

        public static var allCases: [FieldValidationCode] {
            return [
                .actionNotPermitted,
                .duplicateValue,
                .invalidEnumValue,
                .invalidStringFormat,
                .invalidValue,
                .requiredFieldMissing,
                .tooManyValues
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .actionNotPermitted: return "ACTION_NOT_PERMITTED"
            case .duplicateValue: return "DUPLICATE_VALUE"
            case .invalidEnumValue: return "INVALID_ENUM_VALUE"
            case .invalidStringFormat: return "INVALID_STRING_FORMAT"
            case .invalidValue: return "INVALID_VALUE"
            case .requiredFieldMissing: return "REQUIRED_FIELD_MISSING"
            case .tooManyValues: return "TOO_MANY_VALUES"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension PartnerCentralAccountClientTypes {

    /// Contains information about a field-level validation error that occurred during an operation.
    public struct FieldValidationError: Swift.Sendable {
        /// A code identifying the specific field validation error.
        /// This member is required.
        public var code: PartnerCentralAccountClientTypes.FieldValidationCode?
        /// A description of the field validation error.
        /// This member is required.
        public var message: Swift.String?
        /// The name of the field that failed validation.
        /// This member is required.
        public var name: Swift.String?

        public init(
            code: PartnerCentralAccountClientTypes.FieldValidationCode? = nil,
            message: Swift.String? = nil,
            name: Swift.String? = nil
        ) {
            self.code = code
            self.message = message
            self.name = name
        }
    }
}

extension PartnerCentralAccountClientTypes {

    /// Contains information about a validation error, which can be either a field-level or business rule validation error.
    public enum ValidationError: Swift.Sendable {
        /// Details about a field-level validation error, if applicable.
        case fieldvalidationerror(PartnerCentralAccountClientTypes.FieldValidationError)
        /// Details about a business rule validation error, if applicable.
        case businessvalidationerror(PartnerCentralAccountClientTypes.BusinessValidationError)
        case sdkUnknown(Swift.String)
    }
}

extension PartnerCentralAccountClientTypes {

    public enum ValidationExceptionReason: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case businessValidationFailed
        case requestValidationFailed
        case sdkUnknown(Swift.String)

        public static var allCases: [ValidationExceptionReason] {
            return [
                .businessValidationFailed,
                .requestValidationFailed
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .businessValidationFailed: return "BUSINESS_VALIDATION_FAILED"
            case .requestValidationFailed: return "REQUEST_VALIDATION_FAILED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// The request failed validation. One or more input parameters are invalid, missing, or do not meet the required format or constraints.
public struct ValidationException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// A list of detailed validation errors that occurred during request processing.
        public internal(set) var errorDetails: [PartnerCentralAccountClientTypes.ValidationError]? = nil
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The reason for the validation failure.
        /// This member is required.
        public internal(set) var reason: PartnerCentralAccountClientTypes.ValidationExceptionReason? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ValidationException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        errorDetails: [PartnerCentralAccountClientTypes.ValidationError]? = nil,
        message: Swift.String? = nil,
        reason: PartnerCentralAccountClientTypes.ValidationExceptionReason? = nil
    ) {
        self.properties.errorDetails = errorDetails
        self.properties.message = message
        self.properties.reason = reason
    }
}

public struct AcceptConnectionInvitationInput: Swift.Sendable {
    /// The catalog identifier where the connection invitation exists.
    /// This member is required.
    public var catalog: Swift.String?
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
    /// This member is required.
    public var clientToken: Swift.String?
    /// The unique identifier of the connection invitation to accept.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        catalog: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        identifier: Swift.String? = nil
    ) {
        self.catalog = catalog
        self.clientToken = clientToken
        self.identifier = identifier
    }
}

extension PartnerCentralAccountClientTypes {

    public enum ConnectionType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case opportunityCollaboration
        case subsidiary
        case sdkUnknown(Swift.String)

        public static var allCases: [ConnectionType] {
            return [
                .opportunityCollaboration,
                .subsidiary
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .opportunityCollaboration: return "OPPORTUNITY_COLLABORATION"
            case .subsidiary: return "SUBSIDIARY"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension PartnerCentralAccountClientTypes {

    /// Summary information about an AWS account.
    public struct AccountSummary: Swift.Sendable {
        /// The name associated with the AWS account.
        /// This member is required.
        public var name: Swift.String?

        public init(
            name: Swift.String? = nil
        ) {
            self.name = name
        }
    }
}

extension PartnerCentralAccountClientTypes {

    /// A summary view of a partner profile containing basic identifying information.
    public struct PartnerProfileSummary: Swift.Sendable {
        /// The unique identifier of the partner profile.
        /// This member is required.
        public var id: Swift.String?
        /// The display name of the partner.
        /// This member is required.
        public var name: Swift.String?

        public init(
            id: Swift.String? = nil,
            name: Swift.String? = nil
        ) {
            self.id = id
            self.name = name
        }
    }
}

extension PartnerCentralAccountClientTypes {

    /// A summary view of a seller profile containing basic identifying information.
    public struct SellerProfileSummary: Swift.Sendable {
        /// The unique identifier of the seller profile.
        /// This member is required.
        public var id: Swift.String?
        /// The display name of the seller.
        /// This member is required.
        public var name: Swift.String?

        public init(
            id: Swift.String? = nil,
            name: Swift.String? = nil
        ) {
            self.id = id
            self.name = name
        }
    }
}

extension PartnerCentralAccountClientTypes {

    /// Represents a participant in a partner connection, containing their profile and account information.
    public enum Participant: Swift.Sendable {
        /// The partner profile information for the participant.
        case partnerprofile(PartnerCentralAccountClientTypes.PartnerProfileSummary)
        /// The seller profile information for the participant.
        case sellerprofile(PartnerCentralAccountClientTypes.SellerProfileSummary)
        /// The AWS account information for the participant.
        case account(PartnerCentralAccountClientTypes.AccountSummary)
        case sdkUnknown(Swift.String)
    }
}

extension PartnerCentralAccountClientTypes {

    public enum ConnectionTypeStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case active
        case canceled
        case sdkUnknown(Swift.String)

        public static var allCases: [ConnectionTypeStatus] {
            return [
                .active,
                .canceled
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .active: return "ACTIVE"
            case .canceled: return "CANCELED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension PartnerCentralAccountClientTypes {

    /// Detailed information about a specific connection type within a connection.
    public struct ConnectionTypeDetail: Swift.Sendable {
        /// The timestamp when this connection type was cancelled, if applicable.
        public var canceledAt: Foundation.Date?
        /// The AWS account ID of the participant who cancelled this connection type.
        public var canceledBy: Swift.String?
        /// The timestamp when this connection type was created.
        /// This member is required.
        public var createdAt: Foundation.Date?
        /// The email address of the person who initiated this connection type.
        /// This member is required.
        public var inviterEmail: Swift.String?
        /// The name of the person who initiated this connection type.
        /// This member is required.
        public var inviterName: Swift.String?
        /// Information about the other participant in this connection type.
        /// This member is required.
        public var otherParticipant: PartnerCentralAccountClientTypes.Participant?
        /// The current status of this connection type.
        /// This member is required.
        public var status: PartnerCentralAccountClientTypes.ConnectionTypeStatus?

        public init(
            canceledAt: Foundation.Date? = nil,
            canceledBy: Swift.String? = nil,
            createdAt: Foundation.Date? = nil,
            inviterEmail: Swift.String? = nil,
            inviterName: Swift.String? = nil,
            otherParticipant: PartnerCentralAccountClientTypes.Participant? = nil,
            status: PartnerCentralAccountClientTypes.ConnectionTypeStatus? = nil
        ) {
            self.canceledAt = canceledAt
            self.canceledBy = canceledBy
            self.createdAt = createdAt
            self.inviterEmail = inviterEmail
            self.inviterName = inviterName
            self.otherParticipant = otherParticipant
            self.status = status
        }
    }
}

extension PartnerCentralAccountClientTypes.ConnectionTypeDetail: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "ConnectionTypeDetail(canceledAt: \(Swift.String(describing: canceledAt)), canceledBy: \(Swift.String(describing: canceledBy)), createdAt: \(Swift.String(describing: createdAt)), inviterEmail: \(Swift.String(describing: inviterEmail)), otherParticipant: \(Swift.String(describing: otherParticipant)), status: \(Swift.String(describing: status)), inviterName: \"CONTENT_REDACTED\")"}
}

extension PartnerCentralAccountClientTypes {

    /// Base structure containing common connection properties.
    public struct Connection: Swift.Sendable {
        /// The AWS Resource Name (ARN) of the connection.
        /// This member is required.
        public var arn: Swift.String?
        /// The catalog identifier that the connection belongs to.
        /// This member is required.
        public var catalog: Swift.String?
        /// The type of connection.
        /// This member is required.
        public var connectionTypes: [Swift.String: PartnerCentralAccountClientTypes.ConnectionTypeDetail]?
        /// The unique identifier of the connection.
        /// This member is required.
        public var id: Swift.String?
        /// The AWS account ID of the other participant in the connection.
        /// This member is required.
        public var otherParticipantAccountId: Swift.String?
        /// The timestamp when the connection was last updated.
        /// This member is required.
        public var updatedAt: Foundation.Date?

        public init(
            arn: Swift.String? = nil,
            catalog: Swift.String? = nil,
            connectionTypes: [Swift.String: PartnerCentralAccountClientTypes.ConnectionTypeDetail]? = nil,
            id: Swift.String? = nil,
            otherParticipantAccountId: Swift.String? = nil,
            updatedAt: Foundation.Date? = nil
        ) {
            self.arn = arn
            self.catalog = catalog
            self.connectionTypes = connectionTypes
            self.id = id
            self.otherParticipantAccountId = otherParticipantAccountId
            self.updatedAt = updatedAt
        }
    }
}

public struct AcceptConnectionInvitationOutput: Swift.Sendable {
    /// The details of the accepted connection between the two partners.
    /// This member is required.
    public var connection: PartnerCentralAccountClientTypes.Connection?

    public init(
        connection: PartnerCentralAccountClientTypes.Connection? = nil
    ) {
        self.connection = connection
    }
}

extension PartnerCentralAccountClientTypes {

    public enum AccessType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case allowAll
        case allowByDefaultDenySome
        case denyAll
        case sdkUnknown(Swift.String)

        public static var allCases: [AccessType] {
            return [
                .allowAll,
                .allowByDefaultDenySome,
                .denyAll
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .allowAll: return "ALLOW_ALL"
            case .allowByDefaultDenySome: return "ALLOW_BY_DEFAULT_DENY_SOME"
            case .denyAll: return "DENY_ALL"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension PartnerCentralAccountClientTypes {

    /// Contains contact information for the primary alliance lead responsible for partnership activities.
    public struct AllianceLeadContact: Swift.Sendable {
        /// The business title or role of the alliance lead contact person.
        /// This member is required.
        public var businessTitle: Swift.String?
        /// The email address of the alliance lead contact person.
        /// This member is required.
        public var email: Swift.String?
        /// The first name of the alliance lead contact person.
        /// This member is required.
        public var firstName: Swift.String?
        /// The last name of the alliance lead contact person.
        /// This member is required.
        public var lastName: Swift.String?

        public init(
            businessTitle: Swift.String? = nil,
            email: Swift.String? = nil,
            firstName: Swift.String? = nil,
            lastName: Swift.String? = nil
        ) {
            self.businessTitle = businessTitle
            self.email = email
            self.firstName = firstName
            self.lastName = lastName
        }
    }
}

extension PartnerCentralAccountClientTypes.AllianceLeadContact: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AllianceLeadContact(email: \(Swift.String(describing: email)), businessTitle: \"CONTENT_REDACTED\", firstName: \"CONTENT_REDACTED\", lastName: \"CONTENT_REDACTED\")"}
}

extension PartnerCentralAccountClientTypes {

    public enum ServiceQuotaExceededExceptionReason: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case limitExceededNumberOfDomain
        case limitExceededNumberOfEmail
        case sdkUnknown(Swift.String)

        public static var allCases: [ServiceQuotaExceededExceptionReason] {
            return [
                .limitExceededNumberOfDomain,
                .limitExceededNumberOfEmail
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .limitExceededNumberOfDomain: return "LIMIT_EXCEEDED_NUMBER_OF_DOMAIN"
            case .limitExceededNumberOfEmail: return "LIMIT_EXCEEDED_NUMBER_OF_EMAIL"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

/// The request was rejected because it would exceed a service quota or limit. This may occur when trying to create more resources than allowed by the service limits.
public struct ServiceQuotaExceededException: ClientRuntime.ModeledError, AWSClientRuntime.AWSServiceError, ClientRuntime.HTTPError, Swift.Error, Swift.Sendable {

    public struct Properties: Swift.Sendable {
        /// This member is required.
        public internal(set) var message: Swift.String? = nil
        /// The specific reason for the service quota being exceeded.
        /// This member is required.
        public internal(set) var reason: PartnerCentralAccountClientTypes.ServiceQuotaExceededExceptionReason? = nil
    }

    public internal(set) var properties = Properties()
    public static var typeName: Swift.String { "ServiceQuotaExceededException" }
    public static var fault: ClientRuntime.ErrorFault { .client }
    public static var isRetryable: Swift.Bool { false }
    public static var isThrottling: Swift.Bool { false }
    public internal(set) var httpResponse = SmithyHTTPAPI.HTTPResponse()
    public internal(set) var message: Swift.String?
    public internal(set) var requestID: Swift.String?

    public init(
        message: Swift.String? = nil,
        reason: PartnerCentralAccountClientTypes.ServiceQuotaExceededExceptionReason? = nil
    ) {
        self.properties.message = message
        self.properties.reason = reason
    }
}

public struct AssociateAwsTrainingCertificationEmailDomainInput: Swift.Sendable {
    /// The catalog identifier for the partner account.
    /// This member is required.
    public var catalog: Swift.String?
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
    public var clientToken: Swift.String?
    /// The email address used to verify domain ownership for AWS training and certification association.
    /// This member is required.
    public var email: Swift.String?
    /// The verification code sent to the email address to confirm domain ownership.
    /// This member is required.
    public var emailVerificationCode: Swift.String?
    /// The unique identifier of the partner account.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        catalog: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        email: Swift.String? = nil,
        emailVerificationCode: Swift.String? = nil,
        identifier: Swift.String? = nil
    ) {
        self.catalog = catalog
        self.clientToken = clientToken
        self.email = email
        self.emailVerificationCode = emailVerificationCode
        self.identifier = identifier
    }
}

extension AssociateAwsTrainingCertificationEmailDomainInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "AssociateAwsTrainingCertificationEmailDomainInput(catalog: \(Swift.String(describing: catalog)), clientToken: \(Swift.String(describing: clientToken)), email: \(Swift.String(describing: email)), identifier: \(Swift.String(describing: identifier)), emailVerificationCode: \"CONTENT_REDACTED\")"}
}

public struct AssociateAwsTrainingCertificationEmailDomainOutput: Swift.Sendable {

    public init() { }
}

extension PartnerCentralAccountClientTypes {

    /// Contains the business information required for verifying a company's legal status and registration details within AWS Partner Central.
    public struct BusinessVerificationDetails: Swift.Sendable {
        /// The ISO 3166-1 alpha-2 country code where the business is legally registered and operates.
        /// This member is required.
        public var countryCode: Swift.String?
        /// The specific legal jurisdiction or state where the business was incorporated or registered, providing additional location context beyond the country code.
        public var jurisdictionOfIncorporation: Swift.String?
        /// The official legal name of the business as registered with the appropriate government authorities.
        /// This member is required.
        public var legalName: Swift.String?
        /// The unique business registration identifier assigned by the government or regulatory authority, such as a company registration number or tax identification number.
        /// This member is required.
        public var registrationId: Swift.String?

        public init(
            countryCode: Swift.String? = nil,
            jurisdictionOfIncorporation: Swift.String? = nil,
            legalName: Swift.String? = nil,
            registrationId: Swift.String? = nil
        ) {
            self.countryCode = countryCode
            self.jurisdictionOfIncorporation = jurisdictionOfIncorporation
            self.legalName = legalName
            self.registrationId = registrationId
        }
    }
}

extension PartnerCentralAccountClientTypes.BusinessVerificationDetails: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "BusinessVerificationDetails(countryCode: \(Swift.String(describing: countryCode)), jurisdictionOfIncorporation: \(Swift.String(describing: jurisdictionOfIncorporation)), legalName: \"CONTENT_REDACTED\", registrationId: \"CONTENT_REDACTED\")"}
}

extension PartnerCentralAccountClientTypes {

    /// Contains the response information and results from a business verification process, including any verification-specific data returned by the verification service.
    public struct BusinessVerificationResponse: Swift.Sendable {
        /// The business verification details that were processed and verified, potentially including additional information discovered during the verification process.
        /// This member is required.
        public var businessVerificationDetails: PartnerCentralAccountClientTypes.BusinessVerificationDetails?

        public init(
            businessVerificationDetails: PartnerCentralAccountClientTypes.BusinessVerificationDetails? = nil
        ) {
            self.businessVerificationDetails = businessVerificationDetails
        }
    }
}

public struct CancelConnectionInput: Swift.Sendable {
    /// The catalog identifier where the connection exists.
    /// This member is required.
    public var catalog: Swift.String?
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
    /// This member is required.
    public var clientToken: Swift.String?
    /// The type of connection to cancel (e.g., reseller, distributor, technology partner).
    /// This member is required.
    public var connectionType: PartnerCentralAccountClientTypes.ConnectionType?
    /// The unique identifier of the connection to cancel.
    /// This member is required.
    public var identifier: Swift.String?
    /// The reason for canceling the connection, providing context for the termination.
    /// This member is required.
    public var reason: Swift.String?

    public init(
        catalog: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        connectionType: PartnerCentralAccountClientTypes.ConnectionType? = nil,
        identifier: Swift.String? = nil,
        reason: Swift.String? = nil
    ) {
        self.catalog = catalog
        self.clientToken = clientToken
        self.connectionType = connectionType
        self.identifier = identifier
        self.reason = reason
    }
}

public struct CancelConnectionOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the canceled connection.
    /// This member is required.
    public var arn: Swift.String?
    /// The catalog identifier where the connection was canceled.
    /// This member is required.
    public var catalog: Swift.String?
    /// The list of connection types that were active before cancellation.
    /// This member is required.
    public var connectionTypes: [Swift.String: PartnerCentralAccountClientTypes.ConnectionTypeDetail]?
    /// The unique identifier of the canceled connection.
    /// This member is required.
    public var id: Swift.String?
    /// The AWS account ID of the other participant in the canceled connection.
    /// This member is required.
    public var otherParticipantAccountId: Swift.String?
    /// The timestamp when the connection was last updated (canceled).
    /// This member is required.
    public var updatedAt: Foundation.Date?

    public init(
        arn: Swift.String? = nil,
        catalog: Swift.String? = nil,
        connectionTypes: [Swift.String: PartnerCentralAccountClientTypes.ConnectionTypeDetail]? = nil,
        id: Swift.String? = nil,
        otherParticipantAccountId: Swift.String? = nil,
        updatedAt: Foundation.Date? = nil
    ) {
        self.arn = arn
        self.catalog = catalog
        self.connectionTypes = connectionTypes
        self.id = id
        self.otherParticipantAccountId = otherParticipantAccountId
        self.updatedAt = updatedAt
    }
}

public struct CancelConnectionInvitationInput: Swift.Sendable {
    /// The catalog identifier where the connection invitation exists.
    /// This member is required.
    public var catalog: Swift.String?
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
    /// This member is required.
    public var clientToken: Swift.String?
    /// The unique identifier of the connection invitation to cancel.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        catalog: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        identifier: Swift.String? = nil
    ) {
        self.catalog = catalog
        self.clientToken = clientToken
        self.identifier = identifier
    }
}

extension PartnerCentralAccountClientTypes {

    public enum ParticipantType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case receiver
        case sender
        case sdkUnknown(Swift.String)

        public static var allCases: [ParticipantType] {
            return [
                .receiver,
                .sender
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .receiver: return "RECEIVER"
            case .sender: return "SENDER"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension PartnerCentralAccountClientTypes {

    public enum InvitationStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case accepted
        case canceled
        case expired
        case pending
        case rejected
        case sdkUnknown(Swift.String)

        public static var allCases: [InvitationStatus] {
            return [
                .accepted,
                .canceled,
                .expired,
                .pending,
                .rejected
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .accepted: return "ACCEPTED"
            case .canceled: return "CANCELED"
            case .expired: return "EXPIRED"
            case .pending: return "PENDING"
            case .rejected: return "REJECTED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct CancelConnectionInvitationOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the canceled connection invitation.
    /// This member is required.
    public var arn: Swift.String?
    /// The catalog identifier where the connection invitation was canceled.
    /// This member is required.
    public var catalog: Swift.String?
    /// The identifier of the connection associated with the canceled invitation.
    public var connectionId: Swift.String?
    /// The type of connection that was being invited for.
    /// This member is required.
    public var connectionType: PartnerCentralAccountClientTypes.ConnectionType?
    /// The timestamp when the connection invitation was originally created.
    /// This member is required.
    public var createdAt: Foundation.Date?
    /// The timestamp when the connection invitation would have expired if not canceled.
    public var expiresAt: Foundation.Date?
    /// The unique identifier of the canceled connection invitation.
    /// This member is required.
    public var id: Swift.String?
    /// The message that was included with the original connection invitation.
    /// This member is required.
    public var invitationMessage: Swift.String?
    /// The email address of the person who sent the connection invitation.
    /// This member is required.
    public var inviterEmail: Swift.String?
    /// The name of the person who sent the connection invitation.
    /// This member is required.
    public var inviterName: Swift.String?
    /// The identifier of the other participant who was invited to connect.
    /// This member is required.
    public var otherParticipantIdentifier: Swift.String?
    /// The type of participant (inviter or invitee) in the connection invitation.
    /// This member is required.
    public var participantType: PartnerCentralAccountClientTypes.ParticipantType?
    /// The current status of the connection invitation (canceled).
    /// This member is required.
    public var status: PartnerCentralAccountClientTypes.InvitationStatus?
    /// The timestamp when the connection invitation was last updated (canceled).
    /// This member is required.
    public var updatedAt: Foundation.Date?

    public init(
        arn: Swift.String? = nil,
        catalog: Swift.String? = nil,
        connectionId: Swift.String? = nil,
        connectionType: PartnerCentralAccountClientTypes.ConnectionType? = nil,
        createdAt: Foundation.Date? = nil,
        expiresAt: Foundation.Date? = nil,
        id: Swift.String? = nil,
        invitationMessage: Swift.String? = nil,
        inviterEmail: Swift.String? = nil,
        inviterName: Swift.String? = nil,
        otherParticipantIdentifier: Swift.String? = nil,
        participantType: PartnerCentralAccountClientTypes.ParticipantType? = nil,
        status: PartnerCentralAccountClientTypes.InvitationStatus? = nil,
        updatedAt: Foundation.Date? = nil
    ) {
        self.arn = arn
        self.catalog = catalog
        self.connectionId = connectionId
        self.connectionType = connectionType
        self.createdAt = createdAt
        self.expiresAt = expiresAt
        self.id = id
        self.invitationMessage = invitationMessage
        self.inviterEmail = inviterEmail
        self.inviterName = inviterName
        self.otherParticipantIdentifier = otherParticipantIdentifier
        self.participantType = participantType
        self.status = status
        self.updatedAt = updatedAt
    }
}

extension CancelConnectionInvitationOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CancelConnectionInvitationOutput(arn: \(Swift.String(describing: arn)), catalog: \(Swift.String(describing: catalog)), connectionId: \(Swift.String(describing: connectionId)), connectionType: \(Swift.String(describing: connectionType)), createdAt: \(Swift.String(describing: createdAt)), expiresAt: \(Swift.String(describing: expiresAt)), id: \(Swift.String(describing: id)), invitationMessage: \(Swift.String(describing: invitationMessage)), inviterEmail: \(Swift.String(describing: inviterEmail)), otherParticipantIdentifier: \(Swift.String(describing: otherParticipantIdentifier)), participantType: \(Swift.String(describing: participantType)), status: \(Swift.String(describing: status)), updatedAt: \(Swift.String(describing: updatedAt)), inviterName: \"CONTENT_REDACTED\")"}
}

public struct CancelProfileUpdateTaskInput: Swift.Sendable {
    /// The catalog identifier for the partner account.
    /// This member is required.
    public var catalog: Swift.String?
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
    public var clientToken: Swift.String?
    /// The unique identifier of the partner account.
    /// This member is required.
    public var identifier: Swift.String?
    /// The unique identifier of the profile update task to cancel.
    /// This member is required.
    public var taskId: Swift.String?

    public init(
        catalog: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        identifier: Swift.String? = nil,
        taskId: Swift.String? = nil
    ) {
        self.catalog = catalog
        self.clientToken = clientToken
        self.identifier = identifier
        self.taskId = taskId
    }
}

extension PartnerCentralAccountClientTypes {

    public enum ProfileValidationErrorReason: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case duplicateProfile
        case invalidContent
        case invalidLogo
        case invalidLogoFile
        case invalidLogoSize
        case invalidLogoUrl
        case invalidWebsiteUrl
        case sdkUnknown(Swift.String)

        public static var allCases: [ProfileValidationErrorReason] {
            return [
                .duplicateProfile,
                .invalidContent,
                .invalidLogo,
                .invalidLogoFile,
                .invalidLogoSize,
                .invalidLogoUrl,
                .invalidWebsiteUrl
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .duplicateProfile: return "DUPLICATE_PROFILE"
            case .invalidContent: return "INVALID_CONTENT"
            case .invalidLogo: return "INVALID_LOGO"
            case .invalidLogoFile: return "INVALID_LOGO_FILE"
            case .invalidLogoSize: return "INVALID_LOGO_SIZE"
            case .invalidLogoUrl: return "INVALID_LOGO_URL"
            case .invalidWebsiteUrl: return "INVALID_WEBSITE_URL"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension PartnerCentralAccountClientTypes {

    /// Contains detailed information about an error that occurred during an operation.
    public struct ErrorDetail: Swift.Sendable {
        /// The locale or language code for the error message.
        /// This member is required.
        public var locale: Swift.String?
        /// A human-readable description of the error.
        /// This member is required.
        public var message: Swift.String?
        /// A machine-readable code or reason for the error.
        /// This member is required.
        public var reason: PartnerCentralAccountClientTypes.ProfileValidationErrorReason?

        public init(
            locale: Swift.String? = nil,
            message: Swift.String? = nil,
            reason: PartnerCentralAccountClientTypes.ProfileValidationErrorReason? = nil
        ) {
            self.locale = locale
            self.message = message
            self.reason = reason
        }
    }
}

extension PartnerCentralAccountClientTypes {

    public enum ProfileTaskStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case canceled
        case failed
        case inProgress
        case succeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [ProfileTaskStatus] {
            return [
                .canceled,
                .failed,
                .inProgress,
                .succeeded
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .canceled: return "CANCELED"
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .succeeded: return "SUCCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension PartnerCentralAccountClientTypes {

    public enum IndustrySegment: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case agricultureMining
        case biotechnology
        case businessConsumerServices
        case businessServ
        case communications
        case computersElectronics
        case computerHardware
        case computerSoftware
        case consumerGoods
        case consumerRelated
        case education
        case energyUtilities
        case financialServices
        case gaming
        case government
        case governmentEducationPublicServices
        case healthcare
        case healthcarePharmaceuticalsBiotech
        case industrialEnergy
        case internetSpecific
        case lifeSciences
        case manufacturing
        case mediaEntertainment
        case mediaEntertainmentLeisure
        case medicalHealth
        case nonProfitOrganization
        case other
        case professionalServices
        case realEstateConstruction
        case retail
        case retailWholesaleDistribution
        case semiconductorElectr
        case softwareInternet
        case telecommunications
        case transportationLogistics
        case travelHospitality
        case wholesaleDistribution
        case sdkUnknown(Swift.String)

        public static var allCases: [IndustrySegment] {
            return [
                .agricultureMining,
                .biotechnology,
                .businessConsumerServices,
                .businessServ,
                .communications,
                .computersElectronics,
                .computerHardware,
                .computerSoftware,
                .consumerGoods,
                .consumerRelated,
                .education,
                .energyUtilities,
                .financialServices,
                .gaming,
                .government,
                .governmentEducationPublicServices,
                .healthcare,
                .healthcarePharmaceuticalsBiotech,
                .industrialEnergy,
                .internetSpecific,
                .lifeSciences,
                .manufacturing,
                .mediaEntertainment,
                .mediaEntertainmentLeisure,
                .medicalHealth,
                .nonProfitOrganization,
                .other,
                .professionalServices,
                .realEstateConstruction,
                .retail,
                .retailWholesaleDistribution,
                .semiconductorElectr,
                .softwareInternet,
                .telecommunications,
                .transportationLogistics,
                .travelHospitality,
                .wholesaleDistribution
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .agricultureMining: return "AGRICULTURE_MINING"
            case .biotechnology: return "BIOTECHNOLOGY"
            case .businessConsumerServices: return "BUSINESS_CONSUMER_SERVICES"
            case .businessServ: return "BUSINESS_SERV"
            case .communications: return "COMMUNICATIONS"
            case .computersElectronics: return "COMPUTERS_ELECTRONICS"
            case .computerHardware: return "COMPUTER_HARDWARE"
            case .computerSoftware: return "COMPUTER_SOFTWARE"
            case .consumerGoods: return "CONSUMER_GOODS"
            case .consumerRelated: return "CONSUMER_RELATED"
            case .education: return "EDUCATION"
            case .energyUtilities: return "ENERGY_UTILITIES"
            case .financialServices: return "FINANCIAL_SERVICES"
            case .gaming: return "GAMING"
            case .government: return "GOVERNMENT"
            case .governmentEducationPublicServices: return "GOVERNMENT_EDUCATION_PUBLIC_SERVICES"
            case .healthcare: return "HEALTHCARE"
            case .healthcarePharmaceuticalsBiotech: return "HEALTHCARE_PHARMACEUTICALS_BIOTECH"
            case .industrialEnergy: return "INDUSTRIAL_ENERGY"
            case .internetSpecific: return "INTERNET_SPECIFIC"
            case .lifeSciences: return "LIFE_SCIENCES"
            case .manufacturing: return "MANUFACTURING"
            case .mediaEntertainment: return "MEDIA_ENTERTAINMENT"
            case .mediaEntertainmentLeisure: return "MEDIA_ENTERTAINMENT_LEISURE"
            case .medicalHealth: return "MEDICAL_HEALTH"
            case .nonProfitOrganization: return "NON_PROFIT_ORGANIZATION"
            case .other: return "OTHER"
            case .professionalServices: return "PROFESSIONAL_SERVICES"
            case .realEstateConstruction: return "REAL_ESTATE_CONSTRUCTION"
            case .retail: return "RETAIL"
            case .retailWholesaleDistribution: return "RETAIL_WHOLESALE_DISTRIBUTION"
            case .semiconductorElectr: return "SEMICONDUCTOR_ELECTR"
            case .softwareInternet: return "SOFTWARE_INTERNET"
            case .telecommunications: return "TELECOMMUNICATIONS"
            case .transportationLogistics: return "TRANSPORTATION_LOGISTICS"
            case .travelHospitality: return "TRAVEL_HOSPITALITY"
            case .wholesaleDistribution: return "WHOLESALE_DISTRIBUTION"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension PartnerCentralAccountClientTypes {

    /// Contains localized content for a partner profile in a specific language or locale.
    public struct LocalizedContent: Swift.Sendable {
        /// The localized description of the partner's business and services.
        /// This member is required.
        public var description: Swift.String?
        /// The localized display name for the partner.
        /// This member is required.
        public var displayName: Swift.String?
        /// The locale or language code for the localized content.
        /// This member is required.
        public var locale: Swift.String?
        /// The URL to the partner's logo image for this locale.
        /// This member is required.
        public var logoUrl: Swift.String?
        /// The localized website URL for the partner.
        /// This member is required.
        public var websiteUrl: Swift.String?

        public init(
            description: Swift.String? = nil,
            displayName: Swift.String? = nil,
            locale: Swift.String? = nil,
            logoUrl: Swift.String? = nil,
            websiteUrl: Swift.String? = nil
        ) {
            self.description = description
            self.displayName = displayName
            self.locale = locale
            self.logoUrl = logoUrl
            self.websiteUrl = websiteUrl
        }
    }
}

extension PartnerCentralAccountClientTypes {

    public enum PrimarySolutionType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case communicationServices
        case consultingServices
        case hardwareProducts
        case managedServices
        case professionalServices
        case softwareProducts
        case trainingServices
        case valueAddedResaleAwsServices
        case sdkUnknown(Swift.String)

        public static var allCases: [PrimarySolutionType] {
            return [
                .communicationServices,
                .consultingServices,
                .hardwareProducts,
                .managedServices,
                .professionalServices,
                .softwareProducts,
                .trainingServices,
                .valueAddedResaleAwsServices
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .communicationServices: return "COMMUNICATION_SERVICES"
            case .consultingServices: return "CONSULTING_SERVICES"
            case .hardwareProducts: return "HARDWARE_PRODUCTS"
            case .managedServices: return "MANAGED_SERVICES"
            case .professionalServices: return "PROFESSIONAL_SERVICES"
            case .softwareProducts: return "SOFTWARE_PRODUCTS"
            case .trainingServices: return "TRAINING_SERVICES"
            case .valueAddedResaleAwsServices: return "VALUE_ADDED_RESALE_AWS_SERVICES"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

extension PartnerCentralAccountClientTypes {

    /// Contains detailed information about a profile update task including the changes to be made.
    public struct TaskDetails: Swift.Sendable {
        /// The updated description for the partner profile.
        /// This member is required.
        public var description: Swift.String?
        /// The updated display name for the partner profile.
        /// This member is required.
        public var displayName: Swift.String?
        /// The updated industry segments for the partner profile.
        /// This member is required.
        public var industrySegments: [PartnerCentralAccountClientTypes.IndustrySegment]?
        /// The updated localized content for the partner profile.
        public var localizedContents: [PartnerCentralAccountClientTypes.LocalizedContent]?
        /// The updated logo URL for the partner profile.
        /// This member is required.
        public var logoUrl: Swift.String?
        /// The updated primary solution type for the partner profile.
        /// This member is required.
        public var primarySolutionType: PartnerCentralAccountClientTypes.PrimarySolutionType?
        /// The updated translation source locale for the partner profile.
        /// This member is required.
        public var translationSourceLocale: Swift.String?
        /// The updated website URL for the partner profile.
        /// This member is required.
        public var websiteUrl: Swift.String?

        public init(
            description: Swift.String? = nil,
            displayName: Swift.String? = nil,
            industrySegments: [PartnerCentralAccountClientTypes.IndustrySegment]? = nil,
            localizedContents: [PartnerCentralAccountClientTypes.LocalizedContent]? = nil,
            logoUrl: Swift.String? = nil,
            primarySolutionType: PartnerCentralAccountClientTypes.PrimarySolutionType? = nil,
            translationSourceLocale: Swift.String? = nil,
            websiteUrl: Swift.String? = nil
        ) {
            self.description = description
            self.displayName = displayName
            self.industrySegments = industrySegments
            self.localizedContents = localizedContents
            self.logoUrl = logoUrl
            self.primarySolutionType = primarySolutionType
            self.translationSourceLocale = translationSourceLocale
            self.websiteUrl = websiteUrl
        }
    }
}

public struct CancelProfileUpdateTaskOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the canceled profile update task.
    /// This member is required.
    public var arn: Swift.String?
    /// The catalog identifier for the partner account.
    /// This member is required.
    public var catalog: Swift.String?
    /// The timestamp when the profile update task was ended (canceled).
    public var endedAt: Foundation.Date?
    /// A list of error details if any errors occurred during the profile update task.
    public var errorDetailList: [PartnerCentralAccountClientTypes.ErrorDetail]?
    /// The unique identifier of the partner account.
    /// This member is required.
    public var id: Swift.String?
    /// The timestamp when the profile update task was started.
    /// This member is required.
    public var startedAt: Foundation.Date?
    /// The current status of the profile update task (canceled).
    /// This member is required.
    public var status: PartnerCentralAccountClientTypes.ProfileTaskStatus?
    /// The details of the profile update task that was canceled.
    /// This member is required.
    public var taskDetails: PartnerCentralAccountClientTypes.TaskDetails?
    /// The unique identifier of the canceled profile update task.
    /// This member is required.
    public var taskId: Swift.String?

    public init(
        arn: Swift.String? = nil,
        catalog: Swift.String? = nil,
        endedAt: Foundation.Date? = nil,
        errorDetailList: [PartnerCentralAccountClientTypes.ErrorDetail]? = nil,
        id: Swift.String? = nil,
        startedAt: Foundation.Date? = nil,
        status: PartnerCentralAccountClientTypes.ProfileTaskStatus? = nil,
        taskDetails: PartnerCentralAccountClientTypes.TaskDetails? = nil,
        taskId: Swift.String? = nil
    ) {
        self.arn = arn
        self.catalog = catalog
        self.endedAt = endedAt
        self.errorDetailList = errorDetailList
        self.id = id
        self.startedAt = startedAt
        self.status = status
        self.taskDetails = taskDetails
        self.taskId = taskId
    }
}

public struct CreateConnectionInvitationInput: Swift.Sendable {
    /// The catalog identifier where the connection invitation will be created.
    /// This member is required.
    public var catalog: Swift.String?
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
    /// This member is required.
    public var clientToken: Swift.String?
    /// The type of connection being requested (e.g., reseller, distributor, technology partner).
    /// This member is required.
    public var connectionType: PartnerCentralAccountClientTypes.ConnectionType?
    /// The email address of the person to send the connection invitation to.
    /// This member is required.
    public var email: Swift.String?
    /// A custom message to include with the connection invitation.
    /// This member is required.
    public var message: Swift.String?
    /// The name of the person sending the connection invitation.
    /// This member is required.
    public var name: Swift.String?
    /// The identifier of the organization or partner to invite for connection.
    /// This member is required.
    public var receiverIdentifier: Swift.String?

    public init(
        catalog: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        connectionType: PartnerCentralAccountClientTypes.ConnectionType? = nil,
        email: Swift.String? = nil,
        message: Swift.String? = nil,
        name: Swift.String? = nil,
        receiverIdentifier: Swift.String? = nil
    ) {
        self.catalog = catalog
        self.clientToken = clientToken
        self.connectionType = connectionType
        self.email = email
        self.message = message
        self.name = name
        self.receiverIdentifier = receiverIdentifier
    }
}

extension CreateConnectionInvitationInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateConnectionInvitationInput(catalog: \(Swift.String(describing: catalog)), clientToken: \(Swift.String(describing: clientToken)), connectionType: \(Swift.String(describing: connectionType)), email: \(Swift.String(describing: email)), message: \(Swift.String(describing: message)), receiverIdentifier: \(Swift.String(describing: receiverIdentifier)), name: \"CONTENT_REDACTED\")"}
}

public struct CreateConnectionInvitationOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the created connection invitation.
    /// This member is required.
    public var arn: Swift.String?
    /// The catalog identifier where the connection invitation was created.
    /// This member is required.
    public var catalog: Swift.String?
    /// The identifier of the connection associated with this invitation.
    public var connectionId: Swift.String?
    /// The type of connection being requested in the invitation.
    /// This member is required.
    public var connectionType: PartnerCentralAccountClientTypes.ConnectionType?
    /// The timestamp when the connection invitation was created.
    /// This member is required.
    public var createdAt: Foundation.Date?
    /// The timestamp when the connection invitation will expire if not responded to.
    public var expiresAt: Foundation.Date?
    /// The unique identifier of the created connection invitation.
    /// This member is required.
    public var id: Swift.String?
    /// The custom message included with the connection invitation.
    /// This member is required.
    public var invitationMessage: Swift.String?
    /// The email address of the person who sent the connection invitation.
    /// This member is required.
    public var inviterEmail: Swift.String?
    /// The name of the person who sent the connection invitation.
    /// This member is required.
    public var inviterName: Swift.String?
    /// The identifier of the organization or partner being invited.
    /// This member is required.
    public var otherParticipantIdentifier: Swift.String?
    /// The type of participant (inviter or invitee) in the connection invitation.
    /// This member is required.
    public var participantType: PartnerCentralAccountClientTypes.ParticipantType?
    /// The current status of the connection invitation (pending, accepted, rejected, etc.).
    /// This member is required.
    public var status: PartnerCentralAccountClientTypes.InvitationStatus?
    /// The timestamp when the connection invitation was last updated.
    /// This member is required.
    public var updatedAt: Foundation.Date?

    public init(
        arn: Swift.String? = nil,
        catalog: Swift.String? = nil,
        connectionId: Swift.String? = nil,
        connectionType: PartnerCentralAccountClientTypes.ConnectionType? = nil,
        createdAt: Foundation.Date? = nil,
        expiresAt: Foundation.Date? = nil,
        id: Swift.String? = nil,
        invitationMessage: Swift.String? = nil,
        inviterEmail: Swift.String? = nil,
        inviterName: Swift.String? = nil,
        otherParticipantIdentifier: Swift.String? = nil,
        participantType: PartnerCentralAccountClientTypes.ParticipantType? = nil,
        status: PartnerCentralAccountClientTypes.InvitationStatus? = nil,
        updatedAt: Foundation.Date? = nil
    ) {
        self.arn = arn
        self.catalog = catalog
        self.connectionId = connectionId
        self.connectionType = connectionType
        self.createdAt = createdAt
        self.expiresAt = expiresAt
        self.id = id
        self.invitationMessage = invitationMessage
        self.inviterEmail = inviterEmail
        self.inviterName = inviterName
        self.otherParticipantIdentifier = otherParticipantIdentifier
        self.participantType = participantType
        self.status = status
        self.updatedAt = updatedAt
    }
}

extension CreateConnectionInvitationOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreateConnectionInvitationOutput(arn: \(Swift.String(describing: arn)), catalog: \(Swift.String(describing: catalog)), connectionId: \(Swift.String(describing: connectionId)), connectionType: \(Swift.String(describing: connectionType)), createdAt: \(Swift.String(describing: createdAt)), expiresAt: \(Swift.String(describing: expiresAt)), id: \(Swift.String(describing: id)), invitationMessage: \(Swift.String(describing: invitationMessage)), inviterEmail: \(Swift.String(describing: inviterEmail)), otherParticipantIdentifier: \(Swift.String(describing: otherParticipantIdentifier)), participantType: \(Swift.String(describing: participantType)), status: \(Swift.String(describing: status)), updatedAt: \(Swift.String(describing: updatedAt)), inviterName: \"CONTENT_REDACTED\")"}
}

public struct GetConnectionInvitationInput: Swift.Sendable {
    /// The catalog identifier where the connection invitation exists.
    /// This member is required.
    public var catalog: Swift.String?
    /// The unique identifier of the connection invitation to retrieve.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        catalog: Swift.String? = nil,
        identifier: Swift.String? = nil
    ) {
        self.catalog = catalog
        self.identifier = identifier
    }
}

public struct GetConnectionInvitationOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the connection invitation.
    /// This member is required.
    public var arn: Swift.String?
    /// The catalog identifier where the connection invitation exists.
    /// This member is required.
    public var catalog: Swift.String?
    /// The identifier of the connection associated with this invitation.
    public var connectionId: Swift.String?
    /// The type of connection being requested in the invitation.
    /// This member is required.
    public var connectionType: PartnerCentralAccountClientTypes.ConnectionType?
    /// The timestamp when the connection invitation was created.
    /// This member is required.
    public var createdAt: Foundation.Date?
    /// The timestamp when the connection invitation will expire.
    public var expiresAt: Foundation.Date?
    /// The unique identifier of the connection invitation.
    /// This member is required.
    public var id: Swift.String?
    /// The custom message included with the connection invitation.
    /// This member is required.
    public var invitationMessage: Swift.String?
    /// The email address of the person who sent the connection invitation.
    /// This member is required.
    public var inviterEmail: Swift.String?
    /// The name of the person who sent the connection invitation.
    /// This member is required.
    public var inviterName: Swift.String?
    /// The identifier of the other participant in the connection invitation.
    /// This member is required.
    public var otherParticipantIdentifier: Swift.String?
    /// The type of participant (inviter or invitee) in the connection invitation.
    /// This member is required.
    public var participantType: PartnerCentralAccountClientTypes.ParticipantType?
    /// The current status of the connection invitation.
    /// This member is required.
    public var status: PartnerCentralAccountClientTypes.InvitationStatus?
    /// The timestamp when the connection invitation was last updated.
    /// This member is required.
    public var updatedAt: Foundation.Date?

    public init(
        arn: Swift.String? = nil,
        catalog: Swift.String? = nil,
        connectionId: Swift.String? = nil,
        connectionType: PartnerCentralAccountClientTypes.ConnectionType? = nil,
        createdAt: Foundation.Date? = nil,
        expiresAt: Foundation.Date? = nil,
        id: Swift.String? = nil,
        invitationMessage: Swift.String? = nil,
        inviterEmail: Swift.String? = nil,
        inviterName: Swift.String? = nil,
        otherParticipantIdentifier: Swift.String? = nil,
        participantType: PartnerCentralAccountClientTypes.ParticipantType? = nil,
        status: PartnerCentralAccountClientTypes.InvitationStatus? = nil,
        updatedAt: Foundation.Date? = nil
    ) {
        self.arn = arn
        self.catalog = catalog
        self.connectionId = connectionId
        self.connectionType = connectionType
        self.createdAt = createdAt
        self.expiresAt = expiresAt
        self.id = id
        self.invitationMessage = invitationMessage
        self.inviterEmail = inviterEmail
        self.inviterName = inviterName
        self.otherParticipantIdentifier = otherParticipantIdentifier
        self.participantType = participantType
        self.status = status
        self.updatedAt = updatedAt
    }
}

extension GetConnectionInvitationOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetConnectionInvitationOutput(arn: \(Swift.String(describing: arn)), catalog: \(Swift.String(describing: catalog)), connectionId: \(Swift.String(describing: connectionId)), connectionType: \(Swift.String(describing: connectionType)), createdAt: \(Swift.String(describing: createdAt)), expiresAt: \(Swift.String(describing: expiresAt)), id: \(Swift.String(describing: id)), invitationMessage: \(Swift.String(describing: invitationMessage)), inviterEmail: \(Swift.String(describing: inviterEmail)), otherParticipantIdentifier: \(Swift.String(describing: otherParticipantIdentifier)), participantType: \(Swift.String(describing: participantType)), status: \(Swift.String(describing: status)), updatedAt: \(Swift.String(describing: updatedAt)), inviterName: \"CONTENT_REDACTED\")"}
}

public struct ListConnectionInvitationsInput: Swift.Sendable {
    /// The catalog identifier for the partner account.
    /// This member is required.
    public var catalog: Swift.String?
    /// Filter results by connection type (e.g., reseller, distributor, technology partner).
    public var connectionType: PartnerCentralAccountClientTypes.ConnectionType?
    /// The maximum number of connection invitations to return in a single response.
    public var maxResults: Swift.Int?
    /// The token for retrieving the next page of results in paginated responses.
    public var nextToken: Swift.String?
    /// Filter results by specific participant identifiers.
    public var otherParticipantIdentifiers: [Swift.String]?
    /// Filter results by participant type (inviter or invitee).
    public var participantType: PartnerCentralAccountClientTypes.ParticipantType?
    /// Filter results by invitation status (pending, accepted, rejected, canceled, expired).
    public var status: PartnerCentralAccountClientTypes.InvitationStatus?

    public init(
        catalog: Swift.String? = nil,
        connectionType: PartnerCentralAccountClientTypes.ConnectionType? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        otherParticipantIdentifiers: [Swift.String]? = nil,
        participantType: PartnerCentralAccountClientTypes.ParticipantType? = nil,
        status: PartnerCentralAccountClientTypes.InvitationStatus? = nil
    ) {
        self.catalog = catalog
        self.connectionType = connectionType
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.otherParticipantIdentifiers = otherParticipantIdentifiers
        self.participantType = participantType
        self.status = status
    }
}

extension PartnerCentralAccountClientTypes {

    /// A summary view of a connection invitation containing key information without full details.
    public struct ConnectionInvitationSummary: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the connection invitation.
        /// This member is required.
        public var arn: Swift.String?
        /// The catalog identifier where the connection invitation exists.
        /// This member is required.
        public var catalog: Swift.String?
        /// The identifier of the connection associated with this invitation.
        public var connectionId: Swift.String?
        /// The type of connection being requested in the invitation.
        /// This member is required.
        public var connectionType: PartnerCentralAccountClientTypes.ConnectionType?
        /// The timestamp when the connection invitation was created.
        /// This member is required.
        public var createdAt: Foundation.Date?
        /// The timestamp when the connection invitation will expire.
        public var expiresAt: Foundation.Date?
        /// The unique identifier of the connection invitation.
        /// This member is required.
        public var id: Swift.String?
        /// The identifier of the other participant in the connection invitation.
        /// This member is required.
        public var otherParticipantIdentifier: Swift.String?
        /// The type of participant (inviter or invitee) in the connection invitation.
        /// This member is required.
        public var participantType: PartnerCentralAccountClientTypes.ParticipantType?
        /// The current status of the connection invitation.
        /// This member is required.
        public var status: PartnerCentralAccountClientTypes.InvitationStatus?
        /// The timestamp when the connection invitation was last updated.
        /// This member is required.
        public var updatedAt: Foundation.Date?

        public init(
            arn: Swift.String? = nil,
            catalog: Swift.String? = nil,
            connectionId: Swift.String? = nil,
            connectionType: PartnerCentralAccountClientTypes.ConnectionType? = nil,
            createdAt: Foundation.Date? = nil,
            expiresAt: Foundation.Date? = nil,
            id: Swift.String? = nil,
            otherParticipantIdentifier: Swift.String? = nil,
            participantType: PartnerCentralAccountClientTypes.ParticipantType? = nil,
            status: PartnerCentralAccountClientTypes.InvitationStatus? = nil,
            updatedAt: Foundation.Date? = nil
        ) {
            self.arn = arn
            self.catalog = catalog
            self.connectionId = connectionId
            self.connectionType = connectionType
            self.createdAt = createdAt
            self.expiresAt = expiresAt
            self.id = id
            self.otherParticipantIdentifier = otherParticipantIdentifier
            self.participantType = participantType
            self.status = status
            self.updatedAt = updatedAt
        }
    }
}

public struct ListConnectionInvitationsOutput: Swift.Sendable {
    /// A list of connection invitation summaries matching the specified criteria.
    /// This member is required.
    public var connectionInvitationSummaries: [PartnerCentralAccountClientTypes.ConnectionInvitationSummary]?
    /// The token for retrieving the next page of results if more results are available.
    public var nextToken: Swift.String?

    public init(
        connectionInvitationSummaries: [PartnerCentralAccountClientTypes.ConnectionInvitationSummary]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.connectionInvitationSummaries = connectionInvitationSummaries
        self.nextToken = nextToken
    }
}

public struct RejectConnectionInvitationInput: Swift.Sendable {
    /// The catalog identifier where the connection invitation exists.
    /// This member is required.
    public var catalog: Swift.String?
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
    /// This member is required.
    public var clientToken: Swift.String?
    /// The unique identifier of the connection invitation to reject.
    /// This member is required.
    public var identifier: Swift.String?
    /// The reason for rejecting the connection invitation.
    public var reason: Swift.String?

    public init(
        catalog: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        identifier: Swift.String? = nil,
        reason: Swift.String? = nil
    ) {
        self.catalog = catalog
        self.clientToken = clientToken
        self.identifier = identifier
        self.reason = reason
    }
}

public struct RejectConnectionInvitationOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the rejected connection invitation.
    /// This member is required.
    public var arn: Swift.String?
    /// The catalog identifier where the connection invitation was rejected.
    /// This member is required.
    public var catalog: Swift.String?
    /// The identifier of the connection associated with the rejected invitation.
    public var connectionId: Swift.String?
    /// The type of connection that was being invited for.
    /// This member is required.
    public var connectionType: PartnerCentralAccountClientTypes.ConnectionType?
    /// The timestamp when the connection invitation was originally created.
    /// This member is required.
    public var createdAt: Foundation.Date?
    /// The timestamp when the connection invitation would have expired.
    public var expiresAt: Foundation.Date?
    /// The unique identifier of the rejected connection invitation.
    /// This member is required.
    public var id: Swift.String?
    /// The message that was included with the original connection invitation.
    /// This member is required.
    public var invitationMessage: Swift.String?
    /// The email address of the person who sent the connection invitation.
    /// This member is required.
    public var inviterEmail: Swift.String?
    /// The name of the person who sent the connection invitation.
    /// This member is required.
    public var inviterName: Swift.String?
    /// The identifier of the other participant who sent the invitation.
    /// This member is required.
    public var otherParticipantIdentifier: Swift.String?
    /// The type of participant (inviter or invitee) in the connection invitation.
    /// This member is required.
    public var participantType: PartnerCentralAccountClientTypes.ParticipantType?
    /// The current status of the connection invitation (rejected).
    /// This member is required.
    public var status: PartnerCentralAccountClientTypes.InvitationStatus?
    /// The timestamp when the connection invitation was last updated (rejected).
    /// This member is required.
    public var updatedAt: Foundation.Date?

    public init(
        arn: Swift.String? = nil,
        catalog: Swift.String? = nil,
        connectionId: Swift.String? = nil,
        connectionType: PartnerCentralAccountClientTypes.ConnectionType? = nil,
        createdAt: Foundation.Date? = nil,
        expiresAt: Foundation.Date? = nil,
        id: Swift.String? = nil,
        invitationMessage: Swift.String? = nil,
        inviterEmail: Swift.String? = nil,
        inviterName: Swift.String? = nil,
        otherParticipantIdentifier: Swift.String? = nil,
        participantType: PartnerCentralAccountClientTypes.ParticipantType? = nil,
        status: PartnerCentralAccountClientTypes.InvitationStatus? = nil,
        updatedAt: Foundation.Date? = nil
    ) {
        self.arn = arn
        self.catalog = catalog
        self.connectionId = connectionId
        self.connectionType = connectionType
        self.createdAt = createdAt
        self.expiresAt = expiresAt
        self.id = id
        self.invitationMessage = invitationMessage
        self.inviterEmail = inviterEmail
        self.inviterName = inviterName
        self.otherParticipantIdentifier = otherParticipantIdentifier
        self.participantType = participantType
        self.status = status
        self.updatedAt = updatedAt
    }
}

extension RejectConnectionInvitationOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "RejectConnectionInvitationOutput(arn: \(Swift.String(describing: arn)), catalog: \(Swift.String(describing: catalog)), connectionId: \(Swift.String(describing: connectionId)), connectionType: \(Swift.String(describing: connectionType)), createdAt: \(Swift.String(describing: createdAt)), expiresAt: \(Swift.String(describing: expiresAt)), id: \(Swift.String(describing: id)), invitationMessage: \(Swift.String(describing: invitationMessage)), inviterEmail: \(Swift.String(describing: inviterEmail)), otherParticipantIdentifier: \(Swift.String(describing: otherParticipantIdentifier)), participantType: \(Swift.String(describing: participantType)), status: \(Swift.String(describing: status)), updatedAt: \(Swift.String(describing: updatedAt)), inviterName: \"CONTENT_REDACTED\")"}
}

public struct GetConnectionPreferencesInput: Swift.Sendable {
    /// The catalog identifier for the partner account.
    /// This member is required.
    public var catalog: Swift.String?

    public init(
        catalog: Swift.String? = nil
    ) {
        self.catalog = catalog
    }
}

public struct GetConnectionPreferencesOutput: Swift.Sendable {
    /// The access type setting for connections (e.g., open, restricted, invitation-only).
    /// This member is required.
    public var accessType: PartnerCentralAccountClientTypes.AccessType?
    /// The Amazon Resource Name (ARN) of the connection preferences.
    /// This member is required.
    public var arn: Swift.String?
    /// The catalog identifier for the partner account.
    /// This member is required.
    public var catalog: Swift.String?
    /// A list of participant IDs that are excluded from connection requests or interactions.
    public var excludedParticipantIds: [Swift.String]?
    /// The revision number of the connection preferences for optimistic locking.
    /// This member is required.
    public var revision: Swift.Int?
    /// The timestamp when the connection preferences were last updated.
    /// This member is required.
    public var updatedAt: Foundation.Date?

    public init(
        accessType: PartnerCentralAccountClientTypes.AccessType? = nil,
        arn: Swift.String? = nil,
        catalog: Swift.String? = nil,
        excludedParticipantIds: [Swift.String]? = nil,
        revision: Swift.Int? = nil,
        updatedAt: Foundation.Date? = nil
    ) {
        self.accessType = accessType
        self.arn = arn
        self.catalog = catalog
        self.excludedParticipantIds = excludedParticipantIds
        self.revision = revision
        self.updatedAt = updatedAt
    }
}

public struct UpdateConnectionPreferencesInput: Swift.Sendable {
    /// The access type setting for connections (e.g., open, restricted, invitation-only).
    /// This member is required.
    public var accessType: PartnerCentralAccountClientTypes.AccessType?
    /// The catalog identifier for the partner account.
    /// This member is required.
    public var catalog: Swift.String?
    /// The updated list of participant identifiers to exclude from connections.
    public var excludedParticipantIdentifiers: [Swift.String]?
    /// The revision number of the connection preferences for optimistic locking.
    /// This member is required.
    public var revision: Swift.Int?

    public init(
        accessType: PartnerCentralAccountClientTypes.AccessType? = nil,
        catalog: Swift.String? = nil,
        excludedParticipantIdentifiers: [Swift.String]? = nil,
        revision: Swift.Int? = nil
    ) {
        self.accessType = accessType
        self.catalog = catalog
        self.excludedParticipantIdentifiers = excludedParticipantIdentifiers
        self.revision = revision
    }
}

public struct UpdateConnectionPreferencesOutput: Swift.Sendable {
    /// The updated access type setting for connections.
    /// This member is required.
    public var accessType: PartnerCentralAccountClientTypes.AccessType?
    /// The Amazon Resource Name (ARN) of the updated connection preferences.
    /// This member is required.
    public var arn: Swift.String?
    /// The catalog identifier for the partner account.
    /// This member is required.
    public var catalog: Swift.String?
    /// A list of participant IDs that are excluded from connection requests or interactions.
    public var excludedParticipantIds: [Swift.String]?
    /// The updated revision number of the connection preferences.
    /// This member is required.
    public var revision: Swift.Int?
    /// The timestamp when the connection preferences were last updated.
    /// This member is required.
    public var updatedAt: Foundation.Date?

    public init(
        accessType: PartnerCentralAccountClientTypes.AccessType? = nil,
        arn: Swift.String? = nil,
        catalog: Swift.String? = nil,
        excludedParticipantIds: [Swift.String]? = nil,
        revision: Swift.Int? = nil,
        updatedAt: Foundation.Date? = nil
    ) {
        self.accessType = accessType
        self.arn = arn
        self.catalog = catalog
        self.excludedParticipantIds = excludedParticipantIds
        self.revision = revision
        self.updatedAt = updatedAt
    }
}

public struct GetConnectionInput: Swift.Sendable {
    /// The catalog identifier where the connection exists.
    /// This member is required.
    public var catalog: Swift.String?
    /// The unique identifier of the connection to retrieve.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        catalog: Swift.String? = nil,
        identifier: Swift.String? = nil
    ) {
        self.catalog = catalog
        self.identifier = identifier
    }
}

public struct GetConnectionOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the connection.
    /// This member is required.
    public var arn: Swift.String?
    /// The catalog identifier where the connection exists.
    /// This member is required.
    public var catalog: Swift.String?
    /// The list of connection types active between the partners.
    /// This member is required.
    public var connectionTypes: [Swift.String: PartnerCentralAccountClientTypes.ConnectionTypeDetail]?
    /// The unique identifier of the connection.
    /// This member is required.
    public var id: Swift.String?
    /// The AWS account ID of the other participant in the connection.
    /// This member is required.
    public var otherParticipantAccountId: Swift.String?
    /// The timestamp when the connection was last updated.
    /// This member is required.
    public var updatedAt: Foundation.Date?

    public init(
        arn: Swift.String? = nil,
        catalog: Swift.String? = nil,
        connectionTypes: [Swift.String: PartnerCentralAccountClientTypes.ConnectionTypeDetail]? = nil,
        id: Swift.String? = nil,
        otherParticipantAccountId: Swift.String? = nil,
        updatedAt: Foundation.Date? = nil
    ) {
        self.arn = arn
        self.catalog = catalog
        self.connectionTypes = connectionTypes
        self.id = id
        self.otherParticipantAccountId = otherParticipantAccountId
        self.updatedAt = updatedAt
    }
}

public struct ListConnectionsInput: Swift.Sendable {
    /// The catalog identifier for the partner account.
    /// This member is required.
    public var catalog: Swift.String?
    /// Filter results by connection type (e.g., reseller, distributor, technology partner).
    public var connectionType: Swift.String?
    /// The maximum number of connections to return in a single response.
    public var maxResults: Swift.Int?
    /// The token for retrieving the next page of results in paginated responses.
    public var nextToken: Swift.String?
    /// Filter results by specific participant identifiers.
    public var otherParticipantIdentifiers: [Swift.String]?

    public init(
        catalog: Swift.String? = nil,
        connectionType: Swift.String? = nil,
        maxResults: Swift.Int? = nil,
        nextToken: Swift.String? = nil,
        otherParticipantIdentifiers: [Swift.String]? = nil
    ) {
        self.catalog = catalog
        self.connectionType = connectionType
        self.maxResults = maxResults
        self.nextToken = nextToken
        self.otherParticipantIdentifiers = otherParticipantIdentifiers
    }
}

extension PartnerCentralAccountClientTypes {

    /// Summary information about a specific connection type between partners.
    public struct ConnectionTypeSummary: Swift.Sendable {
        /// Information about the other participant in this connection type.
        /// This member is required.
        public var otherParticipant: PartnerCentralAccountClientTypes.Participant?
        /// The current status of this connection type (active, canceled, etc.).
        /// This member is required.
        public var status: PartnerCentralAccountClientTypes.ConnectionTypeStatus?

        public init(
            otherParticipant: PartnerCentralAccountClientTypes.Participant? = nil,
            status: PartnerCentralAccountClientTypes.ConnectionTypeStatus? = nil
        ) {
            self.otherParticipant = otherParticipant
            self.status = status
        }
    }
}

extension PartnerCentralAccountClientTypes {

    /// A summary view of an active connection between partners containing key information.
    public struct ConnectionSummary: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the connection.
        /// This member is required.
        public var arn: Swift.String?
        /// The catalog identifier where the connection exists.
        /// This member is required.
        public var catalog: Swift.String?
        /// A map of connection types and their summary information for this connection.
        /// This member is required.
        public var connectionTypes: [Swift.String: PartnerCentralAccountClientTypes.ConnectionTypeSummary]?
        /// The unique identifier of the connection.
        /// This member is required.
        public var id: Swift.String?
        /// The AWS account ID of the other participant in the connection.
        /// This member is required.
        public var otherParticipantAccountId: Swift.String?
        /// The timestamp when the connection was last updated.
        /// This member is required.
        public var updatedAt: Foundation.Date?

        public init(
            arn: Swift.String? = nil,
            catalog: Swift.String? = nil,
            connectionTypes: [Swift.String: PartnerCentralAccountClientTypes.ConnectionTypeSummary]? = nil,
            id: Swift.String? = nil,
            otherParticipantAccountId: Swift.String? = nil,
            updatedAt: Foundation.Date? = nil
        ) {
            self.arn = arn
            self.catalog = catalog
            self.connectionTypes = connectionTypes
            self.id = id
            self.otherParticipantAccountId = otherParticipantAccountId
            self.updatedAt = updatedAt
        }
    }
}

public struct ListConnectionsOutput: Swift.Sendable {
    /// A list of connection summaries matching the specified criteria.
    /// This member is required.
    public var connectionSummaries: [PartnerCentralAccountClientTypes.ConnectionSummary]?
    /// The token for retrieving the next page of results if more results are available.
    public var nextToken: Swift.String?

    public init(
        connectionSummaries: [PartnerCentralAccountClientTypes.ConnectionSummary]? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.connectionSummaries = connectionSummaries
        self.nextToken = nextToken
    }
}

extension PartnerCentralAccountClientTypes {

    /// A key-value pair used to associate metadata with AWS Partner Central Account resources.
    public struct Tag: Swift.Sendable {
        /// The key name of the tag. Tag keys are case-sensitive.
        /// This member is required.
        public var key: Swift.String?
        /// The value associated with the tag key. Tag values are case-sensitive.
        /// This member is required.
        public var value: Swift.String?

        public init(
            key: Swift.String? = nil,
            value: Swift.String? = nil
        ) {
            self.key = key
            self.value = value
        }
    }
}

public struct CreatePartnerInput: Swift.Sendable {
    /// The primary contact person for alliance and partnership matters.
    /// This member is required.
    public var allianceLeadContact: PartnerCentralAccountClientTypes.AllianceLeadContact?
    /// The catalog identifier where the partner account will be created.
    /// This member is required.
    public var catalog: Swift.String?
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
    public var clientToken: Swift.String?
    /// The verification code sent to the alliance lead contact's email to confirm account creation.
    /// This member is required.
    public var emailVerificationCode: Swift.String?
    /// The legal name of the organization becoming a partner.
    /// This member is required.
    public var legalName: Swift.String?
    /// The primary type of solution or service the partner provides (e.g., consulting, software, managed services).
    /// This member is required.
    public var primarySolutionType: PartnerCentralAccountClientTypes.PrimarySolutionType?
    /// A list of tags to associate with the partner account for organization and billing purposes.
    public var tags: [PartnerCentralAccountClientTypes.Tag]?

    public init(
        allianceLeadContact: PartnerCentralAccountClientTypes.AllianceLeadContact? = nil,
        catalog: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        emailVerificationCode: Swift.String? = nil,
        legalName: Swift.String? = nil,
        primarySolutionType: PartnerCentralAccountClientTypes.PrimarySolutionType? = nil,
        tags: [PartnerCentralAccountClientTypes.Tag]? = nil
    ) {
        self.allianceLeadContact = allianceLeadContact
        self.catalog = catalog
        self.clientToken = clientToken
        self.emailVerificationCode = emailVerificationCode
        self.legalName = legalName
        self.primarySolutionType = primarySolutionType
        self.tags = tags
    }
}

extension CreatePartnerInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreatePartnerInput(allianceLeadContact: \(Swift.String(describing: allianceLeadContact)), catalog: \(Swift.String(describing: catalog)), clientToken: \(Swift.String(describing: clientToken)), primarySolutionType: \(Swift.String(describing: primarySolutionType)), tags: \(Swift.String(describing: tags)), emailVerificationCode: \"CONTENT_REDACTED\", legalName: \"CONTENT_REDACTED\")"}
}

extension PartnerCentralAccountClientTypes {

    /// Represents a verified domain associated with a partner account.
    public struct PartnerDomain: Swift.Sendable {
        /// The domain name that has been verified for the partner account.
        /// This member is required.
        public var domainName: Swift.String?
        /// The timestamp when the domain was registered and verified for the partner account.
        /// This member is required.
        public var registeredAt: Foundation.Date?

        public init(
            domainName: Swift.String? = nil,
            registeredAt: Foundation.Date? = nil
        ) {
            self.domainName = domainName
            self.registeredAt = registeredAt
        }
    }
}

extension PartnerCentralAccountClientTypes {

    /// Contains comprehensive profile information for a partner including public-facing details.
    public struct PartnerProfile: Swift.Sendable {
        /// A description of the partner's business, services, and capabilities.
        /// This member is required.
        public var description: Swift.String?
        /// The public display name for the partner organization.
        /// This member is required.
        public var displayName: Swift.String?
        /// The industry segments or verticals that the partner serves.
        /// This member is required.
        public var industrySegments: [PartnerCentralAccountClientTypes.IndustrySegment]?
        /// A list of localized content versions for different languages and regions.
        public var localizedContents: [PartnerCentralAccountClientTypes.LocalizedContent]?
        /// The URL to the partner's logo image.
        /// This member is required.
        public var logoUrl: Swift.String?
        /// The primary type of solution or service the partner provides.
        /// This member is required.
        public var primarySolutionType: PartnerCentralAccountClientTypes.PrimarySolutionType?
        /// The unique identifier of the partner profile.
        public var profileId: Swift.String?
        /// The source locale used for automatic translation of profile content.
        /// This member is required.
        public var translationSourceLocale: Swift.String?
        /// The partner's primary website URL.
        /// This member is required.
        public var websiteUrl: Swift.String?

        public init(
            description: Swift.String? = nil,
            displayName: Swift.String? = nil,
            industrySegments: [PartnerCentralAccountClientTypes.IndustrySegment]? = nil,
            localizedContents: [PartnerCentralAccountClientTypes.LocalizedContent]? = nil,
            logoUrl: Swift.String? = nil,
            primarySolutionType: PartnerCentralAccountClientTypes.PrimarySolutionType? = nil,
            profileId: Swift.String? = nil,
            translationSourceLocale: Swift.String? = nil,
            websiteUrl: Swift.String? = nil
        ) {
            self.description = description
            self.displayName = displayName
            self.industrySegments = industrySegments
            self.localizedContents = localizedContents
            self.logoUrl = logoUrl
            self.primarySolutionType = primarySolutionType
            self.profileId = profileId
            self.translationSourceLocale = translationSourceLocale
            self.websiteUrl = websiteUrl
        }
    }
}

public struct CreatePartnerOutput: Swift.Sendable {
    /// The alliance lead contact information for the partner account.
    /// This member is required.
    public var allianceLeadContact: PartnerCentralAccountClientTypes.AllianceLeadContact?
    /// The Amazon Resource Name (ARN) of the created partner account.
    /// This member is required.
    public var arn: Swift.String?
    /// The list of verified email domains associated with AWS training and certification credentials for the partner organization.
    public var awsTrainingCertificationEmailDomains: [PartnerCentralAccountClientTypes.PartnerDomain]?
    /// The catalog identifier where the partner account was created.
    /// This member is required.
    public var catalog: Swift.String?
    /// The timestamp when the partner account was created.
    /// This member is required.
    public var createdAt: Foundation.Date?
    /// The unique identifier of the created partner account.
    /// This member is required.
    public var id: Swift.String?
    /// The legal name of the partner organization.
    /// This member is required.
    public var legalName: Swift.String?
    /// The partner profile information including display name, description, and other public details.
    /// This member is required.
    public var profile: PartnerCentralAccountClientTypes.PartnerProfile?

    public init(
        allianceLeadContact: PartnerCentralAccountClientTypes.AllianceLeadContact? = nil,
        arn: Swift.String? = nil,
        awsTrainingCertificationEmailDomains: [PartnerCentralAccountClientTypes.PartnerDomain]? = nil,
        catalog: Swift.String? = nil,
        createdAt: Foundation.Date? = nil,
        id: Swift.String? = nil,
        legalName: Swift.String? = nil,
        profile: PartnerCentralAccountClientTypes.PartnerProfile? = nil
    ) {
        self.allianceLeadContact = allianceLeadContact
        self.arn = arn
        self.awsTrainingCertificationEmailDomains = awsTrainingCertificationEmailDomains
        self.catalog = catalog
        self.createdAt = createdAt
        self.id = id
        self.legalName = legalName
        self.profile = profile
    }
}

extension CreatePartnerOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "CreatePartnerOutput(allianceLeadContact: \(Swift.String(describing: allianceLeadContact)), arn: \(Swift.String(describing: arn)), awsTrainingCertificationEmailDomains: \(Swift.String(describing: awsTrainingCertificationEmailDomains)), catalog: \(Swift.String(describing: catalog)), createdAt: \(Swift.String(describing: createdAt)), id: \(Swift.String(describing: id)), profile: \(Swift.String(describing: profile)), legalName: \"CONTENT_REDACTED\")"}
}

public struct DisassociateAwsTrainingCertificationEmailDomainInput: Swift.Sendable {
    /// The catalog identifier for the partner account.
    /// This member is required.
    public var catalog: Swift.String?
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
    public var clientToken: Swift.String?
    /// The domain name to disassociate from AWS training and certification.
    /// This member is required.
    public var domainName: Swift.String?
    /// The unique identifier of the partner account.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        catalog: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        domainName: Swift.String? = nil,
        identifier: Swift.String? = nil
    ) {
        self.catalog = catalog
        self.clientToken = clientToken
        self.domainName = domainName
        self.identifier = identifier
    }
}

public struct DisassociateAwsTrainingCertificationEmailDomainOutput: Swift.Sendable {

    public init() { }
}

public struct GetAllianceLeadContactInput: Swift.Sendable {
    /// The catalog identifier for the partner account.
    /// This member is required.
    public var catalog: Swift.String?
    /// The unique identifier of the partner account.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        catalog: Swift.String? = nil,
        identifier: Swift.String? = nil
    ) {
        self.catalog = catalog
        self.identifier = identifier
    }
}

public struct GetAllianceLeadContactOutput: Swift.Sendable {
    /// The alliance lead contact information including name, email, and business title.
    /// This member is required.
    public var allianceLeadContact: PartnerCentralAccountClientTypes.AllianceLeadContact?
    /// The Amazon Resource Name (ARN) of the partner account.
    /// This member is required.
    public var arn: Swift.String?
    /// The catalog identifier for the partner account.
    /// This member is required.
    public var catalog: Swift.String?
    /// The unique identifier of the partner account.
    /// This member is required.
    public var id: Swift.String?

    public init(
        allianceLeadContact: PartnerCentralAccountClientTypes.AllianceLeadContact? = nil,
        arn: Swift.String? = nil,
        catalog: Swift.String? = nil,
        id: Swift.String? = nil
    ) {
        self.allianceLeadContact = allianceLeadContact
        self.arn = arn
        self.catalog = catalog
        self.id = id
    }
}

public struct GetPartnerInput: Swift.Sendable {
    /// The catalog identifier for the partner account.
    /// This member is required.
    public var catalog: Swift.String?
    /// The unique identifier of the partner account to retrieve.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        catalog: Swift.String? = nil,
        identifier: Swift.String? = nil
    ) {
        self.catalog = catalog
        self.identifier = identifier
    }
}

public struct GetPartnerOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the partner account.
    /// This member is required.
    public var arn: Swift.String?
    /// The list of verified email domains associated with AWS training and certification credentials for the partner organization.
    public var awsTrainingCertificationEmailDomains: [PartnerCentralAccountClientTypes.PartnerDomain]?
    /// The catalog identifier for the partner account.
    /// This member is required.
    public var catalog: Swift.String?
    /// The timestamp when the partner account was created.
    /// This member is required.
    public var createdAt: Foundation.Date?
    /// The unique identifier of the partner account.
    /// This member is required.
    public var id: Swift.String?
    /// The legal name of the partner organization.
    /// This member is required.
    public var legalName: Swift.String?
    /// The partner profile information including display name, description, and other public details.
    /// This member is required.
    public var profile: PartnerCentralAccountClientTypes.PartnerProfile?

    public init(
        arn: Swift.String? = nil,
        awsTrainingCertificationEmailDomains: [PartnerCentralAccountClientTypes.PartnerDomain]? = nil,
        catalog: Swift.String? = nil,
        createdAt: Foundation.Date? = nil,
        id: Swift.String? = nil,
        legalName: Swift.String? = nil,
        profile: PartnerCentralAccountClientTypes.PartnerProfile? = nil
    ) {
        self.arn = arn
        self.awsTrainingCertificationEmailDomains = awsTrainingCertificationEmailDomains
        self.catalog = catalog
        self.createdAt = createdAt
        self.id = id
        self.legalName = legalName
        self.profile = profile
    }
}

extension GetPartnerOutput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "GetPartnerOutput(arn: \(Swift.String(describing: arn)), awsTrainingCertificationEmailDomains: \(Swift.String(describing: awsTrainingCertificationEmailDomains)), catalog: \(Swift.String(describing: catalog)), createdAt: \(Swift.String(describing: createdAt)), id: \(Swift.String(describing: id)), profile: \(Swift.String(describing: profile)), legalName: \"CONTENT_REDACTED\")"}
}

public struct GetProfileUpdateTaskInput: Swift.Sendable {
    /// The catalog identifier for the partner account.
    /// This member is required.
    public var catalog: Swift.String?
    /// The unique identifier of the partner account.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        catalog: Swift.String? = nil,
        identifier: Swift.String? = nil
    ) {
        self.catalog = catalog
        self.identifier = identifier
    }
}

public struct GetProfileUpdateTaskOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the profile update task.
    /// This member is required.
    public var arn: Swift.String?
    /// The catalog identifier for the partner account.
    /// This member is required.
    public var catalog: Swift.String?
    /// The timestamp when the profile update task was completed or failed.
    public var endedAt: Foundation.Date?
    /// A list of error details if any errors occurred during the profile update task.
    public var errorDetailList: [PartnerCentralAccountClientTypes.ErrorDetail]?
    /// The unique identifier of the partner account.
    /// This member is required.
    public var id: Swift.String?
    /// The timestamp when the profile update task was started.
    /// This member is required.
    public var startedAt: Foundation.Date?
    /// The current status of the profile update task (in progress, completed, failed, etc.).
    /// This member is required.
    public var status: PartnerCentralAccountClientTypes.ProfileTaskStatus?
    /// The details of the profile update task including what changes are being made.
    /// This member is required.
    public var taskDetails: PartnerCentralAccountClientTypes.TaskDetails?
    /// The unique identifier of the profile update task.
    /// This member is required.
    public var taskId: Swift.String?

    public init(
        arn: Swift.String? = nil,
        catalog: Swift.String? = nil,
        endedAt: Foundation.Date? = nil,
        errorDetailList: [PartnerCentralAccountClientTypes.ErrorDetail]? = nil,
        id: Swift.String? = nil,
        startedAt: Foundation.Date? = nil,
        status: PartnerCentralAccountClientTypes.ProfileTaskStatus? = nil,
        taskDetails: PartnerCentralAccountClientTypes.TaskDetails? = nil,
        taskId: Swift.String? = nil
    ) {
        self.arn = arn
        self.catalog = catalog
        self.endedAt = endedAt
        self.errorDetailList = errorDetailList
        self.id = id
        self.startedAt = startedAt
        self.status = status
        self.taskDetails = taskDetails
        self.taskId = taskId
    }
}

public struct GetProfileVisibilityInput: Swift.Sendable {
    /// The catalog identifier for the partner account.
    /// This member is required.
    public var catalog: Swift.String?
    /// The unique identifier of the partner account.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        catalog: Swift.String? = nil,
        identifier: Swift.String? = nil
    ) {
        self.catalog = catalog
        self.identifier = identifier
    }
}

extension PartnerCentralAccountClientTypes {

    public enum ProfileVisibility: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case `private`
        case `public`
        case sdkUnknown(Swift.String)

        public static var allCases: [ProfileVisibility] {
            return [
                .private,
                .public
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .private: return "PRIVATE"
            case .public: return "PUBLIC"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetProfileVisibilityOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the partner account.
    /// This member is required.
    public var arn: Swift.String?
    /// The catalog identifier for the partner account.
    /// This member is required.
    public var catalog: Swift.String?
    /// The unique identifier of the partner account.
    /// This member is required.
    public var id: Swift.String?
    /// The unique identifier of the partner profile.
    /// This member is required.
    public var profileId: Swift.String?
    /// The visibility setting for the partner profile (public, private, restricted, etc.).
    /// This member is required.
    public var visibility: PartnerCentralAccountClientTypes.ProfileVisibility?

    public init(
        arn: Swift.String? = nil,
        catalog: Swift.String? = nil,
        id: Swift.String? = nil,
        profileId: Swift.String? = nil,
        visibility: PartnerCentralAccountClientTypes.ProfileVisibility? = nil
    ) {
        self.arn = arn
        self.catalog = catalog
        self.id = id
        self.profileId = profileId
        self.visibility = visibility
    }
}

extension PartnerCentralAccountClientTypes {

    public enum VerificationType: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case businessVerification
        case registrantVerification
        case sdkUnknown(Swift.String)

        public static var allCases: [VerificationType] {
            return [
                .businessVerification,
                .registrantVerification
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .businessVerification: return "BUSINESS_VERIFICATION"
            case .registrantVerification: return "REGISTRANT_VERIFICATION"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetVerificationInput: Swift.Sendable {
    /// The type of verification to retrieve information for. Valid values include business verification for company registration details and registrant verification for individual identity confirmation.
    /// This member is required.
    public var verificationType: PartnerCentralAccountClientTypes.VerificationType?

    public init(
        verificationType: PartnerCentralAccountClientTypes.VerificationType? = nil
    ) {
        self.verificationType = verificationType
    }
}

extension PartnerCentralAccountClientTypes {

    /// Contains the response information from a registrant verification process, including any verification-specific data and next steps for the individual verification workflow.
    public struct RegistrantVerificationResponse: Swift.Sendable {
        /// A secure URL where the registrant can complete additional verification steps, such as document upload or identity confirmation through a third-party verification service.
        /// This member is required.
        public var completionUrl: Swift.String?
        /// The timestamp when the completion URL expires and is no longer valid for accessing the verification workflow.
        /// This member is required.
        public var completionUrlExpiresAt: Foundation.Date?

        public init(
            completionUrl: Swift.String? = nil,
            completionUrlExpiresAt: Foundation.Date? = nil
        ) {
            self.completionUrl = completionUrl
            self.completionUrlExpiresAt = completionUrlExpiresAt
        }
    }
}

extension PartnerCentralAccountClientTypes {

    /// A union structure containing the response details specific to different types of verification processes, providing type-specific information and results.
    public enum VerificationResponseDetails: Swift.Sendable {
        /// The response details from a business verification process, including verification results and any additional business information discovered.
        case businessverificationresponse(PartnerCentralAccountClientTypes.BusinessVerificationResponse)
        /// The response details from a registrant verification process, including verification results and any additional steps required for identity confirmation.
        case registrantverificationresponse(PartnerCentralAccountClientTypes.RegistrantVerificationResponse)
        case sdkUnknown(Swift.String)
    }
}

extension PartnerCentralAccountClientTypes {

    public enum VerificationStatus: Swift.Sendable, Swift.Equatable, Swift.RawRepresentable, Swift.CaseIterable, Swift.Hashable {
        case failed
        case inProgress
        case pendingCustomerAction
        case rejected
        case succeeded
        case sdkUnknown(Swift.String)

        public static var allCases: [VerificationStatus] {
            return [
                .failed,
                .inProgress,
                .pendingCustomerAction,
                .rejected,
                .succeeded
            ]
        }

        public init?(rawValue: Swift.String) {
            let value = Self.allCases.first(where: { $0.rawValue == rawValue })
            self = value ?? Self.sdkUnknown(rawValue)
        }

        public var rawValue: Swift.String {
            switch self {
            case .failed: return "FAILED"
            case .inProgress: return "IN_PROGRESS"
            case .pendingCustomerAction: return "PENDING_CUSTOMER_ACTION"
            case .rejected: return "REJECTED"
            case .succeeded: return "SUCCEEDED"
            case let .sdkUnknown(s): return s
            }
        }
    }
}

public struct GetVerificationOutput: Swift.Sendable {
    /// The timestamp when the verification process was completed. This field is null if the verification is still in progress.
    public var completedAt: Foundation.Date?
    /// The timestamp when the verification process was initiated.
    /// This member is required.
    public var startedAt: Foundation.Date?
    /// Detailed response information specific to the type of verification performed, including any verification-specific data or results.
    /// This member is required.
    public var verificationResponseDetails: PartnerCentralAccountClientTypes.VerificationResponseDetails?
    /// The current status of the verification process. Possible values include pending, in-progress, completed, failed, or expired.
    /// This member is required.
    public var verificationStatus: PartnerCentralAccountClientTypes.VerificationStatus?
    /// Additional information explaining the current verification status, particularly useful when the status indicates a failure or requires additional action.
    public var verificationStatusReason: Swift.String?
    /// The type of verification that was requested and processed.
    /// This member is required.
    public var verificationType: PartnerCentralAccountClientTypes.VerificationType?

    public init(
        completedAt: Foundation.Date? = nil,
        startedAt: Foundation.Date? = nil,
        verificationResponseDetails: PartnerCentralAccountClientTypes.VerificationResponseDetails? = nil,
        verificationStatus: PartnerCentralAccountClientTypes.VerificationStatus? = nil,
        verificationStatusReason: Swift.String? = nil,
        verificationType: PartnerCentralAccountClientTypes.VerificationType? = nil
    ) {
        self.completedAt = completedAt
        self.startedAt = startedAt
        self.verificationResponseDetails = verificationResponseDetails
        self.verificationStatus = verificationStatus
        self.verificationStatusReason = verificationStatusReason
        self.verificationType = verificationType
    }
}

public struct ListPartnersInput: Swift.Sendable {
    /// The catalog identifier to list partners from.
    /// This member is required.
    public var catalog: Swift.String?
    /// The token for retrieving the next page of results in paginated responses.
    public var nextToken: Swift.String?

    public init(
        catalog: Swift.String? = nil,
        nextToken: Swift.String? = nil
    ) {
        self.catalog = catalog
        self.nextToken = nextToken
    }
}

extension PartnerCentralAccountClientTypes {

    /// A summary view of a partner account containing basic information for listing purposes.
    public struct PartnerSummary: Swift.Sendable {
        /// The Amazon Resource Name (ARN) of the partner account.
        /// This member is required.
        public var arn: Swift.String?
        /// The catalog identifier for the partner account.
        /// This member is required.
        public var catalog: Swift.String?
        /// The timestamp when the partner account was created.
        /// This member is required.
        public var createdAt: Foundation.Date?
        /// The unique identifier of the partner account.
        /// This member is required.
        public var id: Swift.String?
        /// The legal name of the partner organization.
        /// This member is required.
        public var legalName: Swift.String?

        public init(
            arn: Swift.String? = nil,
            catalog: Swift.String? = nil,
            createdAt: Foundation.Date? = nil,
            id: Swift.String? = nil,
            legalName: Swift.String? = nil
        ) {
            self.arn = arn
            self.catalog = catalog
            self.createdAt = createdAt
            self.id = id
            self.legalName = legalName
        }
    }
}

extension PartnerCentralAccountClientTypes.PartnerSummary: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PartnerSummary(arn: \(Swift.String(describing: arn)), catalog: \(Swift.String(describing: catalog)), createdAt: \(Swift.String(describing: createdAt)), id: \(Swift.String(describing: id)), legalName: \"CONTENT_REDACTED\")"}
}

public struct ListPartnersOutput: Swift.Sendable {
    /// The token for retrieving the next page of results if more results are available.
    public var nextToken: Swift.String?
    /// A list of partner summaries including basic information about each partner account.
    /// This member is required.
    public var partnerSummaryList: [PartnerCentralAccountClientTypes.PartnerSummary]?

    public init(
        nextToken: Swift.String? = nil,
        partnerSummaryList: [PartnerCentralAccountClientTypes.PartnerSummary]? = nil
    ) {
        self.nextToken = nextToken
        self.partnerSummaryList = partnerSummaryList
    }
}

public struct ListTagsForResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the resource to list tags for.
    /// This member is required.
    public var resourceArn: Swift.String?

    public init(
        resourceArn: Swift.String? = nil
    ) {
        self.resourceArn = resourceArn
    }
}

public struct ListTagsForResourceOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the resource that the tags are associated with.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// A list of tags associated with the specified resource.
    public var tags: [PartnerCentralAccountClientTypes.Tag]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [PartnerCentralAccountClientTypes.Tag]? = nil
    ) {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

public struct PutAllianceLeadContactInput: Swift.Sendable {
    /// The alliance lead contact information to set for the partner account.
    /// This member is required.
    public var allianceLeadContact: PartnerCentralAccountClientTypes.AllianceLeadContact?
    /// The catalog identifier for the partner account.
    /// This member is required.
    public var catalog: Swift.String?
    /// The verification code sent to the alliance lead contact's email to confirm the update.
    public var emailVerificationCode: Swift.String?
    /// The unique identifier of the partner account.
    /// This member is required.
    public var identifier: Swift.String?

    public init(
        allianceLeadContact: PartnerCentralAccountClientTypes.AllianceLeadContact? = nil,
        catalog: Swift.String? = nil,
        emailVerificationCode: Swift.String? = nil,
        identifier: Swift.String? = nil
    ) {
        self.allianceLeadContact = allianceLeadContact
        self.catalog = catalog
        self.emailVerificationCode = emailVerificationCode
        self.identifier = identifier
    }
}

extension PutAllianceLeadContactInput: Swift.CustomDebugStringConvertible {
    public var debugDescription: Swift.String {
        "PutAllianceLeadContactInput(allianceLeadContact: \(Swift.String(describing: allianceLeadContact)), catalog: \(Swift.String(describing: catalog)), identifier: \(Swift.String(describing: identifier)), emailVerificationCode: \"CONTENT_REDACTED\")"}
}

public struct PutAllianceLeadContactOutput: Swift.Sendable {
    /// The updated alliance lead contact information.
    /// This member is required.
    public var allianceLeadContact: PartnerCentralAccountClientTypes.AllianceLeadContact?
    /// The Amazon Resource Name (ARN) of the partner account.
    /// This member is required.
    public var arn: Swift.String?
    /// The catalog identifier for the partner account.
    /// This member is required.
    public var catalog: Swift.String?
    /// The unique identifier of the partner account.
    /// This member is required.
    public var id: Swift.String?

    public init(
        allianceLeadContact: PartnerCentralAccountClientTypes.AllianceLeadContact? = nil,
        arn: Swift.String? = nil,
        catalog: Swift.String? = nil,
        id: Swift.String? = nil
    ) {
        self.allianceLeadContact = allianceLeadContact
        self.arn = arn
        self.catalog = catalog
        self.id = id
    }
}

public struct PutProfileVisibilityInput: Swift.Sendable {
    /// The catalog identifier for the partner account.
    /// This member is required.
    public var catalog: Swift.String?
    /// The unique identifier of the partner account.
    /// This member is required.
    public var identifier: Swift.String?
    /// The visibility setting to apply to the partner profile.
    /// This member is required.
    public var visibility: PartnerCentralAccountClientTypes.ProfileVisibility?

    public init(
        catalog: Swift.String? = nil,
        identifier: Swift.String? = nil,
        visibility: PartnerCentralAccountClientTypes.ProfileVisibility? = nil
    ) {
        self.catalog = catalog
        self.identifier = identifier
        self.visibility = visibility
    }
}

public struct PutProfileVisibilityOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the partner account.
    /// This member is required.
    public var arn: Swift.String?
    /// The catalog identifier for the partner account.
    /// This member is required.
    public var catalog: Swift.String?
    /// The unique identifier of the partner account.
    /// This member is required.
    public var id: Swift.String?
    /// The unique identifier of the partner profile.
    /// This member is required.
    public var profileId: Swift.String?
    /// The updated visibility setting for the partner profile.
    /// This member is required.
    public var visibility: PartnerCentralAccountClientTypes.ProfileVisibility?

    public init(
        arn: Swift.String? = nil,
        catalog: Swift.String? = nil,
        id: Swift.String? = nil,
        profileId: Swift.String? = nil,
        visibility: PartnerCentralAccountClientTypes.ProfileVisibility? = nil
    ) {
        self.arn = arn
        self.catalog = catalog
        self.id = id
        self.profileId = profileId
        self.visibility = visibility
    }
}

public struct StartProfileUpdateTaskInput: Swift.Sendable {
    /// The catalog identifier for the partner account.
    /// This member is required.
    public var catalog: Swift.String?
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request.
    public var clientToken: Swift.String?
    /// The unique identifier of the partner account.
    /// This member is required.
    public var identifier: Swift.String?
    /// The details of the profile updates to be performed.
    /// This member is required.
    public var taskDetails: PartnerCentralAccountClientTypes.TaskDetails?

    public init(
        catalog: Swift.String? = nil,
        clientToken: Swift.String? = nil,
        identifier: Swift.String? = nil,
        taskDetails: PartnerCentralAccountClientTypes.TaskDetails? = nil
    ) {
        self.catalog = catalog
        self.clientToken = clientToken
        self.identifier = identifier
        self.taskDetails = taskDetails
    }
}

public struct StartProfileUpdateTaskOutput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the started profile update task.
    /// This member is required.
    public var arn: Swift.String?
    /// The catalog identifier for the partner account.
    /// This member is required.
    public var catalog: Swift.String?
    /// The timestamp when the profile update task ended (null for in-progress tasks).
    public var endedAt: Foundation.Date?
    /// A list of error details if any errors occurred during the profile update task.
    public var errorDetailList: [PartnerCentralAccountClientTypes.ErrorDetail]?
    /// The unique identifier of the partner account.
    /// This member is required.
    public var id: Swift.String?
    /// The timestamp when the profile update task was started.
    /// This member is required.
    public var startedAt: Foundation.Date?
    /// The current status of the profile update task (in progress).
    /// This member is required.
    public var status: PartnerCentralAccountClientTypes.ProfileTaskStatus?
    /// The details of the profile update task that was started.
    /// This member is required.
    public var taskDetails: PartnerCentralAccountClientTypes.TaskDetails?
    /// The unique identifier of the started profile update task.
    /// This member is required.
    public var taskId: Swift.String?

    public init(
        arn: Swift.String? = nil,
        catalog: Swift.String? = nil,
        endedAt: Foundation.Date? = nil,
        errorDetailList: [PartnerCentralAccountClientTypes.ErrorDetail]? = nil,
        id: Swift.String? = nil,
        startedAt: Foundation.Date? = nil,
        status: PartnerCentralAccountClientTypes.ProfileTaskStatus? = nil,
        taskDetails: PartnerCentralAccountClientTypes.TaskDetails? = nil,
        taskId: Swift.String? = nil
    ) {
        self.arn = arn
        self.catalog = catalog
        self.endedAt = endedAt
        self.errorDetailList = errorDetailList
        self.id = id
        self.startedAt = startedAt
        self.status = status
        self.taskDetails = taskDetails
        self.taskId = taskId
    }
}

public struct SendEmailVerificationCodeInput: Swift.Sendable {
    /// The catalog identifier for the partner account.
    /// This member is required.
    public var catalog: Swift.String?
    /// The email address to send the verification code to.
    /// This member is required.
    public var email: Swift.String?

    public init(
        catalog: Swift.String? = nil,
        email: Swift.String? = nil
    ) {
        self.catalog = catalog
        self.email = email
    }
}

public struct SendEmailVerificationCodeOutput: Swift.Sendable {

    public init() { }
}

extension PartnerCentralAccountClientTypes {

    /// Contains the personal information required for verifying an individual's identity as part of the partner registration process in AWS Partner Central.
    public struct RegistrantVerificationDetails: Swift.Sendable {

        public init() { }
    }
}

extension PartnerCentralAccountClientTypes {

    /// A union structure containing the specific details required for different types of verification processes supported by AWS Partner Central.
    public enum VerificationDetails: Swift.Sendable {
        /// The business verification details to be used when starting a business verification process.
        case businessverificationdetails(PartnerCentralAccountClientTypes.BusinessVerificationDetails)
        /// The registrant verification details to be used when starting an individual identity verification process.
        case registrantverificationdetails(PartnerCentralAccountClientTypes.RegistrantVerificationDetails)
        case sdkUnknown(Swift.String)
    }
}

public struct StartVerificationInput: Swift.Sendable {
    /// A unique, case-sensitive identifier that you provide to ensure the idempotency of the request. This prevents duplicate verification processes from being started accidentally.
    public var clientToken: Swift.String?
    /// The specific details required for the verification process, including business information for business verification or personal information for registrant verification.
    public var verificationDetails: PartnerCentralAccountClientTypes.VerificationDetails?

    public init(
        clientToken: Swift.String? = nil,
        verificationDetails: PartnerCentralAccountClientTypes.VerificationDetails? = nil
    ) {
        self.clientToken = clientToken
        self.verificationDetails = verificationDetails
    }
}

public struct StartVerificationOutput: Swift.Sendable {
    /// The timestamp when the verification process was completed. This field is typically null for newly started verifications unless they complete immediately.
    public var completedAt: Foundation.Date?
    /// The timestamp when the verification process was successfully initiated.
    /// This member is required.
    public var startedAt: Foundation.Date?
    /// Initial response details specific to the type of verification started, which may include next steps or additional requirements.
    /// This member is required.
    public var verificationResponseDetails: PartnerCentralAccountClientTypes.VerificationResponseDetails?
    /// The initial status of the verification process after it has been started. Typically this will be pending or in-progress.
    /// This member is required.
    public var verificationStatus: PartnerCentralAccountClientTypes.VerificationStatus?
    /// Additional information about the initial verification status, including any immediate feedback about the submitted verification details.
    public var verificationStatusReason: Swift.String?
    /// The type of verification that was started based on the provided verification details.
    /// This member is required.
    public var verificationType: PartnerCentralAccountClientTypes.VerificationType?

    public init(
        completedAt: Foundation.Date? = nil,
        startedAt: Foundation.Date? = nil,
        verificationResponseDetails: PartnerCentralAccountClientTypes.VerificationResponseDetails? = nil,
        verificationStatus: PartnerCentralAccountClientTypes.VerificationStatus? = nil,
        verificationStatusReason: Swift.String? = nil,
        verificationType: PartnerCentralAccountClientTypes.VerificationType? = nil
    ) {
        self.completedAt = completedAt
        self.startedAt = startedAt
        self.verificationResponseDetails = verificationResponseDetails
        self.verificationStatus = verificationStatus
        self.verificationStatusReason = verificationStatusReason
        self.verificationType = verificationType
    }
}

public struct TagResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the resource to tag.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// A list of tags to add or update for the specified resource.
    /// This member is required.
    public var tags: [PartnerCentralAccountClientTypes.Tag]?

    public init(
        resourceArn: Swift.String? = nil,
        tags: [PartnerCentralAccountClientTypes.Tag]? = nil
    ) {
        self.resourceArn = resourceArn
        self.tags = tags
    }
}

public struct TagResourceOutput: Swift.Sendable {

    public init() { }
}

public struct UntagResourceInput: Swift.Sendable {
    /// The Amazon Resource Name (ARN) of the resource to remove tags from.
    /// This member is required.
    public var resourceArn: Swift.String?
    /// A list of tag keys to remove from the specified resource.
    /// This member is required.
    public var tagKeys: [Swift.String]?

    public init(
        resourceArn: Swift.String? = nil,
        tagKeys: [Swift.String]? = nil
    ) {
        self.resourceArn = resourceArn
        self.tagKeys = tagKeys
    }
}

public struct UntagResourceOutput: Swift.Sendable {

    public init() { }
}

extension AcceptConnectionInvitationInput {

    static func urlPathProvider(_ value: AcceptConnectionInvitationInput) -> Swift.String? {
        return "/"
    }
}

extension AssociateAwsTrainingCertificationEmailDomainInput {

    static func urlPathProvider(_ value: AssociateAwsTrainingCertificationEmailDomainInput) -> Swift.String? {
        return "/"
    }
}

extension CancelConnectionInput {

    static func urlPathProvider(_ value: CancelConnectionInput) -> Swift.String? {
        return "/"
    }
}

extension CancelConnectionInvitationInput {

    static func urlPathProvider(_ value: CancelConnectionInvitationInput) -> Swift.String? {
        return "/"
    }
}

extension CancelProfileUpdateTaskInput {

    static func urlPathProvider(_ value: CancelProfileUpdateTaskInput) -> Swift.String? {
        return "/"
    }
}

extension CreateConnectionInvitationInput {

    static func urlPathProvider(_ value: CreateConnectionInvitationInput) -> Swift.String? {
        return "/"
    }
}

extension CreatePartnerInput {

    static func urlPathProvider(_ value: CreatePartnerInput) -> Swift.String? {
        return "/"
    }
}

extension DisassociateAwsTrainingCertificationEmailDomainInput {

    static func urlPathProvider(_ value: DisassociateAwsTrainingCertificationEmailDomainInput) -> Swift.String? {
        return "/"
    }
}

extension GetAllianceLeadContactInput {

    static func urlPathProvider(_ value: GetAllianceLeadContactInput) -> Swift.String? {
        return "/"
    }
}

extension GetConnectionInput {

    static func urlPathProvider(_ value: GetConnectionInput) -> Swift.String? {
        return "/"
    }
}

extension GetConnectionInvitationInput {

    static func urlPathProvider(_ value: GetConnectionInvitationInput) -> Swift.String? {
        return "/"
    }
}

extension GetConnectionPreferencesInput {

    static func urlPathProvider(_ value: GetConnectionPreferencesInput) -> Swift.String? {
        return "/"
    }
}

extension GetPartnerInput {

    static func urlPathProvider(_ value: GetPartnerInput) -> Swift.String? {
        return "/"
    }
}

extension GetProfileUpdateTaskInput {

    static func urlPathProvider(_ value: GetProfileUpdateTaskInput) -> Swift.String? {
        return "/"
    }
}

extension GetProfileVisibilityInput {

    static func urlPathProvider(_ value: GetProfileVisibilityInput) -> Swift.String? {
        return "/"
    }
}

extension GetVerificationInput {

    static func urlPathProvider(_ value: GetVerificationInput) -> Swift.String? {
        return "/"
    }
}

extension ListConnectionInvitationsInput {

    static func urlPathProvider(_ value: ListConnectionInvitationsInput) -> Swift.String? {
        return "/"
    }
}

extension ListConnectionsInput {

    static func urlPathProvider(_ value: ListConnectionsInput) -> Swift.String? {
        return "/"
    }
}

extension ListPartnersInput {

    static func urlPathProvider(_ value: ListPartnersInput) -> Swift.String? {
        return "/"
    }
}

extension ListTagsForResourceInput {

    static func urlPathProvider(_ value: ListTagsForResourceInput) -> Swift.String? {
        return "/"
    }
}

extension PutAllianceLeadContactInput {

    static func urlPathProvider(_ value: PutAllianceLeadContactInput) -> Swift.String? {
        return "/"
    }
}

extension PutProfileVisibilityInput {

    static func urlPathProvider(_ value: PutProfileVisibilityInput) -> Swift.String? {
        return "/"
    }
}

extension RejectConnectionInvitationInput {

    static func urlPathProvider(_ value: RejectConnectionInvitationInput) -> Swift.String? {
        return "/"
    }
}

extension SendEmailVerificationCodeInput {

    static func urlPathProvider(_ value: SendEmailVerificationCodeInput) -> Swift.String? {
        return "/"
    }
}

extension StartProfileUpdateTaskInput {

    static func urlPathProvider(_ value: StartProfileUpdateTaskInput) -> Swift.String? {
        return "/"
    }
}

extension StartVerificationInput {

    static func urlPathProvider(_ value: StartVerificationInput) -> Swift.String? {
        return "/"
    }
}

extension TagResourceInput {

    static func urlPathProvider(_ value: TagResourceInput) -> Swift.String? {
        return "/"
    }
}

extension UntagResourceInput {

    static func urlPathProvider(_ value: UntagResourceInput) -> Swift.String? {
        return "/"
    }
}

extension UpdateConnectionPreferencesInput {

    static func urlPathProvider(_ value: UpdateConnectionPreferencesInput) -> Swift.String? {
        return "/"
    }
}

extension AcceptConnectionInvitationInput {

    static func write(value: AcceptConnectionInvitationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Catalog"].write(value.catalog)
        try writer["ClientToken"].write(value.clientToken)
        try writer["Identifier"].write(value.identifier)
    }
}

extension AssociateAwsTrainingCertificationEmailDomainInput {

    static func write(value: AssociateAwsTrainingCertificationEmailDomainInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Catalog"].write(value.catalog)
        try writer["ClientToken"].write(value.clientToken)
        try writer["Email"].write(value.email)
        try writer["EmailVerificationCode"].write(value.emailVerificationCode)
        try writer["Identifier"].write(value.identifier)
    }
}

extension CancelConnectionInput {

    static func write(value: CancelConnectionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Catalog"].write(value.catalog)
        try writer["ClientToken"].write(value.clientToken)
        try writer["ConnectionType"].write(value.connectionType)
        try writer["Identifier"].write(value.identifier)
        try writer["Reason"].write(value.reason)
    }
}

extension CancelConnectionInvitationInput {

    static func write(value: CancelConnectionInvitationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Catalog"].write(value.catalog)
        try writer["ClientToken"].write(value.clientToken)
        try writer["Identifier"].write(value.identifier)
    }
}

extension CancelProfileUpdateTaskInput {

    static func write(value: CancelProfileUpdateTaskInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Catalog"].write(value.catalog)
        try writer["ClientToken"].write(value.clientToken)
        try writer["Identifier"].write(value.identifier)
        try writer["TaskId"].write(value.taskId)
    }
}

extension CreateConnectionInvitationInput {

    static func write(value: CreateConnectionInvitationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Catalog"].write(value.catalog)
        try writer["ClientToken"].write(value.clientToken)
        try writer["ConnectionType"].write(value.connectionType)
        try writer["Email"].write(value.email)
        try writer["Message"].write(value.message)
        try writer["Name"].write(value.name)
        try writer["ReceiverIdentifier"].write(value.receiverIdentifier)
    }
}

extension CreatePartnerInput {

    static func write(value: CreatePartnerInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AllianceLeadContact"].write(value.allianceLeadContact, with: PartnerCentralAccountClientTypes.AllianceLeadContact.write(value:to:))
        try writer["Catalog"].write(value.catalog)
        try writer["ClientToken"].write(value.clientToken)
        try writer["EmailVerificationCode"].write(value.emailVerificationCode)
        try writer["LegalName"].write(value.legalName)
        try writer["PrimarySolutionType"].write(value.primarySolutionType)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: PartnerCentralAccountClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension DisassociateAwsTrainingCertificationEmailDomainInput {

    static func write(value: DisassociateAwsTrainingCertificationEmailDomainInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Catalog"].write(value.catalog)
        try writer["ClientToken"].write(value.clientToken)
        try writer["DomainName"].write(value.domainName)
        try writer["Identifier"].write(value.identifier)
    }
}

extension GetAllianceLeadContactInput {

    static func write(value: GetAllianceLeadContactInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Catalog"].write(value.catalog)
        try writer["Identifier"].write(value.identifier)
    }
}

extension GetConnectionInput {

    static func write(value: GetConnectionInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Catalog"].write(value.catalog)
        try writer["Identifier"].write(value.identifier)
    }
}

extension GetConnectionInvitationInput {

    static func write(value: GetConnectionInvitationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Catalog"].write(value.catalog)
        try writer["Identifier"].write(value.identifier)
    }
}

extension GetConnectionPreferencesInput {

    static func write(value: GetConnectionPreferencesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Catalog"].write(value.catalog)
    }
}

extension GetPartnerInput {

    static func write(value: GetPartnerInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Catalog"].write(value.catalog)
        try writer["Identifier"].write(value.identifier)
    }
}

extension GetProfileUpdateTaskInput {

    static func write(value: GetProfileUpdateTaskInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Catalog"].write(value.catalog)
        try writer["Identifier"].write(value.identifier)
    }
}

extension GetProfileVisibilityInput {

    static func write(value: GetProfileVisibilityInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Catalog"].write(value.catalog)
        try writer["Identifier"].write(value.identifier)
    }
}

extension GetVerificationInput {

    static func write(value: GetVerificationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["VerificationType"].write(value.verificationType)
    }
}

extension ListConnectionInvitationsInput {

    static func write(value: ListConnectionInvitationsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Catalog"].write(value.catalog)
        try writer["ConnectionType"].write(value.connectionType)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["OtherParticipantIdentifiers"].writeList(value.otherParticipantIdentifiers, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["ParticipantType"].write(value.participantType)
        try writer["Status"].write(value.status)
    }
}

extension ListConnectionsInput {

    static func write(value: ListConnectionsInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Catalog"].write(value.catalog)
        try writer["ConnectionType"].write(value.connectionType)
        try writer["MaxResults"].write(value.maxResults)
        try writer["NextToken"].write(value.nextToken)
        try writer["OtherParticipantIdentifiers"].writeList(value.otherParticipantIdentifiers, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension ListPartnersInput {

    static func write(value: ListPartnersInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Catalog"].write(value.catalog)
        try writer["NextToken"].write(value.nextToken)
    }
}

extension ListTagsForResourceInput {

    static func write(value: ListTagsForResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceArn"].write(value.resourceArn)
    }
}

extension PutAllianceLeadContactInput {

    static func write(value: PutAllianceLeadContactInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AllianceLeadContact"].write(value.allianceLeadContact, with: PartnerCentralAccountClientTypes.AllianceLeadContact.write(value:to:))
        try writer["Catalog"].write(value.catalog)
        try writer["EmailVerificationCode"].write(value.emailVerificationCode)
        try writer["Identifier"].write(value.identifier)
    }
}

extension PutProfileVisibilityInput {

    static func write(value: PutProfileVisibilityInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Catalog"].write(value.catalog)
        try writer["Identifier"].write(value.identifier)
        try writer["Visibility"].write(value.visibility)
    }
}

extension RejectConnectionInvitationInput {

    static func write(value: RejectConnectionInvitationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Catalog"].write(value.catalog)
        try writer["ClientToken"].write(value.clientToken)
        try writer["Identifier"].write(value.identifier)
        try writer["Reason"].write(value.reason)
    }
}

extension SendEmailVerificationCodeInput {

    static func write(value: SendEmailVerificationCodeInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Catalog"].write(value.catalog)
        try writer["Email"].write(value.email)
    }
}

extension StartProfileUpdateTaskInput {

    static func write(value: StartProfileUpdateTaskInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Catalog"].write(value.catalog)
        try writer["ClientToken"].write(value.clientToken)
        try writer["Identifier"].write(value.identifier)
        try writer["TaskDetails"].write(value.taskDetails, with: PartnerCentralAccountClientTypes.TaskDetails.write(value:to:))
    }
}

extension StartVerificationInput {

    static func write(value: StartVerificationInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ClientToken"].write(value.clientToken)
        try writer["VerificationDetails"].write(value.verificationDetails, with: PartnerCentralAccountClientTypes.VerificationDetails.write(value:to:))
    }
}

extension TagResourceInput {

    static func write(value: TagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceArn"].write(value.resourceArn)
        try writer["Tags"].writeList(value.tags, memberWritingClosure: PartnerCentralAccountClientTypes.Tag.write(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UntagResourceInput {

    static func write(value: UntagResourceInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["ResourceArn"].write(value.resourceArn)
        try writer["TagKeys"].writeList(value.tagKeys, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
    }
}

extension UpdateConnectionPreferencesInput {

    static func write(value: UpdateConnectionPreferencesInput?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["AccessType"].write(value.accessType)
        try writer["Catalog"].write(value.catalog)
        try writer["ExcludedParticipantIdentifiers"].writeList(value.excludedParticipantIdentifiers, memberWritingClosure: SmithyReadWrite.WritingClosures.writeString(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["Revision"].write(value.revision)
    }
}

extension AcceptConnectionInvitationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AcceptConnectionInvitationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = AcceptConnectionInvitationOutput()
        value.connection = try reader["Connection"].readIfPresent(with: PartnerCentralAccountClientTypes.Connection.read(from:))
        return value
    }
}

extension AssociateAwsTrainingCertificationEmailDomainOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> AssociateAwsTrainingCertificationEmailDomainOutput {
        return AssociateAwsTrainingCertificationEmailDomainOutput()
    }
}

extension CancelConnectionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CancelConnectionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CancelConnectionOutput()
        value.arn = try reader["Arn"].readIfPresent() ?? ""
        value.catalog = try reader["Catalog"].readIfPresent() ?? ""
        value.connectionTypes = try reader["ConnectionTypes"].readMapIfPresent(valueReadingClosure: PartnerCentralAccountClientTypes.ConnectionTypeDetail.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false) ?? [:]
        value.id = try reader["Id"].readIfPresent() ?? ""
        value.otherParticipantAccountId = try reader["OtherParticipantAccountId"].readIfPresent() ?? ""
        value.updatedAt = try reader["UpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension CancelConnectionInvitationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CancelConnectionInvitationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CancelConnectionInvitationOutput()
        value.arn = try reader["Arn"].readIfPresent() ?? ""
        value.catalog = try reader["Catalog"].readIfPresent() ?? ""
        value.connectionId = try reader["ConnectionId"].readIfPresent()
        value.connectionType = try reader["ConnectionType"].readIfPresent() ?? .sdkUnknown("")
        value.createdAt = try reader["CreatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.expiresAt = try reader["ExpiresAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.id = try reader["Id"].readIfPresent() ?? ""
        value.invitationMessage = try reader["InvitationMessage"].readIfPresent() ?? ""
        value.inviterEmail = try reader["InviterEmail"].readIfPresent() ?? ""
        value.inviterName = try reader["InviterName"].readIfPresent() ?? ""
        value.otherParticipantIdentifier = try reader["OtherParticipantIdentifier"].readIfPresent() ?? ""
        value.participantType = try reader["ParticipantType"].readIfPresent() ?? .sdkUnknown("")
        value.status = try reader["Status"].readIfPresent() ?? .sdkUnknown("")
        value.updatedAt = try reader["UpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension CancelProfileUpdateTaskOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CancelProfileUpdateTaskOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CancelProfileUpdateTaskOutput()
        value.arn = try reader["Arn"].readIfPresent() ?? ""
        value.catalog = try reader["Catalog"].readIfPresent() ?? ""
        value.endedAt = try reader["EndedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.errorDetailList = try reader["ErrorDetailList"].readListIfPresent(memberReadingClosure: PartnerCentralAccountClientTypes.ErrorDetail.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.id = try reader["Id"].readIfPresent() ?? ""
        value.startedAt = try reader["StartedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.status = try reader["Status"].readIfPresent() ?? .sdkUnknown("")
        value.taskDetails = try reader["TaskDetails"].readIfPresent(with: PartnerCentralAccountClientTypes.TaskDetails.read(from:))
        value.taskId = try reader["TaskId"].readIfPresent() ?? ""
        return value
    }
}

extension CreateConnectionInvitationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreateConnectionInvitationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreateConnectionInvitationOutput()
        value.arn = try reader["Arn"].readIfPresent() ?? ""
        value.catalog = try reader["Catalog"].readIfPresent() ?? ""
        value.connectionId = try reader["ConnectionId"].readIfPresent()
        value.connectionType = try reader["ConnectionType"].readIfPresent() ?? .sdkUnknown("")
        value.createdAt = try reader["CreatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.expiresAt = try reader["ExpiresAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.id = try reader["Id"].readIfPresent() ?? ""
        value.invitationMessage = try reader["InvitationMessage"].readIfPresent() ?? ""
        value.inviterEmail = try reader["InviterEmail"].readIfPresent() ?? ""
        value.inviterName = try reader["InviterName"].readIfPresent() ?? ""
        value.otherParticipantIdentifier = try reader["OtherParticipantIdentifier"].readIfPresent() ?? ""
        value.participantType = try reader["ParticipantType"].readIfPresent() ?? .sdkUnknown("")
        value.status = try reader["Status"].readIfPresent() ?? .sdkUnknown("")
        value.updatedAt = try reader["UpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension CreatePartnerOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> CreatePartnerOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = CreatePartnerOutput()
        value.allianceLeadContact = try reader["AllianceLeadContact"].readIfPresent(with: PartnerCentralAccountClientTypes.AllianceLeadContact.read(from:))
        value.arn = try reader["Arn"].readIfPresent() ?? ""
        value.awsTrainingCertificationEmailDomains = try reader["AwsTrainingCertificationEmailDomains"].readListIfPresent(memberReadingClosure: PartnerCentralAccountClientTypes.PartnerDomain.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.catalog = try reader["Catalog"].readIfPresent() ?? ""
        value.createdAt = try reader["CreatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.id = try reader["Id"].readIfPresent() ?? ""
        value.legalName = try reader["LegalName"].readIfPresent() ?? ""
        value.profile = try reader["Profile"].readIfPresent(with: PartnerCentralAccountClientTypes.PartnerProfile.read(from:))
        return value
    }
}

extension DisassociateAwsTrainingCertificationEmailDomainOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> DisassociateAwsTrainingCertificationEmailDomainOutput {
        return DisassociateAwsTrainingCertificationEmailDomainOutput()
    }
}

extension GetAllianceLeadContactOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetAllianceLeadContactOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetAllianceLeadContactOutput()
        value.allianceLeadContact = try reader["AllianceLeadContact"].readIfPresent(with: PartnerCentralAccountClientTypes.AllianceLeadContact.read(from:))
        value.arn = try reader["Arn"].readIfPresent() ?? ""
        value.catalog = try reader["Catalog"].readIfPresent() ?? ""
        value.id = try reader["Id"].readIfPresent() ?? ""
        return value
    }
}

extension GetConnectionOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetConnectionOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetConnectionOutput()
        value.arn = try reader["Arn"].readIfPresent() ?? ""
        value.catalog = try reader["Catalog"].readIfPresent() ?? ""
        value.connectionTypes = try reader["ConnectionTypes"].readMapIfPresent(valueReadingClosure: PartnerCentralAccountClientTypes.ConnectionTypeDetail.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false) ?? [:]
        value.id = try reader["Id"].readIfPresent() ?? ""
        value.otherParticipantAccountId = try reader["OtherParticipantAccountId"].readIfPresent() ?? ""
        value.updatedAt = try reader["UpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension GetConnectionInvitationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetConnectionInvitationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetConnectionInvitationOutput()
        value.arn = try reader["Arn"].readIfPresent() ?? ""
        value.catalog = try reader["Catalog"].readIfPresent() ?? ""
        value.connectionId = try reader["ConnectionId"].readIfPresent()
        value.connectionType = try reader["ConnectionType"].readIfPresent() ?? .sdkUnknown("")
        value.createdAt = try reader["CreatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.expiresAt = try reader["ExpiresAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.id = try reader["Id"].readIfPresent() ?? ""
        value.invitationMessage = try reader["InvitationMessage"].readIfPresent() ?? ""
        value.inviterEmail = try reader["InviterEmail"].readIfPresent() ?? ""
        value.inviterName = try reader["InviterName"].readIfPresent() ?? ""
        value.otherParticipantIdentifier = try reader["OtherParticipantIdentifier"].readIfPresent() ?? ""
        value.participantType = try reader["ParticipantType"].readIfPresent() ?? .sdkUnknown("")
        value.status = try reader["Status"].readIfPresent() ?? .sdkUnknown("")
        value.updatedAt = try reader["UpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension GetConnectionPreferencesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetConnectionPreferencesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetConnectionPreferencesOutput()
        value.accessType = try reader["AccessType"].readIfPresent() ?? .sdkUnknown("")
        value.arn = try reader["Arn"].readIfPresent() ?? ""
        value.catalog = try reader["Catalog"].readIfPresent() ?? ""
        value.excludedParticipantIds = try reader["ExcludedParticipantIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.revision = try reader["Revision"].readIfPresent() ?? 0
        value.updatedAt = try reader["UpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension GetPartnerOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetPartnerOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetPartnerOutput()
        value.arn = try reader["Arn"].readIfPresent() ?? ""
        value.awsTrainingCertificationEmailDomains = try reader["AwsTrainingCertificationEmailDomains"].readListIfPresent(memberReadingClosure: PartnerCentralAccountClientTypes.PartnerDomain.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.catalog = try reader["Catalog"].readIfPresent() ?? ""
        value.createdAt = try reader["CreatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.id = try reader["Id"].readIfPresent() ?? ""
        value.legalName = try reader["LegalName"].readIfPresent() ?? ""
        value.profile = try reader["Profile"].readIfPresent(with: PartnerCentralAccountClientTypes.PartnerProfile.read(from:))
        return value
    }
}

extension GetProfileUpdateTaskOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetProfileUpdateTaskOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetProfileUpdateTaskOutput()
        value.arn = try reader["Arn"].readIfPresent() ?? ""
        value.catalog = try reader["Catalog"].readIfPresent() ?? ""
        value.endedAt = try reader["EndedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.errorDetailList = try reader["ErrorDetailList"].readListIfPresent(memberReadingClosure: PartnerCentralAccountClientTypes.ErrorDetail.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.id = try reader["Id"].readIfPresent() ?? ""
        value.startedAt = try reader["StartedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.status = try reader["Status"].readIfPresent() ?? .sdkUnknown("")
        value.taskDetails = try reader["TaskDetails"].readIfPresent(with: PartnerCentralAccountClientTypes.TaskDetails.read(from:))
        value.taskId = try reader["TaskId"].readIfPresent() ?? ""
        return value
    }
}

extension GetProfileVisibilityOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetProfileVisibilityOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetProfileVisibilityOutput()
        value.arn = try reader["Arn"].readIfPresent() ?? ""
        value.catalog = try reader["Catalog"].readIfPresent() ?? ""
        value.id = try reader["Id"].readIfPresent() ?? ""
        value.profileId = try reader["ProfileId"].readIfPresent() ?? ""
        value.visibility = try reader["Visibility"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension GetVerificationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> GetVerificationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = GetVerificationOutput()
        value.completedAt = try reader["CompletedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.startedAt = try reader["StartedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.verificationResponseDetails = try reader["VerificationResponseDetails"].readIfPresent(with: PartnerCentralAccountClientTypes.VerificationResponseDetails.read(from:))
        value.verificationStatus = try reader["VerificationStatus"].readIfPresent() ?? .sdkUnknown("")
        value.verificationStatusReason = try reader["VerificationStatusReason"].readIfPresent()
        value.verificationType = try reader["VerificationType"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension ListConnectionInvitationsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListConnectionInvitationsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListConnectionInvitationsOutput()
        value.connectionInvitationSummaries = try reader["ConnectionInvitationSummaries"].readListIfPresent(memberReadingClosure: PartnerCentralAccountClientTypes.ConnectionInvitationSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListConnectionsOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListConnectionsOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListConnectionsOutput()
        value.connectionSummaries = try reader["ConnectionSummaries"].readListIfPresent(memberReadingClosure: PartnerCentralAccountClientTypes.ConnectionSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.nextToken = try reader["NextToken"].readIfPresent()
        return value
    }
}

extension ListPartnersOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListPartnersOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListPartnersOutput()
        value.nextToken = try reader["NextToken"].readIfPresent()
        value.partnerSummaryList = try reader["PartnerSummaryList"].readListIfPresent(memberReadingClosure: PartnerCentralAccountClientTypes.PartnerSummary.read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        return value
    }
}

extension ListTagsForResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> ListTagsForResourceOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = ListTagsForResourceOutput()
        value.resourceArn = try reader["ResourceArn"].readIfPresent() ?? ""
        value.tags = try reader["Tags"].readListIfPresent(memberReadingClosure: PartnerCentralAccountClientTypes.Tag.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension PutAllianceLeadContactOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutAllianceLeadContactOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = PutAllianceLeadContactOutput()
        value.allianceLeadContact = try reader["AllianceLeadContact"].readIfPresent(with: PartnerCentralAccountClientTypes.AllianceLeadContact.read(from:))
        value.arn = try reader["Arn"].readIfPresent() ?? ""
        value.catalog = try reader["Catalog"].readIfPresent() ?? ""
        value.id = try reader["Id"].readIfPresent() ?? ""
        return value
    }
}

extension PutProfileVisibilityOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> PutProfileVisibilityOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = PutProfileVisibilityOutput()
        value.arn = try reader["Arn"].readIfPresent() ?? ""
        value.catalog = try reader["Catalog"].readIfPresent() ?? ""
        value.id = try reader["Id"].readIfPresent() ?? ""
        value.profileId = try reader["ProfileId"].readIfPresent() ?? ""
        value.visibility = try reader["Visibility"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension RejectConnectionInvitationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> RejectConnectionInvitationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = RejectConnectionInvitationOutput()
        value.arn = try reader["Arn"].readIfPresent() ?? ""
        value.catalog = try reader["Catalog"].readIfPresent() ?? ""
        value.connectionId = try reader["ConnectionId"].readIfPresent()
        value.connectionType = try reader["ConnectionType"].readIfPresent() ?? .sdkUnknown("")
        value.createdAt = try reader["CreatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.expiresAt = try reader["ExpiresAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.id = try reader["Id"].readIfPresent() ?? ""
        value.invitationMessage = try reader["InvitationMessage"].readIfPresent() ?? ""
        value.inviterEmail = try reader["InviterEmail"].readIfPresent() ?? ""
        value.inviterName = try reader["InviterName"].readIfPresent() ?? ""
        value.otherParticipantIdentifier = try reader["OtherParticipantIdentifier"].readIfPresent() ?? ""
        value.participantType = try reader["ParticipantType"].readIfPresent() ?? .sdkUnknown("")
        value.status = try reader["Status"].readIfPresent() ?? .sdkUnknown("")
        value.updatedAt = try reader["UpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension SendEmailVerificationCodeOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> SendEmailVerificationCodeOutput {
        return SendEmailVerificationCodeOutput()
    }
}

extension StartProfileUpdateTaskOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartProfileUpdateTaskOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartProfileUpdateTaskOutput()
        value.arn = try reader["Arn"].readIfPresent() ?? ""
        value.catalog = try reader["Catalog"].readIfPresent() ?? ""
        value.endedAt = try reader["EndedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.errorDetailList = try reader["ErrorDetailList"].readListIfPresent(memberReadingClosure: PartnerCentralAccountClientTypes.ErrorDetail.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.id = try reader["Id"].readIfPresent() ?? ""
        value.startedAt = try reader["StartedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.status = try reader["Status"].readIfPresent() ?? .sdkUnknown("")
        value.taskDetails = try reader["TaskDetails"].readIfPresent(with: PartnerCentralAccountClientTypes.TaskDetails.read(from:))
        value.taskId = try reader["TaskId"].readIfPresent() ?? ""
        return value
    }
}

extension StartVerificationOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> StartVerificationOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = StartVerificationOutput()
        value.completedAt = try reader["CompletedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.startedAt = try reader["StartedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.verificationResponseDetails = try reader["VerificationResponseDetails"].readIfPresent(with: PartnerCentralAccountClientTypes.VerificationResponseDetails.read(from:))
        value.verificationStatus = try reader["VerificationStatus"].readIfPresent() ?? .sdkUnknown("")
        value.verificationStatusReason = try reader["VerificationStatusReason"].readIfPresent()
        value.verificationType = try reader["VerificationType"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension TagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> TagResourceOutput {
        return TagResourceOutput()
    }
}

extension UntagResourceOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UntagResourceOutput {
        return UntagResourceOutput()
    }
}

extension UpdateConnectionPreferencesOutput {

    static func httpOutput(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> UpdateConnectionPreferencesOutput {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let reader = responseReader
        var value = UpdateConnectionPreferencesOutput()
        value.accessType = try reader["AccessType"].readIfPresent() ?? .sdkUnknown("")
        value.arn = try reader["Arn"].readIfPresent() ?? ""
        value.catalog = try reader["Catalog"].readIfPresent() ?? ""
        value.excludedParticipantIds = try reader["ExcludedParticipantIds"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosures.readString(from:), memberNodeInfo: "member", isFlattened: false)
        value.revision = try reader["Revision"].readIfPresent() ?? 0
        value.updatedAt = try reader["UpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

enum AcceptConnectionInvitationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum AssociateAwsTrainingCertificationEmailDomainOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CancelConnectionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CancelConnectionInvitationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CancelProfileUpdateTaskOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreateConnectionInvitationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum CreatePartnerOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum DisassociateAwsTrainingCertificationEmailDomainOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetAllianceLeadContactOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetConnectionOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetConnectionInvitationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetConnectionPreferencesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetPartnerOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetProfileUpdateTaskOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetProfileVisibilityOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum GetVerificationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListConnectionInvitationsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListConnectionsOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListPartnersOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum ListTagsForResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutAllianceLeadContactOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum PutProfileVisibilityOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum RejectConnectionInvitationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum SendEmailVerificationCodeOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartProfileUpdateTaskOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum StartVerificationOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ServiceQuotaExceededException": return try ServiceQuotaExceededException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum TagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UntagResourceOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ResourceNotFoundException": return try ResourceNotFoundException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

enum UpdateConnectionPreferencesOutputError {

    static func httpError(from httpResponse: SmithyHTTPAPI.HTTPResponse) async throws -> Swift.Error {
        let data = try await httpResponse.data()
        let responseReader = try SmithyJSON.Reader.from(data: data)
        let baseError = try AWSClientRuntime.AWSJSONError(httpResponse: httpResponse, responseReader: responseReader, noErrorWrapping: false)
        if let error = baseError.customError() { return error }
        switch baseError.code {
            case "AccessDeniedException": return try AccessDeniedException.makeError(baseError: baseError)
            case "ConflictException": return try ConflictException.makeError(baseError: baseError)
            case "InternalServerException": return try InternalServerException.makeError(baseError: baseError)
            case "ThrottlingException": return try ThrottlingException.makeError(baseError: baseError)
            case "ValidationException": return try ValidationException.makeError(baseError: baseError)
            default: return try AWSClientRuntime.UnknownAWSHTTPServiceError.makeError(baseError: baseError)
        }
    }
}

extension AccessDeniedException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> AccessDeniedException {
        let reader = baseError.errorBodyReader
        var value = AccessDeniedException()
        value.properties.message = try reader["Message"].readIfPresent() ?? ""
        value.properties.reason = try reader["Reason"].readIfPresent() ?? .sdkUnknown("")
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ConflictException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ConflictException {
        let reader = baseError.errorBodyReader
        var value = ConflictException()
        value.properties.message = try reader["Message"].readIfPresent() ?? ""
        value.properties.reason = try reader["Reason"].readIfPresent() ?? .sdkUnknown("")
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension InternalServerException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> InternalServerException {
        let reader = baseError.errorBodyReader
        var value = InternalServerException()
        value.properties.message = try reader["Message"].readIfPresent() ?? ""
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ResourceNotFoundException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ResourceNotFoundException {
        let reader = baseError.errorBodyReader
        var value = ResourceNotFoundException()
        value.properties.message = try reader["Message"].readIfPresent() ?? ""
        value.properties.reason = try reader["Reason"].readIfPresent() ?? .sdkUnknown("")
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ThrottlingException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ThrottlingException {
        let reader = baseError.errorBodyReader
        var value = ThrottlingException()
        value.properties.message = try reader["Message"].readIfPresent() ?? ""
        value.properties.quotaCode = try reader["QuotaCode"].readIfPresent()
        value.properties.serviceCode = try reader["ServiceCode"].readIfPresent()
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ValidationException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ValidationException {
        let reader = baseError.errorBodyReader
        var value = ValidationException()
        value.properties.errorDetails = try reader["ErrorDetails"].readListIfPresent(memberReadingClosure: PartnerCentralAccountClientTypes.ValidationError.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.properties.message = try reader["Message"].readIfPresent() ?? ""
        value.properties.reason = try reader["Reason"].readIfPresent() ?? .sdkUnknown("")
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension ServiceQuotaExceededException {

    static func makeError(baseError: AWSClientRuntime.AWSJSONError) throws -> ServiceQuotaExceededException {
        let reader = baseError.errorBodyReader
        var value = ServiceQuotaExceededException()
        value.properties.message = try reader["Message"].readIfPresent() ?? ""
        value.properties.reason = try reader["Reason"].readIfPresent() ?? .sdkUnknown("")
        value.httpResponse = baseError.httpResponse
        value.requestID = baseError.requestID
        value.message = baseError.message
        return value
    }
}

extension PartnerCentralAccountClientTypes.Connection {

    static func read(from reader: SmithyJSON.Reader) throws -> PartnerCentralAccountClientTypes.Connection {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PartnerCentralAccountClientTypes.Connection()
        value.catalog = try reader["Catalog"].readIfPresent() ?? ""
        value.id = try reader["Id"].readIfPresent() ?? ""
        value.arn = try reader["Arn"].readIfPresent() ?? ""
        value.otherParticipantAccountId = try reader["OtherParticipantAccountId"].readIfPresent() ?? ""
        value.updatedAt = try reader["UpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.connectionTypes = try reader["ConnectionTypes"].readMapIfPresent(valueReadingClosure: PartnerCentralAccountClientTypes.ConnectionTypeDetail.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false) ?? [:]
        return value
    }
}

extension PartnerCentralAccountClientTypes.ConnectionTypeDetail {

    static func read(from reader: SmithyJSON.Reader) throws -> PartnerCentralAccountClientTypes.ConnectionTypeDetail {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PartnerCentralAccountClientTypes.ConnectionTypeDetail()
        value.createdAt = try reader["CreatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.inviterEmail = try reader["InviterEmail"].readIfPresent() ?? ""
        value.inviterName = try reader["InviterName"].readIfPresent() ?? ""
        value.status = try reader["Status"].readIfPresent() ?? .sdkUnknown("")
        value.canceledAt = try reader["CanceledAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.canceledBy = try reader["CanceledBy"].readIfPresent()
        value.otherParticipant = try reader["OtherParticipant"].readIfPresent(with: PartnerCentralAccountClientTypes.Participant.read(from:))
        return value
    }
}

extension PartnerCentralAccountClientTypes.Participant {

    static func read(from reader: SmithyJSON.Reader) throws -> PartnerCentralAccountClientTypes.Participant {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "PartnerProfile":
                return .partnerprofile(try reader["PartnerProfile"].read(with: PartnerCentralAccountClientTypes.PartnerProfileSummary.read(from:)))
            case "SellerProfile":
                return .sellerprofile(try reader["SellerProfile"].read(with: PartnerCentralAccountClientTypes.SellerProfileSummary.read(from:)))
            case "Account":
                return .account(try reader["Account"].read(with: PartnerCentralAccountClientTypes.AccountSummary.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension PartnerCentralAccountClientTypes.AccountSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> PartnerCentralAccountClientTypes.AccountSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PartnerCentralAccountClientTypes.AccountSummary()
        value.name = try reader["Name"].readIfPresent() ?? ""
        return value
    }
}

extension PartnerCentralAccountClientTypes.SellerProfileSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> PartnerCentralAccountClientTypes.SellerProfileSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PartnerCentralAccountClientTypes.SellerProfileSummary()
        value.id = try reader["Id"].readIfPresent() ?? ""
        value.name = try reader["Name"].readIfPresent() ?? ""
        return value
    }
}

extension PartnerCentralAccountClientTypes.PartnerProfileSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> PartnerCentralAccountClientTypes.PartnerProfileSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PartnerCentralAccountClientTypes.PartnerProfileSummary()
        value.id = try reader["Id"].readIfPresent() ?? ""
        value.name = try reader["Name"].readIfPresent() ?? ""
        return value
    }
}

extension PartnerCentralAccountClientTypes.TaskDetails {

    static func write(value: PartnerCentralAccountClientTypes.TaskDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Description"].write(value.description)
        try writer["DisplayName"].write(value.displayName)
        try writer["IndustrySegments"].writeList(value.industrySegments, memberWritingClosure: SmithyReadWrite.WritingClosureBox<PartnerCentralAccountClientTypes.IndustrySegment>().write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["LocalizedContents"].writeList(value.localizedContents, memberWritingClosure: PartnerCentralAccountClientTypes.LocalizedContent.write(value:to:), memberNodeInfo: "member", isFlattened: false)
        try writer["LogoUrl"].write(value.logoUrl)
        try writer["PrimarySolutionType"].write(value.primarySolutionType)
        try writer["TranslationSourceLocale"].write(value.translationSourceLocale)
        try writer["WebsiteUrl"].write(value.websiteUrl)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> PartnerCentralAccountClientTypes.TaskDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PartnerCentralAccountClientTypes.TaskDetails()
        value.displayName = try reader["DisplayName"].readIfPresent() ?? ""
        value.description = try reader["Description"].readIfPresent() ?? ""
        value.websiteUrl = try reader["WebsiteUrl"].readIfPresent() ?? ""
        value.logoUrl = try reader["LogoUrl"].readIfPresent() ?? ""
        value.primarySolutionType = try reader["PrimarySolutionType"].readIfPresent() ?? .sdkUnknown("")
        value.industrySegments = try reader["IndustrySegments"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<PartnerCentralAccountClientTypes.IndustrySegment>().read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.translationSourceLocale = try reader["TranslationSourceLocale"].readIfPresent() ?? ""
        value.localizedContents = try reader["LocalizedContents"].readListIfPresent(memberReadingClosure: PartnerCentralAccountClientTypes.LocalizedContent.read(from:), memberNodeInfo: "member", isFlattened: false)
        return value
    }
}

extension PartnerCentralAccountClientTypes.LocalizedContent {

    static func write(value: PartnerCentralAccountClientTypes.LocalizedContent?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Description"].write(value.description)
        try writer["DisplayName"].write(value.displayName)
        try writer["Locale"].write(value.locale)
        try writer["LogoUrl"].write(value.logoUrl)
        try writer["WebsiteUrl"].write(value.websiteUrl)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> PartnerCentralAccountClientTypes.LocalizedContent {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PartnerCentralAccountClientTypes.LocalizedContent()
        value.displayName = try reader["DisplayName"].readIfPresent() ?? ""
        value.description = try reader["Description"].readIfPresent() ?? ""
        value.websiteUrl = try reader["WebsiteUrl"].readIfPresent() ?? ""
        value.logoUrl = try reader["LogoUrl"].readIfPresent() ?? ""
        value.locale = try reader["Locale"].readIfPresent() ?? ""
        return value
    }
}

extension PartnerCentralAccountClientTypes.ErrorDetail {

    static func read(from reader: SmithyJSON.Reader) throws -> PartnerCentralAccountClientTypes.ErrorDetail {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PartnerCentralAccountClientTypes.ErrorDetail()
        value.locale = try reader["Locale"].readIfPresent() ?? ""
        value.message = try reader["Message"].readIfPresent() ?? ""
        value.reason = try reader["Reason"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension PartnerCentralAccountClientTypes.PartnerProfile {

    static func read(from reader: SmithyJSON.Reader) throws -> PartnerCentralAccountClientTypes.PartnerProfile {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PartnerCentralAccountClientTypes.PartnerProfile()
        value.displayName = try reader["DisplayName"].readIfPresent() ?? ""
        value.description = try reader["Description"].readIfPresent() ?? ""
        value.websiteUrl = try reader["WebsiteUrl"].readIfPresent() ?? ""
        value.logoUrl = try reader["LogoUrl"].readIfPresent() ?? ""
        value.primarySolutionType = try reader["PrimarySolutionType"].readIfPresent() ?? .sdkUnknown("")
        value.industrySegments = try reader["IndustrySegments"].readListIfPresent(memberReadingClosure: SmithyReadWrite.ReadingClosureBox<PartnerCentralAccountClientTypes.IndustrySegment>().read(from:), memberNodeInfo: "member", isFlattened: false) ?? []
        value.translationSourceLocale = try reader["TranslationSourceLocale"].readIfPresent() ?? ""
        value.localizedContents = try reader["LocalizedContents"].readListIfPresent(memberReadingClosure: PartnerCentralAccountClientTypes.LocalizedContent.read(from:), memberNodeInfo: "member", isFlattened: false)
        value.profileId = try reader["ProfileId"].readIfPresent()
        return value
    }
}

extension PartnerCentralAccountClientTypes.PartnerDomain {

    static func read(from reader: SmithyJSON.Reader) throws -> PartnerCentralAccountClientTypes.PartnerDomain {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PartnerCentralAccountClientTypes.PartnerDomain()
        value.domainName = try reader["DomainName"].readIfPresent() ?? ""
        value.registeredAt = try reader["RegisteredAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension PartnerCentralAccountClientTypes.AllianceLeadContact {

    static func write(value: PartnerCentralAccountClientTypes.AllianceLeadContact?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["BusinessTitle"].write(value.businessTitle)
        try writer["Email"].write(value.email)
        try writer["FirstName"].write(value.firstName)
        try writer["LastName"].write(value.lastName)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> PartnerCentralAccountClientTypes.AllianceLeadContact {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PartnerCentralAccountClientTypes.AllianceLeadContact()
        value.firstName = try reader["FirstName"].readIfPresent() ?? ""
        value.lastName = try reader["LastName"].readIfPresent() ?? ""
        value.email = try reader["Email"].readIfPresent() ?? ""
        value.businessTitle = try reader["BusinessTitle"].readIfPresent() ?? ""
        return value
    }
}

extension PartnerCentralAccountClientTypes.VerificationResponseDetails {

    static func read(from reader: SmithyJSON.Reader) throws -> PartnerCentralAccountClientTypes.VerificationResponseDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "BusinessVerificationResponse":
                return .businessverificationresponse(try reader["BusinessVerificationResponse"].read(with: PartnerCentralAccountClientTypes.BusinessVerificationResponse.read(from:)))
            case "RegistrantVerificationResponse":
                return .registrantverificationresponse(try reader["RegistrantVerificationResponse"].read(with: PartnerCentralAccountClientTypes.RegistrantVerificationResponse.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension PartnerCentralAccountClientTypes.RegistrantVerificationResponse {

    static func read(from reader: SmithyJSON.Reader) throws -> PartnerCentralAccountClientTypes.RegistrantVerificationResponse {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PartnerCentralAccountClientTypes.RegistrantVerificationResponse()
        value.completionUrl = try reader["CompletionUrl"].readIfPresent() ?? ""
        value.completionUrlExpiresAt = try reader["CompletionUrlExpiresAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension PartnerCentralAccountClientTypes.BusinessVerificationResponse {

    static func read(from reader: SmithyJSON.Reader) throws -> PartnerCentralAccountClientTypes.BusinessVerificationResponse {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PartnerCentralAccountClientTypes.BusinessVerificationResponse()
        value.businessVerificationDetails = try reader["BusinessVerificationDetails"].readIfPresent(with: PartnerCentralAccountClientTypes.BusinessVerificationDetails.read(from:))
        return value
    }
}

extension PartnerCentralAccountClientTypes.BusinessVerificationDetails {

    static func write(value: PartnerCentralAccountClientTypes.BusinessVerificationDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["CountryCode"].write(value.countryCode)
        try writer["JurisdictionOfIncorporation"].write(value.jurisdictionOfIncorporation)
        try writer["LegalName"].write(value.legalName)
        try writer["RegistrationId"].write(value.registrationId)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> PartnerCentralAccountClientTypes.BusinessVerificationDetails {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PartnerCentralAccountClientTypes.BusinessVerificationDetails()
        value.legalName = try reader["LegalName"].readIfPresent() ?? ""
        value.registrationId = try reader["RegistrationId"].readIfPresent() ?? ""
        value.countryCode = try reader["CountryCode"].readIfPresent() ?? ""
        value.jurisdictionOfIncorporation = try reader["JurisdictionOfIncorporation"].readIfPresent()
        return value
    }
}

extension PartnerCentralAccountClientTypes.ConnectionInvitationSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> PartnerCentralAccountClientTypes.ConnectionInvitationSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PartnerCentralAccountClientTypes.ConnectionInvitationSummary()
        value.catalog = try reader["Catalog"].readIfPresent() ?? ""
        value.id = try reader["Id"].readIfPresent() ?? ""
        value.arn = try reader["Arn"].readIfPresent() ?? ""
        value.connectionId = try reader["ConnectionId"].readIfPresent()
        value.connectionType = try reader["ConnectionType"].readIfPresent() ?? .sdkUnknown("")
        value.createdAt = try reader["CreatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.updatedAt = try reader["UpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.expiresAt = try reader["ExpiresAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime)
        value.otherParticipantIdentifier = try reader["OtherParticipantIdentifier"].readIfPresent() ?? ""
        value.participantType = try reader["ParticipantType"].readIfPresent() ?? .sdkUnknown("")
        value.status = try reader["Status"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension PartnerCentralAccountClientTypes.ConnectionSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> PartnerCentralAccountClientTypes.ConnectionSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PartnerCentralAccountClientTypes.ConnectionSummary()
        value.catalog = try reader["Catalog"].readIfPresent() ?? ""
        value.id = try reader["Id"].readIfPresent() ?? ""
        value.arn = try reader["Arn"].readIfPresent() ?? ""
        value.otherParticipantAccountId = try reader["OtherParticipantAccountId"].readIfPresent() ?? ""
        value.updatedAt = try reader["UpdatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        value.connectionTypes = try reader["ConnectionTypes"].readMapIfPresent(valueReadingClosure: PartnerCentralAccountClientTypes.ConnectionTypeSummary.read(from:), keyNodeInfo: "key", valueNodeInfo: "value", isFlattened: false) ?? [:]
        return value
    }
}

extension PartnerCentralAccountClientTypes.ConnectionTypeSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> PartnerCentralAccountClientTypes.ConnectionTypeSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PartnerCentralAccountClientTypes.ConnectionTypeSummary()
        value.status = try reader["Status"].readIfPresent() ?? .sdkUnknown("")
        value.otherParticipant = try reader["OtherParticipant"].readIfPresent(with: PartnerCentralAccountClientTypes.Participant.read(from:))
        return value
    }
}

extension PartnerCentralAccountClientTypes.PartnerSummary {

    static func read(from reader: SmithyJSON.Reader) throws -> PartnerCentralAccountClientTypes.PartnerSummary {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PartnerCentralAccountClientTypes.PartnerSummary()
        value.catalog = try reader["Catalog"].readIfPresent() ?? ""
        value.arn = try reader["Arn"].readIfPresent() ?? ""
        value.id = try reader["Id"].readIfPresent() ?? ""
        value.legalName = try reader["LegalName"].readIfPresent() ?? ""
        value.createdAt = try reader["CreatedAt"].readTimestampIfPresent(format: SmithyTimestamps.TimestampFormat.dateTime) ?? SmithyTimestamps.TimestampFormatter(format: .dateTime).date(from: "1970-01-01T00:00:00Z")
        return value
    }
}

extension PartnerCentralAccountClientTypes.Tag {

    static func write(value: PartnerCentralAccountClientTypes.Tag?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        try writer["Key"].write(value.key)
        try writer["Value"].write(value.value)
    }

    static func read(from reader: SmithyJSON.Reader) throws -> PartnerCentralAccountClientTypes.Tag {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PartnerCentralAccountClientTypes.Tag()
        value.key = try reader["Key"].readIfPresent() ?? ""
        value.value = try reader["Value"].readIfPresent() ?? ""
        return value
    }
}

extension PartnerCentralAccountClientTypes.ValidationError {

    static func read(from reader: SmithyJSON.Reader) throws -> PartnerCentralAccountClientTypes.ValidationError {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        let name = reader.children.filter { $0.hasContent && $0.nodeInfo.name != "__type" }.first?.nodeInfo.name
        switch name {
            case "FieldValidationError":
                return .fieldvalidationerror(try reader["FieldValidationError"].read(with: PartnerCentralAccountClientTypes.FieldValidationError.read(from:)))
            case "BusinessValidationError":
                return .businessvalidationerror(try reader["BusinessValidationError"].read(with: PartnerCentralAccountClientTypes.BusinessValidationError.read(from:)))
            default:
                return .sdkUnknown(name ?? "")
        }
    }
}

extension PartnerCentralAccountClientTypes.BusinessValidationError {

    static func read(from reader: SmithyJSON.Reader) throws -> PartnerCentralAccountClientTypes.BusinessValidationError {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PartnerCentralAccountClientTypes.BusinessValidationError()
        value.message = try reader["Message"].readIfPresent() ?? ""
        value.code = try reader["Code"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension PartnerCentralAccountClientTypes.FieldValidationError {

    static func read(from reader: SmithyJSON.Reader) throws -> PartnerCentralAccountClientTypes.FieldValidationError {
        guard reader.hasContent else { throw SmithyReadWrite.ReaderError.requiredValueNotPresent }
        var value = PartnerCentralAccountClientTypes.FieldValidationError()
        value.name = try reader["Name"].readIfPresent() ?? ""
        value.message = try reader["Message"].readIfPresent() ?? ""
        value.code = try reader["Code"].readIfPresent() ?? .sdkUnknown("")
        return value
    }
}

extension PartnerCentralAccountClientTypes.VerificationDetails {

    static func write(value: PartnerCentralAccountClientTypes.VerificationDetails?, to writer: SmithyJSON.Writer) throws {
        guard let value else { return }
        switch value {
            case let .businessverificationdetails(businessverificationdetails):
                try writer["BusinessVerificationDetails"].write(businessverificationdetails, with: PartnerCentralAccountClientTypes.BusinessVerificationDetails.write(value:to:))
            case let .registrantverificationdetails(registrantverificationdetails):
                try writer["RegistrantVerificationDetails"].write(registrantverificationdetails, with: PartnerCentralAccountClientTypes.RegistrantVerificationDetails.write(value:to:))
            case let .sdkUnknown(sdkUnknown):
                try writer["sdkUnknown"].write(sdkUnknown)
        }
    }
}

extension PartnerCentralAccountClientTypes.RegistrantVerificationDetails {

    static func write(value: PartnerCentralAccountClientTypes.RegistrantVerificationDetails?, to writer: SmithyJSON.Writer) throws {
        guard value != nil else { return }
        _ = writer[""]  // create an empty structure
    }
}

public enum PartnerCentralAccountClientTypes {}
