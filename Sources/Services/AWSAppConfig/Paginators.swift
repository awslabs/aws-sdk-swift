// Code generated by smithy-swift-codegen. DO NOT EDIT!

import ClientRuntime

extension AppConfigClient {
    /// Paginate over `[ListApplicationsOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListApplicationsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListApplicationsOutputResponse`
    public func listApplicationsPaginated(input: ListApplicationsInput) -> ClientRuntime.PaginatorSequence<ListApplicationsInput, ListApplicationsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListApplicationsInput, ListApplicationsOutputResponse>(input: input, inputKey: \ListApplicationsInput.nextToken, outputKey: \ListApplicationsOutputResponse.nextToken, paginationFunction: self.listApplications(input:))
    }
}

extension ListApplicationsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListApplicationsInput {
        return ListApplicationsInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where Input == ListApplicationsInput, Output == ListApplicationsOutputResponse {
    /// This paginator transforms the `AsyncSequence` returned by `listApplicationsPaginated`
    /// to access the nested member `[AppConfigClientTypes.Application]`
    /// - Returns: `[AppConfigClientTypes.Application]`
    public func items() async throws -> [AppConfigClientTypes.Application] {
        return try await self.asyncCompactMap { item in item.items }
    }
}
extension AppConfigClient {
    /// Paginate over `[ListConfigurationProfilesOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListConfigurationProfilesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListConfigurationProfilesOutputResponse`
    public func listConfigurationProfilesPaginated(input: ListConfigurationProfilesInput) -> ClientRuntime.PaginatorSequence<ListConfigurationProfilesInput, ListConfigurationProfilesOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListConfigurationProfilesInput, ListConfigurationProfilesOutputResponse>(input: input, inputKey: \ListConfigurationProfilesInput.nextToken, outputKey: \ListConfigurationProfilesOutputResponse.nextToken, paginationFunction: self.listConfigurationProfiles(input:))
    }
}

extension ListConfigurationProfilesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListConfigurationProfilesInput {
        return ListConfigurationProfilesInput(
            applicationId: self.applicationId,
            maxResults: self.maxResults,
            nextToken: token,
            type: self.type
        )}
}

extension PaginatorSequence where Input == ListConfigurationProfilesInput, Output == ListConfigurationProfilesOutputResponse {
    /// This paginator transforms the `AsyncSequence` returned by `listConfigurationProfilesPaginated`
    /// to access the nested member `[AppConfigClientTypes.ConfigurationProfileSummary]`
    /// - Returns: `[AppConfigClientTypes.ConfigurationProfileSummary]`
    public func items() async throws -> [AppConfigClientTypes.ConfigurationProfileSummary] {
        return try await self.asyncCompactMap { item in item.items }
    }
}
extension AppConfigClient {
    /// Paginate over `[ListDeploymentsOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListDeploymentsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListDeploymentsOutputResponse`
    public func listDeploymentsPaginated(input: ListDeploymentsInput) -> ClientRuntime.PaginatorSequence<ListDeploymentsInput, ListDeploymentsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListDeploymentsInput, ListDeploymentsOutputResponse>(input: input, inputKey: \ListDeploymentsInput.nextToken, outputKey: \ListDeploymentsOutputResponse.nextToken, paginationFunction: self.listDeployments(input:))
    }
}

extension ListDeploymentsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListDeploymentsInput {
        return ListDeploymentsInput(
            applicationId: self.applicationId,
            environmentId: self.environmentId,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where Input == ListDeploymentsInput, Output == ListDeploymentsOutputResponse {
    /// This paginator transforms the `AsyncSequence` returned by `listDeploymentsPaginated`
    /// to access the nested member `[AppConfigClientTypes.DeploymentSummary]`
    /// - Returns: `[AppConfigClientTypes.DeploymentSummary]`
    public func items() async throws -> [AppConfigClientTypes.DeploymentSummary] {
        return try await self.asyncCompactMap { item in item.items }
    }
}
extension AppConfigClient {
    /// Paginate over `[ListDeploymentStrategiesOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListDeploymentStrategiesInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListDeploymentStrategiesOutputResponse`
    public func listDeploymentStrategiesPaginated(input: ListDeploymentStrategiesInput) -> ClientRuntime.PaginatorSequence<ListDeploymentStrategiesInput, ListDeploymentStrategiesOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListDeploymentStrategiesInput, ListDeploymentStrategiesOutputResponse>(input: input, inputKey: \ListDeploymentStrategiesInput.nextToken, outputKey: \ListDeploymentStrategiesOutputResponse.nextToken, paginationFunction: self.listDeploymentStrategies(input:))
    }
}

extension ListDeploymentStrategiesInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListDeploymentStrategiesInput {
        return ListDeploymentStrategiesInput(
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where Input == ListDeploymentStrategiesInput, Output == ListDeploymentStrategiesOutputResponse {
    /// This paginator transforms the `AsyncSequence` returned by `listDeploymentStrategiesPaginated`
    /// to access the nested member `[AppConfigClientTypes.DeploymentStrategy]`
    /// - Returns: `[AppConfigClientTypes.DeploymentStrategy]`
    public func items() async throws -> [AppConfigClientTypes.DeploymentStrategy] {
        return try await self.asyncCompactMap { item in item.items }
    }
}
extension AppConfigClient {
    /// Paginate over `[ListEnvironmentsOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListEnvironmentsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListEnvironmentsOutputResponse`
    public func listEnvironmentsPaginated(input: ListEnvironmentsInput) -> ClientRuntime.PaginatorSequence<ListEnvironmentsInput, ListEnvironmentsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListEnvironmentsInput, ListEnvironmentsOutputResponse>(input: input, inputKey: \ListEnvironmentsInput.nextToken, outputKey: \ListEnvironmentsOutputResponse.nextToken, paginationFunction: self.listEnvironments(input:))
    }
}

extension ListEnvironmentsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListEnvironmentsInput {
        return ListEnvironmentsInput(
            applicationId: self.applicationId,
            maxResults: self.maxResults,
            nextToken: token
        )}
}

extension PaginatorSequence where Input == ListEnvironmentsInput, Output == ListEnvironmentsOutputResponse {
    /// This paginator transforms the `AsyncSequence` returned by `listEnvironmentsPaginated`
    /// to access the nested member `[AppConfigClientTypes.Environment]`
    /// - Returns: `[AppConfigClientTypes.Environment]`
    public func items() async throws -> [AppConfigClientTypes.Environment] {
        return try await self.asyncCompactMap { item in item.items }
    }
}
extension AppConfigClient {
    /// Paginate over `[ListExtensionAssociationsOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListExtensionAssociationsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListExtensionAssociationsOutputResponse`
    public func listExtensionAssociationsPaginated(input: ListExtensionAssociationsInput) -> ClientRuntime.PaginatorSequence<ListExtensionAssociationsInput, ListExtensionAssociationsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListExtensionAssociationsInput, ListExtensionAssociationsOutputResponse>(input: input, inputKey: \ListExtensionAssociationsInput.nextToken, outputKey: \ListExtensionAssociationsOutputResponse.nextToken, paginationFunction: self.listExtensionAssociations(input:))
    }
}

extension ListExtensionAssociationsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListExtensionAssociationsInput {
        return ListExtensionAssociationsInput(
            extensionIdentifier: self.extensionIdentifier,
            extensionVersionNumber: self.extensionVersionNumber,
            maxResults: self.maxResults,
            nextToken: token,
            resourceIdentifier: self.resourceIdentifier
        )}
}

extension PaginatorSequence where Input == ListExtensionAssociationsInput, Output == ListExtensionAssociationsOutputResponse {
    /// This paginator transforms the `AsyncSequence` returned by `listExtensionAssociationsPaginated`
    /// to access the nested member `[AppConfigClientTypes.ExtensionAssociationSummary]`
    /// - Returns: `[AppConfigClientTypes.ExtensionAssociationSummary]`
    public func items() async throws -> [AppConfigClientTypes.ExtensionAssociationSummary] {
        return try await self.asyncCompactMap { item in item.items }
    }
}
extension AppConfigClient {
    /// Paginate over `[ListExtensionsOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListExtensionsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListExtensionsOutputResponse`
    public func listExtensionsPaginated(input: ListExtensionsInput) -> ClientRuntime.PaginatorSequence<ListExtensionsInput, ListExtensionsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListExtensionsInput, ListExtensionsOutputResponse>(input: input, inputKey: \ListExtensionsInput.nextToken, outputKey: \ListExtensionsOutputResponse.nextToken, paginationFunction: self.listExtensions(input:))
    }
}

extension ListExtensionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListExtensionsInput {
        return ListExtensionsInput(
            maxResults: self.maxResults,
            name: self.name,
            nextToken: token
        )}
}

extension PaginatorSequence where Input == ListExtensionsInput, Output == ListExtensionsOutputResponse {
    /// This paginator transforms the `AsyncSequence` returned by `listExtensionsPaginated`
    /// to access the nested member `[AppConfigClientTypes.ExtensionSummary]`
    /// - Returns: `[AppConfigClientTypes.ExtensionSummary]`
    public func items() async throws -> [AppConfigClientTypes.ExtensionSummary] {
        return try await self.asyncCompactMap { item in item.items }
    }
}
extension AppConfigClient {
    /// Paginate over `[ListHostedConfigurationVersionsOutputResponse]` results.
    ///
    /// When this operation is called, an `AsyncSequence` is created. AsyncSequences are lazy so no service
    /// calls are made until the sequence is iterated over. This also means there is no guarantee that the request is valid
    /// until then. If there are errors in your request, you will see the failures only after you start iterating.
    /// - Parameters:
    ///     - input: A `[ListHostedConfigurationVersionsInput]` to start pagination
    /// - Returns: An `AsyncSequence` that can iterate over `ListHostedConfigurationVersionsOutputResponse`
    public func listHostedConfigurationVersionsPaginated(input: ListHostedConfigurationVersionsInput) -> ClientRuntime.PaginatorSequence<ListHostedConfigurationVersionsInput, ListHostedConfigurationVersionsOutputResponse> {
        return ClientRuntime.PaginatorSequence<ListHostedConfigurationVersionsInput, ListHostedConfigurationVersionsOutputResponse>(input: input, inputKey: \ListHostedConfigurationVersionsInput.nextToken, outputKey: \ListHostedConfigurationVersionsOutputResponse.nextToken, paginationFunction: self.listHostedConfigurationVersions(input:))
    }
}

extension ListHostedConfigurationVersionsInput: ClientRuntime.PaginateToken {
    public func usingPaginationToken(_ token: Swift.String) -> ListHostedConfigurationVersionsInput {
        return ListHostedConfigurationVersionsInput(
            applicationId: self.applicationId,
            configurationProfileId: self.configurationProfileId,
            maxResults: self.maxResults,
            nextToken: token,
            versionLabel: self.versionLabel
        )}
}

extension PaginatorSequence where Input == ListHostedConfigurationVersionsInput, Output == ListHostedConfigurationVersionsOutputResponse {
    /// This paginator transforms the `AsyncSequence` returned by `listHostedConfigurationVersionsPaginated`
    /// to access the nested member `[AppConfigClientTypes.HostedConfigurationVersionSummary]`
    /// - Returns: `[AppConfigClientTypes.HostedConfigurationVersionSummary]`
    public func items() async throws -> [AppConfigClientTypes.HostedConfigurationVersionSummary] {
        return try await self.asyncCompactMap { item in item.items }
    }
}
